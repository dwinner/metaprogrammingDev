/*@@includes:*/
includes
{
//Jen's email 05.03.2013
#pragma library ("..\..\..\BAP170.dll")

}
/*@@end*/

/*@@var:*/
variables
{

	//@BAPSIMGEN_VAR_SECTION_BEGIN

	/***************************************************/
	/*            BapSimGen FSG template               */
	/***************************************************/

	/************** Ausgabe Konsole (Traces) ***********/
	dword gBAP_Trace;
	dword gError_Trace;

	/************** Node Verwaltung ***************/
	//Power on/off
	byte gSG_PowerOnOff=0x01;     // wird mit Power_off/on gesetzt
	byte gBAP_Init=0;             // schon mal initialisiert?

	const Power_off = 0x00;	
	const Power_on	= 0x01;

	mstimer TaskTimer;				//real communication timer

	/************** Request **************/
	const Requestbuffer_lines = 100;
	const BAP_buffer_size = 4096;

	/************ Speichern von Requests im "Ringbuffer" ***********/
	int   gBAP_Requestbuffer_status	[Requestbuffer_lines];		             // 0: kein Eintrag, 1: pending
	dword gBAP_Request_header		[Requestbuffer_lines] [6];				 // beinhaltet auch skalare Daten
	dword gBAP_Request_data         [Requestbuffer_lines] [BAP_buffer_size]; // Ringbuffer fuer BAP-Request


	/************** Indication **************/
	// enthaelt die derzeitige Indication
	dword gBAP_Indication_header[6];	
	byte  gBAP_Indication_data[BAP_buffer_size];		

	/************** Konstanten ****************/

	//BAP Data Type 
	const Bap_void				=0;
	const Bap_uint8				=1;
	const Bap_uint16			=2;
	const Bap_uint32			=3;
	const Bap_byteSequence		=4;
    const Bap_fixedByteSequence =4;
    const Bap_error				=5;
    const Bap_acknowledge		=6;

	char Datatype_Text[7][20] =
	{
		"void", "uint8", "uint16", "uint32", "byteSequence", "error", "acknowledge"
	};
	
	//BAP request types
	const DataSetGet_REQ	= 0x00;
	const DataSet_REQ		= 0x01;
	const DataGet_REQ		= 0x02;
	const Data_REQ			= 0x03;
	const Changed_REQ		= 0x04;
	const Start_REQ			= 0x05;
	const StartResult_REQ	= 0x06;
	const AbortResult_REQ	= 0x07;
	const Processing_REQ	= 0x08;
	const Result_REQ		= 0x09;
	const DataAck_REQ       = 0x0A;
	const Ack_REQ           = 0x0B;
	const Invalid_REQ    	= 0x1F; // Kennzeichnung fuer einen ungueltigen Request
	const Error_REQ         = 0x20;

	char Requesttype_Text[33][30] =
	{
		"DataSetGet_REQ", "DataSet_REQ", "DataGet_REQ", "Data_REQ",			/* 00 .. 03 */
		"Changed_REQ", "Start_REQ", "StartResult_REQ", "AbortResult_REQ",   /* 04 .. 07 */
		"Processing_REQ", "Result_REQ", "DataAck_REQ", "Ack_REQ", 		/* 08 .. 0b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 0c .. 0f */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 10 .. 13 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 14 .. 17 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", 		/* 18 .. 1b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 1c .. 1f */
		"Error_REQ"	  														/* 20 */
	};
	
	//BAP indication types
	const Data_IND				= 0x00;
	const Reset_IND				= 0x01;
	const DataAck_IND			= 0x02;
	const Result_IND			= 0x03;
	const Processing_IND	    = 0x04;
	const Changed_IND			= 0x05;
	const DataSetGet_IND	    = 0x06;
	const DataSet_IND			= 0x07;
	const DataGet_IND			= 0x08;
	const Ack_IND				= 0x09;
	const Processing_CNF_IND	= 0x0A;
	const Start_IND				= 0x0B;
	const StartResult_IND		= 0x0C;
	const AbortResult_IND		= 0x0D;
	const Invalid_IND			= 0x1F; // Kennzeichnung fuer eine ungueltige Indication
	const Error_IND             = 0x20;

	char Indicationtype_Text[33][30] =
	{
		"Data_IND", "Reset_IND", "DataAck_IND", "Result_IND",				/* 00 .. 03 */
		"Processing_IND", "Changed_IND", "DataSetGet_IND", "DataSet_IND",	/* 04 .. 07 */
		"DataGet_IND", "Ack_IND", "Processing_CNF_IND", "Start_REQ",		/* 08 .. 0b */
		"StartResult_REQ", "AbortResult_REQ", "Invalid_REQ", "Invalid_REQ", /* 0c .. 0f */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 10 .. 13 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 14 .. 17 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 18 .. 1b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 1c .. 1f */
		"Error_REQ"	  														/* 20 */
	};	
	
	char Acknowledgetype_Text[24][30] =
	{
		"Property_SetGet_ACK", "Array_SetGet_ACK", "Property_Set_ACK", "Array_Set_ACK",				/* 00 .. 03 */
		"Method_Start_ACK", "Method_StartResult_ACK", "Method_AbortResult_ACK", "Property_Get_ACK",	/* 04 .. 07 */
		"Array_Get_ACK", "Cache_GetAll_ACK", "Property_Ack_ACK", "Property_Status_ACK",	   			/* 08 .. 0b */
		"Property_StatusAck_ACK", "Property_Error_ACK", "Array_Status_ACK", "Array_Changed_ACK",	/* 0c .. 0f */
		"Array_Error_ACK", "Method_Processing_ACK", "Method_Result_ACK", "Method_Error_ACK",  		/* 10 .. 13 */
		"Unknown_ACK", "Unknown_ACK", "Unknown_ACK", "Unknown_ACK"									/* 14 .. 17 */
	};

	/**************************** Global Function-ID's ******************************/

	byte already_pressed = 0;

	const FctID_GetAll									= 0x01;
	const FctID_BAP_Config								= 0x02;
	const FctID_FunctionList							= 0x03;
	const FctID_HeartBeat								= 0x04;
    
    char SGtype[4]="FSG";


	//// Begin: konfigurationsabhýngige Variablen, die als BAPCONFIG_VARS in Template definiert sind
	
	char  dbc_path[255]             = "BAP\\_DBC\\BAP_only_MQB_MLBevo_v1.50.dbc";
	char  xml_path[255]             = "BAP\\BAP-SIM_Wiper_Comfort_P30DF32_V1.20\\fsg12\\bapxml\\BAP_SW17_Wiper_FSG_v1.20.xml";
	dword NODE_INDEX                =  0;
	char  NODE_NAME[100]            = "Wiper_Comfort";
	const LSGID                     = 12;
	char  panel_name[100]           = "FSG12_0";
	char  bapconfig_panel_name[100]    = "panel1";
	char  common_panel_name[100]    = "panel2";
	const TaskTime                  = 10;
	 const C_FSG_12_0_0_1_ID = 1;
	 char gCheckbox1[100] = "checkbox_C_FSG_12_0_0_1";
	 char gErrField1[100] = "errfield_C_FSG_12_0_0_1";
	 byte gC_FSG_12_0_0_1_ErrCode = 1;
	 const P_FSG_12_0_0_2_ID = 2;
	 byte P_FSG_12_0_0_2Reset_BTN_already_pressed = 0;
	 char gCheckbox2[100] = "checkbox_P_FSG_12_0_0_2";
	 char gErrField2[100] = "errfield_P_FSG_12_0_0_2";
	 byte gP_FSG_12_0_0_2_ErrCode = 1;
	 const P_FSG_12_0_0_3_ID = 3;
	 byte P_FSG_12_0_0_3Status_BTN_already_pressed = 0;
	 char gCheckbox3[100] = "checkbox_P_FSG_12_0_0_3";
	 char gErrField3[100] = "errfield_P_FSG_12_0_0_3";
	 byte gP_FSG_12_0_0_3_ErrCode = 1;
	 const P_FSG_12_0_0_4_ID = 4;
	 byte P_FSG_12_0_0_4Status_BTN_already_pressed = 0;
	 char gCheckbox4[100] = "checkbox_P_FSG_12_0_0_4";
	 char gErrField4[100] = "errfield_P_FSG_12_0_0_4";
	 byte gP_FSG_12_0_0_4_ErrCode = 1;
	 const P_FSG_12_0_0_13_ID = 13;
	 byte P_FSG_12_0_0_13Status_BTN_already_pressed = 0;
	 char gCheckbox13[100] = "checkbox_P_FSG_12_0_0_13";
	 char gErrField13[100] = "errfield_P_FSG_12_0_0_13";
	 byte gP_FSG_12_0_0_13_ErrCode = 1;
	 char gPanel13[100] = "panel_P_FSG_12_0_0_13";
	 const P_FSG_12_0_0_15_ID = 15;
	 byte P_FSG_12_0_0_15Status_BTN_already_pressed = 0;
	 char gCheckbox15[100] = "checkbox_P_FSG_12_0_0_15";
	 char gErrField15[100] = "errfield_P_FSG_12_0_0_15";
	 byte gP_FSG_12_0_0_15_ErrCode = 1;
	 char gPanel15[100] = "panel_P_FSG_12_0_0_15";
	 const P_FSG_12_0_0_16_ID = 16;
	 byte P_FSG_12_0_0_16Status_BTN_already_pressed = 0;
	 char gCheckbox16[100] = "checkbox_P_FSG_12_0_0_16";
	 char gErrField16[100] = "errfield_P_FSG_12_0_0_16";
	 byte gP_FSG_12_0_0_16_ErrCode = 1;
	 char gPanel16[100] = "panel_P_FSG_12_0_0_16";
	 const P_FSG_12_0_0_17_ID = 17;
	 byte P_FSG_12_0_0_17Status_BTN_already_pressed = 0;
	 char gCheckbox17[100] = "checkbox_P_FSG_12_0_0_17";
	 char gErrField17[100] = "errfield_P_FSG_12_0_0_17";
	 byte gP_FSG_12_0_0_17_ErrCode = 1;
	 char gPanel17[100] = "panel_P_FSG_12_0_0_17";
	 const P_FSG_12_0_0_18_ID = 18;
	 byte P_FSG_12_0_0_18Status_BTN_already_pressed = 0;
	 char gCheckbox18[100] = "checkbox_P_FSG_12_0_0_18";
	 char gErrField18[100] = "errfield_P_FSG_12_0_0_18";
	 byte gP_FSG_12_0_0_18_ErrCode = 1;
	 char gPanel18[100] = "panel_P_FSG_12_0_0_18";
	 const P_FSG_12_0_0_19_ID = 19;
	 byte P_FSG_12_0_0_19Status_BTN_already_pressed = 0;
	 char gCheckbox19[100] = "checkbox_P_FSG_12_0_0_19";
	 char gErrField19[100] = "errfield_P_FSG_12_0_0_19";
	 byte gP_FSG_12_0_0_19_ErrCode = 1;
	 char gPanel19[100] = "panel_P_FSG_12_0_0_19";
	 const P_FSG_12_0_0_20_ID = 20;
	 byte P_FSG_12_0_0_20Status_BTN_already_pressed = 0;
	 char gCheckbox20[100] = "checkbox_P_FSG_12_0_0_20";
	 char gErrField20[100] = "errfield_P_FSG_12_0_0_20";
	 byte gP_FSG_12_0_0_20_ErrCode = 1;
	 char gPanel20[100] = "panel_P_FSG_12_0_0_20";
	 const P_FSG_12_0_0_21_ID = 21;
	 byte P_FSG_12_0_0_21Status_BTN_already_pressed = 0;
	 char gCheckbox21[100] = "checkbox_P_FSG_12_0_0_21";
	 char gErrField21[100] = "errfield_P_FSG_12_0_0_21";
	 byte gP_FSG_12_0_0_21_ErrCode = 1;
	 char gPanel21[100] = "panel_P_FSG_12_0_0_21";
	 const P_FSG_12_0_0_22_ID = 22;
	 byte P_FSG_12_0_0_22Status_BTN_already_pressed = 0;
	 char gCheckbox22[100] = "checkbox_P_FSG_12_0_0_22";
	 char gErrField22[100] = "errfield_P_FSG_12_0_0_22";
	 byte gP_FSG_12_0_0_22_ErrCode = 1;
	 char gPanel22[100] = "panel_P_FSG_12_0_0_22";
	 const P_FSG_12_0_0_23_ID = 23;
	 byte P_FSG_12_0_0_23Status_BTN_already_pressed = 0;
	 char gCheckbox23[100] = "checkbox_P_FSG_12_0_0_23";
	 char gErrField23[100] = "errfield_P_FSG_12_0_0_23";
	 byte gP_FSG_12_0_0_23_ErrCode = 1;
	 char gPanel23[100] = "panel_P_FSG_12_0_0_23";


	//// End konfigurationsabhýngige Variablen 
	
	/// Begin: Definition der BUS-Schnittstellen
	
	// FLEXRAY NOT ENABLED!
	
	// ETHERNET NOT ENABLED! 
	
	//// End Bus Schnittstellen

}
/*@@end*/

/*@@preStart:PreStart:*/
on preStart
{
    /***** Erzeugen der Ausgabeconsolen *****/  
    gBAP_Trace=writecreate("BAP-Trace");        //write-window for BAP-cummunication
    writeclear(gBAP_Trace);                     //clear BAP-window in write-window
    
    gError_Trace=writecreate("Error");          //error-window for BAP-cummunication
    writeclear(gError_Trace);                   //clear error-window in write-window
    
    writeclear(1);                              //clear CAPL-window in write-window

	// MWN 2016-05-27
    
    // FLEXRAY NOT ENABLED!
}
/*@@end*/

/*@@caplFunc:DisableFctCtrl():*/
DisableFctCtrl ()
{
  	EnableControl(panel_name, common_panel_name, 0);
	EnableControl(panel_name,gErrField1,0);
	EnableControl(panel_name,gErrField2,0);
	EnableControl(panel_name,gErrField3,0);
	EnableControl(panel_name,gErrField4,0);
	EnableControl(panel_name,gErrField13,0);
	EnableControl(panel_name,gPanel13,0);
	EnableControl(panel_name,"panel_P_FSG_12_0_0_13",0);
	EnableControl(panel_name,gErrField15,0);
	EnableControl(panel_name,gPanel15,0);
	EnableControl(panel_name,"panel_P_FSG_12_0_0_15",0);
	EnableControl(panel_name,gErrField16,0);
	EnableControl(panel_name,gPanel16,0);
	EnableControl(panel_name,"panel_P_FSG_12_0_0_16",0);
	EnableControl(panel_name,gErrField17,0);
	EnableControl(panel_name,gPanel17,0);
	EnableControl(panel_name,"panel_P_FSG_12_0_0_17",0);
	EnableControl(panel_name,gErrField18,0);
	EnableControl(panel_name,gPanel18,0);
	EnableControl(panel_name,"panel_P_FSG_12_0_0_18",0);
	EnableControl(panel_name,gErrField19,0);
	EnableControl(panel_name,gPanel19,0);
	EnableControl(panel_name,"panel_P_FSG_12_0_0_19",0);
	EnableControl(panel_name,gErrField20,0);
	EnableControl(panel_name,gPanel20,0);
	EnableControl(panel_name,"panel_P_FSG_12_0_0_20",0);
	EnableControl(panel_name,gErrField21,0);
	EnableControl(panel_name,gPanel21,0);
	EnableControl(panel_name,"panel_P_FSG_12_0_0_21",0);
	EnableControl(panel_name,gErrField22,0);
	EnableControl(panel_name,gPanel22,0);
	EnableControl(panel_name,"panel_P_FSG_12_0_0_22",0);
	EnableControl(panel_name,gErrField23,0);
	EnableControl(panel_name,gPanel23,0);
	EnableControl(panel_name,"panel_P_FSG_12_0_0_23",0);

}
/*@@end*/

/*@@caplFunc:EnableFctCtrl():*/
EnableFctCtrl ()
{
  	EnableControl(panel_name, common_panel_name, 1);
	if(getValue(P_FSG_12_0_0_13_FctLstItemEn)){
		 EnableControl(panel_name,gPanel13,1);
		 EnableControl(panel_name,gErrField13,1);
	}
	if(getValue(P_FSG_12_0_0_15_FctLstItemEn)){
		 EnableControl(panel_name,gPanel15,1);
		 EnableControl(panel_name,gErrField15,1);
	}
	if(getValue(P_FSG_12_0_0_16_FctLstItemEn)){
		 EnableControl(panel_name,gPanel16,1);
		 EnableControl(panel_name,gErrField16,1);
	}
	if(getValue(P_FSG_12_0_0_17_FctLstItemEn)){
		 EnableControl(panel_name,gPanel17,1);
		 EnableControl(panel_name,gErrField17,1);
	}
	if(getValue(P_FSG_12_0_0_18_FctLstItemEn)){
		 EnableControl(panel_name,gPanel18,1);
		 EnableControl(panel_name,gErrField18,1);
	}
	if(getValue(P_FSG_12_0_0_19_FctLstItemEn)){
		 EnableControl(panel_name,gPanel19,1);
		 EnableControl(panel_name,gErrField19,1);
	}
	if(getValue(P_FSG_12_0_0_20_FctLstItemEn)){
		 EnableControl(panel_name,gPanel20,1);
		 EnableControl(panel_name,gErrField20,1);
	}
	if(getValue(P_FSG_12_0_0_21_FctLstItemEn)){
		 EnableControl(panel_name,gPanel21,1);
		 EnableControl(panel_name,gErrField21,1);
	}
	if(getValue(P_FSG_12_0_0_22_FctLstItemEn)){
		 EnableControl(panel_name,gPanel22,1);
		 EnableControl(panel_name,gErrField22,1);
	}
	if(getValue(P_FSG_12_0_0_23_FctLstItemEn)){
		 EnableControl(panel_name,gPanel23,1);
		 EnableControl(panel_name,gErrField23,1);
	}

}
/*@@end*/

/*@@caplFunc:DisableConfigCtrl():*/
DisableConfigCtrl ()
{
  	EnableControl(panel_name, bapconfig_panel_name, 0);
	EnableControl(panel_name, "panel1_edit", 0);
//	EnableControl(panel_name,gCheckbox1,0);
//	if(!getValue(C_FSG_12_0_0_1_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox1,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox2,0);
//	if(!getValue(P_FSG_12_0_0_2_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox2,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox3,0);
//	if(!getValue(P_FSG_12_0_0_3_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox3,MakeRGB(200,200,200));
//	}
	EnableControl(panel_name, "panel_P_FSG_12_0_0_4", 0);
//	EnableControl(panel_name,gCheckbox4,0);
//	if(!getValue(P_FSG_12_0_0_4_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox4,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox13,0);
//	if(!getValue(P_FSG_12_0_0_13_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox13,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox15,0);
//	if(!getValue(P_FSG_12_0_0_15_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox15,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox16,0);
//	if(!getValue(P_FSG_12_0_0_16_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox16,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox17,0);
//	if(!getValue(P_FSG_12_0_0_17_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox17,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox18,0);
//	if(!getValue(P_FSG_12_0_0_18_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox18,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox19,0);
//	if(!getValue(P_FSG_12_0_0_19_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox19,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox20,0);
//	if(!getValue(P_FSG_12_0_0_20_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox20,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox21,0);
//	if(!getValue(P_FSG_12_0_0_21_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox21,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox22,0);
//	if(!getValue(P_FSG_12_0_0_22_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox22,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox23,0);
//	if(!getValue(P_FSG_12_0_0_23_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox23,MakeRGB(200,200,200));
//	}

}
/*@@end*/

/*@@caplFunc:EnableConfigCtrl():*/
EnableConfigCtrl ()
{
  	EnableControl(panel_name, bapconfig_panel_name, 1);
	EnableControl(panel_name, "panel1_edit", 1);
	if(getValue(C_FSG_12_0_0_1_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox1, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox1, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_2_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox2, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox2, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_3_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox3, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox3, MakeRGB(250,0,0));
	}
	EnableControl(panel_name, "panel_P_FSG_12_0_0_4", 1);
	if(getValue(P_FSG_12_0_0_4_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox4, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox4, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_13_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_13",1);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_13",1);
		setControlForeColor(panel_name, gCheckbox13, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_13",0);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_13",0);
		setControlForeColor(panel_name, gCheckbox13, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_15_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_15",1);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_15",1);
		setControlForeColor(panel_name, gCheckbox15, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_15",0);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_15",0);
		setControlForeColor(panel_name, gCheckbox15, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_16_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_16",1);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_16",1);
		setControlForeColor(panel_name, gCheckbox16, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_16",0);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_16",0);
		setControlForeColor(panel_name, gCheckbox16, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_17_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_17",1);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_17",1);
		setControlForeColor(panel_name, gCheckbox17, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_17",0);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_17",0);
		setControlForeColor(panel_name, gCheckbox17, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_18_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_18",1);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_18",1);
		setControlForeColor(panel_name, gCheckbox18, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_18",0);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_18",0);
		setControlForeColor(panel_name, gCheckbox18, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_19_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_19",1);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_19",1);
		setControlForeColor(panel_name, gCheckbox19, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_19",0);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_19",0);
		setControlForeColor(panel_name, gCheckbox19, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_20_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_20",1);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_20",1);
		setControlForeColor(panel_name, gCheckbox20, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_20",0);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_20",0);
		setControlForeColor(panel_name, gCheckbox20, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_21_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_21",1);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_21",1);
		setControlForeColor(panel_name, gCheckbox21, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_21",0);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_21",0);
		setControlForeColor(panel_name, gCheckbox21, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_22_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_22",1);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_22",1);
		setControlForeColor(panel_name, gCheckbox22, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_22",0);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_22",0);
		setControlForeColor(panel_name, gCheckbox22, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_12_0_0_23_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_23",1);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_23",1);
		setControlForeColor(panel_name, gCheckbox23, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_12_0_0_23",0);
		EnableControl(panel_name,"errfield_P_FSG_12_0_0_23",0);
		setControlForeColor(panel_name, gCheckbox23, MakeRGB(250,0,0));
	}

}
/*@@end*/

/*@@caplFunc:resetErrfieldColor():*/
resetErrfieldColor()
{
  	setControlBackColor(panel_name, "errfield_C_FSG_12_0_0_1", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_2", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_3", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_4", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_13", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_15", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_16", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_17", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_18", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_19", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_20", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_21", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_22", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_23", MakeRGB(255,255,255));

}
/*@@end*/

/*@@caplFunc:CANoe_Shutdown():*/
CANoe_Shutdown ()
{
	// Timer: cancel real CAN-communication timer
	canceltimer(TaskTimer);
	// Ruecksetzen der Hintergrundfarbe der Error-Felder
	resetErrfieldColor();
	// Deaktivierung aller Panel Elemente 
	EnableConfigCtrl();
}
/*@@end*/

/*@@timer:TaskTimer:*/
on timer TaskTimer
{
	/*** Aufruf des BAP Task in DLL fuer NODE_INDEX ***/
	BAP150_Task(NODE_INDEX);	

	/*** Pollen ueber die anstehenden Indications (Lesen aus DLL, Auslesen eines Puffers der DLL) ***/
	BAP_DLL_Indication();	
	
	/*** Pollen ueber die anstehenden Requests (Schreiben in DLL, dort werden evt. Sendeauftraege gesetzt) ***/
	BAP_DLL_Request();
	
	/*** Abarbeiten der ausstehenden Sendeauftraege innerhalb der BAP DLL und Versenden ueber CANoe ***/
	//email from Jens 20.12.2012
    if (getValue(eSendEnabled))
    {
		BAP_CAN_TX_Request();
	}

	/*** Der Empfang von CAN Daten geschieht ueber on message CAN message Mechanismen ***/
	// keine Funktion hier

	/*** Retriggern des Timers mit 10 ms ***/
	setTimer(TaskTimer, TaskTime); // @TODO bei anderer Taskzeit muss hier modifiziert werden
}
/*@@end*/

/*@@caplFunc:BAP_DLL_Indication():*/
BAP_DLL_Indication()	//function to get received BAP-data from DLL (at BAL-interface)
{
	int i, length, datalength, temp;
	byte Indication_data[BAP_buffer_size];		// indication data from DLL
	dword Indication_header[6];					// indication header from DLL
	byte BAP_data_type;

	// init local variables
	length=0;
	datalength=0;
	temp=0;
	BAP_data_type=0;

	for(i = 0; i < 6; i++)
		Indication_header[i]=0;

	for(i = 0; i < BAP_buffer_size; i++)
		Indication_data[i]=0;

	// BAP-Stack needs this information for successful BAP150_GetIndication 
	Indication_header[4]=BAP_buffer_size;

	while (BAP150_GetInd(NODE_INDEX, Indication_header, Indication_data) == 0)
	{		
		//read header and write in global variable
		for (i = 0; i < 6; i++) {
			gBAP_Indication_header[i]=Indication_header[i];	
		}

		// nur Bytesequneces haben Datenanteil
		if (gBAP_Indication_header[3] == Bap_byteSequence)
		{
			for (i = 0; i < BAP_buffer_size; i++) {
				gBAP_Indication_data[i]=Indication_data[i];	
			}
		}	
		// Verarbeiten der Indication
		Process_Current_Indication();

		// Vorbereiten fuer naechsten Durchlauf 
		Indication_header[4]=BAP_buffer_size;
	} 
}
/*@@end*/

/*@@caplFunc:setBitInFctList(word,byte[]):*/
setBitInFctList(word fctid, byte fctList[])
{
    byte byteNo ;
    byte bitno ;
    byte fctValue ;

    byteNo = fctid / 8;
    bitno = fctid % 8;
    fctValue = 0x80 >> bitno;
    fctList[byteNo] |= fctValue;
}
/*@@end*/

/*@@caplFunc:round(float,float):*/
float round (float value, float step)
{
	//conflict with CANeasy
	//return _floor(value / step + 0.5) * step;
	long factor;
	double val1, val2;
	factor= value/step;
	val1=step*factor;
	val2=value-val1;
	if(abs(val2)>=(step/2))
		factor+= (val2>0?1:-1);
	return (factor * step);
}
/*@@end*/

/*@@caplFunc:ChangeConfig(long,long[]):*/
ChangeConfig(long paramIndex,long config[])
{

        byte temp ;
        temp = BAP150_ChangeConfig(NODE_INDEX, paramIndex, config);
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP150_ChangeConfig for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP150_ChangeConfig error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        
}
/*@@end*/

/*@@caplFunc:PrintIndicationError(char[]):*/
PrintIndicationError(char reason[])
{
	writelineEx(gError_Trace, 0, "%s - %s lsgId:%d fctid:%d indType:%d dataType:%s",
		reason, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]]);
}
/*@@end*/

/*@@caplFunc:initBapConfig():*/
initBapConfig()
{
        long config[3];
    config[0] = LSGID;
    config[1] = 0;
    config[2] = getValue(BAPCFG_FSG_12_0_0_ProtocolMajor);
    ChangeConfig(0x0012,config);
    config[2] = getValue(BAPCFG_FSG_12_0_0_ProtocolMinor);
    ChangeConfig(0x0013,config);
    config[2] = getValue(BAPCFG_FSG_12_0_0_LsgClassMajor);
    ChangeConfig(0x0010,config);
    config[2] = getValue(BAPCFG_FSG_12_0_0_LsgClassMinor);
    ChangeConfig(0x0011,config);
    config[2] = getValue(BAPCFG_FSG_12_0_0_DFMajor);
    ChangeConfig(0x0014,config);
    config[2] = getValue(BAPCFG_FSG_12_0_0_DFMinor);
    ChangeConfig(0x0015,config);
    
}
/*@@end*/

/*@@caplFunc:initFctList():*/
initFctList()
{
    byte fctList[8]={0,0,0,0,0,0,0,0};
    long fctList2[9]; //MWN 2016-05-25
    int i;
    dword request[6];
    byte errorCode;

    fctList[0]=0;
    fctList[1]=0;
    fctList[2]=0;
    fctList[3]=0;
    fctList[4]=0;
    fctList[5]=0;
    fctList[6]=0;
    fctList[7]=0;

    /*if(getValue(P_FSG_44_0_13_FunctionListId))
    {
        setBitInFctList(P_FSG_44_0_13_ID, fctList);
    }*/
           if(getValue(P_FSG_12_0_0_23_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_23_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_22_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_22_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_21_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_21_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_19_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_19_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_20_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_20_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_18_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_18_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_17_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_17_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_16_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_16_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_15_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_15_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_4_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_4_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_13_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_13_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_3_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_3_ID, fctList);
       }
       if(getValue(P_FSG_12_0_0_2_FctLstItemEn))
       {
           setBitInFctList(P_FSG_12_0_0_2_ID, fctList);
       }
       if(getValue(C_FSG_12_0_0_1_FctLstItemEn))
       {
           setBitInFctList(C_FSG_12_0_0_1_ID, fctList);
       }


    for(i=0;i<8;i++){
        writelineEx(gBAP_Trace, 0, "fctList[%d]: 0x%02x ",i,fctList[i]);
    }

	//MWN 2016-05-26
    request [0]=LSGID;
    request [1]=3;
    request [3]= Bap_byteSequence;
    request [4]= 8;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,fctList);
    if(errorCode)
        writelineEx(gError_Trace, 0, "BAP150_InitSendBuf(Functionlist) returns 0x%02x ",errorCode);

	/*
	fctList2[0]=LSGID;
    fctList2[1]=fctList[0];
    fctList2[2]=fctList[1];
    fctList2[3]=fctList[2];
    fctList2[4]=fctList[3];
    fctList2[5]=fctList[4];
    fctList2[6]=fctList[5];
    fctList2[7]=fctList[6];
    fctList2[8]=fctList[7];
    
    ChangeConfig(0x0030,fctList2);
	*/
	//MWN 2016-05-26
}
/*@@end*/

/*@@caplFunc:initHeartbeat():*/
initHeartbeat()
{
       long data[2];
   data[0]=LSGID;
   if( getValue(P_FSG_12_0_0_4_FctLstItemEn) )
      data[1]=getValue(P_FSG_12_0_0_4);
   else
      data[1]=0;
   ChangeConfig(0x00,data);
   InitSendBuf_int8(P_FSG_12_0_0_4_ID, data[1]);

}
/*@@end*/

/*@@caplFunc:BapOnOff(byte):*/
BapOnOff(byte _on)
{
    int length, temp;

    /***** Einschalten ******/
    if(_on==1){
        // soll der BAP Stack wieder initlialisiert werden?                                 
        if(gBAP_Init==0){
            gBAP_Init=1;
            temp=BAP150_Init(NODE_INDEX, LSGID);
            if(temp==0)
                writelineEx(gBAP_Trace, 0, "BAP_Init for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
            else
                writelineEx(gError_Trace, 0, "BAP_Init error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);         
        }

        // Initialisierung aller Variablen
        Initialize_Variables();                     

        // Aktivierung aller Panelelemente
		EnableFctCtrl();
        //EnableControl(panel_name, bapconfig_panel_name, 0); // @TODO
		DisableConfigCtrl();


        //BAP-Shutdown
        temp = BAP150_Shutdown(NODE_INDEX, LSGID);
        if(temp==0)
            writelineEx(gBAP_Trace, 0, "BAP_Shutdown for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP_Shutdown error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX); 

        initBapConfig();
        initFctList();
        initHeartbeat();

        temp = BAP150_Start(NODE_INDEX, LSGID);             
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP_Start for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP_Start error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        
    
        // setze den Timer fuer den zyklischen Aufruf des CANoe-"Tasks"
        setTimer(TaskTimer, 10);                
    
        //  BAPFsg_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID, DEBUG_SWITCH_ON);    
    }
    else{ /***** Ausschalten ****/
        
        BAP150_Shutdown(NODE_INDEX,LSGID);
        
        CANoe_Shutdown();
        
        // ETHERNET NOT ENABLED! (CALL_FCT_CLOSE_UPD_SOCKET_TOKEN)
    }

}
/*@@end*/

/*@@caplFunc:Initialize_Variables():*/
Initialize_Variables()	//initialize/reset all global variables
{
	int temp, i;
	byte  InitSend_data[BAP_buffer_size];	// InitSend data for DLL
	dword InitSend_header[6];	// InitSend header for DLL

	/**** Request Buffer Geschichten initialisieren ****/
	for (i = 0; i < Requestbuffer_lines; i++)
	{
		gBAP_Requestbuffer_status[i] = 0;
	}	
	for (i = 0; i < BAP_buffer_size; i++)
	{
		InitSend_data[i] = 0;
	}	

	// @TODO nur FSG relevant
	/**** Es ist notwendig mittels InitSendbuffer alle Properties im FSG zu initialisieren ****/
           InitSend_header[0] = LSGID;       
       InitSend_header[1] = 13; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_12_0_0_13);
	 putValue(P_FSG_12_0_0_13, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 15; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_12_0_0_15);
	 putValue(P_FSG_12_0_0_15, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 16; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 1;
       InitSend_header[5] = 0;
       getValue(P_FSG_12_0_0_16,InitSend_data);
       putValue(P_FSG_12_0_0_16,InitSend_data, 1);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_12_0_0_16)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 17; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_12_0_0_17);
	 putValue(P_FSG_12_0_0_17, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 18; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_12_0_0_18);
	 putValue(P_FSG_12_0_0_18, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 19; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_12_0_0_19);
	 putValue(P_FSG_12_0_0_19, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 20; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_12_0_0_20);
	 putValue(P_FSG_12_0_0_20, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 21; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_12_0_0_21);
	 putValue(P_FSG_12_0_0_21, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 22; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 2;
       InitSend_header[5] = 0;
       getValue(P_FSG_12_0_0_22,InitSend_data);
       putValue(P_FSG_12_0_0_22,InitSend_data, 2);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_12_0_0_22)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 23; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 2;
       InitSend_header[5] = 0;
       getValue(P_FSG_12_0_0_23,InitSend_data);
       putValue(P_FSG_12_0_0_23,InitSend_data, 2);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_12_0_0_23)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);

}
/*@@end*/

/*@@startStart:Start:*/
on start
{
    char Version[200];
    char Path[255];

	// noch nicht eingeschaltet
	gSG_PowerOnOff=0;
	// noch nicht initialisiert
	gBAP_Init=0;
	// open the panel, nur fuer CANoe-Version >= 5.1 erlaubt
	//openPanel(panel_name);
	// deaktiviere alle aktiven Panel Elemente, ausser AN/AUSS
    CANoe_Shutdown();
	
	// MWN 2016-05-27
    /**** Versionsstring von DLL holen und auf Bildschirm ausgeben ***/ 
    BAP150_GetVersions(Version, 200);
    writelineEx(gBAP_Trace, 0, "Versionx:%s", Version);
                                            
    NODE_INDEX = BAP150_CreateNode();
    writelineEx(gBAP_Trace, 0, "FSG %d Nodeindex:%d", LSGID, Version);
    
    /**** Laden der CANoe Datenbank *****/
    getAbsFilePath(dbc_path, Path, 255);
    writelineEx(gBAP_Trace, 0, "Load BAP_DBC-File: %s", Path);
    if(BAP150_LoadDBC(NODE_INDEX, 1, Path)  != 0) {        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
    }

    /**** Laden des BAP XML Files ****/
    getAbsFilePath(xml_path, Path, 255);
    writelineEx(gBAP_Trace, 0, "Load BAP-XML-File: %s", Path);
    if (BAP150_LoadConfig(NODE_INDEX, Path) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
    }

    if (BAP150_AddCanMap(NODE_INDEX, 1, 1) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Mappen!");
    }   
	// MWN 2016-05-27
    
    
// ETHERNET AND FLEXRAY NOT ENABLED!
        
}
/*@@end*/

/*@@caplFunc:BAP_CAN_TX_Request():*/
BAP_CAN_TX_Request()	//Function to send BAP-data over CAN
{
   int i;
   byte TX_Data[8];				// CAN-data
   byte TX_Data_FR[10];    		// FlexRay-Data
   dword TX_Header[3];			// CAN-header
   message 0x100 TX_Message;	// dummy-message, Adresse wird noch modifiziert
   
   byte send_result;
   
   // ONLY CAN IS ENABLED! 
   		TX_Header[2] = 8; // max-Length of TX_Data

		// Pollen ueber die Queue, die von der DLL zur Verfuegung gestellt wird
		// Diese Daten muessen ueber den CAN Bus gesendet werden
	   	while (BAP150_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) {	
			TX_Message.CAN = TX_Header[0]; 		//CAN channel
			TX_Message.ID =TX_Header[1]; 			//Can ID
			TX_Message.DLC = TX_Header[2]; 		// received length
			
			for (i=0; i<TX_Message.DLC; i++) {	//CAN data-bytes
		  		TX_Message.byte(i) = TX_Data[i];
		  	}
		  	
		  	output(TX_Message);					//send CAN message
		  	
		  	//Versions Output
		  	if(TX_Data[0] == 0x40 && TX_Data[1] == 0x00 && TX_Header[2] == 4)
		  	{
		    	writelineEx(gBAP_Trace, 0,"Major Version: %i, Minor Version: %i", TX_Data[2], TX_Data[3]);
		  	}       
		  	TX_Header[2] = 8; // max-Length of TX_Data
	   	} 
   // ONLY CAN IS ENABLED!
   // FLEXRAY NOT ENABLED! (TX_FR_TOKEN)
   // ETHERNET NOT ENABLED! (TX_IP_TOKEN)
}
/*@@end*/

/*@@caplFunc:ringbuffer_write(byte,byte,byte,byte,word,dword,byte[]):*/
ringbuffer_write (byte lsgID, byte fctID, byte request, byte dataType, word length, dword singleData, byte data[])
{
	int bufferline, i;

	bufferline = getNextWriteIndex();	//get next free position in ring-buffer

	if (bufferline == -1) 
	{
		writelineEx(gError_Trace, 0, "Crititcal Error: No free buffer found!");
		return;
	}
		
	gBAP_Request_header[bufferline][0] = lsgID;	// LSG
	gBAP_Request_header[bufferline][1] = fctID;	// FCT
	gBAP_Request_header[bufferline][3] = dataType; // dataType
    //writelineEx(gBAP_Trace, 0, "Write request in buffer FSG NODEINDEX:%d lsgid:%d fctid:%d requesttype:%d datatype:%d length:%d", 
    //        NODE_INDEX,lsgID,fctID,request,dataType,length);


	switch (dataType)
	{
		case Bap_void:
			gBAP_Request_header[bufferline][2] = request;	// request
			gBAP_Request_header[bufferline][4] = 0;	// length
				// Void
			// @TODO?		
			break;
		case Bap_uint8:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten		
			break;
		case Bap_uint16:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten
			break;			
		case Bap_uint32:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten		
			break;	
		case Bap_byteSequence:
			gBAP_Request_header[bufferline][2] = request;	// request
			gBAP_Request_header[bufferline][4] = length;	// length
			// Daten der ByteSequence kopieren
			for(i = 0; i < BAP_buffer_size; i++)									
				gBAP_Request_data[bufferline][i] = data[i];
		case Bap_error:
			gBAP_Request_header[bufferline][5] = singleData;	// Errorcode						
			break;
		default:
			break;
	}

			

}
/*@@end*/

/*@@caplFunc:Request_void(byte,byte,byte):*/
Request_void (byte lsgID, byte fctID, byte request)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_void, 0, 0, dataArray);	
}
/*@@end*/

/*@@caplFunc:Request_int8(byte,byte,byte,dword):*/
Request_int8 (byte lsgID, byte fctID, byte request, dword data)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_uint8, 0, data, dataArray);

}
/*@@end*/

/*@@caplFunc:Request_int16(byte,byte,byte,dword):*/
Request_int16 (byte lsgID, byte fctID, byte request, dword data)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_uint16, 0, data, dataArray);

}
/*@@end*/

/*@@caplFunc:Request_int32(byte,byte,byte,dword):*/
Request_int32 (byte lsgID, byte fctID, byte request, dword data)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_uint32, 0, data, dataArray);
}
/*@@end*/

/*@@caplFunc:Request_byteSequence(byte,byte,byte,byte[],word):*/
Request_byteSequence (byte lsgID, byte fctID, byte request, byte data[], word length)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	// Fuellen des Arrays
	for(i=0;i<length;i++) dataArray [i]=data[i];

	ringbuffer_write (lsgID, fctID, request, Bap_byteSequence, length, 0, dataArray);
}
/*@@end*/

/*@@caplFunc:Request_error(byte,byte,byte):*/
Request_error (byte lsgID, byte fctID, byte errorCode)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, Error_REQ, Bap_error, 0, errorCode, dataArray);
}
/*@@end*/

/*@@caplFunc:InitSendBuf_int8(byte,dword):*/
InitSendBuf_int8 (byte fctID, dword data)
{
    dword request[6];
    int errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint8;
    request [5]= data;

    errorCode=
    BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int8 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
    
}
/*@@end*/

/*@@caplFunc:InitSendBuf_int16(byte,dword):*/
InitSendBuf_int16 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint16;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int16 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}
/*@@end*/

/*@@caplFunc:InitSendBuf_int32(byte,dword):*/
InitSendBuf_int32 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int32 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}
/*@@end*/

/*@@caplFunc:InitSendBuf_byteSequence(byte,byte[],word):*/
InitSendBuf_byteSequence (byte fctID, byte data[], word length)
{
    dword request[6];
    byte errorCode;

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [4]= length;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_byteSequence error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}
/*@@end*/

/*@@caplFunc:DisplayRequestErrorCode(dword,dword):*/
DisplayRequestErrorCode(dword fctID, dword errCode)
{
       switch(fctID)
   {
       case C_FSG_12_0_0_1_ID:
           gC_FSG_12_0_0_1_ErrCode = 0;
           putValue(C_FSG_12_0_0_1_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_C_FSG_12_0_0_1", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_2_ID:
           gP_FSG_12_0_0_2_ErrCode = 0;
           putValue(P_FSG_12_0_0_2_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_2", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_3_ID:
           gP_FSG_12_0_0_3_ErrCode = 0;
           putValue(P_FSG_12_0_0_3_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_3", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_4_ID:
           gP_FSG_12_0_0_4_ErrCode = 0;
           putValue(P_FSG_12_0_0_4_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_4", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_13_ID:
           gP_FSG_12_0_0_13_ErrCode = 0;
           putValue(P_FSG_12_0_0_13_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_13", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_15_ID:
           gP_FSG_12_0_0_15_ErrCode = 0;
           putValue(P_FSG_12_0_0_15_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_15", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_16_ID:
           gP_FSG_12_0_0_16_ErrCode = 0;
           putValue(P_FSG_12_0_0_16_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_16", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_17_ID:
           gP_FSG_12_0_0_17_ErrCode = 0;
           putValue(P_FSG_12_0_0_17_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_17", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_18_ID:
           gP_FSG_12_0_0_18_ErrCode = 0;
           putValue(P_FSG_12_0_0_18_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_18", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_19_ID:
           gP_FSG_12_0_0_19_ErrCode = 0;
           putValue(P_FSG_12_0_0_19_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_19", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_20_ID:
           gP_FSG_12_0_0_20_ErrCode = 0;
           putValue(P_FSG_12_0_0_20_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_20", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_21_ID:
           gP_FSG_12_0_0_21_ErrCode = 0;
           putValue(P_FSG_12_0_0_21_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_21", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_22_ID:
           gP_FSG_12_0_0_22_ErrCode = 0;
           putValue(P_FSG_12_0_0_22_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_22", MakeRGB(255,79,79));
       break;
       case P_FSG_12_0_0_23_ID:
           gP_FSG_12_0_0_23_ErrCode = 0;
           putValue(P_FSG_12_0_0_23_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_23", MakeRGB(255,79,79));
       break;
       default:
           writelineEx(gError_Trace, 0, "%s%d/%d Unknown Functionid in  displayErrorCode", SGtype, LSGID,fctID);
   }

}
/*@@end*/

/*@@caplFunc:BAP_DLL_Request():*/
BAP_DLL_Request ()
{
    int i;
    int l=0;
    byte temp;
    byte Request_data[4096];    //Request data for DLL
    dword Request_header[6];    //Request header for DLL
    byte dataValid;
    int nextElementToRead;
    
    // defaultmaessig ist senden OK
    dataValid = 1;

    // loeschen der Daten "Container"
    for(i=0;i<6;i++)
        Request_header[i]=0;
    for(i=0;i<BAP_buffer_size;i++)
        Request_data[i]=0;

    
    // Verarbeiten aller noch offenen Requests  
    while ((nextElementToRead = getNextReadIndex()) != -1) 
    {
        // Fuer alle Datentypen gleich
        Request_header[0]=gBAP_Request_header [nextElementToRead][0];       //LSG-ID
        Request_header[1]=gBAP_Request_header [nextElementToRead][1];       //Function-ID
        Request_header[2]=gBAP_Request_header [nextElementToRead][2];       //request type
        Request_header[3]=gBAP_Request_header [nextElementToRead][3];       //BAP data type

        switch(gBAP_Request_header[nextElementToRead][3]){
            case Bap_uint32:
                l=2;
            case Bap_uint16:
                l++;
            case Bap_uint8:
            case Bap_error: // Request (2) wird dabei ignoriert
                l++;
            case Bap_void:  // Datenfeld (5) wird dabei ignoriert
                Request_header[4]=l;                                                //  not used
                Request_header[5]=gBAP_Request_header [nextElementToRead][5];       // Daten
            break;
            case Bap_byteSequence:                                  
                Request_header[4]=gBAP_Request_header [nextElementToRead][4];       // length
                Request_header[5]=0;                                                // not used

                // data-array for BAP-DLL funcion 'BAP_Request'
                for(i=0;i<BAP_buffer_size;i++)
                    Request_data[i]=gBAP_Request_data [nextElementToRead][i];
                break;          
            default:
                writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Request_header[nextElementToRead][3]);
                dataValid = 0;
            break;          
        }
        
        if(dataValid){
            // wie heisst der Request?
            writelineEx(gBAP_Trace, 0, "%s%d/%d BAP_Request %s datatype:%s length:%d", SGtype, Request_header[0],Request_header[1],Requesttype_Text[Request_header[2]],Datatype_Text[Request_header[3]],Request_header[4]);
            temp = BAP150_Request(NODE_INDEX, Request_header, Request_data);    //send data to BAP-DLL  
            // BAP-Request failed
            if(temp != 0){
                // Fehlercode: Request failed
                writelineEx(gError_Trace, 0, "%s%d/%d Error during BAP_Request errorcode: 0x%X", SGtype, Request_header[0],Request_header[1],temp);
                DisplayRequestErrorCode(Request_header[1],temp);
            } 
        }

    }
} 
/*@@end*/

/*@@caplFunc:getNextReadIndex():*/
int getNextReadIndex ()
{
	int i, ret;
	// der Puffer wird nach dem naechsten zu lesenden Eintrag durchsucht
	// Existiert keiner wird -1 zurueckgegeben
	ret = -1;

	for (i = 0; i < Requestbuffer_lines; i++)
	{
		if (gBAP_Requestbuffer_status[i] == 1)
		{
			// zum verschicken
			ret = i;
			// und wieder freigeben
			gBAP_Requestbuffer_status[i] = 0;
			break;
		}
	}

	return (ret);
}
/*@@end*/

/*@@caplFunc:getNextWriteIndex():*/
int getNextWriteIndex ()
{
	int i, ret;
	// der Puffer wird nach dem naechsten freien Eintrag durchsucht
	// Existiert keiner wird -1 zurueckgegeben
	ret = -1;

	for (i = 0; i < Requestbuffer_lines; i++)
	{
		if (gBAP_Requestbuffer_status[i] == 0)
		{
			// zum schreiben
			ret = i;
			// belegen
			gBAP_Requestbuffer_status[i] = 1;
			break;
		}
	}

	return (ret);
}
/*@@end*/

/*@@caplFunc:Process_Current_Indication():*/
//gBAP_Indication_header[0])  // LSGID
//gBAP_Indication_header[1]) // FCTID
//gBAP_Indication_header[2]) // IndType
//gBAP_Indication_header[3]) // Datentyp



Process_Current_Indication ()
{
   int rxsize;
   int txsize;
   byte temp[BAP_buffer_size];
   char buffer[BAP_buffer_size];
   if(strncmp(Datatype_Text[gBAP_Indication_header[3]], "acknowledge", 4)!=0) 
       writelineEx(gBAP_Trace, 0, "NodeIndex: %d: CurrentIndication %s lsgid:%d fctid:%d indType:%s dataType=%s length=%d",
               NODE_INDEX, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   else 
       writelineEx(gBAP_Trace, 0, "Internal acknowledge %s-%d fctid:%d indType:%s dataType=%s length=%d",
               SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Acknowledgetype_Text[gBAP_Indication_header[5]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   switch(gBAP_Indication_header[0])  // LSGID
   {
   case LSGID:
       switch(gBAP_Indication_header[1]) // FCTID
       {
    case P_FSG_12_0_0_13_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_13_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_13_ID,getValue(P_FSG_12_0_0_13_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_13, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_13", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_13_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_13_ID,getValue(P_FSG_12_0_0_13_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_13, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_13", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_12_0_0_13_ID, Data_REQ, getValue(P_FSG_12_0_0_13));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_12_0_0_13_ErrCode = 0;
                putValue(P_FSG_12_0_0_13_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_13", MakeRGB(255,79,79));  
                gP_FSG_12_0_0_13_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_12_0_0_15_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_12_0_0_15_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_15", MakeRGB(255,79,79));  
                gP_FSG_12_0_0_15_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_12_0_0_16_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_12_0_0_16_ErrEn)) { 
                           Request_error(LSGID,P_FSG_12_0_0_16_ID,getValue(P_FSG_12_0_0_16_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_12_0_0_16, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_16", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_12_0_0_16_ErrEn)) { 
                           Request_error(LSGID,P_FSG_12_0_0_16_ID,getValue(P_FSG_12_0_0_16_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_12_0_0_16, temp);
						gBAP_Indication_data[0]= gBAP_Indication_data[0]&0xf0;
						gBAP_Indication_data[0]= gBAP_Indication_data[0]|(temp[0]&0x0f);
                        putValue(P_FSG_12_0_0_16, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_16", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_12_0_0_16, temp);
                        Request_byteSequence(LSGID, P_FSG_12_0_0_16_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_12_0_0_16_ErrCode = 0;
                putValue(P_FSG_12_0_0_16_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_16", MakeRGB(255,79,79));  
                gP_FSG_12_0_0_16_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_12_0_0_17_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_17_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_17_ID,getValue(P_FSG_12_0_0_17_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_17, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_17", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_17_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_17_ID,getValue(P_FSG_12_0_0_17_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_17, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_17", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_12_0_0_17_ID, Data_REQ, getValue(P_FSG_12_0_0_17));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_12_0_0_17_ErrCode = 0;
                putValue(P_FSG_12_0_0_17_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_17", MakeRGB(255,79,79));  
                gP_FSG_12_0_0_17_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_12_0_0_18_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_18_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_18_ID,getValue(P_FSG_12_0_0_18_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_18, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_18", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_18_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_18_ID,getValue(P_FSG_12_0_0_18_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_18, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_18", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_12_0_0_18_ID, Data_REQ, getValue(P_FSG_12_0_0_18));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_12_0_0_18_ErrCode = 0;
                putValue(P_FSG_12_0_0_18_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_18", MakeRGB(255,79,79));  
                gP_FSG_12_0_0_18_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_12_0_0_19_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_19_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_19_ID,getValue(P_FSG_12_0_0_19_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_19, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_19", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_19_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_19_ID,getValue(P_FSG_12_0_0_19_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_19, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_19", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_12_0_0_19_ID, Data_REQ, getValue(P_FSG_12_0_0_19));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_12_0_0_19_ErrCode = 0;
                putValue(P_FSG_12_0_0_19_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_19", MakeRGB(255,79,79));  
                gP_FSG_12_0_0_19_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_12_0_0_20_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_20_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_20_ID,getValue(P_FSG_12_0_0_20_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_20, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_20", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_20_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_20_ID,getValue(P_FSG_12_0_0_20_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_20, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_20", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_12_0_0_20_ID, Data_REQ, getValue(P_FSG_12_0_0_20));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_12_0_0_20_ErrCode = 0;
                putValue(P_FSG_12_0_0_20_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_20", MakeRGB(255,79,79));  
                gP_FSG_12_0_0_20_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_12_0_0_21_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_21_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_21_ID,getValue(P_FSG_12_0_0_21_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_21, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_21", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_12_0_0_21_ErrEn)) { 
                               Request_error(LSGID,P_FSG_12_0_0_21_ID,getValue(P_FSG_12_0_0_21_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_12_0_0_21, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_21", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_12_0_0_21_ID, Data_REQ, getValue(P_FSG_12_0_0_21));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_12_0_0_21_ErrCode = 0;
                putValue(P_FSG_12_0_0_21_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_21", MakeRGB(255,79,79));  
                gP_FSG_12_0_0_21_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_12_0_0_22_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_12_0_0_22_ErrEn)) { 
                           Request_error(LSGID,P_FSG_12_0_0_22_ID,getValue(P_FSG_12_0_0_22_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_12_0_0_22, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_22", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_12_0_0_22_ErrEn)) { 
                           Request_error(LSGID,P_FSG_12_0_0_22_ID,getValue(P_FSG_12_0_0_22_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_12_0_0_22, temp);
						gBAP_Indication_data[1]=temp[1];
                        putValue(P_FSG_12_0_0_22, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_22", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_12_0_0_22, temp);
                        Request_byteSequence(LSGID, P_FSG_12_0_0_22_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_12_0_0_22_ErrCode = 0;
                putValue(P_FSG_12_0_0_22_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_22", MakeRGB(255,79,79));  
                gP_FSG_12_0_0_22_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_12_0_0_23_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_12_0_0_23_ErrEn)) { 
                           Request_error(LSGID,P_FSG_12_0_0_23_ID,getValue(P_FSG_12_0_0_23_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_12_0_0_23, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_23", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_12_0_0_23_ErrEn)) { 
                           Request_error(LSGID,P_FSG_12_0_0_23_ID,getValue(P_FSG_12_0_0_23_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_12_0_0_23, temp);
						gBAP_Indication_data[1]= gBAP_Indication_data[1]&0x0f;
						gBAP_Indication_data[1]= gBAP_Indication_data[1]|(temp[1]&0xf0);
						gBAP_Indication_data[1]= gBAP_Indication_data[1]&0xf0;
						gBAP_Indication_data[1]= gBAP_Indication_data[1]|(temp[1]&0x0f);
                        putValue(P_FSG_12_0_0_23, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_23", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_12_0_0_23, temp);
                        Request_byteSequence(LSGID, P_FSG_12_0_0_23_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_12_0_0_23_ErrCode = 0;
                putValue(P_FSG_12_0_0_23_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_12_0_0_23", MakeRGB(255,79,79));  
                gP_FSG_12_0_0_23_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
       default:
           writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal Fct: lsgid:%d fctid:%d indType:%d",
           NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], gBAP_Indication_header[2]);
           break;
       }
       break;
   default:
       writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal LSGID: lsgid:%d fctid:%d indType:%s", NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]]);
       break;
   }
}
/*@@end*/

/*@@msg:CAN1.MQB_KCAN_KMatrix::BAP_Wiper_ASG_01 (0x17330C00X):*/
on message BAP_Wiper_ASG_01
{
   int i, temp;
   byte RX_Data[8];            // received CAN-DATA
   dword RX_Header[3];         // received CAN-Header
   if(gSG_PowerOnOff==Power_on){
       RX_Header[0]=this.CAN;
       RX_Header[1]=this.ID;
       RX_Header[2]=this.DLC; // received length
       for (i=0; i<this.DLC; i++) {
           RX_Data[i]=this.byte(i);
       }
		switch ((RX_Data[1] & 0x0F))
        {
        //getAll
        case 1: //error
                if (getValue(C_FSG_12_0_0_1_ErrEn)==0x01)
                Request_error(LSGID,FctID_GetAll,getValue(C_FSG_12_0_0_1_ErrCode)); 
                
                else if (getValue(C_FSG_12_0_0_1_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 2: //error
                if (getValue(P_FSG_12_0_0_2_ErrEn)==0x01)
                Request_error(LSGID,FctID_BAP_Config,getValue(P_FSG_12_0_0_2_ErrCode)); 

                else if (getValue(P_FSG_12_0_0_2_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 3: //error
                if (getValue(P_FSG_12_0_0_3_ErrEn)==0x01)
                Request_error(LSGID,FctID_FunctionList,getValue(P_FSG_12_0_0_3_ErrCode)); 
                
                else if (getValue(P_FSG_12_0_0_3_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);
                break;
             
        
        default: temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	//send recieved CAN-data with CAN-header to BAP-DLL
                break;
        }
   }
}
/*@@end*/

/*@@caplFunc:intertelegram_err(long):*/
intertelegram_err(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=1;
    data[3]=940;
    ChangeConfig(0x0020,data);
}
/*@@end*/

/*@@caplFunc:sequence_err(long,long):*/
sequence_err(long fctId, long size)
{
    long data[5];
    long lastSeg;

    lastSeg = size-5;

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=lastSeg/7+1;
    data[3]=1;
    data[4]=(lastSeg/7+4) & 15;
    ChangeConfig(0x0021,data);
}
/*@@end*/

/*@@caplFunc:intertelegram_err_off(long):*/
intertelegram_err_off(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    ChangeConfig(0x0020,data);
}
/*@@end*/

/*@@caplFunc:sequence_err_off(long):*/
sequence_err_off(long fctId)
{
    long data[5];

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    data[4]=0;
    ChangeConfig(0x0021,data);
}
/*@@end*/

/*@@envVar:ON_OFF_FSG12_0:*/
// START OF BUS CONFIG PANEL CAPL

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_BUS_SELECTOR_PANEL_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_CAN_FRAME_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_FR_FRAME_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_ETHERNET_FRAME_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_IP_FORMAT_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ON_ENVVAR_BUSTYPE_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_ETHERNET_APPLY_BTN_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_ETHERNET_RESET_BTN_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_IP_INTERFACE_LIST_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_IP_FORMAT_TOKEN)

// ETHERNET NOT ENABLED! (ON_UDP_RECEIVE_FROM_TOKEN)

// ETHERNET NOT ENABLED!

on envVar ON_OFF_FSG12_0
{
   BapOnOff(getvalue(this));
   gSG_PowerOnOff=getvalue(ON_OFF_FSG12_0);
}
/*@@end*/

/*@@envVar:BAPCFG_FSG_12_0_0_DFMajor:*/
on envVar BAPCFG_FSG_12_0_0_DFMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 9, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
/*@@end*/

/*@@envVar:BAPCFG_FSG_12_0_0_DFMinor:*/
on envVar BAPCFG_FSG_12_0_0_DFMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 10, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
/*@@end*/

/*@@envVar:BAPCFG_FSG_12_0_0_LsgClassMajor:*/
on envVar BAPCFG_FSG_12_0_0_LsgClassMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 5, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
/*@@end*/

/*@@envVar:BAPCFG_FSG_12_0_0_LsgClassMinor:*/
on envVar BAPCFG_FSG_12_0_0_LsgClassMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 6, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
/*@@end*/

/*@@envVar:BAPCFG_FSG_12_0_0_ProtocolMajor:*/
on envVar BAPCFG_FSG_12_0_0_ProtocolMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 7, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
/*@@end*/

/*@@envVar:BAPCFG_FSG_12_0_0_ProtocolMinor:*/
on envVar BAPCFG_FSG_12_0_0_ProtocolMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 8, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
/*@@end*/

/*@@envVar:C_FSG_12_0_0_1_FctLstItemEn:*/
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID C_FSG_12_0_0_1_ID
on envVar C_FSG_12_0_0_1_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_C_FSG_12_0_0_1", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_C_FSG_12_0_0_1", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_2_FctLstItemEn:*/
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_12_0_0_2_ID
on envVar P_FSG_12_0_0_2_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_2", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_2", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_2_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_2_ErrCode
{
       if(gP_FSG_12_0_0_2_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_2", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_2_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_3_FctLstItemEn:*/
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_12_0_0_3_ID
on envVar P_FSG_12_0_0_3_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_3", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_3", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_3_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_3_ErrCode
{
       if(gP_FSG_12_0_0_3_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_3", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_3_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_4_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der HB-FCT P_FSG_12_0_0_4
on envVar P_FSG_12_0_0_4_FctLstItemEn
{
       if(getValue(this)) 
       {
//           EnableControl(panel_name,"panel_FSG_12_0_0_4",1);
//           EnableControl(panel_name,"${ERRFIELD}",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_4_HBEn",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_4", MakeRGB(0,240,0));
       }
       else
       {
//           EnableControl(panel_name,"panel_FSG_12_0_0_4",0);
//           EnableControl(panel_name,"${ERRFIELD}",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_4_HBEn",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_4", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_4_FctEn:*/
on envVar P_FSG_12_0_0_4_FctEn
{
	long data[2];
	if(getValue(P_FSG_12_0_0_4_FctEn)>0)
	{
		data[0] = 12;
		data[1] = getValue(P_FSG_12_0_0_4);
		write("enable HB");
	}
	else
	{
		data[0] = 12;
		data[1] = 0;
		write("disable HB");
	}
	Bap150_ChangeConfig(NODE_INDEX, 0x00, data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_4_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_4_ErrCode
{
       if(gP_FSG_12_0_0_4_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_4", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_4_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_13_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_13_ErrCode
{
       if(gP_FSG_12_0_0_13_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_13", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_13_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_13Status_BTN:*/
on envVar P_FSG_12_0_0_13Status_BTN
{
    if (P_FSG_12_0_0_13Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_12_0_0_13_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_12_0_0_13",MakeRGB(255,255,255));
       P_FSG_12_0_0_13Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_12_0_0_13_ID, Data_REQ, getValue(P_FSG_12_0_0_13));
      P_FSG_12_0_0_13Status_BTN_already_pressed = 0;
    }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_13_FctEn:*/
on envVar P_FSG_12_0_0_13_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_12_0_0_13_ID;
    data[2]=getValue(P_FSG_12_0_0_13_FctEn);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_13_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der FCTID P_FSG_12_0_0_13
on envVar P_FSG_12_0_0_13_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_13",1);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_13",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_13",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_13", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_13",0);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_13",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_13",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_13", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_13:*/
on envVar P_FSG_12_0_0_13 // bus value of FSG_Control (13).
{
	// opcodes: Error-Status
	byte param1; // Controlcode
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_12_0_0_13);
	putValue(P_FSG_12_0_0_13_1, param1);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_13_1_0:*/
on envVar P_FSG_12_0_0_13_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Controlcode
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_13_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_13_1,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_13_1:*/
on envVar P_FSG_12_0_0_13_1 // FSG_Control.Controlcode
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Controlcode
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_13_1_0, 1);
	else
		putValue(P_FSG_12_0_0_13_1_0, 0);

    // Update superval
	superval = getValue(P_FSG_12_0_0_13);
	superval = thisval;
	putValue(P_FSG_12_0_0_13,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_15_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_15_ErrCode
{
       if(gP_FSG_12_0_0_15_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_15", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_15_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_15Status_BTN:*/
on envVar P_FSG_12_0_0_15Status_BTN
{
    if (P_FSG_12_0_0_15Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_12_0_0_15_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_12_0_0_15",MakeRGB(255,255,255));
       P_FSG_12_0_0_15Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_12_0_0_15_ID, Data_REQ, getValue(P_FSG_12_0_0_15));
      P_FSG_12_0_0_15Status_BTN_already_pressed = 0;
    }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_15_FctEn:*/
on envVar P_FSG_12_0_0_15_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_12_0_0_15_ID;
    data[2]=getValue(P_FSG_12_0_0_15_FctEn);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_15_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der FCTID P_FSG_12_0_0_15
on envVar P_FSG_12_0_0_15_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_15",1);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_15",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_15",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_15", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_15",0);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_15",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_15",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_15", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_15:*/
on envVar P_FSG_12_0_0_15 // bus value of FSG_OperationState (15).
{
	// opcodes: Error-Status
	byte param1; // OP-State
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_12_0_0_15);
	putValue(P_FSG_12_0_0_15_1, param1);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_15_1:*/
on envVar P_FSG_12_0_0_15_1 // FSG_OperationState.OP-State
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // OP-State
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_12_0_0_15);
	superval = thisval;
	putValue(P_FSG_12_0_0_15,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_16_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_16_ErrCode
{
       if(gP_FSG_12_0_0_16_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_16", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_16_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_16Status_BTN:*/
on envVar P_FSG_12_0_0_16Status_BTN
{
	byte BAPTemp[1];
   if (P_FSG_12_0_0_16Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_12_0_0_16_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_12_0_0_16",MakeRGB(255,255,255));
      P_FSG_12_0_0_16Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_12_0_0_16, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_12_0_0_16_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_12_0_0_16));
      P_FSG_12_0_0_16Status_BTN_already_pressed = 0;
   }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_16_FctEn:*/
on envVar P_FSG_12_0_0_16_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_12_0_0_16_ID;
    data[2]=getValue(P_FSG_12_0_0_16_FctEn);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_16_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der FCTID P_FSG_12_0_0_16
on envVar P_FSG_12_0_0_16_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_16",1);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_16",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_16",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_16", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_16",0);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_16",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_16",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_16", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_16:*/
on envVar P_FSG_12_0_0_16 // bus value of ServicePosition (16).
{
	// opcodes: Error-Status
	byte param1; // Position
	byte param2; // Modification
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[1];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 1; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_12_0_0_16, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_12_0_0_16_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_12_0_0_16_2, param2);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_16_1_0:*/
on envVar P_FSG_12_0_0_16_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Position
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_16_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_16_1,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_16_1:*/
on envVar P_FSG_12_0_0_16_1 // ServicePosition.Position
{
	byte superval[1];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Position
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_16_1_0, 1);
	else
		putValue(P_FSG_12_0_0_16_1_0, 0);

    // Update superval
	getValue(P_FSG_12_0_0_16, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(P_FSG_12_0_0_16,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_16_2_0:*/
on envVar P_FSG_12_0_0_16_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Modification
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_16_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_16_2,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_16_2:*/
on envVar P_FSG_12_0_0_16_2 // ServicePosition.Modification
{
	byte superval[1];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Modification
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_16_2_0, 1);
	else
		putValue(P_FSG_12_0_0_16_2_0, 0);

    // Update superval
	getValue(P_FSG_12_0_0_16, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(P_FSG_12_0_0_16,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_17_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_17_ErrCode
{
       if(gP_FSG_12_0_0_17_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_17", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_17_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_17Status_BTN:*/
on envVar P_FSG_12_0_0_17Status_BTN
{
    if (P_FSG_12_0_0_17Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_12_0_0_17_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_12_0_0_17",MakeRGB(255,255,255));
       P_FSG_12_0_0_17Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_12_0_0_17_ID, Data_REQ, getValue(P_FSG_12_0_0_17));
      P_FSG_12_0_0_17Status_BTN_already_pressed = 0;
    }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_17_FctEn:*/
on envVar P_FSG_12_0_0_17_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_12_0_0_17_ID;
    data[2]=getValue(P_FSG_12_0_0_17_FctEn);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_17_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der FCTID P_FSG_12_0_0_17
on envVar P_FSG_12_0_0_17_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_17",1);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_17",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_17",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_17", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_17",0);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_17",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_17",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_17", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_17:*/
on envVar P_FSG_12_0_0_17 // bus value of WinterPosition (17).
{
	// opcodes: Error-Status
	byte param1; // Position
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_12_0_0_17);
	putValue(P_FSG_12_0_0_17_1, param1);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_17_1_0:*/
on envVar P_FSG_12_0_0_17_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Position
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_17_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_17_1,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_17_1:*/
on envVar P_FSG_12_0_0_17_1 // WinterPosition.Position
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Position
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_17_1_0, 1);
	else
		putValue(P_FSG_12_0_0_17_1_0, 0);

    // Update superval
	superval = getValue(P_FSG_12_0_0_17);
	superval = thisval;
	putValue(P_FSG_12_0_0_17,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_18_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_18_ErrCode
{
       if(gP_FSG_12_0_0_18_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_18", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_18_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_18Status_BTN:*/
on envVar P_FSG_12_0_0_18Status_BTN
{
    if (P_FSG_12_0_0_18Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_12_0_0_18_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_12_0_0_18",MakeRGB(255,255,255));
       P_FSG_12_0_0_18Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_12_0_0_18_ID, Data_REQ, getValue(P_FSG_12_0_0_18));
      P_FSG_12_0_0_18Status_BTN_already_pressed = 0;
    }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_18_FctEn:*/
on envVar P_FSG_12_0_0_18_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_12_0_0_18_ID;
    data[2]=getValue(P_FSG_12_0_0_18_FctEn);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_18_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der FCTID P_FSG_12_0_0_18
on envVar P_FSG_12_0_0_18_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_18",1);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_18",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_18",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_18", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_18",0);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_18",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_18",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_18", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_18:*/
on envVar P_FSG_12_0_0_18 // bus value of RearWiping (18).
{
	// opcodes: Error-Status
	byte param1; // Wiping
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_12_0_0_18);
	putValue(P_FSG_12_0_0_18_1, param1);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_18_1_0:*/
on envVar P_FSG_12_0_0_18_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Wiping
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_18_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_18_1,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_18_1:*/
on envVar P_FSG_12_0_0_18_1 // RearWiping.Wiping
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Wiping
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_18_1_0, 1);
	else
		putValue(P_FSG_12_0_0_18_1_0, 0);

    // Update superval
	superval = getValue(P_FSG_12_0_0_18);
	superval = thisval;
	putValue(P_FSG_12_0_0_18,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_19_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_19_ErrCode
{
       if(gP_FSG_12_0_0_19_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_19", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_19_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_19Status_BTN:*/
on envVar P_FSG_12_0_0_19Status_BTN
{
    if (P_FSG_12_0_0_19Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_12_0_0_19_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_12_0_0_19",MakeRGB(255,255,255));
       P_FSG_12_0_0_19Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_12_0_0_19_ID, Data_REQ, getValue(P_FSG_12_0_0_19));
      P_FSG_12_0_0_19Status_BTN_already_pressed = 0;
    }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_19_FctEn:*/
on envVar P_FSG_12_0_0_19_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_12_0_0_19_ID;
    data[2]=getValue(P_FSG_12_0_0_19_FctEn);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_19_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der FCTID P_FSG_12_0_0_19
on envVar P_FSG_12_0_0_19_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_19",1);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_19",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_19",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_19", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_19",0);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_19",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_19",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_19", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_19:*/
on envVar P_FSG_12_0_0_19 // bus value of TearsWiping (19).
{
	// opcodes: Error-Status
	byte param1; // Function
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_12_0_0_19);
	putValue(P_FSG_12_0_0_19_1, param1);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_19_1_0:*/
on envVar P_FSG_12_0_0_19_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Function
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_19_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_19_1,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_19_1:*/
on envVar P_FSG_12_0_0_19_1 // TearsWiping.Function
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Function
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_19_1_0, 1);
	else
		putValue(P_FSG_12_0_0_19_1_0, 0);

    // Update superval
	superval = getValue(P_FSG_12_0_0_19);
	superval = thisval;
	putValue(P_FSG_12_0_0_19,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_20_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_20_ErrCode
{
       if(gP_FSG_12_0_0_20_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_20", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_20_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_20Status_BTN:*/
on envVar P_FSG_12_0_0_20Status_BTN
{
    if (P_FSG_12_0_0_20Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_12_0_0_20_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_12_0_0_20",MakeRGB(255,255,255));
       P_FSG_12_0_0_20Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_12_0_0_20_ID, Data_REQ, getValue(P_FSG_12_0_0_20));
      P_FSG_12_0_0_20Status_BTN_already_pressed = 0;
    }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_20_FctEn:*/
on envVar P_FSG_12_0_0_20_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_12_0_0_20_ID;
    data[2]=getValue(P_FSG_12_0_0_20_FctEn);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_20_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der FCTID P_FSG_12_0_0_20
on envVar P_FSG_12_0_0_20_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_20",1);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_20",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_20",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_20", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_20",0);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_20",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_20",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_20", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_20:*/
on envVar P_FSG_12_0_0_20 // bus value of RainSensorOFF (20).
{
	// opcodes: Error-Status
	byte param1; // Status
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_12_0_0_20);
	putValue(P_FSG_12_0_0_20_1, param1);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_20_1_0:*/
on envVar P_FSG_12_0_0_20_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Status
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_20_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_20_1,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_20_1:*/
on envVar P_FSG_12_0_0_20_1 // RainSensorOFF.Status
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Status
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_20_1_0, 1);
	else
		putValue(P_FSG_12_0_0_20_1_0, 0);

    // Update superval
	superval = getValue(P_FSG_12_0_0_20);
	superval = thisval;
	putValue(P_FSG_12_0_0_20,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_21_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_21_ErrCode
{
       if(gP_FSG_12_0_0_21_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_21", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_21_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_21Status_BTN:*/
on envVar P_FSG_12_0_0_21Status_BTN
{
    if (P_FSG_12_0_0_21Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_12_0_0_21_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_12_0_0_21",MakeRGB(255,255,255));
       P_FSG_12_0_0_21Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_12_0_0_21_ID, Data_REQ, getValue(P_FSG_12_0_0_21));
      P_FSG_12_0_0_21Status_BTN_already_pressed = 0;
    }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_21_FctEn:*/
on envVar P_FSG_12_0_0_21_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_12_0_0_21_ID;
    data[2]=getValue(P_FSG_12_0_0_21_FctEn);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_21_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der FCTID P_FSG_12_0_0_21
on envVar P_FSG_12_0_0_21_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_21",1);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_21",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_21",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_21", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_21",0);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_21",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_21",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_21", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_21:*/
on envVar P_FSG_12_0_0_21 // bus value of RainSensorConfig (21).
{
	// opcodes: Error-Status
	byte param1; // Config
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_12_0_0_21);
	putValue(P_FSG_12_0_0_21_1, param1);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_21_1:*/
on envVar P_FSG_12_0_0_21_1 // RainSensorConfig.Config
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // Config
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_12_0_0_21);
	superval = thisval;
	putValue(P_FSG_12_0_0_21,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_22_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_22_ErrCode
{
       if(gP_FSG_12_0_0_22_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_22", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_22_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_22Status_BTN:*/
on envVar P_FSG_12_0_0_22Status_BTN
{
	byte BAPTemp[2];
   if (P_FSG_12_0_0_22Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_12_0_0_22_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_12_0_0_22",MakeRGB(255,255,255));
      P_FSG_12_0_0_22Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_12_0_0_22, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_12_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_12_0_0_22));
      P_FSG_12_0_0_22Status_BTN_already_pressed = 0;
   }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_22_FctEn:*/
on envVar P_FSG_12_0_0_22_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_12_0_0_22_ID;
    data[2]=getValue(P_FSG_12_0_0_22_FctEn);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_22_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der FCTID P_FSG_12_0_0_22
on envVar P_FSG_12_0_0_22_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_22",1);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_22",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_22",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_22", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_22",0);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_22",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_22",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_22", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_22:*/
on envVar P_FSG_12_0_0_22 // bus value of EasyEntrySteeringColumn (22).
{
	// opcodes: Error-Status
	byte param1; // Status
	byte param2; // Modification
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[2];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_12_0_0_22, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_12_0_0_22_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_12_0_0_22_2, param2);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_22_1_0:*/
on envVar P_FSG_12_0_0_22_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Status
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_22_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_22_1,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_22_1:*/
on envVar P_FSG_12_0_0_22_1 // EasyEntrySteeringColumn.Status
{
	byte superval[2];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Status
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_22_1_0, 1);
	else
		putValue(P_FSG_12_0_0_22_1_0, 0);

    // Update superval
	getValue(P_FSG_12_0_0_22, superval);
	superval[0]=thisval;
	putValue(P_FSG_12_0_0_22,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_22_2_0:*/
on envVar P_FSG_12_0_0_22_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Modification
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_22_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_22_2,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_22_2:*/
on envVar P_FSG_12_0_0_22_2 // EasyEntrySteeringColumn.Modification
{
	byte superval[2];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Modification
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_22_2_0, 1);
	else
		putValue(P_FSG_12_0_0_22_2_0, 0);

    // Update superval
	getValue(P_FSG_12_0_0_22, superval);
	superval[1]=thisval;
	putValue(P_FSG_12_0_0_22,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_23_ErrCode:*/
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_12_0_0_23_ErrCode
{
       if(gP_FSG_12_0_0_23_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_12_0_0_23", MakeRGB(255,255,255));
       }
       gP_FSG_12_0_0_23_ErrCode = 1;
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_23Status_BTN:*/
on envVar P_FSG_12_0_0_23Status_BTN
{
	byte BAPTemp[2];
   if (P_FSG_12_0_0_23Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_12_0_0_23_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_12_0_0_23",MakeRGB(255,255,255));
      P_FSG_12_0_0_23Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_12_0_0_23, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_12_0_0_23_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_12_0_0_23));
      P_FSG_12_0_0_23Status_BTN_already_pressed = 0;
   }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_23_FctEn:*/
on envVar P_FSG_12_0_0_23_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_12_0_0_23_ID;
    data[2]=getValue(P_FSG_12_0_0_23_FctEn);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_23_FctLstItemEn:*/
// De-Aktivierung der Eingabefelder der FCTID P_FSG_12_0_0_23
on envVar P_FSG_12_0_0_23_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_23",1);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_23",1);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_23",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_23", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_12_0_0_23",0);
           EnableControl(panel_name,"errfield_P_FSG_12_0_0_23",0);
           EnableControl(panel_name,"panel_P_FSG_12_0_0_23",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_12_0_0_23", MakeRGB(250,0,0));
       }
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_23:*/
on envVar P_FSG_12_0_0_23 // bus value of CameraCleaning (23).
{
	// opcodes: Error-Status
	byte param1; // Setup
	byte param2; // ModificationReason
	byte param3; // ModificationState
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[2];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_12_0_0_23, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_12_0_0_23_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_12_0_0_23_2, param2);
	///////// Start param3 - NIBBLE /////////
	param3 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_12_0_0_23_3, param3);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_23_1_0:*/
on envVar P_FSG_12_0_0_23_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Setup
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_23_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_23_1,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_23_1:*/
on envVar P_FSG_12_0_0_23_1 // CameraCleaning.Setup
{
	byte superval[2];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Setup
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_23_1_0, 1);
	else
		putValue(P_FSG_12_0_0_23_1_0, 0);

    // Update superval
	getValue(P_FSG_12_0_0_23, superval);
	superval[0]=thisval;
	putValue(P_FSG_12_0_0_23,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_23_2:*/
on envVar P_FSG_12_0_0_23_2 // CameraCleaning.ModificationReason
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // ModificationReason
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_FSG_12_0_0_23, superval);
	superval[1]= superval[1]&0x0f;
	superval[1]= superval[1]|(thisval<<4);
	putValue(P_FSG_12_0_0_23,superval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_23_3_0:*/
on envVar P_FSG_12_0_0_23_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ModificationState
	bitval= getValue(this);
	thisval = getValue(P_FSG_12_0_0_23_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_12_0_0_23_3,thisval);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_23_3:*/
on envVar P_FSG_12_0_0_23_3 // CameraCleaning.ModificationState
{
	byte superval[2];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // ModificationState
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_12_0_0_23_3_0, 1);
	else
		putValue(P_FSG_12_0_0_23_3_0, 0);

    // Update superval
	getValue(P_FSG_12_0_0_23, superval);
	superval[1]= superval[1]&0xf0;
	superval[1]= superval[1]|thisval;
	putValue(P_FSG_12_0_0_23,superval);
}
/*@@end*/

/*@@caplFunc:initStruct(byte[],dword[],byte[],dword[],word,word):*/
/**
*
* Template-Funktion zum automatischen befuellen der Array-Daten, die in einer Arrayfunktion genutzt werden.
* Die Funktion wird durch den von BAPSimGen generierten Code aufgerufen.
*
* Parameter:
* - structArray: Muss mindestens nMax * Arraygroesse Bytes Platz haben, wird vom BAPSimGen automatisch generiert
* - structElementsSizeArray: Enthaelt die Groesseangabe jedes Array-Elements. Die Arraygroesse entspricht der Elementanzahl im Array.
*       Byte & Nibble = 1; Word = 2; usw. Bei Strings wird die maximale Stringlaenge angegeben.
* - structElementsTypeArray: Gibt den Datentyp eines Array-Elements zurueck. Die Arraygroesse entspricht der Elmentanzahl im Array.
*                               0x0 = Zahlenwert, also ein Slider, Enum, Bitfield,...
*                               0xE = String (darauf folgt immer eine 2, mit der Angabe der benutzen Bytes im String)
*                               0xF = Laenge der Nutzdaten des Strings, nur return Wert
* - fctID: Kann zur Fallunterscheidung der Funktions-IDs verwendet werden.
* - nMax: Array-Index
*
* Die Funktion kann im Switch-Case beliebig erweitert werden. Der Switch-Case wertet den Parameter fctID aus.
*           
*                    
**/
initStruct(byte structArray[], dword structElementsSizeArray[], byte structElementsTypeArray[], dword structElementsMaxSizeArray[], word fctID, word nMax )
{
    byte rand8;
    word rand16;
    word randSize;
    word index;           //indexNr die an die String Parameter angehaengt wird.
    dword destArraySize;   //groesse von structArray
    dword destStructSize;  //groesse eines "Structs" also destArraySize / Anzahl Elemente (nMax))
    dword rand32;    
    dword i;
    dword pos;    //aktuelle Position im structArray
    dword elpos;  //aktuelle Position in den structElementsXXXArray's
    
    destArraySize = elCount(structArray);
    destStructSize = destArraySize / nMax;    

    Switch(fctID){

        //Idee ist, die Arrays je nach Funcion-ID speziell initalisieren zu koennen.
        //hierbei koennten die Daten z.B. aus einer Datei eingelesen werden,
        //oder auch ueber spezielle init Funktionen mit festen Werten initialisiert werden.
        //Der Default-Fall befuellt das Array mit Random-Werten und Strings mit einem vordefinierten Wort (hier test,)

        default :
        {
            pos = 0; 
            for(i = 1; i <= nMax; i++)
            {
                //walk through the array
                
                elpos = 0;
                while(pos < (destStructSize * i) )
                {   
                    //check Element type
                    if( structElementsTypeArray[elpos] == 0x0)          
                    { //Params like int, word, etc.
                        //check element length
                        Switch(structElementsSizeArray[elpos])
                        {
                            case(1) : //byte / nibble
                                rand8 = random(structElementsMaxSizeArray[elpos]);
                                structArray[pos] = rand8;
                                pos++;
                                break;

                            case(2) : //word / int
                                rand16 = random(structElementsMaxSizeArray[elpos]);
                                int2byte(structArray, pos, rand16);
                                pos += 2;
                                break;

                            case (4) : //dword / long
                                rand32 = random(structElementsMaxSizeArray[elpos]);
                                long2byte(structArray, pos, rand32);
                                pos += 4;
                                break;                        
                         }
                    }
                    else if(structElementsTypeArray[elpos] == 0xE)          
                    { //String Params like byte[]
                        randSize = random(structElementsSizeArray[elpos]);
                        if(randSize < 2) randSize = 2; 
                        index = i-1;
                        setRandomString(structArray ,pos ,structElementsSizeArray[elpos], randSize, index);
                        pos += structElementsSizeArray[elpos];
                    }
                    else if(structElementsTypeArray[elpos] == 0xF)          
                    {
                        int2byte(structArray, pos, randSize);
                        pos += 2;
                        //write("Pos: %d Strlth: %d Type: %d ",pos-1,randSize,structElementsTypeArray[elpos]);
                    
                    }
                    elpos++;
                }
            }   
        break;
        }            
    }
}
/*@@end*/

/*@@caplFunc:long2Byte(byte[],dword,dword):*/
long2Byte(byte in[], dword pos, dword value)
{
    if( (elCount(in)-pos) < 4)
        write("Array out ouf bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);
    in[++pos] = (value >> 16);
    in[++pos] = (value >> 24);
}
/*@@end*/

/*@@caplFunc:int2byte(byte[],dword,word):*/
int2byte (byte in[],dword pos,word value)
{
    if( (elCount(in)-pos) < 2 )
        write("Array out of bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);        
}
/*@@end*/

/*@@caplFunc:setRandomString(byte[],dword,word,word,word):*/
setRandomString (byte in[], dword pos, word strSize, word randSize, word count)
{
    word endPos, endString, j;
    byte testString[4]={'t','e','s','t'};
    
    endPos = pos + strSize;
    endString = pos + randSize;
    j=0;
    
    int2ascii(in, pos, count);
    pos += 2;
    
    for(pos; pos < endPos ;pos ++)
    {
        if(j > 3 )
            j = 0;
        if(pos < endString)
            in[pos] = testString[j++];
        else
            in[pos] = 0x0;
    }
}
/*@@end*/

/*@@caplFunc:int2ascii(byte[],dword,word):*/
int2ascii (byte in[], dword pos, word value)
{
    //Konvertiert nur die erste und zweite Dezimalstelle, also Zahlen zw. 0 und 99.
    
    //auf 2 Stellen kuerzen
    value = value%100;
    //10er schreiben
    in[pos] = (value/10) + 48;    //  0x30 hex = 48 dez = ascii null
    //1er schreiben
    in[pos+1] = (value%10) + 48;  //  0x30 hex = 48 dez = ascii null
}
/*@@end*/

/*@@envVar:C_FSG_12_0_0_1_SegmEn:*/
//VAGH-15438 
on envVar C_FSG_12_0_0_1_SegmEn
{
	if(getValue(this)) 
	{
		putValue(C_FSG_12_0_0_1_IntTlgEn,0);
		sequence_err(FctID_GetAll,15);
	}
	else
	{
		sequence_err_off(FctID_GetAll);
	}
}
/*@@end*/

/*@@envVar:C_FSG_12_0_0_1_IntTlgEn:*/
//VAGH-15438 
on envVar C_FSG_12_0_0_1_IntTlgEn
{
	if(getValue(this)) 
	{
		putValue(C_FSG_12_0_0_1_SegmEn,0);
		intertelegram_err(FctID_GetAll);
	}
	else
	{
		intertelegram_err_off(FctID_GetAll);
	}
}
/*@@end*/

/*@@envVar:C_FSG_12_0_0_1_ErrEn:*/
//VAGH-15438 
on envVar C_FSG_12_0_0_1_ErrEn
{
	if (getValue(this))
		putValue(C_FSG_12_0_0_1_FctEn,0);
}
/*@@end*/

/*@@envVar:C_FSG_12_0_0_1_FctEn:*/
//VAGH-15438 
on envVar C_FSG_12_0_0_1_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_GetAll;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_3_SegmEn:*/
//VAGH-15438 
on envVar P_FSG_12_0_0_3_SegmEn
{
	if(getValue(this)) 
	{
		putValue(P_FSG_12_0_0_3_IntTlgEn,0);
		sequence_err(FctID_FunctionList,8);
	}
	else
	{
		sequence_err_off(FctID_FunctionList);
	}
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_3_IntTlgEn:*/
//VAGH-15438 
on envVar P_FSG_12_0_0_3_IntTlgEn
{
	if(getValue(this)) 
	{
		putValue(P_FSG_12_0_0_3_SegmEn,0);
		intertelegram_err(FctID_FunctionList);
	}
	else
	{
		intertelegram_err_off(FctID_FunctionList);
	}
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_3_ErrEn:*/
//VAGH-15438 
on envVar P_FSG_12_0_0_3_ErrEn
{
	if (getValue(this))
		putValue(P_FSG_12_0_0_3_FctEn,0);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_3_FctEn:*/
//VAGH-15438 
on envVar P_FSG_12_0_0_3_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_FunctionList;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_2_FctEn:*/
//VAGH-15438 
on envVar P_FSG_12_0_0_2_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_BAP_Config;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}
/*@@end*/

/*@@envVar:P_FSG_12_0_0_2Reset_BTN:*/
//VAGH-15438
on envVar P_FSG_12_0_0_2Reset_BTN
{
   message 0x100 _mBAPconfig;	

    if (getValue(this))
    {
        //for BAPconfig Set/Reset button
         _mBAPconfig.CAN=1; 
		 _mBAPconfig.ID=0x97330C10; 
		 _mBAPconfig.DLC=8; 
                	
         _mBAPconfig.byte(0) = 0x03;
         _mBAPconfig.byte(1) = 0x02;
         _mBAPconfig.byte(2) = getValue(BAPCFG_FSG_12_0_0_ProtocolMajor);
         _mBAPconfig.byte(3) = getValue(BAPCFG_FSG_12_0_0_ProtocolMinor);
         _mBAPconfig.byte(4) = getValue(BAPCFG_FSG_12_0_0_LsgClassMajor);
         _mBAPconfig.byte(5) = getValue(BAPCFG_FSG_12_0_0_LsgClassMinor);
         _mBAPconfig.byte(6) = getValue(BAPCFG_FSG_12_0_0_DFMajor);
         _mBAPconfig.byte(7) = getValue(BAPCFG_FSG_12_0_0_DFMinor);
      
        output(_mBAPconfig);	
   }

}
/*@@end*/

