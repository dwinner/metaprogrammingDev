/*@!Encoding:1252*/
includes
{
  #include "../../_DLL/latest_BAP_DLL.cin"
}

variables
{
  //Lane Guidance
  int  index_lane;
  int  Active[4][9];
  byte LG_SS_counter=0;
  byte LG_SS_element_counter = 0;
  char LG_panel[100] = "A_0x18_LG_new";
  byte fru_flag = 0;
  
  const BAP_BUFFER_SIZE = 2048;
   

	//@BAPSIMGEN_VAR_SECTION_BEGIN

	/***************************************************/
	/*            BapSimGen FSG template               */
	/***************************************************/

	/************** Ausgabe Konsole (Traces) ***********/
	dword gBAP_Trace;
	dword gError_Trace;

	/************** Node Verwaltung ***************/
	//Power on/off
	byte gSG_PowerOnOff=0x01;     // wird mit Power_off/on gesetzt
	byte gBAP_Init=0;             // schon mal initialisiert?

	const Power_off = 0x00;	
	const Power_on	= 0x01;

	mstimer TaskTimer;				//real communication timer

	/************** Request **************/
	const Requestbuffer_lines = 37;
	const dword BAP_buffer_size = 1874;

	/************ Speichern von Requests im "Ringbuffer" ***********/
	int   gBAP_Requestbuffer_status	[Requestbuffer_lines];		             // 0: kein Eintrag, 1: pending
	dword gBAP_Request_header		[Requestbuffer_lines] [6];				 // beinhaltet auch skalare Daten
	dword gBAP_Request_data         [Requestbuffer_lines] [BAP_buffer_size]; // Ringbuffer fuer BAP-Request


	/************** Indication **************/
	// enthaelt die derzeitige Indication
	dword gBAP_Indication_header[6];	
	byte  gBAP_Indication_data[BAP_buffer_size];		

	/************** Konstanten ****************/

	//BAP Data Type 
	const Bap_void				=0;
	const Bap_uint8				=1;
	const Bap_uint16			=2;
	const Bap_uint32			=3;
	const Bap_byteSequence		=4;
    const Bap_fixedByteSequence =4;
    const Bap_error				=5;
    const Bap_acknowledge		=6;

	char Datatype_Text[7][20] =
	{
		"void", "uint8", "uint16", "uint32", "byteSequence", "error", "acknowledge"
	};
	
	//BAP request types
	const DataSetGet_REQ	= 0x00;
	const DataSet_REQ		= 0x01;
	const DataGet_REQ		= 0x02;
	const Data_REQ			= 0x03;
	const Changed_REQ		= 0x04;
	const Start_REQ			= 0x05;
	const StartResult_REQ	= 0x06;
	const AbortResult_REQ	= 0x07;
	const Processing_REQ	= 0x08;
	const Result_REQ		= 0x09;
	const DataAck_REQ       = 0x0A;
	const Ack_REQ           = 0x0B;
	const Invalid_REQ    	= 0x1F; // Kennzeichnung fuer einen ungueltigen Request
	const Error_REQ         = 0x20;

	char Requesttype_Text[33][30] =
	{
		"DataSetGet_REQ", "DataSet_REQ", "DataGet_REQ", "Data_REQ",			/* 00 .. 03 */
		"Changed_REQ", "Start_REQ", "StartResult_REQ", "AbortResult_REQ",   /* 04 .. 07 */
		"Processing_REQ", "Result_REQ", "DataAck_REQ", "Ack_REQ", 		/* 08 .. 0b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 0c .. 0f */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 10 .. 13 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 14 .. 17 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", 		/* 18 .. 1b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 1c .. 1f */
		"Error_REQ"	  														/* 20 */
	};
	
	//BAP indication types
	const Data_IND				= 0x00;
	const Reset_IND				= 0x01;
	const DataAck_IND			= 0x02;
	const Result_IND			= 0x03;
	const Processing_IND	    = 0x04;
	const Changed_IND			= 0x05;
	const DataSetGet_IND	    = 0x06;
	const DataSet_IND			= 0x07;
	const DataGet_IND			= 0x08;
	const Ack_IND				= 0x09;
	const Processing_CNF_IND	= 0x0A;
	const Start_IND				= 0x0B;
	const StartResult_IND		= 0x0C;
	const AbortResult_IND		= 0x0D;
	const Invalid_IND			= 0x1F; // Kennzeichnung fuer eine ungueltige Indication
	const Error_IND             = 0x20;

	char Indicationtype_Text[33][30] =
	{
		"Data_IND", "Reset_IND", "DataAck_IND", "Result_IND",				/* 00 .. 03 */
		"Processing_IND", "Changed_IND", "DataSetGet_IND", "DataSet_IND",	/* 04 .. 07 */
		"DataGet_IND", "Ack_IND", "Processing_CNF_IND", "Start_REQ",		/* 08 .. 0b */
		"StartResult_REQ", "AbortResult_REQ", "Invalid_REQ", "Invalid_REQ", /* 0c .. 0f */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 10 .. 13 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 14 .. 17 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 18 .. 1b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 1c .. 1f */
		"Error_REQ"	  														/* 20 */
	};	
	
	char Acknowledgetype_Text[24][30] =
	{
		"Property_SetGet_ACK", "Array_SetGet_ACK", "Property_Set_ACK", "Array_Set_ACK",				/* 00 .. 03 */
		"Method_Start_ACK", "Method_StartResult_ACK", "Method_AbortResult_ACK", "Property_Get_ACK",	/* 04 .. 07 */
		"Array_Get_ACK", "Cache_GetAll_ACK", "Property_Ack_ACK", "Property_Status_ACK",	   			/* 08 .. 0b */
		"Property_StatusAck_ACK", "Property_Error_ACK", "Array_Status_ACK", "Array_Changed_ACK",	/* 0c .. 0f */
		"Array_Error_ACK", "Method_Processing_ACK", "Method_Result_ACK", "Method_Error_ACK",  		/* 10 .. 13 */
		"Unknown_ACK", "Unknown_ACK", "Unknown_ACK", "Unknown_ACK"									/* 14 .. 17 */
	};

	/**************************** Global Function-ID's ******************************/

	byte already_pressed = 0;

	const FctID_GetAll									= 0x01;
	const FctID_BAP_Config								= 0x02;
	const FctID_FunctionList							= 0x03;
	const FctID_HeartBeat								= 0x04;
    
  char SGtype[4]="FSG";
  
  _align(1) struct CommConfigStruct{
    char  Name[100];
    dword Number;
    dword Channel;
    dword Reserved;
  };

  byte isSelectedCAN;
  byte isSelectedEth;
  byte isSelectedFr; 
  
	//// Begin: konfigurationsabhýngige Variablen, die als BAPCONFIG_VARS in Template definiert sind
	
	char  dbcan_path[255]           = "BAP\\FSG50_Navigation_410\\bapdb\\BAP_BAP_only_MQB_MLBevo_MQB2020_MEB_KMatrix__45_18_V1.20F_20181116_AHe.dbc";
	char  xml_path[255]             = "BAP\\FSG50_Navigation_410\\bapxml\\BAP_SW16_Navigation_P30DF4.10_FSG_V2.10.0_FSG.xml";
	dword NODE_INDEX                =  0;
	char  NODE_NAME[100]            = "Navigation";
	const LSGID                     = 50;
	char  panel_name[100]           = "FSG50_0";
	char  bapconfig_panel_name[100]    = "panel10";
	char  common_panel_name[100]    = "panel2";
	const TaskTime                  = 10;
	 const C_FSG_50_0_0_1_ID = 1;
	 char gCheckbox1[100] = "checkbox_C_FSG_50_0_0_1";
	 char gErrField1[100] = "errfield_C_FSG_50_0_0_1";
	 byte gC_FSG_50_0_0_1_ErrCode = 1;
	 const P_FSG_50_0_0_2_ID = 2;
	 byte P_FSG_50_0_0_2Reset_BTN_already_pressed = 0;
	 char gCheckbox2[100] = "checkbox_P_FSG_50_0_0_2";
	 char gErrField2[100] = "errfield_P_FSG_50_0_0_2";
	 byte gP_FSG_50_0_0_2_ErrCode = 1;
	 const P_FSG_50_0_0_3_ID = 3;
	 byte P_FSG_50_0_0_3Status_BTN_already_pressed = 0;
	 char gCheckbox3[100] = "checkbox_P_FSG_50_0_0_3";
	 char gErrField3[100] = "errfield_P_FSG_50_0_0_3";
	 byte gP_FSG_50_0_0_3_ErrCode = 1;
	 const P_FSG_50_0_0_4_ID = 4;
	 byte P_FSG_50_0_0_4Status_BTN_already_pressed = 0;
	 char gCheckbox4[100] = "checkbox_P_FSG_50_0_0_4";
	 char gErrField4[100] = "errfield_P_FSG_50_0_0_4";
	 byte gP_FSG_50_0_0_4_ErrCode = 1;
	 const P_FSG_50_0_0_15_ID = 15;
	 byte P_FSG_50_0_0_15Status_BTN_already_pressed = 0;
	 char gCheckbox15[100] = "checkbox_P_FSG_50_0_0_15";
	 char gErrField15[100] = "errfield_P_FSG_50_0_0_15";
	 byte gP_FSG_50_0_0_15_ErrCode = 1;
	 char gPanel15[100] = "panel_P_FSG_50_0_0_15";
	 const P_FSG_50_0_0_16_ID = 16;
	 byte P_FSG_50_0_0_16Status_BTN_already_pressed = 0;
	 char gCheckbox16[100] = "checkbox_P_FSG_50_0_0_16";
	 char gErrField16[100] = "errfield_P_FSG_50_0_0_16";
	 byte gP_FSG_50_0_0_16_ErrCode = 1;
	 char gPanel16[100] = "panel_P_FSG_50_0_0_16";
	 const P_FSG_50_0_0_17_ID = 17;
	 byte P_FSG_50_0_0_17Status_BTN_already_pressed = 0;
	 char gCheckbox17[100] = "checkbox_P_FSG_50_0_0_17";
	 char gErrField17[100] = "errfield_P_FSG_50_0_0_17";
	 byte gP_FSG_50_0_0_17_ErrCode = 1;
	 char gPanel17[100] = "panel_P_FSG_50_0_0_17";
	 const P_FSG_50_0_0_18_ID = 18;
	 byte P_FSG_50_0_0_18Status_BTN_already_pressed = 0;
	 char gCheckbox18[100] = "checkbox_P_FSG_50_0_0_18";
	 char gErrField18[100] = "errfield_P_FSG_50_0_0_18";
	 byte gP_FSG_50_0_0_18_ErrCode = 1;
	 char gPanel18[100] = "panel_P_FSG_50_0_0_18";
	 const P_FSG_50_0_0_19_ID = 19;
	 byte P_FSG_50_0_0_19Status_BTN_already_pressed = 0;
	 char gCheckbox19[100] = "checkbox_P_FSG_50_0_0_19";
	 char gErrField19[100] = "errfield_P_FSG_50_0_0_19";
	 byte gP_FSG_50_0_0_19_ErrCode = 1;
	 char gPanel19[100] = "panel_P_FSG_50_0_0_19";
	 const P_FSG_50_0_0_20_ID = 20;
	 byte P_FSG_50_0_0_20Status_BTN_already_pressed = 0;
	 char gCheckbox20[100] = "checkbox_P_FSG_50_0_0_20";
	 char gErrField20[100] = "errfield_P_FSG_50_0_0_20";
	 byte gP_FSG_50_0_0_20_ErrCode = 1;
	 char gPanel20[100] = "panel_P_FSG_50_0_0_20";
	 const P_FSG_50_0_0_21_ID = 21;
	 byte P_FSG_50_0_0_21Status_BTN_already_pressed = 0;
	 char gCheckbox21[100] = "checkbox_P_FSG_50_0_0_21";
	 char gErrField21[100] = "errfield_P_FSG_50_0_0_21";
	 byte gP_FSG_50_0_0_21_ErrCode = 1;
	 char gPanel21[100] = "panel_P_FSG_50_0_0_21";
	 const P_FSG_50_0_0_22_ID = 22;
	 byte P_FSG_50_0_0_22Status_BTN_already_pressed = 0;
	 char gCheckbox22[100] = "checkbox_P_FSG_50_0_0_22";
	 char gErrField22[100] = "errfield_P_FSG_50_0_0_22";
	 byte gP_FSG_50_0_0_22_ErrCode = 1;
	 char gPanel22[100] = "panel_P_FSG_50_0_0_22";
	 const P_FSG_50_0_0_23_ID = 23;
	 byte P_FSG_50_0_0_23Status_BTN_already_pressed = 0;
	 char gCheckbox23[100] = "checkbox_P_FSG_50_0_0_23";
	 char gErrField23[100] = "errfield_P_FSG_50_0_0_23";
	 byte gP_FSG_50_0_0_23_ErrCode = 1;
	 char gPanel23[100] = "panel_P_FSG_50_0_0_23";
	 const A_FSG_50_0_0_24_ID = 24;
	 byte A_FSG_50_0_0_24Changed_BTN_already_pressed = 0;
	 byte A_FSG_50_0_0_24Status_BTN_already_pressed = 0;
	 char gCheckbox24[100] = "checkbox_A_FSG_50_0_0_24";
	 char gErrField24[100] = "errfield_A_FSG_50_0_0_24";
	 byte gA_FSG_50_0_0_24_ErrCode = 1;
	 char gPanel24[100] = "panel_A_FSG_50_0_0_24";
	 byte A_FSG_50_0_0_24_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_24_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_24_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_24_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_24_generateData_Btn_already_pressed = 0;
	 byte A_FSG_50_0_0_24_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_50_0_0_24_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3[17];
		 word Param3_Length;
		 byte Param4;
		 byte Param5;
		 byte Param6;
		 byte Param7;
		 byte Param8;
	 };
	 struct A_FSG_50_0_0_24_ArrayDataStruct A_FSG_50_0_0_24_ArrayDataList[255];
	 const A_FSG_50_0_0_24_ArrayDataList_Length = 255;
	 long A_FSG_50_0_0_24_Data_3_LenList[255];
	 byte A_FSG_50_0_0_24_Data_3_CntList[255];
	 long A_FSG_50_0_0_24_Data_3_SetGet_LenList[255];
	 byte A_FSG_50_0_0_24_Data_3_SetGet_CntList[255];
	 const P_FSG_50_0_0_25_ID = 25;
	 byte P_FSG_50_0_0_25Status_BTN_already_pressed = 0;
	 char gCheckbox25[100] = "checkbox_P_FSG_50_0_0_25";
	 char gErrField25[100] = "errfield_P_FSG_50_0_0_25";
	 byte gP_FSG_50_0_0_25_ErrCode = 1;
	 char gPanel25[100] = "panel_P_FSG_50_0_0_25";
	 const P_FSG_50_0_0_26_ID = 26;
	 byte P_FSG_50_0_0_26Status_BTN_already_pressed = 0;
	 char gCheckbox26[100] = "checkbox_P_FSG_50_0_0_26";
	 char gErrField26[100] = "errfield_P_FSG_50_0_0_26";
	 byte gP_FSG_50_0_0_26_ErrCode = 1;
	 char gPanel26[100] = "panel_P_FSG_50_0_0_26";
	 const P_FSG_50_0_0_27_ID = 27;
	 byte P_FSG_50_0_0_27Status_BTN_already_pressed = 0;
	 char gCheckbox27[100] = "checkbox_P_FSG_50_0_0_27";
	 char gErrField27[100] = "errfield_P_FSG_50_0_0_27";
	 byte gP_FSG_50_0_0_27_ErrCode = 1;
	 char gPanel27[100] = "panel_P_FSG_50_0_0_27";
	 const P_FSG_50_0_0_28_ID = 28;
	 byte P_FSG_50_0_0_28Status_BTN_already_pressed = 0;
	 char gCheckbox28[100] = "checkbox_P_FSG_50_0_0_28";
	 char gErrField28[100] = "errfield_P_FSG_50_0_0_28";
	 byte gP_FSG_50_0_0_28_ErrCode = 1;
	 char gPanel28[100] = "panel_P_FSG_50_0_0_28";
	 const A_FSG_50_0_0_29_ID = 29;
	 byte A_FSG_50_0_0_29Changed_BTN_already_pressed = 0;
	 byte A_FSG_50_0_0_29Status_BTN_already_pressed = 0;
	 char gCheckbox29[100] = "checkbox_A_FSG_50_0_0_29";
	 char gErrField29[100] = "errfield_A_FSG_50_0_0_29";
	 byte gA_FSG_50_0_0_29_ErrCode = 1;
	 char gPanel29[100] = "panel_A_FSG_50_0_0_29";
	 byte A_FSG_50_0_0_29_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_29_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_29_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_29_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_29_generateData_Btn_already_pressed = 0;
	 byte A_FSG_50_0_0_29_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_50_0_0_29_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3[97];
		 word Param3_Length;
	 };
	 struct A_FSG_50_0_0_29_ArrayDataStruct A_FSG_50_0_0_29_ArrayDataList[254];
	 const A_FSG_50_0_0_29_ArrayDataList_Length = 254;
	 long A_FSG_50_0_0_29_Data_3_LenList[254];
	 byte A_FSG_50_0_0_29_Data_3_CntList[254];
	 long A_FSG_50_0_0_29_Data_3_SetGet_LenList[254];
	 byte A_FSG_50_0_0_29_Data_3_SetGet_CntList[254];
	 const A_FSG_50_0_0_30_ID = 30;
	 byte A_FSG_50_0_0_30Changed_BTN_already_pressed = 0;
	 byte A_FSG_50_0_0_30Status_BTN_already_pressed = 0;
	 char gCheckbox30[100] = "checkbox_A_FSG_50_0_0_30";
	 char gErrField30[100] = "errfield_A_FSG_50_0_0_30";
	 byte gA_FSG_50_0_0_30_ErrCode = 1;
	 char gPanel30[100] = "panel_A_FSG_50_0_0_30";
	 byte A_FSG_50_0_0_30_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_30_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_30_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_30_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_30_generateData_Btn_already_pressed = 0;
	 byte A_FSG_50_0_0_30_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_50_0_0_30_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3[97];
		 word Param3_Length;
	 };
	 struct A_FSG_50_0_0_30_ArrayDataStruct A_FSG_50_0_0_30_ArrayDataList[254];
	 const A_FSG_50_0_0_30_ArrayDataList_Length = 254;
	 long A_FSG_50_0_0_30_Data_3_LenList[254];
	 byte A_FSG_50_0_0_30_Data_3_CntList[254];
	 long A_FSG_50_0_0_30_Data_3_SetGet_LenList[254];
	 byte A_FSG_50_0_0_30_Data_3_SetGet_CntList[254];
	 const P_FSG_50_0_0_31_ID = 31;
	 byte P_FSG_50_0_0_31Status_BTN_already_pressed = 0;
	 char gCheckbox31[100] = "checkbox_P_FSG_50_0_0_31";
	 char gErrField31[100] = "errfield_P_FSG_50_0_0_31";
	 byte gP_FSG_50_0_0_31_ErrCode = 1;
	 char gPanel31[100] = "panel_P_FSG_50_0_0_31";
	 const A_FSG_50_0_0_32_ID = 32;
	 byte A_FSG_50_0_0_32Changed_BTN_already_pressed = 0;
	 byte A_FSG_50_0_0_32Status_BTN_already_pressed = 0;
	 char gCheckbox32[100] = "checkbox_A_FSG_50_0_0_32";
	 char gErrField32[100] = "errfield_A_FSG_50_0_0_32";
	 byte gA_FSG_50_0_0_32_ErrCode = 1;
	 char gPanel32[100] = "panel_A_FSG_50_0_0_32";
	 byte A_FSG_50_0_0_32_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_32_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_32_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_32_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_32_generateData_Btn_already_pressed = 0;
	 byte A_FSG_50_0_0_32_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_50_0_0_32_ArrayDataStruct {
		 word Param1;
		 byte Param2[61];
		 word Param2_Length;
		 byte Param3[61];
		 word Param3_Length;
	 };
	 struct A_FSG_50_0_0_32_ArrayDataStruct A_FSG_50_0_0_32_ArrayDataList[65534];
	 const A_FSG_50_0_0_32_ArrayDataList_Length = 65534;
	 long A_FSG_50_0_0_32_Data_2_LenList[65534];
	 byte A_FSG_50_0_0_32_Data_2_CntList[65534];
	 long A_FSG_50_0_0_32_Data_2_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_32_Data_2_SetGet_CntList[65534];
	 long A_FSG_50_0_0_32_Data_3_LenList[65534];
	 byte A_FSG_50_0_0_32_Data_3_CntList[65534];
	 long A_FSG_50_0_0_32_Data_3_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_32_Data_3_SetGet_CntList[65534];
	 const A_FSG_50_0_0_33_ID = 33;
	 byte A_FSG_50_0_0_33Changed_BTN_already_pressed = 0;
	 byte A_FSG_50_0_0_33Status_BTN_already_pressed = 0;
	 char gCheckbox33[100] = "checkbox_A_FSG_50_0_0_33";
	 char gErrField33[100] = "errfield_A_FSG_50_0_0_33";
	 byte gA_FSG_50_0_0_33_ErrCode = 1;
	 char gPanel33[100] = "panel_A_FSG_50_0_0_33";
	 byte A_FSG_50_0_0_33_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_33_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_33_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_33_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_33_generateData_Btn_already_pressed = 0;
	 byte A_FSG_50_0_0_33_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_50_0_0_33_ArrayDataStruct {
		 word Param1;
		 byte Param2[61];
		 word Param2_Length;
		 byte Param3[61];
		 word Param3_Length;
		 byte Param4[61];
		 word Param4_Length;
		 byte Param5[61];
		 word Param5_Length;
		 byte Param6[61];
		 word Param6_Length;
		 byte Param7[22];
		 word Param7_Length;
		 byte Param8[61];
		 word Param8_Length;
		 byte Param9[61];
		 word Param9_Length;
		 byte Param10[61];
		 word Param10_Length;
		 byte Param11;
		 byte Param12;
	 };
	 struct A_FSG_50_0_0_33_ArrayDataStruct A_FSG_50_0_0_33_ArrayDataList[65534];
	 const A_FSG_50_0_0_33_ArrayDataList_Length = 65534;
	 long A_FSG_50_0_0_33_Data_2_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_2_CntList[65534];
	 long A_FSG_50_0_0_33_Data_2_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_2_SetGet_CntList[65534];
	 long A_FSG_50_0_0_33_Data_3_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_3_CntList[65534];
	 long A_FSG_50_0_0_33_Data_3_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_3_SetGet_CntList[65534];
	 long A_FSG_50_0_0_33_Data_4_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_4_CntList[65534];
	 long A_FSG_50_0_0_33_Data_4_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_4_SetGet_CntList[65534];
	 long A_FSG_50_0_0_33_Data_5_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_5_CntList[65534];
	 long A_FSG_50_0_0_33_Data_5_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_5_SetGet_CntList[65534];
	 long A_FSG_50_0_0_33_Data_6_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_6_CntList[65534];
	 long A_FSG_50_0_0_33_Data_6_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_6_SetGet_CntList[65534];
	 long A_FSG_50_0_0_33_Data_7_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_7_CntList[65534];
	 long A_FSG_50_0_0_33_Data_7_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_7_SetGet_CntList[65534];
	 long A_FSG_50_0_0_33_Data_8_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_8_CntList[65534];
	 long A_FSG_50_0_0_33_Data_8_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_8_SetGet_CntList[65534];
	 long A_FSG_50_0_0_33_Data_9_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_9_CntList[65534];
	 long A_FSG_50_0_0_33_Data_9_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_9_SetGet_CntList[65534];
	 long A_FSG_50_0_0_33_Data_10_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_10_CntList[65534];
	 long A_FSG_50_0_0_33_Data_10_SetGet_LenList[65534];
	 byte A_FSG_50_0_0_33_Data_10_SetGet_CntList[65534];
	 const M_FSG_50_0_0_34_ID = 34;
	 byte M_FSG_50_0_0_34Result_BTN_already_pressed = 0;
	 char gCheckbox34[100] = "checkbox_M_FSG_50_0_0_34";
	 char gErrField34[100] = "errfield_M_FSG_50_0_0_34";
	 byte gM_FSG_50_0_0_34_ErrCode = 1;
	 char gPanel34[100] = "panel_M_FSG_50_0_0_34";
	 const M_FSG_50_0_0_35_ID = 35;
	 byte M_FSG_50_0_0_35Result_BTN_already_pressed = 0;
	 char gCheckbox35[100] = "checkbox_M_FSG_50_0_0_35";
	 char gErrField35[100] = "errfield_M_FSG_50_0_0_35";
	 byte gM_FSG_50_0_0_35_ErrCode = 1;
	 char gPanel35[100] = "panel_M_FSG_50_0_0_35";
	 const P_FSG_50_0_0_36_ID = 36;
	 byte P_FSG_50_0_0_36Status_BTN_already_pressed = 0;
	 char gCheckbox36[100] = "checkbox_P_FSG_50_0_0_36";
	 char gErrField36[100] = "errfield_P_FSG_50_0_0_36";
	 byte gP_FSG_50_0_0_36_ErrCode = 1;
	 char gPanel36[100] = "panel_P_FSG_50_0_0_36";
	 const P_FSG_50_0_0_37_ID = 37;
	 byte P_FSG_50_0_0_37Status_BTN_already_pressed = 0;
	 char gCheckbox37[100] = "checkbox_P_FSG_50_0_0_37";
	 char gErrField37[100] = "errfield_P_FSG_50_0_0_37";
	 byte gP_FSG_50_0_0_37_ErrCode = 1;
	 char gPanel37[100] = "panel_P_FSG_50_0_0_37";
	 const P_FSG_50_0_0_38_ID = 38;
	 byte P_FSG_50_0_0_38Status_BTN_already_pressed = 0;
	 char gCheckbox38[100] = "checkbox_P_FSG_50_0_0_38";
	 char gErrField38[100] = "errfield_P_FSG_50_0_0_38";
	 byte gP_FSG_50_0_0_38_ErrCode = 1;
	 char gPanel38[100] = "panel_P_FSG_50_0_0_38";
	 const P_FSG_50_0_0_39_ID = 39;
	 byte P_FSG_50_0_0_39Status_BTN_already_pressed = 0;
	 char gCheckbox39[100] = "checkbox_P_FSG_50_0_0_39";
	 char gErrField39[100] = "errfield_P_FSG_50_0_0_39";
	 byte gP_FSG_50_0_0_39_ErrCode = 1;
	 char gPanel39[100] = "panel_P_FSG_50_0_0_39";
	 const P_FSG_50_0_0_40_ID = 40;
	 byte P_FSG_50_0_0_40Status_BTN_already_pressed = 0;
	 char gCheckbox40[100] = "checkbox_P_FSG_50_0_0_40";
	 char gErrField40[100] = "errfield_P_FSG_50_0_0_40";
	 byte gP_FSG_50_0_0_40_ErrCode = 1;
	 char gPanel40[100] = "panel_P_FSG_50_0_0_40";
	 const M_FSG_50_0_0_41_ID = 41;
	 byte M_FSG_50_0_0_41Result_BTN_already_pressed = 0;
	 char gCheckbox41[100] = "checkbox_M_FSG_50_0_0_41";
	 char gErrField41[100] = "errfield_M_FSG_50_0_0_41";
	 byte gM_FSG_50_0_0_41_ErrCode = 1;
	 char gPanel41[100] = "panel_M_FSG_50_0_0_41";
	 const M_FSG_50_0_0_42_ID = 42;
	 byte M_FSG_50_0_0_42Result_BTN_already_pressed = 0;
	 char gCheckbox42[100] = "checkbox_M_FSG_50_0_0_42";
	 char gErrField42[100] = "errfield_M_FSG_50_0_0_42";
	 byte gM_FSG_50_0_0_42_ErrCode = 1;
	 char gPanel42[100] = "panel_M_FSG_50_0_0_42";
	 const P_FSG_50_0_0_43_ID = 43;
	 byte P_FSG_50_0_0_43Status_BTN_already_pressed = 0;
	 char gCheckbox43[100] = "checkbox_P_FSG_50_0_0_43";
	 char gErrField43[100] = "errfield_P_FSG_50_0_0_43";
	 byte gP_FSG_50_0_0_43_ErrCode = 1;
	 char gPanel43[100] = "panel_P_FSG_50_0_0_43";
	 const P_FSG_50_0_0_44_ID = 44;
	 byte P_FSG_50_0_0_44Status_BTN_already_pressed = 0;
	 char gCheckbox44[100] = "checkbox_P_FSG_50_0_0_44";
	 char gErrField44[100] = "errfield_P_FSG_50_0_0_44";
	 byte gP_FSG_50_0_0_44_ErrCode = 1;
	 char gPanel44[100] = "panel_P_FSG_50_0_0_44";
	 const P_FSG_50_0_0_45_ID = 45;
	 byte P_FSG_50_0_0_45Status_BTN_already_pressed = 0;
	 char gCheckbox45[100] = "checkbox_P_FSG_50_0_0_45";
	 char gErrField45[100] = "errfield_P_FSG_50_0_0_45";
	 byte gP_FSG_50_0_0_45_ErrCode = 1;
	 char gPanel45[100] = "panel_P_FSG_50_0_0_45";
	 const P_FSG_50_0_0_46_ID = 46;
	 byte P_FSG_50_0_0_46Status_BTN_already_pressed = 0;
	 char gCheckbox46[100] = "checkbox_P_FSG_50_0_0_46";
	 char gErrField46[100] = "errfield_P_FSG_50_0_0_46";
	 byte gP_FSG_50_0_0_46_ErrCode = 1;
	 char gPanel46[100] = "panel_P_FSG_50_0_0_46";
	 const P_FSG_50_0_0_47_ID = 47;
	 byte P_FSG_50_0_0_47Status_BTN_already_pressed = 0;
	 char gCheckbox47[100] = "checkbox_P_FSG_50_0_0_47";
	 char gErrField47[100] = "errfield_P_FSG_50_0_0_47";
	 byte gP_FSG_50_0_0_47_ErrCode = 1;
	 char gPanel47[100] = "panel_P_FSG_50_0_0_47";
	 const P_FSG_50_0_0_48_ID = 48;
	 byte P_FSG_50_0_0_48Status_BTN_already_pressed = 0;
	 char gCheckbox48[100] = "checkbox_P_FSG_50_0_0_48";
	 char gErrField48[100] = "errfield_P_FSG_50_0_0_48";
	 byte gP_FSG_50_0_0_48_ErrCode = 1;
	 char gPanel48[100] = "panel_P_FSG_50_0_0_48";
	 const P_FSG_50_0_0_49_ID = 49;
	 byte P_FSG_50_0_0_49Status_BTN_already_pressed = 0;
	 char gCheckbox49[100] = "checkbox_P_FSG_50_0_0_49";
	 char gErrField49[100] = "errfield_P_FSG_50_0_0_49";
	 byte gP_FSG_50_0_0_49_ErrCode = 1;
	 char gPanel49[100] = "panel_P_FSG_50_0_0_49";
	 const P_FSG_50_0_0_50_ID = 50;
	 byte P_FSG_50_0_0_50Status_BTN_already_pressed = 0;
	 char gCheckbox50[100] = "checkbox_P_FSG_50_0_0_50";
	 char gErrField50[100] = "errfield_P_FSG_50_0_0_50";
	 byte gP_FSG_50_0_0_50_ErrCode = 1;
	 char gPanel50[100] = "panel_P_FSG_50_0_0_50";
	 const M_FSG_50_0_0_51_ID = 51;
	 byte M_FSG_50_0_0_51Result_BTN_already_pressed = 0;
	 char gCheckbox51[100] = "checkbox_M_FSG_50_0_0_51";
	 char gErrField51[100] = "errfield_M_FSG_50_0_0_51";
	 byte gM_FSG_50_0_0_51_ErrCode = 1;
	 char gPanel51[100] = "panel_M_FSG_50_0_0_51";
	 const A_FSG_50_0_0_52_ID = 52;
	 byte A_FSG_50_0_0_52Changed_BTN_already_pressed = 0;
	 byte A_FSG_50_0_0_52Status_BTN_already_pressed = 0;
	 char gCheckbox52[100] = "checkbox_A_FSG_50_0_0_52";
	 char gErrField52[100] = "errfield_A_FSG_50_0_0_52";
	 byte gA_FSG_50_0_0_52_ErrCode = 1;
	 char gPanel52[100] = "panel_A_FSG_50_0_0_52";
	 byte A_FSG_50_0_0_52_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_52_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_52_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_52_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_52_generateData_Btn_already_pressed = 0;
	 byte A_FSG_50_0_0_52_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_50_0_0_52_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3;
		 byte Param4;
		 dword Param5;
		 byte Param6;
		 byte Param7[91];
		 word Param7_Length;
		 byte Param8[91];
		 word Param8_Length;
		 byte Param9[91];
		 word Param9_Length;
		 byte Param10[22];
		 word Param10_Length;
	 };
	 struct A_FSG_50_0_0_52_ArrayDataStruct A_FSG_50_0_0_52_ArrayDataList[254];
	 const A_FSG_50_0_0_52_ArrayDataList_Length = 254;
	 long A_FSG_50_0_0_52_Data_7_LenList[254];
	 byte A_FSG_50_0_0_52_Data_7_CntList[254];
	 long A_FSG_50_0_0_52_Data_7_SetGet_LenList[254];
	 byte A_FSG_50_0_0_52_Data_7_SetGet_CntList[254];
	 long A_FSG_50_0_0_52_Data_8_LenList[254];
	 byte A_FSG_50_0_0_52_Data_8_CntList[254];
	 long A_FSG_50_0_0_52_Data_8_SetGet_LenList[254];
	 byte A_FSG_50_0_0_52_Data_8_SetGet_CntList[254];
	 long A_FSG_50_0_0_52_Data_9_LenList[254];
	 byte A_FSG_50_0_0_52_Data_9_CntList[254];
	 long A_FSG_50_0_0_52_Data_9_SetGet_LenList[254];
	 byte A_FSG_50_0_0_52_Data_9_SetGet_CntList[254];
	 long A_FSG_50_0_0_52_Data_10_LenList[254];
	 byte A_FSG_50_0_0_52_Data_10_CntList[254];
	 long A_FSG_50_0_0_52_Data_10_SetGet_LenList[254];
	 byte A_FSG_50_0_0_52_Data_10_SetGet_CntList[254];
	 const P_FSG_50_0_0_53_ID = 53;
	 byte P_FSG_50_0_0_53Status_BTN_already_pressed = 0;
	 char gCheckbox53[100] = "checkbox_P_FSG_50_0_0_53";
	 char gErrField53[100] = "errfield_P_FSG_50_0_0_53";
	 byte gP_FSG_50_0_0_53_ErrCode = 1;
	 char gPanel53[100] = "panel_P_FSG_50_0_0_53";
	 const P_FSG_50_0_0_54_ID = 54;
	 byte P_FSG_50_0_0_54Status_BTN_already_pressed = 0;
	 char gCheckbox54[100] = "checkbox_P_FSG_50_0_0_54";
	 char gErrField54[100] = "errfield_P_FSG_50_0_0_54";
	 byte gP_FSG_50_0_0_54_ErrCode = 1;
	 char gPanel54[100] = "panel_P_FSG_50_0_0_54";
	 const P_FSG_50_0_0_55_ID = 55;
	 byte P_FSG_50_0_0_55Status_BTN_already_pressed = 0;
	 char gCheckbox55[100] = "checkbox_P_FSG_50_0_0_55";
	 char gErrField55[100] = "errfield_P_FSG_50_0_0_55";
	 byte gP_FSG_50_0_0_55_ErrCode = 1;
	 char gPanel55[100] = "panel_P_FSG_50_0_0_55";
	 const P_FSG_50_0_0_56_ID = 56;
	 byte P_FSG_50_0_0_56Status_BTN_already_pressed = 0;
	 char gCheckbox56[100] = "checkbox_P_FSG_50_0_0_56";
	 char gErrField56[100] = "errfield_P_FSG_50_0_0_56";
	 byte gP_FSG_50_0_0_56_ErrCode = 1;
	 char gPanel56[100] = "panel_P_FSG_50_0_0_56";
	 const P_FSG_50_0_0_57_ID = 57;
	 byte P_FSG_50_0_0_57Status_BTN_already_pressed = 0;
	 char gCheckbox57[100] = "checkbox_P_FSG_50_0_0_57";
	 char gErrField57[100] = "errfield_P_FSG_50_0_0_57";
	 byte gP_FSG_50_0_0_57_ErrCode = 1;
	 char gPanel57[100] = "panel_P_FSG_50_0_0_57";
	 const A_FSG_50_0_0_58_ID = 58;
	 byte A_FSG_50_0_0_58Changed_BTN_already_pressed = 0;
	 byte A_FSG_50_0_0_58Status_BTN_already_pressed = 0;
	 char gCheckbox58[100] = "checkbox_A_FSG_50_0_0_58";
	 char gErrField58[100] = "errfield_A_FSG_50_0_0_58";
	 byte gA_FSG_50_0_0_58_ErrCode = 1;
	 char gPanel58[100] = "panel_A_FSG_50_0_0_58";
	 byte A_FSG_50_0_0_58_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_58_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_58_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_58_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_58_generateData_Btn_already_pressed = 0;
	 byte A_FSG_50_0_0_58_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_50_0_0_58_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3[17];
		 word Param3_Length;
		 word Param4;
		 byte Param5[602];
		 word Param5_Length;
	 };
	 struct A_FSG_50_0_0_58_ArrayDataStruct A_FSG_50_0_0_58_ArrayDataList[254];
	 const A_FSG_50_0_0_58_ArrayDataList_Length = 254;
	 long A_FSG_50_0_0_58_Data_3_LenList[254];
	 byte A_FSG_50_0_0_58_Data_3_CntList[254];
	 long A_FSG_50_0_0_58_Data_3_SetGet_LenList[254];
	 byte A_FSG_50_0_0_58_Data_3_SetGet_CntList[254];
	 long A_FSG_50_0_0_58_Data_5_LenList[254];
	 byte A_FSG_50_0_0_58_Data_5_CntList[254];
	 long A_FSG_50_0_0_58_Data_5_SetGet_LenList[254];
	 byte A_FSG_50_0_0_58_Data_5_SetGet_CntList[254];
	 const M_FSG_50_0_0_59_ID = 59;
	 byte M_FSG_50_0_0_59Result_BTN_already_pressed = 0;
	 char gCheckbox59[100] = "checkbox_M_FSG_50_0_0_59";
	 char gErrField59[100] = "errfield_M_FSG_50_0_0_59";
	 byte gM_FSG_50_0_0_59_ErrCode = 1;
	 char gPanel59[100] = "panel_M_FSG_50_0_0_59";
	 const P_FSG_50_0_0_60_ID = 60;
	 byte P_FSG_50_0_0_60Status_BTN_already_pressed = 0;
	 char gCheckbox60[100] = "checkbox_P_FSG_50_0_0_60";
	 char gErrField60[100] = "errfield_P_FSG_50_0_0_60";
	 byte gP_FSG_50_0_0_60_ErrCode = 1;
	 char gPanel60[100] = "panel_P_FSG_50_0_0_60";
	 const A_FSG_50_0_0_61_ID = 61;
	 byte A_FSG_50_0_0_61Changed_BTN_already_pressed = 0;
	 byte A_FSG_50_0_0_61Status_BTN_already_pressed = 0;
	 char gCheckbox61[100] = "checkbox_A_FSG_50_0_0_61";
	 char gErrField61[100] = "errfield_A_FSG_50_0_0_61";
	 byte gA_FSG_50_0_0_61_ErrCode = 1;
	 char gPanel61[100] = "panel_A_FSG_50_0_0_61";
	 byte A_FSG_50_0_0_61_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_61_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_61_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_61_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_61_generateData_Btn_already_pressed = 0;
	 byte A_FSG_50_0_0_61_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_50_0_0_61_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3;
		 byte Param4;
		 byte Param5;
		 byte Param6;
		 byte Param7[17];
		 word Param7_Length;
		 byte Param8;
		 byte Param9;
		 byte Param10;
		 byte Param11;
		 byte Param12;
	 };
	 struct A_FSG_50_0_0_61_ArrayDataStruct A_FSG_50_0_0_61_ArrayDataList[255];
	 const A_FSG_50_0_0_61_ArrayDataList_Length = 255;
	 long A_FSG_50_0_0_61_Data_7_LenList[255];
	 byte A_FSG_50_0_0_61_Data_7_CntList[255];
	 long A_FSG_50_0_0_61_Data_7_SetGet_LenList[255];
	 byte A_FSG_50_0_0_61_Data_7_SetGet_CntList[255];
	 const A_FSG_50_0_0_62_ID = 62;
	 byte A_FSG_50_0_0_62Changed_BTN_already_pressed = 0;
	 byte A_FSG_50_0_0_62Status_BTN_already_pressed = 0;
	 char gCheckbox62[100] = "checkbox_A_FSG_50_0_0_62";
	 char gErrField62[100] = "errfield_A_FSG_50_0_0_62";
	 byte gA_FSG_50_0_0_62_ErrCode = 1;
	 char gPanel62[100] = "panel_A_FSG_50_0_0_62";
	 byte A_FSG_50_0_0_62_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_62_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_62_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_50_0_0_62_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_50_0_0_62_generateData_Btn_already_pressed = 0;
	 byte A_FSG_50_0_0_62_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_50_0_0_62_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3[17];
		 word Param3_Length;
		 word Param4;
		 byte Param5[602];
		 word Param5_Length;
	 };
	 struct A_FSG_50_0_0_62_ArrayDataStruct A_FSG_50_0_0_62_ArrayDataList[254];
	 const A_FSG_50_0_0_62_ArrayDataList_Length = 254;
	 long A_FSG_50_0_0_62_Data_3_LenList[254];
	 byte A_FSG_50_0_0_62_Data_3_CntList[254];
	 long A_FSG_50_0_0_62_Data_3_SetGet_LenList[254];
	 byte A_FSG_50_0_0_62_Data_3_SetGet_CntList[254];
	 long A_FSG_50_0_0_62_Data_5_LenList[254];
	 byte A_FSG_50_0_0_62_Data_5_CntList[254];
	 long A_FSG_50_0_0_62_Data_5_SetGet_LenList[254];
	 byte A_FSG_50_0_0_62_Data_5_SetGet_CntList[254];


	//// End konfigurationsabhýngige Variablen 
	
	/// Begin: Definition der BUS-Schnittstellen
	
// FLEXRAY NOT ENABLED!
	
	// ETHERNET NOT ENABLED! 
	
	//// End Bus Schnittstellen

}

on preStart
{
    char Version[200];
    
    /***** Erzeugen der Ausgabeconsolen *****/  
    gBAP_Trace=writecreate("BAP-Trace");        //write-window for BAP-cummunication
    writeclear(gBAP_Trace);                     //clear BAP-window in write-window
    
    gError_Trace=writecreate("Error");          //error-window for BAP-cummunication
    writeclear(gError_Trace);                   //clear error-window in write-window
    
    writeclear(1);                              //clear CAPL-window in write-window
    
    /**** Versionsstring von DLL holen und auf Bildschirm ausgeben ***/ 
    BAP150_GetVersions(Version, 200);
    writelineEx(gBAP_Trace, 0, "Versionx:%s", Version);
                                            
    NODE_INDEX = BAP150_CreateNode();
    writelineEx(gBAP_Trace, 0, "FSG %d Nodeindex:%d", LSGID, NODE_INDEX);
    
    ReadCommCfgIni();
// FLEXRAY NOT ENABLED!
}

on preStop
{
  WriteCommCfgIni();
}

Split(char bufin[], char delimiter, char bufout1[], char bufout2[])
{
  dword i,j;
  byte found;
  
  i=j=0;
  found = 0;
  while(bufin[i] != '\0' &&
        bufin[i] != '\r' &&
        bufin[i] != '\n')    
  {
    if(found == 0)
    {  
      if(bufin[i] != delimiter)
      {
        bufout1[i] = bufin[i];
      }
      else
      {
        found = 1;
        bufout1[i] = '\0';
      }
    }
    else
    {
      bufout2[j] = bufin[i];
      j++;
    }
    i++;
  }
  bufout1[i] = '\0';
  bufout2[j] = '\0';
}

ReadCommCfgIni()
{
  dword fHandle;
  char buff1[255];
  char buff2[255];
  char buff3[255];
  dword i;

  setFilePath ("\\FSG\\panel", 0);
  fHandle = OpenFileRead ("CommCfg.ini",0);  
  
  if(fHandle !=0)
  {
    i=0;
    while (fileGetString(buff1,elcount(buff1),fHandle)!=0 ) 
    {
      Split(buff1,';',buff2, buff3);
      
      switch(i)
      {
        case 0 :
          putValue(FSG50_0_0_BusType, atol(buff2));
          putValue(FSG50_0_0_Channel, atol(buff3));
          break;
        case 1 :
          putValue(FSG50_0_1_BusType, atol(buff2));
          putValue(FSG50_0_1_Channel, atol(buff3));
          break;
        case 2 :
          putValue(FSG50_0_2_BusType, atol(buff2));
          putValue(FSG50_0_2_Channel, atol(buff3));
          break;
        case 3 :
          putValue(FSG50_0_3_BusType, atol(buff2));
          putValue(FSG50_0_3_Channel, atol(buff3));
          break;
        case 4 :
          putValue(FSG50_0_4_BusType, atol(buff2));
          putValue(FSG50_0_4_Channel, atol(buff3));
          break;
        case 5 :
          putValue(FSG50_0_5_BusType, atol(buff2));
          putValue(FSG50_0_5_Channel, atol(buff3));
          break;
        case 6 :
          putValue(FSG50_0_6_BusType, atol(buff2));
          putValue(FSG50_0_6_Channel, atol(buff3));
          break;
        case 7 :
          putValue(FSG50_0_7_BusType, atol(buff2));
          putValue(FSG50_0_7_Channel, atol(buff3));
          break;
        case 8 :
          putValue(FSG50_3_fileSelectorDbCan, buff2);
          break;
      }
      i++;
    } 
    fileClose (fHandle);    
  }
}

WriteCommCfgIni()
{
  dword fHandle;  
  char buff[255];
  
  setWritePath ("\\FSG\\panel");
  fHandle = OpenFileWrite ("CommCfg.ini",0); 
  
  if(fHandle !=0)
  {
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG50_0_0_BusType), getValue(FSG50_0_0_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG50_0_1_BusType), getValue(FSG50_0_1_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG50_0_2_BusType), getValue(FSG50_0_2_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG50_0_3_BusType), getValue(FSG50_0_3_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG50_0_4_BusType), getValue(FSG50_0_4_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG50_0_5_BusType), getValue(FSG50_0_5_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG50_0_6_BusType), getValue(FSG50_0_6_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG50_0_7_BusType), getValue(FSG50_0_7_Channel));
    filePutString(buff, elCount(buff), fHandle);
    getValue(FSG50_3_fileSelectorDbCan, buff);
    snprintf (buff,elcount(buff),"%s\n",buff);
    filePutString(buff, elCount(buff), fHandle);
    fileClose (fHandle);
  }
}

DisableFctCtrl ()
{
  	EnableControl(panel_name, common_panel_name, 0);
	EnableControl(panel_name,gErrField1,0);
	EnableControl(panel_name,gErrField2,0);
	EnableControl(panel_name,gErrField3,0);
	EnableControl(panel_name,gErrField4,0);
	EnableControl(panel_name,gErrField15,0);
	EnableControl(panel_name,gPanel15,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_15",0);
	EnableControl(panel_name,gErrField16,0);
	EnableControl(panel_name,gPanel16,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_16",0);
	EnableControl(panel_name,gErrField17,0);
	EnableControl(panel_name,gPanel17,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_17",0);
	EnableControl(panel_name,gErrField18,0);
	EnableControl(panel_name,gPanel18,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_18",0);
	EnableControl(panel_name,gErrField19,0);
	EnableControl(panel_name,gPanel19,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_19",0);
	EnableControl(panel_name,gErrField20,0);
	EnableControl(panel_name,gPanel20,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_20",0);
	EnableControl(panel_name,gErrField21,0);
	EnableControl(panel_name,gPanel21,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_21",0);
	EnableControl(panel_name,gErrField22,0);
	EnableControl(panel_name,gPanel22,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_22",0);
	EnableControl(panel_name,gErrField23,0);
	EnableControl(panel_name,gPanel23,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_23",0);
	EnableControl(panel_name,gErrField24,0);
	EnableControl(panel_name,gPanel24,0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_24",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Status",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_24_SetGet",0);
	EnableControl(panel_name,gErrField25,0);
	EnableControl(panel_name,gPanel25,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_25",0);
	EnableControl(panel_name,gErrField26,0);
	EnableControl(panel_name,gPanel26,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_26",0);
	EnableControl(panel_name,gErrField27,0);
	EnableControl(panel_name,gPanel27,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_27",0);
	EnableControl(panel_name,gErrField28,0);
	EnableControl(panel_name,gPanel28,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_28",0);
	EnableControl(panel_name,gErrField29,0);
	EnableControl(panel_name,gPanel29,0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_29",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Status",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_29_SetGet",0);
	EnableControl(panel_name,gErrField30,0);
	EnableControl(panel_name,gPanel30,0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_30",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Status",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_30_SetGet",0);
	EnableControl(panel_name,gErrField31,0);
	EnableControl(panel_name,gPanel31,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_31",0);
	EnableControl(panel_name,gErrField32,0);
	EnableControl(panel_name,gPanel32,0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_32",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Status",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_32_SetGet",0);
	EnableControl(panel_name,gErrField33,0);
	EnableControl(panel_name,gPanel33,0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_33",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Status",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_33_SetGet",0);
	EnableControl(panel_name,gErrField34,0);
	EnableControl(panel_name,gPanel34,0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Result",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Start",0);
	EnableControl(panel_name,gErrField35,0);
	EnableControl(panel_name,gPanel35,0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Result",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Start",0);
	EnableControl(panel_name,gErrField36,0);
	EnableControl(panel_name,gPanel36,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_36",0);
	EnableControl(panel_name,gErrField37,0);
	EnableControl(panel_name,gPanel37,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_37",0);
	EnableControl(panel_name,gErrField38,0);
	EnableControl(panel_name,gPanel38,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_38",0);
	EnableControl(panel_name,gErrField39,0);
	EnableControl(panel_name,gPanel39,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_39",0);
	EnableControl(panel_name,gErrField40,0);
	EnableControl(panel_name,gPanel40,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_40",0);
	EnableControl(panel_name,gErrField41,0);
	EnableControl(panel_name,gPanel41,0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Result",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Start",0);
	EnableControl(panel_name,gErrField42,0);
	EnableControl(panel_name,gPanel42,0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Result",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Start",0);
	EnableControl(panel_name,gErrField43,0);
	EnableControl(panel_name,gPanel43,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_43",0);
	EnableControl(panel_name,gErrField44,0);
	EnableControl(panel_name,gPanel44,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_44",0);
	EnableControl(panel_name,gErrField45,0);
	EnableControl(panel_name,gPanel45,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_45",0);
	EnableControl(panel_name,gErrField46,0);
	EnableControl(panel_name,gPanel46,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_46",0);
	EnableControl(panel_name,gErrField47,0);
	EnableControl(panel_name,gPanel47,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_47",0);
	EnableControl(panel_name,gErrField48,0);
	EnableControl(panel_name,gPanel48,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_48",0);
	EnableControl(panel_name,gErrField49,0);
	EnableControl(panel_name,gPanel49,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_49",0);
	EnableControl(panel_name,gErrField50,0);
	EnableControl(panel_name,gPanel50,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_50",0);
	EnableControl(panel_name,gErrField51,0);
	EnableControl(panel_name,gPanel51,0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Result",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Start",0);
	EnableControl(panel_name,gErrField52,0);
	EnableControl(panel_name,gPanel52,0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_52",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Status",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_52_SetGet",0);
	EnableControl(panel_name,gErrField53,0);
	EnableControl(panel_name,gPanel53,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_53",0);
	EnableControl(panel_name,gErrField54,0);
	EnableControl(panel_name,gPanel54,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_54",0);
	EnableControl(panel_name,gErrField55,0);
	EnableControl(panel_name,gPanel55,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_55",0);
	EnableControl(panel_name,gErrField56,0);
	EnableControl(panel_name,gPanel56,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_56",0);
	EnableControl(panel_name,gErrField57,0);
	EnableControl(panel_name,gPanel57,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_57",0);
	EnableControl(panel_name,gErrField58,0);
	EnableControl(panel_name,gPanel58,0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_58",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Status",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_58_SetGet",0);
	EnableControl(panel_name,gErrField59,0);
	EnableControl(panel_name,gPanel59,0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Result",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Start",0);
	EnableControl(panel_name,gErrField60,0);
	EnableControl(panel_name,gPanel60,0);
	EnableControl(panel_name,"panel_P_FSG_50_0_0_60",0);
	EnableControl(panel_name,gErrField61,0);
	EnableControl(panel_name,gPanel61,0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_61",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Status",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_61_SetGet",0);
	EnableControl(panel_name,gErrField62,0);
	EnableControl(panel_name,gPanel62,0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_62",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Status",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_62_SetGet",0);

}

EnableFctCtrl ()
{
  	EnableControl(panel_name, common_panel_name, 1);
	if(getValue(P_FSG_50_0_0_15_FctLstItemEn)){
		 EnableControl(panel_name,gPanel15,1);
		 EnableControl(panel_name,gErrField15,1);
	}
	if(getValue(P_FSG_50_0_0_16_FctLstItemEn)){
		 EnableControl(panel_name,gPanel16,1);
		 EnableControl(panel_name,gErrField16,1);
	}
	if(getValue(P_FSG_50_0_0_17_FctLstItemEn)){
		 EnableControl(panel_name,gPanel17,1);
		 EnableControl(panel_name,gErrField17,1);
	}
	if(getValue(P_FSG_50_0_0_18_FctLstItemEn)){
		 EnableControl(panel_name,gPanel18,1);
		 EnableControl(panel_name,gErrField18,1);
	}
	if(getValue(P_FSG_50_0_0_19_FctLstItemEn)){
		 EnableControl(panel_name,gPanel19,1);
		 EnableControl(panel_name,gErrField19,1);
	}
	if(getValue(P_FSG_50_0_0_20_FctLstItemEn)){
		 EnableControl(panel_name,gPanel20,1);
		 EnableControl(panel_name,gErrField20,1);
	}
	if(getValue(P_FSG_50_0_0_21_FctLstItemEn)){
		 EnableControl(panel_name,gPanel21,1);
		 EnableControl(panel_name,gErrField21,1);
	}
	if(getValue(P_FSG_50_0_0_22_FctLstItemEn)){
		 EnableControl(panel_name,gPanel22,1);
		 EnableControl(panel_name,gErrField22,1);
	}
	if(getValue(P_FSG_50_0_0_23_FctLstItemEn)){
		 EnableControl(panel_name,gPanel23,1);
		 EnableControl(panel_name,gErrField23,1);
	}
	if(getValue(A_FSG_50_0_0_24_FctLstItemEn)){
		 EnableControl(panel_name,gPanel24,1);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Status",1);
		 EnableControl(panel_name,gErrField24,1);
	}
	if(getValue(P_FSG_50_0_0_25_FctLstItemEn)){
		 EnableControl(panel_name,gPanel25,1);
		 EnableControl(panel_name,gErrField25,1);
	}
	if(getValue(P_FSG_50_0_0_26_FctLstItemEn)){
		 EnableControl(panel_name,gPanel26,1);
		 EnableControl(panel_name,gErrField26,1);
	}
	if(getValue(P_FSG_50_0_0_27_FctLstItemEn)){
		 EnableControl(panel_name,gPanel27,1);
		 EnableControl(panel_name,gErrField27,1);
	}
	if(getValue(P_FSG_50_0_0_28_FctLstItemEn)){
		 EnableControl(panel_name,gPanel28,1);
		 EnableControl(panel_name,gErrField28,1);
	}
	if(getValue(A_FSG_50_0_0_29_FctLstItemEn)){
		 EnableControl(panel_name,gPanel29,1);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Status",1);
		 EnableControl(panel_name,gErrField29,1);
	}
	if(getValue(A_FSG_50_0_0_30_FctLstItemEn)){
		 EnableControl(panel_name,gPanel30,1);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Status",1);
		 EnableControl(panel_name,gErrField30,1);
	}
	if(getValue(P_FSG_50_0_0_31_FctLstItemEn)){
		 EnableControl(panel_name,gPanel31,1);
		 EnableControl(panel_name,gErrField31,1);
	}
	if(getValue(A_FSG_50_0_0_32_FctLstItemEn)){
		 EnableControl(panel_name,gPanel32,1);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Status",1);
		 EnableControl(panel_name,gErrField32,1);
	}
	if(getValue(A_FSG_50_0_0_33_FctLstItemEn)){
		 EnableControl(panel_name,gPanel33,1);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Status",1);
		 EnableControl(panel_name,gErrField33,1);
	}
	if(getValue(M_FSG_50_0_0_34_FctLstItemEn)){
		 EnableControl(panel_name,gPanel34,1);
		 EnableControl(panel_name,gErrField34,1);
	}
	if(getValue(M_FSG_50_0_0_35_FctLstItemEn)){
		 EnableControl(panel_name,gPanel35,1);
		 EnableControl(panel_name,gErrField35,1);
	}
	if(getValue(P_FSG_50_0_0_36_FctLstItemEn)){
		 EnableControl(panel_name,gPanel36,1);
		 EnableControl(panel_name,gErrField36,1);
	}
	if(getValue(P_FSG_50_0_0_37_FctLstItemEn)){
		 EnableControl(panel_name,gPanel37,1);
		 EnableControl(panel_name,gErrField37,1);
	}
	if(getValue(P_FSG_50_0_0_38_FctLstItemEn)){
		 EnableControl(panel_name,gPanel38,1);
		 EnableControl(panel_name,gErrField38,1);
	}
	if(getValue(P_FSG_50_0_0_39_FctLstItemEn)){
		 EnableControl(panel_name,gPanel39,1);
		 EnableControl(panel_name,gErrField39,1);
	}
	if(getValue(P_FSG_50_0_0_40_FctLstItemEn)){
		 EnableControl(panel_name,gPanel40,1);
		 EnableControl(panel_name,gErrField40,1);
	}
	if(getValue(M_FSG_50_0_0_41_FctLstItemEn)){
		 EnableControl(panel_name,gPanel41,1);
		 EnableControl(panel_name,gErrField41,1);
	}
	if(getValue(M_FSG_50_0_0_42_FctLstItemEn)){
		 EnableControl(panel_name,gPanel42,1);
		 EnableControl(panel_name,gErrField42,1);
	}
	if(getValue(P_FSG_50_0_0_43_FctLstItemEn)){
		 EnableControl(panel_name,gPanel43,1);
		 EnableControl(panel_name,gErrField43,1);
	}
	if(getValue(P_FSG_50_0_0_44_FctLstItemEn)){
		 EnableControl(panel_name,gPanel44,1);
		 EnableControl(panel_name,gErrField44,1);
	}
	if(getValue(P_FSG_50_0_0_45_FctLstItemEn)){
		 EnableControl(panel_name,gPanel45,1);
		 EnableControl(panel_name,gErrField45,1);
	}
	if(getValue(P_FSG_50_0_0_46_FctLstItemEn)){
		 EnableControl(panel_name,gPanel46,1);
		 EnableControl(panel_name,gErrField46,1);
	}
	if(getValue(P_FSG_50_0_0_47_FctLstItemEn)){
		 EnableControl(panel_name,gPanel47,1);
		 EnableControl(panel_name,gErrField47,1);
	}
	if(getValue(P_FSG_50_0_0_48_FctLstItemEn)){
		 EnableControl(panel_name,gPanel48,1);
		 EnableControl(panel_name,gErrField48,1);
	}
	if(getValue(P_FSG_50_0_0_49_FctLstItemEn)){
		 EnableControl(panel_name,gPanel49,1);
		 EnableControl(panel_name,gErrField49,1);
	}
	if(getValue(P_FSG_50_0_0_50_FctLstItemEn)){
		 EnableControl(panel_name,gPanel50,1);
		 EnableControl(panel_name,gErrField50,1);
	}
	if(getValue(M_FSG_50_0_0_51_FctLstItemEn)){
		 EnableControl(panel_name,gPanel51,1);
		 EnableControl(panel_name,gErrField51,1);
	}
	if(getValue(A_FSG_50_0_0_52_FctLstItemEn)){
		 EnableControl(panel_name,gPanel52,1);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Status",1);
		 EnableControl(panel_name,gErrField52,1);
	}
	if(getValue(P_FSG_50_0_0_53_FctLstItemEn)){
		 EnableControl(panel_name,gPanel53,1);
		 EnableControl(panel_name,gErrField53,1);
	}
	if(getValue(P_FSG_50_0_0_54_FctLstItemEn)){
		 EnableControl(panel_name,gPanel54,1);
		 EnableControl(panel_name,gErrField54,1);
	}
	if(getValue(P_FSG_50_0_0_55_FctLstItemEn)){
		 EnableControl(panel_name,gPanel55,1);
		 EnableControl(panel_name,gErrField55,1);
	}
	if(getValue(P_FSG_50_0_0_56_FctLstItemEn)){
		 EnableControl(panel_name,gPanel56,1);
		 EnableControl(panel_name,gErrField56,1);
	}
	if(getValue(P_FSG_50_0_0_57_FctLstItemEn)){
		 EnableControl(panel_name,gPanel57,1);
		 EnableControl(panel_name,gErrField57,1);
	}
	if(getValue(A_FSG_50_0_0_58_FctLstItemEn)){
		 EnableControl(panel_name,gPanel58,1);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Status",1);
		 EnableControl(panel_name,gErrField58,1);
	}
	if(getValue(M_FSG_50_0_0_59_FctLstItemEn)){
		 EnableControl(panel_name,gPanel59,1);
		 EnableControl(panel_name,gErrField59,1);
	}
	if(getValue(P_FSG_50_0_0_60_FctLstItemEn)){
		 EnableControl(panel_name,gPanel60,1);
		 EnableControl(panel_name,gErrField60,1);
	}
	if(getValue(A_FSG_50_0_0_61_FctLstItemEn)){
		 EnableControl(panel_name,gPanel61,1);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Status",1);
		 EnableControl(panel_name,gErrField61,1);
	}
	if(getValue(A_FSG_50_0_0_62_FctLstItemEn)){
		 EnableControl(panel_name,gPanel62,1);
	EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Status",1);
		 EnableControl(panel_name,gErrField62,1);
	}

}

DisableConfigCtrl ()
{
  	EnableControl(panel_name, bapconfig_panel_name, 0);
	EnableControl(panel_name, bapconfig_panel_name, 0);
	EnableControl(panel_name, "panel10_edit", 0);
//	EnableControl(panel_name,gCheckbox1,0);
//	if(!getValue(C_FSG_50_0_0_1_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox1,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox2,0);
//	if(!getValue(P_FSG_50_0_0_2_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox2,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox3,0);
//	if(!getValue(P_FSG_50_0_0_3_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox3,MakeRGB(200,200,200));
//	}
	EnableControl(panel_name, "panel_P_FSG_50_0_0_4", 0);
//	EnableControl(panel_name,gCheckbox4,0);
//	if(!getValue(P_FSG_50_0_0_4_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox4,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox15,0);
//	if(!getValue(P_FSG_50_0_0_15_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox15,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox16,0);
//	if(!getValue(P_FSG_50_0_0_16_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox16,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox17,0);
//	if(!getValue(P_FSG_50_0_0_17_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox17,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox18,0);
//	if(!getValue(P_FSG_50_0_0_18_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox18,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox19,0);
//	if(!getValue(P_FSG_50_0_0_19_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox19,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox20,0);
//	if(!getValue(P_FSG_50_0_0_20_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox20,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox21,0);
//	if(!getValue(P_FSG_50_0_0_21_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox21,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox22,0);
//	if(!getValue(P_FSG_50_0_0_22_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox22,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox23,0);
//	if(!getValue(P_FSG_50_0_0_23_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox23,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox24,0);
//	if(!getValue(A_FSG_50_0_0_24_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox24,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox25,0);
//	if(!getValue(P_FSG_50_0_0_25_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox25,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox26,0);
//	if(!getValue(P_FSG_50_0_0_26_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox26,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox27,0);
//	if(!getValue(P_FSG_50_0_0_27_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox27,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox28,0);
//	if(!getValue(P_FSG_50_0_0_28_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox28,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox29,0);
//	if(!getValue(A_FSG_50_0_0_29_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox29,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox30,0);
//	if(!getValue(A_FSG_50_0_0_30_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox30,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox31,0);
//	if(!getValue(P_FSG_50_0_0_31_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox31,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox32,0);
//	if(!getValue(A_FSG_50_0_0_32_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox32,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox33,0);
//	if(!getValue(A_FSG_50_0_0_33_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox33,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox34,0);
//	if(!getValue(M_FSG_50_0_0_34_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox34,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox35,0);
//	if(!getValue(M_FSG_50_0_0_35_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox35,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox36,0);
//	if(!getValue(P_FSG_50_0_0_36_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox36,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox37,0);
//	if(!getValue(P_FSG_50_0_0_37_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox37,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox38,0);
//	if(!getValue(P_FSG_50_0_0_38_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox38,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox39,0);
//	if(!getValue(P_FSG_50_0_0_39_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox39,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox40,0);
//	if(!getValue(P_FSG_50_0_0_40_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox40,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox41,0);
//	if(!getValue(M_FSG_50_0_0_41_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox41,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox42,0);
//	if(!getValue(M_FSG_50_0_0_42_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox42,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox43,0);
//	if(!getValue(P_FSG_50_0_0_43_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox43,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox44,0);
//	if(!getValue(P_FSG_50_0_0_44_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox44,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox45,0);
//	if(!getValue(P_FSG_50_0_0_45_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox45,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox46,0);
//	if(!getValue(P_FSG_50_0_0_46_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox46,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox47,0);
//	if(!getValue(P_FSG_50_0_0_47_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox47,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox48,0);
//	if(!getValue(P_FSG_50_0_0_48_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox48,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox49,0);
//	if(!getValue(P_FSG_50_0_0_49_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox49,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox50,0);
//	if(!getValue(P_FSG_50_0_0_50_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox50,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox51,0);
//	if(!getValue(M_FSG_50_0_0_51_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox51,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox52,0);
//	if(!getValue(A_FSG_50_0_0_52_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox52,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox53,0);
//	if(!getValue(P_FSG_50_0_0_53_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox53,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox54,0);
//	if(!getValue(P_FSG_50_0_0_54_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox54,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox55,0);
//	if(!getValue(P_FSG_50_0_0_55_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox55,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox56,0);
//	if(!getValue(P_FSG_50_0_0_56_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox56,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox57,0);
//	if(!getValue(P_FSG_50_0_0_57_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox57,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox58,0);
//	if(!getValue(A_FSG_50_0_0_58_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox58,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox59,0);
//	if(!getValue(M_FSG_50_0_0_59_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox59,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox60,0);
//	if(!getValue(P_FSG_50_0_0_60_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox60,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox61,0);
//	if(!getValue(A_FSG_50_0_0_61_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox61,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox62,0);
//	if(!getValue(A_FSG_50_0_0_62_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox62,MakeRGB(200,200,200));
//	}

}

EnableConfigCtrl ()
{
  	EnableControl(panel_name, bapconfig_panel_name, 1);
	EnableControl(panel_name, "panel10_edit", 1);
	if(getValue(C_FSG_50_0_0_1_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox1, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox1, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_2_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox2, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox2, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_3_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox3, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox3, MakeRGB(250,0,0));
	}
	EnableControl(panel_name, "panel_P_FSG_50_0_0_4", 1);
	if(getValue(P_FSG_50_0_0_4_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox4, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox4, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_15_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_15",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_15",1);
		setControlForeColor(panel_name, gCheckbox15, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_15",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_15",0);
		setControlForeColor(panel_name, gCheckbox15, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_16_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_16",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_16",1);
		setControlForeColor(panel_name, gCheckbox16, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_16",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_16",0);
		setControlForeColor(panel_name, gCheckbox16, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_17_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_17",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_17",1);
		setControlForeColor(panel_name, gCheckbox17, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_17",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_17",0);
		setControlForeColor(panel_name, gCheckbox17, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_18_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_18",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_18",1);
		setControlForeColor(panel_name, gCheckbox18, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_18",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_18",0);
		setControlForeColor(panel_name, gCheckbox18, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_19_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_19",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_19",1);
		setControlForeColor(panel_name, gCheckbox19, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_19",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_19",0);
		setControlForeColor(panel_name, gCheckbox19, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_20_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_20",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_20",1);
		setControlForeColor(panel_name, gCheckbox20, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_20",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_20",0);
		setControlForeColor(panel_name, gCheckbox20, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_21_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_21",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_21",1);
		setControlForeColor(panel_name, gCheckbox21, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_21",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_21",0);
		setControlForeColor(panel_name, gCheckbox21, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_22_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_22",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_22",1);
		setControlForeColor(panel_name, gCheckbox22, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_22",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_22",0);
		setControlForeColor(panel_name, gCheckbox22, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_23_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_23",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_23",1);
		setControlForeColor(panel_name, gCheckbox23, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_23",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_23",0);
		setControlForeColor(panel_name, gCheckbox23, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_50_0_0_24_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_24",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_24",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_24_SetGet",1);
		setControlForeColor(panel_name, gCheckbox24, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_24",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_24",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_24_SetGet",0);
		setControlForeColor(panel_name, gCheckbox24, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_25_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_25",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_25",1);
		setControlForeColor(panel_name, gCheckbox25, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_25",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_25",0);
		setControlForeColor(panel_name, gCheckbox25, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_26_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_26",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_26",1);
		setControlForeColor(panel_name, gCheckbox26, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_26",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_26",0);
		setControlForeColor(panel_name, gCheckbox26, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_27_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_27",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_27",1);
		setControlForeColor(panel_name, gCheckbox27, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_27",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_27",0);
		setControlForeColor(panel_name, gCheckbox27, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_28_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_28",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_28",1);
		setControlForeColor(panel_name, gCheckbox28, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_28",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_28",0);
		setControlForeColor(panel_name, gCheckbox28, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_50_0_0_29_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_29",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_29",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_29_SetGet",1);
		setControlForeColor(panel_name, gCheckbox29, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_29",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_29",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_29_SetGet",0);
		setControlForeColor(panel_name, gCheckbox29, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_50_0_0_30_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_30",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_30",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_30_SetGet",1);
		setControlForeColor(panel_name, gCheckbox30, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_30",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_30",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_30_SetGet",0);
		setControlForeColor(panel_name, gCheckbox30, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_31_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_31",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_31",1);
		setControlForeColor(panel_name, gCheckbox31, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_31",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_31",0);
		setControlForeColor(panel_name, gCheckbox31, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_50_0_0_32_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_32",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_32",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_32_SetGet",1);
		setControlForeColor(panel_name, gCheckbox32, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_32",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_32",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_32_SetGet",0);
		setControlForeColor(panel_name, gCheckbox32, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_50_0_0_33_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_33",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_33",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_33_SetGet",1);
		setControlForeColor(panel_name, gCheckbox33, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_33",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_33",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_33_SetGet",0);
		setControlForeColor(panel_name, gCheckbox33, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_50_0_0_34_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_34",1);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_34",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Start",1);
		setControlForeColor(panel_name, gCheckbox34, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_34",0);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_34",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Start",0);
		setControlForeColor(panel_name, gCheckbox34, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_50_0_0_35_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_35",1);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_35",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Start",1);
		setControlForeColor(panel_name, gCheckbox35, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_35",0);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_35",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Start",0);
		setControlForeColor(panel_name, gCheckbox35, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_36_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_36",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_36",1);
		setControlForeColor(panel_name, gCheckbox36, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_36",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_36",0);
		setControlForeColor(panel_name, gCheckbox36, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_37_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_37",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_37",1);
		setControlForeColor(panel_name, gCheckbox37, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_37",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_37",0);
		setControlForeColor(panel_name, gCheckbox37, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_38_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_38",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_38",1);
		setControlForeColor(panel_name, gCheckbox38, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_38",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_38",0);
		setControlForeColor(panel_name, gCheckbox38, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_39_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_39",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_39",1);
		setControlForeColor(panel_name, gCheckbox39, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_39",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_39",0);
		setControlForeColor(panel_name, gCheckbox39, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_40_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_40",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_40",1);
		setControlForeColor(panel_name, gCheckbox40, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_40",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_40",0);
		setControlForeColor(panel_name, gCheckbox40, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_50_0_0_41_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_41",1);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_41",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Start",1);
		setControlForeColor(panel_name, gCheckbox41, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_41",0);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_41",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Start",0);
		setControlForeColor(panel_name, gCheckbox41, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_50_0_0_42_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_42",1);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_42",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Start",1);
		setControlForeColor(panel_name, gCheckbox42, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_42",0);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_42",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Start",0);
		setControlForeColor(panel_name, gCheckbox42, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_43_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_43",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_43",1);
		setControlForeColor(panel_name, gCheckbox43, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_43",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_43",0);
		setControlForeColor(panel_name, gCheckbox43, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_44_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_44",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_44",1);
		setControlForeColor(panel_name, gCheckbox44, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_44",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_44",0);
		setControlForeColor(panel_name, gCheckbox44, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_45_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_45",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_45",1);
		setControlForeColor(panel_name, gCheckbox45, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_45",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_45",0);
		setControlForeColor(panel_name, gCheckbox45, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_46_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_46",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_46",1);
		setControlForeColor(panel_name, gCheckbox46, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_46",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_46",0);
		setControlForeColor(panel_name, gCheckbox46, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_47_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_47",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_47",1);
		setControlForeColor(panel_name, gCheckbox47, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_47",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_47",0);
		setControlForeColor(panel_name, gCheckbox47, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_48_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_48",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_48",1);
		setControlForeColor(panel_name, gCheckbox48, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_48",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_48",0);
		setControlForeColor(panel_name, gCheckbox48, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_49_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_49",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_49",1);
		setControlForeColor(panel_name, gCheckbox49, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_49",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_49",0);
		setControlForeColor(panel_name, gCheckbox49, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_50_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_50",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_50",1);
		setControlForeColor(panel_name, gCheckbox50, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_50",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_50",0);
		setControlForeColor(panel_name, gCheckbox50, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_50_0_0_51_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_51",1);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_51",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Start",1);
		setControlForeColor(panel_name, gCheckbox51, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_51",0);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_51",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Start",0);
		setControlForeColor(panel_name, gCheckbox51, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_50_0_0_52_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_52",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_52",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_52_SetGet",1);
		setControlForeColor(panel_name, gCheckbox52, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_52",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_52",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_52_SetGet",0);
		setControlForeColor(panel_name, gCheckbox52, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_53_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_53",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_53",1);
		setControlForeColor(panel_name, gCheckbox53, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_53",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_53",0);
		setControlForeColor(panel_name, gCheckbox53, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_54_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_54",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_54",1);
		setControlForeColor(panel_name, gCheckbox54, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_54",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_54",0);
		setControlForeColor(panel_name, gCheckbox54, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_55_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_55",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_55",1);
		setControlForeColor(panel_name, gCheckbox55, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_55",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_55",0);
		setControlForeColor(panel_name, gCheckbox55, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_56_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_56",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_56",1);
		setControlForeColor(panel_name, gCheckbox56, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_56",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_56",0);
		setControlForeColor(panel_name, gCheckbox56, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_57_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_57",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_57",1);
		setControlForeColor(panel_name, gCheckbox57, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_57",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_57",0);
		setControlForeColor(panel_name, gCheckbox57, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_50_0_0_58_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_58",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_58",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_58_SetGet",1);
		setControlForeColor(panel_name, gCheckbox58, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_58",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_58",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_58_SetGet",0);
		setControlForeColor(panel_name, gCheckbox58, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_50_0_0_59_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_59",1);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_59",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Start",1);
		setControlForeColor(panel_name, gCheckbox59, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_50_0_0_59",0);
		EnableControl(panel_name,"errfield_M_FSG_50_0_0_59",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Start",0);
		setControlForeColor(panel_name, gCheckbox59, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_50_0_0_60_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_60",1);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_60",1);
		setControlForeColor(panel_name, gCheckbox60, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_50_0_0_60",0);
		EnableControl(panel_name,"errfield_P_FSG_50_0_0_60",0);
		setControlForeColor(panel_name, gCheckbox60, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_50_0_0_61_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_61",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_61",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_61_SetGet",1);
		setControlForeColor(panel_name, gCheckbox61, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_61",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_61",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_61_SetGet",0);
		setControlForeColor(panel_name, gCheckbox61, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_50_0_0_62_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_62",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_62",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_62_SetGet",1);
		setControlForeColor(panel_name, gCheckbox62, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_50_0_0_62",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_50_0_0_62",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_50_0_0_62_SetGet",0);
		setControlForeColor(panel_name, gCheckbox62, MakeRGB(250,0,0));
	}

}

resetErrfieldColor()
{
  	setControlBackColor(panel_name, "errfield_C_FSG_50_0_0_1", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_2", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_3", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_4", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_15", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_16", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_17", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_18", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_19", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_20", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_21", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_22", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_23", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_24", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_25", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_26", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_27", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_28", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_29", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_30", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_31", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_32", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_33", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_34", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_35", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_36", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_37", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_38", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_39", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_40", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_41", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_42", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_43", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_44", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_45", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_46", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_47", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_48", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_49", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_50", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_51", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_52", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_53", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_54", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_55", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_56", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_57", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_58", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_59", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_60", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_61", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_62", MakeRGB(255,255,255));

}

CANoe_Shutdown ()
{
	// Timer: cancel real CAN-communication timer
	canceltimer(TaskTimer);
	// Ruecksetzen der Hintergrundfarbe der Error-Felder
	resetErrfieldColor();
	// Deaktivierung aller Panel Elemente 
	EnableConfigCtrl();
}

on timer TaskTimer
{
	/*** Aufruf des BAP Task in DLL fuer NODE_INDEX ***/
	BAP150_Task(NODE_INDEX);	

	/*** Pollen ueber die anstehenden Indications (Lesen aus DLL, Auslesen eines Puffers der DLL) ***/
	BAP_DLL_Indication();	
	
	/*** Pollen ueber die anstehenden Requests (Schreiben in DLL, dort werden evt. Sendeauftraege gesetzt) ***/
	BAP_DLL_Request();
	
	/*** Abarbeiten der ausstehenden Sendeauftraege innerhalb der BAP DLL und Versenden ueber CANoe ***/
	if (getValue(KCAN__NMH_ICAS1_Gateway_CommActive))
	{
		BAP_CAN_TX_Request();
	}

	BAP_DLL_SetRxData();

	/*** Retriggern des Timers mit 10 ms ***/
	setTimer(TaskTimer, TaskTime); // @TODO bei anderer Taskzeit muss hier modifiziert werden
}


BAP_DLL_SetRxData()
{
}


BAP_DLL_Indication()	//function to get received BAP-data from DLL (at BAL-interface)
{
	int length, datalength, temp;
  dword i;
	dword Indication_header[6];					// indication header from DLL
	byte BAP_data_type;

	// init local variables
	length=0;
	datalength=0;
	temp=0;
	BAP_data_type=0;

	for(i = 0; i < 6; i++)
		Indication_header[i]=0;

  // BAP-Stack needs this information for successful BAP150_GetIndication 
	Indication_header[4]=BAP_buffer_size;

	while (BAP150_GetInd(NODE_INDEX, Indication_header, gBAP_Indication_data) == 0)
	{		
		//read header and write in global variable
		for (i = 0; i < 6; i++) {
			gBAP_Indication_header[i]=Indication_header[i];	
		}
		// Verarbeiten der Indication
		Process_Current_Indication();

		// Vorbereiten fuer naechsten Durchlauf 
		Indication_header[4]=BAP_buffer_size;
	} 
}

setBitInFctList(word fctid, byte fctList[])
{
    byte byteNo ;
    byte bitno ;
    byte fctValue ;

    byteNo = fctid / 8;
    bitno = fctid % 8;
    fctValue = 0x80 >> bitno;
    fctList[byteNo] |= fctValue;
}

float round (float value, float step)
{
	return _floor(value / step + 0.5) * step;
}

ChangeConfig(long paramIndex,long config[])
{

        byte temp ;
	if(gBAP_Init)
	{
	    temp = BAP150_ChangeConfig(NODE_INDEX, paramIndex, config);
	}
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP150_ChangeConfig for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP150_ChangeConfig error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        
}

PrintIndicationError(char reason[])
{
	writelineEx(gError_Trace, 0, "%s - %s lsgId:%d fctid:%d indType:%d dataType:%s",
		reason, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]]);
}

initBapConfig()
{
        long config[3];
    config[0] = LSGID;
    config[1] = 0;
    config[2] = getValue(BAPCFG_FSG_50_0_0_ProtocolMajor);
    ChangeConfig(0x0012,config);
    config[2] = getValue(BAPCFG_FSG_50_0_0_ProtocolMinor);
    ChangeConfig(0x0013,config);
    config[2] = getValue(BAPCFG_FSG_50_0_0_LsgClassMajor);
    ChangeConfig(0x0010,config);
    config[2] = getValue(BAPCFG_FSG_50_0_0_LsgClassMinor);
    ChangeConfig(0x0011,config);
    config[2] = getValue(BAPCFG_FSG_50_0_0_DFMajor);
    ChangeConfig(0x0014,config);
    config[2] = getValue(BAPCFG_FSG_50_0_0_DFMinor);
    ChangeConfig(0x0015,config);
    
}

initFctList()
{
    byte fctList[8]={0,0,0,0,0,0,0,0};
    int i;
    dword request[6];
    byte errorCode;

    fctList[0]=0;
    fctList[1]=0;
    fctList[2]=0;
    fctList[3]=0;
    fctList[4]=0;
    fctList[5]=0;
    fctList[6]=0;
    fctList[7]=0;

    /*if(getValue(P_FSG_44_0_13_FunctionListId))
    {
        setBitInFctList(P_FSG_44_0_13_ID, fctList);
    }*/
           if(getValue(A_FSG_50_0_0_29_FctLstItemEn))
       {
           setBitInFctList(A_FSG_50_0_0_29_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_28_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_28_ID, fctList);
       }
       if(getValue(M_FSG_50_0_0_59_FctLstItemEn))
       {
           setBitInFctList(M_FSG_50_0_0_59_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_27_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_27_ID, fctList);
       }
       if(getValue(A_FSG_50_0_0_58_FctLstItemEn))
       {
           setBitInFctList(A_FSG_50_0_0_58_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_26_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_26_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_57_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_57_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_25_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_25_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_56_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_56_ID, fctList);
       }
       if(getValue(A_FSG_50_0_0_24_FctLstItemEn))
       {
           setBitInFctList(A_FSG_50_0_0_24_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_55_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_55_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_23_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_23_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_54_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_54_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_22_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_22_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_53_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_53_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_21_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_21_ID, fctList);
       }
       if(getValue(A_FSG_50_0_0_52_FctLstItemEn))
       {
           setBitInFctList(A_FSG_50_0_0_52_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_20_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_20_ID, fctList);
       }
       if(getValue(M_FSG_50_0_0_51_FctLstItemEn))
       {
           setBitInFctList(M_FSG_50_0_0_51_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_50_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_50_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_19_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_19_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_18_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_18_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_49_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_49_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_17_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_17_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_48_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_48_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_16_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_16_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_47_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_47_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_4_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_4_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_15_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_15_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_46_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_46_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_3_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_3_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_2_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_2_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_45_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_45_ID, fctList);
       }
       if(getValue(C_FSG_50_0_0_1_FctLstItemEn))
       {
           setBitInFctList(C_FSG_50_0_0_1_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_44_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_44_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_43_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_43_ID, fctList);
       }
       if(getValue(M_FSG_50_0_0_42_FctLstItemEn))
       {
           setBitInFctList(M_FSG_50_0_0_42_ID, fctList);
       }
       if(getValue(M_FSG_50_0_0_41_FctLstItemEn))
       {
           setBitInFctList(M_FSG_50_0_0_41_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_40_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_40_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_39_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_39_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_38_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_38_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_37_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_37_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_36_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_36_ID, fctList);
       }
       if(getValue(M_FSG_50_0_0_35_FctLstItemEn))
       {
           setBitInFctList(M_FSG_50_0_0_35_ID, fctList);
       }
       if(getValue(M_FSG_50_0_0_34_FctLstItemEn))
       {
           setBitInFctList(M_FSG_50_0_0_34_ID, fctList);
       }
       if(getValue(A_FSG_50_0_0_33_FctLstItemEn))
       {
           setBitInFctList(A_FSG_50_0_0_33_ID, fctList);
       }
       if(getValue(A_FSG_50_0_0_32_FctLstItemEn))
       {
           setBitInFctList(A_FSG_50_0_0_32_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_31_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_31_ID, fctList);
       }
       if(getValue(A_FSG_50_0_0_62_FctLstItemEn))
       {
           setBitInFctList(A_FSG_50_0_0_62_ID, fctList);
       }
       if(getValue(A_FSG_50_0_0_30_FctLstItemEn))
       {
           setBitInFctList(A_FSG_50_0_0_30_ID, fctList);
       }
       if(getValue(A_FSG_50_0_0_61_FctLstItemEn))
       {
           setBitInFctList(A_FSG_50_0_0_61_ID, fctList);
       }
       if(getValue(P_FSG_50_0_0_60_FctLstItemEn))
       {
           setBitInFctList(P_FSG_50_0_0_60_ID, fctList);
       }


    for(i=0;i<8;i++){
        writelineEx(gBAP_Trace, 0, "fctList[%d]: 0x%02x ",i,fctList[i]);
    }

    request [0]=LSGID;
    request [1]=3;
    request [3]= Bap_byteSequence;
    request [4]= 8;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,fctList);
    if(errorCode)
        writelineEx(gError_Trace, 0, "BAP150_InitSendBuf(Functionlist) returns 0x%02x ",errorCode);
}

initHeartbeat()
{
       long data[2];
   data[0]=LSGID;
   if( getValue(P_FSG_50_0_0_4_FctLstItemEn) )
      data[1]=getValue(P_FSG_50_0_0_4);
   else
      data[1]=0;
   ChangeConfig(0x00,data);
   InitSendBuf_int8(P_FSG_50_0_0_4_ID, data[1]);

}

void GetGenCommNumber(struct CommConfigStruct CommConfig, dword Number, dword Channel)
{
  switch(Number)
  {
    case 0: // XML
      CommConfig.Number = 0;
      break;
    case 1: // CAN
    case 2: // CAN-FD
      CommConfig.Number = 1 + (Channel-1);
      isSelectedCAN = 1;
      break;
    case 3: // Flexray
      CommConfig.Number = 10 + (Channel-1);
      isSelectedFr = 1;
      break;
    case 4: // Ethernet
      CommConfig.Number = 20 + (Channel-1);
      isSelectedEth = 1;
      break;
  }
}

void GetCommConfig(byte data[])
{
  dword Index;
  struct CommConfigStruct CommConfig;

  Index = 0;
  strncpy(CommConfig.Name,"BAP_Navigation_FSG_01", 100);
  CommConfig.Channel = getValue(FSG50_0_0_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG50_0_0_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_Navigation_FSG_02", 100);
  CommConfig.Channel = getValue(FSG50_0_1_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG50_0_1_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_Navigation_ASG_06", 100);
  CommConfig.Channel = getValue(FSG50_0_2_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG50_0_2_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_Navigation_ASG_04", 100);
  CommConfig.Channel = getValue(FSG50_0_3_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG50_0_3_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_Navigation_ASG_02", 100);
  CommConfig.Channel = getValue(FSG50_0_4_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG50_0_4_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_Navigation_ASG_05", 100);
  CommConfig.Channel = getValue(FSG50_0_5_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG50_0_5_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_Navigation_ASG_03", 100);
  CommConfig.Channel = getValue(FSG50_0_6_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG50_0_6_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_Navigation_ASG_01", 100);
  CommConfig.Channel = getValue(FSG50_0_7_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG50_0_7_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

}

  
BapOnOff(byte _on)
{
  int i, length, temp;
  char Path[255];
  const dword CommConfigSize = 8 * __size_of(struct CommConfigStruct);
  byte CommConfigs[CommConfigSize];
  
  dword DB_ALL_CAN_INTERFACES = 0x80000000;
  dword DB_ALL_ETH_INTERFACES = 0x40000000;
  dword DB_ALL_FR_INTERFACES  = 0x20000000;
  
  isSelectedCAN = 0;
  isSelectedEth = 0;
  isSelectedFr = 0;
  
  /***** Einschalten ******/
  if(_on==1){
    if(BAP180_RemoveDBs(NODE_INDEX) != 0){
      writelineEx(gError_Trace, 0, "Fehler beim Entfernen der Datanbasen!");
    } 
     
    GetCommConfig(CommConfigs);
    
    if(isSelectedCAN){ 
      getValue(FSG50_3_fileSelectorDbCan, Path);
      if(Path[0] != '\0'){
        getValue(FSG50_3_fileSelectorDbCan, dbcan_path);
      }else{
        putValue(FSG50_3_fileSelectorDbCan, dbcan_path);
      }
      getAbsFilePath(dbcan_path, Path, 255);
      if(BAP180_LoadDB(NODE_INDEX, DB_ALL_CAN_INTERFACES, 0, Path) != 0){
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
      }
    }
     
    /**** Laden des BAP XML Files ****/
    getAbsFilePath(xml_path, Path, 255);
    writelineEx(gBAP_Trace, 0, "Load BAP-XML-File: %s", Path);
    
    if (BAP1101_LoadConfig(NODE_INDEX, Path, "", CommConfigs, CommConfigSize) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
    }
    
    
    // soll der BAP Stack wieder initlialisiert werden?                                 
    if(gBAP_Init==0){
        gBAP_Init=1;
        temp=BAP150_Init(NODE_INDEX, LSGID);
        if(temp==0)
            writelineEx(gBAP_Trace, 0, "BAP_Init for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP_Init error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);         
    }

    // Initialisierung aller Variablen
    Initialize_Variables();                     

    // Aktivierung aller Panelelemente
    EnableFctCtrl();
    //EnableControl(panel_name, bapconfig_panel_name, 0); // @TODO
    //DisableConfigCtrl();


    //BAP-Shutdown
    if(gBAP_Init)
    {
        temp = BAP150_Shutdown(NODE_INDEX, LSGID);
    }
    
    if(temp==0)
        writelineEx(gBAP_Trace, 0, "BAP_Shutdown for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
    else
        writelineEx(gError_Trace, 0, "BAP_Shutdown error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX); 

    initBapConfig();
    initFctList();
    initHeartbeat();

    temp = BAP150_Start(NODE_INDEX, LSGID);             
    if(temp == 0)
        writelineEx(gBAP_Trace, 0, "BAP_Start for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
    else
        writelineEx(gError_Trace, 0, "BAP_Start error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        

    // setze den Timer fuer den zyklischen Aufruf des CANoe-"Tasks"
    setTimer(TaskTimer, 10);                
    //  BAPFsg_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID, DEBUG_SWITCH_ON);    
  }
  else{ /***** Ausschalten ****/
    if(gBAP_Init)
    {
        BAP150_Shutdown(NODE_INDEX,LSGID);
    }
    CANoe_Shutdown();
	
	gBAP_Init = 0;
      
  }
  P_FSG_50_0_0_4_FctEn();
}

Initialize_Variables()	//initialize/reset all global variables
{
	int temp;
  dword i;
	byte  InitSend_data[BAP_buffer_size];	// InitSend data for DLL
	dword InitSend_header[6];	// InitSend header for DLL

	/**** Request Buffer Geschichten initialisieren ****/
	for (i = 0; i < Requestbuffer_lines; i++)
	{
		gBAP_Requestbuffer_status[i] = 0;
	}	
	for (i = 0; i < BAP_buffer_size; i++)
	{
		InitSend_data[i] = 0;
	}	

	// @TODO nur FSG relevant
	/**** Es ist notwendig mittels InitSendbuffer alle Properties im FSG zu initialisieren ****/
           InitSend_header[0] = LSGID;       
       InitSend_header[1] = 15; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_50_0_0_15);
	 putValue(P_FSG_50_0_0_15, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 16; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 3;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_16,InitSend_data);
       putValue(P_FSG_50_0_0_16,InitSend_data, 3);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_16)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 17; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_50_0_0_17);
	 putValue(P_FSG_50_0_0_17, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 18; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 8;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_18,InitSend_data);
       putValue(P_FSG_50_0_0_18,InitSend_data, 8);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_18)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 19; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 1;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_19,InitSend_data);
       putValue(P_FSG_50_0_0_19,InitSend_data, 1);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_19)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 20; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 2;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_20,InitSend_data);
       putValue(P_FSG_50_0_0_20,InitSend_data, 2);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_20)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 21; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_21,InitSend_data);
       putValue(P_FSG_50_0_0_21,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_21)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 22; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 7;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_22,InitSend_data);
       putValue(P_FSG_50_0_0_22,InitSend_data, 7);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_22)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 23; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 12;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_23,InitSend_data);
       putValue(P_FSG_50_0_0_23,InitSend_data, 12);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_23)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 25; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 12;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_25,InitSend_data);
       putValue(P_FSG_50_0_0_25,InitSend_data, 12);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_25)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 26; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_50_0_0_26);
	 putValue(P_FSG_50_0_0_26, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 27; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_50_0_0_27);
	 putValue(P_FSG_50_0_0_27, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 28; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 1;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_28,InitSend_data);
       putValue(P_FSG_50_0_0_28,InitSend_data, 1);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_28)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 31; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_50_0_0_31);
	 putValue(P_FSG_50_0_0_31, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 36; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_50_0_0_36);
	 putValue(P_FSG_50_0_0_36, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 37; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 8;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_37,InitSend_data);
       putValue(P_FSG_50_0_0_37,InitSend_data, 8);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_37)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 38; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_50_0_0_38);
	 putValue(P_FSG_50_0_0_38, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 39; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_50_0_0_39);
	 putValue(P_FSG_50_0_0_39, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 40; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_50_0_0_40);
	 putValue(P_FSG_50_0_0_40, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 43; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 4;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_43,InitSend_data);
       putValue(P_FSG_50_0_0_43,InitSend_data, 4);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_43)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 44; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 7;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_44,InitSend_data);
       putValue(P_FSG_50_0_0_44,InitSend_data, 7);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_44)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 45; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_45,InitSend_data);
       putValue(P_FSG_50_0_0_45,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_45)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 46; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 17;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_46,InitSend_data);
       putValue(P_FSG_50_0_0_46,InitSend_data, 17);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_46)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 47; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 3;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_47,InitSend_data);
       putValue(P_FSG_50_0_0_47,InitSend_data, 3);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_47)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 48; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 3;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_48,InitSend_data);
       putValue(P_FSG_50_0_0_48,InitSend_data, 3);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_48)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 49; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 3;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_49,InitSend_data);
       putValue(P_FSG_50_0_0_49,InitSend_data, 3);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_49)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 50; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 16;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_50,InitSend_data);
       putValue(P_FSG_50_0_0_50,InitSend_data, 16);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_50)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 53; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_53,InitSend_data);
       putValue(P_FSG_50_0_0_53,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_53)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 54; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_50_0_0_54);
	 putValue(P_FSG_50_0_0_54, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 55; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 4;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_55,InitSend_data);
       putValue(P_FSG_50_0_0_55,InitSend_data, 4);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_55)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 56; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 2;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_56,InitSend_data);
       putValue(P_FSG_50_0_0_56,InitSend_data, 2);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_56)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 57; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_57,InitSend_data);
       putValue(P_FSG_50_0_0_57,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_57)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 60; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 11;
       InitSend_header[5] = 0;
       getValue(P_FSG_50_0_0_60,InitSend_data);
       putValue(P_FSG_50_0_0_60,InitSend_data, 11);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_50_0_0_60)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);

}

on start
{
  callAllOnEnvVar();
  @A_FSG_50_0_0_24_Elements = 0;
  @A_FSG_50_0_0_24_3 = 0;
  @A_FSG_50_0_0_24_DataIndex = 0;
  @A_FSG_50_0_0_24_AT = 0;
  DisableFctCtrl_LG_all();
  
	// noch nicht eingeschaltet
	gSG_PowerOnOff=0;
	// noch nicht initialisiert
	gBAP_Init=0;
	// open the panel, nur fuer CANoe-Version >= 5.1 erlaubt
	//openPanel(panel_name);
  
    putValue(Node_Index_FSG_50, NODE_INDEX); // CG: für BAPControl
  
	// deaktiviere alle aktiven Panel Elemente, ausser AN/AUSS
  CANoe_Shutdown();
        
}


BAP_CAN_TX_Request()	//Function to send BAP-data over CAN
{
   int i;
   byte DestIp[16];
   byte TX_Data[1500];			// Data
   dword TX_Header[13];			// Header
   message 0x100 TX_Message;	// dummy-message, Adresse wird noch modifiziert
   
   byte send_result;

    TX_Header[2] = 1500; // max-Length of TX_Data

		// Pollen ueber die Queue, die von der DLL zur Verfuegung gestellt wird
		// Diese Daten muessen ueber den CAN Bus gesendet werden
    while (BAP180_GetTxData(NODE_INDEX,TX_Header,TX_Data) == 0) {
      if(TX_Header[0] == 1)
      {
        TX_Message.CAN = TX_Header[1]; 		//CAN channel
        TX_Message.ID = TX_Header[3]; 	  //Can ID
        TX_Message.DataLength = TX_Header[2]; 		// received length
      
        for (i=0; i<TX_Message.DataLength; i++) {	//CAN data-bytes
          TX_Message.byte(i) = TX_Data[i];
        }
        
        TX_Message.EDL = 0;
        TX_Message.BRS = 0;
        if(TX_Header[4] & 2) 
          TX_Message.EDL = 1;
        if(TX_Header[4] & 4) 
          TX_Message.BRS = 1;
        
        output(TX_Message);					//send CAN message
        
        //Versions Output
        if(TX_Data[0] == 0x40 && TX_Data[1] == 0x00 && TX_Header[2] == 4)
        {
          writelineEx(gBAP_Trace, 0,"Major Version: %i, Minor Version: %i", TX_Data[2], TX_Data[3]);
        }       
      }
      TX_Header[2] = 1500; 
    } 
}


ringbuffer_write (byte lsgID, byte fctID, byte request, byte dataType, dword singleData)
{
  byte data[1];
  ringbuffer_write(lsgID, fctID, request, dataType, 0, singleData, data);
}

ringbuffer_write (byte lsgID, byte fctID, byte request, byte dataType, dword length, dword singleData, byte data[])
{
	int bufferline;
  dword i;
  
	bufferline = getNextWriteIndex();	//get next free position in ring-buffer

	if (bufferline == -1) 
	{
		writelineEx(gError_Trace, 0, "Crititcal Error: No free buffer found!");
		return;
	}
		
	gBAP_Request_header[bufferline][0] = lsgID;	// LSG
	gBAP_Request_header[bufferline][1] = fctID;	// FCT
	gBAP_Request_header[bufferline][3] = dataType; // dataType
    //writelineEx(gBAP_Trace, 0, "Write request in buffer FSG NODEINDEX:%d lsgid:%d fctid:%d requesttype:%d datatype:%d length:%d", 
    //        NODE_INDEX,lsgID,fctID,request,dataType,length);


	switch (dataType)
	{
		case Bap_void:
			gBAP_Request_header[bufferline][2] = request;	// request
			gBAP_Request_header[bufferline][4] = 0;	// length
				// Void
			// @TODO?		
			break;
		case Bap_uint8:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten		
			break;
		case Bap_uint16:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten
			break;			
		case Bap_uint32:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten		
			break;	
		case Bap_byteSequence:
			gBAP_Request_header[bufferline][2] = request;	// request
			gBAP_Request_header[bufferline][4] = length;	// length
			// Daten der ByteSequence kopieren
      for(i = 0; i < length; i++)									
				gBAP_Request_data[bufferline][i] = data[i];
		case Bap_error:
			gBAP_Request_header[bufferline][5] = singleData;	// Errorcode						
			break;
		default:
			break;
	}
}

Request_void (byte lsgID, byte fctID, byte request)
{
  ringbuffer_write (lsgID, fctID, request, Bap_void, 0);	
}

Request_int8 (byte lsgID, byte fctID, byte request, dword data)
{
  ringbuffer_write (lsgID, fctID, request, Bap_uint8, data);
}

Request_int16 (byte lsgID, byte fctID, byte request, dword data)
{
  ringbuffer_write (lsgID, fctID, request, Bap_uint16, data);
}

Request_int32 (byte lsgID, byte fctID, byte request, dword data)
{
  ringbuffer_write (lsgID, fctID, request, Bap_uint32, data);
}

Request_byteSequence (byte lsgID, byte fctID, byte request, byte data[], dword length)
{
  ringbuffer_write (lsgID, fctID, request, Bap_byteSequence, length, 0, data);
}

Request_error (byte lsgID, byte fctID, byte errorCode)
{
  ringbuffer_write (lsgID, fctID, Error_REQ, Bap_error, errorCode);
}

InitSendBuf_int8 (byte fctID, dword data)
{
    dword request[6];
    int errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint8;
    request [5]= data;

    errorCode=
    BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int8 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
    
}

InitSendBuf_int16 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint16;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int16 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_int32 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int32 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_byteSequence (byte fctID, byte data[], word length)
{
    dword request[6];
    byte errorCode;

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [4]= length;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_byteSequence error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

DisplayRequestErrorCode(dword fctID, dword errCode)
{
       switch(fctID)
   {
       case C_FSG_50_0_0_1_ID:
           gC_FSG_50_0_0_1_ErrCode = 0;
           putValue(C_FSG_50_0_0_1_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_C_FSG_50_0_0_1", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_2_ID:
           gP_FSG_50_0_0_2_ErrCode = 0;
           putValue(P_FSG_50_0_0_2_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_2", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_3_ID:
           gP_FSG_50_0_0_3_ErrCode = 0;
           putValue(P_FSG_50_0_0_3_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_3", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_4_ID:
           gP_FSG_50_0_0_4_ErrCode = 0;
           putValue(P_FSG_50_0_0_4_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_4", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_15_ID:
           gP_FSG_50_0_0_15_ErrCode = 0;
           putValue(P_FSG_50_0_0_15_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_15", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_16_ID:
           gP_FSG_50_0_0_16_ErrCode = 0;
           putValue(P_FSG_50_0_0_16_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_16", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_17_ID:
           gP_FSG_50_0_0_17_ErrCode = 0;
           putValue(P_FSG_50_0_0_17_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_17", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_18_ID:
           gP_FSG_50_0_0_18_ErrCode = 0;
           putValue(P_FSG_50_0_0_18_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_18", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_19_ID:
           gP_FSG_50_0_0_19_ErrCode = 0;
           putValue(P_FSG_50_0_0_19_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_19", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_20_ID:
           gP_FSG_50_0_0_20_ErrCode = 0;
           putValue(P_FSG_50_0_0_20_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_20", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_21_ID:
           gP_FSG_50_0_0_21_ErrCode = 0;
           putValue(P_FSG_50_0_0_21_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_21", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_22_ID:
           gP_FSG_50_0_0_22_ErrCode = 0;
           putValue(P_FSG_50_0_0_22_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_22", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_23_ID:
           gP_FSG_50_0_0_23_ErrCode = 0;
           putValue(P_FSG_50_0_0_23_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_23", MakeRGB(255,79,79));
       break;
       case A_FSG_50_0_0_24_ID:
           gA_FSG_50_0_0_24_ErrCode = 0;
           putValue(A_FSG_50_0_0_24_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_24", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_25_ID:
           gP_FSG_50_0_0_25_ErrCode = 0;
           putValue(P_FSG_50_0_0_25_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_25", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_26_ID:
           gP_FSG_50_0_0_26_ErrCode = 0;
           putValue(P_FSG_50_0_0_26_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_26", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_27_ID:
           gP_FSG_50_0_0_27_ErrCode = 0;
           putValue(P_FSG_50_0_0_27_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_27", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_28_ID:
           gP_FSG_50_0_0_28_ErrCode = 0;
           putValue(P_FSG_50_0_0_28_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_28", MakeRGB(255,79,79));
       break;
       case A_FSG_50_0_0_29_ID:
           gA_FSG_50_0_0_29_ErrCode = 0;
           putValue(A_FSG_50_0_0_29_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_29", MakeRGB(255,79,79));
       break;
       case A_FSG_50_0_0_30_ID:
           gA_FSG_50_0_0_30_ErrCode = 0;
           putValue(A_FSG_50_0_0_30_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_30", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_31_ID:
           gP_FSG_50_0_0_31_ErrCode = 0;
           putValue(P_FSG_50_0_0_31_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_31", MakeRGB(255,79,79));
       break;
       case A_FSG_50_0_0_32_ID:
           gA_FSG_50_0_0_32_ErrCode = 0;
           putValue(A_FSG_50_0_0_32_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_32", MakeRGB(255,79,79));
       break;
       case A_FSG_50_0_0_33_ID:
           gA_FSG_50_0_0_33_ErrCode = 0;
           putValue(A_FSG_50_0_0_33_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_33", MakeRGB(255,79,79));
       break;
       case M_FSG_50_0_0_34_ID:
           gM_FSG_50_0_0_34_ErrCode = 0;
           putValue(M_FSG_50_0_0_34_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_34", MakeRGB(255,79,79));
           putValue(M_FSG_50_0_0_34_State,  "ReqErr");
       break;
       case M_FSG_50_0_0_35_ID:
           gM_FSG_50_0_0_35_ErrCode = 0;
           putValue(M_FSG_50_0_0_35_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_35", MakeRGB(255,79,79));
           putValue(M_FSG_50_0_0_35_State,  "ReqErr");
       break;
       case P_FSG_50_0_0_36_ID:
           gP_FSG_50_0_0_36_ErrCode = 0;
           putValue(P_FSG_50_0_0_36_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_36", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_37_ID:
           gP_FSG_50_0_0_37_ErrCode = 0;
           putValue(P_FSG_50_0_0_37_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_37", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_38_ID:
           gP_FSG_50_0_0_38_ErrCode = 0;
           putValue(P_FSG_50_0_0_38_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_38", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_39_ID:
           gP_FSG_50_0_0_39_ErrCode = 0;
           putValue(P_FSG_50_0_0_39_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_39", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_40_ID:
           gP_FSG_50_0_0_40_ErrCode = 0;
           putValue(P_FSG_50_0_0_40_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_40", MakeRGB(255,79,79));
       break;
       case M_FSG_50_0_0_41_ID:
           gM_FSG_50_0_0_41_ErrCode = 0;
           putValue(M_FSG_50_0_0_41_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_41", MakeRGB(255,79,79));
           putValue(M_FSG_50_0_0_41_State,  "ReqErr");
       break;
       case M_FSG_50_0_0_42_ID:
           gM_FSG_50_0_0_42_ErrCode = 0;
           putValue(M_FSG_50_0_0_42_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_42", MakeRGB(255,79,79));
           putValue(M_FSG_50_0_0_42_State,  "ReqErr");
       break;
       case P_FSG_50_0_0_43_ID:
           gP_FSG_50_0_0_43_ErrCode = 0;
           putValue(P_FSG_50_0_0_43_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_43", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_44_ID:
           gP_FSG_50_0_0_44_ErrCode = 0;
           putValue(P_FSG_50_0_0_44_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_44", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_45_ID:
           gP_FSG_50_0_0_45_ErrCode = 0;
           putValue(P_FSG_50_0_0_45_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_45", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_46_ID:
           gP_FSG_50_0_0_46_ErrCode = 0;
           putValue(P_FSG_50_0_0_46_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_46", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_47_ID:
           gP_FSG_50_0_0_47_ErrCode = 0;
           putValue(P_FSG_50_0_0_47_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_47", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_48_ID:
           gP_FSG_50_0_0_48_ErrCode = 0;
           putValue(P_FSG_50_0_0_48_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_48", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_49_ID:
           gP_FSG_50_0_0_49_ErrCode = 0;
           putValue(P_FSG_50_0_0_49_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_49", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_50_ID:
           gP_FSG_50_0_0_50_ErrCode = 0;
           putValue(P_FSG_50_0_0_50_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_50", MakeRGB(255,79,79));
       break;
       case M_FSG_50_0_0_51_ID:
           gM_FSG_50_0_0_51_ErrCode = 0;
           putValue(M_FSG_50_0_0_51_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_51", MakeRGB(255,79,79));
           putValue(M_FSG_50_0_0_51_State,  "ReqErr");
       break;
       case A_FSG_50_0_0_52_ID:
           gA_FSG_50_0_0_52_ErrCode = 0;
           putValue(A_FSG_50_0_0_52_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_52", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_53_ID:
           gP_FSG_50_0_0_53_ErrCode = 0;
           putValue(P_FSG_50_0_0_53_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_53", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_54_ID:
           gP_FSG_50_0_0_54_ErrCode = 0;
           putValue(P_FSG_50_0_0_54_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_54", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_55_ID:
           gP_FSG_50_0_0_55_ErrCode = 0;
           putValue(P_FSG_50_0_0_55_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_55", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_56_ID:
           gP_FSG_50_0_0_56_ErrCode = 0;
           putValue(P_FSG_50_0_0_56_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_56", MakeRGB(255,79,79));
       break;
       case P_FSG_50_0_0_57_ID:
           gP_FSG_50_0_0_57_ErrCode = 0;
           putValue(P_FSG_50_0_0_57_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_57", MakeRGB(255,79,79));
       break;
       case A_FSG_50_0_0_58_ID:
           gA_FSG_50_0_0_58_ErrCode = 0;
           putValue(A_FSG_50_0_0_58_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_58", MakeRGB(255,79,79));
       break;
       case M_FSG_50_0_0_59_ID:
           gM_FSG_50_0_0_59_ErrCode = 0;
           putValue(M_FSG_50_0_0_59_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_59", MakeRGB(255,79,79));
           putValue(M_FSG_50_0_0_59_State,  "ReqErr");
       break;
       case P_FSG_50_0_0_60_ID:
           gP_FSG_50_0_0_60_ErrCode = 0;
           putValue(P_FSG_50_0_0_60_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_60", MakeRGB(255,79,79));
       break;
       case A_FSG_50_0_0_61_ID:
           gA_FSG_50_0_0_61_ErrCode = 0;
           putValue(A_FSG_50_0_0_61_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_61", MakeRGB(255,79,79));
       break;
       case A_FSG_50_0_0_62_ID:
           gA_FSG_50_0_0_62_ErrCode = 0;
           putValue(A_FSG_50_0_0_62_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_62", MakeRGB(255,79,79));
       break;
       default:
           writelineEx(gError_Trace, 0, "%s%d/%d Unknown Functionid in  displayErrorCode", SGtype, LSGID,fctID);
   }

}

BAP_DLL_Request ()
{
    dword i;
    int l=0;
    byte temp;
    byte Request_data[BAP_buffer_size];    //Request data for DLL
    dword Request_header[6];    //Request header for DLL
    byte dataValid;
    int nextElementToRead;
    
    // defaultmaessig ist senden OK
    dataValid = 1;

    // loeschen der Daten "Container"
    for(i=0;i<6;i++)
        Request_header[i]=0;
    //for(i=0;i<BAP_buffer_size;i++)
    //    Request_data[i]=0;

    
    // Verarbeiten aller noch offenen Requests  
    while ((nextElementToRead = getNextReadIndex()) != -1) 
    {
        // Fuer alle Datentypen gleich
        Request_header[0]=gBAP_Request_header [nextElementToRead][0];       //LSG-ID
        Request_header[1]=gBAP_Request_header [nextElementToRead][1];       //Function-ID
        Request_header[2]=gBAP_Request_header [nextElementToRead][2];       //request type
        Request_header[3]=gBAP_Request_header [nextElementToRead][3];       //BAP data type

        switch(gBAP_Request_header[nextElementToRead][3]){
            case Bap_uint32:
                l=2;
            case Bap_uint16:
                l++;
            case Bap_uint8:
            case Bap_error: // Request (2) wird dabei ignoriert
                l++;
            case Bap_void:  // Datenfeld (5) wird dabei ignoriert
                Request_header[4]=l;                                                //  not used
                Request_header[5]=gBAP_Request_header [nextElementToRead][5];       // Daten
            break;
            case Bap_byteSequence:                                  
                Request_header[4]=gBAP_Request_header [nextElementToRead][4];       // length
                Request_header[5]=0;                                                // not used

                // data-array for BAP-DLL funcion 'BAP_Request'
                for(i=0;i<Request_header[4]/*BAP_buffer_size*/;i++)
                    Request_data[i]=gBAP_Request_data [nextElementToRead][i];
                break;          
            default:
                writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Request_header[nextElementToRead][3]);
                dataValid = 0;
            break;          
        }
        
        if(dataValid){
            // wie heisst der Request?
            writelineEx(gBAP_Trace, 0, "%s%d/%d BAP_Request %s datatype:%s length:%d", SGtype, Request_header[0],Request_header[1],Requesttype_Text[Request_header[2]],Datatype_Text[Request_header[3]],Request_header[4]);
            temp = BAP150_Request(NODE_INDEX, Request_header, Request_data);    //send data to BAP-DLL  
            // BAP-Request failed
            if(temp != 0){
                // Fehlercode: Request failed
                writelineEx(gError_Trace, 0, "%s%d/%d Error during BAP_Request errorcode: 0x%X", SGtype, Request_header[0],Request_header[1],temp);
                DisplayRequestErrorCode(Request_header[1],temp);
            } 
        }

    }
} 

int getNextReadIndex ()
{
	int i, ret;
	// der Puffer wird nach dem naechsten zu lesenden Eintrag durchsucht
	// Existiert keiner wird -1 zurueckgegeben
	ret = -1;

	for (i = 0; i < Requestbuffer_lines; i++)
	{
		if (gBAP_Requestbuffer_status[i] == 1)
		{
			// zum verschicken
			ret = i;
			// und wieder freigeben
			gBAP_Requestbuffer_status[i] = 0;
			break;
		}
	}

	return (ret);
}

int getNextWriteIndex ()
{
	int i, ret;
	// der Puffer wird nach dem naechsten freien Eintrag durchsucht
	// Existiert keiner wird -1 zurueckgegeben
	ret = -1;

	for (i = 0; i < Requestbuffer_lines; i++)
	{
		if (gBAP_Requestbuffer_status[i] == 0)
		{
			// zum schreiben
			ret = i;
			// belegen
			gBAP_Requestbuffer_status[i] = 1;
			break;
		}
	}

	return (ret);
}

//gBAP_Indication_header[0])  // LSGID
//gBAP_Indication_header[1]) // FCTID
//gBAP_Indication_header[2]) // IndType
//gBAP_Indication_header[3]) // Datentyp

M_FSG_50_0_0_59_ProcessingRequest ()
{
   byte temp[BAP_buffer_size];
   getValue(M_FSG_50_0_0_59_Processing, temp);
   Request_byteSequence(LSGID, M_FSG_50_0_0_59_ID, Processing_REQ, temp, getValueSize(M_FSG_50_0_0_59_Processing));
}
M_FSG_50_0_0_51_ProcessingRequest ()
{
   byte temp[BAP_buffer_size];
   getValue(M_FSG_50_0_0_51_Processing, temp);
   Request_byteSequence(LSGID, M_FSG_50_0_0_51_ID, Processing_REQ, temp, getValueSize(M_FSG_50_0_0_51_Processing));
}
M_FSG_50_0_0_42_ProcessingRequest ()
{
   byte temp[BAP_buffer_size];
   getValue(M_FSG_50_0_0_42_Processing, temp);
   Request_byteSequence(LSGID, M_FSG_50_0_0_42_ID, Processing_REQ, temp, getValueSize(M_FSG_50_0_0_42_Processing));
}
M_FSG_50_0_0_41_ProcessingRequest ()
{
   byte temp[BAP_buffer_size];
   getValue(M_FSG_50_0_0_41_Processing, temp);
   Request_byteSequence(LSGID, M_FSG_50_0_0_41_ID, Processing_REQ, temp, getValueSize(M_FSG_50_0_0_41_Processing));
}
M_FSG_50_0_0_35_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_50_0_0_35_ID, Processing_REQ, getValue(M_FSG_50_0_0_35_Processing));
}
M_FSG_50_0_0_34_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_50_0_0_34_ID, Processing_REQ, getValue(M_FSG_50_0_0_34_Processing));
}


Process_Current_Indication ()
{
   int rxsize;
   int txsize;
   byte temp[BAP_buffer_size];
   char buffer[BAP_buffer_size];
   if(strncmp(Datatype_Text[gBAP_Indication_header[3]], "acknowledge", 4)!=0) 
       writelineEx(gBAP_Trace, 0, "NodeIndex: %d: CurrentIndication %s lsgid:%d fctid:%d indType:%s dataType=%s length=%d",
               NODE_INDEX, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   else 
       writelineEx(gBAP_Trace, 0, "Internal acknowledge %s-%d fctid:%d indType:%s dataType=%s length=%d",
               SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Acknowledgetype_Text[gBAP_Indication_header[5]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   switch(gBAP_Indication_header[0])  // LSGID
   {
   case LSGID:
       switch(gBAP_Indication_header[1]) // FCTID
       {
    case P_FSG_50_0_0_15_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_15_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_15", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_15_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_16_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_16_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_16", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_16_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_17_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_17_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_17", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_17_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_18_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_18_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_18", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_18_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_19_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_19_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_19", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_19_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_20_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_20_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_20", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_20_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_21_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_21_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_21", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_21_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_22_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_22_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_22", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_22_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_23_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_23_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_23", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_23_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_50_0_0_24_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_24_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_24_ID,getValue(A_FSG_50_0_0_24_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_24_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_24_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_24", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_50_0_0_24_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_24_ID,getValue(A_FSG_50_0_0_24_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_24_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_24_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_24", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_24, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_24_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_24));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_24Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_24Status_BTN, 0);
                    if (@Env_BAPList_Source == 1 && @Env_LG_Source == 2)
                    {
                      A_FSG_50_0_0_24_SendStatus();
                      
                      if (fru_flag == 1)
                      {
                        fru_flag = 0;
                        @Env_BAPList_Source = 0;
                      }
                    }
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_24_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_24_ID,getValue(A_FSG_50_0_0_24_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_24_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_24_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_24", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_24, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_24_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_24));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_24Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_24Status_BTN, 0);
                    if (@Env_BAPList_Source == 1 && @Env_LG_Source == 2)
                    {
                      A_FSG_50_0_0_24_SendStatus();
                      
                      if (fru_flag == 1)
                      {
                        fru_flag = 0;
                        @Env_BAPList_Source = 0;
                      }
                    }
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_50_0_0_24_ErrCode = 0;
                putValue(A_FSG_50_0_0_24_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_24", MakeRGB(255,79,79));  
                gA_FSG_50_0_0_24_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_25_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_25_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_25_ID,getValue(P_FSG_50_0_0_25_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_50_0_0_25, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_25", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_25_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_25_ID,getValue(P_FSG_50_0_0_25_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_50_0_0_25, temp);
						gBAP_Indication_data[1]=temp[1];
                        putValue(P_FSG_50_0_0_25, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_25", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_50_0_0_25, temp);
                        Request_byteSequence(LSGID, P_FSG_50_0_0_25_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_50_0_0_25_ErrCode = 0;
                putValue(P_FSG_50_0_0_25_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_25", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_25_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_26_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_50_0_0_26_ErrEn)) { 
                               Request_error(LSGID,P_FSG_50_0_0_26_ID,getValue(P_FSG_50_0_0_26_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_50_0_0_26, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_26", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_50_0_0_26_ErrEn)) { 
                               Request_error(LSGID,P_FSG_50_0_0_26_ID,getValue(P_FSG_50_0_0_26_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_50_0_0_26, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_26", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_50_0_0_26_ID, Data_REQ, getValue(P_FSG_50_0_0_26));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_50_0_0_26_ErrCode = 0;
                putValue(P_FSG_50_0_0_26_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_26", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_26_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_50_0_0_27_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_50_0_0_27_ErrEn)) { 
                               Request_error(LSGID,P_FSG_50_0_0_27_ID,getValue(P_FSG_50_0_0_27_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_50_0_0_27, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_27", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_50_0_0_27_ErrEn)) { 
                               Request_error(LSGID,P_FSG_50_0_0_27_ID,getValue(P_FSG_50_0_0_27_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_50_0_0_27, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_27", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_50_0_0_27_ID, Data_REQ, getValue(P_FSG_50_0_0_27));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_50_0_0_27_ErrCode = 0;
                putValue(P_FSG_50_0_0_27_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_27", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_27_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_50_0_0_28_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_28_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_28_ID,getValue(P_FSG_50_0_0_28_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_50_0_0_28, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_28", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_28_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_28_ID,getValue(P_FSG_50_0_0_28_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_50_0_0_28, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_28", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_50_0_0_28, temp);
                        Request_byteSequence(LSGID, P_FSG_50_0_0_28_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_50_0_0_28_ErrCode = 0;
                putValue(P_FSG_50_0_0_28_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_28", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_28_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_50_0_0_29_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_29_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_29_ID,getValue(A_FSG_50_0_0_29_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_29_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_29_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_29", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_50_0_0_29_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_29_ID,getValue(A_FSG_50_0_0_29_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_29_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_29_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_29", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_29, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_29_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_29));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_29Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_29Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_29_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_29_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_29_ID,getValue(A_FSG_50_0_0_29_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_29_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_29_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_29", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_29, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_29_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_29));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_29Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_29Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_29_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_50_0_0_29_ErrCode = 0;
                putValue(A_FSG_50_0_0_29_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_29", MakeRGB(255,79,79));  
                gA_FSG_50_0_0_29_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_50_0_0_30_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_30_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_30_ID,getValue(A_FSG_50_0_0_30_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_30_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_30_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_30", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_50_0_0_30_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_30_ID,getValue(A_FSG_50_0_0_30_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_30_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_30_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_30", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_30, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_30_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_30));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_30Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_30Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_30_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_30_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_30_ID,getValue(A_FSG_50_0_0_30_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_30_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_30_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_30", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_30, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_30_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_30));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_30Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_30Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_30_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_50_0_0_30_ErrCode = 0;
                putValue(A_FSG_50_0_0_30_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_30", MakeRGB(255,79,79));  
                gA_FSG_50_0_0_30_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_31_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_31_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_31", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_31_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_50_0_0_32_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_32_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_32_ID,getValue(A_FSG_50_0_0_32_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_32_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_32_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_32", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_50_0_0_32_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_32_ID,getValue(A_FSG_50_0_0_32_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_32_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_32_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_32", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_32, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_32_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_32));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_32Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_32Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_32_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_32_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_32_ID,getValue(A_FSG_50_0_0_32_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_32_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_32_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_32", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_32, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_32_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_32));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_32Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_32Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_32_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_50_0_0_32_ErrCode = 0;
                putValue(A_FSG_50_0_0_32_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_32", MakeRGB(255,79,79));  
                gA_FSG_50_0_0_32_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_50_0_0_33_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_33_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_33_ID,getValue(A_FSG_50_0_0_33_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_33_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_33_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_33", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_50_0_0_33_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_33_ID,getValue(A_FSG_50_0_0_33_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_33_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_33_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_33", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_33, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_33_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_33));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_33Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_33Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_33_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_33_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_33_ID,getValue(A_FSG_50_0_0_33_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_33_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_33_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_33", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_33, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_33_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_33));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_33Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_33Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_33_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_50_0_0_33_ErrCode = 0;
                putValue(A_FSG_50_0_0_33_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_33", MakeRGB(255,79,79));  
                gA_FSG_50_0_0_33_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_FSG_50_0_0_34_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_50_0_0_34_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_34_ID,getValue(M_FSG_50_0_0_34_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_50_0_0_34_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_50_0_0_34_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_34", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_50_0_0_34_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_34_ID,getValue(M_FSG_50_0_0_34_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_50_0_0_34_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_50_0_0_34_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_34", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_50_0_0_34_State, "Aborted");
                            //if (getValue(M_FSG_50_0_0_34_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_34_ID, getValue(M_FSG_50_0_0_34_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_50_0_0_34_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_34_ID, getValue(M_FSG_50_0_0_34_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_50_0_0_34_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_50_0_0_34_ID, Processing_REQ, temp, getValueSize(M_FSG_50_0_0_34_Processing));
                            M_FSG_50_0_0_34_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_34", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_50_0_0_34_ErrCode = 0;
                putValue(M_FSG_50_0_0_34_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_34", MakeRGB(255,79,79));  
                gM_FSG_50_0_0_34_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_50_0_0_35_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_50_0_0_35_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_35_ID,getValue(M_FSG_50_0_0_35_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_50_0_0_35_State, "Running");
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_35", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_50_0_0_35_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_35_ID,getValue(M_FSG_50_0_0_35_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_50_0_0_35_State, "Started");
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_35", MakeRGB(255,255,255));  
                            break;
                        case AbortResult_IND:
                            putValue(M_FSG_50_0_0_35_State, "Aborted");
                            //if (getValue(M_FSG_50_0_0_35_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_35_ID, getValue(M_FSG_50_0_0_35_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_50_0_0_35_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_35_ID, getValue(M_FSG_50_0_0_35_ErrCode));
                            }
                            // Processing schicken
                           //Request_Void(LSGID, M_FSG_50_0_0_35_ID, Processing_REQ);
                            M_FSG_50_0_0_35_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_35", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                putValue(M_FSG_50_0_0_35_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_35", MakeRGB(255,79,79));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_FSG_50_0_0_36_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_50_0_0_36_ErrEn)) { 
                               Request_error(LSGID,P_FSG_50_0_0_36_ID,getValue(P_FSG_50_0_0_36_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_50_0_0_36, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_36", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_50_0_0_36_ErrEn)) { 
                               Request_error(LSGID,P_FSG_50_0_0_36_ID,getValue(P_FSG_50_0_0_36_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_50_0_0_36, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_36", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_50_0_0_36_ID, Data_REQ, getValue(P_FSG_50_0_0_36));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_50_0_0_36_ErrCode = 0;
                putValue(P_FSG_50_0_0_36_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_36", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_36_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_50_0_0_37_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_37_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_37", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_37_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_38_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_38_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_38", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_38_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_39_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_50_0_0_39_ErrEn)) { 
                               Request_error(LSGID,P_FSG_50_0_0_39_ID,getValue(P_FSG_50_0_0_39_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_50_0_0_39, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_39", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_50_0_0_39_ErrEn)) { 
                               Request_error(LSGID,P_FSG_50_0_0_39_ID,getValue(P_FSG_50_0_0_39_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_50_0_0_39, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_39", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_50_0_0_39_ID, Data_REQ, getValue(P_FSG_50_0_0_39));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_50_0_0_39_ErrCode = 0;
                putValue(P_FSG_50_0_0_39_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_39", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_39_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_50_0_0_40_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_40_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_40", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_40_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_FSG_50_0_0_41_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_50_0_0_41_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_41_ID,getValue(M_FSG_50_0_0_41_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_50_0_0_41_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_50_0_0_41_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_41", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_50_0_0_41_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_41_ID,getValue(M_FSG_50_0_0_41_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_50_0_0_41_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_50_0_0_41_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_41", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_50_0_0_41_State, "Aborted");
                            //if (getValue(M_FSG_50_0_0_41_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_41_ID, getValue(M_FSG_50_0_0_41_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_50_0_0_41_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_41_ID, getValue(M_FSG_50_0_0_41_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_50_0_0_41_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_50_0_0_41_ID, Processing_REQ, temp, getValueSize(M_FSG_50_0_0_41_Processing));
                            M_FSG_50_0_0_41_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_41", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_50_0_0_41_ErrCode = 0;
                putValue(M_FSG_50_0_0_41_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_41", MakeRGB(255,79,79));  
                gM_FSG_50_0_0_41_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_50_0_0_42_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_50_0_0_42_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_42_ID,getValue(M_FSG_50_0_0_42_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_50_0_0_42_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_50_0_0_42_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_42", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_50_0_0_42_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_42_ID,getValue(M_FSG_50_0_0_42_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_50_0_0_42_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_50_0_0_42_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_42", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_50_0_0_42_State, "Aborted");
                            //if (getValue(M_FSG_50_0_0_42_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_42_ID, getValue(M_FSG_50_0_0_42_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_50_0_0_42_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_42_ID, getValue(M_FSG_50_0_0_42_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_50_0_0_42_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_50_0_0_42_ID, Processing_REQ, temp, getValueSize(M_FSG_50_0_0_42_Processing));
                            M_FSG_50_0_0_42_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_42", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_50_0_0_42_ErrCode = 0;
                putValue(M_FSG_50_0_0_42_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_42", MakeRGB(255,79,79));  
                gM_FSG_50_0_0_42_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_FSG_50_0_0_43_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_43_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_43_ID,getValue(P_FSG_50_0_0_43_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_50_0_0_43, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_43", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_43_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_43_ID,getValue(P_FSG_50_0_0_43_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_50_0_0_43, temp);
						gBAP_Indication_data[3]=temp[3];
                        putValue(P_FSG_50_0_0_43, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_43", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_50_0_0_43, temp);
                        Request_byteSequence(LSGID, P_FSG_50_0_0_43_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_50_0_0_43_ErrCode = 0;
                putValue(P_FSG_50_0_0_43_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_43", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_43_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_44_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_44_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_44_ID,getValue(P_FSG_50_0_0_44_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_50_0_0_44, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_44", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_44_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_44_ID,getValue(P_FSG_50_0_0_44_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_50_0_0_44, temp);
						gBAP_Indication_data[2]=temp[2];
						gBAP_Indication_data[3]=temp[3];
						gBAP_Indication_data[6]=temp[6];
                        putValue(P_FSG_50_0_0_44, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_44", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_50_0_0_44, temp);
                        Request_byteSequence(LSGID, P_FSG_50_0_0_44_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_50_0_0_44_ErrCode = 0;
                putValue(P_FSG_50_0_0_44_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_44", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_44_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_45_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_45_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_45_ID,getValue(P_FSG_50_0_0_45_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_50_0_0_45, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_45", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_45_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_45_ID,getValue(P_FSG_50_0_0_45_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_50_0_0_45, temp);
						gBAP_Indication_data[2]=temp[2];
						gBAP_Indication_data[3]=temp[3];
						gBAP_Indication_data[4]=temp[4];
						gBAP_Indication_data[5]=temp[5];
                        putValue(P_FSG_50_0_0_45, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_45", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_50_0_0_45, temp);
                        Request_byteSequence(LSGID, P_FSG_50_0_0_45_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_50_0_0_45_ErrCode = 0;
                putValue(P_FSG_50_0_0_45_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_45", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_45_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_46_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_46_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_46", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_46_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_47_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_47_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_47", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_47_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_48_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_48_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_48", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_48_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_49_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_49_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_49", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_49_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_50_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_50_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_50", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_50_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_FSG_50_0_0_51_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_50_0_0_51_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_51_ID,getValue(M_FSG_50_0_0_51_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_50_0_0_51_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_50_0_0_51_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_51", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_50_0_0_51_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_51_ID,getValue(M_FSG_50_0_0_51_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_50_0_0_51_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_50_0_0_51_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_51", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_50_0_0_51_State, "Aborted");
                            //if (getValue(M_FSG_50_0_0_51_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_51_ID, getValue(M_FSG_50_0_0_51_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_50_0_0_51_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_51_ID, getValue(M_FSG_50_0_0_51_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_50_0_0_51_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_50_0_0_51_ID, Processing_REQ, temp, getValueSize(M_FSG_50_0_0_51_Processing));
                            M_FSG_50_0_0_51_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_51", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_50_0_0_51_ErrCode = 0;
                putValue(M_FSG_50_0_0_51_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_51", MakeRGB(255,79,79));  
                gM_FSG_50_0_0_51_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case A_FSG_50_0_0_52_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_52_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_52_ID,getValue(A_FSG_50_0_0_52_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_52_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_52_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_52", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_50_0_0_52_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_52_ID,getValue(A_FSG_50_0_0_52_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_52_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_52_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_52", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_52, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_52_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_52));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_52Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_52Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_52_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_52_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_52_ID,getValue(A_FSG_50_0_0_52_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_52_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_52_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_52", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_52, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_52_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_52));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_52Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_52Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_52_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_50_0_0_52_ErrCode = 0;
                putValue(A_FSG_50_0_0_52_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_52", MakeRGB(255,79,79));  
                gA_FSG_50_0_0_52_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_53_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_53_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_53", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_53_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_54_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_50_0_0_54_ErrEn)) { 
                               Request_error(LSGID,P_FSG_50_0_0_54_ID,getValue(P_FSG_50_0_0_54_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_50_0_0_54, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_54", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_50_0_0_54_ErrEn)) { 
                               Request_error(LSGID,P_FSG_50_0_0_54_ID,getValue(P_FSG_50_0_0_54_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_50_0_0_54, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_54", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_50_0_0_54_ID, Data_REQ, getValue(P_FSG_50_0_0_54));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_50_0_0_54_ErrCode = 0;
                putValue(P_FSG_50_0_0_54_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_54", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_54_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_50_0_0_55_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_55_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_55", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_55_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_56_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_56_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_56", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_56_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_50_0_0_57_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_57_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_57_ID,getValue(P_FSG_50_0_0_57_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_50_0_0_57, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_57", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_50_0_0_57_ErrEn)) { 
                           Request_error(LSGID,P_FSG_50_0_0_57_ID,getValue(P_FSG_50_0_0_57_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_50_0_0_57, temp);
						gBAP_Indication_data[0]=temp[0];
                        putValue(P_FSG_50_0_0_57, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_57", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_50_0_0_57, temp);
                        Request_byteSequence(LSGID, P_FSG_50_0_0_57_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_50_0_0_57_ErrCode = 0;
                putValue(P_FSG_50_0_0_57_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_57", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_57_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_50_0_0_58_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_58_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_58_ID,getValue(A_FSG_50_0_0_58_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_58_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_58_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_58", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_50_0_0_58_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_58_ID,getValue(A_FSG_50_0_0_58_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_58_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_58_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_58", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_58, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_58_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_58));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_58Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_58Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_58_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_58_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_58_ID,getValue(A_FSG_50_0_0_58_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_58_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_58_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_58", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_58, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_58_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_58));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_58Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_58Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_58_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_50_0_0_58_ErrCode = 0;
                putValue(A_FSG_50_0_0_58_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_58", MakeRGB(255,79,79));  
                gA_FSG_50_0_0_58_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_FSG_50_0_0_59_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_50_0_0_59_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_59_ID,getValue(M_FSG_50_0_0_59_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_50_0_0_59_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_50_0_0_59_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_59", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_50_0_0_59_ErrEn)) { 
                               Request_error(LSGID,M_FSG_50_0_0_59_ID,getValue(M_FSG_50_0_0_59_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_50_0_0_59_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_50_0_0_59_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_59", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_50_0_0_59_State, "Aborted");
                            //if (getValue(M_FSG_50_0_0_59_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_59_ID, getValue(M_FSG_50_0_0_59_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_50_0_0_59_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_50_0_0_59_ID, getValue(M_FSG_50_0_0_59_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_50_0_0_59_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_50_0_0_59_ID, Processing_REQ, temp, getValueSize(M_FSG_50_0_0_59_Processing));
                            M_FSG_50_0_0_59_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_59", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_50_0_0_59_ErrCode = 0;
                putValue(M_FSG_50_0_0_59_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_50_0_0_59", MakeRGB(255,79,79));  
                gM_FSG_50_0_0_59_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_FSG_50_0_0_60_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_50_0_0_60_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_50_0_0_60", MakeRGB(255,79,79));  
                gP_FSG_50_0_0_60_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_50_0_0_61_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_61_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_61_ID,getValue(A_FSG_50_0_0_61_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_61_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_61_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_61", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_50_0_0_61_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_61_ID,getValue(A_FSG_50_0_0_61_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_61_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_61_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_61", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_61, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_61_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_61));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_61Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_61Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_61_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_61_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_61_ID,getValue(A_FSG_50_0_0_61_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_61_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_61_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_61", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_61, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_61_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_61));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_61Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_61Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_61_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_50_0_0_61_ErrCode = 0;
                putValue(A_FSG_50_0_0_61_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_61", MakeRGB(255,79,79));  
                gA_FSG_50_0_0_61_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_50_0_0_62_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_62_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_62_ID,getValue(A_FSG_50_0_0_62_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_62_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_62_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_62", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_50_0_0_62_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_62_ID,getValue(A_FSG_50_0_0_62_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_62_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_62_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_62", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_62, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_62_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_62));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_62Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_62Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_62_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_50_0_0_62_ErrEn)) { 
                               Request_error(LSGID,A_FSG_50_0_0_62_ID,getValue(A_FSG_50_0_0_62_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_50_0_0_62_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_50_0_0_62_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_62", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_50_0_0_62, temp);
                    //Request_byteSequence(LSGID, A_FSG_50_0_0_62_ID, Data_REQ, temp, getValueSize(A_FSG_50_0_0_62));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_50_0_0_62Status_BTN, 1);
                    //putValue(A_FSG_50_0_0_62Status_BTN, 0);
                    if (@Env_BAPList_Source == 1) A_FSG_50_0_0_62_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_50_0_0_62_ErrCode = 0;
                putValue(A_FSG_50_0_0_62_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_50_0_0_62", MakeRGB(255,79,79));  
                gA_FSG_50_0_0_62_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
       default:
           writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal Fct: lsgid:%d fctid:%d indType:%d",
           NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], gBAP_Indication_header[2]);
           break;
       }
       break;
   default:
       writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal LSGID: lsgid:%d fctid:%d indType:%s", NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]]);
       break;
   }
}


on message *
{
  int i, temp;;
  byte RX_Data[64];           // received CAN-DATA";
  dword RX_Header[4];         // received CAN-Header";
  if(gSG_PowerOnOff==Power_on){
    if((this.dir == rx) && ((this.ID & 0xFFFF0000) == 0x97330000)){
      RX_Header[0]=1; /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
      RX_Header[1]=this.msgChannel;
      RX_Header[2]=this.DataLength; // received length
      RX_Header[3]=this.ID;
      for (i=0; i<this.DataLength; i++) {
        RX_Data[i]=this.byte(i);
      }
	  
	  //MR61529 - start
        //temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
         switch ((RX_Data[1] & 0x0F))
        {
        //getAll
        case 1: //error
                if (getValue(C_FSG_50_0_0_0_1_ErrEn)==0x01)
                Request_error(LSGID,FctID_GetAll,getValue(C_FSG_50_0_0_0_1_ErrCode)); 
                
                else if (getValue(C_FSG_50_0_0_0_1_FctEn) == 0x01)
                temp=BAP180_SetRxData(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 2: //error
                if (getValue(P_FSG_50_0_0_0_2_ErrEn)==0x01)
                Request_error(LSGID,FctID_BAP_Config,getValue(P_FSG_50_0_0_0_2_ErrCode)); 

                else if (getValue(P_FSG_50_0_0_0_2_FctEn) == 0x01)
                temp=BAP180_SetRxData(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 3: //error
                if (getValue(P_FSG_50_0_0_0_3_ErrEn)==0x01)
                Request_error(LSGID,FctID_FunctionList,getValue(P_FSG_40_0_0_0_3_ErrCode)); 
                
                else if (getValue(P_FSG_50_0_0_0_3_FctEn) == 0x01)
       		temp=BAP180_SetRxData(NODE_INDEX, RX_Header, RX_Data);
       		break;
             
        
        default: temp=BAP180_SetRxData(NODE_INDEX,RX_Header,RX_Data);	//send recieved CAN-data with CAN-header to BAP-DLL
                break;
        }
	  
      //temp=BAP180_SetRxData(NODE_INDEX, RX_Header, RX_Data);
    }
  }
  // if get all languidance - sendstatus senden
  if(this.byte(2)== 0x1C && this.byte(3) == 0x98 && @Env_LG_Source == 2) // Panel
  {
    @A_FSG_50_0_0_24_1         = (this.byte(4)>>4) & 0x0F;
    @A_FSG_50_0_0_24_2         =  this.byte(4)     & 0x0F;
    @A_FSG_50_0_0_24_Shift     = (this.byte(5)>>4) & 0x01;
    @A_FSG_50_0_0_24_Direction = (this.byte(5)>>5) & 0x01;
    @A_FSG_50_0_0_24_TransPos  = (this.byte(5)>>6) & 0x01;
    @A_FSG_50_0_0_24_IndexSize = (this.byte(5)>>7) & 0x01;
    
    // Pos
    for (i=0;i<=7;i++)
      A_FSG_50_0_0_24_ArrayDataList[i].Param1 = i;

    A_FSG_50_0_0_24_SendStatus();
  }
}


intertelegram_err(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=1;
    data[3]=940;
    ChangeConfig(0x0020,data);
}

sequence_err(long fctId, long size)
{
    long data[5];
    long lastSeg;

    lastSeg = size-5;

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=lastSeg/7+1;
    data[3]=1;
    data[4]=(lastSeg/7+4) & 15;
    ChangeConfig(0x0021,data);
}

intertelegram_err_off(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    ChangeConfig(0x0020,data);
}

sequence_err_off(long fctId)
{
    long data[5];

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    data[4]=0;
    ChangeConfig(0x0021,data);
}

// ETHERNET NOT ENABLED! (ON_UDP_RECEIVE_FROM_TOKEN)

// ETHERNET NOT ENABLED!

on envVar ON_OFF_FSG50_0
{
   BapOnOff(getvalue(this));
   gSG_PowerOnOff=getvalue(ON_OFF_FSG50_0);
}
on envVar BAPCFG_FSG_50_0_0_DFMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 9, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_50_0_0_DFMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 10, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_50_0_0_LsgClassMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 5, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_50_0_0_LsgClassMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 6, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_50_0_0_ProtocolMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 7, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_50_0_0_ProtocolMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 8, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID C_FSG_50_0_0_1_ID
on envVar C_FSG_50_0_0_1_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_C_FSG_50_0_0_1", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_C_FSG_50_0_0_1", MakeRGB(250,0,0));
       }
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_50_0_0_2_ID
on envVar P_FSG_50_0_0_2_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_2", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_2", MakeRGB(250,0,0));
       }
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_2_ErrCode
{
       if(gP_FSG_50_0_0_2_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_2", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_2_ErrCode = 1;
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_50_0_0_3_ID
on envVar P_FSG_50_0_0_3_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_3", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_3", MakeRGB(250,0,0));
       }
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_3_ErrCode
{
       if(gP_FSG_50_0_0_3_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_3", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_3_ErrCode = 1;
}
// De-Aktivierung der Eingabefelder der HB-FCT P_FSG_50_0_0_4
on envVar P_FSG_50_0_0_4_FctLstItemEn
{
       if(getValue(this)) 
       {
//           EnableControl(panel_name,"panel_FSG_50_0_0_4",1);
//           EnableControl(panel_name,"${ERRFIELD}",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_4_HBEn",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_4", MakeRGB(0,240,0));
       }
       else
       {
//           EnableControl(panel_name,"panel_FSG_50_0_0_4",0);
//           EnableControl(panel_name,"${ERRFIELD}",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_4_HBEn",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_4", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_4_FctEn
{
  P_FSG_50_0_0_4_FctEn();
}
P_FSG_50_0_0_4_FctEn()
{
	long data[2];
	if(getValue(P_FSG_50_0_0_4_FctEn)>0)
	{
		data[0] = 50;
		data[1] = getValue(P_FSG_50_0_0_4);
		write("enable HB");
	}
	else
	{
		data[0] = 50;
		data[1] = 0;
		write("disable HB");
	}
        if(gBAP_Init)
	{
	    Bap150_ChangeConfig(NODE_INDEX, 0x00, data);
	}
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_4_ErrCode
{
       if(gP_FSG_50_0_0_4_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_4", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_4_ErrCode = 1;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_15_ErrCode
{
       if(gP_FSG_50_0_0_15_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_15", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_15_ErrCode = 1;
}
on envVar P_FSG_50_0_0_15Status_BTN
{
    if (P_FSG_50_0_0_15Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_50_0_0_15_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_15",MakeRGB(255,255,255));
       P_FSG_50_0_0_15Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_50_0_0_15_ID, Data_REQ, getValue(P_FSG_50_0_0_15));
      P_FSG_50_0_0_15Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_15_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_15_ID;
    data[2]=getValue(P_FSG_50_0_0_15_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_15
on envVar P_FSG_50_0_0_15_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_15",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_15",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_15",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_15", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_15",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_15",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_15",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_15", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_15 // bus value of FSG_OperationState (15).
{
	// opcodes: Error-Status
	byte param1; // OP_State
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_50_0_0_15);
	putValue(P_FSG_50_0_0_15_1, param1);
}

on envVar P_FSG_50_0_0_15_1 // FSG_OperationState.OP_State
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // OP_State
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_50_0_0_15);
	superval = thisval;
	putValue(P_FSG_50_0_0_15,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_16_ErrCode
{
       if(gP_FSG_50_0_0_16_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_16", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_16_ErrCode = 1;
}
on envVar P_FSG_50_0_0_16Status_BTN
{
	byte BAPTemp[3];
   if (P_FSG_50_0_0_16Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_16_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_16",MakeRGB(255,255,255));
      P_FSG_50_0_0_16Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_16, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_16_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_16));
      P_FSG_50_0_0_16Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_16_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_16_ID;
    data[2]=getValue(P_FSG_50_0_0_16_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_16
on envVar P_FSG_50_0_0_16_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_16",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_16",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_16",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_16", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_16",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_16",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_16",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_16", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_16 // bus value of CompassInfo (16).
{
	// opcodes: Error-Status
	byte param1; // Direction_Symbolic
	word param2; // Direction_Angle
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[3];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_16, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_16_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_50_0_0_16_2, round((param2 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_50_0_0_16_1 // CompassInfo.Direction_Symbolic
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // Direction_Symbolic
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_16, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_16,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_16_2_range // CompassInfo.Direction_Angle 
{
	@P_FSG_50_0_0_16_2 = @P_FSG_50_0_0_16_2_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_16_2 // CompassInfo.Direction_Angle
{
	byte superval[3];

	//Update Childvalue (Number)
	word thisval; // Direction_Angle
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_16_2, 1.0);
	@P_FSG_50_0_0_16_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_16, superval);
	superval[1]=thisval&0x00ff;
	superval[2]=(thisval&0xff00)>>8;
	putValue(P_FSG_50_0_0_16,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_17_ErrCode
{
       if(gP_FSG_50_0_0_17_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_17", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_17_ErrCode = 1;
}
on envVar P_FSG_50_0_0_17Status_BTN
{
    if (P_FSG_50_0_0_17Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_50_0_0_17_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_17",MakeRGB(255,255,255));
       P_FSG_50_0_0_17Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_50_0_0_17_ID, Data_REQ, getValue(P_FSG_50_0_0_17));
      P_FSG_50_0_0_17Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_17_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_17_ID;
    data[2]=getValue(P_FSG_50_0_0_17_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_17
on envVar P_FSG_50_0_0_17_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_17",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_17",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_17",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_17", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_17",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_17",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_17",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_17", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_17 // bus value of RG_Status (17).
{
	// opcodes: Error-Status
	byte param1; // RG_Status
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_50_0_0_17);
	putValue(P_FSG_50_0_0_17_1, param1);
}

on envVar P_FSG_50_0_0_17_1 // RG_Status.RG_Status
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // RG_Status
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_50_0_0_17);
	superval = thisval;
	putValue(P_FSG_50_0_0_17,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_18_ErrCode
{
       if(gP_FSG_50_0_0_18_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_18", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_18_ErrCode = 1;
}
on envVar P_FSG_50_0_0_18Status_BTN
{
	byte BAPTemp[8];
    if (P_FSG_50_0_0_18Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_18_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_18",MakeRGB(255,255,255));
        P_FSG_50_0_0_18Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_18_BuildFct();
        getValue(P_FSG_50_0_0_18, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_18_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_18));
        if(getValue(P_FSG_50_0_0_18_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_18_ID);
        }
        if(getValue(P_FSG_50_0_0_18_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_18_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_18Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_18_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_18_ID;
    data[2]=getValue(P_FSG_50_0_0_18_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_18
on envVar P_FSG_50_0_0_18_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_18",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_18",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_18",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_18", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_18",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_18",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_18",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_18", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_18_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_18_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_18_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_18_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_18_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_18_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_18_ID,getValueSize(P_FSG_50_0_0_18_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_18_ID);
       }
}
on envVar P_FSG_50_0_0_18 // bus value of DistanceToNextManeuver (18).
{
	// opcodes: Error-Status
	byte param1[5]; //Record: DistanceToNextManeuver
	byte param2[2]; //Record: BargraphInfo
	byte param3; // ValidityInformation
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[8];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 8; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_18, superval);
	///////// Start param1 - Record /////////
	for( i = 0; i < 5; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_18_1, param1);
	///////// Start param2 - Record /////////
	for( i = 0; i < 2; i++ )
	{
		param2[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_18_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_50_0_0_18_3, param3);
}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_18_BuildFct()
{
	byte param1[5]; //Record: DistanceToNextManeuver
	byte param2[2]; //Record: BargraphInfo
	byte param3; // ValidityInformation

	dword i;
	byte superval[8];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	//Record:DistanceToNextManeuver
	getValue(P_FSG_50_0_0_18_1, param1);
	for( i = 0; i < 5; i++)
	{
	 superval[currentPos++] = param1[i];
	}
// gen_BuildFunc_SetSuperVals 
	//Record:BargraphInfo
	getValue(P_FSG_50_0_0_18_2, param2);
	for( i = 0; i < 2; i++)
	{
	 superval[currentPos++] = param2[i];
	}
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_50_0_0_18_3);
	@P_FSG_50_0_0_18_3_0 = (param3 & 1) > 0;
	superval[currentPos++]=param3;
	putValue(P_FSG_50_0_0_18, superval, currentPos);
}


//Record: DistanceToNextManeuver, Element: Distance
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_18_1_Distance_range // DistanceToNextManeuver.Distance 
{
	@P_FSG_50_0_0_18_1_Distance = @P_FSG_50_0_0_18_1_Distance_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_18_1_Distance // DistanceToNextManeuver.Distance
{
	byte superval[5];

	//Update Childvalue (Number)
	dword thisval; // Distance
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_18_1_Distance, 0.1);
	@P_FSG_50_0_0_18_1_Distance_range = slider_value + (0); // real value := slider value + range min.
	thisval = (dword)round((slider_value + (0) - (0)) / (0.1), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_18_1, superval);
	superval[0]= thisval&0x000000ff;
	superval[1]=(thisval&0x0000ff00)>>8;
	superval[2]=(thisval&0x00ff0000)>>16;
	superval[3]=(thisval&0xff000000)>>24;
	putValue(P_FSG_50_0_0_18_1,superval);
}

//Record: DistanceToNextManeuver, Element: Unit
on envVar P_FSG_50_0_0_18_1_Unit // DistanceToNextManeuver.Unit
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // Unit
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_18_1, superval);
	superval[4]=thisval;
	putValue(P_FSG_50_0_0_18_1,superval);
}

on envVar P_FSG_50_0_0_18_1 // DistanceToNextManeuver.DistanceToNextManeuver
{
	byte recordVal[5]; //Record: DistanceToNextManeuver
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	dword param1; // Distance
	byte param2; // Unit

	currentPos = 0;
	getValue(P_FSG_50_0_0_18_1, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT32 /////////
	param1 = recordVal[currentPos++]|(recordVal[currentPos++]<<8)|(recordVal[currentPos++]<<16)|(recordVal[currentPos++]<<24);
	putValue(P_FSG_50_0_0_18_1_Distance, round((param1 * 0.1) - (0) + (0), 0.1));
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_18_1_Unit, param2);
	P_FSG_50_0_0_18_BuildFct();
}

//Record: BargraphInfo, Element: BargraphOnOff
on envVar P_FSG_50_0_0_18_2_BargraphOnOff // BargraphInfo.BargraphOnOff
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // BargraphOnOff
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_18_2, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_18_2,superval);
}

//Record: BargraphInfo, Element: Bargraph
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_18_2_Bargraph_range // DistanceToNextManeuver.Bargraph 
{
	@P_FSG_50_0_0_18_2_Bargraph = @P_FSG_50_0_0_18_2_Bargraph_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_18_2_Bargraph // BargraphInfo.Bargraph
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // Bargraph
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_18_2_Bargraph, 1.0);
	@P_FSG_50_0_0_18_2_Bargraph_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_18_2, superval);
	superval[1]=thisval;
	putValue(P_FSG_50_0_0_18_2,superval);
}

on envVar P_FSG_50_0_0_18_2 // DistanceToNextManeuver.BargraphInfo
{
	byte recordVal[2]; //Record: BargraphInfo
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	byte param1; // BargraphOnOff
	byte param2; // Bargraph

	currentPos = 0;
	getValue(P_FSG_50_0_0_18_2, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT8 /////////
	param1 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_18_2_BargraphOnOff, param1);
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_18_2_Bargraph, round((param2 * 1.0) - (0) + (0), 1.0));
	P_FSG_50_0_0_18_BuildFct();
}

on envVar P_FSG_50_0_0_18_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_18_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_18_3,thisval);
}

on envVar P_FSG_50_0_0_18_3 // DistanceToNextManeuver.ValidityInformation
{
	P_FSG_50_0_0_18_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_19_ErrCode
{
       if(gP_FSG_50_0_0_19_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_19", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_19_ErrCode = 1;
}
on envVar P_FSG_50_0_0_19Status_BTN
{
	byte BAPTemp[97];
    if (P_FSG_50_0_0_19Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_19_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_19",MakeRGB(255,255,255));
        P_FSG_50_0_0_19Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_19_BuildFct();
        getValue(P_FSG_50_0_0_19, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_19_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_19));
        if(getValue(P_FSG_50_0_0_19_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_19_ID);
        }
        if(getValue(P_FSG_50_0_0_19_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_19_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_19Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_19_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_19_ID;
    data[2]=getValue(P_FSG_50_0_0_19_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_19
on envVar P_FSG_50_0_0_19_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_19",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_19",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_19",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_19", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_19",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_19",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_19",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_19", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_19_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_19_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_19_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_19_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_19_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_19_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_19_ID,getValueSize(P_FSG_50_0_0_19_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_19_ID);
       }
}
on envVar P_FSG_50_0_0_19 // bus value of CurrentPositionInfo (19).
{
	// opcodes: Error-Status
	byte param1[97]; // PositionInfo
	word len1;
	byte cnt1;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[97];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 97; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_19, superval);
	///////// Start param1 - STRING /////////
	//getValue(P_FSG_50_0_0_19_1, param1);
  getValue(P_FSG_50_0_0_19_1_Hex, param1);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(96>127) /* Max Fct-Katalog Laenge: 96*/
		{
			len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt1 = 1;
		}
		else
		{
			len1 = 96;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_19 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len1 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt1 = 0;
	}
	
	if(len1 > 96)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
		len1 = 96;
	
		if(len1 < 128) cnt1 = 0;
		else cnt1 = 1;
	}
	
	for(i = 0; i < len1; i++)
	{
		param1[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_19_1_len, len1);
	putValue(P_FSG_50_0_0_19_1_cnt, cnt1);
	
  /*if(len1 > getValueSize(P_FSG_50_0_0_19_1_Hex))
		putValue(P_FSG_50_0_0_19_1_Hex, param1, len1);
	else
		putValue(P_FSG_50_0_0_19_1_Hex, param1, getValueSize(P_FSG_50_0_0_19_1_Hex));*/
  
	/*if(len1 > getValueSize(P_FSG_50_0_0_19_1))
		putValue(P_FSG_50_0_0_19_1, param1, len1);
	else
		putValue(P_FSG_50_0_0_19_1, param1, getValueSize(P_FSG_50_0_0_19_1));*/

}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_19_BuildFct()
{
	byte param1[97]; // PositionInfo
	word len1;
	byte cnt1;

	dword i;
	byte superval[97];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_50_0_0_19_1, param1);
  getValue(P_FSG_50_0_0_19_1_Hex, param1);
	len1 = getValue(P_FSG_50_0_0_19_1_len);
	cnt1= getValue(P_FSG_50_0_0_19_1_cnt);
	
	/* check box aktiviert*/
	if (cnt1 == 1)
	{
		/* 0 bis 96 (MaxString - 1B oder 2B) */
		if(len1 >= 0 && len1 <= 96)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos] = ((len1>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_19_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 96);
			return;
		}
	}
	else if(cnt1 == 0) /*check box deaktiviert*/
	{
		if(len1 >= 0 && len1 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos]= len1 & 0x00ff;
			putValue(P_FSG_50_0_0_19_1_len, len1);
		}
		else if(len1 > 127 && len1 <= 96)
		{
			superval[currentPos] = ((len1>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
			putValue(P_FSG_50_0_0_19_1_len, len1);
			putValue(P_FSG_50_0_0_19_1_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_19_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 96);
			return;
		}
	}
	currentPos += cnt1+1;
	for(i = 0; i < len1; i++)
	{
		superval[currentPos++]= param1[i];
	}

	putValue(P_FSG_50_0_0_19, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_19_1_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_19_1_len);
	cnt = getValue(P_FSG_50_0_0_19_1_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_19_1_len, 127);
		}
	}

	P_FSG_50_0_0_19_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_19_1_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 96)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_19_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 96);
		putValue(this, 96);
	}
	P_FSG_50_0_0_19_BuildFct();
}


on envVar P_FSG_50_0_0_19_1 // CurrentPositionInfo.PositionInfo
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_19_1_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_19_1_len, string_length_mod);
  
  /*putValue(P_FSG_50_0_0_19_1_len, getValueSize(this));
	P_FSG_50_0_0_19_BuildFct();*/
}




// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_20_ErrCode
{
       if(gP_FSG_50_0_0_20_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_20", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_20_ErrCode = 1;
}
on envVar P_FSG_50_0_0_20Status_BTN
{
	byte BAPTemp[107];
    if (P_FSG_50_0_0_20Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_20_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_20",MakeRGB(255,255,255));
        P_FSG_50_0_0_20Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_20_BuildFct();
        getValue(P_FSG_50_0_0_20, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_20_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_20));
        if(getValue(P_FSG_50_0_0_20_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_20_ID);
        }
        if(getValue(P_FSG_50_0_0_20_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_20_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_20Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_20_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_20_ID;
    data[2]=getValue(P_FSG_50_0_0_20_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_20
on envVar P_FSG_50_0_0_20_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_20",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_20",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_20",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_20", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_20",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_20",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_20",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_20", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_20_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_20_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_20_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_20_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_20_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_20_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_20_ID,getValueSize(P_FSG_50_0_0_20_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_20_ID);
       }
}
on envVar P_FSG_50_0_0_20 // bus value of TurnToInfo (20).
{
	// opcodes: Error-Status
	byte param1[76]; // TurnToInfo
	word len1;
	byte cnt1;
	byte param2[31]; // SignPost
	word len2;
	byte cnt2;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[107];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 107; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_20, superval);
	///////// Start param1 - STRING /////////
	//getValue(P_FSG_50_0_0_20_1, param1);
  getValue(P_FSG_50_0_0_20_1_Hex, param1);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(75>127) /* Max Fct-Katalog Laenge: 75*/
		{
			len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt1 = 1;
		}
		else
		{
			len1 = 75;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_20 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len1 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt1 = 0;
	}
	
	if(len1 > 75)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
		len1 = 75;
	
		if(len1 < 128) cnt1 = 0;
		else cnt1 = 1;
	}
	
	for(i = 0; i < len1; i++)
	{
		param1[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_20_1_len, len1);
	putValue(P_FSG_50_0_0_20_1_cnt, cnt1);
	
	/*if(len1 > getValueSize(P_FSG_50_0_0_20_1))
		putValue(P_FSG_50_0_0_20_1, param1, len1);
	else
		putValue(P_FSG_50_0_0_20_1, param1, getValueSize(P_FSG_50_0_0_20_1));*/
  
  if(len1 > getValueSize(P_FSG_50_0_0_20_1_Hex))
		putValue(P_FSG_50_0_0_20_1_Hex, param1, len1);
	else
		putValue(P_FSG_50_0_0_20_1_Hex, param1, getValueSize(P_FSG_50_0_0_20_1_Hex));

	///////// Start param2 - STRING /////////
	//getValue(P_FSG_50_0_0_20_2, param2);
  getValue(P_FSG_50_0_0_20_2_Hex, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(30>127) /* Max Fct-Katalog Laenge: 30*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 30;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_20 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 30)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 30;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_20_2_len, len2);
	putValue(P_FSG_50_0_0_20_2_cnt, cnt2);
	
  if(len2 > getValueSize(P_FSG_50_0_0_20_2_Hex))
		putValue(P_FSG_50_0_0_20_2_Hex, param2, len2);
	else
		putValue(P_FSG_50_0_0_20_2_Hex, param2, getValueSize(P_FSG_50_0_0_20_2_Hex));
  
	/*if(len2 > getValueSize(P_FSG_50_0_0_20_2))
		putValue(P_FSG_50_0_0_20_2, param2, len2);
	else
		putValue(P_FSG_50_0_0_20_2, param2, getValueSize(P_FSG_50_0_0_20_2));*/

}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_20_BuildFct()
{
	byte param1[76]; // TurnToInfo
	word len1;
	byte cnt1;
	byte param2[31]; // SignPost
	word len2;
	byte cnt2;

	dword i;
	byte superval[107];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_50_0_0_20_1, param1);
  getValue(P_FSG_50_0_0_20_1_Hex, param1);
	len1 = getValue(P_FSG_50_0_0_20_1_len);
	cnt1= getValue(P_FSG_50_0_0_20_1_cnt);
	
	/* check box aktiviert*/
	if (cnt1 == 1)
	{
		/* 0 bis 75 (MaxString - 1B oder 2B) */
		if(len1 >= 0 && len1 <= 75)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos] = ((len1>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_20_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 75);
			return;
		}
	}
	else if(cnt1 == 0) /*check box deaktiviert*/
	{
		if(len1 >= 0 && len1 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos]= len1 & 0x00ff;
			putValue(P_FSG_50_0_0_20_1_len, len1);
		}
		else if(len1 > 127 && len1 <= 75)
		{
			superval[currentPos] = ((len1>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
			putValue(P_FSG_50_0_0_20_1_len, len1);
			putValue(P_FSG_50_0_0_20_1_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_20_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 75);
			return;
		}
	}
	currentPos += cnt1+1;
	for(i = 0; i < len1; i++)
	{
		superval[currentPos++]= param1[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_50_0_0_20_2, param2);
  getValue(P_FSG_50_0_0_20_2_Hex, param2);
	len2 = getValue(P_FSG_50_0_0_20_2_len);
	cnt2= getValue(P_FSG_50_0_0_20_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 30 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 30)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = ((len2>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_20_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 30);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(P_FSG_50_0_0_20_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 30)
		{
			superval[currentPos] = ((len2>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(P_FSG_50_0_0_20_2_len, len2);
			putValue(P_FSG_50_0_0_20_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_20_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 30);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

	putValue(P_FSG_50_0_0_20, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_20_1_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_20_1_len);
	cnt = getValue(P_FSG_50_0_0_20_1_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_20_1_len, 127);
		}
	}

	P_FSG_50_0_0_20_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_20_1_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 75)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_20_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 75);
		putValue(this, 75);
	}
	P_FSG_50_0_0_20_BuildFct();
}


on envVar P_FSG_50_0_0_20_1 // TurnToInfo.TurnToInfo
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_20_1_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_20_1_len, string_length_mod);
  
  /*putValue(P_FSG_50_0_0_20_1_len, getValueSize(this));
	P_FSG_50_0_0_20_BuildFct();*/
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_20_2_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_20_2_len);
	cnt = getValue(P_FSG_50_0_0_20_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_20_2_len, 127);
		}
	}

	P_FSG_50_0_0_20_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_20_2_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 30)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_20_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 30);
		putValue(this, 30);
	}
	P_FSG_50_0_0_20_BuildFct();
}


on envVar P_FSG_50_0_0_20_2 // TurnToInfo.SignPost
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_20_2_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_20_2_len, string_length_mod);
  
  /*putValue(P_FSG_50_0_0_20_2_len, getValueSize(this));
	P_FSG_50_0_0_20_BuildFct();*/
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_21_ErrCode
{
       if(gP_FSG_50_0_0_21_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_21", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_21_ErrCode = 1;
}
on envVar P_FSG_50_0_0_21Status_BTN
{
	byte BAPTemp[6];
   if (P_FSG_50_0_0_21Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_21_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_21",MakeRGB(255,255,255));
      P_FSG_50_0_0_21Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_21, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_21_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_21));
      P_FSG_50_0_0_21Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_21_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_21_ID;
    data[2]=getValue(P_FSG_50_0_0_21_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_21
on envVar P_FSG_50_0_0_21_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_21",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_21",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_21",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_21", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_21",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_21",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_21",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_21", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_21 // bus value of DistanceToDestination (21).
{
	// opcodes: Error-Status
	byte param1[5]; //Record: DistanceToDestination
	byte param2; // DistanceToDestinationType
	byte param3; // ValidityInformation
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[6];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_21, superval);
	///////// Start param1 - Record /////////
	for( i = 0; i < 5; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_21_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_50_0_0_21_2, param2);
	///////// Start param3 - NIBBLE /////////
	param3 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_50_0_0_21_3, param3);
}

//Record: DistanceToDestination, Element: Distance
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_21_1_Distance_range // DistanceToDestination.Distance 
{
	@P_FSG_50_0_0_21_1_Distance = @P_FSG_50_0_0_21_1_Distance_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_21_1_Distance // DistanceToDestination.Distance
{
	byte superval[5];

	//Update Childvalue (Number)
	dword thisval; // Distance
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_21_1_Distance, 0.1);
	@P_FSG_50_0_0_21_1_Distance_range = slider_value + (0); // real value := slider value + range min.
	thisval = (dword)round((slider_value + (0) - (0)) / (0.1), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_21_1, superval);
	superval[0]= thisval&0x000000ff;
	superval[1]=(thisval&0x0000ff00)>>8;
	superval[2]=(thisval&0x00ff0000)>>16;
	superval[3]=(thisval&0xff000000)>>24;
	putValue(P_FSG_50_0_0_21_1,superval);
}

//Record: DistanceToDestination, Element: Unit
on envVar P_FSG_50_0_0_21_1_Unit // DistanceToDestination.Unit
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // Unit
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_21_1, superval);
	superval[4]=thisval;
	putValue(P_FSG_50_0_0_21_1,superval);
}

on envVar P_FSG_50_0_0_21_1 // DistanceToDestination.DistanceToDestination
{
	byte superval[6];
	byte recordVal[5]; //Record: DistanceToDestination
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	dword param1; // Distance
	byte param2; // Unit

	currentPos = 0;
	getValue(P_FSG_50_0_0_21_1, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT32 /////////
	param1 = recordVal[currentPos++]|(recordVal[currentPos++]<<8)|(recordVal[currentPos++]<<16)|(recordVal[currentPos++]<<24);
	putValue(P_FSG_50_0_0_21_1_Distance, round((param1 * 0.1) - (0) + (0), 0.1));
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_21_1_Unit, param2);

    // Update superval
	getValue(P_FSG_50_0_0_21, superval);
	for( i = 0; i < 5; i++ )
	{
		superval[i+0] = recordVal[i];
	}
	putValue(P_FSG_50_0_0_21,superval);
}

on envVar P_FSG_50_0_0_21_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DistanceToDestinationType
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_21_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_21_2,thisval);
}

on envVar P_FSG_50_0_0_21_2 // DistanceToDestination.DistanceToDestinationType
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // DistanceToDestinationType
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_21_2_0, 1);
	else
		putValue(P_FSG_50_0_0_21_2_0, 0);

    // Update superval
	getValue(P_FSG_50_0_0_21, superval);
	superval[5]= superval[5]&0x0f;
	superval[5]= superval[5]|(thisval<<4);
	putValue(P_FSG_50_0_0_21,superval);
}

on envVar P_FSG_50_0_0_21_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_21_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_21_3,thisval);
}

on envVar P_FSG_50_0_0_21_3 // DistanceToDestination.ValidityInformation
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // ValidityInformation
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_21_3_0, 1);
	else
		putValue(P_FSG_50_0_0_21_3_0, 0);

    // Update superval
	getValue(P_FSG_50_0_0_21, superval);
	superval[5]= superval[5]&0xf0;
	superval[5]= superval[5]|thisval;
	putValue(P_FSG_50_0_0_21,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_22_ErrCode
{
       if(gP_FSG_50_0_0_22_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_22", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_22_ErrCode = 1;
}
on envVar P_FSG_50_0_0_22Status_BTN
{
	byte BAPTemp[7];
    if (P_FSG_50_0_0_22Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_22_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_22",MakeRGB(255,255,255));
        P_FSG_50_0_0_22Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_22_BuildFct();
        getValue(P_FSG_50_0_0_22, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_22));
        if(getValue(P_FSG_50_0_0_22_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_22_ID);
        }
        if(getValue(P_FSG_50_0_0_22_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_22_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_22Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_22_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_22_ID;
    data[2]=getValue(P_FSG_50_0_0_22_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_22
on envVar P_FSG_50_0_0_22_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_22",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_22",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_22",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_22", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_22",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_22",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_22",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_22", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_22_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_22_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_22_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_22_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_22_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_22_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_22_ID,getValueSize(P_FSG_50_0_0_22_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_22_ID);
       }
}
on envVar P_FSG_50_0_0_22 // bus value of TimeToDestination (22).
{
	// opcodes: Error-Status
	byte param1[6]; //Record: TimeInfo
	byte param2; // ValidityInformation
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[7];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 7; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_22, superval);
	///////// Start param1 - Record /////////
	for( i = 0; i < 6; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_22_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_22_2, param2);
}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_22_BuildFct()
{
	byte param1[6]; //Record: TimeInfo
	byte param2; // ValidityInformation

	dword i;
	byte superval[7];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	//Record:TimeInfo
	getValue(P_FSG_50_0_0_22_1, param1);
	for( i = 0; i < 6; i++)
	{
	 superval[currentPos++] = param1[i];
	}
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_50_0_0_22_2);
	@P_FSG_50_0_0_22_2_1 = (param2 & 2) > 0;
	@P_FSG_50_0_0_22_2_2 = (param2 & 4) > 0;
	@P_FSG_50_0_0_22_2_3 = (param2 & 8) > 0;
	@P_FSG_50_0_0_22_2_4 = (param2 & 16) > 0;
	@P_FSG_50_0_0_22_2_5 = (param2 & 32) > 0;
	superval[currentPos++]=param2;
	putValue(P_FSG_50_0_0_22, superval, currentPos);
}


//Record: TimeInfo, Element: TimeInfoType
on envVar P_FSG_50_0_0_22_1_TimeInfoType // TimeInfo.TimeInfoType
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // TimeInfoType
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_22_1, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(P_FSG_50_0_0_22_1,superval);
}

//Record: TimeInfo, Element: NavigationTimeFormat
on envVar P_FSG_50_0_0_22_1_NavigationTimeFormat // TimeInfo.NavigationTimeFormat
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // NavigationTimeFormat
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_22_1, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(P_FSG_50_0_0_22_1,superval);
}

//Record: TimeInfo, Element: Minute
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_22_1_Minute_range // TimeToDestination.Minute 
{
	@P_FSG_50_0_0_22_1_Minute = @P_FSG_50_0_0_22_1_Minute_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_22_1_Minute // TimeInfo.Minute
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_22_1_Minute, 1.0);
	@P_FSG_50_0_0_22_1_Minute_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_22_1, superval);
	superval[1]=thisval;
	putValue(P_FSG_50_0_0_22_1,superval);
}

//Record: TimeInfo, Element: Hour
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_22_1_Hour_range // TimeToDestination.Hour 
{
	@P_FSG_50_0_0_22_1_Hour = @P_FSG_50_0_0_22_1_Hour_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_22_1_Hour // TimeInfo.Hour
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_22_1_Hour, 1.0);
	@P_FSG_50_0_0_22_1_Hour_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_22_1, superval);
	superval[2]=thisval;
	putValue(P_FSG_50_0_0_22_1,superval);
}

//Record: TimeInfo, Element: Day
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_22_1_Day_range // TimeToDestination.Day 
{
	@P_FSG_50_0_0_22_1_Day = @P_FSG_50_0_0_22_1_Day_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_22_1_Day // TimeInfo.Day
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Day
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_22_1_Day, 1.0);
	@P_FSG_50_0_0_22_1_Day_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_22_1, superval);
	superval[3]=thisval;
	putValue(P_FSG_50_0_0_22_1,superval);
}

//Record: TimeInfo, Element: Month
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_22_1_Month_range // TimeToDestination.Month 
{
	@P_FSG_50_0_0_22_1_Month = @P_FSG_50_0_0_22_1_Month_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_22_1_Month // TimeInfo.Month
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Month
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_22_1_Month, 1.0);
	@P_FSG_50_0_0_22_1_Month_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_22_1, superval);
	superval[4]=thisval;
	putValue(P_FSG_50_0_0_22_1,superval);
}

//Record: TimeInfo, Element: Year
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_22_1_Year_range // TimeToDestination.Year 
{
	@P_FSG_50_0_0_22_1_Year = @P_FSG_50_0_0_22_1_Year_range - (2000); // slider = range - min
}

on envVar P_FSG_50_0_0_22_1_Year // TimeInfo.Year
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Year
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_22_1_Year, 1.0);
	@P_FSG_50_0_0_22_1_Year_range = slider_value + (2000); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (2000) - (2000)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_22_1, superval);
	superval[5]=thisval;
	putValue(P_FSG_50_0_0_22_1,superval);
}

on envVar P_FSG_50_0_0_22_1 // TimeToDestination.TimeInfo
{
	byte recordVal[6]; //Record: TimeInfo
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	byte param1; // TimeInfoType
	byte param2; // NavigationTimeFormat
	byte param3; // Minute
	byte param4; // Hour
	byte param5; // Day
	byte param6; // Month
	byte param7; // Year

	currentPos = 0;
	getValue(P_FSG_50_0_0_22_1, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - NIBBLE /////////
	param1 = (recordVal[currentPos] & 0xf0)>>4;
	putValue(P_FSG_50_0_0_22_1_TimeInfoType, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = recordVal[currentPos++] & 0x0f;
	putValue(P_FSG_50_0_0_22_1_NavigationTimeFormat, param2);
	///////// Start param3 - UINT8 /////////
	param3 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_22_1_Minute, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_22_1_Hour, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_22_1_Day, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_22_1_Month, round((param6 * 1.0) - (0) + (0), 1.0));
	///////// Start param7 - UINT8 /////////
	param7 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_22_1_Year, round((param7 * 1.0) - (2000) + (2000), 1.0));
	P_FSG_50_0_0_22_BuildFct();
}

on envVar P_FSG_50_0_0_22_2_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_22_2);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_22_2,thisval);
}

on envVar P_FSG_50_0_0_22_2_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_22_2);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_22_2,thisval);
}

on envVar P_FSG_50_0_0_22_2_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_22_2);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_22_2,thisval);
}

on envVar P_FSG_50_0_0_22_2_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_22_2);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_50_0_0_22_2,thisval);
}

on envVar P_FSG_50_0_0_22_2_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_22_2);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_50_0_0_22_2,thisval);
}

on envVar P_FSG_50_0_0_22_2 // TimeToDestination.ValidityInformation
{
	P_FSG_50_0_0_22_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_23_ErrCode
{
       if(gP_FSG_50_0_0_23_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_23", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_23_ErrCode = 1;
}
on envVar P_FSG_50_0_0_23Status_BTN
{
	byte BAPTemp[72];
    if (P_FSG_50_0_0_23Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_23_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_23",MakeRGB(255,255,255));
        P_FSG_50_0_0_23Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_23_BuildFct();
        getValue(P_FSG_50_0_0_23, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_23_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_23));
        if(getValue(P_FSG_50_0_0_23_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_23_ID);
        }
        if(getValue(P_FSG_50_0_0_23_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_23_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_23Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_23_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_23_ID;
    data[2]=getValue(P_FSG_50_0_0_23_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_23
on envVar P_FSG_50_0_0_23_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_23",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_23",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_23",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_23", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_23",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_23",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_23",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_23", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_23_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_23_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_23_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_23_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_23_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_23_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_23_ID,getValueSize(P_FSG_50_0_0_23_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_23_ID);
       }
}
on envVar P_FSG_50_0_0_23 // bus value of ManeuverDescriptor (23).
{
	// opcodes: Error-Status
	byte param1[24]; //Record: Maneuver_1
	byte param2[24]; //Record: Maneuver_2
	byte param3[24]; //Record: Maneuver_3
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[72];
	dword currentPos;
  
  int length1, length2, length3;
  
	currentPos = 0;
	for( i = 0; i < 63; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_23, superval);
	///////// Start param1 - Record /////////
	for( i = 0; i <= getvaluesize(P_FSG_50_0_0_23_1)-1; i++ )
	{
		param1[i] = superval[currentPos++];
	}
  length1 = currentPos;
	putValue(P_FSG_50_0_0_23_1, param1,length1);
	///////// Start param2 - Record /////////
	for( i = 0; i < getvaluesize(P_FSG_50_0_0_23_2); i++ )
	{
		param2[i] = superval[currentPos++];
	}
  length2 = currentPos - length1;
	putValue(P_FSG_50_0_0_23_2, param2,length2);
	///////// Start param3 - Record /////////
	for( i = 0; i < getvaluesize(P_FSG_50_0_0_23_3); i++ )
	{
		param3[i] = superval[currentPos++];
	}
  length3 = currentPos - length1 - length2;
	putValue(P_FSG_50_0_0_23_3, param3,length3);
}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_23_BuildFct()
{
	byte param1[24]; //Record: Maneuver_1
	byte param2[24]; //Record: Maneuver_2
	byte param3[24]; //Record: Maneuver_3

	dword i;
	byte superval[72];
	dword currentPos;
    
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	//Record:Maneuver_1
	getValue(P_FSG_50_0_0_23_1, param1);
	for( i = 0; i <= getvaluesize(P_FSG_50_0_0_23_1)-1; i++)
	{
	 superval[currentPos++] = param1[i];
	}
// gen_BuildFunc_SetSuperVals 
	//Record:Maneuver_2
	getValue(P_FSG_50_0_0_23_2, param2);
	for( i = 0; i <= getvaluesize(P_FSG_50_0_0_23_2)-1; i++)
	{
	 superval[currentPos++] = param2[i];
	}
// gen_BuildFunc_SetSuperVals 
	//Record:Maneuver_3
	getValue(P_FSG_50_0_0_23_3, param3);
	for( i = 0; i <= getvaluesize(P_FSG_50_0_0_23_3)-1; i++)
	{
	 superval[currentPos++] = param3[i];
	}
	putValue(P_FSG_50_0_0_23, superval, currentPos);
}


//Record: Maneuver_1, Element: MainElement
on envVar P_FSG_50_0_0_23_1_MainElement // Maneuver_1.MainElement
{
	byte superval[24];

	//Update Childvalue (Enum)
	byte thisval; // MainElement
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_23_1, superval);
	superval[0]=thisval;
 
	if (getvaluesize(P_FSG_50_0_0_23_1) != 0)
    putValue(P_FSG_50_0_0_23_1,superval,getvaluesize(P_FSG_50_0_0_23_1));
  else
    putValue(P_FSG_50_0_0_23_1,superval,3);
}

//Record: Maneuver_1, Element: Direction
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_23_1_Direction_range // ManeuverDescriptor.Direction 
{
	@P_FSG_50_0_0_23_1_Direction = @P_FSG_50_0_0_23_1_Direction_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_23_1_Direction // Maneuver_1.Direction
{
	byte superval[24];

	//Update Childvalue (Number)
	byte thisval; // Direction
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_23_1_Direction, 1.0);
	@P_FSG_50_0_0_23_1_Direction_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_23_1, superval);
	superval[1]=thisval;
  
  if (getvaluesize(P_FSG_50_0_0_23_1) != 0)
    putValue(P_FSG_50_0_0_23_1,superval,getvaluesize(P_FSG_50_0_0_23_1));
  else
    putValue(P_FSG_50_0_0_23_1,superval,3);
}

//Record: Maneuver_1, Element: Z-LevelGuidance
on envVar P_FSG_50_0_0_23_1_Z_LevelGuidance // Maneuver_1.Z-LevelGuidance
{
	byte superval[24];

	//Update Childvalue (Enum)
	byte thisval; // Z-LevelGuidance
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_23_1, superval);
	superval[2]=thisval;

	if (getvaluesize(P_FSG_50_0_0_23_1) != 0)
    putValue(P_FSG_50_0_0_23_1,superval,getvaluesize(P_FSG_50_0_0_23_1));
  else
   putValue(P_FSG_50_0_0_23_1,superval,3);
}

//Record: Maneuver_1, Element: Sidestreets
on envVar P_FSG_50_0_0_23_1_Sidestreets // Maneuver_1.Sidestreets
{
	byte superval[24];

	//Update Childvalue (String)
	word i;
	byte thisval[24];
	getValue(this, thisval);

    // Update superval
	getValue(P_FSG_50_0_0_23_1, superval);
  
  putValue(P_FSG_50_0_0_23_1_Sidestreets_len, getValueSize(this));
  
  superval[3] = getvalue(P_FSG_50_0_0_23_1_Sidestreets_len);
  
	for( i = 0; i <= getvalue(P_FSG_50_0_0_23_1_Sidestreets_len); i++ )
	{
		superval[i+4] = thisval[i];
	}
  
	putValue(P_FSG_50_0_0_23_1,superval,getvalue(P_FSG_50_0_0_23_1_Sidestreets_len)+4);
}

on envVar P_FSG_50_0_0_23_1_1
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_2
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_3
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_4
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_5
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_6
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_7
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_8
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_9
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_10
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_11
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_12
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_13
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_14
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_15
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_16
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_17
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_18
{
	build_RGI_string_1();
}

on envVar P_FSG_50_0_0_23_1_19
{
	build_RGI_string_1();
}

build_RGI_string_1()
{
  byte i;
  byte RGI_Buffer[24];
  byte RGI_Buffer_pos;
  
 //Array leeren
  for (i=0;i<21;i++)
    RGI_Buffer[i]=0;
  
  //Zähler löschen
  RGI_Buffer_pos = 0;
  
  //Checkbox 1 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_1) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x00;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 2 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_2) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x10;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 3 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_3) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x20;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 4 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_4) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x30;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 5 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_5) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x40;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 6 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_6) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x50;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 7 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_7) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x60;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 8 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_8) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x70;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 9 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_9) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x80;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 10 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_10) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x90;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 11 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_11) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xA0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 12 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_12) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xB0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 13 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_13) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xC0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 14 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_14) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xD0;
    RGI_Buffer_pos++;
  }
  //Checkbox 15 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_15) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xE0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 16 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_16) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xF0;
    RGI_Buffer_pos++;
  }
    
  //Checkbox 17 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_17) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x41;
    RGI_Buffer_pos++;
  }
    
  //Checkbox 18 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_18) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xC1;
    RGI_Buffer_pos++;
  }
    
  //Checkbox 19 prüfen
  if (getvalue(P_FSG_50_0_0_23_1_19) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xFF;
    RGI_Buffer_pos++;
  }
  //String bauen
  putvalue(P_FSG_50_0_0_23_1_Sidestreets,RGI_Buffer,RGI_Buffer_pos);
}

on envVar P_FSG_50_0_0_23_1 // ManeuverDescriptor.Maneuver_1
{
	byte recordVal[24]; //Record: Maneuver_1
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	byte param1; // MainElement
	byte param2; // Direction
	byte param3; // Z_LevelGuidance
	byte param4[24]; // Sidestreets

	currentPos = 0;
	getValue(P_FSG_50_0_0_23_1, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT8 /////////
	param1 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_23_1_MainElement, param1);
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_23_1_Direction, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_23_1_Z_LevelGuidance, param3);
  currentPos++;
	///////// Start param4 - STRING (fixedBytesequnece)/////////
	for( i = 0; i <= getvalue(P_FSG_50_0_0_23_1_Sidestreets_len); i++ )
	{
		param4[i] = recordVal[currentPos++];
	}
  //putValue(P_FSG_50_0_0_23_1_Sidestreets, param4, 17);
  putValue(P_FSG_50_0_0_23_1_Sidestreets, param4, getvalue(P_FSG_50_0_0_23_1_Sidestreets_len));
	P_FSG_50_0_0_23_BuildFct();
}

//Record: Maneuver_2, Element: MainElement
on envVar P_FSG_50_0_0_23_2_MainElement // Maneuver_2.MainElement
{
	byte superval[24];

	//Update Childvalue (Enum)
	byte thisval; // MainElement
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_23_2, superval);
	superval[0]=thisval;
  
	if (getvaluesize(P_FSG_50_0_0_23_2) != 0)
    putValue(P_FSG_50_0_0_23_2,superval,getvaluesize(P_FSG_50_0_0_23_2));
  else
    putValue(P_FSG_50_0_0_23_2,superval,3);
}

//Record: Maneuver_2, Element: Direction
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_23_2_Direction_range // ManeuverDescriptor.Direction 
{
	@P_FSG_50_0_0_23_2_Direction = @P_FSG_50_0_0_23_2_Direction_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_23_2_Direction // Maneuver_2.Direction
{
	byte superval[24];

	//Update Childvalue (Number)
	byte thisval; // Direction
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_23_2_Direction, 1.0);
	@P_FSG_50_0_0_23_2_Direction_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_23_2, superval);
	superval[1]=thisval;
  
	if (getvaluesize(P_FSG_50_0_0_23_2) != 0)
    putValue(P_FSG_50_0_0_23_2,superval,getvaluesize(P_FSG_50_0_0_23_2));
  else
    putValue(P_FSG_50_0_0_23_2,superval,3);
}

//Record: Maneuver_2, Element: Z_LevelGuidance
on envVar P_FSG_50_0_0_23_2_Z_LevelGuidance // Maneuver_2.Z_LevelGuidance
{
	byte superval[24];

	//Update Childvalue (Enum)
	byte thisval; // Z_LevelGuidance
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_23_2, superval);
	superval[2]=thisval;
  
	if (getvaluesize(P_FSG_50_0_0_23_2) != 0)
    putValue(P_FSG_50_0_0_23_2,superval,getvaluesize(P_FSG_50_0_0_23_2));
  else
    putValue(P_FSG_50_0_0_23_2,superval,3);
}

//Record: Maneuver_2, Element: Sidestreets
on envVar P_FSG_50_0_0_23_2_Sidestreets // Maneuver_2.Sidestreets
{
	byte superval[24];

	//Update Childvalue (String)
	word i;
	byte thisval[24];
	getValue(this, thisval);

    // Update superval
	getValue(P_FSG_50_0_0_23_2, superval);
  
  putValue(P_FSG_50_0_0_23_2_Sidestreets_len, getValueSize(this));
  
  superval[3] = getvalue(P_FSG_50_0_0_23_2_Sidestreets_len);
  
	for( i = 0; i < getvalue(P_FSG_50_0_0_23_2_Sidestreets_len); i++ )
	{
		superval[i+4] = thisval[i];
	}
  
	putValue(P_FSG_50_0_0_23_2,superval,getvalue(P_FSG_50_0_0_23_2_Sidestreets_len)+4);
}

on envVar P_FSG_50_0_0_23_2_1
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_2
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_3
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_4
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_5
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_6
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_7
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_8
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_9
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_10
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_11
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_12
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_13
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_14
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_15
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_16
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_17
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_18
{
	build_RGI_string_2();
}

on envVar P_FSG_50_0_0_23_2_19
{
	build_RGI_string_2();
}

build_RGI_string_2()
{
  byte i;
  byte RGI_Buffer[24];
  byte RGI_Buffer_pos=0;
  
 //Array leeren
  for (i=0;i<21;i++)
    RGI_Buffer[i]=0;
  
  //Zähler löschen
  RGI_Buffer_pos = 0;
  
  //Checkbox 1 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_1) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x00;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 2 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_2) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x10;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 3 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_3) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x20;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 4 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_4) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x30;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 5 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_5) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x40;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 6 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_6) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x50;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 7 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_7) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x60;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 8 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_8) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x70;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 9 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_9) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x80;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 10 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_10) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x90;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 11 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_11) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xA0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 12 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_12) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xB0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 13 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_13) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xC0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 14 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_14) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xD0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 15 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_15) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xE0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 16 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_16) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xF0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 17 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_17) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x41;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 18 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_18) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xC1;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 19 prüfen
  if (getvalue(P_FSG_50_0_0_23_2_19) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xFF;
    RGI_Buffer_pos++;
  }
  //String bauen
  putvalue(P_FSG_50_0_0_23_2_Sidestreets,RGI_Buffer,RGI_Buffer_pos);
}


on envVar P_FSG_50_0_0_23_2 // ManeuverDescriptor.Maneuver_2
{
	byte recordVal[24]; //Record: Maneuver_2
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	byte param1; // MainElement
	byte param2; // Direction
	byte param3; // Z_LevelGuidance
	byte param4[24]; // Sidestreets

	currentPos = 0;
	getValue(P_FSG_50_0_0_23_2, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT8 /////////
	param1 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_23_2_MainElement, param1);
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_23_2_Direction, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_23_2_Z_LevelGuidance, param3);
  currentPos++;
	///////// Start param4 - STRING (fixedBytesequnece)/////////
	for( i = 0; i < getvalue(P_FSG_50_0_0_23_2_Sidestreets_len); i++ )
	{
		param4[i] = recordVal[currentPos++];
	}
	//putValue(P_FSG_50_0_0_23_2_Sidestreets, param4, 17);
  putValue(P_FSG_50_0_0_23_2_Sidestreets, param4, getvalue(P_FSG_50_0_0_23_2_Sidestreets_len));
	P_FSG_50_0_0_23_BuildFct();
}

//Record: Maneuver_3, Element: MainElement
on envVar P_FSG_50_0_0_23_3_MainElement // Maneuver_3.MainElement
{
	byte superval[24];

	//Update Childvalue (Enum)
	byte thisval; // MainElement
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_23_3, superval);
	superval[0]=thisval;
	
  if (getvaluesize(P_FSG_50_0_0_23_3) != 0)
    putValue(P_FSG_50_0_0_23_3,superval,getvaluesize(P_FSG_50_0_0_23_3));
  else
    putValue(P_FSG_50_0_0_23_3,superval,3);
}

//Record: Maneuver_3, Element: Direction
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_23_3_Direction_range // ManeuverDescriptor.Direction 
{
	@P_FSG_50_0_0_23_3_Direction = @P_FSG_50_0_0_23_3_Direction_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_23_3_Direction // Maneuver_3.Direction
{
	byte superval[24];

	//Update Childvalue (Number)
	byte thisval; // Direction
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_23_3_Direction, 1.0);
	@P_FSG_50_0_0_23_3_Direction_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_23_3, superval);
	superval[1]=thisval;
	
  if (getvaluesize(P_FSG_50_0_0_23_3) != 0)
    putValue(P_FSG_50_0_0_23_3,superval,getvaluesize(P_FSG_50_0_0_23_3));
  else
    putValue(P_FSG_50_0_0_23_3,superval,3);
}

//Record: Maneuver_3, Element: Z_LevelGuidance
on envVar P_FSG_50_0_0_23_3_Z_LevelGuidance // Maneuver_3.Z_LevelGuidance
{
	byte superval[24];

	//Update Childvalue (Enum)
	byte thisval; // Z_LevelGuidance
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_23_3, superval);
	superval[2]=thisval;
	
  if (getvaluesize(P_FSG_50_0_0_23_3) != 0)
    putValue(P_FSG_50_0_0_23_3,superval,getvaluesize(P_FSG_50_0_0_23_3));
  else
    putValue(P_FSG_50_0_0_23_3,superval,3);
}

//Record: Maneuver_3, Element: Sidestreets
on envVar P_FSG_50_0_0_23_3_Sidestreets // Maneuver_3.Sidestreets
{
	byte superval[24];

	//Update Childvalue (String)
	word i;
	byte thisval[24];
	getValue(this, thisval);

    // Update superval
	getValue(P_FSG_50_0_0_23_3, superval);
  
  putValue(P_FSG_50_0_0_23_3_Sidestreets_len, getValueSize(this));
  
  superval[3] = getvalue(P_FSG_50_0_0_23_3_Sidestreets_len);
  
	for( i = 0; i < getvalue(P_FSG_50_0_0_23_3_Sidestreets_len); i++ )
	{
		superval[i+4] = thisval[i];
	}
  
	putValue(P_FSG_50_0_0_23_3,superval,getvalue(P_FSG_50_0_0_23_3_Sidestreets_len)+4);
}

on envVar P_FSG_50_0_0_23_3_1
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_2
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_3
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_4
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_5
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_6
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_7
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_8
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_9
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_10
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_11
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_12
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_13
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_14
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_15
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_16
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_17
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_18
{
	build_RGI_string_3();
}

on envVar P_FSG_50_0_0_23_3_19
{
	build_RGI_string_3();
}

build_RGI_string_3()
{
  byte i;
  byte RGI_Buffer[24];
  byte RGI_Buffer_pos=0;
  
  //Array leeren
  for (i=0;i<21;i++)
    RGI_Buffer[i]=0;
  
  //Zähler löschen
  RGI_Buffer_pos = 0;
  
  //Checkbox 1 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_1) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x00;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 2 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_2) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x10;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 3 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_3) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x20;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 4 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_4) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x30;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 5 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_5) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x40;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 6 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_6) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x50;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 7 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_7) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x60;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 8 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_8) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x70;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 9 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_9) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x80;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 10 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_10) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x90;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 11 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_11) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xA0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 12 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_12) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xB0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 13 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_13) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xC0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 14 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_14) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xD0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 15 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_15) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xE0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 16 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_16) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xF0;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 17 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_17) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0x41;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 18 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_18) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xC1;
    RGI_Buffer_pos++;
  }
  
  //Checkbox 19 prüfen
  if (getvalue(P_FSG_50_0_0_23_3_19) == 1)
  {
    RGI_Buffer[RGI_Buffer_pos] = 0xFF;
    RGI_Buffer_pos++;
  }
  
  //String bauen
  putvalue(P_FSG_50_0_0_23_3_Sidestreets,RGI_Buffer,RGI_Buffer_pos);
}

on envVar P_FSG_50_0_0_23_3 // ManeuverDescriptor.Maneuver_3
{
	byte recordVal[24]; //Record: Maneuver_3
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	byte param1; // MainElement
	byte param2; // Direction
	byte param3; // Z_LevelGuidance
	byte param4[24]; // Sidestreets

	currentPos = 0;
	getValue(P_FSG_50_0_0_23_3, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT8 /////////
	param1 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_23_3_MainElement, param1);
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_23_3_Direction, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_23_3_Z_LevelGuidance, param3);
  currentPos++;
	///////// Start param4 - STRING (fixedBytesequnece)/////////
	for( i = 0; i < getvalue(P_FSG_50_0_0_23_3_Sidestreets_len); i++ )
	{
		param4[i] = recordVal[currentPos++];
	}
	//putValue(P_FSG_50_0_0_23_3_Sidestreets, param4, 17);
  putValue(P_FSG_50_0_0_23_3_Sidestreets, param4, getvalue(P_FSG_50_0_0_23_3_Sidestreets_len));
	P_FSG_50_0_0_23_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_50_0_0_24_ErrCode
{
       if(gA_FSG_50_0_0_24_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_24", MakeRGB(255,255,255));
       }
       gA_FSG_50_0_0_24_ErrCode = 1;
}
on envVar A_FSG_50_0_0_24Changed_BTN
{
    byte data[181]; 
    byte stringValue[181];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_50_0_0_24Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_24_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_24",MakeRGB(255,255,255));
        A_FSG_50_0_0_24Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //Einzelparameter: LaneGuidanceOnOff
        tempValue = getValue(A_FSG_50_0_0_24_1_Changed);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_24_Changed);
        getValue(A_FSG_50_0_0_24_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_24_Changed_Start);
     elementsVal = getValue(A_FSG_50_0_0_24_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_24_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 24");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_24_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_24_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 24");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_50_0_0_24_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_50_0_0_24_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_50_0_0_24_ID);
       }
       if(getValue(A_FSG_50_0_0_24_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_50_0_0_24_ID,getValueSize(A_FSG_50_0_0_24_Changed));
       }
        A_FSG_50_0_0_24Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_24Status_BTN
{
    byte data[181 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[181];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
  
    if (A_FSG_50_0_0_24Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_24_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_24",MakeRGB(255,255,255));
        A_FSG_50_0_0_24Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_24_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_24_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: LaneGuidanceOnOff
        tempValue = getValue(A_FSG_50_0_0_24_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_24);
        getValue(A_FSG_50_0_0_24,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_24_Start);
     elementsVal = getValue(A_FSG_50_0_0_24_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_24_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 24");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LaneDirection:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneSidestreets:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_24_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_24_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_24_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_24_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_24_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable LaneType:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_left:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_right:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneDescription:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) || 3 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) || 3 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param8) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param8 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_24_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_24_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 24");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LaneDirection:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneSidestreets:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_24_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_24_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_24_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_24_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_24_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable LaneType:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_left:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_right:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneDescription:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) || 3 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) || 3 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param8) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param8 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_50_0_0_24, data);
        Request_ByteSequence(LSGID, A_FSG_50_0_0_24_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_50_0_0_24_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_50_0_0_24_ID);
        }
        if(getValue(A_FSG_50_0_0_24_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_50_0_0_24_ID,getValueSize(A_FSG_50_0_0_24));
        }
        A_FSG_50_0_0_24Status_BTN_already_pressed = 0;
    }
}
A_FSG_50_0_0_24_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[181];
    byte stringValue[181];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_24_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_24_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: LaneGuidanceOnOff
        tempValue = getValue(A_FSG_50_0_0_24_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_24);
        getValue(A_FSG_50_0_0_24,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_24_Start);
     elementsVal = getValue(A_FSG_50_0_0_24_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       write("startVal: %d / elementsVal: %d",startVal,elementsVal);
       if( i < 0 || i >= A_FSG_50_0_0_24_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 24");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LaneDirection:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0; write("currentPos: %d / i: %d",currentPos,i);
        data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneSidestreets:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_24_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_24_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_24_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_24_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_24_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable LaneType:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_left:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_right:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneDescription:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) || 3 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) || 3 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param8) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param8 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_24_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_24_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 24");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LaneDirection:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneSidestreets:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_24_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_24_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_24_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_24_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_24_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_24_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable LaneType:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_24_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_left:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_right:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneDescription:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) || 3 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo:
      if( 0 || 0 == getValue( A_FSG_50_0_0_24_RecAdr ) || 1 == getValue( A_FSG_50_0_0_24_RecAdr ) || 2 == getValue( A_FSG_50_0_0_24_RecAdr ) || 3 == getValue( A_FSG_50_0_0_24_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param8) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_24_ArrayDataList[i].Param8 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_50_0_0_24_ID, Data_REQ, data, currentPos);
}

on envVar A_FSG_50_0_0_24Status_BTN2
{
  A_FSG_50_0_0_24_SendStatus(); 
}

on envVar A_FSG_50_0_0_24
{
    byte temp[181];
    getValue(A_FSG_50_0_0_24, temp);
    putValue(A_FSG_50_0_0_24_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_24_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_24_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_24_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_24_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_50_0_0_24_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_50_0_0_24_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_24_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_24_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_24_IndexSize))
    {
        putValue(A_FSG_50_0_0_24_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_50_0_0_24_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_50_0_0_24_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_50_0_0_24_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_50_0_0_24_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_24_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_24_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_24_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_24_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_24_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_24_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_24_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_24_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_24_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_24_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_24_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_24_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_24_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_50_0_0_24, head, headLength); 
}

on envVar A_FSG_50_0_0_24_RecAdr
{
    A_FSG_50_0_0_24_GenerateStatus();
}

on envVar A_FSG_50_0_0_24_Shift
{
    A_FSG_50_0_0_24_GenerateStatus();
}

on envVar A_FSG_50_0_0_24_Direction
{
    A_FSG_50_0_0_24_GenerateStatus();
}

on envVar A_FSG_50_0_0_24_Start
{
    A_FSG_50_0_0_24_GenerateStatus();
}

on envVar A_FSG_50_0_0_24_Elements
{
    A_FSG_50_0_0_24_GenerateStatus();
}

on envVar A_FSG_50_0_0_24_IndexSize
{
    A_FSG_50_0_0_24_GenerateStatus();
}
on envVar A_FSG_50_0_0_24_TransPos
{
    A_FSG_50_0_0_24_GenerateStatus();
}
A_FSG_50_0_0_24_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_24_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_24_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_24_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_24_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_24_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_24_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_24_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_24_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_24_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_24_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_24_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_50_0_0_24_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_24_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_24_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_50_0_0_24_Changed, head, 3); 
    }
}

on envVar A_FSG_50_0_0_24_Changed_RecAdr
{
    A_FSG_50_0_0_24_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_24_Changed_Shift
{
    A_FSG_50_0_0_24_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_24_Changed_Direction
{
    A_FSG_50_0_0_24_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_24_Changed_Start
{
    A_FSG_50_0_0_24_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_24_Changed_Elements
{
    A_FSG_50_0_0_24_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_24_Changed_IndexSize
{
    A_FSG_50_0_0_24_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_24_Changed_TransPos
{
    A_FSG_50_0_0_24_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_24_FRU
{
  byte data[4];
  
  data[0]=0x01;
  data[1]=0x00;
  data[2]=0x00;
  data[3]=0xFF;
  
  if(getvalue(this) == 1)
  {
    fru_flag = 1;
    @Env_LG_Source = 2; // Panel
    @Env_BAPList_Source = 1; // Panel
    Request_ByteSequence(50, A_FSG_50_0_0_24_ID, Changed_REQ, data, 4);
  }
}

on envVar A_FSG_50_0_0_24_SetGet
{
    byte temp[181];
    getValue(A_FSG_50_0_0_24_SetGet, temp);
    putValue(A_FSG_50_0_0_24_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_24_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_24_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_24_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_24_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_24_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_24_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_24_SetGet_IndexSize))
    {
        putValue(A_FSG_50_0_0_24_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_50_0_0_24_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_50_0_0_24_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_50_0_0_24_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_50_0_0_24_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_50_0_0_24_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_50_0_0_24_ArrayDataList[i].Param1 = 0;
		A_FSG_50_0_0_24_ArrayDataList[i].Param2 = 0;
		for(j=0; j<17; j++)
			A_FSG_50_0_0_24_ArrayDataList[i].Param3[j] = 0;
		A_FSG_50_0_0_24_ArrayDataList[i].Param3_Length = 0;
		A_FSG_50_0_0_24_Data_3_LenList[i] = 0;
		A_FSG_50_0_0_24_ArrayDataList[i].Param4 = 0;
		A_FSG_50_0_0_24_ArrayDataList[i].Param5 = 0;
		A_FSG_50_0_0_24_ArrayDataList[i].Param6 = 0;
		A_FSG_50_0_0_24_ArrayDataList[i].Param7 = 0;
		A_FSG_50_0_0_24_ArrayDataList[i].Param8 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_50_0_0_24_fileSelector,gListPath);
  
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 9) //ignore first line in *.csv file
					{
						A_FSG_50_0_0_24_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_50_0_0_24_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //LaneDirection
						A_FSG_50_0_0_24_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //LaneType
						A_FSG_50_0_0_24_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //LaneMarking_left
						A_FSG_50_0_0_24_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //LaneMarking_right
						A_FSG_50_0_0_24_ArrayDataList[current_CSV_line-1].Param7 = atol(temp7); //LaneDescription
						A_FSG_50_0_0_24_ArrayDataList[current_CSV_line-1].Param8 = atol(temp8); //GuidanceInfo
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 9)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //LaneDirection
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //LaneSidestreets
								if(paramPos < 16)
								{
									A_FSG_50_0_0_24_ArrayDataList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_24_ArrayDataList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 4: //LaneType
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //LaneMarking_left
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //LaneMarking_right
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //LaneDescription
								if( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //GuidanceInfo
								if( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_50_0_0_24_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_50_0_0_24_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_24_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_50_0_0_24_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_50_0_0_24_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			//writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_50_0_0_24_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_50_0_0_24_Data_1, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_24_Data_2, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_24_Data_3, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param3, A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param3_Length);
	putValue(A_FSG_50_0_0_24_Data_4, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param4);
	putValue(A_FSG_50_0_0_24_Data_5, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param5);
	putValue(A_FSG_50_0_0_24_Data_6, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param6);
	putValue(A_FSG_50_0_0_24_Data_7, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param7);
	putValue(A_FSG_50_0_0_24_Data_8, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param8);
}


on envVar A_FSG_50_0_0_24_generateData_Btn
{
	word i;
	dword elementsArray[9] = {1, 1, 17, 2, 1, 1, 1, 1, 1};
	byte elementsTypeArray[9] = {0, 0, 0xE, 0xF, 0, 0, 0, 0, 0};
	dword elementsMaxSizeArray[9] = {8, 254, 0, 0, 0xFF, 0xF, 0xF, 0xF, 0xF};
	byte tempArray[6630];
	if (A_FSG_50_0_0_24_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_24_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 24, 255 );
		for(i = 0; i < 255; i++)
		{
			memcpy(A_FSG_50_0_0_24_ArrayDataList[i], tempArray, (i * 26) );
			if(A_FSG_50_0_0_24_ArrayDataList[i].Param3_Length > 127 )
				A_FSG_50_0_0_24_Data_3_CntList[i] = 1;
		}
		A_FSG_50_0_0_24_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_50_0_0_24_Data_1, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_24_Data_2, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_24_Data_3, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param3, A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param3_Length);
	putValue(A_FSG_50_0_0_24_Data_4, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param4);
	putValue(A_FSG_50_0_0_24_Data_5, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param5);
	putValue(A_FSG_50_0_0_24_Data_6, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param6);
	putValue(A_FSG_50_0_0_24_Data_7, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param7);
	putValue(A_FSG_50_0_0_24_Data_8, A_FSG_50_0_0_24_ArrayDataList[ getValue( A_FSG_50_0_0_24_DataIndex) ].Param8);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_50_0_0_24_DataIndex
{
    long index;
    long maxIndex = 255-1;
    int dec, inc;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    
    
    EnableFctCtrl_LG();
    DisableFctCtrl_LG();
    
    /*putValue(A_FSG_50_0_0_24_Data_1, A_FSG_50_0_0_24_ArrayDataList[index].Param1);
    putValue(A_FSG_50_0_0_24_Data_2, A_FSG_50_0_0_24_ArrayDataList[index].Param2);
    putValue(A_FSG_50_0_0_24_Data_3_len, A_FSG_50_0_0_24_Data_3_LenList[index]);
    putValue(A_FSG_50_0_0_24_Data_3_cnt, A_FSG_50_0_0_24_Data_3_CntList[index]);
    putValue(A_FSG_50_0_0_24_Data_3, A_FSG_50_0_0_24_ArrayDataList[index].Param3, A_FSG_50_0_0_24_ArrayDataList[index].Param3_Length);
    putValue(A_FSG_50_0_0_24_Data_4, A_FSG_50_0_0_24_ArrayDataList[index].Param4);
    putValue(A_FSG_50_0_0_24_Data_5, A_FSG_50_0_0_24_ArrayDataList[index].Param5);
    putValue(A_FSG_50_0_0_24_Data_6, A_FSG_50_0_0_24_ArrayDataList[index].Param6);
    putValue(A_FSG_50_0_0_24_Data_7, A_FSG_50_0_0_24_ArrayDataList[index].Param7);
    putValue(A_FSG_50_0_0_24_Data_8, A_FSG_50_0_0_24_ArrayDataList[index].Param8);*/
    putValue(A_FSG_50_0_0_24_Elements,getValue(this)+1);
    
    if(index_lane > getValue(this))
    {
      dec = 1;
      inc = 0;
    }
    else
    {
      dec = 0;
      inc = 1;
    }
    
    EnableControl(LG_panel,"LSS18",0);
     EnableControl(LG_panel,"LSS28",0);
     EnableControl(LG_panel,"LSS38",0);
     EnableControl(LG_panel,"LSS17",0);
     EnableControl(LG_panel,"LSS27",0);
     EnableControl(LG_panel,"LSS37",0);  
     EnableControl(LG_panel,"LSS16",0);
     EnableControl(LG_panel,"LSS26",0);
     EnableControl(LG_panel,"LSS36",0);
     EnableControl(LG_panel,"LSS15",0);
     EnableControl(LG_panel,"LSS25",0);
     EnableControl(LG_panel,"LSS35",0);
     EnableControl(LG_panel,"LSS14",0);
     EnableControl(LG_panel,"LSS24",0);
     EnableControl(LG_panel,"LSS34",0);
     EnableControl(LG_panel,"LSS13",0);
     EnableControl(LG_panel,"LSS23",0);
     EnableControl(LG_panel,"LSS33",0);
     EnableControl(LG_panel,"LSS12",0);
     EnableControl(LG_panel,"LSS22",0);
     EnableControl(LG_panel,"LSS32",0);     
     EnableControl(LG_panel,"LSS11",0);
     EnableControl(LG_panel,"LSS21",0);
     EnableControl(LG_panel,"LSS31",0);
                 
    
     index_lane = getvalue(this);
        
        //lanemaking setzen
    if(getValue(this) == 7)
    {
      putValue(A_FSG_50_0_0_24_Data_5_1,1);
      putValue(A_FSG_50_0_0_24_Data_6_1,2);      
      putValue(A_FSG_50_0_0_24_Data_5_2,2);
      putValue(A_FSG_50_0_0_24_Data_6_2,2);      
      putValue(A_FSG_50_0_0_24_Data_5_3,2);
      putValue(A_FSG_50_0_0_24_Data_6_3,2);      
      putValue(A_FSG_50_0_0_24_Data_5_4,2);
      putValue(A_FSG_50_0_0_24_Data_6_4,2);      
      putValue(A_FSG_50_0_0_24_Data_5_5,2);
      putValue(A_FSG_50_0_0_24_Data_6_5,2);
      putValue(A_FSG_50_0_0_24_Data_5_6,2);
      putValue(A_FSG_50_0_0_24_Data_6_6,2);
      putValue(A_FSG_50_0_0_24_Data_5_7,2);
      putValue(A_FSG_50_0_0_24_Data_6_7,2);
      putValue(A_FSG_50_0_0_24_Data_5_8,2);
      putValue(A_FSG_50_0_0_24_Data_6_8,1);

    }

    if(getValue(this) == 6)
    {
      putValue(A_FSG_50_0_0_24_Data_5_1,1);
      putValue(A_FSG_50_0_0_24_Data_6_1,2);      
      putValue(A_FSG_50_0_0_24_Data_5_2,2);
      putValue(A_FSG_50_0_0_24_Data_6_2,2);      
      putValue(A_FSG_50_0_0_24_Data_5_3,2);
      putValue(A_FSG_50_0_0_24_Data_6_3,2);      
      putValue(A_FSG_50_0_0_24_Data_5_4,2);
      putValue(A_FSG_50_0_0_24_Data_6_4,2);      
      putValue(A_FSG_50_0_0_24_Data_5_5,2);
      putValue(A_FSG_50_0_0_24_Data_6_5,2);      
      putValue(A_FSG_50_0_0_24_Data_5_6,2);
      putValue(A_FSG_50_0_0_24_Data_6_6,2);      
      putValue(A_FSG_50_0_0_24_Data_5_7,2);
      putValue(A_FSG_50_0_0_24_Data_6_7,1);      
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      
      putValue(A_FSG_50_0_0_24_Data_8_8,0);
      putValue(A_FSG_50_0_0_24_Data_7_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_4_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_8,0);
      putValue(A_FSG_50_0_0_24_Data_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_8,1);

      //putValue(A_FSG_50_0_0_24_Data_3_empty_2_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_1_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_3_1,1);

    }  
    
    if(getValue(this) == 5)
    {
      putValue(A_FSG_50_0_0_24_Data_5_1,1);
      putValue(A_FSG_50_0_0_24_Data_6_1,2);      
      putValue(A_FSG_50_0_0_24_Data_5_2,2);
      putValue(A_FSG_50_0_0_24_Data_6_2,2);      
      putValue(A_FSG_50_0_0_24_Data_5_3,2);
      putValue(A_FSG_50_0_0_24_Data_6_3,2);      
      putValue(A_FSG_50_0_0_24_Data_5_4,2);
      putValue(A_FSG_50_0_0_24_Data_6_4,2);      
      putValue(A_FSG_50_0_0_24_Data_5_5,2);
      putValue(A_FSG_50_0_0_24_Data_6_5,2);      
      putValue(A_FSG_50_0_0_24_Data_5_6,2);
      putValue(A_FSG_50_0_0_24_Data_6_6,1);      
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);      
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      
      putValue(A_FSG_50_0_0_24_Data_8_7,0);
      putValue(A_FSG_50_0_0_24_Data_7_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_4_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_7,0);
      putValue(A_FSG_50_0_0_24_Data_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_7,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_8,0);
      putValue(A_FSG_50_0_0_24_Data_7_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_4_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_8,0);
      putValue(A_FSG_50_0_0_24_Data_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_8,1);
      
      //putValue(A_FSG_50_0_0_24_Data_3_empty_2_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_1_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_3_1,1);

    }    
    
    if(getValue(this) == 4)
    {
      putValue(A_FSG_50_0_0_24_Data_5_1,1);
      putValue(A_FSG_50_0_0_24_Data_6_1,2);      
      putValue(A_FSG_50_0_0_24_Data_5_2,2);
      putValue(A_FSG_50_0_0_24_Data_6_2,2);      
      putValue(A_FSG_50_0_0_24_Data_5_3,2);
      putValue(A_FSG_50_0_0_24_Data_6_3,2);      
      putValue(A_FSG_50_0_0_24_Data_5_4,2);
      putValue(A_FSG_50_0_0_24_Data_6_4,2);      
      putValue(A_FSG_50_0_0_24_Data_5_5,2);
      putValue(A_FSG_50_0_0_24_Data_6_5,1);      
      putValue(A_FSG_50_0_0_24_Data_5_6,0);
      putValue(A_FSG_50_0_0_24_Data_6_6,0);      
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);      
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);

      putValue(A_FSG_50_0_0_24_Data_8_6,0);
      putValue(A_FSG_50_0_0_24_Data_7_6,0);
      putValue(A_FSG_50_0_0_24_Data_6_6,0);
      putValue(A_FSG_50_0_0_24_Data_5_6,0);
      putValue(A_FSG_50_0_0_24_Data_4_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_6,0);
      putValue(A_FSG_50_0_0_24_Data_2_6,0);
      putValue(A_FSG_50_0_0_24_Data_1_6,0);      
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_6,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_6,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_6,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_7,0);
      putValue(A_FSG_50_0_0_24_Data_7_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_4_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_7,0);
      putValue(A_FSG_50_0_0_24_Data_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_7,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_8,0);
      putValue(A_FSG_50_0_0_24_Data_7_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_4_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_8,0);
      putValue(A_FSG_50_0_0_24_Data_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_8,1);
      
      //putValue(A_FSG_50_0_0_24_Data_3_empty_2_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_1_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_3_1,1);
    }        
    if(getValue(this) == 3)
    {
      putValue(A_FSG_50_0_0_24_Data_5_1,1);
      putValue(A_FSG_50_0_0_24_Data_6_1,2);      
      putValue(A_FSG_50_0_0_24_Data_5_2,2);
      putValue(A_FSG_50_0_0_24_Data_6_2,2);      
      putValue(A_FSG_50_0_0_24_Data_5_3,2);
      putValue(A_FSG_50_0_0_24_Data_6_3,2);      
      putValue(A_FSG_50_0_0_24_Data_5_4,2);
      putValue(A_FSG_50_0_0_24_Data_6_4,1);      
      putValue(A_FSG_50_0_0_24_Data_5_5,0);
      putValue(A_FSG_50_0_0_24_Data_6_5,0);      
      putValue(A_FSG_50_0_0_24_Data_5_6,0);
      putValue(A_FSG_50_0_0_24_Data_6_6,0);      
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);      
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      
      putValue(A_FSG_50_0_0_24_Data_8_5,0);
      putValue(A_FSG_50_0_0_24_Data_7_5,0);
      putValue(A_FSG_50_0_0_24_Data_6_5,0);
      putValue(A_FSG_50_0_0_24_Data_5_5,0);
      putValue(A_FSG_50_0_0_24_Data_4_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_5,0);
      putValue(A_FSG_50_0_0_24_Data_2_5,0);
      putValue(A_FSG_50_0_0_24_Data_1_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_5,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_5,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_5,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_6,0);
      putValue(A_FSG_50_0_0_24_Data_7_6,0);
      putValue(A_FSG_50_0_0_24_Data_6_6,0);
      putValue(A_FSG_50_0_0_24_Data_5_6,0);
      putValue(A_FSG_50_0_0_24_Data_4_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_6,0);
      putValue(A_FSG_50_0_0_24_Data_2_6,0);
      putValue(A_FSG_50_0_0_24_Data_1_6,0);      
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_6,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_6,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_6,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_7,0);
      putValue(A_FSG_50_0_0_24_Data_7_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_4_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_7,0);
      putValue(A_FSG_50_0_0_24_Data_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_7,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_8,0);
      putValue(A_FSG_50_0_0_24_Data_7_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_4_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_8,0);
      putValue(A_FSG_50_0_0_24_Data_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_8,1);
      
      //putValue(A_FSG_50_0_0_24_Data_3_empty_2_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_1_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_3_1,1);

    }        
    if(getValue(this) == 2)
    {
      putValue(A_FSG_50_0_0_24_Data_5_1,1);
      putValue(A_FSG_50_0_0_24_Data_6_1,2);      
      putValue(A_FSG_50_0_0_24_Data_5_2,2);
      putValue(A_FSG_50_0_0_24_Data_6_2,2);      
      putValue(A_FSG_50_0_0_24_Data_5_3,2);
      putValue(A_FSG_50_0_0_24_Data_6_3,1);      
      putValue(A_FSG_50_0_0_24_Data_5_4,0);
      putValue(A_FSG_50_0_0_24_Data_6_4,0);      
      putValue(A_FSG_50_0_0_24_Data_5_5,0);
      putValue(A_FSG_50_0_0_24_Data_6_5,0);      
      putValue(A_FSG_50_0_0_24_Data_5_6,0);
      putValue(A_FSG_50_0_0_24_Data_6_6,0);      
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);      
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);

      putValue(A_FSG_50_0_0_24_Data_8_4,0);
      putValue(A_FSG_50_0_0_24_Data_7_4,0);
      putValue(A_FSG_50_0_0_24_Data_6_4,0);
      putValue(A_FSG_50_0_0_24_Data_5_4,0);
      putValue(A_FSG_50_0_0_24_Data_4_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_4,0);
      putValue(A_FSG_50_0_0_24_Data_2_4,0);
      putValue(A_FSG_50_0_0_24_Data_1_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_4,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_4,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_4,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_5,0);
      putValue(A_FSG_50_0_0_24_Data_7_5,0);
      putValue(A_FSG_50_0_0_24_Data_6_5,0);
      putValue(A_FSG_50_0_0_24_Data_5_5,0);
      putValue(A_FSG_50_0_0_24_Data_4_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_5,0);
      putValue(A_FSG_50_0_0_24_Data_2_5,0);
      putValue(A_FSG_50_0_0_24_Data_1_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_5,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_5,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_5,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_6,0);
      putValue(A_FSG_50_0_0_24_Data_7_6,0);
      putValue(A_FSG_50_0_0_24_Data_6_6,0);
      putValue(A_FSG_50_0_0_24_Data_5_6,0);
      putValue(A_FSG_50_0_0_24_Data_4_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_6,0);
      putValue(A_FSG_50_0_0_24_Data_2_6,0);
      putValue(A_FSG_50_0_0_24_Data_1_6,0);      
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_6,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_6,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_6,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_7,0);
      putValue(A_FSG_50_0_0_24_Data_7_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_4_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_7,0);
      putValue(A_FSG_50_0_0_24_Data_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_7,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_8,0);
      putValue(A_FSG_50_0_0_24_Data_7_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_4_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_8,0);
      putValue(A_FSG_50_0_0_24_Data_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_8,1);
      
      //putValue(A_FSG_50_0_0_24_Data_3_empty_2_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_1_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_3_1,1);
    }        
    if(getValue(this) == 1)
    {
      putValue(A_FSG_50_0_0_24_Data_5_1,1);
      putValue(A_FSG_50_0_0_24_Data_6_1,2);      
      putValue(A_FSG_50_0_0_24_Data_5_2,2);
      putValue(A_FSG_50_0_0_24_Data_6_2,1);      
      putValue(A_FSG_50_0_0_24_Data_5_3,0);
      putValue(A_FSG_50_0_0_24_Data_6_3,0);      
      putValue(A_FSG_50_0_0_24_Data_5_4,0);
      putValue(A_FSG_50_0_0_24_Data_6_4,0);      
      putValue(A_FSG_50_0_0_24_Data_5_5,0);
      putValue(A_FSG_50_0_0_24_Data_6_5,0);      
      putValue(A_FSG_50_0_0_24_Data_5_6,0);
      putValue(A_FSG_50_0_0_24_Data_6_6,0);      
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);      
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      
      putValue(A_FSG_50_0_0_24_Data_8_3,0);
      putValue(A_FSG_50_0_0_24_Data_7_3,0);
      putValue(A_FSG_50_0_0_24_Data_6_3,0);
      putValue(A_FSG_50_0_0_24_Data_5_3,0);
      putValue(A_FSG_50_0_0_24_Data_4_3,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_3,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_3,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_3,0);
      putValue(A_FSG_50_0_0_24_Data_2_3,0);
      putValue(A_FSG_50_0_0_24_Data_1_3,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_3,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_3,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_3,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_4,0);
      putValue(A_FSG_50_0_0_24_Data_7_4,0);
      putValue(A_FSG_50_0_0_24_Data_6_4,0);
      putValue(A_FSG_50_0_0_24_Data_5_4,0);
      putValue(A_FSG_50_0_0_24_Data_4_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_4,0);
      putValue(A_FSG_50_0_0_24_Data_2_4,0);
      putValue(A_FSG_50_0_0_24_Data_1_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_4,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_4,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_4,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_5,0);
      putValue(A_FSG_50_0_0_24_Data_7_5,0);
      putValue(A_FSG_50_0_0_24_Data_6_5,0);
      putValue(A_FSG_50_0_0_24_Data_5_5,0);
      putValue(A_FSG_50_0_0_24_Data_4_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_5,0);
      putValue(A_FSG_50_0_0_24_Data_2_5,0);
      putValue(A_FSG_50_0_0_24_Data_1_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_5,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_5,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_5,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_6,0);
      putValue(A_FSG_50_0_0_24_Data_7_6,0);
      putValue(A_FSG_50_0_0_24_Data_6_6,0);
      putValue(A_FSG_50_0_0_24_Data_5_6,0);
      putValue(A_FSG_50_0_0_24_Data_4_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_6,0);
      putValue(A_FSG_50_0_0_24_Data_2_6,0);
      putValue(A_FSG_50_0_0_24_Data_1_6,0);      
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_6,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_6,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_6,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_7,0);
      putValue(A_FSG_50_0_0_24_Data_7_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_4_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_7,0);
      putValue(A_FSG_50_0_0_24_Data_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_7,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_8,0);
      putValue(A_FSG_50_0_0_24_Data_7_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_4_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_8,0);
      putValue(A_FSG_50_0_0_24_Data_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_8,1);
      
      //putValue(A_FSG_50_0_0_24_Data_3_empty_2_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_1_1,1);
      //putValue(A_FSG_50_0_0_24_Data_3_empty_3_1,1);

    }    
    
    if(getValue(this) == 0)
    {
      putValue(A_FSG_50_0_0_24_Data_5_1,1);
      putValue(A_FSG_50_0_0_24_Data_6_1,1);      
      putValue(A_FSG_50_0_0_24_Data_5_2,0);
      putValue(A_FSG_50_0_0_24_Data_6_2,0);      
      putValue(A_FSG_50_0_0_24_Data_5_3,0);
      putValue(A_FSG_50_0_0_24_Data_6_3,0);      
      putValue(A_FSG_50_0_0_24_Data_5_4,0);
      putValue(A_FSG_50_0_0_24_Data_6_4,0);      
      putValue(A_FSG_50_0_0_24_Data_5_5,0);
      putValue(A_FSG_50_0_0_24_Data_6_5,0);      
      putValue(A_FSG_50_0_0_24_Data_5_6,0);
      putValue(A_FSG_50_0_0_24_Data_6_6,0);      
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);      
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);

      
      putValue(A_FSG_50_0_0_24_Data_8_2,0);
      putValue(A_FSG_50_0_0_24_Data_7_2,0);
      putValue(A_FSG_50_0_0_24_Data_6_2,0);
      putValue(A_FSG_50_0_0_24_Data_5_2,0);
      putValue(A_FSG_50_0_0_24_Data_4_2,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_2,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_2,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_2,0);
      putValue(A_FSG_50_0_0_24_Data_2_2,0);
      putValue(A_FSG_50_0_0_24_Data_1_2,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_2,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_2,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_2,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_3,0);
      putValue(A_FSG_50_0_0_24_Data_7_3,0);
      putValue(A_FSG_50_0_0_24_Data_6_3,0);
      putValue(A_FSG_50_0_0_24_Data_5_3,0);
      putValue(A_FSG_50_0_0_24_Data_4_3,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_3,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_3,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_3,0);
      putValue(A_FSG_50_0_0_24_Data_2_3,0);
      putValue(A_FSG_50_0_0_24_Data_1_3,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_3,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_3,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_3,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_4,0);
      putValue(A_FSG_50_0_0_24_Data_7_4,0);
      putValue(A_FSG_50_0_0_24_Data_6_4,0);
      putValue(A_FSG_50_0_0_24_Data_5_4,0);
      putValue(A_FSG_50_0_0_24_Data_4_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_4,0);
      putValue(A_FSG_50_0_0_24_Data_2_4,0);
      putValue(A_FSG_50_0_0_24_Data_1_4,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_4,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_4,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_4,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_5,0);
      putValue(A_FSG_50_0_0_24_Data_7_5,0);
      putValue(A_FSG_50_0_0_24_Data_6_5,0);
      putValue(A_FSG_50_0_0_24_Data_5_5,0);
      putValue(A_FSG_50_0_0_24_Data_4_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_5,0);
      putValue(A_FSG_50_0_0_24_Data_2_5,0);
      putValue(A_FSG_50_0_0_24_Data_1_5,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_5,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_5,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_5,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_6,0);
      putValue(A_FSG_50_0_0_24_Data_7_6,0);
      putValue(A_FSG_50_0_0_24_Data_6_6,0);
      putValue(A_FSG_50_0_0_24_Data_5_6,0);
      putValue(A_FSG_50_0_0_24_Data_4_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_6,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_6,0);
      putValue(A_FSG_50_0_0_24_Data_2_6,0);
      putValue(A_FSG_50_0_0_24_Data_1_6,0);      
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_6,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_6,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_6,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_7,0);
      putValue(A_FSG_50_0_0_24_Data_7_7,0);
      putValue(A_FSG_50_0_0_24_Data_6_7,0);
      putValue(A_FSG_50_0_0_24_Data_5_7,0);
      putValue(A_FSG_50_0_0_24_Data_4_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_7,0);
      putValue(A_FSG_50_0_0_24_Data_2_7,0);
      putValue(A_FSG_50_0_0_24_Data_1_7,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_7,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_7,1);
      
      putValue(A_FSG_50_0_0_24_Data_8_8,0);
      putValue(A_FSG_50_0_0_24_Data_7_8,0);
      putValue(A_FSG_50_0_0_24_Data_6_8,0);
      putValue(A_FSG_50_0_0_24_Data_5_8,0);
      putValue(A_FSG_50_0_0_24_Data_4_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_3_8,0);
      putValue(A_FSG_50_0_0_24_Data_2_8,0);
      putValue(A_FSG_50_0_0_24_Data_1_8,0);
      putValue(A_FSG_50_0_0_24_Data_3_empty_2_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_1_8,1);
      putValue(A_FSG_50_0_0_24_Data_3_empty_3_8,1);
    } 
}

on envVar A_FSG_50_0_0_24_DataIndex_Incr
{
    long index;
    if(A_FSG_50_0_0_24_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_50_0_0_24_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_24_DataIndex);
        index++;
        putValue(A_FSG_50_0_0_24_DataIndex, index);
        A_FSG_50_0_0_24_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_24_DataIndex_Decr
{
    long index;
    if(A_FSG_50_0_0_24_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_50_0_0_24_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_24_DataIndex);
        index--;
        putValue(A_FSG_50_0_0_24_DataIndex, index);
        A_FSG_50_0_0_24_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_24_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_50_0_0_24_ID;
    data[2]=getValue(A_FSG_50_0_0_24_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_50_0_0_24
on envVar A_FSG_50_0_0_24_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_24",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_24",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_24",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_24_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_24", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_24",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_24",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_24",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_24_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_24", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_24_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_24_SegmEn,0);
           intertelegram_err(A_FSG_50_0_0_24_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_50_0_0_24_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_24_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_24_IntTlgEn,0);
           sequence_err(A_FSG_50_0_0_24_ID,getValueSize(A_FSG_50_0_0_24_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_50_0_0_24_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_50_0_0_24_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_50_0_0_24_Status",1);
 	}
}



A_FSG_50_0_0_24_SetInd () { /* leere Function*/ }

A_FSG_50_0_0_24_SetGetInd () { /* leere Function*/ }

A_FSG_50_0_0_24_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[181];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_24_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_24_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_50_0_0_24_SetGet, head, 5);
                if(getValue(A_FSG_50_0_0_24_AT))
                {
                    putValue(A_FSG_50_0_0_24,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_50_0_0_24_SetGet, head, 3);
            if(getValue(A_FSG_50_0_0_24_AT))
            {
                putValue(A_FSG_50_0_0_24,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_50_0_0_24_AT))
        {
            putValue(A_FSG_50_0_0_24_RecAdr,recordAddressVal);
            putValue(A_FSG_50_0_0_24_Start, startVal);
            putValue(A_FSG_50_0_0_24_Elements, elementsVal);
            putValue(A_FSG_50_0_0_24_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_50_0_0_24_1
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_24_2_range // LaneGuidance.TAID 
{
	@A_FSG_50_0_0_24_2 = @A_FSG_50_0_0_24_2_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_24_2
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_24_2, 1.0);
	@A_FSG_50_0_0_24_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_FSG_50_0_0_24_3
{

	//Update Childvalue (Enum)
	byte thisval; // LaneGuidanceOnOff
	thisval = getValue(this);
  
  if(getValue(this) == 1)
  {
    EnableFctCtrl_LG();
    putValue(A_FSG_50_0_0_24_DataIndex,0);
  }
  if(getValue(this) == 0)
    DisableFctCtrl_LG_all();
  
  if(getvalue(this) == 1)
  {
    putValue(A_FSG_50_0_0_24_Data_3_empty_1_1,1);
    EnableControl(LG_panel,"LSS11",0);     
    putValue(A_FSG_50_0_0_24_Data_3_empty_2_1,1);
    EnableControl(LG_panel,"LSS21",0);      
    putValue(A_FSG_50_0_0_24_Data_3_empty_3_1,1);
    EnableControl(LG_panel,"LSS31",0);
  }
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_24_Data_1_range // LaneGuidance.Pos 
{
	@A_FSG_50_0_0_24_Data_1 = @A_FSG_50_0_0_24_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_24_Data_1
{

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_24_Data_1, 1.0);
	@A_FSG_50_0_0_24_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param1 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_24_Data_2_range // LaneGuidance.LaneDirection 
{
	@A_FSG_50_0_0_24_Data_2 = @A_FSG_50_0_0_24_Data_2_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_24_Data_2
{

	//Update Childvalue (Number)
	byte thisval; // LaneDirection
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_24_Data_2, 1.0);
	@A_FSG_50_0_0_24_Data_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param2 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_24_Data_3_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_24_Data_3_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_24_Data_3_CntList[ getValue(A_FSG_50_0_0_24_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_24_Data_3_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_24_Data_3_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_24_Data_3_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 16 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_24_Data_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 16);
		thisval = 16;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_24_Data_3_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param3_Length = thisval;
	A_FSG_50_0_0_24_Data_3_LenList[ getValue(A_FSG_50_0_0_24_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_24_Data_3_len, thisval);

}

on envVar A_FSG_50_0_0_24_Data_3
{

	//Update Childvalue (String)
	word i;
	byte thisval[17];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param3[i] = thisval[i];
    A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param3_Length = getValueSize(this);
    A_FSG_50_0_0_24_Data_3_LenList[getValue(A_FSG_50_0_0_24_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_24_Data_3_len, getValueSize(this));
}
on envVar A_FSG_50_0_0_24_Data_4
{

	//Update Childvalue (Enum)
	byte thisval; // LaneType
	thisval = getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param4 = thisval;
}
on envVar A_FSG_50_0_0_24_Data_5
{

	//Update Childvalue (Enum)
	byte thisval; // LaneMarking_left
	thisval = 0x0f & getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param5 = thisval;
}
on envVar A_FSG_50_0_0_24_Data_6
{

	//Update Childvalue (Enum)
	byte thisval; // LaneMarking_right
	thisval = 0x0f & getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param6 = thisval;
}
on envVar A_FSG_50_0_0_24_Data_7
{

	//Update Childvalue (Enum)
	byte thisval; // LaneDescription
	thisval = 0x0f & getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param7 = thisval;
}
on envVar A_FSG_50_0_0_24_Data_8
{

	//Update Childvalue (Enum)
	byte thisval; // GuidanceInfo
	thisval = 0x0f & getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[getValue(A_FSG_50_0_0_24_DataIndex)].Param8 = thisval;
}


DisableFctCtrl_LG ()
{
    //1st Element
  if(getValue(A_FSG_50_0_0_24_DataIndex) < 0)
   { 
    EnableControl(LG_panel,"Pos1",0);
    EnableControl(LG_panel,"LD1",0);
    EnableControl(LG_panel,"LSS11",0);
    EnableControl(LG_panel,"LSSe11",0);
    EnableControl(LG_panel,"LSS21",0);
    EnableControl(LG_panel,"LSSe21",0);
    EnableControl(LG_panel,"LSS31",0);
    EnableControl(LG_panel,"LSSe31",0);
    EnableControl(LG_panel,"LT1",0);
    EnableControl(LG_panel,"MKL1",0);
    EnableControl(LG_panel,"MKR1",0);
    EnableControl(LG_panel,"LDe1",0);
    EnableControl(LG_panel,"GI1",0);
  }
  
    //2nd Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) < 1)
   {
    EnableControl(LG_panel,"Pos2",0);
    EnableControl(LG_panel,"LD2",0);
    EnableControl(LG_panel,"LSS12",0);
    EnableControl(LG_panel,"LSSe12",0);
    EnableControl(LG_panel,"LSS22",0);
    EnableControl(LG_panel,"LSSe22",0);
    EnableControl(LG_panel,"LSS32",0);
    EnableControl(LG_panel,"LSSe32",0);
    EnableControl(LG_panel,"LT2",0);
    EnableControl(LG_panel,"MKL2",0);
    EnableControl(LG_panel,"MKR2",0);
    EnableControl(LG_panel,"LDe2",0);
    EnableControl(LG_panel,"GI2",0);
  }
  
    //3rd Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) < 2)
   {
    EnableControl(LG_panel,"Pos3",0);
    EnableControl(LG_panel,"LD3",0);
    EnableControl(LG_panel,"LSS13",0);
    EnableControl(LG_panel,"LSSe13",0);
    EnableControl(LG_panel,"LSS23",0);
    EnableControl(LG_panel,"LSSe23",0);
    EnableControl(LG_panel,"LSS33",0);
    EnableControl(LG_panel,"LSSe33",0);
    EnableControl(LG_panel,"LT3",0);
    EnableControl(LG_panel,"MKL3",0);
    EnableControl(LG_panel,"MKR3",0);
    EnableControl(LG_panel,"LDe3",0);
    EnableControl(LG_panel,"GI3",0);
  }
  
    //4th Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) < 3)
   {
    EnableControl(LG_panel,"Pos4",0);
    EnableControl(LG_panel,"LD4",0);
    EnableControl(LG_panel,"LSS14",0);
    EnableControl(LG_panel,"LSSe14",0);
    EnableControl(LG_panel,"LSS24",0);
    EnableControl(LG_panel,"LSSe24",0);
    EnableControl(LG_panel,"LSS34",0);
    EnableControl(LG_panel,"LSSe34",0);
    EnableControl(LG_panel,"LT4",0);
    EnableControl(LG_panel,"MKL4",0);
    EnableControl(LG_panel,"MKR4",0);
    EnableControl(LG_panel,"LDe4",0);
    EnableControl(LG_panel,"GI4",0);
  }
  
    //5th Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) < 4)
   {
    EnableControl(LG_panel,"Pos5",0);
    EnableControl(LG_panel,"LD5",0);
    EnableControl(LG_panel,"LSS15",0);
    EnableControl(LG_panel,"LSSe15",0);
    EnableControl(LG_panel,"LSS25",0);
    EnableControl(LG_panel,"LSSe25",0);
    EnableControl(LG_panel,"LSS35",0);
    EnableControl(LG_panel,"LSSe35",0);
    EnableControl(LG_panel,"LT5",0);
    EnableControl(LG_panel,"MKL5",0);
    EnableControl(LG_panel,"MKR5",0);
    EnableControl(LG_panel,"LDe5",0);
    EnableControl(LG_panel,"GI5",0);
  }
  
    //6th Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) < 5)
   {
    EnableControl(LG_panel,"Pos6",0);
    EnableControl(LG_panel,"LD6",0);
    EnableControl(LG_panel,"LSS16",0);
    EnableControl(LG_panel,"LSSe16",0);
    EnableControl(LG_panel,"LSS26",0);
    EnableControl(LG_panel,"LSSe26",0);
    EnableControl(LG_panel,"LSS36",0);
    EnableControl(LG_panel,"LSSe36",0);
    EnableControl(LG_panel,"LT6",0);
    EnableControl(LG_panel,"MKL6",0);
    EnableControl(LG_panel,"MKR6",0);
    EnableControl(LG_panel,"LDe6",0);
    EnableControl(LG_panel,"GI6",0);
  }
  
    //7th Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) < 6)
   {
    EnableControl(LG_panel,"Pos7",0);
    EnableControl(LG_panel,"LD7",0);
    EnableControl(LG_panel,"LSS17",0);
    EnableControl(LG_panel,"LSSe17",0);
    EnableControl(LG_panel,"LSS27",0);
    EnableControl(LG_panel,"LSSe27",0);
    EnableControl(LG_panel,"LSS37",0);
    EnableControl(LG_panel,"LSSe37",0);
    EnableControl(LG_panel,"LT7",0);
    EnableControl(LG_panel,"MKL7",0);
    EnableControl(LG_panel,"MKR7",0);
    EnableControl(LG_panel,"LDe7",0);
    EnableControl(LG_panel,"GI7",0);
  }
  
    //8th Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) < 7)
   {
    EnableControl(LG_panel,"Pos8",0);
    EnableControl(LG_panel,"LD8",0);
    EnableControl(LG_panel,"LSS18",0);
    EnableControl(LG_panel,"LSSe18",0);
    EnableControl(LG_panel,"LSS28",0);
    EnableControl(LG_panel,"LSSe28",0);
    EnableControl(LG_panel,"LSS38",0);
    EnableControl(LG_panel,"LSSe38",0);
    EnableControl(LG_panel,"LT8",0);
    EnableControl(LG_panel,"MKL8",0);
    EnableControl(LG_panel,"MKR8",0);
    EnableControl(LG_panel,"LDe8",0);
    EnableControl(LG_panel,"GI8",0);
  }
  
}


DisableFctCtrl_LG_all ()
{
      EnableControl(LG_panel,"DataIndex Combobox",0);
      EnableControl(LG_panel,"Status Button",0);
  
    //1st Element
    EnableControl(LG_panel,"Pos1",0);
    EnableControl(LG_panel,"LD1",0);
    EnableControl(LG_panel,"LSS11",0);
    EnableControl(LG_panel,"LSSe11",0);
    EnableControl(LG_panel,"LSS21",0);
    EnableControl(LG_panel,"LSSe21",0);
    EnableControl(LG_panel,"LSS31",0);
    EnableControl(LG_panel,"LSSe31",0);
    EnableControl(LG_panel,"LT1",0);
    EnableControl(LG_panel,"MKL1",0);
    EnableControl(LG_panel,"MKR1",0);
    EnableControl(LG_panel,"LDe1",0);
    EnableControl(LG_panel,"GI1",0);
  
    //2nd Element
    EnableControl(LG_panel,"Pos2",0);
    EnableControl(LG_panel,"LD2",0);
    EnableControl(LG_panel,"LSS12",0);
    EnableControl(LG_panel,"LSSe12",0);
    EnableControl(LG_panel,"LSS22",0);
    EnableControl(LG_panel,"LSSe22",0);
    EnableControl(LG_panel,"LSS32",0);
    EnableControl(LG_panel,"LSSe32",0);
    EnableControl(LG_panel,"LT2",0);
    EnableControl(LG_panel,"MKL2",0);
    EnableControl(LG_panel,"MKR2",0);
    EnableControl(LG_panel,"LDe2",0);
    EnableControl(LG_panel,"GI2",0);

    //3rd Element
    EnableControl(LG_panel,"Pos3",0);
    EnableControl(LG_panel,"LD3",0);
    EnableControl(LG_panel,"LSS13",0);
    EnableControl(LG_panel,"LSSe13",0);
    EnableControl(LG_panel,"LSS23",0);
    EnableControl(LG_panel,"LSSe23",0);
    EnableControl(LG_panel,"LSS33",0);
    EnableControl(LG_panel,"LSSe33",0);
    EnableControl(LG_panel,"LT3",0);
    EnableControl(LG_panel,"MKL3",0);
    EnableControl(LG_panel,"MKR3",0);
    EnableControl(LG_panel,"LDe3",0);
    EnableControl(LG_panel,"GI3",0);
 
    //4th Element
    EnableControl(LG_panel,"Pos4",0);
    EnableControl(LG_panel,"LD4",0);
    EnableControl(LG_panel,"LSS14",0);
    EnableControl(LG_panel,"LSSe14",0);
    EnableControl(LG_panel,"LSS24",0);
    EnableControl(LG_panel,"LSSe24",0);
    EnableControl(LG_panel,"LSS34",0);
    EnableControl(LG_panel,"LSSe34",0);
    EnableControl(LG_panel,"LT4",0);
    EnableControl(LG_panel,"MKL4",0);
    EnableControl(LG_panel,"MKR4",0);
    EnableControl(LG_panel,"LDe4",0);
    EnableControl(LG_panel,"GI4",0);

   //5th Element
    EnableControl(LG_panel,"Pos5",0);
    EnableControl(LG_panel,"LD5",0);
    EnableControl(LG_panel,"LSS15",0);
    EnableControl(LG_panel,"LSSe15",0);
    EnableControl(LG_panel,"LSS25",0);
    EnableControl(LG_panel,"LSSe25",0);
    EnableControl(LG_panel,"LSS35",0);
    EnableControl(LG_panel,"LSSe35",0);
    EnableControl(LG_panel,"LT5",0);
    EnableControl(LG_panel,"MKL5",0);
    EnableControl(LG_panel,"MKR5",0);
    EnableControl(LG_panel,"LDe5",0);
    EnableControl(LG_panel,"GI5",0);
  
    //6th Element
    EnableControl(LG_panel,"Pos6",0);
    EnableControl(LG_panel,"LD6",0);
    EnableControl(LG_panel,"LSS16",0);
    EnableControl(LG_panel,"LSSe16",0);
    EnableControl(LG_panel,"LSS26",0);
    EnableControl(LG_panel,"LSSe26",0);
    EnableControl(LG_panel,"LSS36",0);
    EnableControl(LG_panel,"LSSe36",0);
    EnableControl(LG_panel,"LT6",0);
    EnableControl(LG_panel,"MKL6",0);
    EnableControl(LG_panel,"MKR6",0);
    EnableControl(LG_panel,"LDe6",0);
    EnableControl(LG_panel,"GI6",0);

    //7th Element
    EnableControl(LG_panel,"Pos7",0);
    EnableControl(LG_panel,"LD7",0);
    EnableControl(LG_panel,"LSS17",0);
    EnableControl(LG_panel,"LSSe17",0);
    EnableControl(LG_panel,"LSS27",0);
    EnableControl(LG_panel,"LSSe27",0);
    EnableControl(LG_panel,"LSS37",0);
    EnableControl(LG_panel,"LSSe37",0);
    EnableControl(LG_panel,"LT7",0);
    EnableControl(LG_panel,"MKL7",0);
    EnableControl(LG_panel,"MKR7",0);
    EnableControl(LG_panel,"LDe7",0);
    EnableControl(LG_panel,"GI7",0);

    //8th Element
    EnableControl(LG_panel,"Pos8",0);
    EnableControl(LG_panel,"LD8",0);
    EnableControl(LG_panel,"LSS18",0);
    EnableControl(LG_panel,"LSSe18",0);
    EnableControl(LG_panel,"LSS28",0);
    EnableControl(LG_panel,"LSSe28",0);
    EnableControl(LG_panel,"LSS38",0);
    EnableControl(LG_panel,"LSSe38",0);
    EnableControl(LG_panel,"LT8",0);
    EnableControl(LG_panel,"MKL8",0);
    EnableControl(LG_panel,"MKR8",0);
    EnableControl(LG_panel,"LDe8",0);
    EnableControl(LG_panel,"GI8",0);
}

EnableFctCtrl_LG ()
{
    EnableControl(LG_panel,"DataIndex Combobox",1);
    EnableControl(LG_panel,"Status Button",1);
  
    //1st Element
  if(getValue(A_FSG_50_0_0_24_DataIndex) >= 0)
   { 
    EnableControl(LG_panel,"Pos1",1);
    EnableControl(LG_panel,"LD1",1);
    EnableControl(LG_panel,"LSS11",1);
    EnableControl(LG_panel,"LSSe11",1);
    EnableControl(LG_panel,"LSS21",1);
    EnableControl(LG_panel,"LSSe21",1);
    EnableControl(LG_panel,"LSS31",1);
    EnableControl(LG_panel,"LSSe31",1);
    EnableControl(LG_panel,"LT1",1);
    EnableControl(LG_panel,"MKL1",1);
    EnableControl(LG_panel,"MKR1",1);
    EnableControl(LG_panel,"LDe1",1);
    EnableControl(LG_panel,"GI1",1);
  }
  
    //2nd Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) >= 1)
   {
    EnableControl(LG_panel,"Pos2",1);
    EnableControl(LG_panel,"LD2",1);
    EnableControl(LG_panel,"LSS12",1);
    EnableControl(LG_panel,"LSS22",1);
    EnableControl(LG_panel,"LSSe12",1);
    EnableControl(LG_panel,"LSSe22",1);
    EnableControl(LG_panel,"LSS32",1);
    EnableControl(LG_panel,"LSSe32",1);
    EnableControl(LG_panel,"LT2",1);
    EnableControl(LG_panel,"MKL2",1);
    EnableControl(LG_panel,"MKR2",1);
    EnableControl(LG_panel,"LDe2",1);
    EnableControl(LG_panel,"GI2",1);
  }
  
    //3rd Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) >= 2)
   {
    EnableControl(LG_panel,"Pos3",1);
    EnableControl(LG_panel,"LD3",1);
    EnableControl(LG_panel,"LSS13",1);
    EnableControl(LG_panel,"LSSe13",1);
    EnableControl(LG_panel,"LSS23",1);
    EnableControl(LG_panel,"LSSe23",1);
    EnableControl(LG_panel,"LSS33",1);
    EnableControl(LG_panel,"LSSe33",1);
    EnableControl(LG_panel,"LT3",1);
    EnableControl(LG_panel,"MKL3",1);
    EnableControl(LG_panel,"MKR3",1);
    EnableControl(LG_panel,"LDe3",1);
    EnableControl(LG_panel,"GI3",1);
  }
  
    //4th Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) >= 3)
   {
    EnableControl(LG_panel,"Pos4",1);
    EnableControl(LG_panel,"LD4",1);
    EnableControl(LG_panel,"LSS14",1);
    EnableControl(LG_panel,"LSSe14",1);
    EnableControl(LG_panel,"LSS24",1);
    EnableControl(LG_panel,"LSSe24",1);
    EnableControl(LG_panel,"LSS34",1);
    EnableControl(LG_panel,"LSSe34",1);
    EnableControl(LG_panel,"LT4",1);
    EnableControl(LG_panel,"MKL4",1);
    EnableControl(LG_panel,"MKR4",1);
    EnableControl(LG_panel,"LDe4",1);
    EnableControl(LG_panel,"GI4",1);
  }
  
    //5th Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) >= 4)
   {
    EnableControl(LG_panel,"Pos5",1);
    EnableControl(LG_panel,"LD5",1);
    EnableControl(LG_panel,"LSS15",1);
    EnableControl(LG_panel,"LSSe15",1);
    EnableControl(LG_panel,"LSS25",1);
    EnableControl(LG_panel,"LSSe25",1);
    EnableControl(LG_panel,"LSS35",1);
    EnableControl(LG_panel,"LSSe35",1);
    EnableControl(LG_panel,"LT5",1);
    EnableControl(LG_panel,"MKL5",1);
    EnableControl(LG_panel,"MKR5",1);
    EnableControl(LG_panel,"LDe5",1);
    EnableControl(LG_panel,"GI5",1);
  }
  
    //6th Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) >= 5)
   {
    EnableControl(LG_panel,"Pos6",1);
    EnableControl(LG_panel,"LD6",1);
    EnableControl(LG_panel,"LSS16",1);
    EnableControl(LG_panel,"LSSe16",1);
    EnableControl(LG_panel,"LSS26",1);
    EnableControl(LG_panel,"LSSe26",1);
    EnableControl(LG_panel,"LSS36",1);
    EnableControl(LG_panel,"LSSe36",1);
    EnableControl(LG_panel,"LT6",1);
    EnableControl(LG_panel,"MKL6",1);
    EnableControl(LG_panel,"MKR6",1);
    EnableControl(LG_panel,"LDe6",1);
    EnableControl(LG_panel,"GI6",1);
  }
  
    //7th Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) >= 6)
   {
    EnableControl(LG_panel,"Pos7",1);
    EnableControl(LG_panel,"LD7",1);
    EnableControl(LG_panel,"LSS17",1);
    EnableControl(LG_panel,"LSSe17",1);
    EnableControl(LG_panel,"LSS27",1);
    EnableControl(LG_panel,"LSSe27",1);
    EnableControl(LG_panel,"LSS37",1);
    EnableControl(LG_panel,"LSSe37",1);
    EnableControl(LG_panel,"LT7",1);
    EnableControl(LG_panel,"MKL7",1);
    EnableControl(LG_panel,"MKR7",1);
    EnableControl(LG_panel,"LDe7",1);
    EnableControl(LG_panel,"GI7",1);
  }
  
    //8th Element
    if(getValue(A_FSG_50_0_0_24_DataIndex) >= 7)
   {
    EnableControl(LG_panel,"Pos8",1);
    EnableControl(LG_panel,"LD8",1);
    EnableControl(LG_panel,"LSS18",1);
    EnableControl(LG_panel,"LSSe18",1);
    EnableControl(LG_panel,"LSS28",1);
    EnableControl(LG_panel,"LSSe28",1);
    EnableControl(LG_panel,"LSS38",1);
    EnableControl(LG_panel,"LSSe38",1);
    EnableControl(LG_panel,"LT8",1);
    EnableControl(LG_panel,"MKL8",1);
    EnableControl(LG_panel,"MKR8",1);
    EnableControl(LG_panel,"LDe8",1);
    EnableControl(LG_panel,"GI8",1);
  }


}

rgi_reset()
{
  putValue(A_FSG_50_0_0_24_Data_1_1,0);
  putValue(A_FSG_50_0_0_24_Data_1_2,0);
  putValue(A_FSG_50_0_0_24_Data_1_3,0);
  putValue(A_FSG_50_0_0_24_Data_1_4,0);
  putValue(A_FSG_50_0_0_24_Data_1_5,0);
  putValue(A_FSG_50_0_0_24_Data_1_6,0);
  putValue(A_FSG_50_0_0_24_Data_1_7,0);
  putValue(A_FSG_50_0_0_24_Data_1_8,0);
  
  putValue(A_FSG_50_0_0_24_Data_2_1,0);
  putValue(A_FSG_50_0_0_24_Data_2_2,0);
  putValue(A_FSG_50_0_0_24_Data_2_3,0);
  putValue(A_FSG_50_0_0_24_Data_2_4,0);
  putValue(A_FSG_50_0_0_24_Data_2_5,0);
  putValue(A_FSG_50_0_0_24_Data_2_6,0);
  putValue(A_FSG_50_0_0_24_Data_2_7,0);
  putValue(A_FSG_50_0_0_24_Data_2_8,0);
  
  putValue(A_FSG_50_0_0_24_Data_3_1_1,0);
  putValue(A_FSG_50_0_0_24_Data_3_1_2,0);
  putValue(A_FSG_50_0_0_24_Data_3_1_3,0);
  putValue(A_FSG_50_0_0_24_Data_3_1_4,0);
  putValue(A_FSG_50_0_0_24_Data_3_1_5,0);
  putValue(A_FSG_50_0_0_24_Data_3_1_6,0);
  putValue(A_FSG_50_0_0_24_Data_3_1_7,0);
  putValue(A_FSG_50_0_0_24_Data_3_1_8,0);
  
  putValue(A_FSG_50_0_0_24_Data_3_2_1,0);
  putValue(A_FSG_50_0_0_24_Data_3_2_2,0);
  putValue(A_FSG_50_0_0_24_Data_3_2_3,0);
  putValue(A_FSG_50_0_0_24_Data_3_2_4,0);
  putValue(A_FSG_50_0_0_24_Data_3_2_5,0);
  putValue(A_FSG_50_0_0_24_Data_3_2_6,0);
  putValue(A_FSG_50_0_0_24_Data_3_2_7,0);
  putValue(A_FSG_50_0_0_24_Data_3_2_8,0);
  
  putValue(A_FSG_50_0_0_24_Data_3_3_1,0);
  putValue(A_FSG_50_0_0_24_Data_3_3_2,0);
  putValue(A_FSG_50_0_0_24_Data_3_3_3,0);
  putValue(A_FSG_50_0_0_24_Data_3_3_4,0);
  putValue(A_FSG_50_0_0_24_Data_3_3_5,0);
  putValue(A_FSG_50_0_0_24_Data_3_3_6,0);
  putValue(A_FSG_50_0_0_24_Data_3_3_7,0);
  putValue(A_FSG_50_0_0_24_Data_3_3_8,0);
  
  putValue(A_FSG_50_0_0_24_Data_4_1,0);
  putValue(A_FSG_50_0_0_24_Data_4_2,0);
  putValue(A_FSG_50_0_0_24_Data_4_3,0);
  putValue(A_FSG_50_0_0_24_Data_4_4,0);
  putValue(A_FSG_50_0_0_24_Data_4_5,0);
  putValue(A_FSG_50_0_0_24_Data_4_6,0);
  putValue(A_FSG_50_0_0_24_Data_4_7,0);
  putValue(A_FSG_50_0_0_24_Data_4_8,0);
  
  putValue(A_FSG_50_0_0_24_Data_5_1,0);
  putValue(A_FSG_50_0_0_24_Data_5_2,0);
  putValue(A_FSG_50_0_0_24_Data_5_3,0);
  putValue(A_FSG_50_0_0_24_Data_5_4,0);
  putValue(A_FSG_50_0_0_24_Data_5_5,0);
  putValue(A_FSG_50_0_0_24_Data_5_6,0);
  putValue(A_FSG_50_0_0_24_Data_5_7,0);
  putValue(A_FSG_50_0_0_24_Data_5_8,0);

  putValue(A_FSG_50_0_0_24_Data_6_1,0);
  putValue(A_FSG_50_0_0_24_Data_6_2,0);
  putValue(A_FSG_50_0_0_24_Data_6_3,0);
  putValue(A_FSG_50_0_0_24_Data_6_4,0);
  putValue(A_FSG_50_0_0_24_Data_6_5,0);
  putValue(A_FSG_50_0_0_24_Data_6_6,0);
  putValue(A_FSG_50_0_0_24_Data_6_7,0);
  putValue(A_FSG_50_0_0_24_Data_6_8,0);
  
  putValue(A_FSG_50_0_0_24_Data_7_1,0);
  putValue(A_FSG_50_0_0_24_Data_7_2,0);
  putValue(A_FSG_50_0_0_24_Data_7_3,0);
  putValue(A_FSG_50_0_0_24_Data_7_4,0);
  putValue(A_FSG_50_0_0_24_Data_7_5,0);
  putValue(A_FSG_50_0_0_24_Data_7_6,0);
  putValue(A_FSG_50_0_0_24_Data_7_7,0);
  putValue(A_FSG_50_0_0_24_Data_7_8,0);
  
  putValue(A_FSG_50_0_0_24_Data_8_1,0);
  putValue(A_FSG_50_0_0_24_Data_8_2,0);
  putValue(A_FSG_50_0_0_24_Data_8_3,0);
  putValue(A_FSG_50_0_0_24_Data_8_4,0);
  putValue(A_FSG_50_0_0_24_Data_8_5,0);
  putValue(A_FSG_50_0_0_24_Data_8_6,0);
  putValue(A_FSG_50_0_0_24_Data_8_7,0);
  putValue(A_FSG_50_0_0_24_Data_8_8,0);
}



//pnt
    /*putValue(A_FSG_50_0_0_24_Data_1, A_FSG_50_0_0_24_ArrayDataList[index].Param1);
    putValue(A_FSG_50_0_0_24_Data_2, A_FSG_50_0_0_24_ArrayDataList[index].Param2);
    putValue(A_FSG_50_0_0_24_Data_3_len, A_FSG_50_0_0_24_Data_3_LenList[index]);
    putValue(A_FSG_50_0_0_24_Data_3_cnt, A_FSG_50_0_0_24_Data_3_CntList[index]);
    putValue(A_FSG_50_0_0_24_Data_3, A_FSG_50_0_0_24_ArrayDataList[index].Param3, A_FSG_50_0_0_24_ArrayDataList[index].Param3_Length);
    putValue(A_FSG_50_0_0_24_Data_4, A_FSG_50_0_0_24_ArrayDataList[index].Param4);
    putValue(A_FSG_50_0_0_24_Data_5, A_FSG_50_0_0_24_ArrayDataList[index].Param5);
    putValue(A_FSG_50_0_0_24_Data_6, A_FSG_50_0_0_24_ArrayDataList[index].Param6);
    putValue(A_FSG_50_0_0_24_Data_7, A_FSG_50_0_0_24_ArrayDataList[index].Param7);
    putValue(A_FSG_50_0_0_24_Data_8, A_FSG_50_0_0_24_ArrayDataList[index].Param8);*/


/////////////////  erstes Element  /////////////////////////////////////////////////
on envVar A_FSG_50_0_0_24_Data_1_1
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  A_FSG_50_0_0_24_ArrayDataList[0].Param1 = thisval;
  putValue(A_FSG_50_0_0_24_Data_1_1, A_FSG_50_0_0_24_ArrayDataList[0].Param1);
}
    
on envVar A_FSG_50_0_0_24_Data_2_1
{	
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[0].Param2 = thisval;
    putValue(A_FSG_50_0_0_24_Data_2_1, A_FSG_50_0_0_24_ArrayDataList[0].Param2);
}





/*   Erster Pfeil - Erste Sidestreet
on envVar A_FSG_50_0_0_24_Data_3_1_1
{
  //erstes element immer aktiv
  A_FSG_50_0_0_24_ArrayDataList[0].Param3[0] = getValue(A_FSG_50_0_0_24_Data_3_1_1);
  if(getValue(A_FSG_50_0_0_24_Data_3_empty_2_1) == 1) //2nd sidestreet leer
  {
        if(getValue(A_FSG_50_0_0_24_Data_3_empty_3_1) == 1) // 3rd sidestreet leer
        {
          //2 & 3 = empty  / 1 aktiv
          A_FSG_50_0_0_24_ArrayDataList[0].Param3_Length =1;
          A_FSG_50_0_0_24_Data_3_LenList[0] = 1;
          putValue(A_FSG_50_0_0_24_Data_3_len_1,1);
        }
        else // 3rd sidestreet befüllt
        {
          //2 = empty / 1 & 3 aktiv
          A_FSG_50_0_0_24_ArrayDataList[0].Param3_Length = (getValueSize(A_FSG_50_0_0_24_Data_3_1_1) + getValueSize(A_FSG_50_0_0_24_Data_3_3_1));
          A_FSG_50_0_0_24_Data_3_LenList[0] = (getValueSize(A_FSG_50_0_0_24_Data_3_1_1) + getValueSize(A_FSG_50_0_0_24_Data_3_3_1));
          putValue(A_FSG_50_0_0_24_Data_3_len_1, (getValueSize(this) + getValueSize(A_FSG_50_0_0_24_Data_3_3_1))); 
        }
  }
  else  // 2nd sidestreet befüllt
  {
        if(getValue(A_FSG_50_0_0_24_Data_3_empty_3_1) == 1) // 3rd sidestreet leer
        {
          //3 = empty  / 1 & 2 aktiv
          A_FSG_50_0_0_24_ArrayDataList[0].Param3_Length = (getValueSize(A_FSG_50_0_0_24_Data_3_1_1) + getValueSize(A_FSG_50_0_0_24_Data_3_2_1));
          A_FSG_50_0_0_24_Data_3_LenList[0] = (getValueSize(A_FSG_50_0_0_24_Data_3_1_1) + getValueSize(A_FSG_50_0_0_24_Data_3_2_1));
          putValue(A_FSG_50_0_0_24_Data_3_len_1,(getValueSize(A_FSG_50_0_0_24_Data_3_1_1) + getValueSize(A_FSG_50_0_0_24_Data_3_2_1)));
        }
        else // 3rd sidestreet befüllt
        {
          // 1 & 2 & 3 befüllt
          A_FSG_50_0_0_24_ArrayDataList[0].Param3_Length = (getValueSize(A_FSG_50_0_0_24_Data_3_1_1) + getValueSize(A_FSG_50_0_0_24_Data_3_3_1)+ getValueSize(A_FSG_50_0_0_24_Data_3_2_1));
          A_FSG_50_0_0_24_Data_3_LenList[0] = (getValueSize(A_FSG_50_0_0_24_Data_3_1_1) + getValueSize(A_FSG_50_0_0_24_Data_3_3_1)+ getValueSize(A_FSG_50_0_0_24_Data_3_2_1));
          putValue(A_FSG_50_0_0_24_Data_3_len_1, (getValueSize(A_FSG_50_0_0_24_Data_3_1_1) + getValueSize(A_FSG_50_0_0_24_Data_3_3_1)+ getValueSize(A_FSG_50_0_0_24_Data_3_2_1))); 
        }
  }
  putValue(A_FSG_50_0_0_24_Data_3_Data_1, A_FSG_50_0_0_24_ArrayDataList[0].Param3, A_FSG_50_0_0_24_ArrayDataList[0].Param3_Length);
}
*/

on envVar A_FSG_50_0_0_24_Data_3_1_1
{
  check_LG_SS(1);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_1_1
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS11",0);
    Active[1][1] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS11",1);
    Active[1][1] = 1;
  }
  check_LG_SS(1);
}

on envVar A_FSG_50_0_0_24_Data_3_2_1
{
  check_LG_SS(1);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_2_1
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS21",0);
    Active[2][1] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS21",1);
    Active[2][1] = 1;
  }
  check_LG_SS(1);
}

on envVar A_FSG_50_0_0_24_Data_3_3_1
{
  check_LG_SS(1);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_3_1
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS31",0);
    Active[3][1] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS31",1);
    Active[3][1] = 1;
  }
  check_LG_SS(1);
}

on envVar A_FSG_50_0_0_24_Data_3_1_2
{
  check_LG_SS(2);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_1_2
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS12",0);
    Active[1][2] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS12",1);
    Active[1][2] = 1;
  }
  check_LG_SS(2);
}

on envVar A_FSG_50_0_0_24_Data_3_2_2
{
  check_LG_SS(2);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_2_2
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS22",0);
    Active[2][2] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS22",1);
    Active[2][2] = 1;
  }
  check_LG_SS(2);
}

on envVar A_FSG_50_0_0_24_Data_3_3_2
{
  check_LG_SS(2);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_3_2
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS32",0);
    Active[3][2] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS32",1);
    Active[3][2] = 1;
  }
  check_LG_SS(2);
}

on envVar A_FSG_50_0_0_24_Data_3_1_3
{
  check_LG_SS(3);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_1_3
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS13",0);
    Active[1][3] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS13",1);
    Active[1][3] = 1;
  }
  check_LG_SS(3);
}

on envVar A_FSG_50_0_0_24_Data_3_2_3
{
  check_LG_SS(3);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_2_3
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS23",0);
    Active[2][3] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS23",1);
    Active[2][3] = 1;
  }
  check_LG_SS(3);
}

on envVar A_FSG_50_0_0_24_Data_3_3_3
{
  check_LG_SS(3);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_3_3
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS33",0);
    Active[3][3] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS33",1);
    Active[3][3] = 1;
  }
  check_LG_SS(3);
}

on envVar A_FSG_50_0_0_24_Data_3_1_4
{
  check_LG_SS(4);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_1_4
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS14",0);
    Active[1][4] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS14",1);
    Active[1][4] = 1;
  }
  check_LG_SS(4);
}

on envVar A_FSG_50_0_0_24_Data_3_2_4
{
  check_LG_SS(4);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_2_4
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS24",0);
    Active[2][4] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS24",1);
    Active[2][4] = 1;
  }
  check_LG_SS(4);
}

on envVar A_FSG_50_0_0_24_Data_3_3_4
{
  check_LG_SS(4);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_3_4
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS34",0);
    Active[3][4] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS34",1);
    Active[3][4] = 1;
  }
  check_LG_SS(4);
}

on envVar A_FSG_50_0_0_24_Data_3_1_5
{
  check_LG_SS(5);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_1_5
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS15",0);
    Active[1][5] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS15",1);
    Active[1][5] = 1;
  }
  check_LG_SS(5);
}

on envVar A_FSG_50_0_0_24_Data_3_2_5
{
  check_LG_SS(5);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_2_5
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS25",0);
    Active[2][5] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS25",1);
    Active[2][5] = 1;
  }
  check_LG_SS(5);
}

on envVar A_FSG_50_0_0_24_Data_3_3_5
{
  check_LG_SS(5);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_3_5
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS35",0);
    Active[3][5] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS35",1);
    Active[3][5] = 1;
  }
  check_LG_SS(5);
}

on envVar A_FSG_50_0_0_24_Data_3_1_6
{
  check_LG_SS(6);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_1_6
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS16",0);
    Active[1][6] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS16",1);
    Active[1][6] = 1;
  }
  check_LG_SS(6);
}

on envVar A_FSG_50_0_0_24_Data_3_2_6
{
  check_LG_SS(6);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_2_6
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS26",0);
    Active[2][6] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS26",1);
    Active[2][6] = 1;
  }
  check_LG_SS(6);
}

on envVar A_FSG_50_0_0_24_Data_3_3_6
{
  check_LG_SS(6);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_3_6
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS36",0);
    Active[3][6] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS36",1);
    Active[3][6] = 1;
  }
  check_LG_SS(6);
}

on envVar A_FSG_50_0_0_24_Data_3_1_7
{
  check_LG_SS(7);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_1_7
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS17",0);
    Active[1][7] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS17",1);
    Active[1][7] = 1;
  }
  check_LG_SS(7);
}

on envVar A_FSG_50_0_0_24_Data_3_2_7
{
  check_LG_SS(7);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_2_7
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS27",0);
    Active[2][7] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS27",1);
    Active[2][7] = 1;
  }
  check_LG_SS(7);
}

on envVar A_FSG_50_0_0_24_Data_3_3_7
{
  check_LG_SS(7);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_3_7
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS37",0);
    Active[3][7] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS37",1);
    Active[3][7] = 1;
  }
  check_LG_SS(7);
}

on envVar A_FSG_50_0_0_24_Data_3_1_8
{
  check_LG_SS(8);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_1_8
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS18",0);
    Active[1][8] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS18",1);
    Active[1][8] = 1;
  }
  check_LG_SS(8);
}

on envVar A_FSG_50_0_0_24_Data_3_2_8
{
  check_LG_SS(8);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_2_8
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS28",0);
    Active[2][8] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS28",1);
    Active[2][8] = 1;
  }
  check_LG_SS(8);
}

on envVar A_FSG_50_0_0_24_Data_3_3_8
{
  check_LG_SS(8);
}

on envVar A_FSG_50_0_0_24_Data_3_empty_3_8
{
  if(getValue(this) == 1) 
  { 
    EnableControl(LG_panel,"LSS38",0);
    Active[3][8] = 0;
  }
  else
  {
    EnableControl(LG_panel,"LSS38",1);
    Active[3][8] = 1;
  }
  check_LG_SS(8);
}

check_LG_SS(byte element)
{
  // couter resetten
  LG_SS_counter=0;
  LG_SS_element_counter = 0;
  
  
  switch (element)
  {
    case 1:  // erstes Element
      
        if (Active[1][1] == 1)  // aktive Elemente checken und Liste befüllen
        {
          A_FSG_50_0_0_24_ArrayDataList[0].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_1_1);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[2][1] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[0].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_2_1);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[3][1] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[0].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_3_1);
          LG_SS_element_counter++;
        }
        
        A_FSG_50_0_0_24_ArrayDataList[0].Param3_Length = LG_SS_element_counter;
        A_FSG_50_0_0_24_Data_3_LenList[0] = LG_SS_element_counter;
        putValue(A_FSG_50_0_0_24_Data_3_len_1, LG_SS_element_counter);
        putValue(A_FSG_50_0_0_24_Data_3_Data_1, A_FSG_50_0_0_24_ArrayDataList[0].Param3, A_FSG_50_0_0_24_ArrayDataList[0].Param3_Length);
        
    break;
        
    case 2:
      
        if (Active[1][2] == 1)  // aktive Elemente checken und Liste befüllen
        {
          A_FSG_50_0_0_24_ArrayDataList[1].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_1_2);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[2][2] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[1].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_2_2);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[3][2] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[1].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_3_2);
          LG_SS_element_counter++;
        }
        
        A_FSG_50_0_0_24_ArrayDataList[1].Param3_Length = LG_SS_element_counter;
        A_FSG_50_0_0_24_Data_3_LenList[1] = LG_SS_element_counter;
        putValue(A_FSG_50_0_0_24_Data_3_len_2, LG_SS_element_counter);
        putValue(A_FSG_50_0_0_24_Data_3_Data_2, A_FSG_50_0_0_24_ArrayDataList[1].Param3, A_FSG_50_0_0_24_ArrayDataList[1].Param3_Length);
        
    break;
                
    case 3:
      
        if (Active[1][3] == 1)  // aktive Elemente checken und Liste befüllen
        {
          A_FSG_50_0_0_24_ArrayDataList[2].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_1_3);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[2][3] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[2].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_2_3);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[3][3] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[2].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_3_3);
          LG_SS_element_counter++;
        }
        
        A_FSG_50_0_0_24_ArrayDataList[2].Param3_Length = LG_SS_element_counter;
        A_FSG_50_0_0_24_Data_3_LenList[2] = LG_SS_element_counter;
        putValue(A_FSG_50_0_0_24_Data_3_len_3, LG_SS_element_counter);
        putValue(A_FSG_50_0_0_24_Data_3_Data_3, A_FSG_50_0_0_24_ArrayDataList[2].Param3, A_FSG_50_0_0_24_ArrayDataList[2].Param3_Length);
        
    break;
                
    case 4:
      
        if (Active[1][4] == 1)  // aktive Elemente checken und Liste befüllen
        {
          A_FSG_50_0_0_24_ArrayDataList[3].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_1_4);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[2][4] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[3].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_2_4);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[3][4] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[3].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_3_4);
          LG_SS_element_counter++;
        }
        
        A_FSG_50_0_0_24_ArrayDataList[3].Param3_Length = LG_SS_element_counter;
        A_FSG_50_0_0_24_Data_3_LenList[3] = LG_SS_element_counter;
        putValue(A_FSG_50_0_0_24_Data_3_len_4, LG_SS_element_counter);
        putValue(A_FSG_50_0_0_24_Data_3_Data_4, A_FSG_50_0_0_24_ArrayDataList[3].Param3, A_FSG_50_0_0_24_ArrayDataList[3].Param3_Length);
        
    break;
        
    case 5:  // erstes Element
      
        if (Active[1][5] == 1)  // aktive Elemente checken und Liste befüllen
        {
          A_FSG_50_0_0_24_ArrayDataList[4].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_1_5);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[2][5] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[4].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_2_5);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[3][5] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[4].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_3_5);
          LG_SS_element_counter++;
        }
        
        A_FSG_50_0_0_24_ArrayDataList[4].Param3_Length = LG_SS_element_counter;
        A_FSG_50_0_0_24_Data_3_LenList[4] = LG_SS_element_counter;
        putValue(A_FSG_50_0_0_24_Data_3_len_5, LG_SS_element_counter);
        putValue(A_FSG_50_0_0_24_Data_3_Data_5, A_FSG_50_0_0_24_ArrayDataList[4].Param3, A_FSG_50_0_0_24_ArrayDataList[4].Param3_Length);
        
    break;
        
    case 6:
      
        if (Active[1][6] == 1)  // aktive Elemente checken und Liste befüllen
        {
          A_FSG_50_0_0_24_ArrayDataList[5].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_1_6);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[2][6] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[5].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_2_6);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[3][6] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[5].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_3_6);
          LG_SS_element_counter++;
        }
        
        A_FSG_50_0_0_24_ArrayDataList[5].Param3_Length = LG_SS_element_counter;
        A_FSG_50_0_0_24_Data_3_LenList[5] = LG_SS_element_counter;
        putValue(A_FSG_50_0_0_24_Data_3_len_6, LG_SS_element_counter);
        putValue(A_FSG_50_0_0_24_Data_3_Data_6, A_FSG_50_0_0_24_ArrayDataList[5].Param3, A_FSG_50_0_0_24_ArrayDataList[5].Param3_Length);
        
    break;
        
    case 7:
      
        if (Active[1][7] == 1)  // aktive Elemente checken und Liste befüllen
        {
          A_FSG_50_0_0_24_ArrayDataList[6].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_1_7);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[2][7] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[6].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_2_7);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[3][7] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[6].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_3_7);
          LG_SS_element_counter++;
        }
        
        A_FSG_50_0_0_24_ArrayDataList[6].Param3_Length = LG_SS_element_counter;
        A_FSG_50_0_0_24_Data_3_LenList[6] = LG_SS_element_counter;
        putValue(A_FSG_50_0_0_24_Data_3_len_6, LG_SS_element_counter);
        putValue(A_FSG_50_0_0_24_Data_3_Data_6, A_FSG_50_0_0_24_ArrayDataList[6].Param3, A_FSG_50_0_0_24_ArrayDataList[6].Param3_Length);
        
    break;
        
    case 8:  // erstes Element
      
        if (Active[1][8] == 1)  // aktive Elemente checken und Liste befüllen
        {
          A_FSG_50_0_0_24_ArrayDataList[7].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_1_8);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[2][8] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[7].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_2_8);
          LG_SS_counter++;
          LG_SS_element_counter++;
        }
        
        if (Active[3][8] == 1)
        {
          A_FSG_50_0_0_24_ArrayDataList[7].Param3[LG_SS_counter] = getValue(A_FSG_50_0_0_24_Data_3_3_8);
          LG_SS_element_counter++;
        }
        
        A_FSG_50_0_0_24_ArrayDataList[7].Param3_Length = LG_SS_element_counter;
        A_FSG_50_0_0_24_Data_3_LenList[7] = LG_SS_element_counter;
        putValue(A_FSG_50_0_0_24_Data_3_len_8, LG_SS_element_counter);
        putValue(A_FSG_50_0_0_24_Data_3_Data_8, A_FSG_50_0_0_24_ArrayDataList[7].Param3, A_FSG_50_0_0_24_ArrayDataList[7].Param3_Length);
        
    break;
  }
}


on envVar A_FSG_50_0_0_24_Data_4_1
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[0].Param4 = thisval;
   putValue(A_FSG_50_0_0_24_Data_4_1, A_FSG_50_0_0_24_ArrayDataList[0].Param4);
}

on envVar A_FSG_50_0_0_24_Data_5_1
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[0].Param5 = thisval;
  putValue(A_FSG_50_0_0_24_Data_5_1, A_FSG_50_0_0_24_ArrayDataList[0].Param5);
}
on envVar A_FSG_50_0_0_24_Data_6_1
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[0].Param6 = thisval;
  putValue(A_FSG_50_0_0_24_Data_6_1, A_FSG_50_0_0_24_ArrayDataList[0].Param6);
}
on envVar A_FSG_50_0_0_24_Data_7_1
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[0].Param7 = thisval;
  putValue(A_FSG_50_0_0_24_Data_7_1, A_FSG_50_0_0_24_ArrayDataList[0].Param7);
}
on envVar A_FSG_50_0_0_24_Data_8_1
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[0].Param8 = thisval;
  putValue(A_FSG_50_0_0_24_Data_8_1, A_FSG_50_0_0_24_ArrayDataList[0].Param8);
}


//////////////////  zweites Element  ///////////////////////////////////////////////////////////////////////////////////////

on envVar A_FSG_50_0_0_24_Data_1_2
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  A_FSG_50_0_0_24_ArrayDataList[1].Param1 = thisval;
  putValue(A_FSG_50_0_0_24_Data_1_2, A_FSG_50_0_0_24_ArrayDataList[1].Param1);
}

on envVar A_FSG_50_0_0_24_Data_2_2
{	
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[1].Param2 = thisval;
    putValue(A_FSG_50_0_0_24_Data_2_2, A_FSG_50_0_0_24_ArrayDataList[1].Param2);
}

on envVar A_FSG_50_0_0_24_Data_4_2
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[1].Param4 = thisval;
   putValue(A_FSG_50_0_0_24_Data_4_2, A_FSG_50_0_0_24_ArrayDataList[1].Param4);
}

on envVar A_FSG_50_0_0_24_Data_5_2
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[1].Param5 = thisval;
  putValue(A_FSG_50_0_0_24_Data_5_2, A_FSG_50_0_0_24_ArrayDataList[1].Param5);
}
on envVar A_FSG_50_0_0_24_Data_6_2
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[1].Param6 = thisval;
  putValue(A_FSG_50_0_0_24_Data_6_2, A_FSG_50_0_0_24_ArrayDataList[1].Param6);
}
on envVar A_FSG_50_0_0_24_Data_7_2
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[1].Param7 = thisval;
  putValue(A_FSG_50_0_0_24_Data_7_2, A_FSG_50_0_0_24_ArrayDataList[1].Param7);
}
on envVar A_FSG_50_0_0_24_Data_8_2
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[1].Param8 = thisval;
  putValue(A_FSG_50_0_0_24_Data_8_2, A_FSG_50_0_0_24_ArrayDataList[1].Param8);
}




//////////////////  drittes Element  ///////////////////////////////////////////////////////////////////////////////////////

on envVar A_FSG_50_0_0_24_Data_1_3
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  A_FSG_50_0_0_24_ArrayDataList[2].Param1 = thisval;
  putValue(A_FSG_50_0_0_24_Data_1_3, A_FSG_50_0_0_24_ArrayDataList[2].Param1);
}

on envVar A_FSG_50_0_0_24_Data_2_3
{	
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[2].Param2 = thisval;
    putValue(A_FSG_50_0_0_24_Data_2_3, A_FSG_50_0_0_24_ArrayDataList[2].Param2);
}

on envVar A_FSG_50_0_0_24_Data_4_3
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[2].Param4 = thisval;
   putValue(A_FSG_50_0_0_24_Data_4_3, A_FSG_50_0_0_24_ArrayDataList[2].Param4);
}

on envVar A_FSG_50_0_0_24_Data_5_3
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[2].Param5 = thisval;
  putValue(A_FSG_50_0_0_24_Data_5_3, A_FSG_50_0_0_24_ArrayDataList[2].Param5);
}
on envVar A_FSG_50_0_0_24_Data_6_3
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[2].Param6 = thisval;
  putValue(A_FSG_50_0_0_24_Data_6_3, A_FSG_50_0_0_24_ArrayDataList[2].Param6);
}
on envVar A_FSG_50_0_0_24_Data_7_3
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[2].Param7 = thisval;
  putValue(A_FSG_50_0_0_24_Data_7_3, A_FSG_50_0_0_24_ArrayDataList[2].Param7);
}
on envVar A_FSG_50_0_0_24_Data_8_3
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[2].Param8 = thisval;
  putValue(A_FSG_50_0_0_24_Data_8_3, A_FSG_50_0_0_24_ArrayDataList[2].Param8);
}


//////////////////  viertes Element  ///////////////////////////////////////////////////////////////////////////////////////

on envVar A_FSG_50_0_0_24_Data_1_4
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  A_FSG_50_0_0_24_ArrayDataList[3].Param1 = thisval;
  putValue(A_FSG_50_0_0_24_Data_1_4, A_FSG_50_0_0_24_ArrayDataList[3].Param1);
}

on envVar A_FSG_50_0_0_24_Data_2_4
{	
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[3].Param2 = thisval;
    putValue(A_FSG_50_0_0_24_Data_2_4, A_FSG_50_0_0_24_ArrayDataList[3].Param2);
}

on envVar A_FSG_50_0_0_24_Data_4_4
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[3].Param4 = thisval;
   putValue(A_FSG_50_0_0_24_Data_4_4, A_FSG_50_0_0_24_ArrayDataList[3].Param4);
}

on envVar A_FSG_50_0_0_24_Data_5_4
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[3].Param5 = thisval;
  putValue(A_FSG_50_0_0_24_Data_5_4, A_FSG_50_0_0_24_ArrayDataList[3].Param5);
}
on envVar A_FSG_50_0_0_24_Data_6_4
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[3].Param6 = thisval;
  putValue(A_FSG_50_0_0_24_Data_6_4, A_FSG_50_0_0_24_ArrayDataList[3].Param6);
}
on envVar A_FSG_50_0_0_24_Data_7_4
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[3].Param7 = thisval;
  putValue(A_FSG_50_0_0_24_Data_7_4, A_FSG_50_0_0_24_ArrayDataList[3].Param7);
}
on envVar A_FSG_50_0_0_24_Data_8_4
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[3].Param8 = thisval;
  putValue(A_FSG_50_0_0_24_Data_8_4, A_FSG_50_0_0_24_ArrayDataList[3].Param8);
}

//////////////////  fünftes Element  ///////////////////////////////////////////////////////////////////////////////////////

on envVar A_FSG_50_0_0_24_Data_1_5
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  A_FSG_50_0_0_24_ArrayDataList[4].Param1 = thisval;
  putValue(A_FSG_50_0_0_24_Data_1_5, A_FSG_50_0_0_24_ArrayDataList[4].Param1);
}

on envVar A_FSG_50_0_0_24_Data_2_5
{	
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[4].Param2 = thisval;
    putValue(A_FSG_50_0_0_24_Data_2_5, A_FSG_50_0_0_24_ArrayDataList[4].Param2);
}


on envVar A_FSG_50_0_0_24_Data_4_5
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[4].Param4 = thisval;
   putValue(A_FSG_50_0_0_24_Data_4_5, A_FSG_50_0_0_24_ArrayDataList[4].Param4);
}

on envVar A_FSG_50_0_0_24_Data_5_5
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[4].Param5 = thisval;
  putValue(A_FSG_50_0_0_24_Data_5_5, A_FSG_50_0_0_24_ArrayDataList[4].Param5);
}
on envVar A_FSG_50_0_0_24_Data_6_5
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[4].Param6 = thisval;
  putValue(A_FSG_50_0_0_24_Data_6_5, A_FSG_50_0_0_24_ArrayDataList[4].Param6);
}
on envVar A_FSG_50_0_0_24_Data_7_5
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[4].Param7 = thisval;
  putValue(A_FSG_50_0_0_24_Data_7_5, A_FSG_50_0_0_24_ArrayDataList[4].Param7);
}
on envVar A_FSG_50_0_0_24_Data_8_5
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[4].Param8 = thisval;
  putValue(A_FSG_50_0_0_24_Data_8_5, A_FSG_50_0_0_24_ArrayDataList[4].Param8);
}




//////////////////  sechstes Element  ///////////////////////////////////////////////////////////////////////////////////////

on envVar A_FSG_50_0_0_24_Data_1_6
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  A_FSG_50_0_0_24_ArrayDataList[5].Param1 = thisval;
  putValue(A_FSG_50_0_0_24_Data_1_6, A_FSG_50_0_0_24_ArrayDataList[5].Param1);
}

on envVar A_FSG_50_0_0_24_Data_2_6
{	
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[5].Param2 = thisval;
    putValue(A_FSG_50_0_0_24_Data_2_6, A_FSG_50_0_0_24_ArrayDataList[5].Param2);
}

on envVar A_FSG_50_0_0_24_Data_4_6
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[5].Param4 = thisval;
   putValue(A_FSG_50_0_0_24_Data_4_6, A_FSG_50_0_0_24_ArrayDataList[5].Param4);
}

on envVar A_FSG_50_0_0_24_Data_5_6
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[5].Param5 = thisval;
  putValue(A_FSG_50_0_0_24_Data_5_6, A_FSG_50_0_0_24_ArrayDataList[5].Param5);
}
on envVar A_FSG_50_0_0_24_Data_6_6
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[5].Param6 = thisval;
  putValue(A_FSG_50_0_0_24_Data_6_6, A_FSG_50_0_0_24_ArrayDataList[5].Param6);
}
on envVar A_FSG_50_0_0_24_Data_7_6
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[5].Param7 = thisval;
  putValue(A_FSG_50_0_0_24_Data_7_6, A_FSG_50_0_0_24_ArrayDataList[5].Param7);
}
on envVar A_FSG_50_0_0_24_Data_8_6
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[5].Param8 = thisval;
  putValue(A_FSG_50_0_0_24_Data_8_6, A_FSG_50_0_0_24_ArrayDataList[5].Param8);
}




//////////////////  siebtes Element  ///////////////////////////////////////////////////////////////////////////////////////

on envVar A_FSG_50_0_0_24_Data_1_7
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  A_FSG_50_0_0_24_ArrayDataList[6].Param1 = thisval;
  putValue(A_FSG_50_0_0_24_Data_1_7, A_FSG_50_0_0_24_ArrayDataList[6].Param1);
}

on envVar A_FSG_50_0_0_24_Data_2_7
{	
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[6].Param2 = thisval;
    putValue(A_FSG_50_0_0_24_Data_2_7, A_FSG_50_0_0_24_ArrayDataList[6].Param2);
}

on envVar A_FSG_50_0_0_24_Data_4_7
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[6].Param4 = thisval;
   putValue(A_FSG_50_0_0_24_Data_4_7, A_FSG_50_0_0_24_ArrayDataList[6].Param4);
}

on envVar A_FSG_50_0_0_24_Data_5_7
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[6].Param5 = thisval;
  putValue(A_FSG_50_0_0_24_Data_5_7, A_FSG_50_0_0_24_ArrayDataList[6].Param5);
}
on envVar A_FSG_50_0_0_24_Data_6_7
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[6].Param6 = thisval;
  putValue(A_FSG_50_0_0_24_Data_6_7, A_FSG_50_0_0_24_ArrayDataList[6].Param6);
}
on envVar A_FSG_50_0_0_24_Data_7_7
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[6].Param7 = thisval;
  putValue(A_FSG_50_0_0_24_Data_7_7, A_FSG_50_0_0_24_ArrayDataList[6].Param7);
}
on envVar A_FSG_50_0_0_24_Data_8_7
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[6].Param8 = thisval;
  putValue(A_FSG_50_0_0_24_Data_8_7, A_FSG_50_0_0_24_ArrayDataList[6].Param8);
}


//////////////////  achtess Element  ///////////////////////////////////////////////////////////////////////////////////////

on envVar A_FSG_50_0_0_24_Data_1_8
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  A_FSG_50_0_0_24_ArrayDataList[7].Param1 = thisval;
  putValue(A_FSG_50_0_0_24_Data_1_8, A_FSG_50_0_0_24_ArrayDataList[7].Param1);
}

on envVar A_FSG_50_0_0_24_Data_2_8
{	
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[7].Param2 = thisval;
    putValue(A_FSG_50_0_0_24_Data_2_8, A_FSG_50_0_0_24_ArrayDataList[7].Param2);
}

on envVar A_FSG_50_0_0_24_Data_4_8
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
    A_FSG_50_0_0_24_ArrayDataList[7].Param4 = thisval;
   putValue(A_FSG_50_0_0_24_Data_4_8, A_FSG_50_0_0_24_ArrayDataList[7].Param4);
}

on envVar A_FSG_50_0_0_24_Data_5_8
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[7].Param5 = thisval;
  putValue(A_FSG_50_0_0_24_Data_5_8, A_FSG_50_0_0_24_ArrayDataList[7].Param5);
}
on envVar A_FSG_50_0_0_24_Data_6_8
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[7].Param6 = thisval;
  putValue(A_FSG_50_0_0_24_Data_6_8, A_FSG_50_0_0_24_ArrayDataList[7].Param6);
}
on envVar A_FSG_50_0_0_24_Data_7_8
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[7].Param7 = thisval;
  putValue(A_FSG_50_0_0_24_Data_7_8, A_FSG_50_0_0_24_ArrayDataList[7].Param7);
}
on envVar A_FSG_50_0_0_24_Data_8_8
{
  byte thisval;
	byte superval[181];
	thisval=getValue(this);
  	thisval=thisval&0x000f;
    A_FSG_50_0_0_24_ArrayDataList[7].Param8 = thisval;
  putValue(A_FSG_50_0_0_24_Data_8_8, A_FSG_50_0_0_24_ArrayDataList[7].Param8);
}


on envVar A_FSG_50_0_0_24_1_Changed
{

	//Update Childvalue (Enum)
	byte thisval; // LaneGuidanceOnOff
	thisval = getValue(this);
}
on envVar A_FSG_50_0_0_24_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_24_2_SetGet_range // LaneGuidance.TAID 
{
	@A_FSG_50_0_0_24_2_SetGet = @A_FSG_50_0_0_24_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_24_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_24_2_SetGet, 1.0);
	@A_FSG_50_0_0_24_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_25_ErrCode
{
       if(gP_FSG_50_0_0_25_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_25", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_25_ErrCode = 1;
}
on envVar P_FSG_50_0_0_25Status_BTN
{
	byte BAPTemp[252];
    if (P_FSG_50_0_0_25Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_25_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_25",MakeRGB(255,255,255));
        P_FSG_50_0_0_25Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_25_BuildFct();
        getValue(P_FSG_50_0_0_25, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_25_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_25));
        if(getValue(P_FSG_50_0_0_25_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_25_ID);
        }
        if(getValue(P_FSG_50_0_0_25_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_25_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_25Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_25_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_25_ID;
    data[2]=getValue(P_FSG_50_0_0_25_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_25
on envVar P_FSG_50_0_0_25_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_25",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_25",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_25",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_25", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_25",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_25",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_25",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_25", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_25_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_25_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_25_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_25_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_25_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_25_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_25_ID,getValueSize(P_FSG_50_0_0_25_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_25_ID);
       }
}
on envVar P_FSG_50_0_0_25 // bus value of TMCinfo (25).
{
	// opcodes: Error-Status
	byte param1; // MessageID
	byte param2; // MessageStatus
	byte param3; // MessageWaitingIndication
	byte param4[250]; //Record: TMCinfo
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[252];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 252; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_25, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_50_0_0_25_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_50_0_0_25_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_50_0_0_25_3, param3);
	///////// Start param4 - Record /////////
	for( i = 0; i < 250; i++ )
	{
		param4[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_25_4, param4);
}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_25_BuildFct()
{
	byte param1; // MessageID
	byte param2; // MessageStatus
	byte param3; // MessageWaitingIndication
	byte param4[250]; //Record: TMCinfo

	dword i;
	byte superval[252];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_50_0_0_25_1_range = round(@P_FSG_50_0_0_25_1 + (0), 1.0); // slider value + min = real value
	param1 = (@P_FSG_50_0_0_25_1 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
	param1 = param1 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_50_0_0_25_2);
	param2 = param2 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param2;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_50_0_0_25_3);
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	//Record:TMCinfo
	getValue(P_FSG_50_0_0_25_4, param4);
	for( i = 0; i < 250; i++)
	{
	 superval[currentPos++] = param4[i];
	}
	putValue(P_FSG_50_0_0_25, superval, currentPos);
}


// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_25_1_range // TMCinfo.MessageID 
{
	@P_FSG_50_0_0_25_1 = @P_FSG_50_0_0_25_1_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_25_1 // TMCinfo.MessageID
{
	P_FSG_50_0_0_25_BuildFct();
}

on envVar P_FSG_50_0_0_25_2 // TMCinfo.MessageStatus
{
	P_FSG_50_0_0_25_BuildFct();
}

on envVar P_FSG_50_0_0_25_3 // TMCinfo.MessageWaitingIndication
{
	P_FSG_50_0_0_25_BuildFct();
}

//Record: TMCinfo, Element: Priority
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_25_4_Priority_range // TMCinfo.Priority 
{
	@P_FSG_50_0_0_25_4_Priority = @P_FSG_50_0_0_25_4_Priority_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_25_4_Priority // TMCinfo.Priority
{
	byte superval[250];

	//Update Childvalue (Number)
	byte thisval; // Priority
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_25_4_Priority, 1.0);
	@P_FSG_50_0_0_25_4_Priority_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_25_4, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_25_4,superval);
}

//Record: TMCinfo, Element: StreetName

// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_25_4_StreetName_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_25_4_StreetName_len);
	cnt = getValue(P_FSG_50_0_0_25_4_StreetName_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_25_4_StreetName_len, 127);
		}
	}

	P_FSG_50_0_0_25_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_25_4_StreetName_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 60)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_25_4_StreetName ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 60);
		putValue(this, 60);
	}
	P_FSG_50_0_0_25_BuildFct();
}


on envVar P_FSG_50_0_0_25_4_StreetName // TMCinfo.StreetName
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_25_4_StreetName_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_25_4_StreetName_len, string_length_mod);
  
  P_FSG_50_0_0_25_4_BuildFct();
  
  
  /*	byte superval[250];

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);

    // Update superval
	getValue(P_FSG_50_0_0_25_4, superval);
	for( i = 0; i < 61; i++ )
	{
		superval[i+1] = thisval[i];
	}
	putValue(P_FSG_50_0_0_25_4,superval);*/
}

//Record: TMCinfo, Element: Location

// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_25_4_Location_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_25_4_Location_len);
	cnt = getValue(P_FSG_50_0_0_25_4_Location_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_25_4_Location_len, 127);
		}
	}

	P_FSG_50_0_0_25_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_25_4_Location_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 60)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_25_4_Location ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 60);
		putValue(this, 60);
	}
	P_FSG_50_0_0_25_BuildFct();
}


on envVar P_FSG_50_0_0_25_4_Location // TMCinfo.Location
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_25_4_Location_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_25_4_Location_len, string_length_mod);
  
  P_FSG_50_0_0_25_4_BuildFct();
  
  
	//putValue(P_FSG_50_0_0_25_4,superval);
  
  /*byte superval[250];

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);

    // Update superval
	getValue(P_FSG_50_0_0_25_4, superval);
	for( i = 0; i < 61; i++ )
	{
		superval[i+62] = thisval[i];
	}
	putValue(P_FSG_50_0_0_25_4,superval);*/
}

//Record: TMCinfo, Element: Infotext

// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_25_4_Infotext_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_25_4_Infotext_len);
	cnt = getValue(P_FSG_50_0_0_25_4_Infotext_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_25_4_Infotext_len, 127);
		}
	}

	P_FSG_50_0_0_25_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_25_4_Infotext_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 120)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_25_4_Infotext ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 120);
		putValue(this, 120);
	}
	P_FSG_50_0_0_25_BuildFct();
}


on envVar P_FSG_50_0_0_25_4_Infotext // TMCinfo.Infotext
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_25_4_Infotext_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_25_4_Infotext_len, string_length_mod);
  
  P_FSG_50_0_0_25_4_BuildFct();
  
  /*	byte superval[250];

	//Update Childvalue (String)
	word i;
	byte thisval[121];
	getValue(this, thisval);

    // Update superval
	getValue(P_FSG_50_0_0_25_4, superval);
	for( i = 0; i < 121; i++ )
	{
		superval[i+123] = thisval[i];
	}
	putValue(P_FSG_50_0_0_25_4,superval);*/
}

//Record: TMCinfo, Element: Length_Validity
on envVar P_FSG_50_0_0_25_4_Length_Validity_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Length_Validity
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_25_4_Length_Validity);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_25_4_Length_Validity,thisval);
}

on envVar P_FSG_50_0_0_25_4_Length_Validity // TMCinfo.Length_Validity
{
	byte superval[250];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Length_Validity
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_25_4_Length_Validity_0, 1);
	else
		putValue(P_FSG_50_0_0_25_4_Length_Validity_0, 0);

    // Update superval
	getValue(P_FSG_50_0_0_25_4, superval);
	superval[244]=thisval;
	putValue(P_FSG_50_0_0_25_4,superval);
  
  P_FSG_50_0_0_25_4_BuildFct();
}

//Record: TMCinfo, Element: Length_Value
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_25_4_Length_Value_range // TMCinfo.Length_Value 
{
	@P_FSG_50_0_0_25_4_Length_Value = @P_FSG_50_0_0_25_4_Length_Value_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_25_4_Length_Value // TMCinfo.Length_Value
{
	byte superval[250];

	//Update Childvalue (Number)
	dword thisval; // Length_Value
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_25_4_Length_Value, 0.1);
	@P_FSG_50_0_0_25_4_Length_Value_range = slider_value + (0); // real value := slider value + range min.
	thisval = (dword)round((slider_value + (0) - (0)) / (0.1), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_25_4, superval);
	superval[245]= thisval&0x000000ff;
	superval[246]=(thisval&0x0000ff00)>>8;
	superval[247]=(thisval&0x00ff0000)>>16;
	superval[248]=(thisval&0xff000000)>>24;
	putValue(P_FSG_50_0_0_25_4,superval);
  
  P_FSG_50_0_0_25_4_BuildFct();
}

//Record: TMCinfo, Element: Length_Unit
on envVar P_FSG_50_0_0_25_4_Length_Unit // TMCinfo.Length_Unit
{
	byte superval[250];

	//Update Childvalue (Enum)
	byte thisval; // Length_Unit
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_25_4, superval);
	superval[249]=thisval;
	putValue(P_FSG_50_0_0_25_4,superval);
  
  P_FSG_50_0_0_25_4_BuildFct();
}

P_FSG_50_0_0_25_4_BuildFct()
{
  byte array[BAP_BUFFER_SIZE];
  byte temp_array[BAP_BUFFER_SIZE];
  int i,j;
  long tempval;
  
  i=0;
  j=0;
  
  array[i++] = @P_FSG_50_0_0_25_4_Priority_range;
  
  if (@P_FSG_50_0_0_25_4_StreetName_len != 0)
  {
    array[i++] = @P_FSG_50_0_0_25_4_StreetName_len;
    getvalue(P_FSG_50_0_0_25_4_StreetName_Hex, temp_array);
    for (j=0; j<@P_FSG_50_0_0_25_4_StreetName_len;j++)
    {
      array[i++] = temp_array[j];
    }
  }
  else
    array[i++] = 0x00;
    
  if (@P_FSG_50_0_0_25_4_Location_len != 0)
  {
    array[i++] = @P_FSG_50_0_0_25_4_Location_len;
    getvalue(P_FSG_50_0_0_25_4_Location_Hex, temp_array);
    for (j=0; j<@P_FSG_50_0_0_25_4_Location_len;j++)
    {
      array[i++] = temp_array[j];
    }
  }
  else
    array[i++] = 0x00;
  
  if (@P_FSG_50_0_0_25_4_Infotext_len != 0)
  {
    array[i++] = @P_FSG_50_0_0_25_4_Infotext_len;
    getvalue(P_FSG_50_0_0_25_4_Infotext_Hex, temp_array);
    for (j=0; j<@P_FSG_50_0_0_25_4_Infotext_len;j++)
    {
      array[i++] = temp_array[j];
    }
  }
  else
    array[i++] = 0x00;
  
  array[i++] = @P_FSG_50_0_0_25_4_Length_Validity;
  
  tempval = @P_FSG_50_0_0_25_4_Length_Value;
  array[i++] = tempval&0x000000ff;
  array[i++] = (tempval&0x0000ff00)>>8;
  array[i++] = (tempval&0x00ff0000)>>16;
  array[i++] = (tempval&0xff000000)>>24;
  
  array[i++] = @P_FSG_50_0_0_25_4_Length_Unit;
  
  putvalue(P_FSG_50_0_0_25_4,array,i);
}

on envVar P_FSG_50_0_0_25_4 // TMCinfo.TMCinfo
{
	byte recordVal[250]; //Record: TMCinfo
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	byte param1; // Priority
	byte param2[61]; // StreetName
	word len2;
	byte cnt2;
	byte param3[61]; // Location
	word len3;
	byte cnt3;
	byte param4[121]; // Infotext
	word len4;
	byte cnt4;
	byte param5; // Length_Validity
	dword param6; // Length_Value
	byte param7; // Length_Unit

	currentPos = 0;
	getValue(P_FSG_50_0_0_25_4, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT8 /////////
	param1 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_25_4_Priority, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - STRING /////////
	getValue(P_FSG_50_0_0_25_4_StreetName, param2);
	if((recordVal[currentPos] & 0x80) > 0)
	{
		if(60>127) /* Max Fct-Katalog Laenge: 60*/
		{
			len2 = ( (recordVal[currentPos]&0x7F) <<8) + recordVal[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 60;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_25_4 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = recordVal[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 60)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 60;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = recordVal[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_25_4_StreetName_len, len2);
	putValue(P_FSG_50_0_0_25_4_StreetName_cnt, cnt2);
	
	if(len2 > getValueSize(P_FSG_50_0_0_25_4_StreetName))
		putValue(P_FSG_50_0_0_25_4_StreetName, param2, len2);
	else
		putValue(P_FSG_50_0_0_25_4_StreetName, param2, getValueSize(P_FSG_50_0_0_25_4_StreetName));

	///////// Start param3 - STRING /////////
	getValue(P_FSG_50_0_0_25_4_Location, param3);
	if((recordVal[currentPos] & 0x80) > 0)
	{
		if(60>127) /* Max Fct-Katalog Laenge: 60*/
		{
			len3 = ( (recordVal[currentPos]&0x7F) <<8) + recordVal[currentPos+1];
			currentPos = currentPos + 2;
			cnt3 = 1;
		}
		else
		{
			len3 = 60;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_25_4 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len3 = recordVal[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt3 = 0;
	}
	
	if(len3 > 60)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len3, currentPos);
		len3 = 60;
	
		if(len3 < 128) cnt3 = 0;
		else cnt3 = 1;
	}
	
	for(i = 0; i < len3; i++)
	{
		param3[i] = recordVal[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_25_4_Location_len, len3);
	putValue(P_FSG_50_0_0_25_4_Location_cnt, cnt3);
	
	if(len3 > getValueSize(P_FSG_50_0_0_25_4_Location))
		putValue(P_FSG_50_0_0_25_4_Location, param3, len3);
	else
		putValue(P_FSG_50_0_0_25_4_Location, param3, getValueSize(P_FSG_50_0_0_25_4_Location));

	///////// Start param4 - STRING /////////
	getValue(P_FSG_50_0_0_25_4_Infotext, param4);
	if((recordVal[currentPos] & 0x80) > 0)
	{
		if(120>127) /* Max Fct-Katalog Laenge: 120*/
		{
			len4 = ( (recordVal[currentPos]&0x7F) <<8) + recordVal[currentPos+1];
			currentPos = currentPos + 2;
			cnt4 = 1;
		}
		else
		{
			len4 = 120;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_25_4 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len4 = recordVal[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt4 = 0;
	}
	
	if(len4 > 120)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len4, currentPos);
		len4 = 120;
	
		if(len4 < 128) cnt4 = 0;
		else cnt4 = 1;
	}
	
	for(i = 0; i < len4; i++)
	{
		param4[i] = recordVal[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_25_4_Infotext_len, len4);
	putValue(P_FSG_50_0_0_25_4_Infotext_cnt, cnt4);
	
	if(len4 > getValueSize(P_FSG_50_0_0_25_4_Infotext))
		putValue(P_FSG_50_0_0_25_4_Infotext, param4, len4);
	else
		putValue(P_FSG_50_0_0_25_4_Infotext, param4, getValueSize(P_FSG_50_0_0_25_4_Infotext));

	///////// Start param5 - UINT8 /////////
	param5 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_25_4_Length_Validity, param5);
	///////// Start param6 - UINT32 /////////
	param6 = recordVal[currentPos++]|(recordVal[currentPos++]<<8)|(recordVal[currentPos++]<<16)|(recordVal[currentPos++]<<24);
	putValue(P_FSG_50_0_0_25_4_Length_Value, round((param6 * 0.1) - (0) + (0), 0.1));
	///////// Start param7 - UINT8 /////////
	param7 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_25_4_Length_Unit, param7);
	P_FSG_50_0_0_25_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_26_ErrCode
{
       if(gP_FSG_50_0_0_26_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_26", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_26_ErrCode = 1;
}
on envVar P_FSG_50_0_0_26Status_BTN
{
    if (P_FSG_50_0_0_26Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_50_0_0_26_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_26",MakeRGB(255,255,255));
       P_FSG_50_0_0_26Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_50_0_0_26_ID, Data_REQ, getValue(P_FSG_50_0_0_26));
      P_FSG_50_0_0_26Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_26_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_26_ID;
    data[2]=getValue(P_FSG_50_0_0_26_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_26
on envVar P_FSG_50_0_0_26_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_26",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_26",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_26",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_26", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_26",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_26",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_26",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_26", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_26 // bus value of MagnetFieldZone (26).
{
	// opcodes: Error-Status
	byte param1; // Zone
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_50_0_0_26);
	putValue(P_FSG_50_0_0_26_1, param1);
}

on envVar P_FSG_50_0_0_26_1 // MagnetFieldZone.Zone
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // Zone
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_50_0_0_26);
	superval = thisval;
	putValue(P_FSG_50_0_0_26,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_27_ErrCode
{
       if(gP_FSG_50_0_0_27_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_27", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_27_ErrCode = 1;
}
on envVar P_FSG_50_0_0_27Status_BTN
{
    if (P_FSG_50_0_0_27Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_50_0_0_27_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_27",MakeRGB(255,255,255));
       P_FSG_50_0_0_27Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_50_0_0_27_ID, Data_REQ, getValue(P_FSG_50_0_0_27));
      P_FSG_50_0_0_27Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_27_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_27_ID;
    data[2]=getValue(P_FSG_50_0_0_27_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_27
on envVar P_FSG_50_0_0_27_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_27",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_27",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_27",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_27", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_27",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_27",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_27",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_27", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_27 // bus value of Calibration (27).
{
	// opcodes: Error-Status
	byte param1; // CalibrationState
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_50_0_0_27);
	putValue(P_FSG_50_0_0_27_1, param1);
}

on envVar P_FSG_50_0_0_27_1 // Calibration.CalibrationState
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // CalibrationState
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_50_0_0_27);
	superval = thisval;
	putValue(P_FSG_50_0_0_27,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_28_ErrCode
{
       if(gP_FSG_50_0_0_28_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_28", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_28_ErrCode = 1;
}
on envVar P_FSG_50_0_0_28Status_BTN
{
	byte BAPTemp[1];
   if (P_FSG_50_0_0_28Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_28_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_28",MakeRGB(255,255,255));
      P_FSG_50_0_0_28Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_28, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_28_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_28));
      P_FSG_50_0_0_28Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_28_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_28_ID;
    data[2]=getValue(P_FSG_50_0_0_28_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_28
on envVar P_FSG_50_0_0_28_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_28",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_28",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_28",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_28", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_28",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_28",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_28",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_28", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_28 // bus value of ASG_Capabilities (28).
{
	// opcodes: Error-Status
	byte param1; // PresentationCapabilities
	byte param2; // FurtherCapabilities
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[1];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 1; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_28, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_50_0_0_28_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_50_0_0_28_2, param2);
}

on envVar P_FSG_50_0_0_28_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PresentationCapabilities
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_28_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_28_1,thisval);
}

on envVar P_FSG_50_0_0_28_1 // ASG_Capabilities.PresentationCapabilities
{
	byte superval[1];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // PresentationCapabilities
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_28_1_0, 1);
	else
		putValue(P_FSG_50_0_0_28_1_0, 0);

    // Update superval
	getValue(P_FSG_50_0_0_28, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(P_FSG_50_0_0_28,superval);
}

on envVar P_FSG_50_0_0_28_2 // ASG_Capabilities.FurtherCapabilities
{
	byte superval[1];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // FurtherCapabilities
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_28, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(P_FSG_50_0_0_28,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_50_0_0_29_ErrCode
{
       if(gA_FSG_50_0_0_29_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_29", MakeRGB(255,255,255));
       }
       gA_FSG_50_0_0_29_ErrCode = 1;
}
on envVar A_FSG_50_0_0_29Changed_BTN
{
    byte data[401]; 
    byte stringValue[401];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_50_0_0_29Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_29_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_29",MakeRGB(255,255,255));
        A_FSG_50_0_0_29Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_29_Changed);
        getValue(A_FSG_50_0_0_29_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_29_Changed_Start);
     elementsVal = getValue(A_FSG_50_0_0_29_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_29_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 29");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_29_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_29_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 29");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_50_0_0_29_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_50_0_0_29_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_50_0_0_29_ID);
       }
       if(getValue(A_FSG_50_0_0_29_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_50_0_0_29_ID,getValueSize(A_FSG_50_0_0_29_Changed));
       }
        A_FSG_50_0_0_29Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_29Status_BTN
{
    byte data[401 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[401];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_50_0_0_29Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_29_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_29",MakeRGB(255,255,255));
        A_FSG_50_0_0_29Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_29_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_29_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_29_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_29);
        getValue(A_FSG_50_0_0_29,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_29_Start);
     elementsVal = getValue(A_FSG_50_0_0_29_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_29_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 29");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_29_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_29_RecAdr ) || 2 == getValue( A_FSG_50_0_0_29_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_29_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_29_RecAdr ) || 1 == getValue( A_FSG_50_0_0_29_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_29_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_29_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 97-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_29_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 97-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_29_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 97-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_29_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 97-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_29_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_29_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 29");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_29_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_29_RecAdr ) || 2 == getValue( A_FSG_50_0_0_29_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_29_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_29_RecAdr ) || 1 == getValue( A_FSG_50_0_0_29_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_29_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_29_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 97-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_29_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 97-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_29_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 97-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_29_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 97-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_50_0_0_29, data);
        Request_ByteSequence(LSGID, A_FSG_50_0_0_29_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_50_0_0_29_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_50_0_0_29_ID);
        }
        if(getValue(A_FSG_50_0_0_29_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_50_0_0_29_ID,getValueSize(A_FSG_50_0_0_29));
        }
        A_FSG_50_0_0_29Status_BTN_already_pressed = 0;
    }
}
A_FSG_50_0_0_29_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[401];
    byte stringValue[401];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_29_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_29_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_29_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_29);
        getValue(A_FSG_50_0_0_29,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_29_Start);
     elementsVal = getValue(A_FSG_50_0_0_29_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_29_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 29");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_29_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_29_RecAdr ) || 2 == getValue( A_FSG_50_0_0_29_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_29_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_29_RecAdr ) || 1 == getValue( A_FSG_50_0_0_29_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_29_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_29_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 97-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_29_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 97-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_29_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 97-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_29_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 97-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_29_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_29_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 29");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_29_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_29_RecAdr ) || 2 == getValue( A_FSG_50_0_0_29_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_29_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_29_RecAdr ) || 1 == getValue( A_FSG_50_0_0_29_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_29_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_29_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 97-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_29_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 97-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_29_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 97-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_29_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 97-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_29_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_50_0_0_29_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_50_0_0_29
{
    byte temp[401];
    getValue(A_FSG_50_0_0_29, temp);
    putValue(A_FSG_50_0_0_29_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_29_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_29_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_29_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_29_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_50_0_0_29_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_50_0_0_29_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_29_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_29_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_29_IndexSize))
    {
        putValue(A_FSG_50_0_0_29_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_50_0_0_29_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_50_0_0_29_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_50_0_0_29_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_50_0_0_29_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_29_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_29_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_29_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_29_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_29_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_29_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_29_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_29_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_29_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_29_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_29_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_29_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_29_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_50_0_0_29, head, headLength); 
}

on envVar A_FSG_50_0_0_29_RecAdr
{
    A_FSG_50_0_0_29_GenerateStatus();
}

on envVar A_FSG_50_0_0_29_Shift
{
    A_FSG_50_0_0_29_GenerateStatus();
}

on envVar A_FSG_50_0_0_29_Direction
{
    A_FSG_50_0_0_29_GenerateStatus();
}

on envVar A_FSG_50_0_0_29_Start
{
    A_FSG_50_0_0_29_GenerateStatus();
}

on envVar A_FSG_50_0_0_29_Elements
{
    A_FSG_50_0_0_29_GenerateStatus();
}

on envVar A_FSG_50_0_0_29_IndexSize
{
    A_FSG_50_0_0_29_GenerateStatus();
}
on envVar A_FSG_50_0_0_29_TransPos
{
    A_FSG_50_0_0_29_GenerateStatus();
}
A_FSG_50_0_0_29_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_29_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_29_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_29_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_29_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_29_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_29_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_29_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_29_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_29_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_29_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_29_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_50_0_0_29_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_29_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_29_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_50_0_0_29_Changed, head, 3); 
    }
}

on envVar A_FSG_50_0_0_29_Changed_RecAdr
{
    A_FSG_50_0_0_29_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_29_Changed_Shift
{
    A_FSG_50_0_0_29_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_29_Changed_Direction
{
    A_FSG_50_0_0_29_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_29_Changed_Start
{
    A_FSG_50_0_0_29_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_29_Changed_Elements
{
    A_FSG_50_0_0_29_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_29_Changed_IndexSize
{
    A_FSG_50_0_0_29_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_29_Changed_TransPos
{
    A_FSG_50_0_0_29_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_29_SetGet
{
    byte temp[401];
    getValue(A_FSG_50_0_0_29_SetGet, temp);
    putValue(A_FSG_50_0_0_29_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_29_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_29_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_29_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_29_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_29_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_29_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_29_SetGet_IndexSize))
    {
        putValue(A_FSG_50_0_0_29_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_50_0_0_29_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_50_0_0_29_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_50_0_0_29_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_50_0_0_29_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_50_0_0_29_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_50_0_0_29_ArrayDataList[i].Param1 = 0;
		A_FSG_50_0_0_29_ArrayDataList[i].Param2 = 0;
		for(j=0; j<97; j++)
			A_FSG_50_0_0_29_ArrayDataList[i].Param3[j] = 0;
		A_FSG_50_0_0_29_ArrayDataList[i].Param3_Length = 0;
		A_FSG_50_0_0_29_Data_3_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_50_0_0_29_fileSelector,gListPath);
  
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						A_FSG_50_0_0_29_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_50_0_0_29_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //POI_Type
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //POI_Type
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Description
								if(paramPos < 96)
								{
									A_FSG_50_0_0_29_ArrayDataList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_29_ArrayDataList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_50_0_0_29_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_50_0_0_29_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_29_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_50_0_0_29_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_50_0_0_29_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_50_0_0_29_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_50_0_0_29_Data_1, A_FSG_50_0_0_29_ArrayDataList[ getValue( A_FSG_50_0_0_29_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_29_Data_2, A_FSG_50_0_0_29_ArrayDataList[ getValue( A_FSG_50_0_0_29_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_29_Data_3, A_FSG_50_0_0_29_ArrayDataList[ getValue( A_FSG_50_0_0_29_DataIndex) ].Param3, A_FSG_50_0_0_29_ArrayDataList[getValue(A_FSG_50_0_0_29_DataIndex)].Param3_Length);
}


on envVar A_FSG_50_0_0_29_generateData_Btn
{
	word i;
	dword elementsArray[4] = {1, 1, 97, 2};
	byte elementsTypeArray[4] = {0, 0, 0xE, 0xF};
	dword elementsMaxSizeArray[4] = {255, 0xFF, 0, 0};
	byte tempArray[25654];
	if (A_FSG_50_0_0_29_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_29_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 29, 254 );
		for(i = 0; i < 254; i++)
		{
			memcpy(A_FSG_50_0_0_29_ArrayDataList[i], tempArray, (i * 101) );
			if(A_FSG_50_0_0_29_ArrayDataList[i].Param3_Length > 127 )
				A_FSG_50_0_0_29_Data_3_CntList[i] = 1;
		}
		A_FSG_50_0_0_29_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_50_0_0_29_Data_1, A_FSG_50_0_0_29_ArrayDataList[ getValue( A_FSG_50_0_0_29_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_29_Data_2, A_FSG_50_0_0_29_ArrayDataList[ getValue( A_FSG_50_0_0_29_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_29_Data_3, A_FSG_50_0_0_29_ArrayDataList[ getValue( A_FSG_50_0_0_29_DataIndex) ].Param3, A_FSG_50_0_0_29_ArrayDataList[getValue(A_FSG_50_0_0_29_DataIndex)].Param3_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_50_0_0_29_DataIndex
{
    long index;
    long maxIndex = 254-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_50_0_0_29_Data_1, A_FSG_50_0_0_29_ArrayDataList[index].Param1);
    putValue(A_FSG_50_0_0_29_Data_2, A_FSG_50_0_0_29_ArrayDataList[index].Param2);
    putValue(A_FSG_50_0_0_29_Data_3_len, A_FSG_50_0_0_29_Data_3_LenList[index]);
    putValue(A_FSG_50_0_0_29_Data_3_cnt, A_FSG_50_0_0_29_Data_3_CntList[index]);
    putValue(A_FSG_50_0_0_29_Data_3, A_FSG_50_0_0_29_ArrayDataList[index].Param3, A_FSG_50_0_0_29_ArrayDataList[index].Param3_Length);

}
on envVar A_FSG_50_0_0_29_DataIndex_Incr
{
    long index;
    if(A_FSG_50_0_0_29_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_50_0_0_29_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_29_DataIndex);
        index++;
        putValue(A_FSG_50_0_0_29_DataIndex, index);
        A_FSG_50_0_0_29_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_29_DataIndex_Decr
{
    long index;
    if(A_FSG_50_0_0_29_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_50_0_0_29_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_29_DataIndex);
        index--;
        putValue(A_FSG_50_0_0_29_DataIndex, index);
        A_FSG_50_0_0_29_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_29_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_50_0_0_29_ID;
    data[2]=getValue(A_FSG_50_0_0_29_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_50_0_0_29
on envVar A_FSG_50_0_0_29_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_29",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_29",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_29",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_29_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_29", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_29",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_29",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_29",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_29_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_29", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_29_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_29_SegmEn,0);
           intertelegram_err(A_FSG_50_0_0_29_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_50_0_0_29_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_29_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_29_IntTlgEn,0);
           sequence_err(A_FSG_50_0_0_29_ID,getValueSize(A_FSG_50_0_0_29_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_50_0_0_29_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_50_0_0_29_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_50_0_0_29_Status",1);
 	}
}



A_FSG_50_0_0_29_SetInd () { /* leere Function*/ }

A_FSG_50_0_0_29_SetGetInd () { /* leere Function*/ }

A_FSG_50_0_0_29_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[401];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_29_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_29_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_50_0_0_29_SetGet, head, 5);
                if(getValue(A_FSG_50_0_0_29_AT))
                {
                    putValue(A_FSG_50_0_0_29,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_50_0_0_29_SetGet, head, 3);
            if(getValue(A_FSG_50_0_0_29_AT))
            {
                putValue(A_FSG_50_0_0_29,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_50_0_0_29_AT))
        {
            putValue(A_FSG_50_0_0_29_RecAdr,recordAddressVal);
            putValue(A_FSG_50_0_0_29_Start, startVal);
            putValue(A_FSG_50_0_0_29_Elements, elementsVal);
            putValue(A_FSG_50_0_0_29_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_50_0_0_29_1
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_29_2_range // LastDest_List.TAID 
{
	@A_FSG_50_0_0_29_2 = @A_FSG_50_0_0_29_2_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_29_2
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_29_2, 1.0);
	@A_FSG_50_0_0_29_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_29_3_range // LastDest_List.TotalNumListElements 
{
	@A_FSG_50_0_0_29_3 = @A_FSG_50_0_0_29_3_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_29_3
{

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_29_3, 1.0);
	@A_FSG_50_0_0_29_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_29_Data_1_range // LastDest_List.Pos 
{
	@A_FSG_50_0_0_29_Data_1 = @A_FSG_50_0_0_29_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_29_Data_1
{

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_29_Data_1, 1.0);
	@A_FSG_50_0_0_29_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_29_ArrayDataList[getValue(A_FSG_50_0_0_29_DataIndex)].Param1 = thisval;
}
on envVar A_FSG_50_0_0_29_Data_2
{

	//Update Childvalue (Enum)
	byte thisval; // POI_Type
	thisval = getValue(this);
    A_FSG_50_0_0_29_ArrayDataList[getValue(A_FSG_50_0_0_29_DataIndex)].Param2 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_29_Data_3_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_29_Data_3_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_29_Data_3_CntList[ getValue(A_FSG_50_0_0_29_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_29_Data_3_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_29_Data_3_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_29_Data_3_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 96 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_29_Data_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 96);
		thisval = 96;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_29_Data_3_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_29_ArrayDataList[getValue(A_FSG_50_0_0_29_DataIndex)].Param3_Length = thisval;
	A_FSG_50_0_0_29_Data_3_LenList[ getValue(A_FSG_50_0_0_29_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_29_Data_3_len, thisval);

}

on envVar A_FSG_50_0_0_29_Data_3
{

	//Update Childvalue (String)
	word i;
	byte thisval[97];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_29_ArrayDataList[getValue(A_FSG_50_0_0_29_DataIndex)].Param3[i] = thisval[i];
    A_FSG_50_0_0_29_ArrayDataList[getValue(A_FSG_50_0_0_29_DataIndex)].Param3_Length = getValueSize(this);
    A_FSG_50_0_0_29_Data_3_LenList[getValue(A_FSG_50_0_0_29_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_29_Data_3_len, getValueSize(this));
}
on envVar A_FSG_50_0_0_29_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_29_2_SetGet_range // LastDest_List.TAID 
{
	@A_FSG_50_0_0_29_2_SetGet = @A_FSG_50_0_0_29_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_29_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_29_2_SetGet, 1.0);
	@A_FSG_50_0_0_29_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_50_0_0_30_ErrCode
{
       if(gA_FSG_50_0_0_30_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_30", MakeRGB(255,255,255));
       }
       gA_FSG_50_0_0_30_ErrCode = 1;
}
on envVar A_FSG_50_0_0_30Changed_BTN
{
    byte data[401]; 
    byte stringValue[401];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_50_0_0_30Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_30_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_30",MakeRGB(255,255,255));
        A_FSG_50_0_0_30Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_30_Changed);
        getValue(A_FSG_50_0_0_30_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_30_Changed_Start);
     elementsVal = getValue(A_FSG_50_0_0_30_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_30_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 30");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_30_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_30_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 30");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_50_0_0_30_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_50_0_0_30_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_50_0_0_30_ID);
       }
       if(getValue(A_FSG_50_0_0_30_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_50_0_0_30_ID,getValueSize(A_FSG_50_0_0_30_Changed));
       }
        A_FSG_50_0_0_30Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_30Status_BTN
{
    byte data[401 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[401];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_50_0_0_30Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_30_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_30",MakeRGB(255,255,255));
        A_FSG_50_0_0_30Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_30_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_30_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_30_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_30);
        getValue(A_FSG_50_0_0_30,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_30_Start);
     elementsVal = getValue(A_FSG_50_0_0_30_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_30_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 30");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_30_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_30_RecAdr ) || 2 == getValue( A_FSG_50_0_0_30_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_30_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_30_RecAdr ) || 1 == getValue( A_FSG_50_0_0_30_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_30_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_30_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 97-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_30_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 97-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_30_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 97-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_30_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 97-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_30_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_30_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 30");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_30_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_30_RecAdr ) || 2 == getValue( A_FSG_50_0_0_30_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_30_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_30_RecAdr ) || 1 == getValue( A_FSG_50_0_0_30_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_30_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_30_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 97-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_30_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 97-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_30_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 97-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_30_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 97-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_50_0_0_30, data);
        Request_ByteSequence(LSGID, A_FSG_50_0_0_30_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_50_0_0_30_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_50_0_0_30_ID);
        }
        if(getValue(A_FSG_50_0_0_30_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_50_0_0_30_ID,getValueSize(A_FSG_50_0_0_30));
        }
        A_FSG_50_0_0_30Status_BTN_already_pressed = 0;
    }
}
A_FSG_50_0_0_30_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[401];
    byte stringValue[401];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_30_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_30_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_30_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_30);
        getValue(A_FSG_50_0_0_30,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_30_Start);
     elementsVal = getValue(A_FSG_50_0_0_30_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_30_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 30");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_30_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_30_RecAdr ) || 2 == getValue( A_FSG_50_0_0_30_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_30_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_30_RecAdr ) || 1 == getValue( A_FSG_50_0_0_30_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_30_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_30_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 97-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_30_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 97-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_30_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 97-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_30_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 97-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_30_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_30_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 30");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_30_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_30_RecAdr ) || 2 == getValue( A_FSG_50_0_0_30_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_30_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_30_RecAdr ) || 1 == getValue( A_FSG_50_0_0_30_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_30_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_30_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 97-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_30_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 97-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_30_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 97-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_30_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 97-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_30_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_50_0_0_30_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_50_0_0_30
{
    byte temp[401];
    getValue(A_FSG_50_0_0_30, temp);
    putValue(A_FSG_50_0_0_30_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_30_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_30_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_30_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_30_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_50_0_0_30_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_50_0_0_30_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_30_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_30_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_30_IndexSize))
    {
        putValue(A_FSG_50_0_0_30_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_50_0_0_30_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_50_0_0_30_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_50_0_0_30_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_50_0_0_30_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_30_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_30_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_30_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_30_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_30_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_30_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_30_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_30_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_30_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_30_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_30_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_30_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_30_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_50_0_0_30, head, headLength); 
}

on envVar A_FSG_50_0_0_30_RecAdr
{
    A_FSG_50_0_0_30_GenerateStatus();
}

on envVar A_FSG_50_0_0_30_Shift
{
    A_FSG_50_0_0_30_GenerateStatus();
}

on envVar A_FSG_50_0_0_30_Direction
{
    A_FSG_50_0_0_30_GenerateStatus();
}

on envVar A_FSG_50_0_0_30_Start
{
    A_FSG_50_0_0_30_GenerateStatus();
}

on envVar A_FSG_50_0_0_30_Elements
{
    A_FSG_50_0_0_30_GenerateStatus();
}

on envVar A_FSG_50_0_0_30_IndexSize
{
    A_FSG_50_0_0_30_GenerateStatus();
}
on envVar A_FSG_50_0_0_30_TransPos
{
    A_FSG_50_0_0_30_GenerateStatus();
}
A_FSG_50_0_0_30_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_30_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_30_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_30_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_30_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_30_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_30_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_30_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_30_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_30_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_30_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_30_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_50_0_0_30_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_30_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_30_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_50_0_0_30_Changed, head, 3); 
    }
}

on envVar A_FSG_50_0_0_30_Changed_RecAdr
{
    A_FSG_50_0_0_30_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_30_Changed_Shift
{
    A_FSG_50_0_0_30_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_30_Changed_Direction
{
    A_FSG_50_0_0_30_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_30_Changed_Start
{
    A_FSG_50_0_0_30_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_30_Changed_Elements
{
    A_FSG_50_0_0_30_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_30_Changed_IndexSize
{
    A_FSG_50_0_0_30_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_30_Changed_TransPos
{
    A_FSG_50_0_0_30_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_30_SetGet
{
    byte temp[401];
    getValue(A_FSG_50_0_0_30_SetGet, temp);
    putValue(A_FSG_50_0_0_30_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_30_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_30_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_30_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_30_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_30_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_30_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_30_SetGet_IndexSize))
    {
        putValue(A_FSG_50_0_0_30_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_50_0_0_30_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_50_0_0_30_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_50_0_0_30_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_50_0_0_30_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_50_0_0_30_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_50_0_0_30_ArrayDataList[i].Param1 = 0;
		A_FSG_50_0_0_30_ArrayDataList[i].Param2 = 0;
		for(j=0; j<97; j++)
			A_FSG_50_0_0_30_ArrayDataList[i].Param3[j] = 0;
		A_FSG_50_0_0_30_ArrayDataList[i].Param3_Length = 0;
		A_FSG_50_0_0_30_Data_3_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_50_0_0_30_fileSelector,gListPath);
  
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						A_FSG_50_0_0_30_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_50_0_0_30_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //POI_Type
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //POI_Type
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Description
								if(paramPos < 96)
								{
									A_FSG_50_0_0_30_ArrayDataList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_30_ArrayDataList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_50_0_0_30_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_50_0_0_30_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_30_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_50_0_0_30_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_50_0_0_30_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			//writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_50_0_0_30_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_50_0_0_30_Data_1, A_FSG_50_0_0_30_ArrayDataList[ getValue( A_FSG_50_0_0_30_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_30_Data_2, A_FSG_50_0_0_30_ArrayDataList[ getValue( A_FSG_50_0_0_30_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_30_Data_3, A_FSG_50_0_0_30_ArrayDataList[ getValue( A_FSG_50_0_0_30_DataIndex) ].Param3, A_FSG_50_0_0_30_ArrayDataList[getValue(A_FSG_50_0_0_30_DataIndex)].Param3_Length);
}


on envVar A_FSG_50_0_0_30_generateData_Btn
{
	word i;
	dword elementsArray[4] = {1, 1, 97, 2};
	byte elementsTypeArray[4] = {0, 0, 0xE, 0xF};
	dword elementsMaxSizeArray[4] = {255, 0xFF, 0, 0};
	byte tempArray[25654];
	if (A_FSG_50_0_0_30_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_30_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 30, 254 );
		for(i = 0; i < 254; i++)
		{
			memcpy(A_FSG_50_0_0_30_ArrayDataList[i], tempArray, (i * 101) );
			if(A_FSG_50_0_0_30_ArrayDataList[i].Param3_Length > 127 )
				A_FSG_50_0_0_30_Data_3_CntList[i] = 1;
		}
		A_FSG_50_0_0_30_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_50_0_0_30_Data_1, A_FSG_50_0_0_30_ArrayDataList[ getValue( A_FSG_50_0_0_30_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_30_Data_2, A_FSG_50_0_0_30_ArrayDataList[ getValue( A_FSG_50_0_0_30_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_30_Data_3, A_FSG_50_0_0_30_ArrayDataList[ getValue( A_FSG_50_0_0_30_DataIndex) ].Param3, A_FSG_50_0_0_30_ArrayDataList[getValue(A_FSG_50_0_0_30_DataIndex)].Param3_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_50_0_0_30_DataIndex
{
    long index;
    long maxIndex = 254-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_50_0_0_30_Data_1, A_FSG_50_0_0_30_ArrayDataList[index].Param1);
    putValue(A_FSG_50_0_0_30_Data_2, A_FSG_50_0_0_30_ArrayDataList[index].Param2);
    putValue(A_FSG_50_0_0_30_Data_3_len, A_FSG_50_0_0_30_Data_3_LenList[index]);
    putValue(A_FSG_50_0_0_30_Data_3_cnt, A_FSG_50_0_0_30_Data_3_CntList[index]);
    putValue(A_FSG_50_0_0_30_Data_3, A_FSG_50_0_0_30_ArrayDataList[index].Param3, A_FSG_50_0_0_30_ArrayDataList[index].Param3_Length);

}
on envVar A_FSG_50_0_0_30_DataIndex_Incr
{
    long index;
    if(A_FSG_50_0_0_30_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_50_0_0_30_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_30_DataIndex);
        index++;
        putValue(A_FSG_50_0_0_30_DataIndex, index);
        A_FSG_50_0_0_30_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_30_DataIndex_Decr
{
    long index;
    if(A_FSG_50_0_0_30_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_50_0_0_30_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_30_DataIndex);
        index--;
        putValue(A_FSG_50_0_0_30_DataIndex, index);
        A_FSG_50_0_0_30_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_30_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_50_0_0_30_ID;
    data[2]=getValue(A_FSG_50_0_0_30_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_50_0_0_30
on envVar A_FSG_50_0_0_30_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_30",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_30",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_30",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_30_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_30", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_30",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_30",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_30",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_30_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_30", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_30_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_30_SegmEn,0);
           intertelegram_err(A_FSG_50_0_0_30_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_50_0_0_30_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_30_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_30_IntTlgEn,0);
           sequence_err(A_FSG_50_0_0_30_ID,getValueSize(A_FSG_50_0_0_30_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_50_0_0_30_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_50_0_0_30_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_50_0_0_30_Status",1);
 	}
}



A_FSG_50_0_0_30_SetInd () { /* leere Function*/ }

A_FSG_50_0_0_30_SetGetInd () { /* leere Function*/ }

A_FSG_50_0_0_30_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[401];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_30_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_30_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_50_0_0_30_SetGet, head, 5);
                if(getValue(A_FSG_50_0_0_30_AT))
                {
                    putValue(A_FSG_50_0_0_30,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_50_0_0_30_SetGet, head, 3);
            if(getValue(A_FSG_50_0_0_30_AT))
            {
                putValue(A_FSG_50_0_0_30,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_50_0_0_30_AT))
        {
            putValue(A_FSG_50_0_0_30_RecAdr,recordAddressVal);
            putValue(A_FSG_50_0_0_30_Start, startVal);
            putValue(A_FSG_50_0_0_30_Elements, elementsVal);
            putValue(A_FSG_50_0_0_30_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_50_0_0_30_1
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_30_2_range // FavoriteDest_List.TAID 
{
	@A_FSG_50_0_0_30_2 = @A_FSG_50_0_0_30_2_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_30_2
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_30_2, 1.0);
	@A_FSG_50_0_0_30_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_30_3_range // FavoriteDest_List.TotalNumListElements 
{
	@A_FSG_50_0_0_30_3 = @A_FSG_50_0_0_30_3_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_30_3
{

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_30_3, 1.0);
	@A_FSG_50_0_0_30_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_30_Data_1_range // FavoriteDest_List.Pos 
{
	@A_FSG_50_0_0_30_Data_1 = @A_FSG_50_0_0_30_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_30_Data_1
{

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_30_Data_1, 1.0);
	@A_FSG_50_0_0_30_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_30_ArrayDataList[getValue(A_FSG_50_0_0_30_DataIndex)].Param1 = thisval;
}
on envVar A_FSG_50_0_0_30_Data_2
{

	//Update Childvalue (Enum)
	byte thisval; // POI_Type
	thisval = getValue(this);
    A_FSG_50_0_0_30_ArrayDataList[getValue(A_FSG_50_0_0_30_DataIndex)].Param2 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_30_Data_3_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_30_Data_3_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_30_Data_3_CntList[ getValue(A_FSG_50_0_0_30_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_30_Data_3_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_30_Data_3_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_30_Data_3_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 96 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_30_Data_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 96);
		thisval = 96;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_30_Data_3_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_30_ArrayDataList[getValue(A_FSG_50_0_0_30_DataIndex)].Param3_Length = thisval;
	A_FSG_50_0_0_30_Data_3_LenList[ getValue(A_FSG_50_0_0_30_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_30_Data_3_len, thisval);

}

on envVar A_FSG_50_0_0_30_Data_3
{

	//Update Childvalue (String)
	word i;
	byte thisval[97];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_30_ArrayDataList[getValue(A_FSG_50_0_0_30_DataIndex)].Param3[i] = thisval[i];
    A_FSG_50_0_0_30_ArrayDataList[getValue(A_FSG_50_0_0_30_DataIndex)].Param3_Length = getValueSize(this);
    A_FSG_50_0_0_30_Data_3_LenList[getValue(A_FSG_50_0_0_30_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_30_Data_3_len, getValueSize(this));
}
on envVar A_FSG_50_0_0_30_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_30_2_SetGet_range // FavoriteDest_List.TAID 
{
	@A_FSG_50_0_0_30_2_SetGet = @A_FSG_50_0_0_30_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_30_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_30_2_SetGet, 1.0);
	@A_FSG_50_0_0_30_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_31_ErrCode
{
       if(gP_FSG_50_0_0_31_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_31", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_31_ErrCode = 1;
}
on envVar P_FSG_50_0_0_31Status_BTN
{
    if (P_FSG_50_0_0_31Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_50_0_0_31_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_31",MakeRGB(255,255,255));
       P_FSG_50_0_0_31Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_50_0_0_31_ID, Data_REQ, getValue(P_FSG_50_0_0_31));
      P_FSG_50_0_0_31Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_31_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_31_ID;
    data[2]=getValue(P_FSG_50_0_0_31_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_31
on envVar P_FSG_50_0_0_31_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_31",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_31",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_31",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_31", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_31",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_31",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_31",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_31", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_31 // bus value of PreferredDest_List (31).
{
	// opcodes: Error-Status
	byte param1; // ListType
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_50_0_0_31);
	putValue(P_FSG_50_0_0_31_1, param1);
}

on envVar P_FSG_50_0_0_31_1 // PreferredDest_List.ListType
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // ListType
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_50_0_0_31);
	superval = thisval;
	putValue(P_FSG_50_0_0_31,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_50_0_0_32_ErrCode
{
       if(gA_FSG_50_0_0_32_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_32", MakeRGB(255,255,255));
       }
       gA_FSG_50_0_0_32_ErrCode = 1;
}
on envVar A_FSG_50_0_0_32Changed_BTN
{
    byte data[504]; 
    byte stringValue[504];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_50_0_0_32Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_32_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_32",MakeRGB(255,255,255));
        A_FSG_50_0_0_32Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_32_Changed);
        getValue(A_FSG_50_0_0_32_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_32_Changed_Start);
     elementsVal = getValue(A_FSG_50_0_0_32_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_32_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 32");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_32_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_32_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 32");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_50_0_0_32_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_50_0_0_32_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_50_0_0_32_ID);
       }
       if(getValue(A_FSG_50_0_0_32_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_50_0_0_32_ID,getValueSize(A_FSG_50_0_0_32_Changed));
       }
        A_FSG_50_0_0_32Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_32Status_BTN
{
    byte data[504 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[504];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_50_0_0_32Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_32_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_32",MakeRGB(255,255,255));
        A_FSG_50_0_0_32Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_32_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_32_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_32_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_32);
        getValue(A_FSG_50_0_0_32,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_32_Start);
     elementsVal = getValue(A_FSG_50_0_0_32_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_32_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 32");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_32_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LastName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_32_RecAdr ) || 1 == getValue( A_FSG_50_0_0_32_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_32_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_32_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_32_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FirstName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_32_RecAdr ) || 2 == getValue( A_FSG_50_0_0_32_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_32_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_32_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_32_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_32_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_32_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 32");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_32_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LastName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_32_RecAdr ) || 1 == getValue( A_FSG_50_0_0_32_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_32_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_32_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_32_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FirstName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_32_RecAdr ) || 2 == getValue( A_FSG_50_0_0_32_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_32_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_32_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_32_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_50_0_0_32, data);
        Request_ByteSequence(LSGID, A_FSG_50_0_0_32_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_50_0_0_32_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_50_0_0_32_ID);
        }
        if(getValue(A_FSG_50_0_0_32_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_50_0_0_32_ID,getValueSize(A_FSG_50_0_0_32));
        }
        A_FSG_50_0_0_32Status_BTN_already_pressed = 0;
    }
}
A_FSG_50_0_0_32_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[504];
    byte stringValue[504];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_32_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_32_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_32_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_32);
        getValue(A_FSG_50_0_0_32,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_32_Start);
     elementsVal = getValue(A_FSG_50_0_0_32_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_32_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 32");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_32_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LastName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_32_RecAdr ) || 1 == getValue( A_FSG_50_0_0_32_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_32_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_32_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_32_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FirstName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_32_RecAdr ) || 2 == getValue( A_FSG_50_0_0_32_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_32_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_32_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_32_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_32_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_32_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 32");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_32_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LastName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_32_RecAdr ) || 1 == getValue( A_FSG_50_0_0_32_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_32_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_32_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_32_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FirstName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_32_RecAdr ) || 2 == getValue( A_FSG_50_0_0_32_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_32_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_32_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_32_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_32_ArrayDataList[i].Param3[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_50_0_0_32_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_50_0_0_32
{
    byte temp[504];
    getValue(A_FSG_50_0_0_32, temp);
    putValue(A_FSG_50_0_0_32_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_32_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_32_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_32_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_32_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_50_0_0_32_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_50_0_0_32_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_32_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_32_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_32_IndexSize))
    {
        putValue(A_FSG_50_0_0_32_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_50_0_0_32_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_50_0_0_32_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_50_0_0_32_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_50_0_0_32_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_32_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_32_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_32_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_32_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_32_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_32_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_32_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_32_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_32_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_32_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_32_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_32_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_32_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_50_0_0_32, head, headLength); 
}

on envVar A_FSG_50_0_0_32_RecAdr
{
    A_FSG_50_0_0_32_GenerateStatus();
}

on envVar A_FSG_50_0_0_32_Shift
{
    A_FSG_50_0_0_32_GenerateStatus();
}

on envVar A_FSG_50_0_0_32_Direction
{
    A_FSG_50_0_0_32_GenerateStatus();
}

on envVar A_FSG_50_0_0_32_Start
{
    A_FSG_50_0_0_32_GenerateStatus();
}

on envVar A_FSG_50_0_0_32_Elements
{
    A_FSG_50_0_0_32_GenerateStatus();
}

on envVar A_FSG_50_0_0_32_IndexSize
{
    A_FSG_50_0_0_32_GenerateStatus();
}
on envVar A_FSG_50_0_0_32_TransPos
{
    A_FSG_50_0_0_32_GenerateStatus();
}
A_FSG_50_0_0_32_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_32_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_32_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_32_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_32_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_32_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_32_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_32_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_32_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_32_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_32_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_32_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_50_0_0_32_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_32_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_32_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_50_0_0_32_Changed, head, 3); 
    }
}

on envVar A_FSG_50_0_0_32_Changed_RecAdr
{
    A_FSG_50_0_0_32_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_32_Changed_Shift
{
    A_FSG_50_0_0_32_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_32_Changed_Direction
{
    A_FSG_50_0_0_32_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_32_Changed_Start
{
    A_FSG_50_0_0_32_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_32_Changed_Elements
{
    A_FSG_50_0_0_32_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_32_Changed_IndexSize
{
    A_FSG_50_0_0_32_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_32_Changed_TransPos
{
    A_FSG_50_0_0_32_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_32_SetGet
{
    byte temp[504];
    getValue(A_FSG_50_0_0_32_SetGet, temp);
    putValue(A_FSG_50_0_0_32_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_32_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_32_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_32_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_32_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_32_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_32_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_32_SetGet_IndexSize))
    {
        putValue(A_FSG_50_0_0_32_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_50_0_0_32_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_50_0_0_32_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_50_0_0_32_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_50_0_0_32_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_50_0_0_32_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_50_0_0_32_ArrayDataList[i].Param1 = 0;
		for(j=0; j<61; j++)
			A_FSG_50_0_0_32_ArrayDataList[i].Param2[j] = 0;
		A_FSG_50_0_0_32_ArrayDataList[i].Param2_Length = 0;
		A_FSG_50_0_0_32_Data_2_LenList[i] = 0;
		for(j=0; j<61; j++)
			A_FSG_50_0_0_32_ArrayDataList[i].Param3[j] = 0;
		A_FSG_50_0_0_32_ArrayDataList[i].Param3_Length = 0;
		A_FSG_50_0_0_32_Data_3_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_50_0_0_32_fileSelector, gListPath);
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 65535) //ignore first line in *.csv file
					{
						A_FSG_50_0_0_32_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 65535)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //LastName
								if(paramPos < 60)
								{
									A_FSG_50_0_0_32_ArrayDataList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_32_ArrayDataList[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //FirstName
								if(paramPos < 60)
								{
									A_FSG_50_0_0_32_ArrayDataList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_32_ArrayDataList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_50_0_0_32_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_50_0_0_32_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_32_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_50_0_0_32_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_50_0_0_32_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			//writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_50_0_0_32_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_50_0_0_32_Data_1, A_FSG_50_0_0_32_ArrayDataList[ getValue( A_FSG_50_0_0_32_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_32_Data_2, A_FSG_50_0_0_32_ArrayDataList[ getValue( A_FSG_50_0_0_32_DataIndex) ].Param2, A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param2_Length);
	putValue(A_FSG_50_0_0_32_Data_3, A_FSG_50_0_0_32_ArrayDataList[ getValue( A_FSG_50_0_0_32_DataIndex) ].Param3, A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param3_Length);
}


on envVar A_FSG_50_0_0_32_generateData_Btn
{
	word i;
	dword elementsArray[5] = {2, 61, 2, 61, 2};
	byte elementsTypeArray[5] = {0, 0xE, 0xF, 0xE, 0xF};
	dword elementsMaxSizeArray[5] = {65535, 0, 0, 0, 0};
	byte tempArray[8388352];
	if (A_FSG_50_0_0_32_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_32_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 32, 65534 );
		for(i = 0; i < 65534; i++)
		{
			memcpy(A_FSG_50_0_0_32_ArrayDataList[i], tempArray, (i * 128) );
			if(A_FSG_50_0_0_32_ArrayDataList[i].Param2_Length > 127 )
				A_FSG_50_0_0_32_Data_2_CntList[i] = 1;
			if(A_FSG_50_0_0_32_ArrayDataList[i].Param3_Length > 127 )
				A_FSG_50_0_0_32_Data_3_CntList[i] = 1;
		}
		A_FSG_50_0_0_32_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_50_0_0_32_Data_1, A_FSG_50_0_0_32_ArrayDataList[ getValue( A_FSG_50_0_0_32_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_32_Data_2, A_FSG_50_0_0_32_ArrayDataList[ getValue( A_FSG_50_0_0_32_DataIndex) ].Param2, A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param2_Length);
	putValue(A_FSG_50_0_0_32_Data_3, A_FSG_50_0_0_32_ArrayDataList[ getValue( A_FSG_50_0_0_32_DataIndex) ].Param3, A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param3_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_50_0_0_32_DataIndex
{
    long index;
    long maxIndex = 65534-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_50_0_0_32_Data_1, A_FSG_50_0_0_32_ArrayDataList[index].Param1);
    putValue(A_FSG_50_0_0_32_Data_2_len, A_FSG_50_0_0_32_Data_2_LenList[index]);
    putValue(A_FSG_50_0_0_32_Data_2_cnt, A_FSG_50_0_0_32_Data_2_CntList[index]);
    putValue(A_FSG_50_0_0_32_Data_2, A_FSG_50_0_0_32_ArrayDataList[index].Param2, A_FSG_50_0_0_32_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_50_0_0_32_Data_3_len, A_FSG_50_0_0_32_Data_3_LenList[index]);
    putValue(A_FSG_50_0_0_32_Data_3_cnt, A_FSG_50_0_0_32_Data_3_CntList[index]);
    putValue(A_FSG_50_0_0_32_Data_3, A_FSG_50_0_0_32_ArrayDataList[index].Param3, A_FSG_50_0_0_32_ArrayDataList[index].Param3_Length);

}
on envVar A_FSG_50_0_0_32_DataIndex_Incr
{
    long index;
    if(A_FSG_50_0_0_32_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_50_0_0_32_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_32_DataIndex);
        index++;
        putValue(A_FSG_50_0_0_32_DataIndex, index);
        A_FSG_50_0_0_32_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_32_DataIndex_Decr
{
    long index;
    if(A_FSG_50_0_0_32_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_50_0_0_32_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_32_DataIndex);
        index--;
        putValue(A_FSG_50_0_0_32_DataIndex, index);
        A_FSG_50_0_0_32_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_32_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_50_0_0_32_ID;
    data[2]=getValue(A_FSG_50_0_0_32_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_50_0_0_32
on envVar A_FSG_50_0_0_32_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_32",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_32",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_32",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_32_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_32", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_32",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_32",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_32",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_32_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_32", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_32_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_32_SegmEn,0);
           intertelegram_err(A_FSG_50_0_0_32_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_50_0_0_32_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_32_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_32_IntTlgEn,0);
           sequence_err(A_FSG_50_0_0_32_ID,getValueSize(A_FSG_50_0_0_32_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_50_0_0_32_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_50_0_0_32_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_50_0_0_32_Status",1);
 	}
}



A_FSG_50_0_0_32_SetInd () { /* leere Function*/ }

A_FSG_50_0_0_32_SetGetInd () { /* leere Function*/ }

A_FSG_50_0_0_32_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[504];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_32_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_32_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_50_0_0_32_SetGet, head, 5);
                if(getValue(A_FSG_50_0_0_32_AT))
                {
                    putValue(A_FSG_50_0_0_32,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_50_0_0_32_SetGet, head, 3);
            if(getValue(A_FSG_50_0_0_32_AT))
            {
                putValue(A_FSG_50_0_0_32,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_50_0_0_32_AT))
        {
            putValue(A_FSG_50_0_0_32_RecAdr,recordAddressVal);
            putValue(A_FSG_50_0_0_32_Start, startVal);
            putValue(A_FSG_50_0_0_32_Elements, elementsVal);
            putValue(A_FSG_50_0_0_32_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_50_0_0_32_1
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_32_2_range // NavBook.TAID 
{
	@A_FSG_50_0_0_32_2 = @A_FSG_50_0_0_32_2_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_32_2
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_32_2, 1.0);
	@A_FSG_50_0_0_32_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_32_3_range // NavBook.TotalNumListElements 
{
	@A_FSG_50_0_0_32_3 = @A_FSG_50_0_0_32_3_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_32_3
{

	//Update Childvalue (Number)
	word thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_32_3, 1.0);
	@A_FSG_50_0_0_32_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_32_Data_1_range // NavBook.Pos 
{
	@A_FSG_50_0_0_32_Data_1 = @A_FSG_50_0_0_32_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_32_Data_1
{

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_32_Data_1, 1.0);
	@A_FSG_50_0_0_32_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_32_Data_2_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_32_Data_2_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_32_Data_2_CntList[ getValue(A_FSG_50_0_0_32_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_32_Data_2_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_32_Data_2_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_32_Data_2_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_32_Data_2_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param2_Length = thisval;
	A_FSG_50_0_0_32_Data_2_LenList[ getValue(A_FSG_50_0_0_32_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_32_Data_2_len, thisval);

}

on envVar A_FSG_50_0_0_32_Data_2
{

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param2[i] = thisval[i];
    A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param2_Length = getValueSize(this);
    A_FSG_50_0_0_32_Data_2_LenList[getValue(A_FSG_50_0_0_32_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_32_Data_2_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_32_Data_3_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_32_Data_3_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_32_Data_3_CntList[ getValue(A_FSG_50_0_0_32_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_32_Data_3_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_32_Data_3_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_32_Data_3_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_32_Data_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_32_Data_3_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param3_Length = thisval;
	A_FSG_50_0_0_32_Data_3_LenList[ getValue(A_FSG_50_0_0_32_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_32_Data_3_len, thisval);

}

on envVar A_FSG_50_0_0_32_Data_3
{

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param3[i] = thisval[i];
    A_FSG_50_0_0_32_ArrayDataList[getValue(A_FSG_50_0_0_32_DataIndex)].Param3_Length = getValueSize(this);
    A_FSG_50_0_0_32_Data_3_LenList[getValue(A_FSG_50_0_0_32_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_32_Data_3_len, getValueSize(this));
}
on envVar A_FSG_50_0_0_32_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_32_2_SetGet_range // NavBook.TAID 
{
	@A_FSG_50_0_0_32_2_SetGet = @A_FSG_50_0_0_32_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_32_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_32_2_SetGet, 1.0);
	@A_FSG_50_0_0_32_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_50_0_0_33_ErrCode
{
       if(gA_FSG_50_0_0_33_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_33", MakeRGB(255,255,255));
       }
       gA_FSG_50_0_0_33_ErrCode = 1;
}
on envVar A_FSG_50_0_0_33Changed_BTN
{
    byte data[1039]; 
    byte stringValue[1039];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_50_0_0_33Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_33_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_33",MakeRGB(255,255,255));
        A_FSG_50_0_0_33Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_33_Changed);
        getValue(A_FSG_50_0_0_33_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_33_Changed_Start);
     elementsVal = getValue(A_FSG_50_0_0_33_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_33_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 33");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_33_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_33_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 33");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_50_0_0_33_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_50_0_0_33_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_50_0_0_33_ID);
       }
       if(getValue(A_FSG_50_0_0_33_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_50_0_0_33_ID,getValueSize(A_FSG_50_0_0_33_Changed));
       }
        A_FSG_50_0_0_33Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_33Status_BTN
{
    byte data[1039 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[1039];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_50_0_0_33Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_33_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_33",MakeRGB(255,255,255));
        A_FSG_50_0_0_33Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_33_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_33_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: OtherListType
        tempValue = getValue(A_FSG_50_0_0_33_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: OtherList_Reference
        tempValue = getValue(A_FSG_50_0_0_33_4);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_33_5);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_33);
        getValue(A_FSG_50_0_0_33,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_33_Start);
     elementsVal = getValue(A_FSG_50_0_0_33_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_33_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 33");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LastName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FirstName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Street:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) || 6 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable City:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) || 6 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param5[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Region:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param6_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_6_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_6_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param6[j];
        }
       }
      // Check if the current value of RecAdr enables the variable PostalCode:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 22-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 22-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 22-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 22-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Country:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param8_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_8_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_8_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param8[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Coordinates:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param9_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_9_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_9_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param9[j];
        }
       }
      // Check if the current value of RecAdr enables the variable POI_Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 5 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param10_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_10_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_10_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param10[j];
        }
       }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 5 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param11 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Address_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param12 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_33_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_33_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 33");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LastName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FirstName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Street:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) || 6 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable City:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) || 6 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param5[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Region:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param6_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_6_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_6_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param6[j];
        }
       }
      // Check if the current value of RecAdr enables the variable PostalCode:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 22-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 22-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 22-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 22-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Country:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param8_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_8_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_8_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param8[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Coordinates:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param9_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_9_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_9_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param9[j];
        }
       }
      // Check if the current value of RecAdr enables the variable POI_Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 5 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param10_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_10_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_10_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param10[j];
        }
       }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 5 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param11 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Address_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param12 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_50_0_0_33, data);
        Request_ByteSequence(LSGID, A_FSG_50_0_0_33_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_50_0_0_33_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_50_0_0_33_ID);
        }
        if(getValue(A_FSG_50_0_0_33_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_50_0_0_33_ID,getValueSize(A_FSG_50_0_0_33));
        }
        A_FSG_50_0_0_33Status_BTN_already_pressed = 0;
    }
}
A_FSG_50_0_0_33_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[1039];
    byte stringValue[1039];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_33_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_33_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: OtherListType
        tempValue = getValue(A_FSG_50_0_0_33_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: OtherList_Reference
        tempValue = getValue(A_FSG_50_0_0_33_4);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_33_5);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_33);
        getValue(A_FSG_50_0_0_33,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_33_Start);
     elementsVal = getValue(A_FSG_50_0_0_33_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_33_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 33");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LastName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FirstName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Street:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) || 6 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable City:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) || 6 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param5[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Region:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param6_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_6_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_6_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param6[j];
        }
       }
      // Check if the current value of RecAdr enables the variable PostalCode:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 22-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 22-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 22-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 22-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Country:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param8_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_8_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_8_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param8[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Coordinates:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param9_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_9_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_9_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param9[j];
        }
       }
      // Check if the current value of RecAdr enables the variable POI_Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 5 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param10_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_10_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_10_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param10[j];
        }
       }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 5 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param11 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Address_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param12 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_33_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_33_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 33");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LastName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FirstName:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Street:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) || 6 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable City:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) || 6 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param5[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Region:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param6_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_6_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_6_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param6[j];
        }
       }
      // Check if the current value of RecAdr enables the variable PostalCode:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 22-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 22-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 22-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 22-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Country:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param8_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_8_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_8_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param8[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Coordinates:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param9_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_9_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_9_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param9[j];
        }
       }
      // Check if the current value of RecAdr enables the variable POI_Description:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 5 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_33_ArrayDataList[i].Param10_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_33_Data_10_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 61-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 61-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_33_Data_10_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 61-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 61-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_33_ArrayDataList[i].Param10[j];
        }
       }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 5 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param11 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Address_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_33_RecAdr ) || 1 == getValue( A_FSG_50_0_0_33_RecAdr ) || 3 == getValue( A_FSG_50_0_0_33_RecAdr ) || 4 == getValue( A_FSG_50_0_0_33_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_33_ArrayDataList[i].Param12 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_50_0_0_33_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_50_0_0_33
{
    byte temp[1039];
    getValue(A_FSG_50_0_0_33, temp);
    putValue(A_FSG_50_0_0_33_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_33_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_33_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_33_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_33_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_50_0_0_33_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_50_0_0_33_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_33_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_33_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_33_IndexSize))
    {
        putValue(A_FSG_50_0_0_33_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_50_0_0_33_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_50_0_0_33_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_50_0_0_33_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_50_0_0_33_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_33_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_33_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_33_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_33_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_33_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_33_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_33_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_33_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_33_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_33_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_33_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_33_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_33_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_50_0_0_33, head, headLength); 
}

on envVar A_FSG_50_0_0_33_RecAdr
{
    A_FSG_50_0_0_33_GenerateStatus();
}

on envVar A_FSG_50_0_0_33_Shift
{
    A_FSG_50_0_0_33_GenerateStatus();
}

on envVar A_FSG_50_0_0_33_Direction
{
    A_FSG_50_0_0_33_GenerateStatus();
}

on envVar A_FSG_50_0_0_33_Start
{
    A_FSG_50_0_0_33_GenerateStatus();
}

on envVar A_FSG_50_0_0_33_Elements
{
    A_FSG_50_0_0_33_GenerateStatus();
}

on envVar A_FSG_50_0_0_33_IndexSize
{
    A_FSG_50_0_0_33_GenerateStatus();
}
on envVar A_FSG_50_0_0_33_TransPos
{
    A_FSG_50_0_0_33_GenerateStatus();
}
A_FSG_50_0_0_33_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_33_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_33_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_33_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_33_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_33_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_33_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_33_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_33_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_33_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_33_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_33_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_50_0_0_33_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_33_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_33_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_50_0_0_33_Changed, head, 3); 
    }
}

on envVar A_FSG_50_0_0_33_Changed_RecAdr
{
    A_FSG_50_0_0_33_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_33_Changed_Shift
{
    A_FSG_50_0_0_33_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_33_Changed_Direction
{
    A_FSG_50_0_0_33_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_33_Changed_Start
{
    A_FSG_50_0_0_33_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_33_Changed_Elements
{
    A_FSG_50_0_0_33_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_33_Changed_IndexSize
{
    A_FSG_50_0_0_33_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_33_Changed_TransPos
{
    A_FSG_50_0_0_33_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_33_SetGet
{
    byte temp[1039];
    getValue(A_FSG_50_0_0_33_SetGet, temp);
    putValue(A_FSG_50_0_0_33_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_33_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_33_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_33_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_33_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_33_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_33_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_33_SetGet_IndexSize))
    {
        putValue(A_FSG_50_0_0_33_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_50_0_0_33_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_50_0_0_33_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_50_0_0_33_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_50_0_0_33_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp11[25];
	char temp12[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_50_0_0_33_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_50_0_0_33_ArrayDataList[i].Param1 = 0;
		for(j=0; j<61; j++)
			A_FSG_50_0_0_33_ArrayDataList[i].Param2[j] = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param2_Length = 0;
		A_FSG_50_0_0_33_Data_2_LenList[i] = 0;
		for(j=0; j<61; j++)
			A_FSG_50_0_0_33_ArrayDataList[i].Param3[j] = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param3_Length = 0;
		A_FSG_50_0_0_33_Data_3_LenList[i] = 0;
		for(j=0; j<61; j++)
			A_FSG_50_0_0_33_ArrayDataList[i].Param4[j] = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param4_Length = 0;
		A_FSG_50_0_0_33_Data_4_LenList[i] = 0;
		for(j=0; j<61; j++)
			A_FSG_50_0_0_33_ArrayDataList[i].Param5[j] = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param5_Length = 0;
		A_FSG_50_0_0_33_Data_5_LenList[i] = 0;
		for(j=0; j<61; j++)
			A_FSG_50_0_0_33_ArrayDataList[i].Param6[j] = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param6_Length = 0;
		A_FSG_50_0_0_33_Data_6_LenList[i] = 0;
		for(j=0; j<22; j++)
			A_FSG_50_0_0_33_ArrayDataList[i].Param7[j] = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param7_Length = 0;
		A_FSG_50_0_0_33_Data_7_LenList[i] = 0;
		for(j=0; j<61; j++)
			A_FSG_50_0_0_33_ArrayDataList[i].Param8[j] = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param8_Length = 0;
		A_FSG_50_0_0_33_Data_8_LenList[i] = 0;
		for(j=0; j<61; j++)
			A_FSG_50_0_0_33_ArrayDataList[i].Param9[j] = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param9_Length = 0;
		A_FSG_50_0_0_33_Data_9_LenList[i] = 0;
		for(j=0; j<61; j++)
			A_FSG_50_0_0_33_ArrayDataList[i].Param10[j] = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param10_Length = 0;
		A_FSG_50_0_0_33_Data_10_LenList[i] = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param11 = 0;
		A_FSG_50_0_0_33_ArrayDataList[i].Param12 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_50_0_0_33_fileSelector,gListPath);
  
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 65535) //ignore first line in *.csv file
					{
						A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param11 = atol(temp11); //POI_Type
						A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param12 = atol(temp12); //Address_Type
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp11[i]=0;
							temp12[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 65535)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //LastName
								if(paramPos < 60)
								{
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //FirstName
								if(paramPos < 60)
								{
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 4: //Street
								if(paramPos < 60)
								{
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 5: //City
								if(paramPos < 60)
								{
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 6: //Region
								if(paramPos < 60)
								{
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 7: //PostalCode
								if(paramPos < 21)
								{
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param7_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 8: //Country
								if(paramPos < 60)
								{
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param8_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 9: //Coordinates
								if(paramPos < 60)
								{
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param9[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param9_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 10: //POI_Description
								if(paramPos < 60)
								{
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param10[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_33_ArrayDataList[current_CSV_line-1].Param10_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 11: //POI_Type
								if( paramPos >= elCount(temp11) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp11[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 12: //Address_Type
								if( paramPos >= elCount(temp12) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp12[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_50_0_0_33_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_50_0_0_33_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_33_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_50_0_0_33_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_50_0_0_33_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_50_0_0_33_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_50_0_0_33_Data_1, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_33_Data_2, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param2, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param2_Length);
	putValue(A_FSG_50_0_0_33_Data_3, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param3, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param3_Length);
	putValue(A_FSG_50_0_0_33_Data_4, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param4, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param4_Length);
	putValue(A_FSG_50_0_0_33_Data_5, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param5, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param5_Length);
	putValue(A_FSG_50_0_0_33_Data_6, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param6, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param6_Length);
	putValue(A_FSG_50_0_0_33_Data_7, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param7, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param7_Length);
	putValue(A_FSG_50_0_0_33_Data_8, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param8, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param8_Length);
	putValue(A_FSG_50_0_0_33_Data_9, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param9, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param9_Length);
	putValue(A_FSG_50_0_0_33_Data_10, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param10, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param10_Length);
	putValue(A_FSG_50_0_0_33_Data_11, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param11);
	putValue(A_FSG_50_0_0_33_Data_12, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param12);
}


on envVar A_FSG_50_0_0_33_generateData_Btn
{
	word i;
	dword elementsArray[21] = {2, 61, 2, 61, 2, 61, 2, 61, 2, 61, 2, 22, 2, 61, 2, 61, 2, 61, 2, 1, 1};
	byte elementsTypeArray[21] = {0, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0, 0};
	dword elementsMaxSizeArray[21] = {65535, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF};
	byte tempArray[34864088];
	if (A_FSG_50_0_0_33_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_33_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 33, 65534 );
		for(i = 0; i < 65534; i++)
		{
			memcpy(A_FSG_50_0_0_33_ArrayDataList[i], tempArray, (i * 532) );
			if(A_FSG_50_0_0_33_ArrayDataList[i].Param2_Length > 127 )
				A_FSG_50_0_0_33_Data_2_CntList[i] = 1;
			if(A_FSG_50_0_0_33_ArrayDataList[i].Param3_Length > 127 )
				A_FSG_50_0_0_33_Data_3_CntList[i] = 1;
			if(A_FSG_50_0_0_33_ArrayDataList[i].Param4_Length > 127 )
				A_FSG_50_0_0_33_Data_4_CntList[i] = 1;
			if(A_FSG_50_0_0_33_ArrayDataList[i].Param5_Length > 127 )
				A_FSG_50_0_0_33_Data_5_CntList[i] = 1;
			if(A_FSG_50_0_0_33_ArrayDataList[i].Param6_Length > 127 )
				A_FSG_50_0_0_33_Data_6_CntList[i] = 1;
			if(A_FSG_50_0_0_33_ArrayDataList[i].Param7_Length > 127 )
				A_FSG_50_0_0_33_Data_7_CntList[i] = 1;
			if(A_FSG_50_0_0_33_ArrayDataList[i].Param8_Length > 127 )
				A_FSG_50_0_0_33_Data_8_CntList[i] = 1;
			if(A_FSG_50_0_0_33_ArrayDataList[i].Param9_Length > 127 )
				A_FSG_50_0_0_33_Data_9_CntList[i] = 1;
			if(A_FSG_50_0_0_33_ArrayDataList[i].Param10_Length > 127 )
				A_FSG_50_0_0_33_Data_10_CntList[i] = 1;
		}
		A_FSG_50_0_0_33_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_50_0_0_33_Data_1, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_33_Data_2, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param2, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param2_Length);
	putValue(A_FSG_50_0_0_33_Data_3, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param3, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param3_Length);
	putValue(A_FSG_50_0_0_33_Data_4, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param4, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param4_Length);
	putValue(A_FSG_50_0_0_33_Data_5, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param5, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param5_Length);
	putValue(A_FSG_50_0_0_33_Data_6, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param6, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param6_Length);
	putValue(A_FSG_50_0_0_33_Data_7, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param7, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param7_Length);
	putValue(A_FSG_50_0_0_33_Data_8, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param8, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param8_Length);
	putValue(A_FSG_50_0_0_33_Data_9, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param9, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param9_Length);
	putValue(A_FSG_50_0_0_33_Data_10, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param10, A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param10_Length);
	putValue(A_FSG_50_0_0_33_Data_11, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param11);
	putValue(A_FSG_50_0_0_33_Data_12, A_FSG_50_0_0_33_ArrayDataList[ getValue( A_FSG_50_0_0_33_DataIndex) ].Param12);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_50_0_0_33_DataIndex
{
    long index;
    long maxIndex = 65534-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_50_0_0_33_Data_1, A_FSG_50_0_0_33_ArrayDataList[index].Param1);
    putValue(A_FSG_50_0_0_33_Data_2_len, A_FSG_50_0_0_33_Data_2_LenList[index]);
    putValue(A_FSG_50_0_0_33_Data_2_cnt, A_FSG_50_0_0_33_Data_2_CntList[index]);
    putValue(A_FSG_50_0_0_33_Data_2, A_FSG_50_0_0_33_ArrayDataList[index].Param2, A_FSG_50_0_0_33_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_50_0_0_33_Data_3_len, A_FSG_50_0_0_33_Data_3_LenList[index]);
    putValue(A_FSG_50_0_0_33_Data_3_cnt, A_FSG_50_0_0_33_Data_3_CntList[index]);
    putValue(A_FSG_50_0_0_33_Data_3, A_FSG_50_0_0_33_ArrayDataList[index].Param3, A_FSG_50_0_0_33_ArrayDataList[index].Param3_Length);
    putValue(A_FSG_50_0_0_33_Data_4_len, A_FSG_50_0_0_33_Data_4_LenList[index]);
    putValue(A_FSG_50_0_0_33_Data_4_cnt, A_FSG_50_0_0_33_Data_4_CntList[index]);
    putValue(A_FSG_50_0_0_33_Data_4, A_FSG_50_0_0_33_ArrayDataList[index].Param4, A_FSG_50_0_0_33_ArrayDataList[index].Param4_Length);
    putValue(A_FSG_50_0_0_33_Data_5_len, A_FSG_50_0_0_33_Data_5_LenList[index]);
    putValue(A_FSG_50_0_0_33_Data_5_cnt, A_FSG_50_0_0_33_Data_5_CntList[index]);
    putValue(A_FSG_50_0_0_33_Data_5, A_FSG_50_0_0_33_ArrayDataList[index].Param5, A_FSG_50_0_0_33_ArrayDataList[index].Param5_Length);
    putValue(A_FSG_50_0_0_33_Data_6_len, A_FSG_50_0_0_33_Data_6_LenList[index]);
    putValue(A_FSG_50_0_0_33_Data_6_cnt, A_FSG_50_0_0_33_Data_6_CntList[index]);
    putValue(A_FSG_50_0_0_33_Data_6, A_FSG_50_0_0_33_ArrayDataList[index].Param6, A_FSG_50_0_0_33_ArrayDataList[index].Param6_Length);
    putValue(A_FSG_50_0_0_33_Data_7_len, A_FSG_50_0_0_33_Data_7_LenList[index]);
    putValue(A_FSG_50_0_0_33_Data_7_cnt, A_FSG_50_0_0_33_Data_7_CntList[index]);
    putValue(A_FSG_50_0_0_33_Data_7, A_FSG_50_0_0_33_ArrayDataList[index].Param7, A_FSG_50_0_0_33_ArrayDataList[index].Param7_Length);
    putValue(A_FSG_50_0_0_33_Data_8_len, A_FSG_50_0_0_33_Data_8_LenList[index]);
    putValue(A_FSG_50_0_0_33_Data_8_cnt, A_FSG_50_0_0_33_Data_8_CntList[index]);
    putValue(A_FSG_50_0_0_33_Data_8, A_FSG_50_0_0_33_ArrayDataList[index].Param8, A_FSG_50_0_0_33_ArrayDataList[index].Param8_Length);
    putValue(A_FSG_50_0_0_33_Data_9_len, A_FSG_50_0_0_33_Data_9_LenList[index]);
    putValue(A_FSG_50_0_0_33_Data_9_cnt, A_FSG_50_0_0_33_Data_9_CntList[index]);
    putValue(A_FSG_50_0_0_33_Data_9, A_FSG_50_0_0_33_ArrayDataList[index].Param9, A_FSG_50_0_0_33_ArrayDataList[index].Param9_Length);
    putValue(A_FSG_50_0_0_33_Data_10_len, A_FSG_50_0_0_33_Data_10_LenList[index]);
    putValue(A_FSG_50_0_0_33_Data_10_cnt, A_FSG_50_0_0_33_Data_10_CntList[index]);
    putValue(A_FSG_50_0_0_33_Data_10, A_FSG_50_0_0_33_ArrayDataList[index].Param10, A_FSG_50_0_0_33_ArrayDataList[index].Param10_Length);
    putValue(A_FSG_50_0_0_33_Data_11, A_FSG_50_0_0_33_ArrayDataList[index].Param11);
    putValue(A_FSG_50_0_0_33_Data_12, A_FSG_50_0_0_33_ArrayDataList[index].Param12);

}
on envVar A_FSG_50_0_0_33_DataIndex_Incr
{
    long index;
    if(A_FSG_50_0_0_33_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_50_0_0_33_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_33_DataIndex);
        index++;
        putValue(A_FSG_50_0_0_33_DataIndex, index);
        A_FSG_50_0_0_33_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_33_DataIndex_Decr
{
    long index;
    if(A_FSG_50_0_0_33_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_50_0_0_33_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_33_DataIndex);
        index--;
        putValue(A_FSG_50_0_0_33_DataIndex, index);
        A_FSG_50_0_0_33_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_33_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_50_0_0_33_ID;
    data[2]=getValue(A_FSG_50_0_0_33_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_50_0_0_33
on envVar A_FSG_50_0_0_33_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_33",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_33",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_33",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_33_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_33", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_33",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_33",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_33",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_33_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_33", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_33_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_33_SegmEn,0);
           intertelegram_err(A_FSG_50_0_0_33_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_50_0_0_33_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_33_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_33_IntTlgEn,0);
           sequence_err(A_FSG_50_0_0_33_ID,getValueSize(A_FSG_50_0_0_33_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_50_0_0_33_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_50_0_0_33_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_50_0_0_33_Status",1);
 	}
}



A_FSG_50_0_0_33_SetInd () { /* leere Function*/ }

A_FSG_50_0_0_33_SetGetInd () { /* leere Function*/ }

A_FSG_50_0_0_33_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[1039];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_33_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_33_2_SetGet, tempValue);
    //Einzelparameter: OtherListType
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_FSG_50_0_0_33_3_SetGet, tempValue);
    //Einzelparameter: OtherList_Reference
    //voriger Parameter war ein first nibble, bei 2 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue =  (gBAP_Indication_data[currentPos++] & 0xFF);
    tempValue += (gBAP_Indication_data[currentPos++] & 0xFF) << 8;
    putValue(A_FSG_50_0_0_33_4_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_50_0_0_33_SetGet, head, 5);
                if(getValue(A_FSG_50_0_0_33_AT))
                {
                    putValue(A_FSG_50_0_0_33,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_50_0_0_33_SetGet, head, 3);
            if(getValue(A_FSG_50_0_0_33_AT))
            {
                putValue(A_FSG_50_0_0_33,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_50_0_0_33_AT))
        {
            putValue(A_FSG_50_0_0_33_RecAdr,recordAddressVal);
            putValue(A_FSG_50_0_0_33_Start, startVal);
            putValue(A_FSG_50_0_0_33_Elements, elementsVal);
            putValue(A_FSG_50_0_0_33_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_50_0_0_33_1
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_33_2_range // Address_List.TAID 
{
	@A_FSG_50_0_0_33_2 = @A_FSG_50_0_0_33_2_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_33_2
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_33_2, 1.0);
	@A_FSG_50_0_0_33_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_FSG_50_0_0_33_3
{

	//Update Childvalue (Enum)
	byte thisval; // OtherListType
	thisval = getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_33_4_range // Address_List.OtherList_Reference 
{
	@A_FSG_50_0_0_33_4 = @A_FSG_50_0_0_33_4_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_33_4
{

	//Update Childvalue (Number)
	word thisval; // OtherList_Reference
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_33_4, 1.0);
	@A_FSG_50_0_0_33_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_33_5_range // Address_List.TotalNumListElements 
{
	@A_FSG_50_0_0_33_5 = @A_FSG_50_0_0_33_5_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_33_5
{

	//Update Childvalue (Number)
	word thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_33_5, 1.0);
	@A_FSG_50_0_0_33_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_33_Data_1_range // Address_List.Pos 
{
	@A_FSG_50_0_0_33_Data_1 = @A_FSG_50_0_0_33_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_33_Data_1
{

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_33_Data_1, 1.0);
	@A_FSG_50_0_0_33_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_33_Data_2_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_33_Data_2_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_33_Data_2_CntList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_33_Data_2_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_33_Data_2_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_33_Data_2_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_33_Data_2_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param2_Length = thisval;
	A_FSG_50_0_0_33_Data_2_LenList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_33_Data_2_len, thisval);

}

on envVar A_FSG_50_0_0_33_Data_2
{

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param2[i] = thisval[i];
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param2_Length = getValueSize(this);
    A_FSG_50_0_0_33_Data_2_LenList[getValue(A_FSG_50_0_0_33_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_33_Data_2_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_33_Data_3_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_33_Data_3_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_33_Data_3_CntList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_33_Data_3_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_33_Data_3_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_33_Data_3_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_33_Data_3_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param3_Length = thisval;
	A_FSG_50_0_0_33_Data_3_LenList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_33_Data_3_len, thisval);

}

on envVar A_FSG_50_0_0_33_Data_3
{

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param3[i] = thisval[i];
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param3_Length = getValueSize(this);
    A_FSG_50_0_0_33_Data_3_LenList[getValue(A_FSG_50_0_0_33_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_33_Data_3_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_33_Data_4_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_33_Data_4_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_33_Data_4_CntList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_33_Data_4_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_33_Data_4_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_33_Data_4_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_33_Data_4_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param4_Length = thisval;
	A_FSG_50_0_0_33_Data_4_LenList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_33_Data_4_len, thisval);

}

on envVar A_FSG_50_0_0_33_Data_4
{

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param4[i] = thisval[i];
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param4_Length = getValueSize(this);
    A_FSG_50_0_0_33_Data_4_LenList[getValue(A_FSG_50_0_0_33_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_33_Data_4_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_33_Data_5_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_33_Data_5_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_33_Data_5_CntList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_33_Data_5_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_33_Data_5_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_33_Data_5_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_33_Data_5_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param5_Length = thisval;
	A_FSG_50_0_0_33_Data_5_LenList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_33_Data_5_len, thisval);

}

on envVar A_FSG_50_0_0_33_Data_5
{

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param5[i] = thisval[i];
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param5_Length = getValueSize(this);
    A_FSG_50_0_0_33_Data_5_LenList[getValue(A_FSG_50_0_0_33_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_33_Data_5_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_33_Data_6_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_33_Data_6_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_33_Data_6_CntList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_33_Data_6_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_33_Data_6_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_33_Data_6_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_33_Data_6_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param6_Length = thisval;
	A_FSG_50_0_0_33_Data_6_LenList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_33_Data_6_len, thisval);

}

on envVar A_FSG_50_0_0_33_Data_6
{

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param6[i] = thisval[i];
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param6_Length = getValueSize(this);
    A_FSG_50_0_0_33_Data_6_LenList[getValue(A_FSG_50_0_0_33_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_33_Data_6_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_33_Data_7_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_33_Data_7_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_33_Data_7_CntList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_33_Data_7_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_33_Data_7_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_33_Data_7_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 21 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 21);
		thisval = 21;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_33_Data_7_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param7_Length = thisval;
	A_FSG_50_0_0_33_Data_7_LenList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_33_Data_7_len, thisval);

}

on envVar A_FSG_50_0_0_33_Data_7
{

	//Update Childvalue (String)
	word i;
	byte thisval[22];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param7[i] = thisval[i];
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param7_Length = getValueSize(this);
    A_FSG_50_0_0_33_Data_7_LenList[getValue(A_FSG_50_0_0_33_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_33_Data_7_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_33_Data_8_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_33_Data_8_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_33_Data_8_CntList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_33_Data_8_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_33_Data_8_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_33_Data_8_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_8 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_33_Data_8_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param8_Length = thisval;
	A_FSG_50_0_0_33_Data_8_LenList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_33_Data_8_len, thisval);

}

on envVar A_FSG_50_0_0_33_Data_8
{

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param8[i] = thisval[i];
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param8_Length = getValueSize(this);
    A_FSG_50_0_0_33_Data_8_LenList[getValue(A_FSG_50_0_0_33_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_33_Data_8_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_33_Data_9_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_33_Data_9_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_33_Data_9_CntList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_33_Data_9_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_33_Data_9_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_33_Data_9_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_9 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_33_Data_9_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param9_Length = thisval;
	A_FSG_50_0_0_33_Data_9_LenList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_33_Data_9_len, thisval);

}

on envVar A_FSG_50_0_0_33_Data_9
{

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param9[i] = thisval[i];
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param9_Length = getValueSize(this);
    A_FSG_50_0_0_33_Data_9_LenList[getValue(A_FSG_50_0_0_33_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_33_Data_9_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_33_Data_10_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_33_Data_10_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_33_Data_10_CntList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_33_Data_10_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_33_Data_10_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_33_Data_10_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_33_Data_10 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_33_Data_10_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param10_Length = thisval;
	A_FSG_50_0_0_33_Data_10_LenList[ getValue(A_FSG_50_0_0_33_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_33_Data_10_len, thisval);

}

on envVar A_FSG_50_0_0_33_Data_10
{

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param10[i] = thisval[i];
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param10_Length = getValueSize(this);
    A_FSG_50_0_0_33_Data_10_LenList[getValue(A_FSG_50_0_0_33_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_33_Data_10_len, getValueSize(this));
}
on envVar A_FSG_50_0_0_33_Data_11
{

	//Update Childvalue (Enum)
	byte thisval; // POI_Type
	thisval = getValue(this);
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param11 = thisval;
}
on envVar A_FSG_50_0_0_33_Data_12
{

	//Update Childvalue (Enum)
	byte thisval; // Address_Type
	thisval = getValue(this);
    A_FSG_50_0_0_33_ArrayDataList[getValue(A_FSG_50_0_0_33_DataIndex)].Param12 = thisval;
}
on envVar A_FSG_50_0_0_33_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_33_2_SetGet_range // Address_List.TAID 
{
	@A_FSG_50_0_0_33_2_SetGet = @A_FSG_50_0_0_33_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_33_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_33_2_SetGet, 1.0);
	@A_FSG_50_0_0_33_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_FSG_50_0_0_33_3_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // OtherListType
	thisval = getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_33_4_SetGet_range // Address_List.OtherList_Reference 
{
	@A_FSG_50_0_0_33_4_SetGet = @A_FSG_50_0_0_33_4_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_33_4_SetGet
{

	//Update Childvalue (Number)
	word thisval; // OtherList_Reference
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_33_4_SetGet, 1.0);
	@A_FSG_50_0_0_33_4_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_50_0_0_34_ErrCode
{
       if(gM_FSG_50_0_0_34_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_34", MakeRGB(255,255,255));
       }
       gM_FSG_50_0_0_34_ErrCode = 1;
}
on envVar M_FSG_50_0_0_34Result_BTN
{
  if (M_FSG_50_0_0_34Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_50_0_0_34_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_50_0_0_34",MakeRGB(255,255,255));
     M_FSG_50_0_0_34Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_50_0_0_34_State, "Result");
     Request_Int8(LSGID, M_FSG_50_0_0_34_ID, Result_REQ, getValue(M_FSG_50_0_0_34_Result));
     M_FSG_50_0_0_34Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_50_0_0_34_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_50_0_0_34_ID;
    data[2]=getValue(M_FSG_50_0_0_34_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_50_0_0_34
on envVar M_FSG_50_0_0_34_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_34",1);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_34",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_34",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_34", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_34",0);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_34",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_34",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_34_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_34", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_50_0_0_34_Result // bus value of RG_ActDeact (34).
{
	// opcodes: Error-Processing-Result
	byte param1; // RG_ActDeact_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_50_0_0_34_Result);
	putValue(M_FSG_50_0_0_34_Result_1, param1);
}

on envVar M_FSG_50_0_0_34_Result_1 // RG_ActDeact.RG_ActDeact_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // RG_ActDeact_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_50_0_0_34_Result);
	superval = thisval;
	putValue(M_FSG_50_0_0_34_Result,superval);
}

on envVar M_FSG_50_0_0_34_Processing // bus value of RG_ActDeact (34).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_50_0_0_34_Processing);
	putValue(M_FSG_50_0_0_34_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_34_Processing_1_range // RG_ActDeact.Reserve1 
{
	@M_FSG_50_0_0_34_Processing_1 = @M_FSG_50_0_0_34_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_34_Processing_1 // RG_ActDeact.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_50_0_0_34_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_50_0_0_34_Processing);
	superval = thisval;
	putValue(M_FSG_50_0_0_34_Processing,superval);
}

on envVar M_FSG_50_0_0_34_Start // bus value of RG_ActDeact (34).
{
	// opcodes: AbortResult-StartResult
	byte param1; // ControlType
	byte param2; // CI_Type
	word param3; // ControlInformation
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[3];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_34_Start, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(M_FSG_50_0_0_34_Start_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(M_FSG_50_0_0_34_Start_2, param2);
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_50_0_0_34_Start_3, round((param3 * 1.0) - (0) + (0), 1.0));
}

on envVar M_FSG_50_0_0_34_Start_1 // RG_ActDeact.ControlType
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // ControlType
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_34_Start, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(M_FSG_50_0_0_34_Start,superval);
}

on envVar M_FSG_50_0_0_34_Start_2 // RG_ActDeact.CI_Type
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // CI_Type
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_34_Start, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(M_FSG_50_0_0_34_Start,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_34_Start_3_range // RG_ActDeact.ControlInformation 
{
	@M_FSG_50_0_0_34_Start_3 = @M_FSG_50_0_0_34_Start_3_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_34_Start_3 // RG_ActDeact.ControlInformation
{
	byte superval[3];

	//Update Childvalue (Number)
	word thisval; // ControlInformation
	float slider_value;

	slider_value = round(@M_FSG_50_0_0_34_Start_3, 1.0);
	@M_FSG_50_0_0_34_Start_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_34_Start, superval);
	superval[1]=thisval&0x00ff;
	superval[2]=(thisval&0xff00)>>8;
	putValue(M_FSG_50_0_0_34_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_50_0_0_35_ErrCode
{
       if(gM_FSG_50_0_0_35_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_35", MakeRGB(255,255,255));
       }
       gM_FSG_50_0_0_35_ErrCode = 1;
}
on envVar M_FSG_50_0_0_35Result_BTN
{
  if (M_FSG_50_0_0_35Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_50_0_0_35_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_50_0_0_35",MakeRGB(255,255,255));
     M_FSG_50_0_0_35Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_50_0_0_35_State, "Result");
     Request_Int8(LSGID, M_FSG_50_0_0_35_ID, Result_REQ, getValue(M_FSG_50_0_0_35_Result));
     M_FSG_50_0_0_35Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_50_0_0_35_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_50_0_0_35_ID;
    data[2]=getValue(M_FSG_50_0_0_35_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_50_0_0_35
on envVar M_FSG_50_0_0_35_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_35",1);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_35",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_35",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_35", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_35",0);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_35",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_35",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_35_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_35", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_50_0_0_35_Result // bus value of RepeatLastNavAnnouncement (35).
{
	// opcodes: Error-Processing-Result
	byte param1; // RepeatLNA_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_50_0_0_35_Result);
	putValue(M_FSG_50_0_0_35_Result_1, param1);
}

on envVar M_FSG_50_0_0_35_Result_1 // RepeatLastNavAnnouncement.RepeatLNA_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // RepeatLNA_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_50_0_0_35_Result);
	superval = thisval;
	putValue(M_FSG_50_0_0_35_Result,superval);
}

on envVar M_FSG_50_0_0_35_Processing // bus value of RepeatLastNavAnnouncement (35).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_50_0_0_35_Processing);
	putValue(M_FSG_50_0_0_35_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_35_Processing_1_range // RepeatLastNavAnnouncement.Reserve1 
{
	@M_FSG_50_0_0_35_Processing_1 = @M_FSG_50_0_0_35_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_35_Processing_1 // RepeatLastNavAnnouncement.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_50_0_0_35_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_50_0_0_35_Processing);
	superval = thisval;
	putValue(M_FSG_50_0_0_35_Processing,superval);
}

on envVar M_FSG_50_0_0_35_Start // bus value of RepeatLastNavAnnouncement (35).
{
	// opcodes: AbortResult-StartResult
}

on envVar M_FSG_50_0_0_35_Start_1 // RepeatLastNavAnnouncement.
{
	byte superval;

    // Update superval
	putValue(M_FSG_50_0_0_35_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_36_ErrCode
{
       if(gP_FSG_50_0_0_36_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_36", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_36_ErrCode = 1;
}
on envVar P_FSG_50_0_0_36Status_BTN
{
    if (P_FSG_50_0_0_36Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_50_0_0_36_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_36",MakeRGB(255,255,255));
       P_FSG_50_0_0_36Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_50_0_0_36_ID, Data_REQ, getValue(P_FSG_50_0_0_36));
      P_FSG_50_0_0_36Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_36_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_36_ID;
    data[2]=getValue(P_FSG_50_0_0_36_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_36
on envVar P_FSG_50_0_0_36_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_36",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_36",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_36",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_36", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_36",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_36",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_36",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_36", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_36 // bus value of VoiceGuidance (36).
{
	// opcodes: Error-Status
	byte param1; // VoiceGuidance_State
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_50_0_0_36);
	putValue(P_FSG_50_0_0_36_1, param1);
}

on envVar P_FSG_50_0_0_36_1 // VoiceGuidance.VoiceGuidance_State
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // VoiceGuidance_State
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_50_0_0_36);
	superval = thisval;
	putValue(P_FSG_50_0_0_36,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_37_ErrCode
{
       if(gP_FSG_50_0_0_37_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_37", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_37_ErrCode = 1;
}
on envVar P_FSG_50_0_0_37Status_BTN
{
	byte BAPTemp[8];
    if (P_FSG_50_0_0_37Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_37_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_37",MakeRGB(255,255,255));
        P_FSG_50_0_0_37Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_37_BuildFct();
        getValue(P_FSG_50_0_0_37, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_37_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_37));
        if(getValue(P_FSG_50_0_0_37_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_37_ID);
        }
        if(getValue(P_FSG_50_0_0_37_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_37_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_37Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_37_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_37_ID;
    data[2]=getValue(P_FSG_50_0_0_37_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_37
on envVar P_FSG_50_0_0_37_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_37",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_37",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_37",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_37", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_37",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_37",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_37",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_37", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_37_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_37_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_37_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_37_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_37_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_37_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_37_ID,getValueSize(P_FSG_50_0_0_37_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_37_ID);
       }
}
on envVar P_FSG_50_0_0_37 // bus value of FunctionSynchronisation (37).
{
	// opcodes: Error-Status
	byte param1[6]; // FctList_1
	byte param2; // FctList_2
	byte param3; // FctList_3
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[8];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 8; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_37, superval);
	///////// Start param1 - 6/8BSTRING /////////
	for( i = 0; i < 6; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_37_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_37_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_50_0_0_37_3, param3);
}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_37_BuildFct()
{
	byte param1[6]; // FctList_1
	byte param2; // FctList_2
	byte param3; // FctList_3

	dword i;
	byte superval[8];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	getValue(P_FSG_50_0_0_37_1, param1);
	@P_FSG_50_0_0_37_1_16 = (param1[2] & 128) > 0;
	@P_FSG_50_0_0_37_1_17 = (param1[2] & 64) > 0;
	@P_FSG_50_0_0_37_1_18 = (param1[2] & 32) > 0;
	@P_FSG_50_0_0_37_1_19 = (param1[2] & 18) > 0;
	@P_FSG_50_0_0_37_1_20 = (param1[2] & 8) > 0;
	@P_FSG_50_0_0_37_1_21 = (param1[2] & 4) > 0;
	@P_FSG_50_0_0_37_1_22 = (param1[2] & 2) > 0;
	@P_FSG_50_0_0_37_1_23 = (param1[2] & 1) > 0;
	@P_FSG_50_0_0_37_1_25 = (param1[3] & 64) > 0;
	@P_FSG_50_0_0_37_1_26 = (param1[3] & 32) > 0;
        @P_FSG_50_0_0_37_1_27 = (param1[3] & 16) > 0;
	@P_FSG_50_0_0_37_1_28 = (param1[3] & 8) > 0;
	@P_FSG_50_0_0_37_1_31 = (param1[3] & 1) > 0;
	@P_FSG_50_0_0_37_1_36 = (param1[4] & 8) > 0;
	@P_FSG_50_0_0_37_1_38 = (param1[4] & 2) > 0;
	@P_FSG_50_0_0_37_1_39 = (param1[4] & 1) > 0;
	@P_FSG_50_0_0_37_1_40 = (param1[5] & 128) > 0;
	@P_FSG_50_0_0_37_1_43 = (param1[5] & 16) > 0;
	@P_FSG_50_0_0_37_1_44 = (param1[5] & 8) > 0;
	@P_FSG_50_0_0_37_1_45 = (param1[5] & 4) > 0;
	@P_FSG_50_0_0_37_1_46 = (param1[5] & 2) > 0;
	@P_FSG_50_0_0_37_1_47 = (param1[5] & 1) > 0;
	for( i = 0; i < 6; i++)
	{
	 superval[currentPos++] = param1[i];
	}
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_50_0_0_37_2);
	@P_FSG_50_0_0_37_2_0 = (param2 & 128) > 0;
	@P_FSG_50_0_0_37_2_1 = (param2 & 64) > 0;
	@P_FSG_50_0_0_37_2_2 = (param2 & 32) > 0;
	@P_FSG_50_0_0_37_2_5 = (param2 & 4) > 0;
	@P_FSG_50_0_0_37_2_6 = (param2 & 2) > 0;
        @P_FSG_50_0_0_37_2_7 = (param2 & 1) > 0;
	superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_50_0_0_37_3);
	@P_FSG_50_0_0_37_3_0 = (param3 & 1) > 0;
	@P_FSG_50_0_0_37_3_1 = (param3 & 2) > 0;
	@P_FSG_50_0_0_37_3_4 = (param3 & 16) > 0;
	superval[currentPos++]=param3;
	putValue(P_FSG_50_0_0_37, superval, currentPos);
}


on envVar P_FSG_50_0_0_37_1_16
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[2] = thisval[2]&~(1<<7)|(bitval<<7);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_17
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[2] = thisval[2]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_18
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[2] = thisval[2]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_19
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[2] = thisval[2]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_20
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[2] = thisval[2]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_21
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[2] = thisval[2]&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_22
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[2] = thisval[2]&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_23
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[2] = thisval[2]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_25
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[3] = thisval[3]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_26
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[3] = thisval[3]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_27
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[3] = thisval[3]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_28
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[3] = thisval[3]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_31
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[3] = thisval[3]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_36
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[4] = thisval[4]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_38
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[4] = thisval[4]&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_39
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[4] = thisval[4]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_40
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[5] = thisval[5]&~(1<<7)|(bitval<<7);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_43
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[5] = thisval[5]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_44
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[5] = thisval[5]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_45
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[5] = thisval[5]&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_46
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[5] = thisval[5]&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1_47
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_50_0_0_37_1, thisval);
	thisval[5] = thisval[5]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_37_1,thisval);
}

on envVar P_FSG_50_0_0_37_1 // FunctionSynchronisation.FctList_1
{
	P_FSG_50_0_0_37_BuildFct();
}

on envVar P_FSG_50_0_0_37_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_37_2);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_50_0_0_37_2,thisval);
}

on envVar P_FSG_50_0_0_37_2_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_37_2);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_50_0_0_37_2,thisval);
}

on envVar P_FSG_50_0_0_37_2_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_37_2);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_50_0_0_37_2,thisval);
}

on envVar P_FSG_50_0_0_37_2_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_37_2);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_37_2,thisval);
}

on envVar P_FSG_50_0_0_37_2_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_37_2);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_37_2,thisval);
}

on envVar P_FSG_50_0_0_37_2_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_37_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_37_2,thisval);
}

on envVar P_FSG_50_0_0_37_2 // FunctionSynchronisation.FctList_2
{
	P_FSG_50_0_0_37_BuildFct();
}

on envVar P_FSG_50_0_0_37_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_3
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_37_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_37_3,thisval);
}

on envVar P_FSG_50_0_0_37_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_3
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_37_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_37_3,thisval);
}

on envVar P_FSG_50_0_0_37_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_3
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_37_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_50_0_0_37_3,thisval);
}

on envVar P_FSG_50_0_0_37_3 // FunctionSynchronisation.FctList_3
{
	P_FSG_50_0_0_37_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_38_ErrCode
{
       if(gP_FSG_50_0_0_38_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_38", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_38_ErrCode = 1;
}
on envVar P_FSG_50_0_0_38Status_BTN
{
    if (P_FSG_50_0_0_38Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_50_0_0_38_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_38",MakeRGB(255,255,255));
       P_FSG_50_0_0_38Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_50_0_0_38_ID, Data_REQ, getValue(P_FSG_50_0_0_38));
      P_FSG_50_0_0_38Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_38_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_38_ID;
    data[2]=getValue(P_FSG_50_0_0_38_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_38
on envVar P_FSG_50_0_0_38_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_38",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_38",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_38",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_38", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_38",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_38",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_38",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_38", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_38 // bus value of InfoStates (38).
{
	// opcodes: Error-Status
	byte param1; // States
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_50_0_0_38);
	putValue(P_FSG_50_0_0_38_1, param1);
}

on envVar P_FSG_50_0_0_38_1 // InfoStates.States
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // States
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_50_0_0_38);
	superval = thisval;
	putValue(P_FSG_50_0_0_38,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_39_ErrCode
{
       if(gP_FSG_50_0_0_39_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_39", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_39_ErrCode = 1;
}
on envVar P_FSG_50_0_0_39Status_BTN
{
    if (P_FSG_50_0_0_39Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_50_0_0_39_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_39",MakeRGB(255,255,255));
       P_FSG_50_0_0_39Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_50_0_0_39_ID, Data_REQ, getValue(P_FSG_50_0_0_39));
      P_FSG_50_0_0_39Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_39_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_39_ID;
    data[2]=getValue(P_FSG_50_0_0_39_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_39
on envVar P_FSG_50_0_0_39_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_39",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_39",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_39",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_39", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_39",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_39",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_39",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_39", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_39 // bus value of ActiveRgType (39).
{
	// opcodes: Error-Status
	byte param1; // RGType
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_50_0_0_39);
	putValue(P_FSG_50_0_0_39_1, param1);
}

on envVar P_FSG_50_0_0_39_1 // ActiveRgType.RGType
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // RGType
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_50_0_0_39);
	superval = thisval;
	putValue(P_FSG_50_0_0_39,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_40_ErrCode
{
       if(gP_FSG_50_0_0_40_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_40", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_40_ErrCode = 1;
}
on envVar P_FSG_50_0_0_40Status_BTN
{
    if (P_FSG_50_0_0_40Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_50_0_0_40_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_40",MakeRGB(255,255,255));
       P_FSG_50_0_0_40Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_50_0_0_40_ID, Data_REQ, getValue(P_FSG_50_0_0_40));
      P_FSG_50_0_0_40Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_40_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_40_ID;
    data[2]=getValue(P_FSG_50_0_0_40_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_40
on envVar P_FSG_50_0_0_40_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_40",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_40",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_40",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_40", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_40",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_40",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_40",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_40", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_40 // bus value of TrafficBlock_Indication (40).
{
	// opcodes: Error-Status
	byte param1; // TMC_Symbol
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_50_0_0_40);
	putValue(P_FSG_50_0_0_40_1, param1);
}

on envVar P_FSG_50_0_0_40_1 // TrafficBlock_Indication.TMC_Symbol
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // TMC_Symbol
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_50_0_0_40);
	superval = thisval;
	putValue(P_FSG_50_0_0_40,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_50_0_0_41_ErrCode
{
       if(gM_FSG_50_0_0_41_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_41", MakeRGB(255,255,255));
       }
       gM_FSG_50_0_0_41_ErrCode = 1;
}
on envVar M_FSG_50_0_0_41Result_BTN
{
    byte temp[7];
    if (M_FSG_50_0_0_41Result_BTN_already_pressed == 0)
    {
        putValue(M_FSG_50_0_0_41_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_FSG_50_0_0_41",MakeRGB(255,255,255));
        M_FSG_50_0_0_41Result_BTN_already_pressed = 1;
    }
    else
    {
		 M_FSG_50_0_0_41_Result_BuildFct();
        putValue(M_FSG_50_0_0_41_State, "Result");
        getValue(M_FSG_50_0_0_41_Result, temp);
        Request_ByteSequence(LSGID, M_FSG_50_0_0_41_ID, Result_REQ, temp, getValueSize(M_FSG_50_0_0_41_Result));
        if(getValue(M_FSG_50_0_0_41_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(M_FSG_50_0_0_41_ID);
        }
        if(getValue(M_FSG_50_0_0_41_SegmEn))   //getvalue(SG)
        {
            sequence_err(M_FSG_50_0_0_41_ID,getValueSize(M_FSG_50_0_0_41_SegmEn));
        }
        M_FSG_50_0_0_41Result_BTN_already_pressed = 0;
    }
}
on envVar M_FSG_50_0_0_41_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_50_0_0_41_ID;
    data[2]=getValue(M_FSG_50_0_0_41_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_50_0_0_41
on envVar M_FSG_50_0_0_41_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_41",1);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_41",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_41",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_41", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_41",0);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_41",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_41",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_41_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_41", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar M_FSG_50_0_0_41_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(M_FSG_50_0_0_41_SegmEn,0);
           intertelegram_err(M_FSG_50_0_0_41_ID);
       }
       else
       {
           intertelegram_err_off(M_FSG_50_0_0_41_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar M_FSG_50_0_0_41_SegmEn
{
       if(getValue(this)) 
       {
           putValue(M_FSG_50_0_0_41_IntTlgEn,0);
           sequence_err(M_FSG_50_0_0_41_ID,getValueSize(M_FSG_50_0_0_41_SegmEn));
       }
       else
       {
              sequence_err_off(M_FSG_50_0_0_41_ID);
       }
}
on envVar M_FSG_50_0_0_41_Result // bus value of GetNextListPos (41).
{
	// opcodes: Error-Processing-Result
	byte param1; // GetNextListPos_Result
	word param2; // currentPos
	word param3; // nextPos
	word param4; // absoluteListPos
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[7];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 7; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_41_Result, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_50_0_0_41_Result_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_50_0_0_41_Result_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_50_0_0_41_Result_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT16 /////////
	param4 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_50_0_0_41_Result_4, round((param4 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
M_FSG_50_0_0_41_Result_BuildFct()
{
	byte param1; // GetNextListPos_Result
	word param2; // currentPos
	word param3; // nextPos
	word param4; // absoluteListPos

	dword i;
	byte superval[7];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(M_FSG_50_0_0_41_Result_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	@M_FSG_50_0_0_41_Result_2_range = round(@M_FSG_50_0_0_41_Result_2 + (0), 1.0); // slider value + min = real value
	param2 = (@M_FSG_50_0_0_41_Result_2 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param2&0x00ff;
	superval[currentPos++]=(param2&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@M_FSG_50_0_0_41_Result_3_range = round(@M_FSG_50_0_0_41_Result_3 + (0), 1.0); // slider value + min = real value
	param3 = (@M_FSG_50_0_0_41_Result_3 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param3&0x00ff;
	superval[currentPos++]=(param3&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@M_FSG_50_0_0_41_Result_4_range = round(@M_FSG_50_0_0_41_Result_4 + (0), 1.0); // slider value + min = real value
	param4 = (@M_FSG_50_0_0_41_Result_4 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param4&0x00ff;
	superval[currentPos++]=(param4&0xff00)>>8;
	putValue(M_FSG_50_0_0_41_Result, superval, currentPos);
}


on envVar M_FSG_50_0_0_41_Result_1 // GetNextListPos.GetNextListPos_Result
{
	M_FSG_50_0_0_41_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_41_Result_2_range // GetNextListPos.currentPos 
{
	@M_FSG_50_0_0_41_Result_2 = @M_FSG_50_0_0_41_Result_2_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_41_Result_2 // GetNextListPos.currentPos
{
	M_FSG_50_0_0_41_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_41_Result_3_range // GetNextListPos.nextPos 
{
	@M_FSG_50_0_0_41_Result_3 = @M_FSG_50_0_0_41_Result_3_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_41_Result_3 // GetNextListPos.nextPos
{
	M_FSG_50_0_0_41_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_41_Result_4_range // GetNextListPos.absoluteListPos 
{
	@M_FSG_50_0_0_41_Result_4 = @M_FSG_50_0_0_41_Result_4_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_41_Result_4 // GetNextListPos.absoluteListPos
{
	M_FSG_50_0_0_41_Result_BuildFct();
}

on envVar M_FSG_50_0_0_41_Processing // bus value of GetNextListPos (41).
{
	// opcodes: Error-Processing-Result
	byte param1[7]; // Reserve1
	word len1;
	byte cnt1;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[7];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 7; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_41_Processing, superval);
	///////// Start param1 - STRING /////////
	getValue(M_FSG_50_0_0_41_Processing_1, param1);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(6>127) /* Max Fct-Katalog Laenge: 6*/
		{
			len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt1 = 1;
		}
		else
		{
			len1 = 6;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_50_0_0_41_Processing ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len1 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt1 = 0;
	}
	
	if(len1 > 6)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
		len1 = 6;
	
		if(len1 < 128) cnt1 = 0;
		else cnt1 = 1;
	}
	
	for(i = 0; i < len1; i++)
	{
		param1[i] = superval[currentPos++];
	}
	
	putValue(M_FSG_50_0_0_41_Processing_1_len, len1);
	putValue(M_FSG_50_0_0_41_Processing_1_cnt, cnt1);
	
	if(len1 > getValueSize(M_FSG_50_0_0_41_Processing_1))
		putValue(M_FSG_50_0_0_41_Processing_1, param1, len1);
	else
		putValue(M_FSG_50_0_0_41_Processing_1, param1, getValueSize(M_FSG_50_0_0_41_Processing_1));

}

// Updates the bus value field and other dependencies.
M_FSG_50_0_0_41_Processing_BuildFct()
{
	byte param1[7]; // Reserve1
	word len1;
	byte cnt1;

	dword i;
	byte superval[7];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	getValue(M_FSG_50_0_0_41_Processing_1, param1);
	len1 = getValue(M_FSG_50_0_0_41_Processing_1_len);
	cnt1= getValue(M_FSG_50_0_0_41_Processing_1_cnt);
	
	/* check box aktiviert*/
	if (cnt1 == 1)
	{
		/* 0 bis 6 (MaxString - 1B oder 2B) */
		if(len1 >= 0 && len1 <= 6)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos] = ((len1>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_50_0_0_41_Processing_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 6);
			return;
		}
	}
	else if(cnt1 == 0) /*check box deaktiviert*/
	{
		if(len1 >= 0 && len1 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos]= len1 & 0x00ff;
			putValue(M_FSG_50_0_0_41_Processing_1_len, len1);
		}
		else if(len1 > 127 && len1 <= 6)
		{
			superval[currentPos] = ((len1>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
			putValue(M_FSG_50_0_0_41_Processing_1_len, len1);
			putValue(M_FSG_50_0_0_41_Processing_1_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_50_0_0_41_Processing_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 6);
			return;
		}
	}
	currentPos += cnt1+1;
	for(i = 0; i < len1; i++)
	{
		superval[currentPos++]= param1[i];
	}

	putValue(M_FSG_50_0_0_41_Processing, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_50_0_0_41_Processing_1_cnt
{
	word len;
	byte cnt;
	len = getValue(M_FSG_50_0_0_41_Processing_1_len);
	cnt = getValue(M_FSG_50_0_0_41_Processing_1_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_FSG_50_0_0_41_Processing_1_len, 127);
		}
	}

	M_FSG_50_0_0_41_Processing_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_50_0_0_41_Processing_1_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 6)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_50_0_0_41_Processing_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 6);
		putValue(this, 6);
	}
	M_FSG_50_0_0_41_Processing_BuildFct();
}


on envVar M_FSG_50_0_0_41_Processing_1 // GetNextListPos.Reserve1
{
	putValue(M_FSG_50_0_0_41_Processing_1_len, getValueSize(this));
	M_FSG_50_0_0_41_Processing_BuildFct();
}

on envVar M_FSG_50_0_0_41_Start // bus value of GetNextListPos (41).
{
	// opcodes: AbortResult-StartResult
	word param1; // currentPos
	int param2; // Offset
	byte param3; // ListType
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[5];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_41_Start, superval);
	///////// Start param1 - UINT16 /////////
	param1 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_50_0_0_41_Start_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_50_0_0_41_Start_2, round((param2 * 1.0) - (-32766) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(M_FSG_50_0_0_41_Start_3, param3);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_41_Start_1_range // GetNextListPos.currentPos 
{
	@M_FSG_50_0_0_41_Start_1 = @M_FSG_50_0_0_41_Start_1_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_41_Start_1 // GetNextListPos.currentPos
{
	byte superval[5];

	//Update Childvalue (Number)
	word thisval; // currentPos
	float slider_value;

	slider_value = round(@M_FSG_50_0_0_41_Start_1, 1.0);
	@M_FSG_50_0_0_41_Start_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_41_Start, superval);
	superval[0]=thisval&0x00ff;
	superval[1]=(thisval&0xff00)>>8;
	putValue(M_FSG_50_0_0_41_Start,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_41_Start_2_range // GetNextListPos.Offset 
{
	@M_FSG_50_0_0_41_Start_2 = @M_FSG_50_0_0_41_Start_2_range - (-32766); // slider = range - min
}

on envVar M_FSG_50_0_0_41_Start_2 // GetNextListPos.Offset
{
	byte superval[5];

	//Update Childvalue (Number)
	int thisval; // Offset
	float slider_value;

	slider_value = round(@M_FSG_50_0_0_41_Start_2, 1.0);
	@M_FSG_50_0_0_41_Start_2_range = slider_value + (-32766); // real value := slider value + range min.
	thisval = (int)round((slider_value + (-32766) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_41_Start, superval);
	superval[2]=thisval&0x00ff;
	superval[3]=(thisval&0xff00)>>8;
	putValue(M_FSG_50_0_0_41_Start,superval);
}

on envVar M_FSG_50_0_0_41_Start_3 // GetNextListPos.ListType
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // ListType
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_41_Start, superval);
	superval[4]=thisval;
	putValue(M_FSG_50_0_0_41_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_50_0_0_42_ErrCode
{
       if(gM_FSG_50_0_0_42_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_42", MakeRGB(255,255,255));
       }
       gM_FSG_50_0_0_42_ErrCode = 1;
}
on envVar M_FSG_50_0_0_42Result_BTN
{
    byte temp[5];
    if (M_FSG_50_0_0_42Result_BTN_already_pressed == 0)
    {
        putValue(M_FSG_50_0_0_42_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_FSG_50_0_0_42",MakeRGB(255,255,255));
        M_FSG_50_0_0_42Result_BTN_already_pressed = 1;
    }
    else
    {
        putValue(M_FSG_50_0_0_42_State, "Result");
        getValue(M_FSG_50_0_0_42_Result, temp);
        Request_ByteSequence(LSGID, M_FSG_50_0_0_42_ID, Result_REQ, temp, getValueSize(M_FSG_50_0_0_42_Result));
        M_FSG_50_0_0_42Result_BTN_already_pressed = 0;
    }
}
on envVar M_FSG_50_0_0_42_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_50_0_0_42_ID;
    data[2]=getValue(M_FSG_50_0_0_42_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_50_0_0_42
on envVar M_FSG_50_0_0_42_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_42",1);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_42",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_42",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_42", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_42",0);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_42",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_42",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_42_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_42", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_50_0_0_42_Result // bus value of NbSpeller (42).
{
	// opcodes: Error-Processing-Result
	byte param1; // NbSpeller_Result
	word param2; // MatchingEntries
	word param3; // Pos
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[5];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_42_Result, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_50_0_0_42_Result_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_50_0_0_42_Result_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_50_0_0_42_Result_3, round((param3 * 1.0) - (0) + (0), 1.0));
}

on envVar M_FSG_50_0_0_42_Result_1 // NbSpeller.NbSpeller_Result
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // NbSpeller_Result
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_42_Result, superval);
	superval[0]=thisval;
	putValue(M_FSG_50_0_0_42_Result,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_42_Result_2_range // NbSpeller.MatchingEntries 
{
	@M_FSG_50_0_0_42_Result_2 = @M_FSG_50_0_0_42_Result_2_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_42_Result_2 // NbSpeller.MatchingEntries
{
	byte superval[5];

	//Update Childvalue (Number)
	word thisval; // MatchingEntries
	float slider_value;

	slider_value = round(@M_FSG_50_0_0_42_Result_2, 1.0);
	@M_FSG_50_0_0_42_Result_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_42_Result, superval);
	superval[1]=thisval&0x00ff;
	superval[2]=(thisval&0xff00)>>8;
	putValue(M_FSG_50_0_0_42_Result,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_42_Result_3_range // NbSpeller.Pos 
{
	@M_FSG_50_0_0_42_Result_3 = @M_FSG_50_0_0_42_Result_3_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_42_Result_3 // NbSpeller.Pos
{
	byte superval[5];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@M_FSG_50_0_0_42_Result_3, 1.0);
	@M_FSG_50_0_0_42_Result_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_42_Result, superval);
	superval[3]=thisval&0x00ff;
	superval[4]=(thisval&0xff00)>>8;
	putValue(M_FSG_50_0_0_42_Result,superval);
}

on envVar M_FSG_50_0_0_42_Processing // bus value of NbSpeller (42).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	dword param2; // Reserve2
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[5];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_42_Processing, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_50_0_0_42_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT32 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8)|(superval[currentPos++]<<16)|(superval[currentPos++]<<24);
	putValue(M_FSG_50_0_0_42_Processing_2, round((param2 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_42_Processing_1_range // NbSpeller.Reserve1 
{
	@M_FSG_50_0_0_42_Processing_1 = @M_FSG_50_0_0_42_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_42_Processing_1 // NbSpeller.Reserve1
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_50_0_0_42_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_42_Processing, superval);
	superval[0]=thisval;
	putValue(M_FSG_50_0_0_42_Processing,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_42_Processing_2_range // NbSpeller.Reserve2 
{
	@M_FSG_50_0_0_42_Processing_2 = @M_FSG_50_0_0_42_Processing_2_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_42_Processing_2 // NbSpeller.Reserve2
{
	byte superval[5];

	//Update Childvalue (Number)
	dword thisval; // Reserve2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_50_0_0_42_Processing_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (dword)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_42_Processing, superval);
	superval[1]= thisval&0x000000ff;
	superval[2]=(thisval&0x0000ff00)>>8;
	superval[3]=(thisval&0x00ff0000)>>16;
	superval[4]=(thisval&0xff000000)>>24;
	putValue(M_FSG_50_0_0_42_Processing,superval);
}

on envVar M_FSG_50_0_0_42_Start // bus value of NbSpeller (42).
{
	// opcodes: AbortResult-StartResult
	byte param1; // Mode
	byte param2[51]; // SearchString
	word len2;
	byte cnt2;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[52];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 52; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_42_Start, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_50_0_0_42_Start_1, param1);
	///////// Start param2 - STRING /////////
	//getValue(M_FSG_50_0_0_42_Start_2, param2);
  getValue(M_FSG_50_0_0_42_Start_2_Hex, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(50>127) /* Max Fct-Katalog Laenge: 50*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 50;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_50_0_0_42_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 50)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 50;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(M_FSG_50_0_0_42_Start_2_len, len2);
	putValue(M_FSG_50_0_0_42_Start_2_cnt, cnt2);
	
  if(len2 > getValueSize(M_FSG_50_0_0_42_Start_2_Hex))
		putValue(M_FSG_50_0_0_42_Start_2_Hex, param2, len2);
	else
		putValue(M_FSG_50_0_0_42_Start_2_Hex, param2, getValueSize(M_FSG_50_0_0_42_Start_2_Hex));
  
	/*if(len2 > getValueSize(M_FSG_50_0_0_42_Start_2))
		putValue(M_FSG_50_0_0_42_Start_2, param2, len2);
	else
		putValue(M_FSG_50_0_0_42_Start_2, param2, getValueSize(M_FSG_50_0_0_42_Start_2));*/

}

// Updates the bus value field and other dependencies.
M_FSG_50_0_0_42_Start_BuildFct()
{
	byte param1; // Mode
	byte param2[51]; // SearchString
	word len2;
	byte cnt2;

	dword i;
	byte superval[52];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(M_FSG_50_0_0_42_Start_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	//getValue(M_FSG_50_0_0_42_Start_2, param2);
  getValue(M_FSG_50_0_0_42_Start_2_Hex, param2);
	len2 = getValue(M_FSG_50_0_0_42_Start_2_len);
	cnt2= getValue(M_FSG_50_0_0_42_Start_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 50 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 50)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = ((len2>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_50_0_0_42_Start_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 50);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(M_FSG_50_0_0_42_Start_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 50)
		{
			superval[currentPos] = ((len2>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(M_FSG_50_0_0_42_Start_2_len, len2);
			putValue(M_FSG_50_0_0_42_Start_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_50_0_0_42_Start_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 50);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

	putValue(M_FSG_50_0_0_42_Start, superval, currentPos);
}


on envVar M_FSG_50_0_0_42_Start_1 // NbSpeller.Mode
{
	M_FSG_50_0_0_42_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_50_0_0_42_Start_2_cnt
{
	word len;
	byte cnt;
	len = getValue(M_FSG_50_0_0_42_Start_2_len);
	cnt = getValue(M_FSG_50_0_0_42_Start_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_FSG_50_0_0_42_Start_2_len, 127);
		}
	}

	M_FSG_50_0_0_42_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_50_0_0_42_Start_2_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 50)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_50_0_0_42_Start_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 50);
		putValue(this, 50);
	}
	M_FSG_50_0_0_42_Start_BuildFct();
}


on envVar M_FSG_50_0_0_42_Start_2 // NbSpeller.SearchString
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(M_FSG_50_0_0_42_Start_2_Hex,string_buffer_mod,string_length_mod);
  putValue(M_FSG_50_0_0_42_Start_2_len, string_length_mod);
  
  /*putValue(M_FSG_50_0_0_42_Start_2_len, getValueSize(this));
	M_FSG_50_0_0_42_Start_BuildFct();*/
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_43_ErrCode
{
       if(gP_FSG_50_0_0_43_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_43", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_43_ErrCode = 1;
}
on envVar P_FSG_50_0_0_43Status_BTN
{
	byte BAPTemp[4];
   if (P_FSG_50_0_0_43Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_43_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_43",MakeRGB(255,255,255));
      P_FSG_50_0_0_43Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_43, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_43_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_43));
      P_FSG_50_0_0_43Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_43_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_43_ID;
    data[2]=getValue(P_FSG_50_0_0_43_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_43
on envVar P_FSG_50_0_0_43_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_43",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_43",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_43",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_43", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_43",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_43",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_43",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_43", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_43 // bus value of MapColorAndType (43).
{
	// opcodes: Error-Status
	byte param1; // Colour
	byte param2; // ActiveMapType
	byte param3; // MainMapSetup
	byte param4; // SupportedMapTypes
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[4];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 4; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_43, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_43_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_43_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_50_0_0_43_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_50_0_0_43_4, param4);
}

on envVar P_FSG_50_0_0_43_1 // MapColorAndType.Colour
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // Colour
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_43, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_43,superval);
}

on envVar P_FSG_50_0_0_43_2 // MapColorAndType.ActiveMapType
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // ActiveMapType
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_43, superval);
	superval[1]=thisval;
	putValue(P_FSG_50_0_0_43,superval);
}

on envVar P_FSG_50_0_0_43_3 // MapColorAndType.MainMapSetup
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // MainMapSetup
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_43, superval);
	superval[2]=thisval;
	putValue(P_FSG_50_0_0_43,superval);
}

on envVar P_FSG_50_0_0_43_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedMapTypes
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_43_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_43_4,thisval);
}

on envVar P_FSG_50_0_0_43_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedMapTypes
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_43_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_43_4,thisval);
}

on envVar P_FSG_50_0_0_43_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedMapTypes
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_43_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_43_4,thisval);
}

on envVar P_FSG_50_0_0_43_4_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedMapTypes
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_43_4);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_43_4,thisval);
}

on envVar P_FSG_50_0_0_43_4_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedMapTypes
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_43_4);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_50_0_0_43_4,thisval);
}

on envVar P_FSG_50_0_0_43_4_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedMapTypes
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_43_4);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_50_0_0_43_4,thisval);
}

on envVar P_FSG_50_0_0_43_4 // MapColorAndType.SupportedMapTypes
{
	byte superval[4];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // SupportedMapTypes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_43_4_0, 1);
	else
		putValue(P_FSG_50_0_0_43_4_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_50_0_0_43_4_1, 1);
	else
		putValue(P_FSG_50_0_0_43_4_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_50_0_0_43_4_2, 1);
	else
		putValue(P_FSG_50_0_0_43_4_2, 0);
	if(thisval&(mask<<3))
		putValue(P_FSG_50_0_0_43_4_3, 1);
	else
		putValue(P_FSG_50_0_0_43_4_3, 0);
	if(thisval&(mask<<4))
		putValue(P_FSG_50_0_0_43_4_4, 1);
	else
		putValue(P_FSG_50_0_0_43_4_4, 0);
	if(thisval&(mask<<5))
		putValue(P_FSG_50_0_0_43_4_5, 1);
	else
		putValue(P_FSG_50_0_0_43_4_5, 0);

    // Update superval
	getValue(P_FSG_50_0_0_43, superval);
	superval[3]=thisval;
	putValue(P_FSG_50_0_0_43,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_44_ErrCode
{
       if(gP_FSG_50_0_0_44_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_44", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_44_ErrCode = 1;
}
on envVar P_FSG_50_0_0_44Status_BTN
{
	byte BAPTemp[7];
    if (P_FSG_50_0_0_44Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_44_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_44",MakeRGB(255,255,255));
        P_FSG_50_0_0_44Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_44_BuildFct();
        getValue(P_FSG_50_0_0_44, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_44_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_44));
        if(getValue(P_FSG_50_0_0_44_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_44_ID);
        }
        if(getValue(P_FSG_50_0_0_44_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_44_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_44Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_44_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_44_ID;
    data[2]=getValue(P_FSG_50_0_0_44_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_44
on envVar P_FSG_50_0_0_44_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_44",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_44",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_44",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_44", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_44",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_44",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_44",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_44", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_44_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_44_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_44_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_44_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_44_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_44_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_44_ID,getValueSize(P_FSG_50_0_0_44_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_44_ID);
       }
}
on envVar P_FSG_50_0_0_44 // bus value of MapViewAndOrientation (44).
{
	// opcodes: Error-Status
	byte param1; // MapView
	byte param2; // SupplementaryMapView
	byte param3; // SupportedMapViews
	byte param4; // SupportedSupplementaryMapViews
	byte param5; // MapVisibility
	byte param6; // MapOrientation
	byte param7; // Modification
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[7];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 7; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_44, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_44_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_44_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_50_0_0_44_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_50_0_0_44_4, param4);
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_50_0_0_44_5, param5);
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_50_0_0_44_6, param6);
	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_FSG_50_0_0_44_7, param7);
}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_44_BuildFct()
{
	byte param1; // MapView
	byte param2; // SupplementaryMapView
	byte param3; // SupportedMapViews
	byte param4; // SupportedSupplementaryMapViews
	byte param5; // MapVisibility
	byte param6; // MapOrientation
	byte param7; // Modification

	dword i;
	byte superval[7];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_FSG_50_0_0_44_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_50_0_0_44_2);
	superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_50_0_0_44_3);
	@P_FSG_50_0_0_44_3_0 = (param3 & 1) > 0;
	@P_FSG_50_0_0_44_3_1 = (param3 & 2) > 0;
	@P_FSG_50_0_0_44_3_2 = (param3 & 4) > 0;
	@P_FSG_50_0_0_44_3_3 = (param3 & 8) > 0;
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_50_0_0_44_4);
	@P_FSG_50_0_0_44_4_0 = (param4 & 1) > 0;
	@P_FSG_50_0_0_44_4_1 = (param4 & 2) > 0;
	@P_FSG_50_0_0_44_4_2 = (param4 & 4) > 0;
	superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_FSG_50_0_0_44_5);
	@P_FSG_50_0_0_44_5_0 = (param5 & 1) > 0;
	@P_FSG_50_0_0_44_5_1 = (param5 & 2) > 0;
	@P_FSG_50_0_0_44_5_2 = (param5 & 4) > 0;
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	param6 = getValue(P_FSG_50_0_0_44_6);
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_FSG_50_0_0_44_7);
	@P_FSG_50_0_0_44_7_0 = (param7 & 1) > 0;
	superval[currentPos++]=param7;
	putValue(P_FSG_50_0_0_44, superval, currentPos);
}


on envVar P_FSG_50_0_0_44_1 // MapViewAndOrientation.MapView
{
	P_FSG_50_0_0_44_BuildFct();
}

on envVar P_FSG_50_0_0_44_2 // MapViewAndOrientation.SupplementaryMapView
{
	P_FSG_50_0_0_44_BuildFct();
}

on envVar P_FSG_50_0_0_44_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedMapViews
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_44_3,thisval);
}

on envVar P_FSG_50_0_0_44_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedMapViews
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_44_3,thisval);
}

on envVar P_FSG_50_0_0_44_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedMapViews
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_44_3,thisval);
}

on envVar P_FSG_50_0_0_44_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedMapViews
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_3);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_44_3,thisval);
}

on envVar P_FSG_50_0_0_44_3 // MapViewAndOrientation.SupportedMapViews
{
	P_FSG_50_0_0_44_BuildFct();
}

on envVar P_FSG_50_0_0_44_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedSupplementaryMapViews
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_44_4,thisval);
}

on envVar P_FSG_50_0_0_44_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedSupplementaryMapViews
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_44_4,thisval);
}

on envVar P_FSG_50_0_0_44_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedSupplementaryMapViews
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_44_4,thisval);
}

on envVar P_FSG_50_0_0_44_4 // MapViewAndOrientation.SupportedSupplementaryMapViews
{
	P_FSG_50_0_0_44_BuildFct();
}

on envVar P_FSG_50_0_0_44_5_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MapVisibility
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_5);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_44_5,thisval);
}

on envVar P_FSG_50_0_0_44_5_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MapVisibility
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_5);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_44_5,thisval);
}

on envVar P_FSG_50_0_0_44_5_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MapVisibility
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_5);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_44_5,thisval);
}

on envVar P_FSG_50_0_0_44_5 // MapViewAndOrientation.MapVisibility
{
	P_FSG_50_0_0_44_BuildFct();
}

on envVar P_FSG_50_0_0_44_6 // MapViewAndOrientation.MapOrientation
{
	P_FSG_50_0_0_44_BuildFct();
}

on envVar P_FSG_50_0_0_44_7_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Modification
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_44_7);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_44_7,thisval);
}

on envVar P_FSG_50_0_0_44_7 // MapViewAndOrientation.Modification
{
	P_FSG_50_0_0_44_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_45_ErrCode
{
       if(gP_FSG_50_0_0_45_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_45", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_45_ErrCode = 1;
}
on envVar P_FSG_50_0_0_45Status_BTN
{
	byte BAPTemp[6];
   if (P_FSG_50_0_0_45Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_45_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_45",MakeRGB(255,255,255));
      P_FSG_50_0_0_45Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_45, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_45_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_45));
      P_FSG_50_0_0_45Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_45_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_45_ID;
    data[2]=getValue(P_FSG_50_0_0_45_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_45
on envVar P_FSG_50_0_0_45_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_45",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_45",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_45",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_45", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_45",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_45",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_45",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_45", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_45 // bus value of MapScale (45).
{
	// opcodes: Error-Status
	char param1; // Steps
	byte param2; // AutoZoom
	byte param3; // AutoZoomState
	word param4; // Scale
	byte param5; // Unit
	byte param6; // SupportedAutoZoom
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[6];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_45, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_45_1, round((param1 * 1.0) - (-128) + (0), 1.0));
	///////// Start param2 - NIBBLE /////////
	param2 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_50_0_0_45_2, param2);
	///////// Start param3 - NIBBLE /////////
	param3 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_50_0_0_45_3, param3);
	///////// Start param4 - UINT16 /////////
	param4 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_50_0_0_45_4, round((param4 * 1) - (0.1) + (0.1), 0.1));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_50_0_0_45_5, param5);
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_50_0_0_45_6, param6);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_45_1_range // MapScale.Steps 
{
	@P_FSG_50_0_0_45_1 = @P_FSG_50_0_0_45_1_range - (-128); // slider = range - min
}

on envVar P_FSG_50_0_0_45_1 // MapScale.Steps
{
	byte superval[6];

	//Update Childvalue (Number)
	char thisval; // Steps
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_45_1, 1.0);
	@P_FSG_50_0_0_45_1_range = slider_value + (-128); // real value := slider value + range min.
	thisval = (char)round((slider_value + (-128) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_45, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_45,superval);
}

on envVar P_FSG_50_0_0_45_2 // MapScale.AutoZoom
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // AutoZoom
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_45, superval);
	superval[1]= superval[1]&0x0f;
	superval[1]= superval[1]|(thisval<<4);
	putValue(P_FSG_50_0_0_45,superval);
}

on envVar P_FSG_50_0_0_45_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AutoZoomState
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_45_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_45_3,thisval);
}

on envVar P_FSG_50_0_0_45_3 // MapScale.AutoZoomState
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // AutoZoomState
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_45_3_0, 1);
	else
		putValue(P_FSG_50_0_0_45_3_0, 0);

    // Update superval
	getValue(P_FSG_50_0_0_45, superval);
	superval[1]= superval[1]&0xf0;
	superval[1]= superval[1]|thisval;
	putValue(P_FSG_50_0_0_45,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_45_4_range // MapScale.Scale 
{
	@P_FSG_50_0_0_45_4 = @P_FSG_50_0_0_45_4_range; // slider = range - min
}

on envVar P_FSG_50_0_0_45_4 // MapScale.Scale
{
	byte superval[6];

	//Update Childvalue (Number)
	word thisval; // Scale
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_45_4, 0.1);
	@P_FSG_50_0_0_45_4_range = slider_value; // real value := slider value + range min.
	thisval = (word)round((slider_value + (0.1) - (0.1)) / (1), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_45, superval);
	superval[2]=thisval&0x00ff;
	superval[3]=(thisval&0xff00)>>8;
	putValue(P_FSG_50_0_0_45,superval);
}

on envVar P_FSG_50_0_0_45_5 // MapScale.Unit
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // Unit
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_45, superval);
	superval[4]=thisval;
	putValue(P_FSG_50_0_0_45,superval);
}

on envVar P_FSG_50_0_0_45_6_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // SupportedAutoZoom
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_45_6);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_45_6,thisval);
}

on envVar P_FSG_50_0_0_45_6 // MapScale.SupportedAutoZoom
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // SupportedAutoZoom
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_45_6_0, 1);
	else
		putValue(P_FSG_50_0_0_45_6_0, 0);

    // Update superval
	getValue(P_FSG_50_0_0_45, superval);
	superval[5]=thisval;
	putValue(P_FSG_50_0_0_45,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_46_ErrCode
{
       if(gP_FSG_50_0_0_46_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_46", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_46_ErrCode = 1;
}
on envVar P_FSG_50_0_0_46Status_BTN
{
	byte BAPTemp[405];
    if (P_FSG_50_0_0_46Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_46_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_46",MakeRGB(255,255,255));
        P_FSG_50_0_0_46Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_46_BuildFct();
        getValue(P_FSG_50_0_0_46, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_46_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_46));
        if(getValue(P_FSG_50_0_0_46_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_46_ID);
        }
        if(getValue(P_FSG_50_0_0_46_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_46_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_46Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_46_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_46_ID;
    data[2]=getValue(P_FSG_50_0_0_46_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_46
on envVar P_FSG_50_0_0_46_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_46",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_46",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_46",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_46", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_46",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_46",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_46",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_46", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_46_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_46_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_46_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_46_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_46_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_46_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_46_ID,getValueSize(P_FSG_50_0_0_46_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_46_ID);
       }
}
on envVar P_FSG_50_0_0_46 // bus value of DestinationInfo (46).
{
	// opcodes: Error-Status
	byte param1[8]; //Record: Position
	byte param2; // TotalNumOfStopovers
	byte param3; // Stopover_SN
	byte param4; // POI_Type
	byte param5[61]; // POI_Description
	word len5;
	byte cnt5;
	byte param6[128]; // Street
	word len6;
	byte cnt6;
	byte param7[61]; // Town
	word len7;
	byte cnt7;
	byte param8[61]; // State
	word len8;
	byte cnt8;
	byte param9[22]; // PostalCode
	word len9;
	byte cnt9;
	byte param10[61]; // Country
	word len10;
	byte cnt10;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[405];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 405; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_46, superval);
	///////// Start param1 - Record /////////
	for( i = 0; i < 8; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_46_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_46_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_50_0_0_46_3, round((param3 * 1.0) - (1) + (1), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_50_0_0_46_4, param4);
	///////// Start param5 - STRING /////////
	//getValue(P_FSG_50_0_0_46_5, param5);
  getValue(P_FSG_50_0_0_46_5_Hex, param5);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(60>127) /* Max Fct-Katalog Laenge: 60*/
		{
			len5 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt5 = 1;
		}
		else
		{
			len5 = 60;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_46 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len5 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt5 = 0;
	}
	
	if(len5 > 60)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len5, currentPos);
		len5 = 60;
	
		if(len5 < 128) cnt5 = 0;
		else cnt5 = 1;
	}
	
	for(i = 0; i < len5; i++)
	{
		param5[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_46_5_len, len5);
	putValue(P_FSG_50_0_0_46_5_cnt, cnt5);
	
	if(len5 > getValueSize(P_FSG_50_0_0_46_5_Hex))
		putValue(P_FSG_50_0_0_46_5_Hex, param5, len5);
	else
		putValue(P_FSG_50_0_0_46_5_Hex, param5, getValueSize(P_FSG_50_0_0_46_5_Hex));
  
  /*if(len5 > getValueSize(P_FSG_50_0_0_46_5))
		putValue(P_FSG_50_0_0_46_5, param5, len5);
	else
		putValue(P_FSG_50_0_0_46_5, param5, getValueSize(P_FSG_50_0_0_46_5));*/

	///////// Start param6 - STRING /////////
	//getValue(P_FSG_50_0_0_46_6, param6);
  getValue(P_FSG_50_0_0_46_6_Hex, param6);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(126>127) /* Max Fct-Katalog Laenge: 126*/
		{
			len6 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt6 = 1;
		}
		else
		{
			len6 = 126;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_46 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len6 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt6 = 0;
	}
	
	if(len6 > 126)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len6, currentPos);
		len6 = 126;
	
		if(len6 < 128) cnt6 = 0;
		else cnt6 = 1;
	}
	
	for(i = 0; i < len6; i++)
	{
		param6[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_46_6_len, len6);
	putValue(P_FSG_50_0_0_46_6_cnt, cnt6);
	
  if(len6 > getValueSize(P_FSG_50_0_0_46_6_Hex))
		putValue(P_FSG_50_0_0_46_6_Hex, param6, len6);
	else
		putValue(P_FSG_50_0_0_46_6_Hex, param6, getValueSize(P_FSG_50_0_0_46_6_Hex));
  
	/*if(len6 > getValueSize(P_FSG_50_0_0_46_6))
		putValue(P_FSG_50_0_0_46_6, param6, len6);
	else
		putValue(P_FSG_50_0_0_46_6, param6, getValueSize(P_FSG_50_0_0_46_6));*/

	///////// Start param7 - STRING /////////
	//getValue(P_FSG_50_0_0_46_7, param7);
  getValue(P_FSG_50_0_0_46_7_Hex, param7);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(60>127) /* Max Fct-Katalog Laenge: 60*/
		{
			len7 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt7 = 1;
		}
		else
		{
			len7 = 60;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_46 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len7 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt7 = 0;
	}
	
	if(len7 > 60)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len7, currentPos);
		len7 = 60;
	
		if(len7 < 128) cnt7 = 0;
		else cnt7 = 1;
	}
	
	for(i = 0; i < len7; i++)
	{
		param7[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_46_7_len, len7);
	putValue(P_FSG_50_0_0_46_7_cnt, cnt7);
	
	/*if(len7 > getValueSize(P_FSG_50_0_0_46_7))
		putValue(P_FSG_50_0_0_46_7, param7, len7);
	else
		putValue(P_FSG_50_0_0_46_7, param7, getValueSize(P_FSG_50_0_0_46_7));*/
  
  if(len7 > getValueSize(P_FSG_50_0_0_46_7_Hex))
		putValue(P_FSG_50_0_0_46_7_Hex, param7, len7);
	else
		putValue(P_FSG_50_0_0_46_7_Hex, param7, getValueSize(P_FSG_50_0_0_46_7_Hex));

	///////// Start param8 - STRING /////////
	//getValue(P_FSG_50_0_0_46_8, param8);
  getValue(P_FSG_50_0_0_46_8_Hex, param8);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(60>127) /* Max Fct-Katalog Laenge: 60*/
		{
			len8 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt8 = 1;
		}
		else
		{
			len8 = 60;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_46 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len8 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt8 = 0;
	}
	
	if(len8 > 60)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len8, currentPos);
		len8 = 60;
	
		if(len8 < 128) cnt8 = 0;
		else cnt8 = 1;
	}
	
	for(i = 0; i < len8; i++)
	{
		param8[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_46_8_len, len8);
	putValue(P_FSG_50_0_0_46_8_cnt, cnt8);
	
  if(len8 > getValueSize(P_FSG_50_0_0_46_8_Hex))
		putValue(P_FSG_50_0_0_46_8_Hex, param8, len8);
	else
		putValue(P_FSG_50_0_0_46_8_Hex, param8, getValueSize(P_FSG_50_0_0_46_8_Hex));
  
	/*if(len8 > getValueSize(P_FSG_50_0_0_46_8))
		putValue(P_FSG_50_0_0_46_8, param8, len8);
	else
		putValue(P_FSG_50_0_0_46_8, param8, getValueSize(P_FSG_50_0_0_46_8));*/

	///////// Start param9 - STRING /////////
	//getValue(P_FSG_50_0_0_46_9, param9);
  getValue(P_FSG_50_0_0_46_9_Hex, param9);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(21>127) /* Max Fct-Katalog Laenge: 21*/
		{
			len9 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt9 = 1;
		}
		else
		{
			len9 = 21;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_46 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len9 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt9 = 0;
	}
	
	if(len9 > 21)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len9, currentPos);
		len9 = 21;
	
		if(len9 < 128) cnt9 = 0;
		else cnt9 = 1;
	}
	
	for(i = 0; i < len9; i++)
	{
		param9[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_46_9_len, len9);
	putValue(P_FSG_50_0_0_46_9_cnt, cnt9);
	
  if(len9 > getValueSize(P_FSG_50_0_0_46_9_Hex))
		putValue(P_FSG_50_0_0_46_9_Hex, param9, len9);
	else
		putValue(P_FSG_50_0_0_46_9_Hex, param9, getValueSize(P_FSG_50_0_0_46_9_Hex));
  
	/*if(len9 > getValueSize(P_FSG_50_0_0_46_9))
		putValue(P_FSG_50_0_0_46_9, param9, len9);
	else
		putValue(P_FSG_50_0_0_46_9, param9, getValueSize(P_FSG_50_0_0_46_9));*/

	///////// Start param10 - STRING /////////
	//getValue(P_FSG_50_0_0_46_10, param10);
  getValue(P_FSG_50_0_0_46_10_Hex, param10);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(60>127) /* Max Fct-Katalog Laenge: 60*/
		{
			len10 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt10 = 1;
		}
		else
		{
			len10 = 60;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_50_0_0_46 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len10 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt10 = 0;
	}
	
	if(len10 > 60)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len10, currentPos);
		len10 = 60;
	
		if(len10 < 128) cnt10 = 0;
		else cnt10 = 1;
	}
	
	for(i = 0; i < len10; i++)
	{
		param10[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_50_0_0_46_10_len, len10);
	putValue(P_FSG_50_0_0_46_10_cnt, cnt10);
	
  if(len10 > getValueSize(P_FSG_50_0_0_46_10_Hex))
		putValue(P_FSG_50_0_0_46_10_Hex, param10, len10);
	else
		putValue(P_FSG_50_0_0_46_10_Hex, param10, getValueSize(P_FSG_50_0_0_46_10_Hex));
  
	/*if(len10 > getValueSize(P_FSG_50_0_0_46_10))
		putValue(P_FSG_50_0_0_46_10, param10, len10);
	else
		putValue(P_FSG_50_0_0_46_10, param10, getValueSize(P_FSG_50_0_0_46_10));*/

}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_46_BuildFct()
{
	byte param1[8]; //Record: Position
	byte param2; // TotalNumOfStopovers
	byte param3; // Stopover_SN
	byte param4; // POI_Type
	byte param5[61]; // POI_Description
	word len5;
	byte cnt5;
	byte param6[128]; // Street
	word len6;
	byte cnt6;
	byte param7[61]; // Town
	word len7;
	byte cnt7;
	byte param8[61]; // State
	word len8;
	byte cnt8;
	byte param9[22]; // PostalCode
	word len9;
	byte cnt9;
	byte param10[61]; // Country
	word len10;
	byte cnt10;

	dword i;
	byte superval[405];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	//Record:Position
	getValue(P_FSG_50_0_0_46_1, param1);
	for( i = 0; i < 8; i++)
	{
	 superval[currentPos++] = param1[i];
	}
// gen_BuildFunc_SetSuperVals 
	@P_FSG_50_0_0_46_2_range = round(@P_FSG_50_0_0_46_2 + (0), 1.0); // slider value + min = real value
	param2 = (@P_FSG_50_0_0_46_2 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_50_0_0_46_3_range = round(@P_FSG_50_0_0_46_3 + (0), 1.0); // slider value + min = real value
	param3 = (@P_FSG_50_0_0_46_3 + (1) - (1)) / (1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_50_0_0_46_4);
	superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_50_0_0_46_5, param5);
  getValue(P_FSG_50_0_0_46_5_Hex, param5);
	len5 = getValue(P_FSG_50_0_0_46_5_len);
	cnt5= getValue(P_FSG_50_0_0_46_5_cnt);
	
	/* check box aktiviert*/
	if (cnt5 == 1)
	{
		/* 0 bis 60 (MaxString - 1B oder 2B) */
		if(len5 >= 0 && len5 <= 60)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len5: %d", len5);
			superval[currentPos] = ((len5>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len5 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_5 ist ungueltig. Die max. erlaubte Laenge ist %d.", len5, 60);
			return;
		}
	}
	else if(cnt5 == 0) /*check box deaktiviert*/
	{
		if(len5 >= 0 && len5 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len5: %d", len5);
			superval[currentPos]= len5 & 0x00ff;
			putValue(P_FSG_50_0_0_46_5_len, len5);
		}
		else if(len5 > 127 && len5 <= 60)
		{
			superval[currentPos] = ((len5>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len5 & 0x00ff;
			putValue(P_FSG_50_0_0_46_5_len, len5);
			putValue(P_FSG_50_0_0_46_5_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_5 ist ungueltig. Die max. erlaubte Laenge ist %d.", len5, 60);
			return;
		}
	}
	currentPos += cnt5+1;
	for(i = 0; i < len5; i++)
	{
		superval[currentPos++]= param5[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_50_0_0_46_6, param6);
  getValue(P_FSG_50_0_0_46_6_Hex, param6);
	len6 = getValue(P_FSG_50_0_0_46_6_len);
	cnt6= getValue(P_FSG_50_0_0_46_6_cnt);
	
	/* check box aktiviert*/
	if (cnt6 == 1)
	{
		/* 0 bis 126 (MaxString - 1B oder 2B) */
		if(len6 >= 0 && len6 <= 126)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
			superval[currentPos] = ((len6>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len6 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 126);
			return;
		}
	}
	else if(cnt6 == 0) /*check box deaktiviert*/
	{
		if(len6 >= 0 && len6 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
			superval[currentPos]= len6 & 0x00ff;
			putValue(P_FSG_50_0_0_46_6_len, len6);
		}
		else if(len6 > 127 && len6 <= 126)
		{
			superval[currentPos] = ((len6>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len6 & 0x00ff;
			putValue(P_FSG_50_0_0_46_6_len, len6);
			putValue(P_FSG_50_0_0_46_6_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 126);
			return;
		}
	}
	currentPos += cnt6+1;
	for(i = 0; i < len6; i++)
	{
		superval[currentPos++]= param6[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_50_0_0_46_7, param7);
  getValue(P_FSG_50_0_0_46_7_Hex, param7);
	len7 = getValue(P_FSG_50_0_0_46_7_len);
	cnt7= getValue(P_FSG_50_0_0_46_7_cnt);
	
	/* check box aktiviert*/
	if (cnt7 == 1)
	{
		/* 0 bis 60 (MaxString - 1B oder 2B) */
		if(len7 >= 0 && len7 <= 60)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
			superval[currentPos] = ((len7>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len7 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 60);
			return;
		}
	}
	else if(cnt7 == 0) /*check box deaktiviert*/
	{
		if(len7 >= 0 && len7 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
			superval[currentPos]= len7 & 0x00ff;
			putValue(P_FSG_50_0_0_46_7_len, len7);
		}
		else if(len7 > 127 && len7 <= 60)
		{
			superval[currentPos] = ((len7>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len7 & 0x00ff;
			putValue(P_FSG_50_0_0_46_7_len, len7);
			putValue(P_FSG_50_0_0_46_7_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 60);
			return;
		}
	}
	currentPos += cnt7+1;
	for(i = 0; i < len7; i++)
	{
		superval[currentPos++]= param7[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_50_0_0_46_8, param8);
  getValue(P_FSG_50_0_0_46_8_Hex, param8);
	len8 = getValue(P_FSG_50_0_0_46_8_len);
	cnt8= getValue(P_FSG_50_0_0_46_8_cnt);
	
	/* check box aktiviert*/
	if (cnt8 == 1)
	{
		/* 0 bis 60 (MaxString - 1B oder 2B) */
		if(len8 >= 0 && len8 <= 60)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
			superval[currentPos] = ((len8>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len8 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 60);
			return;
		}
	}
	else if(cnt8 == 0) /*check box deaktiviert*/
	{
		if(len8 >= 0 && len8 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
			superval[currentPos]= len8 & 0x00ff;
			putValue(P_FSG_50_0_0_46_8_len, len8);
		}
		else if(len8 > 127 && len8 <= 60)
		{
			superval[currentPos] = ((len8>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len8 & 0x00ff;
			putValue(P_FSG_50_0_0_46_8_len, len8);
			putValue(P_FSG_50_0_0_46_8_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 60);
			return;
		}
	}
	currentPos += cnt8+1;
	for(i = 0; i < len8; i++)
	{
		superval[currentPos++]= param8[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_50_0_0_46_9, param9);
  getValue(P_FSG_50_0_0_46_9_Hex, param9);
	len9 = getValue(P_FSG_50_0_0_46_9_len);
	cnt9= getValue(P_FSG_50_0_0_46_9_cnt);
	
	/* check box aktiviert*/
	if (cnt9 == 1)
	{
		/* 0 bis 21 (MaxString - 1B oder 2B) */
		if(len9 >= 0 && len9 <= 21)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len9: %d", len9);
			superval[currentPos] = ((len9>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len9 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_9 ist ungueltig. Die max. erlaubte Laenge ist %d.", len9, 21);
			return;
		}
	}
	else if(cnt9 == 0) /*check box deaktiviert*/
	{
		if(len9 >= 0 && len9 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len9: %d", len9);
			superval[currentPos]= len9 & 0x00ff;
			putValue(P_FSG_50_0_0_46_9_len, len9);
		}
		else if(len9 > 127 && len9 <= 21)
		{
			superval[currentPos] = ((len9>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len9 & 0x00ff;
			putValue(P_FSG_50_0_0_46_9_len, len9);
			putValue(P_FSG_50_0_0_46_9_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_9 ist ungueltig. Die max. erlaubte Laenge ist %d.", len9, 21);
			return;
		}
	}
	currentPos += cnt9+1;
	for(i = 0; i < len9; i++)
	{
		superval[currentPos++]= param9[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_50_0_0_46_10, param10);
  getValue(P_FSG_50_0_0_46_10_Hex, param10);
	len10 = getValue(P_FSG_50_0_0_46_10_len);
	cnt10= getValue(P_FSG_50_0_0_46_10_cnt);
	
	/* check box aktiviert*/
	if (cnt10 == 1)
	{
		/* 0 bis 60 (MaxString - 1B oder 2B) */
		if(len10 >= 0 && len10 <= 60)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len10: %d", len10);
			superval[currentPos] = ((len10>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len10 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_10 ist ungueltig. Die max. erlaubte Laenge ist %d.", len10, 60);
			return;
		}
	}
	else if(cnt10 == 0) /*check box deaktiviert*/
	{
		if(len10 >= 0 && len10 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len10: %d", len10);
			superval[currentPos]= len10 & 0x00ff;
			putValue(P_FSG_50_0_0_46_10_len, len10);
		}
		else if(len10 > 127 && len10 <= 60)
		{
			superval[currentPos] = ((len10>>8)&0x7F) | 0x80;
			superval[currentPos+1] = len10 & 0x00ff;
			putValue(P_FSG_50_0_0_46_10_len, len10);
			putValue(P_FSG_50_0_0_46_10_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_10 ist ungueltig. Die max. erlaubte Laenge ist %d.", len10, 60);
			return;
		}
	}
	currentPos += cnt10+1;
	for(i = 0; i < len10; i++)
	{
		superval[currentPos++]= param10[i];
	}

	putValue(P_FSG_50_0_0_46, superval, currentPos);
}


//Record: Position, Element: Latitude
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_46_1_Latitude_range // DestinationInfo.Latitude 
{
	@P_FSG_50_0_0_46_1_Latitude = @P_FSG_50_0_0_46_1_Latitude_range - (-90); // slider = range - min
}

on envVar P_FSG_50_0_0_46_1_Latitude // Position.Latitude
{
	byte superval[8];

	//Update Childvalue (Number)
	long thisval; // Latitude
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_46_1_Latitude, 1.0E-6);
	@P_FSG_50_0_0_46_1_Latitude_range = slider_value + (-90); // real value := slider value + range min.
	thisval = (long)round((slider_value + (-90) - (0)) / (1.0E-6), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_46_1, superval);
	superval[0]= thisval&0x000000ff;
	superval[1]=(thisval&0x0000ff00)>>8;
	superval[2]=(thisval&0x00ff0000)>>16;
	superval[3]=(thisval&0xff000000)>>24;
	putValue(P_FSG_50_0_0_46_1,superval);
}

//Record: Position, Element: Longitude
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_46_1_Longitude_range // DestinationInfo.Longitude 
{
	@P_FSG_50_0_0_46_1_Longitude = @P_FSG_50_0_0_46_1_Longitude_range - (-180); // slider = range - min
}

on envVar P_FSG_50_0_0_46_1_Longitude // Position.Longitude
{
	byte superval[8];

	//Update Childvalue (Number)
	long thisval; // Longitude
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_46_1_Longitude, 1.0E-6);
	@P_FSG_50_0_0_46_1_Longitude_range = slider_value + (-180); // real value := slider value + range min.
	thisval = (long)round((slider_value + (-180) - (0)) / (1.0E-6), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_46_1, superval);
	superval[4]= thisval&0x000000ff;
	superval[5]=(thisval&0x0000ff00)>>8;
	superval[6]=(thisval&0x00ff0000)>>16;
	superval[7]=(thisval&0xff000000)>>24;
	putValue(P_FSG_50_0_0_46_1,superval);
}

on envVar P_FSG_50_0_0_46_1 // DestinationInfo.Position
{
	byte recordVal[8]; //Record: Position
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	long param1; // Latitude
	long param2; // Longitude

	currentPos = 0;
	getValue(P_FSG_50_0_0_46_1, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT32 /////////
	param1 = recordVal[currentPos++]|(recordVal[currentPos++]<<8)|(recordVal[currentPos++]<<16)|(recordVal[currentPos++]<<24);
	putValue(P_FSG_50_0_0_46_1_Latitude, round((param1 * 1.0E-6) - (-90) + (0), 1.0E-6));
	///////// Start param2 - UINT32 /////////
	param2 = recordVal[currentPos++]|(recordVal[currentPos++]<<8)|(recordVal[currentPos++]<<16)|(recordVal[currentPos++]<<24);
	putValue(P_FSG_50_0_0_46_1_Longitude, round((param2 * 1.0E-6) - (-180) + (0), 1.0E-6));
	P_FSG_50_0_0_46_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_46_2_range // DestinationInfo.TotalNumOfStopovers 
{
	@P_FSG_50_0_0_46_2 = @P_FSG_50_0_0_46_2_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_46_2 // DestinationInfo.TotalNumOfStopovers
{
	P_FSG_50_0_0_46_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_46_3_range // DestinationInfo.Stopover_SN 
{
	@P_FSG_50_0_0_46_3 = @P_FSG_50_0_0_46_3_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_46_3 // DestinationInfo.Stopover_SN
{
	P_FSG_50_0_0_46_BuildFct();
}

on envVar P_FSG_50_0_0_46_4 // DestinationInfo.POI_Type
{
	P_FSG_50_0_0_46_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_46_5_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_46_5_len);
	cnt = getValue(P_FSG_50_0_0_46_5_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_46_5_len, 127);
		}
	}

	P_FSG_50_0_0_46_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_46_5_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 60)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 60);
		putValue(this, 60);
	}
	P_FSG_50_0_0_46_BuildFct();
}


on envVar P_FSG_50_0_0_46_5 // DestinationInfo.POI_Description
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_46_5_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_46_5_len, string_length_mod);
  
  /*putValue(P_FSG_50_0_0_46_5_len, getValueSize(this));
	P_FSG_50_0_0_46_BuildFct();*/
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_46_6_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_46_6_len);
	cnt = getValue(P_FSG_50_0_0_46_6_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_46_6_len, 127);
		}
	}

	P_FSG_50_0_0_46_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_46_6_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 126)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 126);
		putValue(this, 126);
	}
	P_FSG_50_0_0_46_BuildFct();
}


on envVar P_FSG_50_0_0_46_6 // DestinationInfo.Street
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_46_6_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_46_6_len, string_length_mod);
  
  /*putValue(P_FSG_50_0_0_46_6_len, getValueSize(this));
	P_FSG_50_0_0_46_BuildFct();*/
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_46_7_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_46_7_len);
	cnt = getValue(P_FSG_50_0_0_46_7_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_46_7_len, 127);
		}
	}

	P_FSG_50_0_0_46_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_46_7_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 60)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 60);
		putValue(this, 60);
	}
	P_FSG_50_0_0_46_BuildFct();
}


on envVar P_FSG_50_0_0_46_7 // DestinationInfo.Town
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_46_7_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_46_7_len, string_length_mod);
  
  /*putValue(P_FSG_50_0_0_46_7_len, getValueSize(this));
	P_FSG_50_0_0_46_BuildFct();*/
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_46_8_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_46_8_len);
	cnt = getValue(P_FSG_50_0_0_46_8_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_46_8_len, 127);
		}
	}

	P_FSG_50_0_0_46_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_46_8_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 60)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_8 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 60);
		putValue(this, 60);
	}
	P_FSG_50_0_0_46_BuildFct();
}


on envVar P_FSG_50_0_0_46_8 // DestinationInfo.State
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_46_8_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_46_8_len, string_length_mod);
  
  /*putValue(P_FSG_50_0_0_46_8_len, getValueSize(this));
	P_FSG_50_0_0_46_BuildFct();*/
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_46_9_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_46_9_len);
	cnt = getValue(P_FSG_50_0_0_46_9_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_46_9_len, 127);
		}
	}

	P_FSG_50_0_0_46_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_46_9_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 21)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_9 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 21);
		putValue(this, 21);
	}
	P_FSG_50_0_0_46_BuildFct();
}


on envVar P_FSG_50_0_0_46_9 // DestinationInfo.PostalCode
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_46_9_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_46_9_len, string_length_mod);
  
  /*putValue(P_FSG_50_0_0_46_9_len, getValueSize(this));
	P_FSG_50_0_0_46_BuildFct();*/
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_50_0_0_46_10_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_50_0_0_46_10_len);
	cnt = getValue(P_FSG_50_0_0_46_10_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_50_0_0_46_10_len, 127);
		}
	}

	P_FSG_50_0_0_46_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_50_0_0_46_10_len
{
	dword len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 60)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_50_0_0_46_10 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 60);
		putValue(this, 60);
	}
	P_FSG_50_0_0_46_BuildFct();
}


on envVar P_FSG_50_0_0_46_10 // DestinationInfo.Country
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_50_0_0_46_10_Hex, string_buffer_mod,string_length_mod);
  putValue(P_FSG_50_0_0_46_10_len, string_length_mod);
  
  /*putValue(P_FSG_50_0_0_46_10_len, getValueSize(this));
	P_FSG_50_0_0_46_BuildFct();*/
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_47_ErrCode
{
       if(gP_FSG_50_0_0_47_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_47", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_47_ErrCode = 1;
}
on envVar P_FSG_50_0_0_47Status_BTN
{
	byte BAPTemp[3];
   if (P_FSG_50_0_0_47Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_47_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_47",MakeRGB(255,255,255));
      P_FSG_50_0_0_47Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_47, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_47_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_47));
      P_FSG_50_0_0_47Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_47_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_47_ID;
    data[2]=getValue(P_FSG_50_0_0_47_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_47
on envVar P_FSG_50_0_0_47_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_47",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_47",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_47",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_47", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_47",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_47",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_47",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_47", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_47 // bus value of Altitude (47).
{
	// opcodes: Error-Status
	int param1; // Altitude
	byte param2; // Unit
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[3];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_47, superval);
	///////// Start param1 - UINT16 /////////
	param1 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_50_0_0_47_1, round((param1 * 1.0) - (-32768) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_47_2, param2);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_47_1_range // Altitude.Altitude 
{
	@P_FSG_50_0_0_47_1 = @P_FSG_50_0_0_47_1_range - (-32768); // slider = range - min
}

on envVar P_FSG_50_0_0_47_1 // Altitude.Altitude
{
	byte superval[3];

	//Update Childvalue (Number)
	int thisval; // Altitude
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_47_1, 1.0);
	@P_FSG_50_0_0_47_1_range = slider_value + (-32768); // real value := slider value + range min.
	thisval = (int)round((slider_value + (-32768) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_47, superval);
	superval[0]=thisval&0x00ff;
	superval[1]=(thisval&0xff00)>>8;
	putValue(P_FSG_50_0_0_47,superval);
}

on envVar P_FSG_50_0_0_47_2 // Altitude.Unit
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // Unit
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_47, superval);
	superval[2]=thisval;
	putValue(P_FSG_50_0_0_47,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_48_ErrCode
{
       if(gP_FSG_50_0_0_48_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_48", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_48_ErrCode = 1;
}
on envVar P_FSG_50_0_0_48Status_BTN
{
	byte BAPTemp[3];
   if (P_FSG_50_0_0_48Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_48_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_48",MakeRGB(255,255,255));
      P_FSG_50_0_0_48Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_48, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_48_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_48));
      P_FSG_50_0_0_48Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_48_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_48_ID;
    data[2]=getValue(P_FSG_50_0_0_48_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_48
on envVar P_FSG_50_0_0_48_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_48",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_48",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_48",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_48", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_48",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_48",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_48",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_48", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_48 // bus value of OnlineNavigationState (48).
{
	// opcodes: Error-Status
	byte param1; // State
	byte param2; // Progress
	byte param3; // OnlineNavigationSystem
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[3];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_48, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_48_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_48_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_50_0_0_48_3, param3);
}

on envVar P_FSG_50_0_0_48_1 // OnlineNavigationState.State
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // State
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_48, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_48,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_48_2_range // OnlineNavigationState.Progress 
{
	@P_FSG_50_0_0_48_2 = @P_FSG_50_0_0_48_2_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_48_2 // OnlineNavigationState.Progress
{
	byte superval[3];

	//Update Childvalue (Number)
	byte thisval; // Progress
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_48_2, 1.0);
	@P_FSG_50_0_0_48_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_48, superval);
	superval[1]=thisval;
	putValue(P_FSG_50_0_0_48,superval);
}

on envVar P_FSG_50_0_0_48_3 // OnlineNavigationState.OnlineNavigationSystem
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // OnlineNavigationSystem
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_48, superval);
	superval[2]=thisval;
	putValue(P_FSG_50_0_0_48,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_49_ErrCode
{
       if(gP_FSG_50_0_0_49_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_49", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_49_ErrCode = 1;
}
on envVar P_FSG_50_0_0_49Status_BTN
{
	byte BAPTemp[3];
   if (P_FSG_50_0_0_49Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_49_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_49",MakeRGB(255,255,255));
      P_FSG_50_0_0_49Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_49, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_49_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_49));
      P_FSG_50_0_0_49Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_49_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_49_ID;
    data[2]=getValue(P_FSG_50_0_0_49_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_49
on envVar P_FSG_50_0_0_49_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_49",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_49",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_49",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_49", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_49",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_49",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_49",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_49", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_49 // bus value of Exitview (49).
{
	// opcodes: Error-Status
	byte param1; // Variant
	word param2; // Exitview_ID
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[3];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_49, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_49_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_50_0_0_49_2, round((param2 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_50_0_0_49_1 // Exitview.Variant
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // Variant
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_49, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_49,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_49_2_range // Exitview.Exitview_ID 
{
	@P_FSG_50_0_0_49_2 = @P_FSG_50_0_0_49_2_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_49_2 // Exitview.Exitview_ID
{
	byte superval[3];

	//Update Childvalue (Number)
	word thisval; // Exitview_ID
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_49_2, 1.0);
	@P_FSG_50_0_0_49_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_49, superval);
	superval[1]=thisval&0x00ff;
	superval[2]=(thisval&0xff00)>>8;
	putValue(P_FSG_50_0_0_49,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_50_ErrCode
{
       if(gP_FSG_50_0_0_50_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_50", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_50_ErrCode = 1;
}
on envVar P_FSG_50_0_0_50Status_BTN
{
	byte BAPTemp[16];
    if (P_FSG_50_0_0_50Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_50_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_50",MakeRGB(255,255,255));
        P_FSG_50_0_0_50Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_50_BuildFct();
        getValue(P_FSG_50_0_0_50, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_50_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_50));
        if(getValue(P_FSG_50_0_0_50_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_50_ID);
        }
        if(getValue(P_FSG_50_0_0_50_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_50_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_50Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_50_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_50_ID;
    data[2]=getValue(P_FSG_50_0_0_50_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_50
on envVar P_FSG_50_0_0_50_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_50",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_50",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_50",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_50", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_50",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_50",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_50",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_50", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_50_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_50_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_50_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_50_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_50_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_50_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_50_ID,getValueSize(P_FSG_50_0_0_50_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_50_ID);
       }
}
on envVar P_FSG_50_0_0_50 // bus value of SemidynamicRouteGuidance (50).
{
	// opcodes: Error-Status
	byte param1; // TrafficImpact
	byte param2[2]; //Record: Delay
	byte param3[6]; //Record: NewDistanceToDestination
	byte param4[6]; //Record: NewTimeToDestination
	byte param5; // ValidityInformation
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[16];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 16; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_50, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_50_1, param1);
	///////// Start param2 - Record /////////
	for( i = 0; i < 2; i++ )
	{
		param2[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_50_2, param2);
	///////// Start param3 - Record /////////
	for( i = 0; i < 6; i++ )
	{
		param3[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_50_3, param3);
	///////// Start param4 - Record /////////
	for( i = 0; i < 6; i++ )
	{
		param4[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_50_4, param4);
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_50_0_0_50_5, param5);
}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_50_BuildFct()
{
	byte param1; // TrafficImpact
	byte param2[2]; //Record: Delay
	byte param3[6]; //Record: NewDistanceToDestination
	byte param4[6]; //Record: NewTimeToDestination
	byte param5; // ValidityInformation

	dword i;
	byte superval[16];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_FSG_50_0_0_50_1);
	@P_FSG_50_0_0_50_1_0 = (param1 & 1) > 0;
	@P_FSG_50_0_0_50_1_1 = (param1 & 2) > 0;
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	//Record:Delay
	getValue(P_FSG_50_0_0_50_2, param2);
	for( i = 0; i < 2; i++)
	{
	 superval[currentPos++] = param2[i];
	}
// gen_BuildFunc_SetSuperVals 
	//Record:NewDistanceToDestination
	getValue(P_FSG_50_0_0_50_3, param3);
	for( i = 0; i < 6; i++)
	{
	 superval[currentPos++] = param3[i];
	}
// gen_BuildFunc_SetSuperVals 
	//Record:NewTimeToDestination
	getValue(P_FSG_50_0_0_50_4, param4);
	for( i = 0; i < 6; i++)
	{
	 superval[currentPos++] = param4[i];
	}
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_FSG_50_0_0_50_5);
	@P_FSG_50_0_0_50_5_0 = (param5 & 1) > 0;
	@P_FSG_50_0_0_50_5_1 = (param5 & 2) > 0;
	@P_FSG_50_0_0_50_5_2 = (param5 & 4) > 0;
	@P_FSG_50_0_0_50_5_3 = (param5 & 8) > 0;
	@P_FSG_50_0_0_50_5_4 = (param5 & 16) > 0;
	@P_FSG_50_0_0_50_5_5 = (param5 & 32) > 0;
	superval[currentPos++]=param5;
	putValue(P_FSG_50_0_0_50, superval, currentPos);
}


on envVar P_FSG_50_0_0_50_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // TrafficImpact
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_50_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_50_1,thisval);
}

on envVar P_FSG_50_0_0_50_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // TrafficImpact
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_50_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_50_1,thisval);
}

on envVar P_FSG_50_0_0_50_1 // SemidynamicRouteGuidance.TrafficImpact
{
	P_FSG_50_0_0_50_BuildFct();
}

//Record: Delay, Element: Minute
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_50_2_Minute_range // SemidynamicRouteGuidance.Minute 
{
	@P_FSG_50_0_0_50_2_Minute = @P_FSG_50_0_0_50_2_Minute_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_50_2_Minute // Delay.Minute
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_50_2_Minute, 1.0);
	@P_FSG_50_0_0_50_2_Minute_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_50_2, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_50_2,superval);
}

//Record: Delay, Element: Hour
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_50_2_Hour_range // SemidynamicRouteGuidance.Hour 
{
	@P_FSG_50_0_0_50_2_Hour = @P_FSG_50_0_0_50_2_Hour_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_50_2_Hour // Delay.Hour
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_50_2_Hour, 1.0);
	@P_FSG_50_0_0_50_2_Hour_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_50_2, superval);
	superval[1]=thisval;
	putValue(P_FSG_50_0_0_50_2,superval);
}

on envVar P_FSG_50_0_0_50_2 // SemidynamicRouteGuidance.Delay
{
	byte recordVal[2]; //Record: Delay
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	byte param1; // Minute
	byte param2; // Hour

	currentPos = 0;
	getValue(P_FSG_50_0_0_50_2, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT8 /////////
	param1 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_50_2_Minute, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_50_2_Hour, round((param2 * 1.0) - (0) + (0), 1.0));
	P_FSG_50_0_0_50_BuildFct();
}

//Record: NewDistanceToDestination, Element: Distance
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_50_3_Distance_range // SemidynamicRouteGuidance.Distance 
{
	@P_FSG_50_0_0_50_3_Distance = @P_FSG_50_0_0_50_3_Distance_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_50_3_Distance // NewDistanceToDestination.Distance
{
	byte superval[6];

	//Update Childvalue (Number)
	dword thisval; // Distance
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_50_3_Distance, 0.1);
	@P_FSG_50_0_0_50_3_Distance_range = slider_value + (0); // real value := slider value + range min.
	thisval = (dword)round((slider_value + (0) - (0)) / (0.1), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_50_3, superval);
	superval[0]= thisval&0x000000ff;
	superval[1]=(thisval&0x0000ff00)>>8;
	superval[2]=(thisval&0x00ff0000)>>16;
	superval[3]=(thisval&0xff000000)>>24;
	putValue(P_FSG_50_0_0_50_3,superval);
}

//Record: NewDistanceToDestination, Element: Unit
on envVar P_FSG_50_0_0_50_3_Unit // NewDistanceToDestination.Unit
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // Unit
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_50_3, superval);
	superval[4]=thisval;
	putValue(P_FSG_50_0_0_50_3,superval);
}

//Record: NewDistanceToDestination, Element: TypeOfDistance
on envVar P_FSG_50_0_0_50_3_TypeOfDistance // NewDistanceToDestination.TypeOfDistance
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // TypeOfDistance
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_50_3, superval);
	superval[5]=thisval;
	putValue(P_FSG_50_0_0_50_3,superval);
}

on envVar P_FSG_50_0_0_50_3 // SemidynamicRouteGuidance.NewDistanceToDestination
{
	byte recordVal[6]; //Record: NewDistanceToDestination
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	dword param1; // Distance
	byte param2; // Unit
	byte param3; // TypeOfDistance

	currentPos = 0;
	getValue(P_FSG_50_0_0_50_3, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT32 /////////
	param1 = recordVal[currentPos++]|(recordVal[currentPos++]<<8)|(recordVal[currentPos++]<<16)|(recordVal[currentPos++]<<24);
	putValue(P_FSG_50_0_0_50_3_Distance, round((param1 * 0.1) - (0) + (0), 0.1));
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_50_3_Unit, param2);
	///////// Start param3 - UINT8 /////////
	param3 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_50_3_TypeOfDistance, param3);
	P_FSG_50_0_0_50_BuildFct();
}

//Record: NewTimeToDestination, Element: TimeInfoType
on envVar P_FSG_50_0_0_50_4_TimeInfoType // NewTimeToDestination.TimeInfoType
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // TimeInfoType
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_50_4, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(P_FSG_50_0_0_50_4,superval);
}

//Record: NewTimeToDestination, Element: NavigationTimeFormat
on envVar P_FSG_50_0_0_50_4_NavigationTimeFormat // NewTimeToDestination.NavigationTimeFormat
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // NavigationTimeFormat
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_50_4, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(P_FSG_50_0_0_50_4,superval);
}

//Record: NewTimeToDestination, Element: Minute
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_50_4_Minute_range // SemidynamicRouteGuidance.Minute 
{
	@P_FSG_50_0_0_50_4_Minute = @P_FSG_50_0_0_50_4_Minute_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_50_4_Minute // NewTimeToDestination.Minute
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_50_4_Minute, 1.0);
	@P_FSG_50_0_0_50_4_Minute_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_50_4, superval);
	superval[1]=thisval;
	putValue(P_FSG_50_0_0_50_4,superval);
}

//Record: NewTimeToDestination, Element: Hour
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_50_4_Hour_range // SemidynamicRouteGuidance.Hour 
{
	@P_FSG_50_0_0_50_4_Hour = @P_FSG_50_0_0_50_4_Hour_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_50_4_Hour // NewTimeToDestination.Hour
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_50_4_Hour, 1.0);
	@P_FSG_50_0_0_50_4_Hour_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_50_4, superval);
	superval[2]=thisval;
	putValue(P_FSG_50_0_0_50_4,superval);
}

//Record: NewTimeToDestination, Element: Day
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_50_4_Day_range // SemidynamicRouteGuidance.Day 
{
	@P_FSG_50_0_0_50_4_Day = @P_FSG_50_0_0_50_4_Day_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_50_4_Day // NewTimeToDestination.Day
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Day
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_50_4_Day, 1.0);
	@P_FSG_50_0_0_50_4_Day_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_50_4, superval);
	superval[3]=thisval;
	putValue(P_FSG_50_0_0_50_4,superval);
}

//Record: NewTimeToDestination, Element: Month
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_50_4_Month_range // SemidynamicRouteGuidance.Month 
{
	@P_FSG_50_0_0_50_4_Month = @P_FSG_50_0_0_50_4_Month_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_50_4_Month // NewTimeToDestination.Month
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Month
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_50_4_Month, 1.0);
	@P_FSG_50_0_0_50_4_Month_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_50_4, superval);
	superval[4]=thisval;
	putValue(P_FSG_50_0_0_50_4,superval);
}

//Record: NewTimeToDestination, Element: Year
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_50_4_Year_range // SemidynamicRouteGuidance.Year 
{
	@P_FSG_50_0_0_50_4_Year = @P_FSG_50_0_0_50_4_Year_range - (2000); // slider = range - min
}

on envVar P_FSG_50_0_0_50_4_Year // NewTimeToDestination.Year
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Year
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_50_4_Year, 1.0);
	@P_FSG_50_0_0_50_4_Year_range = slider_value + (2000); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (2000) - (2000)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_50_4, superval);
	superval[5]=thisval;
	putValue(P_FSG_50_0_0_50_4,superval);
}

on envVar P_FSG_50_0_0_50_4 // SemidynamicRouteGuidance.NewTimeToDestination
{
	byte recordVal[6]; //Record: NewTimeToDestination
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	byte param1; // TimeInfoType
	byte param2; // NavigationTimeFormat
	byte param3; // Minute
	byte param4; // Hour
	byte param5; // Day
	byte param6; // Month
	byte param7; // Year

	currentPos = 0;
	getValue(P_FSG_50_0_0_50_4, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - NIBBLE /////////
	param1 = (recordVal[currentPos] & 0xf0)>>4;
	putValue(P_FSG_50_0_0_50_4_TimeInfoType, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = recordVal[currentPos++] & 0x0f;
	putValue(P_FSG_50_0_0_50_4_NavigationTimeFormat, param2);
	///////// Start param3 - UINT8 /////////
	param3 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_50_4_Minute, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_50_4_Hour, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_50_4_Day, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_50_4_Month, round((param6 * 1.0) - (0) + (0), 1.0));
	///////// Start param7 - UINT8 /////////
	param7 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_50_4_Year, round((param7 * 1.0) - (2000) + (2000), 1.0));
	P_FSG_50_0_0_50_BuildFct();
}

on envVar P_FSG_50_0_0_50_5_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_50_5);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_50_5,thisval);
}

on envVar P_FSG_50_0_0_50_5_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_50_5);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_50_5,thisval);
}

on envVar P_FSG_50_0_0_50_5_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_50_5);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_50_5,thisval);
}

on envVar P_FSG_50_0_0_50_5_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_50_5);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_50_5,thisval);
}

on envVar P_FSG_50_0_0_50_5_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_50_5);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_50_0_0_50_5,thisval);
}

on envVar P_FSG_50_0_0_50_5_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_50_5);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_50_0_0_50_5,thisval);
}

on envVar P_FSG_50_0_0_50_5 // SemidynamicRouteGuidance.ValidityInformation
{
	P_FSG_50_0_0_50_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_50_0_0_51_ErrCode
{
       if(gM_FSG_50_0_0_51_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_51", MakeRGB(255,255,255));
       }
       gM_FSG_50_0_0_51_ErrCode = 1;
}
on envVar M_FSG_50_0_0_51Result_BTN
{
    byte temp[2];
    if (M_FSG_50_0_0_51Result_BTN_already_pressed == 0)
    {
        putValue(M_FSG_50_0_0_51_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_FSG_50_0_0_51",MakeRGB(255,255,255));
        M_FSG_50_0_0_51Result_BTN_already_pressed = 1;
    }
    else
    {
        putValue(M_FSG_50_0_0_51_State, "Result");
        getValue(M_FSG_50_0_0_51_Result, temp);
        Request_ByteSequence(LSGID, M_FSG_50_0_0_51_ID, Result_REQ, temp, getValueSize(M_FSG_50_0_0_51_Result));
        M_FSG_50_0_0_51Result_BTN_already_pressed = 0;
    }
}
on envVar M_FSG_50_0_0_51_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_50_0_0_51_ID;
    data[2]=getValue(M_FSG_50_0_0_51_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_50_0_0_51
on envVar M_FSG_50_0_0_51_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_51",1);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_51",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_51",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_51", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_51",0);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_51",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_51",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_51_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_51", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_50_0_0_51_Result // bus value of POI_Search (51).
{
	// opcodes: Error-Processing-Result
	byte param1; // AmountOfFoundEntries
	byte param2; // POI_Search_Result
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[2];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_51_Result, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_50_0_0_51_Result_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(M_FSG_50_0_0_51_Result_2, param2);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_51_Result_1_range // POI_Search.AmountOfFoundEntries 
{
	@M_FSG_50_0_0_51_Result_1 = @M_FSG_50_0_0_51_Result_1_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_51_Result_1 // POI_Search.AmountOfFoundEntries
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // AmountOfFoundEntries
	float slider_value;

	slider_value = round(@M_FSG_50_0_0_51_Result_1, 1.0);
	@M_FSG_50_0_0_51_Result_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_51_Result, superval);
	superval[0]=thisval;
	putValue(M_FSG_50_0_0_51_Result,superval);
}

on envVar M_FSG_50_0_0_51_Result_2 // POI_Search.POI_Search_Result
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // POI_Search_Result
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_51_Result, superval);
	superval[1]=thisval;
	putValue(M_FSG_50_0_0_51_Result,superval);
}

on envVar M_FSG_50_0_0_51_Processing // bus value of POI_Search (51).
{
	// opcodes: Error-Processing-Result
	byte param1; // AmountOfFoundEntries
	byte param2; // ProgressIndicator
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[2];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_51_Processing, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_50_0_0_51_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(M_FSG_50_0_0_51_Processing_2, round((param2 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_51_Processing_1_range // POI_Search.AmountOfFoundEntries 
{
	@M_FSG_50_0_0_51_Processing_1 = @M_FSG_50_0_0_51_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_51_Processing_1 // POI_Search.AmountOfFoundEntries
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // AmountOfFoundEntries
	float slider_value;

	slider_value = round(@M_FSG_50_0_0_51_Processing_1, 1.0);
	@M_FSG_50_0_0_51_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_51_Processing, superval);
	superval[0]=thisval;
	putValue(M_FSG_50_0_0_51_Processing,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_51_Processing_2_range // POI_Search.ProgressIndicator 
{
	@M_FSG_50_0_0_51_Processing_2 = @M_FSG_50_0_0_51_Processing_2_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_51_Processing_2 // POI_Search.ProgressIndicator
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // ProgressIndicator
	float slider_value;

	slider_value = round(@M_FSG_50_0_0_51_Processing_2, 1.0);
	@M_FSG_50_0_0_51_Processing_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_51_Processing, superval);
	superval[1]=thisval;
	putValue(M_FSG_50_0_0_51_Processing,superval);
}

on envVar M_FSG_50_0_0_51_Start // bus value of POI_Search (51).
{
	// opcodes: AbortResult-StartResult
	byte param1; // SearchType
	byte param2; // POI_Type
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[2];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_51_Start, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_50_0_0_51_Start_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(M_FSG_50_0_0_51_Start_2, param2);
}

on envVar M_FSG_50_0_0_51_Start_1 // POI_Search.SearchType
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // SearchType
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_51_Start, superval);
	superval[0]=thisval;
	putValue(M_FSG_50_0_0_51_Start,superval);
}

on envVar M_FSG_50_0_0_51_Start_2 // POI_Search.POI_Type
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // POI_Type
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_51_Start, superval);
	superval[1]=thisval;
	putValue(M_FSG_50_0_0_51_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_50_0_0_52_ErrCode
{
       if(gA_FSG_50_0_0_52_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_52", MakeRGB(255,255,255));
       }
       gA_FSG_50_0_0_52_ErrCode = 1;
}
on envVar A_FSG_50_0_0_52Changed_BTN
{
    byte data[1829]; 
    byte stringValue[1829];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_50_0_0_52Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_52_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_52",MakeRGB(255,255,255));
        A_FSG_50_0_0_52Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_52_Changed);
        getValue(A_FSG_50_0_0_52_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_52_Changed_Start);
     elementsVal = getValue(A_FSG_50_0_0_52_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_52_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_50_0_0_52_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_50_0_0_52_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_50_0_0_52_ID);
       }
       if(getValue(A_FSG_50_0_0_52_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_50_0_0_52_ID,getValueSize(A_FSG_50_0_0_52_Changed));
       }
        A_FSG_50_0_0_52Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_52Status_BTN
{
    byte data[1829 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[1829];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_50_0_0_52Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_52_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_52",MakeRGB(255,255,255));
        A_FSG_50_0_0_52Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_52_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_52_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_52_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_52);
        getValue(A_FSG_50_0_0_52,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_52_Start);
     elementsVal = getValue(A_FSG_50_0_0_52_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable Direction_Symbolic:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 3 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DistanceType:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Distance:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 2 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 4 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5      ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >>  8) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >> 16) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >> 24) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Unit:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 2 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable MainDescription:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Street:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param8_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_8_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_8_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param8[j];
        }
       }
      // Check if the current value of RecAdr enables the variable City:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param9_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_9_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_9_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param9[j];
        }
       }
      // Check if the current value of RecAdr enables the variable PostalCode:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param10_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_10_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 22-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 22-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_10_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 22-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 22-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param10[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_52_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable Direction_Symbolic:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 3 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DistanceType:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Distance:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 2 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 4 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5      ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >>  8) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >> 16) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >> 24) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Unit:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 2 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable MainDescription:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Street:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param8_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_8_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_8_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param8[j];
        }
       }
      // Check if the current value of RecAdr enables the variable City:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param9_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_9_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_9_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param9[j];
        }
       }
      // Check if the current value of RecAdr enables the variable PostalCode:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param10_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_10_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 22-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 22-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_10_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 22-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 22-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param10[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_50_0_0_52, data);
        Request_ByteSequence(LSGID, A_FSG_50_0_0_52_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_50_0_0_52_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_50_0_0_52_ID);
        }
        if(getValue(A_FSG_50_0_0_52_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_50_0_0_52_ID,getValueSize(A_FSG_50_0_0_52));
        }
        A_FSG_50_0_0_52Status_BTN_already_pressed = 0;
    }
}
A_FSG_50_0_0_52_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[1829];
    byte stringValue[1829];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_52_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_52_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_52_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_52);
        getValue(A_FSG_50_0_0_52,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_52_Start);
     elementsVal = getValue(A_FSG_50_0_0_52_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable Direction_Symbolic:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 3 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DistanceType:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Distance:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 2 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 4 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5      ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >>  8) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >> 16) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >> 24) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Unit:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 2 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable MainDescription:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Street:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param8_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_8_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_8_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param8[j];
        }
       }
      // Check if the current value of RecAdr enables the variable City:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param9_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_9_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_9_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param9[j];
        }
       }
      // Check if the current value of RecAdr enables the variable PostalCode:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param10_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_10_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 22-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 22-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_10_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 22-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 22-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param10[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_52_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable Direction_Symbolic:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 3 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable POI_Type:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DistanceType:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Distance:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 2 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 4 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5      ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >>  8) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >> 16) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param5 >> 24) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Unit:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 2 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_52_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable MainDescription:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) || 5 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Street:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param8_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_8_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_8_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_8 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param8[j];
        }
       }
      // Check if the current value of RecAdr enables the variable City:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param9_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_9_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 91-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 91-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_9_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 91-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_9 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 91-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param9[j];
        }
       }
      // Check if the current value of RecAdr enables the variable PostalCode:
      if( 0 || 0 == getValue( A_FSG_50_0_0_52_RecAdr ) || 1 == getValue( A_FSG_50_0_0_52_RecAdr ) || 4 == getValue( A_FSG_50_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_52_ArrayDataList[i].Param10_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_52_Data_10_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 22-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 22-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_52_Data_10_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 22-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_10 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 22-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_52_ArrayDataList[i].Param10[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_50_0_0_52_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_50_0_0_52
{
    byte temp[1829];
    getValue(A_FSG_50_0_0_52, temp);
    putValue(A_FSG_50_0_0_52_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_52_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_52_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_52_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_52_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_50_0_0_52_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_50_0_0_52_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_52_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_52_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_52_IndexSize))
    {
        putValue(A_FSG_50_0_0_52_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_50_0_0_52_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_50_0_0_52_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_50_0_0_52_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_50_0_0_52_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_52_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_52_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_52_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_52_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_52_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_52_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_52_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_52_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_52_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_52_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_52_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_52_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_52_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_50_0_0_52, head, headLength); 
}

on envVar A_FSG_50_0_0_52_RecAdr
{
    A_FSG_50_0_0_52_GenerateStatus();
}

on envVar A_FSG_50_0_0_52_Shift
{
    A_FSG_50_0_0_52_GenerateStatus();
}

on envVar A_FSG_50_0_0_52_Direction
{
    A_FSG_50_0_0_52_GenerateStatus();
}

on envVar A_FSG_50_0_0_52_Start
{
    A_FSG_50_0_0_52_GenerateStatus();
}

on envVar A_FSG_50_0_0_52_Elements
{
    A_FSG_50_0_0_52_GenerateStatus();
}

on envVar A_FSG_50_0_0_52_IndexSize
{
    A_FSG_50_0_0_52_GenerateStatus();
}
on envVar A_FSG_50_0_0_52_TransPos
{
    A_FSG_50_0_0_52_GenerateStatus();
}
A_FSG_50_0_0_52_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_52_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_52_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_52_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_52_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_52_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_52_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_52_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_52_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_52_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_52_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_52_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_50_0_0_52_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_52_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_52_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_50_0_0_52_Changed, head, 3); 
    }
}

on envVar A_FSG_50_0_0_52_Changed_RecAdr
{
    A_FSG_50_0_0_52_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_52_Changed_Shift
{
    A_FSG_50_0_0_52_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_52_Changed_Direction
{
    A_FSG_50_0_0_52_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_52_Changed_Start
{
    A_FSG_50_0_0_52_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_52_Changed_Elements
{
    A_FSG_50_0_0_52_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_52_Changed_IndexSize
{
    A_FSG_50_0_0_52_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_52_Changed_TransPos
{
    A_FSG_50_0_0_52_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_52_SetGet
{
    byte temp[1829];
    getValue(A_FSG_50_0_0_52_SetGet, temp);
    putValue(A_FSG_50_0_0_52_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_52_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_52_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_52_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_52_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_52_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_52_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_52_SetGet_IndexSize))
    {
        putValue(A_FSG_50_0_0_52_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_50_0_0_52_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_50_0_0_52_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_50_0_0_52_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_50_0_0_52_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_50_0_0_52_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_50_0_0_52_ArrayDataList[i].Param1 = 0;
		A_FSG_50_0_0_52_ArrayDataList[i].Param2 = 0;
		A_FSG_50_0_0_52_ArrayDataList[i].Param3 = 0;
		A_FSG_50_0_0_52_ArrayDataList[i].Param4 = 0;
		A_FSG_50_0_0_52_ArrayDataList[i].Param5 = 0;
		A_FSG_50_0_0_52_ArrayDataList[i].Param6 = 0;
		for(j=0; j<91; j++)
			A_FSG_50_0_0_52_ArrayDataList[i].Param7[j] = 0;
		A_FSG_50_0_0_52_ArrayDataList[i].Param7_Length = 0;
		A_FSG_50_0_0_52_Data_7_LenList[i] = 0;
		for(j=0; j<91; j++)
			A_FSG_50_0_0_52_ArrayDataList[i].Param8[j] = 0;
		A_FSG_50_0_0_52_ArrayDataList[i].Param8_Length = 0;
		A_FSG_50_0_0_52_Data_8_LenList[i] = 0;
		for(j=0; j<91; j++)
			A_FSG_50_0_0_52_ArrayDataList[i].Param9[j] = 0;
		A_FSG_50_0_0_52_ArrayDataList[i].Param9_Length = 0;
		A_FSG_50_0_0_52_Data_9_LenList[i] = 0;
		for(j=0; j<22; j++)
			A_FSG_50_0_0_52_ArrayDataList[i].Param10[j] = 0;
		A_FSG_50_0_0_52_ArrayDataList[i].Param10_Length = 0;
		A_FSG_50_0_0_52_Data_10_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_50_0_0_52_fileSelector, gListPath);
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //Direction_Symbolic
						A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //POI_Type
						A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //DistanceType
						A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //Distance
						A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //Unit
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Direction_Symbolic
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //POI_Type
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //DistanceType
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Distance
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //Unit
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //MainDescription
								if(paramPos < 90)
								{
									A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param7_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 8: //Street
								if(paramPos < 90)
								{
									A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param8_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 9: //City
								if(paramPos < 90)
								{
									A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param9[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param9_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 10: //PostalCode
								if(paramPos < 21)
								{
									A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param10[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_52_ArrayDataList[current_CSV_line-1].Param10_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_50_0_0_52_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_50_0_0_52_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_52_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_50_0_0_52_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_50_0_0_52_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			//writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_50_0_0_52_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_50_0_0_52_Data_1, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_52_Data_2, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_52_Data_3, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param3);
	putValue(A_FSG_50_0_0_52_Data_4, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param4);
	putValue(A_FSG_50_0_0_52_Data_5, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param5);
	putValue(A_FSG_50_0_0_52_Data_6, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param6);
	putValue(A_FSG_50_0_0_52_Data_7, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param7, A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param7_Length);
	putValue(A_FSG_50_0_0_52_Data_8, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param8, A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param8_Length);
	putValue(A_FSG_50_0_0_52_Data_9, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param9, A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param9_Length);
	putValue(A_FSG_50_0_0_52_Data_10, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param10, A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param10_Length);
}


on envVar A_FSG_50_0_0_52_generateData_Btn
{
	word i;
	dword elementsArray[14] = {1, 1, 1, 1, 4, 1, 91, 2, 91, 2, 91, 2, 22, 2};
	byte elementsTypeArray[14] = {0, 0, 0, 0, 0, 0, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF};
	dword elementsMaxSizeArray[14] = {255, 0xFF, 0xFF, 0xFF, 429496729, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0};
	byte tempArray[79248];
	if (A_FSG_50_0_0_52_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_52_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 52, 254 );
		for(i = 0; i < 254; i++)
		{
			memcpy(A_FSG_50_0_0_52_ArrayDataList[i], tempArray, (i * 312) );
			if(A_FSG_50_0_0_52_ArrayDataList[i].Param7_Length > 127 )
				A_FSG_50_0_0_52_Data_7_CntList[i] = 1;
			if(A_FSG_50_0_0_52_ArrayDataList[i].Param8_Length > 127 )
				A_FSG_50_0_0_52_Data_8_CntList[i] = 1;
			if(A_FSG_50_0_0_52_ArrayDataList[i].Param9_Length > 127 )
				A_FSG_50_0_0_52_Data_9_CntList[i] = 1;
			if(A_FSG_50_0_0_52_ArrayDataList[i].Param10_Length > 127 )
				A_FSG_50_0_0_52_Data_10_CntList[i] = 1;
		}
		A_FSG_50_0_0_52_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_50_0_0_52_Data_1, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_52_Data_2, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_52_Data_3, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param3);
	putValue(A_FSG_50_0_0_52_Data_4, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param4);
	putValue(A_FSG_50_0_0_52_Data_5, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param5);
	putValue(A_FSG_50_0_0_52_Data_6, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param6);
	putValue(A_FSG_50_0_0_52_Data_7, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param7, A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param7_Length);
	putValue(A_FSG_50_0_0_52_Data_8, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param8, A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param8_Length);
	putValue(A_FSG_50_0_0_52_Data_9, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param9, A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param9_Length);
	putValue(A_FSG_50_0_0_52_Data_10, A_FSG_50_0_0_52_ArrayDataList[ getValue( A_FSG_50_0_0_52_DataIndex) ].Param10, A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param10_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_50_0_0_52_DataIndex
{
    long index;
    long maxIndex = 254-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_50_0_0_52_Data_1, A_FSG_50_0_0_52_ArrayDataList[index].Param1);
    putValue(A_FSG_50_0_0_52_Data_2, A_FSG_50_0_0_52_ArrayDataList[index].Param2);
    putValue(A_FSG_50_0_0_52_Data_3, A_FSG_50_0_0_52_ArrayDataList[index].Param3);
    putValue(A_FSG_50_0_0_52_Data_4, A_FSG_50_0_0_52_ArrayDataList[index].Param4);
    putValue(A_FSG_50_0_0_52_Data_5, A_FSG_50_0_0_52_ArrayDataList[index].Param5);
    putValue(A_FSG_50_0_0_52_Data_6, A_FSG_50_0_0_52_ArrayDataList[index].Param6);
    putValue(A_FSG_50_0_0_52_Data_7_len, A_FSG_50_0_0_52_Data_7_LenList[index]);
    putValue(A_FSG_50_0_0_52_Data_7_cnt, A_FSG_50_0_0_52_Data_7_CntList[index]);
    putValue(A_FSG_50_0_0_52_Data_7, A_FSG_50_0_0_52_ArrayDataList[index].Param7, A_FSG_50_0_0_52_ArrayDataList[index].Param7_Length);
    putValue(A_FSG_50_0_0_52_Data_8_len, A_FSG_50_0_0_52_Data_8_LenList[index]);
    putValue(A_FSG_50_0_0_52_Data_8_cnt, A_FSG_50_0_0_52_Data_8_CntList[index]);
    putValue(A_FSG_50_0_0_52_Data_8, A_FSG_50_0_0_52_ArrayDataList[index].Param8, A_FSG_50_0_0_52_ArrayDataList[index].Param8_Length);
    putValue(A_FSG_50_0_0_52_Data_9_len, A_FSG_50_0_0_52_Data_9_LenList[index]);
    putValue(A_FSG_50_0_0_52_Data_9_cnt, A_FSG_50_0_0_52_Data_9_CntList[index]);
    putValue(A_FSG_50_0_0_52_Data_9, A_FSG_50_0_0_52_ArrayDataList[index].Param9, A_FSG_50_0_0_52_ArrayDataList[index].Param9_Length);
    putValue(A_FSG_50_0_0_52_Data_10_len, A_FSG_50_0_0_52_Data_10_LenList[index]);
    putValue(A_FSG_50_0_0_52_Data_10_cnt, A_FSG_50_0_0_52_Data_10_CntList[index]);
    putValue(A_FSG_50_0_0_52_Data_10, A_FSG_50_0_0_52_ArrayDataList[index].Param10, A_FSG_50_0_0_52_ArrayDataList[index].Param10_Length);

}
on envVar A_FSG_50_0_0_52_DataIndex_Incr
{
    long index;
    if(A_FSG_50_0_0_52_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_50_0_0_52_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_52_DataIndex);
        index++;
        putValue(A_FSG_50_0_0_52_DataIndex, index);
        A_FSG_50_0_0_52_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_52_DataIndex_Decr
{
    long index;
    if(A_FSG_50_0_0_52_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_50_0_0_52_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_52_DataIndex);
        index--;
        putValue(A_FSG_50_0_0_52_DataIndex, index);
        A_FSG_50_0_0_52_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_52_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_50_0_0_52_ID;
    data[2]=getValue(A_FSG_50_0_0_52_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_50_0_0_52
on envVar A_FSG_50_0_0_52_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_52",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_52",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_52",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_52_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_52", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_52",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_52",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_52",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_52_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_52", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_52_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_52_SegmEn,0);
           intertelegram_err(A_FSG_50_0_0_52_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_50_0_0_52_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_52_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_52_IntTlgEn,0);
           sequence_err(A_FSG_50_0_0_52_ID,getValueSize(A_FSG_50_0_0_52_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_50_0_0_52_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_50_0_0_52_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_50_0_0_52_Status",1);
 	}
}



A_FSG_50_0_0_52_SetInd () { /* leere Function*/ }

A_FSG_50_0_0_52_SetGetInd () { /* leere Function*/ }

A_FSG_50_0_0_52_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[1829];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_52_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_52_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_50_0_0_52_SetGet, head, 5);
                if(getValue(A_FSG_50_0_0_52_AT))
                {
                    putValue(A_FSG_50_0_0_52,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_50_0_0_52_SetGet, head, 3);
            if(getValue(A_FSG_50_0_0_52_AT))
            {
                putValue(A_FSG_50_0_0_52,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_50_0_0_52_AT))
        {
            putValue(A_FSG_50_0_0_52_RecAdr,recordAddressVal);
            putValue(A_FSG_50_0_0_52_Start, startVal);
            putValue(A_FSG_50_0_0_52_Elements, elementsVal);
            putValue(A_FSG_50_0_0_52_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_50_0_0_52_1
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_52_2_range // POI_List.TAID 
{
	@A_FSG_50_0_0_52_2 = @A_FSG_50_0_0_52_2_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_52_2
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_52_2, 1.0);
	@A_FSG_50_0_0_52_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_52_3_range // POI_List.TotalNumListElements 
{
	@A_FSG_50_0_0_52_3 = @A_FSG_50_0_0_52_3_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_52_3
{

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_52_3, 1.0);
	@A_FSG_50_0_0_52_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_52_Data_1_range // POI_List.Pos 
{
	@A_FSG_50_0_0_52_Data_1 = @A_FSG_50_0_0_52_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_52_Data_1
{

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_52_Data_1, 1.0);
	@A_FSG_50_0_0_52_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param1 = thisval;
}
on envVar A_FSG_50_0_0_52_Data_2
{

	//Update Childvalue (Enum)
	byte thisval; // Direction_Symbolic
	thisval = getValue(this);
    A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param2 = thisval;
}
on envVar A_FSG_50_0_0_52_Data_3
{

	//Update Childvalue (Enum)
	byte thisval; // POI_Type
	thisval = getValue(this);
    A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param3 = thisval;
}
on envVar A_FSG_50_0_0_52_Data_4
{

	//Update Childvalue (Enum)
	byte thisval; // DistanceType
	thisval = getValue(this);
    A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param4 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_52_Data_5_range // POI_List.Distance 
{
	@A_FSG_50_0_0_52_Data_5 = @A_FSG_50_0_0_52_Data_5_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_52_Data_5
{

	//Update Childvalue (Number)
	dword thisval; // Distance
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_52_Data_5, 0.1);
	@A_FSG_50_0_0_52_Data_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (dword)round((slider_value + (0) - (0)) / (0.1), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param5 = thisval;
}
on envVar A_FSG_50_0_0_52_Data_6
{

	//Update Childvalue (Enum)
	byte thisval; // Unit
	thisval = getValue(this);
    A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param6 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_52_Data_7_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_52_Data_7_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_52_Data_7_CntList[ getValue(A_FSG_50_0_0_52_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_52_Data_7_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_52_Data_7_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_52_Data_7_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 90 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 90);
		thisval = 90;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_52_Data_7_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param7_Length = thisval;
	A_FSG_50_0_0_52_Data_7_LenList[ getValue(A_FSG_50_0_0_52_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_52_Data_7_len, thisval);

}

on envVar A_FSG_50_0_0_52_Data_7
{

	//Update Childvalue (String)
	word i;
	byte thisval[91];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param7[i] = thisval[i];
    A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param7_Length = getValueSize(this);
    A_FSG_50_0_0_52_Data_7_LenList[getValue(A_FSG_50_0_0_52_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_52_Data_7_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_52_Data_8_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_52_Data_8_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_52_Data_8_CntList[ getValue(A_FSG_50_0_0_52_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_52_Data_8_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_52_Data_8_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_52_Data_8_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 90 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_8 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 90);
		thisval = 90;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_52_Data_8_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param8_Length = thisval;
	A_FSG_50_0_0_52_Data_8_LenList[ getValue(A_FSG_50_0_0_52_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_52_Data_8_len, thisval);

}

on envVar A_FSG_50_0_0_52_Data_8
{

	//Update Childvalue (String)
	word i;
	byte thisval[91];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param8[i] = thisval[i];
    A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param8_Length = getValueSize(this);
    A_FSG_50_0_0_52_Data_8_LenList[getValue(A_FSG_50_0_0_52_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_52_Data_8_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_52_Data_9_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_52_Data_9_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_52_Data_9_CntList[ getValue(A_FSG_50_0_0_52_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_52_Data_9_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_52_Data_9_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_52_Data_9_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 90 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_9 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 90);
		thisval = 90;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_52_Data_9_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param9_Length = thisval;
	A_FSG_50_0_0_52_Data_9_LenList[ getValue(A_FSG_50_0_0_52_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_52_Data_9_len, thisval);

}

on envVar A_FSG_50_0_0_52_Data_9
{

	//Update Childvalue (String)
	word i;
	byte thisval[91];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param9[i] = thisval[i];
    A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param9_Length = getValueSize(this);
    A_FSG_50_0_0_52_Data_9_LenList[getValue(A_FSG_50_0_0_52_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_52_Data_9_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_52_Data_10_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_52_Data_10_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_52_Data_10_CntList[ getValue(A_FSG_50_0_0_52_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_52_Data_10_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_52_Data_10_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_52_Data_10_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 21 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_52_Data_10 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 21);
		thisval = 21;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_52_Data_10_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param10_Length = thisval;
	A_FSG_50_0_0_52_Data_10_LenList[ getValue(A_FSG_50_0_0_52_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_52_Data_10_len, thisval);

}

on envVar A_FSG_50_0_0_52_Data_10
{

	//Update Childvalue (String)
	word i;
	byte thisval[22];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param10[i] = thisval[i];
    A_FSG_50_0_0_52_ArrayDataList[getValue(A_FSG_50_0_0_52_DataIndex)].Param10_Length = getValueSize(this);
    A_FSG_50_0_0_52_Data_10_LenList[getValue(A_FSG_50_0_0_52_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_52_Data_10_len, getValueSize(this));
}
on envVar A_FSG_50_0_0_52_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_52_2_SetGet_range // POI_List.TAID 
{
	@A_FSG_50_0_0_52_2_SetGet = @A_FSG_50_0_0_52_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_52_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_52_2_SetGet, 1.0);
	@A_FSG_50_0_0_52_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_53_ErrCode
{
       if(gP_FSG_50_0_0_53_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_53", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_53_ErrCode = 1;
}
on envVar P_FSG_50_0_0_53Status_BTN
{
	byte BAPTemp[6];
   if (P_FSG_50_0_0_53Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_53_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_53",MakeRGB(255,255,255));
      P_FSG_50_0_0_53Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_53, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_53_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_53));
      P_FSG_50_0_0_53Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_53_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_53_ID;
    data[2]=getValue(P_FSG_50_0_0_53_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_53
on envVar P_FSG_50_0_0_53_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_53",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_53",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_53",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_53", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_53",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_53",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_53",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_53", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_53 // bus value of FSG_Setup (53).
{
	// opcodes: Error-Status
	byte param1; // VoiceGuidance
	byte param2; // Supported_POI_Types
	byte param3; // FunctionSupport
	byte param4; // Dummy2
	byte param5; // Dummy3
	byte param6; // Dummy4
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[6];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_53, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_53_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_53_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_50_0_0_53_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_50_0_0_53_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_50_0_0_53_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_50_0_0_53_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_50_0_0_53_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // VoiceGuidance
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_53_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_53_1,thisval);
}

on envVar P_FSG_50_0_0_53_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // VoiceGuidance
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_53_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_53_1,thisval);
}

on envVar P_FSG_50_0_0_53_1_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // VoiceGuidance
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_53_1);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_53_1,thisval);
}

on envVar P_FSG_50_0_0_53_1 // FSG_Setup.VoiceGuidance
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // VoiceGuidance
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_53_1_0, 1);
	else
		putValue(P_FSG_50_0_0_53_1_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_50_0_0_53_1_1, 1);
	else
		putValue(P_FSG_50_0_0_53_1_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_50_0_0_53_1_2, 1);
	else
		putValue(P_FSG_50_0_0_53_1_2, 0);

    // Update superval
	getValue(P_FSG_50_0_0_53, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_53,superval);
}

on envVar P_FSG_50_0_0_53_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Supported_POI_Types
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_53_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_53_2,thisval);
}

on envVar P_FSG_50_0_0_53_2 // FSG_Setup.Supported_POI_Types
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Supported_POI_Types
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_53_2_0, 1);
	else
		putValue(P_FSG_50_0_0_53_2_0, 0);

    // Update superval
	getValue(P_FSG_50_0_0_53, superval);
	superval[1]=thisval;
	putValue(P_FSG_50_0_0_53,superval);
}

on envVar P_FSG_50_0_0_53_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FunctionSupport
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_53_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_53_3,thisval);
}

on envVar P_FSG_50_0_0_53_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FunctionSupport
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_53_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_53_3,thisval);
}

on envVar P_FSG_50_0_0_53_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FunctionSupport
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_53_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_53_3,thisval);
}

on envVar P_FSG_50_0_0_53_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FunctionSupport
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_53_3);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_53_3,thisval);
}

on envVar P_FSG_50_0_0_53_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FunctionSupport
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_53_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_50_0_0_53_3,thisval);
}

on envVar P_FSG_50_0_0_53_3_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FunctionSupport
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_53_3);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_50_0_0_53_3,thisval);
}

on envVar P_FSG_50_0_0_53_3 // FSG_Setup.FunctionSupport
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // FunctionSupport
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_53_3_0, 1);
	else
		putValue(P_FSG_50_0_0_53_3_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_50_0_0_53_3_1, 1);
	else
		putValue(P_FSG_50_0_0_53_3_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_50_0_0_53_3_2, 1);
	else
		putValue(P_FSG_50_0_0_53_3_2, 0);
	if(thisval&(mask<<3))
		putValue(P_FSG_50_0_0_53_3_3, 1);
	else
		putValue(P_FSG_50_0_0_53_3_3, 0);
	if(thisval&(mask<<4))
		putValue(P_FSG_50_0_0_53_3_4, 1);
	else
		putValue(P_FSG_50_0_0_53_3_4, 0);
	if(thisval&(mask<<5))
		putValue(P_FSG_50_0_0_53_3_5, 1);
	else
		putValue(P_FSG_50_0_0_53_3_5, 0);

    // Update superval
	getValue(P_FSG_50_0_0_53, superval);
	superval[2]=thisval;
	putValue(P_FSG_50_0_0_53,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_53_4_range // FSG_Setup.Dummy2 
{
	@P_FSG_50_0_0_53_4 = @P_FSG_50_0_0_53_4_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_53_4 // FSG_Setup.Dummy2
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Dummy2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_50_0_0_53_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_53, superval);
	superval[3]=thisval;
	putValue(P_FSG_50_0_0_53,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_53_5_range // FSG_Setup.Dummy3 
{
	@P_FSG_50_0_0_53_5 = @P_FSG_50_0_0_53_5_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_53_5 // FSG_Setup.Dummy3
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Dummy3
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_50_0_0_53_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_53, superval);
	superval[4]=thisval;
	putValue(P_FSG_50_0_0_53,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_53_6_range // FSG_Setup.Dummy4 
{
	@P_FSG_50_0_0_53_6 = @P_FSG_50_0_0_53_6_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_53_6 // FSG_Setup.Dummy4
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Dummy4
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_50_0_0_53_6_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_53, superval);
	superval[5]=thisval;
	putValue(P_FSG_50_0_0_53,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_54_ErrCode
{
       if(gP_FSG_50_0_0_54_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_54", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_54_ErrCode = 1;
}
on envVar P_FSG_50_0_0_54Status_BTN
{
    if (P_FSG_50_0_0_54Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_50_0_0_54_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_54",MakeRGB(255,255,255));
       P_FSG_50_0_0_54Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_50_0_0_54_ID, Data_REQ, getValue(P_FSG_50_0_0_54));
      P_FSG_50_0_0_54Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_54_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_54_ID;
    data[2]=getValue(P_FSG_50_0_0_54_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_54
on envVar P_FSG_50_0_0_54_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_54",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_54",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_54",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_54", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_54",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_54",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_54",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_54", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_54 // bus value of Map_Presentation (54).
{
	// opcodes: Error-Status
	byte param1; // ASG_HMI_State
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_50_0_0_54);
	putValue(P_FSG_50_0_0_54_1, param1);
}

on envVar P_FSG_50_0_0_54_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ASG_HMI_State
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_54_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_54_1,thisval);
}

on envVar P_FSG_50_0_0_54_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ASG_HMI_State
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_54_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_54_1,thisval);
}

on envVar P_FSG_50_0_0_54_1_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ASG_HMI_State
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_54_1);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_54_1,thisval);
}

on envVar P_FSG_50_0_0_54_1 // Map_Presentation.ASG_HMI_State
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // ASG_HMI_State
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_54_1_0, 1);
	else
		putValue(P_FSG_50_0_0_54_1_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_50_0_0_54_1_1, 1);
	else
		putValue(P_FSG_50_0_0_54_1_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_50_0_0_54_1_2, 1);
	else
		putValue(P_FSG_50_0_0_54_1_2, 0);

    // Update superval
	superval = getValue(P_FSG_50_0_0_54);
	superval = thisval;
	putValue(P_FSG_50_0_0_54,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_55_ErrCode
{
       if(gP_FSG_50_0_0_55_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_55", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_55_ErrCode = 1;
}
on envVar P_FSG_50_0_0_55Status_BTN
{
	byte BAPTemp[4];
   if (P_FSG_50_0_0_55Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_55_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_55",MakeRGB(255,255,255));
      P_FSG_50_0_0_55Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_55, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_55_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_55));
      P_FSG_50_0_0_55Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_55_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_55_ID;
    data[2]=getValue(P_FSG_50_0_0_55_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_55
on envVar P_FSG_50_0_0_55_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_55",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_55",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_55",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_55", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_55",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_55",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_55",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_55", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_55 // bus value of ManeuverState (55).
{
	// opcodes: Error-Status
	byte param1; // State
	byte param2; // Dummy1
	byte param3; // Dummy2
	byte param4; // Dummy3
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[4];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 4; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_55, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_55_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_55_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_50_0_0_55_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_50_0_0_55_4, round((param4 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_50_0_0_55_1 // ManeuverState.State
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // State
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_55, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_55,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_55_2_range // ManeuverState.Dummy1 
{
	@P_FSG_50_0_0_55_2 = @P_FSG_50_0_0_55_2_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_55_2 // ManeuverState.Dummy1
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // Dummy1
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_55_2, 1.0);
	@P_FSG_50_0_0_55_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_55, superval);
	superval[1]=thisval;
	putValue(P_FSG_50_0_0_55,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_55_3_range // ManeuverState.Dummy2 
{
	@P_FSG_50_0_0_55_3 = @P_FSG_50_0_0_55_3_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_55_3 // ManeuverState.Dummy2
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // Dummy2
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_55_3, 1.0);
	@P_FSG_50_0_0_55_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_55, superval);
	superval[2]=thisval;
	putValue(P_FSG_50_0_0_55,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_55_4_range // ManeuverState.Dummy3 
{
	@P_FSG_50_0_0_55_4 = @P_FSG_50_0_0_55_4_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_55_4 // ManeuverState.Dummy3
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // Dummy3
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_55_4, 1.0);
	@P_FSG_50_0_0_55_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_55, superval);
	superval[3]=thisval;
	putValue(P_FSG_50_0_0_55,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_56_ErrCode
{
       if(gP_FSG_50_0_0_56_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_56", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_56_ErrCode = 1;
}
on envVar P_FSG_50_0_0_56Status_BTN
{
	byte BAPTemp[2];
   if (P_FSG_50_0_0_56Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_56_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_56",MakeRGB(255,255,255));
      P_FSG_50_0_0_56Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_56, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_56_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_56));
      P_FSG_50_0_0_56Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_56_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_56_ID;
    data[2]=getValue(P_FSG_50_0_0_56_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_56
on envVar P_FSG_50_0_0_56_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_56",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_56",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_56",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_56", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_56",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_56",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_56",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_56", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_56 // bus value of ETC_Status (56).
{
	// opcodes: Error-Status
	byte param1; // CardStatus
	byte param2; // Extension1
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[2];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_56, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_56_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_56_2, round((param2 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_50_0_0_56_1 // ETC_Status.CardStatus
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // CardStatus
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_56, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_56,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_56_2_range // ETC_Status.Extension1 
{
	@P_FSG_50_0_0_56_2 = @P_FSG_50_0_0_56_2_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_56_2 // ETC_Status.Extension1
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_50_0_0_56_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_56, superval);
	superval[1]=thisval;
	putValue(P_FSG_50_0_0_56,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_57_ErrCode
{
       if(gP_FSG_50_0_0_57_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_57", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_57_ErrCode = 1;
}
on envVar P_FSG_50_0_0_57Status_BTN
{
	byte BAPTemp[6];
   if (P_FSG_50_0_0_57Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_50_0_0_57_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_57",MakeRGB(255,255,255));
      P_FSG_50_0_0_57Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_50_0_0_57, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_50_0_0_57_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_57));
      P_FSG_50_0_0_57Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_50_0_0_57_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_57_ID;
    data[2]=getValue(P_FSG_50_0_0_57_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_57
on envVar P_FSG_50_0_0_57_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_57",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_57",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_57",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_57", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_57",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_57",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_57",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_57", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_50_0_0_57 // bus value of MapContentSettings (57).
{
	// opcodes: Error-Status
	byte param1; // AvailableContents
	byte param2; // ContentStatus
	byte param3; // Extension1
	byte param4; // Extension2
	byte param5; // Extension3
	byte param6; // Extension4
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[6];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_57, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_50_0_0_57_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_57_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_50_0_0_57_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_50_0_0_57_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_50_0_0_57_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_50_0_0_57_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_50_0_0_57_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AvailableContents
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_57_1,thisval);
}

on envVar P_FSG_50_0_0_57_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AvailableContents
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_57_1,thisval);
}

on envVar P_FSG_50_0_0_57_1_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AvailableContents
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_1);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_57_1,thisval);
}

on envVar P_FSG_50_0_0_57_1_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AvailableContents
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_1);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_57_1,thisval);
}

on envVar P_FSG_50_0_0_57_1_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AvailableContents
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_1);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_50_0_0_57_1,thisval);
}

on envVar P_FSG_50_0_0_57_1_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AvailableContents
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_1);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_50_0_0_57_1,thisval);
}

on envVar P_FSG_50_0_0_57_1_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AvailableContents
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_1);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_50_0_0_57_1,thisval);
}

on envVar P_FSG_50_0_0_57_1_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AvailableContents
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_1);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_50_0_0_57_1,thisval);
}

on envVar P_FSG_50_0_0_57_1 // MapContentSettings.AvailableContents
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // AvailableContents
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_57_1_0, 1);
	else
		putValue(P_FSG_50_0_0_57_1_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_50_0_0_57_1_1, 1);
	else
		putValue(P_FSG_50_0_0_57_1_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_50_0_0_57_1_2, 1);
	else
		putValue(P_FSG_50_0_0_57_1_2, 0);
	if(thisval&(mask<<3))
		putValue(P_FSG_50_0_0_57_1_3, 1);
	else
		putValue(P_FSG_50_0_0_57_1_3, 0);
	if(thisval&(mask<<4))
		putValue(P_FSG_50_0_0_57_1_4, 1);
	else
		putValue(P_FSG_50_0_0_57_1_4, 0);
	if(thisval&(mask<<5))
		putValue(P_FSG_50_0_0_57_1_5, 1);
	else
		putValue(P_FSG_50_0_0_57_1_5, 0);
	if(thisval&(mask<<6))
		putValue(P_FSG_50_0_0_57_1_6, 1);
	else
		putValue(P_FSG_50_0_0_57_1_6, 0);
	if(thisval&(mask<<7))
		putValue(P_FSG_50_0_0_57_1_7, 1);
	else
		putValue(P_FSG_50_0_0_57_1_7, 0);

    // Update superval
	getValue(P_FSG_50_0_0_57, superval);
	superval[0]=thisval;
	putValue(P_FSG_50_0_0_57,superval);
}

on envVar P_FSG_50_0_0_57_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ContentStatus
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_57_2,thisval);
}

on envVar P_FSG_50_0_0_57_2_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ContentStatus
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_2);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_57_2,thisval);
}

on envVar P_FSG_50_0_0_57_2_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ContentStatus
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_2);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_50_0_0_57_2,thisval);
}

on envVar P_FSG_50_0_0_57_2_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ContentStatus
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_2);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_50_0_0_57_2,thisval);
}

on envVar P_FSG_50_0_0_57_2_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ContentStatus
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_2);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_50_0_0_57_2,thisval);
}

on envVar P_FSG_50_0_0_57_2_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ContentStatus
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_2);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_50_0_0_57_2,thisval);
}

on envVar P_FSG_50_0_0_57_2_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ContentStatus
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_2);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_50_0_0_57_2,thisval);
}

on envVar P_FSG_50_0_0_57_2_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ContentStatus
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_57_2);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_50_0_0_57_2,thisval);
}

on envVar P_FSG_50_0_0_57_2 // MapContentSettings.ContentStatus
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // ContentStatus
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_50_0_0_57_2_0, 1);
	else
		putValue(P_FSG_50_0_0_57_2_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_50_0_0_57_2_1, 1);
	else
		putValue(P_FSG_50_0_0_57_2_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_50_0_0_57_2_2, 1);
	else
		putValue(P_FSG_50_0_0_57_2_2, 0);
	if(thisval&(mask<<3))
		putValue(P_FSG_50_0_0_57_2_3, 1);
	else
		putValue(P_FSG_50_0_0_57_2_3, 0);
	if(thisval&(mask<<4))
		putValue(P_FSG_50_0_0_57_2_4, 1);
	else
		putValue(P_FSG_50_0_0_57_2_4, 0);
	if(thisval&(mask<<5))
		putValue(P_FSG_50_0_0_57_2_5, 1);
	else
		putValue(P_FSG_50_0_0_57_2_5, 0);
	if(thisval&(mask<<6))
		putValue(P_FSG_50_0_0_57_2_6, 1);
	else
		putValue(P_FSG_50_0_0_57_2_6, 0);
	if(thisval&(mask<<7))
		putValue(P_FSG_50_0_0_57_2_7, 1);
	else
		putValue(P_FSG_50_0_0_57_2_7, 0);

    // Update superval
	getValue(P_FSG_50_0_0_57, superval);
	superval[1]=thisval;
	putValue(P_FSG_50_0_0_57,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_57_3_range // MapContentSettings.Extension1 
{
	@P_FSG_50_0_0_57_3 = @P_FSG_50_0_0_57_3_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_57_3 // MapContentSettings.Extension1
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_50_0_0_57_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_57, superval);
	superval[2]=thisval;
	putValue(P_FSG_50_0_0_57,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_57_4_range // MapContentSettings.Extension2 
{
	@P_FSG_50_0_0_57_4 = @P_FSG_50_0_0_57_4_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_57_4 // MapContentSettings.Extension2
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_50_0_0_57_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_57, superval);
	superval[3]=thisval;
	putValue(P_FSG_50_0_0_57,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_57_5_range // MapContentSettings.Extension3 
{
	@P_FSG_50_0_0_57_5 = @P_FSG_50_0_0_57_5_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_57_5 // MapContentSettings.Extension3
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension3
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_50_0_0_57_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_57, superval);
	superval[4]=thisval;
	putValue(P_FSG_50_0_0_57,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_57_6_range // MapContentSettings.Extension4 
{
	@P_FSG_50_0_0_57_6 = @P_FSG_50_0_0_57_6_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_57_6 // MapContentSettings.Extension4
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension4
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_50_0_0_57_6_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_57, superval);
	superval[5]=thisval;
	putValue(P_FSG_50_0_0_57,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_50_0_0_58_ErrCode
{
       if(gA_FSG_50_0_0_58_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_58", MakeRGB(255,255,255));
       }
       gA_FSG_50_0_0_58_ErrCode = 1;
}
on envVar A_FSG_50_0_0_58Changed_BTN
{
    byte data[1874]; 
    byte stringValue[1874];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_50_0_0_58Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_58_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_58",MakeRGB(255,255,255));
        A_FSG_50_0_0_58Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_58_Changed);
        getValue(A_FSG_50_0_0_58_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_58_Changed_Start);
     elementsVal = getValue(A_FSG_50_0_0_58_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_58_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 58");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_58_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_58_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 58");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_50_0_0_58_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_50_0_0_58_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_50_0_0_58_ID);
       }
       if(getValue(A_FSG_50_0_0_58_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_50_0_0_58_ID,getValueSize(A_FSG_50_0_0_58_Changed));
       }
        A_FSG_50_0_0_58Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_58Status_BTN
{
    byte data[1874 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[1874];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_50_0_0_58Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_58_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_58",MakeRGB(255,255,255));
        A_FSG_50_0_0_58Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_58_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_58_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_58_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_58);
        getValue(A_FSG_50_0_0_58,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_58_Start);
     elementsVal = getValue(A_FSG_50_0_0_58_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_58_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 58");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable StreamType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IPv6_Address:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_58_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_58_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_58_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable UDP_Port:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable URI:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_58_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_58_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 602-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 602-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_58_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 602-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 602-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param5[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_58_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_58_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 58");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable StreamType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IPv6_Address:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_58_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_58_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_58_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable UDP_Port:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable URI:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_58_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_58_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 602-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 602-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_58_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 602-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 602-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param5[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_50_0_0_58, data);
        Request_ByteSequence(LSGID, A_FSG_50_0_0_58_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_50_0_0_58_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_50_0_0_58_ID);
        }
        if(getValue(A_FSG_50_0_0_58_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_50_0_0_58_ID,getValueSize(A_FSG_50_0_0_58));
        }
        A_FSG_50_0_0_58Status_BTN_already_pressed = 0;
    }
}
A_FSG_50_0_0_58_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[1874];
    byte stringValue[1874];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_58_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_58_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_58_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_58);
        getValue(A_FSG_50_0_0_58,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_58_Start);
     elementsVal = getValue(A_FSG_50_0_0_58_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_58_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 58");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable StreamType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IPv6_Address:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_58_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_58_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_58_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable UDP_Port:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable URI:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_58_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_58_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 602-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 602-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_58_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 602-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 602-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param5[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_58_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_58_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 58");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable StreamType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IPv6_Address:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_58_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_58_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_58_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable UDP_Port:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) || 2 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_58_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable URI:
      if( 0 || 1 == getValue( A_FSG_50_0_0_58_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_58_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_58_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 602-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 602-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_58_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 602-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 602-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_58_ArrayDataList[i].Param5[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_50_0_0_58_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_50_0_0_58
{
    byte temp[1874];
    getValue(A_FSG_50_0_0_58, temp);
    putValue(A_FSG_50_0_0_58_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_58_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_58_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_58_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_58_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_50_0_0_58_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_50_0_0_58_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_58_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_58_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_58_IndexSize))
    {
        putValue(A_FSG_50_0_0_58_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_50_0_0_58_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_50_0_0_58_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_50_0_0_58_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_50_0_0_58_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_58_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_58_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_58_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_58_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_58_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_58_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_58_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_58_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_58_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_58_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_58_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_58_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_58_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_50_0_0_58, head, headLength); 
}

on envVar A_FSG_50_0_0_58_RecAdr
{
    A_FSG_50_0_0_58_GenerateStatus();
}

on envVar A_FSG_50_0_0_58_Shift
{
    A_FSG_50_0_0_58_GenerateStatus();
}

on envVar A_FSG_50_0_0_58_Direction
{
    A_FSG_50_0_0_58_GenerateStatus();
}

on envVar A_FSG_50_0_0_58_Start
{
    A_FSG_50_0_0_58_GenerateStatus();
}

on envVar A_FSG_50_0_0_58_Elements
{
    A_FSG_50_0_0_58_GenerateStatus();
}

on envVar A_FSG_50_0_0_58_IndexSize
{
    A_FSG_50_0_0_58_GenerateStatus();
}
on envVar A_FSG_50_0_0_58_TransPos
{
    A_FSG_50_0_0_58_GenerateStatus();
}
A_FSG_50_0_0_58_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_58_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_58_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_58_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_58_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_58_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_58_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_58_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_58_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_58_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_58_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_58_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_50_0_0_58_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_58_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_58_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_50_0_0_58_Changed, head, 3); 
    }
}

on envVar A_FSG_50_0_0_58_Changed_RecAdr
{
    A_FSG_50_0_0_58_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_58_Changed_Shift
{
    A_FSG_50_0_0_58_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_58_Changed_Direction
{
    A_FSG_50_0_0_58_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_58_Changed_Start
{
    A_FSG_50_0_0_58_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_58_Changed_Elements
{
    A_FSG_50_0_0_58_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_58_Changed_IndexSize
{
    A_FSG_50_0_0_58_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_58_Changed_TransPos
{
    A_FSG_50_0_0_58_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_58_SetGet
{
    byte temp[1874];
    getValue(A_FSG_50_0_0_58_SetGet, temp);
    putValue(A_FSG_50_0_0_58_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_58_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_58_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_58_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_58_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_58_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_58_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_58_SetGet_IndexSize))
    {
        putValue(A_FSG_50_0_0_58_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_50_0_0_58_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_50_0_0_58_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_50_0_0_58_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_50_0_0_58_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";


	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_50_0_0_58_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_50_0_0_58_ArrayDataList[i].Param1 = 0;
		A_FSG_50_0_0_58_ArrayDataList[i].Param2 = 0;
		for(j=0; j<17; j++)
			A_FSG_50_0_0_58_ArrayDataList[i].Param3[j] = 0;
		A_FSG_50_0_0_58_ArrayDataList[i].Param3_Length = 0;
		A_FSG_50_0_0_58_Data_3_LenList[i] = 0;
		A_FSG_50_0_0_58_ArrayDataList[i].Param4 = 0;
		for(j=0; j<602; j++)
			A_FSG_50_0_0_58_ArrayDataList[i].Param5[j] = 0;
		A_FSG_50_0_0_58_ArrayDataList[i].Param5_Length = 0;
		A_FSG_50_0_0_58_Data_5_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_50_0_0_58_fileSelector, gListPath);
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						A_FSG_50_0_0_58_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_50_0_0_58_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //StreamType
						A_FSG_50_0_0_58_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //UDP_Port
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //StreamType
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //IPv6_Address
								if(paramPos < 16)
								{
									A_FSG_50_0_0_58_ArrayDataList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_58_ArrayDataList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 4: //UDP_Port
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //URI
								if(paramPos < 600)
								{
									A_FSG_50_0_0_58_ArrayDataList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_58_ArrayDataList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_50_0_0_58_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_50_0_0_58_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_58_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_50_0_0_58_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_50_0_0_58_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			//writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_50_0_0_58_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_50_0_0_58_Data_1, A_FSG_50_0_0_58_ArrayDataList[ getValue( A_FSG_50_0_0_58_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_58_Data_2, A_FSG_50_0_0_58_ArrayDataList[ getValue( A_FSG_50_0_0_58_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_58_Data_3, A_FSG_50_0_0_58_ArrayDataList[ getValue( A_FSG_50_0_0_58_DataIndex) ].Param3, A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param3_Length);
	putValue(A_FSG_50_0_0_58_Data_4, A_FSG_50_0_0_58_ArrayDataList[ getValue( A_FSG_50_0_0_58_DataIndex) ].Param4);
	putValue(A_FSG_50_0_0_58_Data_5, A_FSG_50_0_0_58_ArrayDataList[ getValue( A_FSG_50_0_0_58_DataIndex) ].Param5, A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param5_Length);
}


on envVar A_FSG_50_0_0_58_generateData_Btn
{
	word i;
	dword elementsArray[7] = {1, 1, 17, 2, 2, 602, 2};
	byte elementsTypeArray[7] = {0, 0, 0xE, 0xF, 0, 0xE, 0xF};
	dword elementsMaxSizeArray[7] = {255, 0xFF, 0, 0, 65535, 0, 0};
	byte tempArray[159258];
	if (A_FSG_50_0_0_58_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_58_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 58, 254 );
		for(i = 0; i < 254; i++)
		{
			memcpy(A_FSG_50_0_0_58_ArrayDataList[i], tempArray, (i * 627) );
			if(A_FSG_50_0_0_58_ArrayDataList[i].Param3_Length > 127 )
				A_FSG_50_0_0_58_Data_3_CntList[i] = 1;
			if(A_FSG_50_0_0_58_ArrayDataList[i].Param5_Length > 127 )
				A_FSG_50_0_0_58_Data_5_CntList[i] = 1;
		}
		A_FSG_50_0_0_58_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_50_0_0_58_Data_1, A_FSG_50_0_0_58_ArrayDataList[ getValue( A_FSG_50_0_0_58_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_58_Data_2, A_FSG_50_0_0_58_ArrayDataList[ getValue( A_FSG_50_0_0_58_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_58_Data_3, A_FSG_50_0_0_58_ArrayDataList[ getValue( A_FSG_50_0_0_58_DataIndex) ].Param3, A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param3_Length);
	putValue(A_FSG_50_0_0_58_Data_4, A_FSG_50_0_0_58_ArrayDataList[ getValue( A_FSG_50_0_0_58_DataIndex) ].Param4);
	putValue(A_FSG_50_0_0_58_Data_5, A_FSG_50_0_0_58_ArrayDataList[ getValue( A_FSG_50_0_0_58_DataIndex) ].Param5, A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param5_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_50_0_0_58_DataIndex
{
    long index;
    long maxIndex = 254-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_50_0_0_58_Data_1, A_FSG_50_0_0_58_ArrayDataList[index].Param1);
    putValue(A_FSG_50_0_0_58_Data_2, A_FSG_50_0_0_58_ArrayDataList[index].Param2);
    putValue(A_FSG_50_0_0_58_Data_3_len, A_FSG_50_0_0_58_Data_3_LenList[index]);
    putValue(A_FSG_50_0_0_58_Data_3_cnt, A_FSG_50_0_0_58_Data_3_CntList[index]);
    putValue(A_FSG_50_0_0_58_Data_3, A_FSG_50_0_0_58_ArrayDataList[index].Param3, A_FSG_50_0_0_58_ArrayDataList[index].Param3_Length);
    putValue(A_FSG_50_0_0_58_Data_4, A_FSG_50_0_0_58_ArrayDataList[index].Param4);
    putValue(A_FSG_50_0_0_58_Data_5_len, A_FSG_50_0_0_58_Data_5_LenList[index]);
    putValue(A_FSG_50_0_0_58_Data_5_cnt, A_FSG_50_0_0_58_Data_5_CntList[index]);
    putValue(A_FSG_50_0_0_58_Data_5, A_FSG_50_0_0_58_ArrayDataList[index].Param5, A_FSG_50_0_0_58_ArrayDataList[index].Param5_Length);

}
on envVar A_FSG_50_0_0_58_DataIndex_Incr
{
    long index;
    if(A_FSG_50_0_0_58_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_50_0_0_58_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_58_DataIndex);
        index++;
        putValue(A_FSG_50_0_0_58_DataIndex, index);
        A_FSG_50_0_0_58_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_58_DataIndex_Decr
{
    long index;
    if(A_FSG_50_0_0_58_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_50_0_0_58_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_58_DataIndex);
        index--;
        putValue(A_FSG_50_0_0_58_DataIndex, index);
        A_FSG_50_0_0_58_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_58_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_50_0_0_58_ID;
    data[2]=getValue(A_FSG_50_0_0_58_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_50_0_0_58
on envVar A_FSG_50_0_0_58_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_58",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_58",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_58",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_58_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_58", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_58",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_58",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_58",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_58_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_58", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_58_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_58_SegmEn,0);
           intertelegram_err(A_FSG_50_0_0_58_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_50_0_0_58_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_58_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_58_IntTlgEn,0);
           sequence_err(A_FSG_50_0_0_58_ID,getValueSize(A_FSG_50_0_0_58_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_50_0_0_58_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_50_0_0_58_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_50_0_0_58_Status",1);
 	}
}



A_FSG_50_0_0_58_SetInd () { /* leere Function*/ }

A_FSG_50_0_0_58_SetGetInd () { /* leere Function*/ }

A_FSG_50_0_0_58_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[1874];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_58_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_58_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_50_0_0_58_SetGet, head, 5);
                if(getValue(A_FSG_50_0_0_58_AT))
                {
                    putValue(A_FSG_50_0_0_58,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_50_0_0_58_SetGet, head, 3);
            if(getValue(A_FSG_50_0_0_58_AT))
            {
                putValue(A_FSG_50_0_0_58,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_50_0_0_58_AT))
        {
            putValue(A_FSG_50_0_0_58_RecAdr,recordAddressVal);
            putValue(A_FSG_50_0_0_58_Start, startVal);
            putValue(A_FSG_50_0_0_58_Elements, elementsVal);
            putValue(A_FSG_50_0_0_58_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_50_0_0_58_1
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_58_2_range // VideoStreams.TAID 
{
	@A_FSG_50_0_0_58_2 = @A_FSG_50_0_0_58_2_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_58_2
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_58_2, 1.0);
	@A_FSG_50_0_0_58_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_58_3_range // VideoStreams.TotalNumListElements 
{
	@A_FSG_50_0_0_58_3 = @A_FSG_50_0_0_58_3_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_58_3
{

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_58_3, 1.0);
	@A_FSG_50_0_0_58_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_58_Data_1_range // VideoStreams.Pos 
{
	@A_FSG_50_0_0_58_Data_1 = @A_FSG_50_0_0_58_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_58_Data_1
{

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_58_Data_1, 1.0);
	@A_FSG_50_0_0_58_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param1 = thisval;
}
on envVar A_FSG_50_0_0_58_Data_2
{

	//Update Childvalue (Enum)
	byte thisval; // StreamType
	thisval = getValue(this);
    A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param2 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_58_Data_3_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_58_Data_3_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_58_Data_3_CntList[ getValue(A_FSG_50_0_0_58_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_58_Data_3_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_58_Data_3_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_58_Data_3_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 16 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 16);
		thisval = 16;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_58_Data_3_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param3_Length = thisval;
	A_FSG_50_0_0_58_Data_3_LenList[ getValue(A_FSG_50_0_0_58_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_58_Data_3_len, thisval);

}

on envVar A_FSG_50_0_0_58_Data_3
{

	//Update Childvalue (String)
	word i;
	byte thisval[17];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param3[i] = thisval[i];
    A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param3_Length = getValueSize(this);
    A_FSG_50_0_0_58_Data_3_LenList[getValue(A_FSG_50_0_0_58_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_58_Data_3_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_58_Data_4_range // VideoStreams.UDP_Port 
{
	@A_FSG_50_0_0_58_Data_4 = @A_FSG_50_0_0_58_Data_4_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_58_Data_4
{

	//Update Childvalue (Number)
	word thisval; // UDP_Port
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_58_Data_4, 1.0);
	@A_FSG_50_0_0_58_Data_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param4 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_58_Data_5_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_58_Data_5_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_58_Data_5_CntList[ getValue(A_FSG_50_0_0_58_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_58_Data_5_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_58_Data_5_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_58_Data_5_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 600 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_58_Data_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 600);
		thisval = 600;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_58_Data_5_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param5_Length = thisval;
	A_FSG_50_0_0_58_Data_5_LenList[ getValue(A_FSG_50_0_0_58_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_58_Data_5_len, thisval);

}

on envVar A_FSG_50_0_0_58_Data_5
{

	//Update Childvalue (String)
	word i;
	byte thisval[602];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param5[i] = thisval[i];
    A_FSG_50_0_0_58_ArrayDataList[getValue(A_FSG_50_0_0_58_DataIndex)].Param5_Length = getValueSize(this);
    A_FSG_50_0_0_58_Data_5_LenList[getValue(A_FSG_50_0_0_58_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_58_Data_5_len, getValueSize(this));
}
on envVar A_FSG_50_0_0_58_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_58_2_SetGet_range // VideoStreams.TAID 
{
	@A_FSG_50_0_0_58_2_SetGet = @A_FSG_50_0_0_58_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_58_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_58_2_SetGet, 1.0);
	@A_FSG_50_0_0_58_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_50_0_0_59_ErrCode
{
       if(gM_FSG_50_0_0_59_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_50_0_0_59", MakeRGB(255,255,255));
       }
       gM_FSG_50_0_0_59_ErrCode = 1;
}
on envVar M_FSG_50_0_0_59Result_BTN
{
    byte temp[2];
    if (M_FSG_50_0_0_59Result_BTN_already_pressed == 0)
    {
        putValue(M_FSG_50_0_0_59_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_FSG_50_0_0_59",MakeRGB(255,255,255));
        M_FSG_50_0_0_59Result_BTN_already_pressed = 1;
    }
    else
    {
        putValue(M_FSG_50_0_0_59_State, "Result");
        getValue(M_FSG_50_0_0_59_Result, temp);
        Request_ByteSequence(LSGID, M_FSG_50_0_0_59_ID, Result_REQ, temp, getValueSize(M_FSG_50_0_0_59_Result));
        M_FSG_50_0_0_59Result_BTN_already_pressed = 0;
    }
}
on envVar M_FSG_50_0_0_59_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_50_0_0_59_ID;
    data[2]=getValue(M_FSG_50_0_0_59_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_50_0_0_59
on envVar M_FSG_50_0_0_59_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_59",1);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_59",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_59",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_59", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_59",0);
           EnableControl(panel_name,"errfield_M_FSG_50_0_0_59",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_59",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_50_0_0_59_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_50_0_0_59", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_50_0_0_59_Result // bus value of RequestSync_Video (59).
{
	// opcodes: Error-Processing-Result
	byte param1; // ASG_ID
	byte param2; // Extension1
	byte param3; // RequestSync_Result
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[2];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_59_Result, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(M_FSG_50_0_0_59_Result_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(M_FSG_50_0_0_59_Result_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(M_FSG_50_0_0_59_Result_3, param3);
}

on envVar M_FSG_50_0_0_59_Result_1 // RequestSync_Video.ASG_ID
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_59_Result, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(M_FSG_50_0_0_59_Result,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_59_Result_2_range // RequestSync_Video.Extension1 
{
	@M_FSG_50_0_0_59_Result_2 = @M_FSG_50_0_0_59_Result_2_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_59_Result_2 // RequestSync_Video.Extension1
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_50_0_0_59_Result_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_59_Result, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(M_FSG_50_0_0_59_Result,superval);
}

on envVar M_FSG_50_0_0_59_Result_3 // RequestSync_Video.RequestSync_Result
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // RequestSync_Result
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_59_Result, superval);
	superval[1]=thisval;
	putValue(M_FSG_50_0_0_59_Result,superval);
}

on envVar M_FSG_50_0_0_59_Processing // bus value of RequestSync_Video (59).
{
	// opcodes: Error-Processing-Result
	byte param1; // ASG_ID
	byte param2; // Extension1
	byte param3; // Reserve1
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[2];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_59_Processing, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(M_FSG_50_0_0_59_Processing_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(M_FSG_50_0_0_59_Processing_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(M_FSG_50_0_0_59_Processing_3, round((param3 * 1.0) - (0) + (0), 1.0));
}

on envVar M_FSG_50_0_0_59_Processing_1 // RequestSync_Video.ASG_ID
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_59_Processing, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(M_FSG_50_0_0_59_Processing,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_59_Processing_2_range // RequestSync_Video.Extension1 
{
	@M_FSG_50_0_0_59_Processing_2 = @M_FSG_50_0_0_59_Processing_2_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_59_Processing_2 // RequestSync_Video.Extension1
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_50_0_0_59_Processing_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_59_Processing, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(M_FSG_50_0_0_59_Processing,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_59_Processing_3_range // RequestSync_Video.Reserve1 
{
	@M_FSG_50_0_0_59_Processing_3 = @M_FSG_50_0_0_59_Processing_3_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_59_Processing_3 // RequestSync_Video.Reserve1
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_50_0_0_59_Processing_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_59_Processing, superval);
	superval[1]=thisval;
	putValue(M_FSG_50_0_0_59_Processing,superval);
}

on envVar M_FSG_50_0_0_59_Start // bus value of RequestSync_Video (59).
{
	// opcodes: AbortResult-StartResult
	byte param1; // ASG_ID
	byte param2; // Extension1
	byte param3; // VideoStreamID
	byte param4; // Extension2
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[3];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_50_0_0_59_Start, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(M_FSG_50_0_0_59_Start_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(M_FSG_50_0_0_59_Start_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(M_FSG_50_0_0_59_Start_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(M_FSG_50_0_0_59_Start_4, round((param4 * 1.0) - (0) + (0), 1.0));
}

on envVar M_FSG_50_0_0_59_Start_1 // RequestSync_Video.ASG_ID
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(M_FSG_50_0_0_59_Start, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(M_FSG_50_0_0_59_Start,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_59_Start_2_range // RequestSync_Video.Extension1 
{
	@M_FSG_50_0_0_59_Start_2 = @M_FSG_50_0_0_59_Start_2_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_59_Start_2 // RequestSync_Video.Extension1
{
	byte superval[3];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_50_0_0_59_Start_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_59_Start, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(M_FSG_50_0_0_59_Start,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_59_Start_3_range // RequestSync_Video.VideoStreamID 
{
	@M_FSG_50_0_0_59_Start_3 = @M_FSG_50_0_0_59_Start_3_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_59_Start_3 // RequestSync_Video.VideoStreamID
{
	byte superval[3];

	//Update Childvalue (Number)
	byte thisval; // VideoStreamID
	float slider_value;

	slider_value = round(@M_FSG_50_0_0_59_Start_3, 1.0);
	@M_FSG_50_0_0_59_Start_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_59_Start, superval);
	superval[1]=thisval;
	putValue(M_FSG_50_0_0_59_Start,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_50_0_0_59_Start_4_range // RequestSync_Video.Extension2 
{
	@M_FSG_50_0_0_59_Start_4 = @M_FSG_50_0_0_59_Start_4_range - (0); // slider = range - min
}

on envVar M_FSG_50_0_0_59_Start_4 // RequestSync_Video.Extension2
{
	byte superval[3];

	//Update Childvalue (Number)
	byte thisval; // Extension2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_50_0_0_59_Start_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_50_0_0_59_Start, superval);
	superval[2]=thisval;
	putValue(M_FSG_50_0_0_59_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_50_0_0_60_ErrCode
{
       if(gP_FSG_50_0_0_60_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_50_0_0_60", MakeRGB(255,255,255));
       }
       gP_FSG_50_0_0_60_ErrCode = 1;
}
on envVar P_FSG_50_0_0_60Status_BTN
{
	byte BAPTemp[11];
    if (P_FSG_50_0_0_60Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_50_0_0_60_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_50_0_0_60",MakeRGB(255,255,255));
        P_FSG_50_0_0_60Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_50_0_0_60_BuildFct();
        getValue(P_FSG_50_0_0_60, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_50_0_0_60_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_50_0_0_60));
        if(getValue(P_FSG_50_0_0_60_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_50_0_0_60_ID);
        }
        if(getValue(P_FSG_50_0_0_60_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_50_0_0_60_ID,elCount(BAPTemp));
        }
       P_FSG_50_0_0_60Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_50_0_0_60_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_50_0_0_60_ID;
    data[2]=getValue(P_FSG_50_0_0_60_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_50_0_0_60
on envVar P_FSG_50_0_0_60_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_60",1);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_60",1);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_60",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_60", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_60",0);
           EnableControl(panel_name,"errfield_P_FSG_50_0_0_60",0);
           EnableControl(panel_name,"panel_P_FSG_50_0_0_60",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_50_0_0_60", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_60_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_60_SegmEn,0);
           intertelegram_err(P_FSG_50_0_0_60_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_50_0_0_60_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_50_0_0_60_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_60_IntTlgEn,0);
           sequence_err(P_FSG_50_0_0_60_ID,getValueSize(P_FSG_50_0_0_60_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_50_0_0_60_ID);
       }
}
on envVar P_FSG_50_0_0_60 // bus value of DistanceToDestinationExtended (60).
{
	// opcodes: Error-Status
	byte param1[5]; //Record: TotalDistanceToDestination
	byte param2; // DistanceToDestination_percentage
	byte param3; // ERangeWarning
	byte param4; // Extension1
	byte param5; // ChargingDelay
	byte param6; // Extension2
	byte param7; // Extension3
	byte param8; // ValidityInformation
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 11; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_50_0_0_60, superval);
	///////// Start param1 - Record /////////
	for( i = 0; i < 5; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(P_FSG_50_0_0_60_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_50_0_0_60_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - NIBBLE /////////
	param3 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_50_0_0_60_3, param3);
	///////// Start param4 - NIBBLE /////////
	param4 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_50_0_0_60_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_50_0_0_60_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_50_0_0_60_6, round((param6 * 1.0) - (0) + (0), 1.0));
	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_FSG_50_0_0_60_7, round((param7 * 1.0) - (0) + (0), 1.0));
	///////// Start param8 - UINT8 /////////
	param8 = superval[currentPos++];
	putValue(P_FSG_50_0_0_60_8, param8);
}

// Updates the bus value field and other dependencies.
P_FSG_50_0_0_60_BuildFct()
{
	byte param1[5]; //Record: TotalDistanceToDestination
	byte param2; // DistanceToDestination_percentage
	byte param3; // ERangeWarning
	byte param4; // Extension1
	byte param5; // ChargingDelay
	byte param6; // Extension2
	byte param7; // Extension3
	byte param8; // ValidityInformation

	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	//Record:TotalDistanceToDestination
	getValue(P_FSG_50_0_0_60_1, param1);
	for( i = 0; i < 5; i++)
	{
	 superval[currentPos++] = param1[i];
	}
// gen_BuildFunc_SetSuperVals 
	@P_FSG_50_0_0_60_2_range = round(@P_FSG_50_0_0_60_2 + (0), 1.0); // slider value + min = real value
	param2 = (@P_FSG_50_0_0_60_2 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_50_0_0_60_3);
	param3 = param3 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param3<<4);
// gen_BuildFunc_SetSuperVals 
	@P_FSG_50_0_0_60_4_range = round(@P_FSG_50_0_0_60_4 + (0), 1.0); // slider value + min = real value
	param4 = 0; // underlying parameter has constant value 0.0.
	param4 = param4 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param4;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_50_0_0_60_5_range = round(@P_FSG_50_0_0_60_5 + (0), 1.0); // slider value + min = real value
	param5 = (@P_FSG_50_0_0_60_5 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_50_0_0_60_6_range = round(@P_FSG_50_0_0_60_6 + (0), 1.0); // slider value + min = real value
	param6 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_50_0_0_60_7_range = round(@P_FSG_50_0_0_60_7 + (0), 1.0); // slider value + min = real value
	param7 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param7;
// gen_BuildFunc_SetSuperVals 
	param8 = getValue(P_FSG_50_0_0_60_8);
	@P_FSG_50_0_0_60_8_0 = (param8 & 1) > 0;
	@P_FSG_50_0_0_60_8_1 = (param8 & 2) > 0;
	superval[currentPos++]=param8;
	putValue(P_FSG_50_0_0_60, superval, currentPos);
}


//Record: TotalDistanceToDestination, Element: Distance
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_60_1_Distance_range // DistanceToDestinationExtended.Distance 
{
	@P_FSG_50_0_0_60_1_Distance = @P_FSG_50_0_0_60_1_Distance_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_60_1_Distance // TotalDistanceToDestination.Distance
{
	byte superval[5];

	//Update Childvalue (Number)
	dword thisval; // Distance
	float slider_value;

	slider_value = round(@P_FSG_50_0_0_60_1_Distance, 0.1);
	@P_FSG_50_0_0_60_1_Distance_range = slider_value + (0); // real value := slider value + range min.
	thisval = (dword)round((slider_value + (0) - (0)) / (0.1), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_50_0_0_60_1, superval);
	superval[0]= thisval&0x000000ff;
	superval[1]=(thisval&0x0000ff00)>>8;
	superval[2]=(thisval&0x00ff0000)>>16;
	superval[3]=(thisval&0xff000000)>>24;
	putValue(P_FSG_50_0_0_60_1,superval);
}

//Record: TotalDistanceToDestination, Element: Unit
on envVar P_FSG_50_0_0_60_1_Unit // TotalDistanceToDestination.Unit
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // Unit
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_50_0_0_60_1, superval);
	superval[4]=thisval;
	putValue(P_FSG_50_0_0_60_1,superval);
}

on envVar P_FSG_50_0_0_60_1 // DistanceToDestinationExtended.TotalDistanceToDestination
{
	byte recordVal[5]; //Record: TotalDistanceToDestination
	dword currentPos;
	dword i;
//UpdateChildValue for Record.
	dword param1; // Distance
	byte param2; // Unit

	currentPos = 0;
	getValue(P_FSG_50_0_0_60_1, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT32 /////////
	param1 = recordVal[currentPos++]|(recordVal[currentPos++]<<8)|(recordVal[currentPos++]<<16)|(recordVal[currentPos++]<<24);
	putValue(P_FSG_50_0_0_60_1_Distance, round((param1 * 0.1) - (0) + (0), 0.1));
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_FSG_50_0_0_60_1_Unit, param2);
	P_FSG_50_0_0_60_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_60_2_range // DistanceToDestinationExtended.DistanceToDestination_percentage 
{
	@P_FSG_50_0_0_60_2 = @P_FSG_50_0_0_60_2_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_60_2 // DistanceToDestinationExtended.DistanceToDestination_percentage
{
	P_FSG_50_0_0_60_BuildFct();
}

on envVar P_FSG_50_0_0_60_3 // DistanceToDestinationExtended.ERangeWarning
{
	P_FSG_50_0_0_60_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_60_4_range // DistanceToDestinationExtended.Extension1 
{
	@P_FSG_50_0_0_60_4 = @P_FSG_50_0_0_60_4_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_60_4 // DistanceToDestinationExtended.Extension1
{
	P_FSG_50_0_0_60_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_60_5_range // DistanceToDestinationExtended.ChargingDelay 
{
	@P_FSG_50_0_0_60_5 = @P_FSG_50_0_0_60_5_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_60_5 // DistanceToDestinationExtended.ChargingDelay
{
	P_FSG_50_0_0_60_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_60_6_range // DistanceToDestinationExtended.Extension2 
{
	@P_FSG_50_0_0_60_6 = @P_FSG_50_0_0_60_6_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_60_6 // DistanceToDestinationExtended.Extension2
{
	P_FSG_50_0_0_60_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_50_0_0_60_7_range // DistanceToDestinationExtended.Extension3 
{
	@P_FSG_50_0_0_60_7 = @P_FSG_50_0_0_60_7_range - (0); // slider = range - min
}

on envVar P_FSG_50_0_0_60_7 // DistanceToDestinationExtended.Extension3
{
	P_FSG_50_0_0_60_BuildFct();
}

on envVar P_FSG_50_0_0_60_8_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_60_8);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_50_0_0_60_8,thisval);
}

on envVar P_FSG_50_0_0_60_8_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ValidityInformation
	bitval= getValue(this);
	thisval = getValue(P_FSG_50_0_0_60_8);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_50_0_0_60_8,thisval);
}

on envVar P_FSG_50_0_0_60_8 // DistanceToDestinationExtended.ValidityInformation
{
	P_FSG_50_0_0_60_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_50_0_0_61_ErrCode
{
       if(gA_FSG_50_0_0_61_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_61", MakeRGB(255,255,255));
       }
       gA_FSG_50_0_0_61_ErrCode = 1;
}
on envVar A_FSG_50_0_0_61Changed_BTN
{
    byte data[423]; 
    byte stringValue[423];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_50_0_0_61Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_61_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_61",MakeRGB(255,255,255));
        A_FSG_50_0_0_61Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //Einzelparameter: LaneGuidanceOnOff
        tempValue = getValue(A_FSG_50_0_0_61_1_Changed);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: CurrentCarPosition
        tempValue = getValue(A_FSG_50_0_0_61_2_Changed);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: RecommendedCarPosition
        tempValue = getValue(A_FSG_50_0_0_61_3_Changed);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_61_Changed);
        getValue(A_FSG_50_0_0_61_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_61_Changed_Start);
     elementsVal = getValue(A_FSG_50_0_0_61_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_61_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 61");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_61_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_61_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 61");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_50_0_0_61_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_50_0_0_61_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_50_0_0_61_ID);
       }
       if(getValue(A_FSG_50_0_0_61_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_50_0_0_61_ID,getValueSize(A_FSG_50_0_0_61_Changed));
       }
        A_FSG_50_0_0_61Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_61Status_BTN
{
    byte data[423 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[423];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_50_0_0_61Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_61_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_61",MakeRGB(255,255,255));
        A_FSG_50_0_0_61Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_61_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_61_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: LaneGuidanceOnOff
        tempValue = getValue(A_FSG_50_0_0_61_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: CurrentCarPosition
        tempValue = getValue(A_FSG_50_0_0_61_4);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: RecommendedCarPosition
        tempValue = getValue(A_FSG_50_0_0_61_5);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_61);
        getValue(A_FSG_50_0_0_61,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_61_Start);
     elementsVal = getValue(A_FSG_50_0_0_61_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_61_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 61");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LaneFocus:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDirection1:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDirection2:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo1:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo2:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneSidestreets:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_61_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_61_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_61_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_61_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_61_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable LaneType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_left:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param9) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param9 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_right:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param10) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param10 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneAttributes:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param11 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDescription:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param12 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_61_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_61_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 61");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LaneFocus:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDirection1:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDirection2:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo1:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo2:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneSidestreets:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_61_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_61_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_61_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_61_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_61_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable LaneType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_left:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param9) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param9 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_right:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param10) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param10 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneAttributes:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param11 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDescription:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param12 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_50_0_0_61, data);
        Request_ByteSequence(LSGID, A_FSG_50_0_0_61_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_50_0_0_61_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_50_0_0_61_ID);
        }
        if(getValue(A_FSG_50_0_0_61_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_50_0_0_61_ID,getValueSize(A_FSG_50_0_0_61));
        }
        A_FSG_50_0_0_61Status_BTN_already_pressed = 0;
    }
}
A_FSG_50_0_0_61_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[423];
    byte stringValue[423];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_61_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_61_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: LaneGuidanceOnOff
        tempValue = getValue(A_FSG_50_0_0_61_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: CurrentCarPosition
        tempValue = getValue(A_FSG_50_0_0_61_4);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: RecommendedCarPosition
        tempValue = getValue(A_FSG_50_0_0_61_5);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_61);
        getValue(A_FSG_50_0_0_61,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_61_Start);
     elementsVal = getValue(A_FSG_50_0_0_61_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_61_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 61");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LaneFocus:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDirection1:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDirection2:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo1:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo2:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneSidestreets:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_61_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_61_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_61_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_61_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_61_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable LaneType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_left:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param9) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param9 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_right:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param10) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param10 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneAttributes:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param11 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDescription:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param12 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_61_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_61_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 61");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable LaneFocus:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDirection1:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDirection2:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo1:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable GuidanceInfo2:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneSidestreets:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_61_ArrayDataList[i].Param7_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_61_Data_7_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_61_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_61_Data_7_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_61_Data_7 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_61_ArrayDataList[i].Param7[j];
        }
       }
      // Check if the current value of RecAdr enables the variable LaneType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_left:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param9) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param9 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneMarking_right:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param10) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_50_0_0_61_ArrayDataList[i].Param10 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable LaneAttributes:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param11 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable LaneDescription:
      if( 0 || 1 == getValue( A_FSG_50_0_0_61_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_61_ArrayDataList[i].Param12 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_50_0_0_61_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_50_0_0_61
{
    byte temp[423];
    getValue(A_FSG_50_0_0_61, temp);
    putValue(A_FSG_50_0_0_61_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_61_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_61_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_61_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_61_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_50_0_0_61_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_50_0_0_61_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_61_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_61_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_61_IndexSize))
    {
        putValue(A_FSG_50_0_0_61_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_50_0_0_61_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_50_0_0_61_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_50_0_0_61_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_50_0_0_61_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_61_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_61_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_61_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_61_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_61_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_61_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_61_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_61_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_61_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_61_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_61_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_61_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_61_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_50_0_0_61, head, headLength); 
}

on envVar A_FSG_50_0_0_61_RecAdr
{
    A_FSG_50_0_0_61_GenerateStatus();
}

on envVar A_FSG_50_0_0_61_Shift
{
    A_FSG_50_0_0_61_GenerateStatus();
}

on envVar A_FSG_50_0_0_61_Direction
{
    A_FSG_50_0_0_61_GenerateStatus();
}

on envVar A_FSG_50_0_0_61_Start
{
    A_FSG_50_0_0_61_GenerateStatus();
}

on envVar A_FSG_50_0_0_61_Elements
{
    A_FSG_50_0_0_61_GenerateStatus();
}

on envVar A_FSG_50_0_0_61_IndexSize
{
    A_FSG_50_0_0_61_GenerateStatus();
}
on envVar A_FSG_50_0_0_61_TransPos
{
    A_FSG_50_0_0_61_GenerateStatus();
}
A_FSG_50_0_0_61_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_61_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_61_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_61_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_61_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_61_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_61_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_61_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_61_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_61_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_61_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_61_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_50_0_0_61_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_61_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_61_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_50_0_0_61_Changed, head, 3); 
    }
}

on envVar A_FSG_50_0_0_61_Changed_RecAdr
{
    A_FSG_50_0_0_61_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_61_Changed_Shift
{
    A_FSG_50_0_0_61_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_61_Changed_Direction
{
    A_FSG_50_0_0_61_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_61_Changed_Start
{
    A_FSG_50_0_0_61_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_61_Changed_Elements
{
    A_FSG_50_0_0_61_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_61_Changed_IndexSize
{
    A_FSG_50_0_0_61_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_61_Changed_TransPos
{
    A_FSG_50_0_0_61_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_61_SetGet
{
    byte temp[423];
    getValue(A_FSG_50_0_0_61_SetGet, temp);
    putValue(A_FSG_50_0_0_61_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_61_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_61_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_61_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_61_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_61_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_61_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_61_SetGet_IndexSize))
    {
        putValue(A_FSG_50_0_0_61_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_50_0_0_61_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_50_0_0_61_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_50_0_0_61_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_50_0_0_61_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];
	char temp11[25];
	char temp12[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_50_0_0_61_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_50_0_0_61_ArrayDataList[i].Param1 = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param2 = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param3 = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param4 = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param5 = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param6 = 0;
		for(j=0; j<17; j++)
			A_FSG_50_0_0_61_ArrayDataList[i].Param7[j] = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param7_Length = 0;
		A_FSG_50_0_0_61_Data_7_LenList[i] = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param8 = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param9 = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param10 = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param11 = 0;
		A_FSG_50_0_0_61_ArrayDataList[i].Param12 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_50_0_0_61_fileSelector, gListPath);
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
					{
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //LaneFocus
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //LaneDirection1
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //LaneDirection2
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //GuidanceInfo1
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //GuidanceInfo2
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param8 = atol(temp8); //LaneType
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param9 = atol(temp9); //LaneMarking_left
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param10 = atol(temp10); //LaneMarking_right
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param11 = atol(temp11); //LaneAttributes
						A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param12 = atol(temp12); //LaneDescription
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
							temp11[i]=0;
							temp12[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 256)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //LaneFocus
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //LaneDirection1
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //LaneDirection2
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //GuidanceInfo1
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //GuidanceInfo2
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //LaneSidestreets
								if(paramPos < 16)
								{
									A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_61_ArrayDataList[current_CSV_line-1].Param7_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 8: //LaneType
								if( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //LaneMarking_left
								if( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //LaneMarking_right
								if( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 11: //LaneAttributes
								if( paramPos >= elCount(temp11) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp11[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 12: //LaneDescription
								if( paramPos >= elCount(temp12) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp12[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_50_0_0_61_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_50_0_0_61_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_61_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_50_0_0_61_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_50_0_0_61_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_50_0_0_61_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_50_0_0_61_Data_1, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_61_Data_2, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_61_Data_3, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param3);
	putValue(A_FSG_50_0_0_61_Data_4, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param4);
	putValue(A_FSG_50_0_0_61_Data_5, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param5);
	putValue(A_FSG_50_0_0_61_Data_6, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param6);
	putValue(A_FSG_50_0_0_61_Data_7, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param7, A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param7_Length);
	putValue(A_FSG_50_0_0_61_Data_8, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param8);
	putValue(A_FSG_50_0_0_61_Data_9, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param9);
	putValue(A_FSG_50_0_0_61_Data_10, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param10);
	putValue(A_FSG_50_0_0_61_Data_11, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param11);
	putValue(A_FSG_50_0_0_61_Data_12, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param12);
}


on envVar A_FSG_50_0_0_61_generateData_Btn
{
	word i;
	dword elementsArray[13] = {1, 1, 1, 1, 1, 1, 17, 2, 1, 1, 1, 1, 1};
	byte elementsTypeArray[13] = {0, 0, 0, 0, 0, 0, 0xE, 0xF, 0, 0, 0, 0, 0};
	dword elementsMaxSizeArray[13] = {16, 0xFF, 254, 254, 0xF, 0xF, 0, 0, 0xFF, 0xF, 0xF, 0xFF, 0xFF};
	byte tempArray[7650];
	if (A_FSG_50_0_0_61_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_61_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 61, 255 );
		for(i = 0; i < 255; i++)
		{
			memcpy(A_FSG_50_0_0_61_ArrayDataList[i], tempArray, (i * 30) );
			if(A_FSG_50_0_0_61_ArrayDataList[i].Param7_Length > 127 )
				A_FSG_50_0_0_61_Data_7_CntList[i] = 1;
		}
		A_FSG_50_0_0_61_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_50_0_0_61_Data_1, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_61_Data_2, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_61_Data_3, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param3);
	putValue(A_FSG_50_0_0_61_Data_4, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param4);
	putValue(A_FSG_50_0_0_61_Data_5, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param5);
	putValue(A_FSG_50_0_0_61_Data_6, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param6);
	putValue(A_FSG_50_0_0_61_Data_7, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param7, A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param7_Length);
	putValue(A_FSG_50_0_0_61_Data_8, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param8);
	putValue(A_FSG_50_0_0_61_Data_9, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param9);
	putValue(A_FSG_50_0_0_61_Data_10, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param10);
	putValue(A_FSG_50_0_0_61_Data_11, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param11);
	putValue(A_FSG_50_0_0_61_Data_12, A_FSG_50_0_0_61_ArrayDataList[ getValue( A_FSG_50_0_0_61_DataIndex) ].Param12);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_50_0_0_61_DataIndex
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_50_0_0_61_Data_1, A_FSG_50_0_0_61_ArrayDataList[index].Param1);
    putValue(A_FSG_50_0_0_61_Data_2, A_FSG_50_0_0_61_ArrayDataList[index].Param2);
    putValue(A_FSG_50_0_0_61_Data_3, A_FSG_50_0_0_61_ArrayDataList[index].Param3);
    putValue(A_FSG_50_0_0_61_Data_4, A_FSG_50_0_0_61_ArrayDataList[index].Param4);
    putValue(A_FSG_50_0_0_61_Data_5, A_FSG_50_0_0_61_ArrayDataList[index].Param5);
    putValue(A_FSG_50_0_0_61_Data_6, A_FSG_50_0_0_61_ArrayDataList[index].Param6);
    putValue(A_FSG_50_0_0_61_Data_7_len, A_FSG_50_0_0_61_Data_7_LenList[index]);
    putValue(A_FSG_50_0_0_61_Data_7_cnt, A_FSG_50_0_0_61_Data_7_CntList[index]);
    putValue(A_FSG_50_0_0_61_Data_7, A_FSG_50_0_0_61_ArrayDataList[index].Param7, A_FSG_50_0_0_61_ArrayDataList[index].Param7_Length);
    putValue(A_FSG_50_0_0_61_Data_8, A_FSG_50_0_0_61_ArrayDataList[index].Param8);
    putValue(A_FSG_50_0_0_61_Data_9, A_FSG_50_0_0_61_ArrayDataList[index].Param9);
    putValue(A_FSG_50_0_0_61_Data_10, A_FSG_50_0_0_61_ArrayDataList[index].Param10);
    putValue(A_FSG_50_0_0_61_Data_11, A_FSG_50_0_0_61_ArrayDataList[index].Param11);
    putValue(A_FSG_50_0_0_61_Data_12, A_FSG_50_0_0_61_ArrayDataList[index].Param12);

}
on envVar A_FSG_50_0_0_61_DataIndex_Incr
{
    long index;
    if(A_FSG_50_0_0_61_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_50_0_0_61_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_61_DataIndex);
        index++;
        putValue(A_FSG_50_0_0_61_DataIndex, index);
        A_FSG_50_0_0_61_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_61_DataIndex_Decr
{
    long index;
    if(A_FSG_50_0_0_61_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_50_0_0_61_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_61_DataIndex);
        index--;
        putValue(A_FSG_50_0_0_61_DataIndex, index);
        A_FSG_50_0_0_61_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_61_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_50_0_0_61_ID;
    data[2]=getValue(A_FSG_50_0_0_61_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_50_0_0_61
on envVar A_FSG_50_0_0_61_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_61",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_61",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_61",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_61_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_61", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_61",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_61",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_61",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_61_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_61", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_61_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_61_SegmEn,0);
           intertelegram_err(A_FSG_50_0_0_61_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_50_0_0_61_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_61_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_61_IntTlgEn,0);
           sequence_err(A_FSG_50_0_0_61_ID,getValueSize(A_FSG_50_0_0_61_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_50_0_0_61_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_50_0_0_61_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_50_0_0_61_Status",1);
 	}
}



A_FSG_50_0_0_61_SetInd () { /* leere Function*/ }

A_FSG_50_0_0_61_SetGetInd () { /* leere Function*/ }

A_FSG_50_0_0_61_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[423];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_61_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_61_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_50_0_0_61_SetGet, head, 5);
                if(getValue(A_FSG_50_0_0_61_AT))
                {
                    putValue(A_FSG_50_0_0_61,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_50_0_0_61_SetGet, head, 3);
            if(getValue(A_FSG_50_0_0_61_AT))
            {
                putValue(A_FSG_50_0_0_61,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_50_0_0_61_AT))
        {
            putValue(A_FSG_50_0_0_61_RecAdr,recordAddressVal);
            putValue(A_FSG_50_0_0_61_Start, startVal);
            putValue(A_FSG_50_0_0_61_Elements, elementsVal);
            putValue(A_FSG_50_0_0_61_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_50_0_0_61_1
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_61_2_range // LaneGuidance2.TAID 
{
	@A_FSG_50_0_0_61_2 = @A_FSG_50_0_0_61_2_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_61_2
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_61_2, 1.0);
	@A_FSG_50_0_0_61_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_FSG_50_0_0_61_3
{

	//Update Childvalue (Enum)
	byte thisval; // LaneGuidanceOnOff
	thisval = getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_61_4_range // LaneGuidance2.CurrentCarPosition 
{
	@A_FSG_50_0_0_61_4 = @A_FSG_50_0_0_61_4_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_61_4
{

	//Update Childvalue (Number)
	byte thisval; // CurrentCarPosition
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_61_4, 1.0);
	@A_FSG_50_0_0_61_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_61_5_range // LaneGuidance2.RecommendedCarPosition 
{
	@A_FSG_50_0_0_61_5 = @A_FSG_50_0_0_61_5_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_61_5
{

	//Update Childvalue (Number)
	byte thisval; // RecommendedCarPosition
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_61_5, 1.0);
	@A_FSG_50_0_0_61_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_61_Data_1_range // LaneGuidance2.Pos 
{
	@A_FSG_50_0_0_61_Data_1 = @A_FSG_50_0_0_61_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_61_Data_1
{

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_61_Data_1, 1.0);
	@A_FSG_50_0_0_61_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param1 = thisval;
}
on envVar A_FSG_50_0_0_61_Data_2
{

	//Update Childvalue (Enum)
	byte thisval; // LaneFocus
	thisval = getValue(this);
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param2 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_61_Data_3_range // LaneGuidance2.LaneDirection1 
{
	@A_FSG_50_0_0_61_Data_3 = @A_FSG_50_0_0_61_Data_3_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_61_Data_3
{

	//Update Childvalue (Number)
	byte thisval; // LaneDirection1
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_61_Data_3, 1.0);
	@A_FSG_50_0_0_61_Data_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param3 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_61_Data_4_range // LaneGuidance2.LaneDirection2 
{
	@A_FSG_50_0_0_61_Data_4 = @A_FSG_50_0_0_61_Data_4_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_61_Data_4
{

	//Update Childvalue (Number)
	byte thisval; // LaneDirection2
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_61_Data_4, 1.0);
	@A_FSG_50_0_0_61_Data_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param4 = thisval;
}
on envVar A_FSG_50_0_0_61_Data_5
{

	//Update Childvalue (Enum)
	byte thisval; // GuidanceInfo1
	thisval = 0x0f & getValue(this);
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param5 = thisval;
}
on envVar A_FSG_50_0_0_61_Data_6
{

	//Update Childvalue (Enum)
	byte thisval; // GuidanceInfo2
	thisval = 0x0f & getValue(this);
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param6 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_61_Data_7_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_61_Data_7_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_61_Data_7_CntList[ getValue(A_FSG_50_0_0_61_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_61_Data_7_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_61_Data_7_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_61_Data_7_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 16 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_61_Data_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 16);
		thisval = 16;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_61_Data_7_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param7_Length = thisval;
	A_FSG_50_0_0_61_Data_7_LenList[ getValue(A_FSG_50_0_0_61_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_61_Data_7_len, thisval);

}

on envVar A_FSG_50_0_0_61_Data_7
{

	//Update Childvalue (String)
	word i;
	byte thisval[17];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param7[i] = thisval[i];
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param7_Length = getValueSize(this);
    A_FSG_50_0_0_61_Data_7_LenList[getValue(A_FSG_50_0_0_61_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_61_Data_7_len, getValueSize(this));
}
on envVar A_FSG_50_0_0_61_Data_8
{

	//Update Childvalue (Enum)
	byte thisval; // LaneType
	thisval = getValue(this);
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param8 = thisval;
}
on envVar A_FSG_50_0_0_61_Data_9
{

	//Update Childvalue (Enum)
	byte thisval; // LaneMarking_left
	thisval = 0x0f & getValue(this);
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param9 = thisval;
}
on envVar A_FSG_50_0_0_61_Data_10
{

	//Update Childvalue (Enum)
	byte thisval; // LaneMarking_right
	thisval = 0x0f & getValue(this);
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param10 = thisval;
}
on envVar A_FSG_50_0_0_61_Data_11_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // LaneAttributes
	bitval= getValue(this);
	thisval = getValue(A_FSG_50_0_0_61_Data_11);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_FSG_50_0_0_61_Data_11,thisval);
}

on envVar A_FSG_50_0_0_61_Data_11_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // LaneAttributes
	bitval= getValue(this);
	thisval = getValue(A_FSG_50_0_0_61_Data_11);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_FSG_50_0_0_61_Data_11,thisval);
}

on envVar A_FSG_50_0_0_61_Data_11
{

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // LaneAttributes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_FSG_50_0_0_61_Data_11_0, 1);
	else
		putValue(A_FSG_50_0_0_61_Data_11_0, 0);
	if(thisval&(mask<<1))
		putValue(A_FSG_50_0_0_61_Data_11_1, 1);
	else
		putValue(A_FSG_50_0_0_61_Data_11_1, 0);
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param11 = thisval;
}
on envVar A_FSG_50_0_0_61_Data_12
{

	//Update Childvalue (Enum)
	byte thisval; // LaneDescription
	thisval = getValue(this);
    A_FSG_50_0_0_61_ArrayDataList[getValue(A_FSG_50_0_0_61_DataIndex)].Param12 = thisval;
}
on envVar A_FSG_50_0_0_61_1_Changed
{

	//Update Childvalue (Enum)
	byte thisval; // LaneGuidanceOnOff
	thisval = getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_61_2_Changed_range // LaneGuidance2.CurrentCarPosition 
{
	@A_FSG_50_0_0_61_2_Changed = @A_FSG_50_0_0_61_2_Changed_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_61_2_Changed
{

	//Update Childvalue (Number)
	byte thisval; // CurrentCarPosition
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_61_2_Changed, 1.0);
	@A_FSG_50_0_0_61_2_Changed_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_61_3_Changed_range // LaneGuidance2.RecommendedCarPosition 
{
	@A_FSG_50_0_0_61_3_Changed = @A_FSG_50_0_0_61_3_Changed_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_61_3_Changed
{

	//Update Childvalue (Number)
	byte thisval; // RecommendedCarPosition
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_61_3_Changed, 1.0);
	@A_FSG_50_0_0_61_3_Changed_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_FSG_50_0_0_61_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_61_2_SetGet_range // LaneGuidance2.TAID 
{
	@A_FSG_50_0_0_61_2_SetGet = @A_FSG_50_0_0_61_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_61_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_61_2_SetGet, 1.0);
	@A_FSG_50_0_0_61_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_50_0_0_62_ErrCode
{
       if(gA_FSG_50_0_0_62_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_50_0_0_62", MakeRGB(255,255,255));
       }
       gA_FSG_50_0_0_62_ErrCode = 1;
}
on envVar A_FSG_50_0_0_62Changed_BTN
{
    byte data[628]; 
    byte stringValue[628];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_50_0_0_62Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_62_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_62",MakeRGB(255,255,255));
        A_FSG_50_0_0_62Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_62_Changed);
        getValue(A_FSG_50_0_0_62_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_62_Changed_Start);
     elementsVal = getValue(A_FSG_50_0_0_62_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_62_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 62");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_62_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_62_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 62");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_50_0_0_62_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_50_0_0_62_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_50_0_0_62_ID);
       }
       if(getValue(A_FSG_50_0_0_62_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_50_0_0_62_ID,getValueSize(A_FSG_50_0_0_62_Changed));
       }
        A_FSG_50_0_0_62Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_62Status_BTN
{
    byte data[628 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[628];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_50_0_0_62Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_50_0_0_62_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_50_0_0_62",MakeRGB(255,255,255));
        A_FSG_50_0_0_62Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_62_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_62_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_62_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_62);
        getValue(A_FSG_50_0_0_62,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_62_Start);
     elementsVal = getValue(A_FSG_50_0_0_62_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_62_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 62");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PictureType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IPv6_Address:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_62_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_62_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_62_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable TCP_Port:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable URI:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_62_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_62_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 602-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 602-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_62_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 602-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 602-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param5[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_62_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_62_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 62");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PictureType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IPv6_Address:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_62_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_62_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_62_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable TCP_Port:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable URI:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_62_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_62_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 602-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 602-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_62_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 602-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 602-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param5[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_50_0_0_62, data);
        Request_ByteSequence(LSGID, A_FSG_50_0_0_62_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_50_0_0_62_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_50_0_0_62_ID);
        }
        if(getValue(A_FSG_50_0_0_62_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_50_0_0_62_ID,getValueSize(A_FSG_50_0_0_62));
        }
        A_FSG_50_0_0_62Status_BTN_already_pressed = 0;
    }
}
A_FSG_50_0_0_62_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[628];
    byte stringValue[628];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_50_0_0_62_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_50_0_0_62_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_50_0_0_62_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_50_0_0_62);
        getValue(A_FSG_50_0_0_62,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_50_0_0_62_Start);
     elementsVal = getValue(A_FSG_50_0_0_62_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_50_0_0_62_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 62");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PictureType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IPv6_Address:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_62_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_62_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_62_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable TCP_Port:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable URI:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_62_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_62_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 602-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 602-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_62_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 602-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 602-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param5[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_50_0_0_62_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_50_0_0_62_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 62");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PictureType:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IPv6_Address:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_62_ArrayDataList[i].Param3_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_62_Data_3_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_62_Data_3_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable TCP_Port:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_50_0_0_62_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable URI:
      if( 0 || 1 == getValue( A_FSG_50_0_0_62_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_50_0_0_62_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_50_0_0_62_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 602-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 602-2);
				return;
			}
		}
		else if(0 == A_FSG_50_0_0_62_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 602-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 602-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_50_0_0_62_ArrayDataList[i].Param5[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_50_0_0_62_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_50_0_0_62
{
    byte temp[628];
    getValue(A_FSG_50_0_0_62, temp);
    putValue(A_FSG_50_0_0_62_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_62_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_62_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_62_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_62_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_50_0_0_62_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_50_0_0_62_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_62_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_62_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_62_IndexSize))
    {
        putValue(A_FSG_50_0_0_62_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_50_0_0_62_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_50_0_0_62_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_50_0_0_62_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_50_0_0_62_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_62_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_62_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_62_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_62_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_62_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_62_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_62_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_62_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_62_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_62_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_62_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_62_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_62_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_50_0_0_62, head, headLength); 
}

on envVar A_FSG_50_0_0_62_RecAdr
{
    A_FSG_50_0_0_62_GenerateStatus();
}

on envVar A_FSG_50_0_0_62_Shift
{
    A_FSG_50_0_0_62_GenerateStatus();
}

on envVar A_FSG_50_0_0_62_Direction
{
    A_FSG_50_0_0_62_GenerateStatus();
}

on envVar A_FSG_50_0_0_62_Start
{
    A_FSG_50_0_0_62_GenerateStatus();
}

on envVar A_FSG_50_0_0_62_Elements
{
    A_FSG_50_0_0_62_GenerateStatus();
}

on envVar A_FSG_50_0_0_62_IndexSize
{
    A_FSG_50_0_0_62_GenerateStatus();
}
on envVar A_FSG_50_0_0_62_TransPos
{
    A_FSG_50_0_0_62_GenerateStatus();
}
A_FSG_50_0_0_62_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_50_0_0_62_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_50_0_0_62_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_50_0_0_62_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_50_0_0_62_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_50_0_0_62_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_50_0_0_62_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_50_0_0_62_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_50_0_0_62_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_50_0_0_62_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_50_0_0_62_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_50_0_0_62_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_50_0_0_62_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_50_0_0_62_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_50_0_0_62_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_50_0_0_62_Changed, head, 3); 
    }
}

on envVar A_FSG_50_0_0_62_Changed_RecAdr
{
    A_FSG_50_0_0_62_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_62_Changed_Shift
{
    A_FSG_50_0_0_62_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_62_Changed_Direction
{
    A_FSG_50_0_0_62_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_62_Changed_Start
{
    A_FSG_50_0_0_62_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_62_Changed_Elements
{
    A_FSG_50_0_0_62_Changed_GenerateChanged();
}

on envVar A_FSG_50_0_0_62_Changed_IndexSize
{
    A_FSG_50_0_0_62_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_62_Changed_TransPos
{
    A_FSG_50_0_0_62_Changed_GenerateChanged();
}
on envVar A_FSG_50_0_0_62_SetGet
{
    byte temp[628];
    getValue(A_FSG_50_0_0_62_SetGet, temp);
    putValue(A_FSG_50_0_0_62_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_50_0_0_62_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_50_0_0_62_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_50_0_0_62_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_50_0_0_62_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_50_0_0_62_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_50_0_0_62_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_50_0_0_62_SetGet_IndexSize))
    {
        putValue(A_FSG_50_0_0_62_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_50_0_0_62_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_50_0_0_62_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_50_0_0_62_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_50_0_0_62_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_50_0_0_62_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_50_0_0_62_ArrayDataList[i].Param1 = 0;
		A_FSG_50_0_0_62_ArrayDataList[i].Param2 = 0;
		for(j=0; j<17; j++)
			A_FSG_50_0_0_62_ArrayDataList[i].Param3[j] = 0;
		A_FSG_50_0_0_62_ArrayDataList[i].Param3_Length = 0;
		A_FSG_50_0_0_62_Data_3_LenList[i] = 0;
		A_FSG_50_0_0_62_ArrayDataList[i].Param4 = 0;
		for(j=0; j<602; j++)
			A_FSG_50_0_0_62_ArrayDataList[i].Param5[j] = 0;
		A_FSG_50_0_0_62_ArrayDataList[i].Param5_Length = 0;
		A_FSG_50_0_0_62_Data_5_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_50_0_0_62_fileSelector, gListPath);
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						A_FSG_50_0_0_62_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_50_0_0_62_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //PictureType
						A_FSG_50_0_0_62_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //TCP_Port
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PictureType
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //IPv6_Address
								if(paramPos < 16)
								{
									A_FSG_50_0_0_62_ArrayDataList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_62_ArrayDataList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 4: //TCP_Port
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //URI
								if(paramPos < 600)
								{
									A_FSG_50_0_0_62_ArrayDataList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									A_FSG_50_0_0_62_ArrayDataList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_50_0_0_62_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_50_0_0_62_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_62_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_50_0_0_62_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_50_0_0_62_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_50_0_0_62_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_50_0_0_62_Data_1, A_FSG_50_0_0_62_ArrayDataList[ getValue( A_FSG_50_0_0_62_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_62_Data_2, A_FSG_50_0_0_62_ArrayDataList[ getValue( A_FSG_50_0_0_62_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_62_Data_3, A_FSG_50_0_0_62_ArrayDataList[ getValue( A_FSG_50_0_0_62_DataIndex) ].Param3, A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param3_Length);
	putValue(A_FSG_50_0_0_62_Data_4, A_FSG_50_0_0_62_ArrayDataList[ getValue( A_FSG_50_0_0_62_DataIndex) ].Param4);
	putValue(A_FSG_50_0_0_62_Data_5, A_FSG_50_0_0_62_ArrayDataList[ getValue( A_FSG_50_0_0_62_DataIndex) ].Param5, A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param5_Length);
}


on envVar A_FSG_50_0_0_62_generateData_Btn
{
	word i;
	dword elementsArray[7] = {1, 1, 17, 2, 2, 602, 2};
	byte elementsTypeArray[7] = {0, 0, 0xE, 0xF, 0, 0xE, 0xF};
	dword elementsMaxSizeArray[7] = {255, 0xFF, 0, 0, 65535, 0, 0};
	byte tempArray[159258];
	if (A_FSG_50_0_0_62_generateData_Btn_already_pressed == 0)
	{
		A_FSG_50_0_0_62_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 62, 254 );
		for(i = 0; i < 254; i++)
		{
			memcpy(A_FSG_50_0_0_62_ArrayDataList[i], tempArray, (i * 627) );
			if(A_FSG_50_0_0_62_ArrayDataList[i].Param3_Length > 127 )
				A_FSG_50_0_0_62_Data_3_CntList[i] = 1;
			if(A_FSG_50_0_0_62_ArrayDataList[i].Param5_Length > 127 )
				A_FSG_50_0_0_62_Data_5_CntList[i] = 1;
		}
		A_FSG_50_0_0_62_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_50_0_0_62_Data_1, A_FSG_50_0_0_62_ArrayDataList[ getValue( A_FSG_50_0_0_62_DataIndex) ].Param1);
	putValue(A_FSG_50_0_0_62_Data_2, A_FSG_50_0_0_62_ArrayDataList[ getValue( A_FSG_50_0_0_62_DataIndex) ].Param2);
	putValue(A_FSG_50_0_0_62_Data_3, A_FSG_50_0_0_62_ArrayDataList[ getValue( A_FSG_50_0_0_62_DataIndex) ].Param3, A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param3_Length);
	putValue(A_FSG_50_0_0_62_Data_4, A_FSG_50_0_0_62_ArrayDataList[ getValue( A_FSG_50_0_0_62_DataIndex) ].Param4);
	putValue(A_FSG_50_0_0_62_Data_5, A_FSG_50_0_0_62_ArrayDataList[ getValue( A_FSG_50_0_0_62_DataIndex) ].Param5, A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param5_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_50_0_0_62_DataIndex
{
    long index;
    long maxIndex = 254-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_50_0_0_62_Data_1, A_FSG_50_0_0_62_ArrayDataList[index].Param1);
    putValue(A_FSG_50_0_0_62_Data_2, A_FSG_50_0_0_62_ArrayDataList[index].Param2);
    putValue(A_FSG_50_0_0_62_Data_3_len, A_FSG_50_0_0_62_Data_3_LenList[index]);
    putValue(A_FSG_50_0_0_62_Data_3_cnt, A_FSG_50_0_0_62_Data_3_CntList[index]);
    putValue(A_FSG_50_0_0_62_Data_3, A_FSG_50_0_0_62_ArrayDataList[index].Param3, A_FSG_50_0_0_62_ArrayDataList[index].Param3_Length);
    putValue(A_FSG_50_0_0_62_Data_4, A_FSG_50_0_0_62_ArrayDataList[index].Param4);
    putValue(A_FSG_50_0_0_62_Data_5_len, A_FSG_50_0_0_62_Data_5_LenList[index]);
    putValue(A_FSG_50_0_0_62_Data_5_cnt, A_FSG_50_0_0_62_Data_5_CntList[index]);
    putValue(A_FSG_50_0_0_62_Data_5, A_FSG_50_0_0_62_ArrayDataList[index].Param5, A_FSG_50_0_0_62_ArrayDataList[index].Param5_Length);

}
on envVar A_FSG_50_0_0_62_DataIndex_Incr
{
    long index;
    if(A_FSG_50_0_0_62_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_50_0_0_62_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_62_DataIndex);
        index++;
        putValue(A_FSG_50_0_0_62_DataIndex, index);
        A_FSG_50_0_0_62_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_62_DataIndex_Decr
{
    long index;
    if(A_FSG_50_0_0_62_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_50_0_0_62_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_50_0_0_62_DataIndex);
        index--;
        putValue(A_FSG_50_0_0_62_DataIndex, index);
        A_FSG_50_0_0_62_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_50_0_0_62_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_50_0_0_62_ID;
    data[2]=getValue(A_FSG_50_0_0_62_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_50_0_0_62
on envVar A_FSG_50_0_0_62_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_62",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_62",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_62",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_62_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_62", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_50_0_0_62",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_50_0_0_62",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_62",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_50_0_0_62_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_50_0_0_62", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_62_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_62_SegmEn,0);
           intertelegram_err(A_FSG_50_0_0_62_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_50_0_0_62_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_50_0_0_62_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_50_0_0_62_IntTlgEn,0);
           sequence_err(A_FSG_50_0_0_62_ID,getValueSize(A_FSG_50_0_0_62_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_50_0_0_62_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_50_0_0_62_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_50_0_0_62_Status",1);
 	}
}



A_FSG_50_0_0_62_SetInd () { /* leere Function*/ }

A_FSG_50_0_0_62_SetGetInd () { /* leere Function*/ }

A_FSG_50_0_0_62_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[628];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_62_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_50_0_0_62_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_50_0_0_62_SetGet, head, 5);
                if(getValue(A_FSG_50_0_0_62_AT))
                {
                    putValue(A_FSG_50_0_0_62,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_50_0_0_62_SetGet, head, 3);
            if(getValue(A_FSG_50_0_0_62_AT))
            {
                putValue(A_FSG_50_0_0_62,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_50_0_0_62_AT))
        {
            putValue(A_FSG_50_0_0_62_RecAdr,recordAddressVal);
            putValue(A_FSG_50_0_0_62_Start, startVal);
            putValue(A_FSG_50_0_0_62_Elements, elementsVal);
            putValue(A_FSG_50_0_0_62_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_50_0_0_62_1
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_62_2_range // Picture.TAID 
{
	@A_FSG_50_0_0_62_2 = @A_FSG_50_0_0_62_2_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_62_2
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_62_2, 1.0);
	@A_FSG_50_0_0_62_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_62_3_range // Picture.TotalNumListElements 
{
	@A_FSG_50_0_0_62_3 = @A_FSG_50_0_0_62_3_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_62_3
{

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_62_3, 1.0);
	@A_FSG_50_0_0_62_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_62_Data_1_range // Picture.Pos 
{
	@A_FSG_50_0_0_62_Data_1 = @A_FSG_50_0_0_62_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_62_Data_1
{

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_62_Data_1, 1.0);
	@A_FSG_50_0_0_62_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param1 = thisval;
}
on envVar A_FSG_50_0_0_62_Data_2
{

	//Update Childvalue (Enum)
	byte thisval; // PictureType
	thisval = getValue(this);
    A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param2 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_62_Data_3_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_62_Data_3_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_62_Data_3_CntList[ getValue(A_FSG_50_0_0_62_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_62_Data_3_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_62_Data_3_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_62_Data_3_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 16 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 16);
		thisval = 16;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_62_Data_3_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param3_Length = thisval;
	A_FSG_50_0_0_62_Data_3_LenList[ getValue(A_FSG_50_0_0_62_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_62_Data_3_len, thisval);

}

on envVar A_FSG_50_0_0_62_Data_3
{

	//Update Childvalue (String)
	word i;
	byte thisval[17];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param3[i] = thisval[i];
    A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param3_Length = getValueSize(this);
    A_FSG_50_0_0_62_Data_3_LenList[getValue(A_FSG_50_0_0_62_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_62_Data_3_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_62_Data_4_range // Picture.TCP_Port 
{
	@A_FSG_50_0_0_62_Data_4 = @A_FSG_50_0_0_62_Data_4_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_62_Data_4
{

	//Update Childvalue (Number)
	word thisval; // TCP_Port
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_62_Data_4, 1.0);
	@A_FSG_50_0_0_62_Data_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param4 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_50_0_0_62_Data_5_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_50_0_0_62_Data_5_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_50_0_0_62_Data_5_CntList[ getValue(A_FSG_50_0_0_62_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_50_0_0_62_Data_5_len, 127);
		}
	}

}


on envVar A_FSG_50_0_0_62_Data_5_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_50_0_0_62_Data_5_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 600 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_50_0_0_62_Data_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 600);
		thisval = 600;
	}
	if( thisval >127)
	{
		putValue(A_FSG_50_0_0_62_Data_5_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param5_Length = thisval;
	A_FSG_50_0_0_62_Data_5_LenList[ getValue(A_FSG_50_0_0_62_DataIndex) ] = thisval;
	putValue(A_FSG_50_0_0_62_Data_5_len, thisval);

}

on envVar A_FSG_50_0_0_62_Data_5
{

	//Update Childvalue (String)
	word i;
	byte thisval[602];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param5[i] = thisval[i];
    A_FSG_50_0_0_62_ArrayDataList[getValue(A_FSG_50_0_0_62_DataIndex)].Param5_Length = getValueSize(this);
    A_FSG_50_0_0_62_Data_5_LenList[getValue(A_FSG_50_0_0_62_DataIndex)]= getValueSize(this);
    putValue(A_FSG_50_0_0_62_Data_5_len, getValueSize(this));
}
on envVar A_FSG_50_0_0_62_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_50_0_0_62_2_SetGet_range // Picture.TAID 
{
	@A_FSG_50_0_0_62_2_SetGet = @A_FSG_50_0_0_62_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_50_0_0_62_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_50_0_0_62_2_SetGet, 1.0);
	@A_FSG_50_0_0_62_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}


/**
*
* Template-Funktion zum automatischen befuellen der Array-Daten, die in einer Arrayfunktion genutzt werden.
* Die Funktion wird durch den von BAPSimGen generierten Code aufgerufen.
*
* Parameter:
* - structArray: Muss mindestens nMax * Arraygroesse Bytes Platz haben, wird vom BAPSimGen automatisch generiert
* - structElementsSizeArray: Enthaelt die Groesseangabe jedes Array-Elements. Die Arraygroesse entspricht der Elementanzahl im Array.
*       Byte & Nibble = 1; Word = 2; usw. Bei Strings wird die maximale Stringlaenge angegeben.
* - structElementsTypeArray: Gibt den Datentyp eines Array-Elements zurueck. Die Arraygroesse entspricht der Elmentanzahl im Array.
*                               0x0 = Zahlenwert, also ein Slider, Enum, Bitfield,...
*                               0xE = String (darauf folgt immer eine 2, mit der Angabe der benutzen Bytes im String)
*                               0xF = Laenge der Nutzdaten des Strings, nur return Wert
* - fctID: Kann zur Fallunterscheidung der Funktions-IDs verwendet werden.
* - nMax: Array-Index
*
* Die Funktion kann im Switch-Case beliebig erweitert werden. Der Switch-Case wertet den Parameter fctID aus.
*           
*                    
**/
initStruct(byte structArray[], dword structElementsSizeArray[], byte structElementsTypeArray[], dword structElementsMaxSizeArray[], word fctID, word nMax )
{
    byte rand8;
    word rand16;
    dword randSize;
    word index;           //indexNr die an die String Parameter angehaengt wird.
    dword destArraySize;   //groesse von structArray
    dword destStructSize;  //groesse eines "Structs" also destArraySize / Anzahl Elemente (nMax))
    dword rand32;    
    dword i;
    dword pos;    //aktuelle Position im structArray
    dword elpos;  //aktuelle Position in den structElementsXXXArray's
    
    destArraySize = elCount(structArray);
    destStructSize = destArraySize / nMax;    

    Switch(fctID){

        //Idee ist, die Arrays je nach Funcion-ID speziell initalisieren zu koennen.
        //hierbei koennten die Daten z.B. aus einer Datei eingelesen werden,
        //oder auch ueber spezielle init Funktionen mit festen Werten initialisiert werden.
        //Der Default-Fall befuellt das Array mit Random-Werten und Strings mit einem vordefinierten Wort (hier test,)

        default :
        {
            pos = 0; 
            for(i = 1; i <= nMax; i++)
            {
                //walk through the array
                
                elpos = 0;
                while(pos < (destStructSize * i) )
                {   
                    //check Element type
                    if( structElementsTypeArray[elpos] == 0x0)          
                    { //Params like int, word, etc.
                        //check element length
                        Switch(structElementsSizeArray[elpos])
                        {
                            case(1) : //byte / nibble
                                rand8 = random(structElementsMaxSizeArray[elpos]);
                                structArray[pos] = rand8;
                                pos++;
                                break;

                            case(2) : //word / int
                                rand16 = random(structElementsMaxSizeArray[elpos]);
                                int2byte(structArray, pos, rand16);
                                pos += 2;
                                break;

                            case (4) : //dword / long
                                rand32 = random(structElementsMaxSizeArray[elpos]);
                                long2byte(structArray, pos, rand32);
                                pos += 4;
                                break;                        
                         }

                    }
                    else if(structElementsTypeArray[elpos] == 0xC)          
                    { //String Params like byte[]
                        randSize = random(structElementsSizeArray[elpos]);
                        if(randSize < 4) randSize = 4; 
                        index = i-1;
                        setRandomString(structArray ,pos ,structElementsSizeArray[elpos], randSize, index);
                        pos += structElementsSizeArray[elpos];
                    }
                    else if(structElementsTypeArray[elpos] == 0xD)          
                    { 
                        structArray[pos++] = randSize & 0xFF;
                        structArray[pos++] = (randSize >> 8) & 0xFF;
                        structArray[pos++] = (randSize >> 16) & 0xFF;
                        structArray[pos++] = (randSize >> 24) & 0xFF;
                    }
                    else if(structElementsTypeArray[elpos] == 0xE)          
                    { //String Params like byte[]
                        randSize = random(structElementsSizeArray[elpos]);
                        if(randSize < 2) randSize = 2; 
                        index = i-1;
                        setRandomString(structArray ,pos ,structElementsSizeArray[elpos], randSize, index);
                        pos += structElementsSizeArray[elpos];
                    }
                    else if(structElementsTypeArray[elpos] == 0xF)          
                    {
                        int2byte(structArray, pos, randSize);
                        pos += 2;
                        //write("Pos: %d Strlth: %d Type: %d ",pos-1,randSize,structElementsTypeArray[elpos]);
                    }
                    elpos++;
                }
            }   
        break;
        }            
    }
}

long2Byte(byte in[], dword pos, dword value)
{
    if( (elCount(in)-pos) < 4)
        write("Array out ouf bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);
    in[++pos] = (value >> 16);
    in[++pos] = (value >> 24);
}

int2byte (byte in[],dword pos,word value)
{
    if( (elCount(in)-pos) < 2 )
        write("Array out of bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);        
}

setRandomString (byte in[], dword pos, word strSize, dword randSize, dword count)
{
    dword endPos, endString, j;
    byte testString[4]={'t','e','s','t'};
    
    endPos = pos + strSize;
    endString = pos + randSize;
    j=0;
    
    int2ascii(in, pos, count);
    pos += 2;
    
    for(pos; pos < endPos ;pos ++)
    {
        if(j > 3 )
            j = 0;
        if(pos < endString)
            in[pos] = testString[j++];
        else
            in[pos] = 0x0;
    }
}

int2ascii (byte in[], dword pos, word value)
{
    //Konvertiert nur die erste und zweite Dezimalstelle, also Zahlen zw. 0 und 99.
    
    //auf 2 Stellen kuerzen
    value = value%100;
    //10er schreiben
    in[pos] = (value/10) + 48;    //  0x30 hex = 48 dez = ascii null
    //1er schreiben
    in[pos+1] = (value%10) + 48;  //  0x30 hex = 48 dez = ascii null
}

void SplitFullFileName(char FullFileName[], char FilePath[], char FileName[])
{
  dword i;
  i= strlen(FullFileName);
  
  while(i>0)
  {
    if(FullFileName[i] == '\\')
      break;  
    i--;
  }
  substr_cpy(FilePath, FullFileName, 0, i+1, elcount(FilePath));
  substr_cpy(FileName, FullFileName, i+1, -1, elcount(FileName));
}

//MR61529 
on envVar P_FSG_50_0_0_0_2_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_BAP_Config;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//MR61529 
on envVar C_FSG_50_0_0_0_1_SegmEn
{
       if(getValue(this)) 
       {
           putValue(C_FSG_50_0_0_0_1_IntTlgEn,0);
           sequence_err(FctID_GetAll,154);
       }
       else
       {
              sequence_err_off(FctID_GetAll);
       }
}

//MR61529 
on envVar C_FSG_50_0_0_0_1_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(C_FSG_50_0_0_0_1_SegmEn,0);
           intertelegram_err(FctID_GetAll);
       }
       else
       {
           intertelegram_err_off(FctID_GetAll);
       }
}

//MR61529 
on envVar C_FSG_50_0_0_0_1_ErrEn
{
if (getValue(this))
putValue(C_FSG_50_0_0_0_1_FctEn,0);
}

//MR61529 
on envVar C_FSG_50_0_0_0_1_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_GetAll;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//MR61529 
on envVar P_FSG_50_0_0_0_3_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_0_3_IntTlgEn,0);
           sequence_err(FctID_FunctionList,8);
       }
       else
       {
              sequence_err_off(FctID_FunctionList);
       }
}

//MR61529 
on envVar P_FSG_50_0_0_0_3_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_50_0_0_0_3_SegmEn,0);
           intertelegram_err(FctID_FunctionList);
       }
       else
       {
           intertelegram_err_off(FctID_FunctionList);
       }
}

//MR61529 
on envVar P_FSG_50_0_0_0_3_ErrEn
{
if (getValue(this))
putValue(P_FSG_50_0_0_0_3_FctEn,0);
}

//MR61529 
on envVar P_FSG_50_0_0_0_3_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_FunctionList;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//MR61529 	
//resending BAPconfig when this button is pressed
on envVar P_FSG_50_0_0_0_2Reset_BTN
{
   message 0x100 _mBAPconfig;	

    if (getValue(this))
    {
        //for BAPconfig Set/Reset button
         _mBAPconfig.CAN=1; 
		 _mBAPconfig.ID=0x97333210; 
		 _mBAPconfig.DLC=8; 
                	
         _mBAPconfig.byte(0) = 0x0C;
         _mBAPconfig.byte(1) = 0x82;
         _mBAPconfig.byte(2) = getValue(BAPCFG_FSG_50_0_0_ProtocolMajor);
         _mBAPconfig.byte(3) = getValue(BAPCFG_FSG_50_0_0_ProtocolMinor);
         _mBAPconfig.byte(4) = getValue(BAPCFG_FSG_50_0_0_LsgClassMajor);
         _mBAPconfig.byte(5) = getValue(BAPCFG_FSG_50_0_0_LsgClassMinor);
         _mBAPconfig.byte(6) = getValue(BAPCFG_FSG_50_0_0_DFMajor);
         _mBAPconfig.byte(7) = getValue(BAPCFG_FSG_50_0_0_DFMinor);
      
        output(_mBAPconfig);	
   }
}

