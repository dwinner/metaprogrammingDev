/*@!Encoding:1252*/
includes
{
}
variables
{
  DWORD udpHandle;
  DWORD transmitterIPdw, transmitterPortdw;
  DWORD receiverIPdw, receiverPortdw;
  CHAR  rxBuffer[1460], txBuffer[1460];
  CHAR  transmitterIPstr[16], transmitterNAMEstr[16];
  CHAR  receiverIPstr[16], receiverNAMEstr[16];      
  CHAR  kPanelName[32] = "DoIP_Test";   // Name of the panel
  
  const dword IPV6_STR_SIZE = 40; // IPv6 string size
  
  char ipv6SourceAddrStr[IPV6_STR_SIZE] = "fd53:7cb8:383:5::10"; // SOURCE ADRESS
  char ipv6GatewayStr[IPV6_STR_SIZE] = "fd53:7cb8:383:5::10"; // GATEWAY ADRESS
  char ipv6KombiStr[IPV6_STR_SIZE] = "fd53:7cb8:383:5::14"; // Kombi ADRESS
  char ipv6MulticastGrpStr[IPV6_STR_SIZE] = "ff02::1"; // Multicast adress
  char ipv6DestAddrStr[IPV6_STR_SIZE]   = "ff14::5"; // Dest adress
  char ipv6TA02_MulticastGrpStr[IPV6_STR_SIZE]   = "ff14::1"; // TA02 Multicast Adress
  char ipv6Diagnose_01_MulticastGrpStr[IPV6_STR_SIZE]   = "ff14::1"; // Diagnose_01 Multicast Adress
  char ipv6Systeminfo_01_MulticastGrpStr[IPV6_STR_SIZE]   = "ff14::1"; // Systeminfo_01 Multicast Adress

  // IPv6 address bytes. - TO CONVERT ALL ABOVE FROM STRING TO BYTES
  byte ipv6SourceAddr[16];  
  byte ipv6DestAddr[16]; 
  byte ipv6Gateway[16];
  byte ipv6Kombi[16];
  byte ipv6MulticastGrp[16]; 
  byte ipv6TA02_MulticastGrp[16];   
  byte ipv6Diagnose_01_MulticastGrp[16];   
  byte ipv6Systeminfo_01_MulticastGrp[16];   
  
  dword dwSrcPort = 13400; // DoIP PORTS - Source
  dword dwDstPort = 13400; // DoIP PORTS - Dest
  dword gResult = 0;
  
  dword gUdpSocketHandleGW = 0;
  dword gTcpSocketHandleGW = 0;   // handle for tester 1
  dword gTcpSocketHandleGWSecond = 0;  // handle for tester 2
  dword gTcpSocketHandler = 0;
  
  dword gAliveCheckAutoResponse = 0;
  CHAR gErrorText[200];
  CHAR gRxBuffer[1472]; // Max. UDP payload without fragmentation
  CHAR gTxBuffer[1472]; // Max. UDP payload without fragmentation
  CHAR gReceiveBuffer[1452];
  
  char textData[20] = "Hello UDP Server";
  byte abData[20];
  
  timer PollTimer;
  msTimer AutoAliveResponseTimer;
  msTimer AutoSendTesterPresentMsg;
  byte IgnoreDiagMsgReply = 0;
  byte DisplayArbitraryMsg = 0;

  struct DoIP_tstHead{
    byte ProtocolVer;
    byte InvProtocolVer;
    word wPayloadType;
    dword dwpayloadLen;
  }stDoIPHead;
  
  struct DoIP_AliveSrcAddr{
    word addr;
  }stDoIPSrcAddr;

  struct DoIP_Handle{
    dword socketHandle;
    word  sourceAddr;
  };
  
  struct DoIP_Handle stDoIpHandle[2];
  
  const word gcRequestHeadLen = 8; //8 bytes
  
  byte gDoIPPayload[1452];
  byte gabEmptyArray[1452];     
  
  //DOIP Specific data
  byte Eid[6] = {0,0,0,0,0,0x0B};
  byte Vin[17] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
      
  struct {
    word SrcAddr;
    byte ActType;
    dword Reservedoc;
    dword ReserveOEM;        
  }stRoutingActivation;
      
  struct{
    word SrcAddr;
    word DstAddr;
  }stDiagMsgHead;
      
  byte DiagUserData[8] = {1,2,3,4,5,6,7,8};
  byte TestDiagUserData[8] = {1,2,3,4,5,6,7,8};
      
  const byte gMAXIDNO = 7;
  byte DoIPID = 0;
      
      // Message define structure

    char gSignalData[256];
    char error[100];
    
    /* Diagnose_01 Specific variable */
    
    LONG packetHandleDiagnose_01;
    word Pdu_Diagnose_01_PduReadOffset =0;
    word Pdu_Diagnose_01_PduWriteOffset = 0;
    char Pdu_Diagnose_01_PduMarshallingData[1452];  
    word Pdu_Diagnose_01_WritePtrPdu = 0;
    
    // IPv6 address bytes.
    dword ipv6SourceUdpPortDiagnose_01 = 0xA7F2;//42994;
    dword ipv6DestinationUdpPortDiagnose_01 = 0xA63D;//42557;

    dword gUdpSocketHandleDiagnose_01 = 0;
    dword gUdpSocketHandleDiagnose_01Recv = 0;


    dword ipv6Diagnose_01_SrcPort = 42994;//42994;
    dword ipv6Diagnose_01_DstPort = 42557;//42993; 
    
    dword ifIdx_Diagnose_01 = 2; //2 is adapter vlan 1.5
    
    msTimer tDiagnose_01_TxMsg;
    const dword  Diagnose_01_TxMsgCycleTime = 800;
    
    /* Systeminfo_01 Specific variable */
    LONG packetHandleSysteminfo_01;
    word Pdu_Systeminfo_01_PduReadOffset =0;
    word Pdu_Systeminfo_01_PduWriteOffset = 0;
    char Pdu_Systeminfo_01_PduMarshallingData[1452];  
    word Pdu_Systeminfo_01_WritePtrPdu = 0;

    // IPv6 address bytes.
    dword ipv6SourceUdpPortSysteminfo_01 = 0xA7F2;//42994;
    dword ipv6DestinationUdpPortSysteminfo_01 = 0xA63D;//42557;

    dword gUdpSocketHandleSysteminfo_01 = 0;
    dword gUdpSocketHandleSysteminfo_01Recv = 0;


    dword ipv6Systeminfo_01_SrcPort = 42994;//42994;
    dword ipv6Systeminfo_01_DstPort = 42557;//42993; 
    
    dword ifIdx_Systeminfo_01 = 2; //2 is adapter vlan 1.5
    
    msTimer tSysteminfo_01_TxMsg;
    const dword  Systeminfo_01_TxMsgCycleTime = 800;
}

on preStart
{
    vConvertIPv6toArray(ipv6SourceAddrStr, ipv6SourceAddr);

    vConvertIPv6toArray(ipv6DestAddrStr, ipv6DestAddr);
  
    vConvertIPv6toArray(ipv6GatewayStr, ipv6Gateway);

    vConvertIPv6toArray(ipv6KombiStr, ipv6Kombi);
  
    vConvertIPv6toArray(ipv6MulticastGrpStr, ipv6MulticastGrp); 
  
    vConvertIPv6toArray(ipv6TA02_MulticastGrpStr, ipv6TA02_MulticastGrp);  
  
    vConvertIPv6toArray(ipv6Diagnose_01_MulticastGrpStr, ipv6Diagnose_01_MulticastGrp); 
  
    vConvertIPv6toArray(ipv6Systeminfo_01_MulticastGrpStr, ipv6Systeminfo_01_MulticastGrp);  
}

on sysvar_update DoIP::UDPSrcPort
{
  vOpenIPv6UdpPort(gUdpSocketHandleGW, ipv6Gateway,sysGetVariableInt(sysvar::DoIP::UDPSrcPort) );
}

/* MAD:- This is the main function for the DoIP functionality */
on ethernetPacket *
{  
  dword wDiagMsgLen;
  long size;
  byte sentdata[128];
  byte array[128];
  int position = 60; // Start of TCP Rx payload of DoIP Data
  int i;
  int offset;
  char msg[1000];
  ethernetPacket testPkt;
  testPkt.destination = ethGetMacAddressAsNumber( "02:84:CF:3B:BE:06" );
  
  sysGetVariableData( sysvar::DoIP::InputHext, sentdata, size); // To get size of whole DoIP message from sent DoIP input box
  wDiagMsgLen =  size; // Get only the size
  if (this.dir == rx) // Rx direction
  {       
    if (this.type == 0x86DD) // IPv6 type
      {
        //write("Destination 0x%x... looking for 0x%x", this.destination, testPkt.destination);
        
//        if (this.destination == testPkt.destination)
//        {
//          write("Received Ethernet packet on Eth%d of lenght %d", this.msgChannel, this.Length );
//        
//          for (i = 0; i < this.Length; i++) 
//          {
//            write("B%02d: 0x%02x", i, this.Byte(i));
//          }
//        }
        
//        if ((this.Byte(42) == 0x34) && (this.Byte(43) == 0x58))
//        {
//          offset = elCount("\n\tReceived IPv6 Data... of lenght: 000\n");
//          snprintf(msg, offset, "\n\tReceived IPv6 Data... of lenght: %03d\n", this.Length);
//          putValueToControl( kPanelName, "DoIPOutput", msg);
//          for (i = 0; i < elCount(msg); i++)
//          {
//              msg[i] = 0;
//          }
//         
//         for (i = 0; i < this.Length; i++)
//         {
//             snprintf(msg, elcount(msg), "\tB%02d: 0x%02x\n", i, this.byte(i));
//             putValueToControl( kPanelName, "DoIPOutput", msg);
//         }
//        }
  }
  }
}

on sysvar DoIP::ClearRxBuf
{
  if(@this)
  {
  byte TempByte[1] = '\0';
  sysSetVariableData( sysvar::DoIP::OutputHexRxDiag, TempByte, 0 ); //clear hex output
  }
  else return;
}

on start
{
  vOpenIPv6UdpPort(gUdpSocketHandleGW, ipv6Gateway,dwSrcPort );
  TcPClientStart();
  
  DoIP_ProInit();
  
  memcpy(abData,textData,elcount(textData));
  
  //Init ETH message packets
  
  InitIPV6dataDiagnose_01();
  InitIPV6dataSysteminfo_01();

  //Diagnose_01 Multicast UDP socket OPEN AND JOIN
  Pdu_Diagnose_01_vOpenIPv6MulticastUdpPort(ipv6Gateway,ipv6Diagnose_01_SrcPort,ipv6Diagnose_01_MulticastGrp,ipv6Diagnose_01_DstPort);
  Pdu_Diagnose_01_vJoinIPv6MulticastGrp(ipv6Diagnose_01_MulticastGrp,ipv6Diagnose_01_DstPort);
  setTimer( tDiagnose_01_TxMsg, Diagnose_01_TxMsgCycleTime );
  
  //Systeminfo_01 Multicast UDP socket OPEN AND JOIN
  Pdu_Systeminfo_01_vOpenIPv6MulticastUdpPort(ipv6Gateway,ipv6Systeminfo_01_SrcPort,ipv6Systeminfo_01_MulticastGrp,ipv6Systeminfo_01_DstPort);
  Pdu_Systeminfo_01_vJoinIPv6MulticastGrp(ipv6Systeminfo_01_MulticastGrp,ipv6Systeminfo_01_DstPort);
  setTimer( tSysteminfo_01_TxMsg, Systeminfo_01_TxMsgCycleTime );
  
  //SendUdpMsg(gUdpSocketHandleGW,ipv6Kombi,dwDstPort,abData);
  
 // DoIP_VinRequest();
 
  ReceiveUdpMsg(gUdpSocketHandleGW);
}

/// <Pdu_Diagnose_01>
BYTE Pdu_u8BuildDiagnose_01(char acSignalData[])
{
  int value;

    Pdu_Diagnose_01_vClearPduSendBuff();
    
    Pdu_Diagnose_01_vSetSignalSize(packetHandleDiagnose_01,Diagnose_01.DLC);

    EthSetTokenSignalValue( packetHandleDiagnose_01, Diagnose_01::DGN_Verlernzaehler, @Diagnose_01::DGN_Verlernzaehler);  //01

    Pdu_Diagnose_01_vConvertSignaltoByte(packetHandleDiagnose_01, Diagnose_01.DLC,Diagnose_01.id, acSignalData);
  
    write("%s",gSignalData);
  
  return 0;
}

/// <Pdu_Diagnose_01>
void SendIPV6dataDiagnose_01()
{
  Pdu_Diagnose_01_u16SendIPv6MulticastCastMessage(Pdu_Diagnose_01_PduMarshallingData);
}

/// <Pdu_Diagnose_01>
void Pdu_Diagnose_01_u16SendIPv6MulticastCastMessage(char abUdpMsg[])
{

  gResult = UdpSendTo(gUdpSocketHandleDiagnose_01, ipv6Diagnose_01_MulticastGrp, ipv6Diagnose_01_DstPort, abUdpMsg, Pdu_Diagnose_01_WritePtrPdu);
  // Check for error
  if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleDiagnose_01) != 997) )
  {
    IpGetLastSocketErrorAsString(gUdpSocketHandleDiagnose_01, gErrorText, elcount(gErrorText) );
    write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleDiagnose_01) );  
  }
}

/// <Pdu_Diagnose_01>
void Pdu_Diagnose_01_vOpenIPv6MulticastUdpPort( byte ipv6SrcAddr[],dword ipv6SrcPort,byte ipv6DstAddr[],dword ipv6DstPort)
{
    int i;                          // loop variable  
    dword result,result2;   
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
    char textData[30] = "HUNM: Hello UDP Server";

  //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
      // success...
      write("<%BASE_FILE_NAME%>IpGetAddressAsArray: returned wildcard array with IPv6 bytes:");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6WildcardAddrArray[i]);
      }
    }
    else
    {
      writeLineEx(1, 3, "<%BASE_FILE_NAME%>IpGetAddressAsArray: The wildcard address string was invalid.");
    }
 
      


    // Open UDP socket
    gUdpSocketHandleDiagnose_01 = UdpOpen(ipv6SrcAddr, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
   // gUdpSocketHandleNM = UdpOpen(ipv6WildcardAddrArray, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
    
    // Check for valid socket handle
    if (gUdpSocketHandleDiagnose_01 == ~0)
    {
      write("<%BASE_FILE_NAME%> UdpOpen failed: Result %d", IpGetLastError());
    }
    else // Socket handle valid
    {

      
      result = IpSetMulticastInterface( gUdpSocketHandleDiagnose_01, ifIdx_Diagnose_01 );
      if (result == 0)
      {
        write("<%BASE_FILE_NAME%>Socket %d set to send multicast on adapter %d.", gUdpSocketHandleDiagnose_01, ifIdx_Diagnose_01);
        write("<%BASE_FILE_NAME%>Sending some multicast messages to :%d ...", ipv6DstPort);
        
       }
      else
      {
        writeLineEx(1, 3, "<%BASE_FILE_NAME%>IpSetMulticastInterface: Error %d", result);
      }
      // Send UDP data
      gResult = UdpSendTo(gUdpSocketHandleDiagnose_01, ipv6DstAddr, ipv6DstPort, textData, strlen(textData));
      write( "<%BASE_FILE_NAME%>UdpSendTo to ipv6: ");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6DstAddr[i]);
      }
      
 
      
      
      // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleDiagnose_01) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleDiagnose_01, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleDiagnose_01) );
      }
 
      // Optionally receive answer from UDP server
      UdpReceiveFrom(gUdpSocketHandleDiagnose_01, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(gUdpSocketHandleDiagnose_01) != 997 )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleDiagnose_01, gErrorText, elcount(gErrorText));
        write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleDiagnose_01));
      }

      
      
    }
 }

/// <Pdu_Diagnose_01>
void Pdu_Diagnose_01_vJoinIPv6MulticastGrp( byte ipv6MultiCastAddr[],dword ipv6MulticastPort)
{
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
  //wildcard IP binding
  long result; // function result
  dword ifIdx = 2;
  Dword port = 12345;
  
    //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
  
        gUdpSocketHandleDiagnose_01Recv = UdpOpen(ipv6WildcardAddrArray, ipv6MulticastPort); // open an UDP socket...
        if (gUdpSocketHandleDiagnose_01Recv != ~0)
        {
          result = IpJoinMulticastGroup( gUdpSocketHandleDiagnose_01Recv, ifIdx, ipv6MultiCastAddr );
          if (result == 0)
          {
            // successfully joined.
            write("successfully joined:  %d", result);
            
            // Optionally receive answer from UDP server
            UdpReceiveFrom(gUdpSocketHandleDiagnose_01Recv, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

            // Check for error
            if ( IpGetLastSocketError(gUdpSocketHandleDiagnose_01Recv) != 997 )
            {
              IpGetLastSocketErrorAsString(gUdpSocketHandleDiagnose_01Recv, gErrorText, elcount(gErrorText));
              write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleDiagnose_01Recv));
              }  

          }
          else
          {
            writeLineEx(1, 3, "IpJoinMulticastGroup: Error %d", result);
          }
        }

    }
    else
     {
       writeLineEx(1, 3, "IpGetAddressAsArray: The wildcard address string was invalid.");
     }
}

on sysvar_update Diagnose_01::DGN_Verlernzaehler
{
  InitIPV6dataDiagnose_01();//Update Ethernet message
}

on timer tSysteminfo_01_TxMsg
{
  if(@Systeminfo_01::Systeminfo_01_On == 1 && getValue( eUDPSendEnabled ))
  {
    SendIPV6dataSysteminfo_01();
  }      
  setTimer( tSysteminfo_01_TxMsg, Systeminfo_01_TxMsgCycleTime );
}

/// <Pdu_Diagnose_01>
void InitIPV6dataDiagnose_01()
{

 
  char NM_PduData[256];
  char BAP_PduData[256];
  char c8Data[1];
  
  // create packet
  packetHandleDiagnose_01 = EthInitPacket("ipv6");
  
  // init UDP protocol
  EthInitProtocol(packetHandleDiagnose_01, "udp" );

  if (EthGetLastError() == 0)
  {
    // set protocol fields    
    EthSetTokenData( packetHandleDiagnose_01, "ipv6", "source", 16, ipv6SourceAddr ); // 255.255.255.255
    EthSetTokenData( packetHandleDiagnose_01, "ipv6", "destination", 16, ipv6DestAddr ); // 255.255.255.255
    EthSetTokenInt( packetHandleDiagnose_01, "udp", "source", ipv6SourceUdpPortDiagnose_01 );
    EthSetTokenInt( packetHandleDiagnose_01, "udp", "destination", ipv6DestinationUdpPortDiagnose_01 );

    // set UDP payload
    
    Pdu_Diagnose_01_vClearPduSendBuff();
        
    //PDU Diagnose_01 BUILD AND PDU MARSHALLING
    Pdu_u8BuildDiagnose_01(gSignalData);

    Pdu_Diagnose_01_u16SetPduMarshallingUdp(Diagnose_01.DLC,Diagnose_01.id,gSignalData);
    
    // Complete and send packet
    EthCompletePacket( packetHandleDiagnose_01 );
  //  EthOutputPacket( packetHandle );

    // release packet
 //   EthReleasePacket( packetHandle );

        
  }
  else
  {
    EthGetLastErrorText( elCount(error), error );
    write("Error: %s", error );
  }

}

/// <Pdu_Diagnose_01>
//Hence, 1452 bytes per datagram are available for the transmission of signals according to
//the SoAd-approach
word Pdu_Diagnose_01_u16SetPduMarshallingUdp(long Len,long ID,char Data[])
 {
  char PduLen[4]; //Pdu length of the user data in byte according to the data
  char PduID[4]; 

  
  PduID[3] = (char)(ID & 0x000000ff);
  PduID[2] = (char)((ID & 0x0000ff00) >> 8);
  PduID[1] = (char)((ID & 0x00ff0000) >> 16);
  PduID[0] = (char)((ID & 0xff000000) >> 24);
  
  
  PduLen[3] = (char)(Len & 0x000000ff);
  PduLen[2] = (char)((Len & 0x0000ff00) >> 8);
  PduLen[1] = (char)((Len & 0x00ff0000) >> 16);
  PduLen[0] = (char)((Len & 0xff000000) >> 24); 
  
  write("PDU ID: %d \r",Len);
  write("%x \r",PduLen[0]);
  write("%x \r",PduLen[1]);
  write("%x \r",PduLen[2]);
  write("%x \r",PduLen[3]);
  
  write("PDU Len: %d \r",ID);
  write("%x \r",PduID[0]);
  write("%x \r",PduID[1]);
  write("%x \r",PduID[2]);
  write("%x \r",PduID[3]);
   
  if(1452 <= Pdu_Diagnose_01_WritePtrPdu) /* Udp Payload is full */
    return 0;
  

  memcpy_off( Pdu_Diagnose_01_PduMarshallingData,  Pdu_Diagnose_01_WritePtrPdu + 0, PduID,0,4 );
  
  memcpy_off( Pdu_Diagnose_01_PduMarshallingData,  Pdu_Diagnose_01_WritePtrPdu + 4, PduLen,0,4 ); 
  
  memcpy_off( Pdu_Diagnose_01_PduMarshallingData,  Pdu_Diagnose_01_WritePtrPdu + 8, Data,0,Len );  
  
  Pdu_Diagnose_01_WritePtrPdu = Pdu_Diagnose_01_WritePtrPdu + 8 + Len;

  return 0;
 }

/// <Pdu_Diagnose_01>
void Pdu_Diagnose_01_vSetSignalSize(Long PkgHdl,long DLC)
{
   EthResizeToken( PkgHdl, "udp", "data", DLC*8 /*bits*/ ); 
  
}
/// <Pdu_Diagnose_01>
void Pdu_Diagnose_01_vClearPduSendBuff()
{
  Pdu_Diagnose_01_PduWriteOffset = 0;
  Pdu_Diagnose_01_WritePtrPdu = 0;
}

/// <Pdu_Diagnose_01>
void Pdu_Diagnose_01_vConvertSignaltoByte(Long PkgHdl, long DLC, long ID, char acSignalData[])
{
    EthGetTokenData(packetHandleDiagnose_01, "udp","data",DLC,acSignalData);  
}

/// <Pdu_Systeminfo_01>
BYTE Pdu_u8BuildSysteminfo_01(char acSignalData[])
{
  int value;

    Pdu_Systeminfo_01_vClearPduSendBuff();
    
    Pdu_Systeminfo_01_vSetSignalSize(packetHandleSysteminfo_01,Systeminfo_01.DLC);

    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_T_Schutz, @Systeminfo_01::SI_T_Schutz);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_Sammel_SG_Fehler, @Systeminfo_01::SI_Sammel_SG_Fehler);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_Sammelfehler, @Systeminfo_01::SI_Sammelfehler);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_P_Mode_gueltig, @Systeminfo_01::SI_P_Mode_gueltig);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_T_Mode, @Systeminfo_01::SI_T_Mode);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_P_Mode, @Systeminfo_01::SI_P_Mode);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_QRS_Mode, @Systeminfo_01::SI_QRS_Mode);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_NWDF_gueltig, @Systeminfo_01::SI_NWDF_gueltig);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_NWDF, @Systeminfo_01::SI_NWDF);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_Diagnose_Aktiv, @Systeminfo_01::SI_Diagnose_Aktiv);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::GW_KD_Fehler, @Systeminfo_01::GW_KD_Fehler);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_15, @Systeminfo_01::SI_BUS_15);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_14, @Systeminfo_01::SI_BUS_14);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_13, @Systeminfo_01::SI_BUS_13);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_12, @Systeminfo_01::SI_BUS_12);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_11, @Systeminfo_01::SI_BUS_11);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_10, @Systeminfo_01::SI_BUS_10);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_09, @Systeminfo_01::SI_BUS_09);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_08, @Systeminfo_01::SI_BUS_08);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_07, @Systeminfo_01::SI_BUS_07);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_06, @Systeminfo_01::SI_BUS_06);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_05, @Systeminfo_01::SI_BUS_05);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_04, @Systeminfo_01::SI_BUS_04);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_03, @Systeminfo_01::SI_BUS_03);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_02, @Systeminfo_01::SI_BUS_02);  //01
    EthSetTokenSignalValue( packetHandleSysteminfo_01, Systeminfo_01::SI_BUS_01, @Systeminfo_01::SI_BUS_01);  //01
  
    Pdu_Systeminfo_01_vConvertSignaltoByte(packetHandleSysteminfo_01, Systeminfo_01.DLC,Systeminfo_01.id, acSignalData);
  
    write("%s",gSignalData);
  
  return 0;
}

/// <Pdu_Systeminfo_01>
void Pdu_Systeminfo_01_vSetSignalSize(Long PkgHdl,long DLC)
{
   EthResizeToken( PkgHdl, "udp", "data", DLC*8 /*bits*/ ); 
  
}
/// <Pdu_Systeminfo_01>
void Pdu_Systeminfo_01_vClearPduSendBuff()
{
  Pdu_Systeminfo_01_PduWriteOffset = 0;
  Pdu_Systeminfo_01_WritePtrPdu = 0;
}

/// <Pdu_Systeminfo_01>
void Pdu_Systeminfo_01_vConvertSignaltoByte(Long PkgHdl, long DLC, long ID, char acSignalData[])
{
    EthGetTokenData(packetHandleSysteminfo_01, "udp","data",DLC,acSignalData);  
}

/// <Pdu_Systeminfo_01>
void InitIPV6dataSysteminfo_01()
{

 
  char NM_PduData[256];
  char BAP_PduData[256];
  char c8Data[1];
  
  // create packet
  packetHandleSysteminfo_01 = EthInitPacket("ipv6");
  
  // init UDP protocol
  EthInitProtocol(packetHandleSysteminfo_01, "udp" );

  if (EthGetLastError() == 0)
  {
    // set protocol fields    
    EthSetTokenData( packetHandleSysteminfo_01, "ipv6", "source", 16, ipv6SourceAddr ); // 255.255.255.255
    EthSetTokenData( packetHandleSysteminfo_01, "ipv6", "destination", 16, ipv6DestAddr ); // 255.255.255.255
    EthSetTokenInt( packetHandleSysteminfo_01, "udp", "source", ipv6SourceUdpPortSysteminfo_01 );
    EthSetTokenInt( packetHandleSysteminfo_01, "udp", "destination", ipv6DestinationUdpPortSysteminfo_01 );

    // set UDP payload
    
    Pdu_Systeminfo_01_vClearPduSendBuff();
        
    //PDU Systeminfo_01 BUILD AND PDU MARSHALLING
    Pdu_u8BuildSysteminfo_01(gSignalData);

    Pdu_Systeminfo_01_u16SetPduMarshallingUdp(Systeminfo_01.DLC,Systeminfo_01.id,gSignalData);
    
    // Complete and send packet
    EthCompletePacket( packetHandleSysteminfo_01 );
  //  EthOutputPacket( packetHandle );

    // release packet
 //   EthReleasePacket( packetHandle );

        
  }
  else
  {
    EthGetLastErrorText( elCount(error), error );
    write("Error: %s", error );
  }

}

/// <Pdu_Systeminfo_01>
void Pdu_Systeminfo_01_u16SendIPv6MulticastCastMessage(char abUdpMsg[])
{

  gResult = UdpSendTo(gUdpSocketHandleSysteminfo_01, ipv6Systeminfo_01_MulticastGrp, ipv6Systeminfo_01_DstPort, abUdpMsg, Pdu_Systeminfo_01_WritePtrPdu);
  // Check for error
  if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleSysteminfo_01) != 997) )
  {
    IpGetLastSocketErrorAsString(gUdpSocketHandleSysteminfo_01, gErrorText, elcount(gErrorText) );
    write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleSysteminfo_01) );  
  }
}

/// <Pdu_Systeminfo_01>
void SendIPV6dataSysteminfo_01()
{
  Pdu_Systeminfo_01_u16SendIPv6MulticastCastMessage(Pdu_Systeminfo_01_PduMarshallingData);
}

/// <Pdu_Systeminfo_01>
void Pdu_Systeminfo_01_vOpenIPv6MulticastUdpPort( byte ipv6SrcAddr[],dword ipv6SrcPort,byte ipv6DstAddr[],dword ipv6DstPort)
{
    int i;                          // loop variable  
    dword result,result2;   
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
    char textData[30] = "HUNM: Hello UDP Server";

  //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
      // success...
      write("<%BASE_FILE_NAME%>IpGetAddressAsArray: returned wildcard array with IPv6 bytes:");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6WildcardAddrArray[i]);
      }
    }
    else
    {
      writeLineEx(1, 3, "<%BASE_FILE_NAME%>IpGetAddressAsArray: The wildcard address string was invalid.");
    }
 
      


    // Open UDP socket
    gUdpSocketHandleSysteminfo_01 = UdpOpen(ipv6SrcAddr, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
   // gUdpSocketHandleNM = UdpOpen(ipv6WildcardAddrArray, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
    
    // Check for valid socket handle
    if (gUdpSocketHandleSysteminfo_01 == ~0)
    {
      write("<%BASE_FILE_NAME%> UdpOpen failed: Result %d", IpGetLastError());
    }
    else // Socket handle valid
    {

      
      result = IpSetMulticastInterface( gUdpSocketHandleSysteminfo_01, ifIdx_Systeminfo_01 );
      if (result == 0)
      {
        write("<%BASE_FILE_NAME%>Socket %d set to send multicast on adapter %d.", gUdpSocketHandleSysteminfo_01, ifIdx_Systeminfo_01);
        write("<%BASE_FILE_NAME%>Sending some multicast messages to :%d ...", ipv6DstPort);
        
       }
      else
      {
        writeLineEx(1, 3, "<%BASE_FILE_NAME%>IpSetMulticastInterface: Error %d", result);
      }
      // Send UDP data
      gResult = UdpSendTo(gUdpSocketHandleSysteminfo_01, ipv6DstAddr, ipv6DstPort, textData, strlen(textData));
      write( "<%BASE_FILE_NAME%>UdpSendTo to ipv6: ");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6DstAddr[i]);
      }
      
 
      
      
      // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleSysteminfo_01) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleSysteminfo_01, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleSysteminfo_01) );
      }
 
      // Optionally receive answer from UDP server
      UdpReceiveFrom(gUdpSocketHandleSysteminfo_01, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(gUdpSocketHandleSysteminfo_01) != 997 )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleSysteminfo_01, gErrorText, elcount(gErrorText));
        write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleSysteminfo_01));
      }

      
      
    }
 }

/// <Pdu_Systeminfo_01>
void Pdu_Systeminfo_01_vJoinIPv6MulticastGrp( byte ipv6MultiCastAddr[],dword ipv6MulticastPort)
{
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
  //wildcard IP binding
  long result; // function result
  dword ifIdx = 2;
  Dword port = 12345;
  
    //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
  
        gUdpSocketHandleSysteminfo_01Recv = UdpOpen(ipv6WildcardAddrArray, ipv6MulticastPort); // open an UDP socket...
        if (gUdpSocketHandleSysteminfo_01Recv != ~0)
        {
          result = IpJoinMulticastGroup( gUdpSocketHandleSysteminfo_01Recv, ifIdx, ipv6MultiCastAddr );
          if (result == 0)
          {
            // successfully joined.
            write("successfully joined:  %d", result);
            
            // Optionally receive answer from UDP server
            UdpReceiveFrom(gUdpSocketHandleSysteminfo_01Recv, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

            // Check for error
            if ( IpGetLastSocketError(gUdpSocketHandleSysteminfo_01Recv) != 997 )
            {
              IpGetLastSocketErrorAsString(gUdpSocketHandleSysteminfo_01Recv, gErrorText, elcount(gErrorText));
              write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleSysteminfo_01Recv));
              }  

          }
          else
          {
            writeLineEx(1, 3, "IpJoinMulticastGroup: Error %d", result);
          }
        }

    }
    else
     {
       writeLineEx(1, 3, "IpGetAddressAsArray: The wildcard address string was invalid.");
     }
}

/// <Pdu_Systeminfo_01>
word Pdu_Systeminfo_01_u16SetPduMarshallingUdp(long Len,long ID,char Data[])
 {
  char PduLen[4]; //Pdu length of the user data in byte according to the data
  char PduID[4]; 

  
  PduID[3] = (char)(ID & 0x000000ff);
  PduID[2] = (char)((ID & 0x0000ff00) >> 8);
  PduID[1] = (char)((ID & 0x00ff0000) >> 16);
  PduID[0] = (char)((ID & 0xff000000) >> 24);
  
  
  PduLen[3] = (char)(Len & 0x000000ff);
  PduLen[2] = (char)((Len & 0x0000ff00) >> 8);
  PduLen[1] = (char)((Len & 0x00ff0000) >> 16);
  PduLen[0] = (char)((Len & 0xff000000) >> 24); 
  
  write("PDU ID: %d \r",Len);
  write("%x \r",PduLen[0]);
  write("%x \r",PduLen[1]);
  write("%x \r",PduLen[2]);
  write("%x \r",PduLen[3]);
  
  write("PDU Len: %d \r",ID);
  write("%x \r",PduID[0]);
  write("%x \r",PduID[1]);
  write("%x \r",PduID[2]);
  write("%x \r",PduID[3]);
   
  if(1452 <= Pdu_Systeminfo_01_WritePtrPdu) /* Udp Payload is full */
    return 0;
  

  memcpy_off( Pdu_Systeminfo_01_PduMarshallingData,  Pdu_Systeminfo_01_WritePtrPdu + 0, PduID,0,4 );
  
  memcpy_off( Pdu_Systeminfo_01_PduMarshallingData,  Pdu_Systeminfo_01_WritePtrPdu + 4, PduLen,0,4 ); 
  
  memcpy_off( Pdu_Systeminfo_01_PduMarshallingData,  Pdu_Systeminfo_01_WritePtrPdu + 8, Data,0,Len );  
  
  Pdu_Systeminfo_01_WritePtrPdu = Pdu_Systeminfo_01_WritePtrPdu + 8 + Len;

  return 0;
 }

on sysvar_update Systeminfo_01::SI_T_Mode
{
  InitIPV6dataSysteminfo_01();//Update Ethernet message
}

on sysvar_update Systeminfo_01::SI_NWDF
{
  InitIPV6dataSysteminfo_01();//Update Ethernet message
}

on sysvar_update Systeminfo_01::SI_NWDF_gueltig
{
  InitIPV6dataSysteminfo_01();//Update Ethernet message
}

dword DoIP_getSocketHandleByAddr()
{
  int i = 0;
  long lSrcAddr;
  dword handle;
  
  sysGetVariableInt(sysvar::DoIP::SrcAddr, lSrcAddr);
  for (i = 0; i < 2; i++)
  {
    if (stDoIpHandle[i].sourceAddr == lSrcAddr)
    {
      handle = stDoIpHandle[i].socketHandle;
      break;
    }
  }
  return handle;
}

on timer tDiagnose_01_TxMsg
{
  if(@Diagnose_01::Diagnose_01_On == 1 && getValue( eUDPSendEnabled ))
  {
    SendIPV6dataDiagnose_01();
  }      
  setTimer( tDiagnose_01_TxMsg, Diagnose_01_TxMsgCycleTime );
}

on sysvar_update DoIP::SendID
{
  if(@this)
    DoIP_SenCmd(0x0001, gTcpSocketHandleGW);
}

on sysvar_update DoIP::SendIDVIN
{
   if(@this)
  DoIP_SenCmd(0x0003, gTcpSocketHandleGW);
}

on sysvar_update DoIP::SendIDEID
{
   if(@this)
  DoIP_SenCmd(0x0002, gTcpSocketHandleGW);
}

on sysvar_update DoIP::SendPwrMode
{
   if(@this)
  DoIP_SenCmd(0x4003, gTcpSocketHandleGW);
}

on sysvar_update DoIP::SendEntityStatus
{
   if(@this)
    DoIP_SenCmd(0x4001, gTcpSocketHandleGW);
}

on sysvar_update DoIP::SendRoutingAct
{
  if(@this)
      DoIP_SenCmd(0x0005, gTcpSocketHandleGW);
}

on sysvar_update DoIP::SendRoutingActSecond
{
  if(@this)
    DoIP_SenCmd(0x0005, gTcpSocketHandleGWSecond);
}

//on sysvar_update DoIP::SendAliveCheck
//{
//  if(@this)
//    DoIP_SenCmd(0x0007, gTcpSocketHandleGW);
//}

on sysvar_update DoIP::SendAliveCheckResponse
{
  if(@this)
    DoIP_SenCmd(0x0008, gTcpSocketHandleGW);
}


on sysvar_update DoIP::SendDiagMsg
{
  if(@this)
     DoIP_SenCmd(0x8001, gTcpSocketHandleGW);
}

on sysvar_update DoIP::SendDiagMsgSecond
{
  if(@this)
     DoIP_SenCmd(0x8001, gTcpSocketHandleGWSecond);
}

on sysvar_update DoIP::SendArbitraryDoIPUdp
{
  if(@this)
  {
    long DataLen;
    word wDataLen;
    byte TempByte[1] ='\0';
        
    DoIP_DeInitPresentTester();
    sysSetVariableInt(sysvar::DoIP::ActivateTesterPresent, 0);
    
    memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
    
    DataLen = elcount(sysvar::DoIP::ArbitraryDoIPInputMsg);
    if (DataLen < 0xFFFF)
    {
      sysGetVariableData(sysvar::DoIP::ArbitraryDoIPInputMsg, gDoIPPayload, DataLen);
      wDataLen = (word)DataLen;
      if(@DoIP::multicast)
        gResult = SendUdpMsg(gUdpSocketHandleGW, ipv6MulticastGrp, dwDstPort, gDoIPPayload, wDataLen);
      else
        gResult = SendUdpMsg(gUdpSocketHandleGW, ipv6Kombi, dwDstPort, gDoIPPayload, wDataLen);  
    
      
      putValueToControl( kPanelName, "DoIPOutput", " Sent arbitrary Udp message. \r\n");
      sysSetVariableData(sysvar::DoIP::OutputHex, TempByte, 0 ); //clear hex output
    }
    else
    {
      putValueToControl( kPanelName, "DoIPOutput", " Message is too long, can't send it! \r\n");
    }
    
  }
}

on sysvar_update DoIP::SendArbitraryDoIPTcp
{
  if(@this)
  {
    long DataLen;
    word wDataLen;
    byte TempByte[1] ='\0';
    
    DoIP_DeInitPresentTester();
    sysSetVariableInt(sysvar::DoIP::ActivateTesterPresent, 0);
    
    memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
    
    DataLen = elcount(sysvar::DoIP::ArbitraryDoIPInputMsg);
    if (DataLen < 0xFFFF)
    {
      sysGetVariableData(sysvar::DoIP::ArbitraryDoIPInputMsg, gDoIPPayload, DataLen);
      wDataLen = (word)DataLen; 
      TcpSendtoServer(gDoIPPayload, wDataLen, gTcpSocketHandleGW);
      
      sysSetVariableData( sysvar::DoIP::InputHext, gDoIPPayload, wDataLen ); //output sent hex 
      
      putValueToControl(kPanelName, "DoIPOutput", " Sent arbitrary Tcp message. \r\n");
      sysSetVariableData(sysvar::DoIP::OutputHex, TempByte, 0 ); //clear hex output
      sysSetVariableData( sysvar::DoIP::OutputHexRxDiag, TempByte, 0 ); //clear hex output
      DisplayArbitraryMsg = 1; 
    }
    else
    {
      putValueToControl( kPanelName, "DoIPOutput", " Message is too long, can't send it! \r\n");
    }
  }
}

on sysvar_update DoIP::ActivateTesterPresent
{
  if(@this)
  {
    settimer(AutoSendTesterPresentMsg, sysGetVariableInt(sysvar::DoIP::TesterPresentTimerDuration));
  }
  else
  {
    DoIP_DeInitPresentTester();
  }
}
on timer AutoSendTesterPresentMsg
{
  int MsgNr;
  word MsgLen = 0;
  byte DiagMsg0[2]= {0x3E, 0x80};
  byte DiagMsg1[2]= {0x3E, 0x00};
  
  DoIP_ProInit();
  memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
  DoIP_MessageHeadBuilder(0x8001,4+2); //4 (bytes of addr) + 2 (DiagMsg0 or DiagMsg1 length)
  memcpy_h2n(gDoIPPayload,8,stDiagMsgHead); //copy src and trg address 
  memcpy_h2n(gDoIPPayload,stDoIPHead); // copy protocols
  
  MsgNr = sysGetVariableInt(sysvar::DoIP::TesterPresentMsg);
  switch (MsgNr)
  {
    case 0:
      memcpy_off(gDoIPPayload,8+4,DiagMsg0,0,2); //8= head, 4= Diag head , 2= Diagmsg0 length
      break;
    case 1:
      memcpy_off(gDoIPPayload,8+4,DiagMsg1,0,2); //8= head, 4= Diag head , 2= Diagmsg1 length
      break;
  }
  IgnoreDiagMsgReply = 1;
  MsgLen = 8 + 4 + 2; //8= head, 4= Diag head , 2= Diagmsg1 length
  TcpSendtoServer(gDoIPPayload, MsgLen, gTcpSocketHandleGW);
  settimer(AutoSendTesterPresentMsg, sysGetVariableInt(sysvar::DoIP::TesterPresentTimerDuration));
}

void DoIP_DeInitPresentTester()
{
  IgnoreDiagMsgReply = 0;
  cancelTimer(AutoSendTesterPresentMsg);
}
  

/// <DoIP_Cmd>
void DoIP_SenCmd(word wID, dword handle)
{
  DoIP_DeInitPresentTester();
  sysSetVariableInt(sysvar::DoIP::ActivateTesterPresent, 0);
  DoIP_ProInit();
  
  switch (wID)
   {
    case 0x1:
      DoIP_VinRequest();
      
      break;
          case 0x2:
      DoIP_VinRequest_EID();
      
      break;
          case 0x3:
      DoIP_VinRequest_VIN();
      
      break;
          case 0x4001:
      DoIP_Entity_Status_Request();
      
      break;
          case 0x4003:
      DoIP_Pwr_mode_Request();
      
      break;
      
          case 0x5:
      DoIP_Route_Act_Request(handle);
      
      break;
      
      case 0x7:
      //DoIP_Alive_Check(handle);
      
      break;
      
      case 0x08:
        DoIP_Alive_Check_Response(handle);
      break;
      
      case 0x8001:
      DoIP_DiagMsg_Request(handle);
      
      break;
      
  }
}

/// <DoIP_Cmd>
void DoIP_VinRequest()
{
  DoIP_MessageHeadBuilder(0x0001,0);
  DoIP_MessageUdpSend(gcRequestHeadLen);
  
  putValueToControl( kPanelName, "DoIPOutput", " Sent Vehicle Indetification  request. \r\n");
}

/// <DoIP_Cmd>
void DoIP_VinRequest_EID()
{
  DoIP_MessageHeadBuilder(0x0002,6); //6 bytes of eid
  
  memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
  
  memcpy_off(gDoIPPayload,8,Eid,0,6);
  
  DoIP_MessageUdpSend(gcRequestHeadLen+6);
  
   putValueToControl( kPanelName, "DoIPOutput", " Sent Vehicle Indetification  request with EID. \r\n");
}

/// <TCP>

int TcPClientStart()
{
  BYTE  remoteAddressIPv6[16];
  BYTE  localAddressIPv6[16];
  CHAR  errorText[200];
  CHAR  buf[32];
  LONG  result;
  byte ServerPortIndex;
  long TcpServerPorts;
  long TcpClientPort = 13400 ;
 
  TcpServerPorts = 13400;

  

  // Setup server address
  //

  if( ipGetAddressAsArray(ipv6KombiStr, remoteAddressIPv6) == 0 )
  {
    //
    // Create IPv6 TCP socket and connect
    //

      write( "$$  <%BASE_FILE_NAME%> Connecting to %s ...", ipv6KombiStr );


    
          ipGetAddressAsArray("::", localAddressIPv6);
    
          gTcpSocketHandleGW = TcpOpen( localAddressIPv6, TcpClientPort );
    
          if (IpGetLastSocketError(gTcpSocketHandleGW) != 0)
          {
            IpGetLastSocketErrorAsString( gTcpSocketHandleGW, errorText, elcount(errorText) );
            write( "$$  <%BASE_FILE_NAME%> TcpSocket::open IPv6 failed, %s (Result %d)", errorText, IpGetLastSocketError(gTcpSocketHandleGW) );
            return -1;
          }

          IpSetSocketOption(gTcpSocketHandleGW, "IPPROTO_IPV6", "IPV6_TCLASS",0);
          IpSetSocketOption(gTcpSocketHandleGW, "IPPROTO_IPV6", "IPV6_AUTOFLOWLABEL",0);
          
          result = TcpConnect( gTcpSocketHandleGW, remoteAddressIPv6, TcpServerPorts );
          if (result != 0 && ipGetLastSocketError(gTcpSocketHandleGW) != 10035 ) // WSAEWOULDBLOCK
          {
            IpGetLastSocketErrorAsString(gTcpSocketHandleGW, errorText, elcount(errorText) );
            write( "$$  <%BASE_FILE_NAME%> TcpSocket::connect IPv6 failed, %s (Result %d)", errorText,IpGetLastSocketError(gTcpSocketHandleGW) );
            return -1;
          }
          
          write( "$$  <%BASE_FILE_NAME%> TCP Client connecting to port: %d, from Socket: 0x%x", TcpServerPorts,gTcpSocketHandleGW  );

      
  
  }
        return 0;
}

on sysvar_update DoIP::PollDiag
{
  if(@this)
  {
    setTimer( PollTimer, 1 ); //disabled for test
   }
  else
   {
    cancelTimer(PollTimer);    
   }
}

on sysvar DoIP::DoIP_AutoAliveResponse
{
  if (@this)
  {
    gAliveCheckAutoResponse = 1;
    putValueToControl( kPanelName, "DoIPOutput", "\t\t\tActivated AutoResponse for Alive check \r\n");
  }
  else
  {
    gAliveCheckAutoResponse = 0;
    putValueToControl( kPanelName, "DoIPOutput", "\t\t\tDe-Activated AutoResponse for Alive check \r\n");
  }
}

on timer PollTimer
{
       DoIP_SenCmd(0x8001, gTcpSocketHandleGW);
  
  setTimer(PollTimer, 3);
}

/// <DoIP_Cmd>
//tcp cmd
void DoIP_Route_Act_Request(dword handle)
{
    memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
  
    DoIP_MessageHeadBuilder(0x005,11); // Payload type 0x0005 + Length 11
  
    memcpy_h2n(gDoIPPayload,8,stRoutingActivation);
   
    DoIP_MessageTcpSend(gcRequestHeadLen+11, handle);
  
    putValueToControl( kPanelName, "DoIPOutput", " Sent Routing activation request. \r\n");
}

word DoIP_wBuildDiagMsg(byte abData[])
{
  word wLen;
  
  wLen = elcount(abData);
  
  return wLen;
}

/// <DoIP_Cmd>
void DoIP_DiagMsg_Request(dword handle)
{
  word wDiagMsgLen;
  
  byte abDiagUserData[100];
  long CmdLen;
  
  CmdLen = elcount(sysvar::DoIP::DiagCmd); 
  
   sysGetVariableData( sysvar::DoIP::DiagCmd, abDiagUserData, CmdLen);
  
  //   wDiagMsgLen = DoIP_wBuildDiagMsg(abDiagUserData);
    wDiagMsgLen =   CmdLen;
  
     DoIP_MessageHeadBuilder(0x8001,4+wDiagMsgLen); //4 bytes of addr + diag length
  
     memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
  
     memcpy_h2n(gDoIPPayload,8,stDiagMsgHead);
  
     memcpy_off(gDoIPPayload,8+4,abDiagUserData,0,wDiagMsgLen); //8 = head, 4= Diag head
    
   
    DoIP_MessageTcpSend(gcRequestHeadLen+wDiagMsgLen+4, handle);
  
    putValueToControl( kPanelName, "DoIPOutput", " Sent Diagnosis request. \r\n");
}

/// <TCP>
/*
  Stop Chat Client and close connection to server
*/
int TcpClientStop()
{
  CHAR errorText[200];
  byte ServerPortIndex;

  //
  // Close socket
  //
        TcpClose(gTcpSocketHandleGW);
        gTcpSocketHandleGW = 0;
  
  return 0;
  
}

/// <TCP>
/*
 * Send text of SysVar ChatClient1::Text to server.
 */
int TcpSendtoServer(byte abData[], word wLen, dword handle)
{
  Byte text[1048510];
  char chartext[1048510]; 
  long copiedBytes;
  byte newData[1];
  long result;
  
 // sysGetVariableData( sysvar::TCPClt::SendBuffer, text,copiedBytes );
  
  //sysSetVariableData( sysvar::TCPSrv::RecvBuffer, newData, 0 ); //clear buffer
  
  //sysSetVariableInt( sysvar::TCPSrv::RecvLen, 0 );
  
  result =  TcpSend( handle, abData, wLen );
  
 // sysGetVariableInt( sysvar::TCPClt::SendLen, copiedBytes );


    memcpy(chartext,text,copiedBytes);
  
   if (result == 0)
  {
    // sending took place immediately.
      
    write( "$$  <%BASE_FILE_NAME%> TCP Sent out %d bytes",wLen );
   // writeLineEx(1, 1, " [ $ <%BASE_FILE_NAME%>: Synchronous sending: on socket %d ]", gTcpSocketHandleGW);
    OnTcpSend(handle, result, chartext, copiedBytes); // trigger callback manually
  }
  else
  {
    if (result == -1)
    {
      result = IpGetLastSocketError(gTcpSocketHandleGW);
      if (result == 997)
      {
        // sending is done asynchronously.
        writeLineEx(1, 1, " [ $$ <%BASE_FILE_NAME%>: Asynchronous sending: on socket %d ]", gTcpSocketHandleGW);
        // => OnTcpSend is called when done sending.
      }
      else
      {
        writeLineEx( 1, 3, " [ $$ <%BASE_FILE_NAME%>: sendTcpData: Error sending data. (%d) ]", result);
      }
    }
    else
    {
      writeLineEx( 1, 3, " [ $$ <%BASE_FILE_NAME%>: sendTcpData: Error sending data. (%d) ]", result);
    }
  } 
  
  return 0;
}




OnTcpSend(dword socket, long result, char buffer[], dword size)
{
  TcpReceivefromServer(socket);
}

/// <TCP>
int TcpReceivefromServer(dword socket)
{
    char msg[100];
    int i;
    int offset;
    CHAR errorText[200];
  long result;
  
   write( "$$  <%BASE_FILE_NAME%> Started receiving.." );
   snprintf(msg, elcount(msg), "\tStarted receiving... result: %d\n", result);
   putValueToControl( kPanelName, "DoIPOutput", msg);
  
   //sysSetVariableInt( sysvar::TCPClt::RecvLen, 0 );
   for (i = 0; i < elCount(gReceiveBuffer); i++)
   {
       gReceiveBuffer[i] = 0;
   }
   
   result = TcpReceive( socket, gReceiveBuffer, elcount(gReceiveBuffer) );
  
  if (result == -1)
  {
    result = IpGetLastSocketError(gTcpSocketHandleGW);
    if (result != 997) // not asynchronous
    {
      // failure
      IPGetLastSocketErrorAsString(gTcpSocketHandleGW, errorText, elcount(errorText) );
      write( "$$ <%BASE_FILE_NAME%> TcpReceive failed, %s (Result %d)", errorText, IpGetLastSocketError(gTcpSocketHandleGW) );
      
    }
  }
  else if (result != 0) // synchronous sending failed
  {
    // failure
    writeLineEx( 1, 3, "$$ <%BASE_FILE_NAME%>: TcpReceive error %d", result);
  }
  else // result == 0
  {
    snprintf(msg, elcount(msg), "\tReceived data");
    putValueToControl( kPanelName, "DoIPOutput", msg);
    }
    return 0;
}

/// <TCP>
/*
 * socket  - Socket handle of the client
 * result  - Result of the operation, 0 on success
 * buffer  - Buffer which contains the received data
 * size    - Size in bytes of the received data
*/

void TcpReceiveInternal( dword socket, long result, char buffer[], dword size, dword port)
{
    long retVal;
  
    char msg[100];
    int i;
    int offset;
  
    char SendText[200];
    byte newData[1];
    long copypostion;
    long copiedBytes;
  
    byte TempByte[1460];
    byte diagResp[1460];
    int diagRespLen;

    memcpy(TempByte,buffer,size);
  
    write( "$$  <%BASE_FILE_NAME%> TCP received %d bytes, socket 0x%x", size, socket );

    if((socket == gTcpSocketHandleGW || socket == gTcpSocketHandleGWSecond) && !IgnoreDiagMsgReply )
  {
    /* TCP Diagnostic N/Aknowledgement Msg Received : 0x8002-positive , 0x8003-negative*/
    if(TempByte[2] == 0x80 && (TempByte[3] == 0x02 || TempByte[3] == 0x03))   
    {
      sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, size );
     
      write( "$$  <%BASE_FILE_NAME%>  %d bytes copied to Hex Panel", size);
      putValueToControl( kPanelName, "DoIPOutput", "\t Received Tcp aknowledge from Kombi. \r\n");
      //Call again TcpReceive (OnTcpReceive is called automatically) to get also the TCP Response
      TcpReceive(socket, buffer, 0 );
      
      //print the diagnostic message acknowledge inofrmation in "Rx Diag Data" box
      i=0; 
      diagRespLen=0;
      write("SIZE:%d", size);
      for(i=12; i<size; i++)
      {
        diagResp[diagRespLen] = TempByte[i];
        diagRespLen++;
      }
      sysSetVariableData( sysvar::DoIP::OutputHexRxDiag, diagResp, diagRespLen);
      write( "$$  <%BASE_FILE_NAME%>  %d bytes copied to Hex Panel", size);
      putValueToControl( kPanelName, "DoIPOutput", "\t Received Tcp response from Kombi. \r\n");
    }
    /* Routing Activation Response : 0x0006*/
    else if (TempByte[2] == 0x00 && TempByte[3] == 0x06 )
    {
      if (TempByte[12] == 0x10) // Routing activation response code is in 4th byte of answer after header (4+8) : positive answer
      {
        if(socket == gTcpSocketHandleGW  )
        {
          sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing1, 1);
          clearBuff(msg, elCount(msg));
          snprintf(msg, elCount(msg), "Socket: 0x%x Port: 0x%x SA: 0x%x%x", socket, port, TempByte[8], TempByte[9]);
          sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToOne, msg); 
        }
        else if(socket == gTcpSocketHandleGWSecond  ) 
        {
          sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing2, 1);
          clearBuff(msg, elCount(msg));
          snprintf(msg, elCount(msg), "Socket: 0x%x Port: 0x%x SA: 0x%x%x", socket, port, TempByte[8], TempByte[9]);
          sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToSecond, msg);
        }
      }
      else // negative answer
      {
        if(socket == gTcpSocketHandleGW  )
        {
          sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing1, 0);
          clearBuff(msg, elCount(msg));
          snprintf(msg, elCount(msg), "None");
          sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToOne, msg);
        }
        else if(socket == gTcpSocketHandleGWSecond  ) 
        {
          sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing2, 0);
          clearBuff(msg, elCount(msg));
          snprintf(msg, elCount(msg), "None");
          sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToSecond, msg);
        }
      }
      // we show the answer anyway in output box
      sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, size );
    }
    /* Alive check request : 0x0007 */
    else if (TempByte[2] == 0x00 && TempByte[3] == 0x07)
    {
      putValueToControl( kPanelName, "DoIPOutput", "\tReceived Alive check request\r\n");
      if(gAliveCheckAutoResponse == 1)
      {
        if(socket == gTcpSocketHandleGW  )
        {
          DoIP_SenCmd(0x0008, gTcpSocketHandleGW);
        }
        else 
        {
          // do nothing 
        }
      }
      else if (sysGetVariableInt(sysvar::DoIP::DoIP_AutoAliveResponseDelay))
      { 
        if(socket == gTcpSocketHandleGW  )
        {
          settimer(AutoAliveResponseTimer, sysGetVariableInt(sysvar::DoIP::DoIP_AutoAliveResponseTimer));
        }
        else
        {
          // do nothing
        }
      }
      // we show the request anyway in output box
      sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, size );
    }
    /* generic NACK recieved 0x0000 */
    else if (TempByte[2] == 0x00 && TempByte[3] == 0x00)
    {
      //do nothing just print the NACK message in output box
      sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, size );
    }
    else
    {
      // do nothing
    }
  }
  else if (DisplayArbitraryMsg) //option to display any msg on OutputHex
  {
    sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, size );
    DisplayArbitraryMsg = 0;
  }
}


OnTcpConnect(dword socket, long result)
{
  char msg[100];
  write( "$$  <%BASE_FILE_NAME%> OnTcpConnect with result %d, socket 0x%x", result, socket );
  //snprintf(msg, elcount(msg), "OnTcpConnect with result %d, socket 0x%x\n", result, socket);
  //putValueToControl( kPanelName, "DoIPOutput", msg);

  if (result == 0)
  {
    if(socket == gTcpSocketHandleGW  )
    {
      write("Tcp client connected from socket 0x%x ", gTcpSocketHandleGW);
      snprintf(msg, elcount(msg), "Tcp client connected to socket 0x%x with result: %d\n", gTcpSocketHandleGW, result);
      putValueToControl( kPanelName, "DoIPOutput", msg);
      sysSetVariableInt( sysvar::DoIP::DoIP_ConnectionServStatus, 1);
    }
    if(socket == gTcpSocketHandleGWSecond  )
    {
      write("Tcp client connected from socket 0x%x ", gTcpSocketHandleGWSecond);
      snprintf(msg, elcount(msg), "Tcp client connected to socket 0x%x with result: %d\n", gTcpSocketHandleGWSecond, result);
      putValueToControl( kPanelName, "DoIPOutput", msg);
      sysSetVariableInt( sysvar::DoIP::DoIP_ConnectionServStatus2, 1);
    }  
  }
}

OnTcpClose( dword socket, long result)
{
  char msg[100];
  write( "$$  <%BASE_FILE_NAME%> TCP connection closed, result %d", result );
  snprintf(msg, elcount(msg), "TCP connection closed from socket: 0x%x, result %d\n", socket, result);
  putValueToControl( kPanelName, "DoIPOutput", msg);
  if(socket == gTcpSocketHandleGW  )
  {
    sysSetVariableInt( sysvar::DoIP::DoIP_ConnectionServStatus, 0);
    sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing1, 0);
    clearBuff(msg, elCount(msg));
    snprintf(msg, elCount(msg), "None");
    sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToOne, msg);
  }
  if(socket == gTcpSocketHandleGWSecond  )
  {
    sysSetVariableInt( sysvar::DoIP::DoIP_ConnectionServStatus2, 0);
    sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing2, 0);
    clearBuff(msg, elCount(msg));
    snprintf(msg, elCount(msg), "None");
    sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToSecond, msg);
  }
  TcpClose(socket);
  socket = 0;
}

OnTcpReceive(dword socket, long result, byte ipv6Address[], dword port, char buffer[], dword size)
{
    TcpReceiveInternal( socket, result, buffer, size, port);
}

/// <DoIP_Cmd>
void DoIP_VinRequest_VIN()
{
  DoIP_MessageHeadBuilder(0x0003,17); // Payload type 0x0003 + Length 17
  
  memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
  
  memcpy_off(gDoIPPayload,8,Vin,0,17);
  
  DoIP_MessageUdpSend(gcRequestHeadLen+17);
  putValueToControl( kPanelName, "DoIPOutput", " Sent Vehicle Indetification  request with VIN. \r\n"); 
}

/// <DoIP_Cmd>
void DoIP_Entity_Status_Request()
{
  DoIP_MessageHeadBuilder(0x4001,0); // Payload type 0x4001 + Length 0
   
  DoIP_MessageUdpSend(gcRequestHeadLen);
  putValueToControl( kPanelName, "DoIPOutput", " Sent Entity status request. \r\n");
  
}

/// <DoIP_Cmd>
void DoIP_Pwr_mode_Request()
{
  DoIP_MessageHeadBuilder(0x4003,0); // Payload type 0x4003 + Length 0
   
  DoIP_MessageUdpSend(gcRequestHeadLen);
  putValueToControl( kPanelName, "DoIPOutput", " Sent Power mode status request. \r\n");
  
}

/// <DoIP_Cmd>
//tcp cmd
//wrong, check_req is DOIP-Module's output, not an input for it
//void DoIP_Alive_Check(dword handle) 
//{
//  DoIP_MessageHeadBuilder(0x0007,0); // Payload type 0x0007 + Length 0
//  DoIP_MessageTcpSend(gcRequestHeadLen, handle);
//    putValueToControl( kPanelName, "DoIPOutput", "\tSent Alive check status request. \r\n");
//  
//}

/// <DoIP_Cmd>
//tcp cmd
void DoIP_Alive_Check_Response(dword handle)
{
  DoIP_MessageHeadBuilder(0x0008,2); // Payload type 0x0007 + Length 0
  
  stDoIPSrcAddr.addr = 0xAAAA;
  memcpy_h2n(gDoIPPayload,2,stDoIPSrcAddr);
  
  DoIP_MessageTcpSend(gcRequestHeadLen + 2, handle);
  putValueToControl( kPanelName, "DoIPOutput", "\tSent Alive check status response. \r\n");
}

/// <DoIP>
void DoIP_ProInit()
{
  long EidLen =6;
  long VinLen =17;
  long lSrcAddr;
  long lDstAddr;
  long lProtoVer;
  long lActType;
  
  stRoutingActivation.Reservedoc = 0;
  stRoutingActivation.ReserveOEM = 0;

  sysGetVariableInt( sysvar::DoIP::SrcAddr,lSrcAddr ); 
  sysGetVariableInt( sysvar::DoIP::DstAddr, lDstAddr); 
  sysGetVariableInt( sysvar::DoIP::ProtocolVer, lProtoVer); 
  sysGetVariableInt( sysvar::DoIP::ActType, lActType); 

  stDoIPHead.ProtocolVer = lProtoVer;
  stDoIPHead.InvProtocolVer = ~stDoIPHead.ProtocolVer;
  
  stRoutingActivation.ActType = lActType;
  stRoutingActivation.SrcAddr = lSrcAddr;

  stDiagMsgHead.SrcAddr = lSrcAddr;
  stDiagMsgHead.DstAddr = lDstAddr;

  sysGetVariableData( sysvar::DoIP::EID, Eid, EidLen ); 
  sysGetVariableData( sysvar::DoIP::VIN, Vin, VinLen );  
}


/// <Udp>
OnUdpReceiveFrom(dword socket, long result, byte ipv6Address[], dword port, char buffer[], dword size)
{
      if(port == dwDstPort) //Only if it is msg from the UDPNM channel 
    {
        RecvMsghandler(buffer, size);
        write("<%BASE_FILE_NAME%> Received message from Udp port");
    }

   ReceiveUdpMsg( socket);
}

on key 'b'
{
  strncpy(txBuffer, "Hello UDP from CANoe", elcount (txBuffer));
  udpSendTo(udpHandle, receiverIPdw, receiverPortdw, txBuffer, strlen(txBuffer)); 
  
}

/// <Udp>
byte u8IPv6Compare(byte ipv6Address1[],byte ipv6Address2[])
{
  byte Cnt;
  
  for(Cnt=0;Cnt<16;Cnt++)
  {
    if(ipv6Address1[Cnt] != ipv6Address2[Cnt])
    {
      return 1; //different IP
    }
  }
  
  return 0;//same IP  
}

/// <Udp>
void vOpenIPv6UdpPort( dword &UdpSocketHandler, byte ipv6SrcAddr[],dword ipv6SrcPort)
{
    int i;                          // loop variable  
    dword result;  
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
    char textData[20] = "Hello UDP Server";
  
  //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
      // success...
      write("<%BASE_FILE_NAME%>IpGetAddressAsArray: returned wildcard array with IPv6 bytes:");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6WildcardAddrArray[i]);
      }
    }
    else
    {
      writeLineEx(1, 3, "IpGetAddressAsArray: The wildcard address string was invalid.");
    }
 

    // Open UDP socket
    UdpSocketHandler = UdpOpen(ipv6SrcAddr, sysGetVariableInt(sysvar::DoIP::UDPSrcPort)); // if The port parameter is set to zero. => A free local port is selected by the stack.

    // Check for valid socket handle
    if (UdpSocketHandler == ~0)
    {
      write("<%BASE_FILE_NAME%> UdpOpen failed: Result %d", IpGetLastError());
    }
    else // Socket handle valid
    {

        write("<%BASE_FILE_NAME%> Udp Open is successful..  ");

    }
 }

 on sysvar_update DoIP::DisconnectSrv
 {
    char msg[100];
    long TcpServerPorts;
    
    TcpServerPorts = 13400;
    if(@this)
    {
        TcpClose(gTcpSocketHandleGW);
        write( "$$  <%BASE_FILE_NAME%> TCP Client disconnecting from port: %d, from Socket: 0x%x", TcpServerPorts,gTcpSocketHandleGW  );
        snprintf(msg, elcount(msg), "TCP Client disconnecting from port: %d, from Socket: 0x%x\n", TcpServerPorts, gTcpSocketHandleGW);
        putValueToControl( kPanelName, "DoIPOutput", msg);
        sysSetVariableInt( sysvar::DoIP::DoIP_ConnectionServStatus, 0);
        sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing1, 0);
        clearBuff(msg, elCount(msg));
        snprintf(msg, elCount(msg), "None");
        sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToOne, msg);
        gTcpSocketHandleGW = 0;
    }
 }

 on sysvar_update DoIP::DisconnectSrv2
 {
    char msg[100];
    long TcpServerPorts;
    
    TcpServerPorts = 13400;
    if(@this)
    {
        TcpClose(gTcpSocketHandleGWSecond);
        write( "$$  <%BASE_FILE_NAME%> TCP Client disconnecting from port: %d, from Socket: 0x%x", TcpServerPorts,gTcpSocketHandleGWSecond);
        snprintf(msg, elcount(msg), "TCP Client disconnecting from port: %d, from Socket: 0x%x\n", TcpServerPorts, gTcpSocketHandleGWSecond);
        putValueToControl( kPanelName, "DoIPOutput", msg);
        sysSetVariableInt( sysvar::DoIP::DoIP_ConnectionServStatus2, 0);
        sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing2, 0);
        clearBuff(msg, elCount(msg));
        snprintf(msg, elCount(msg), "None");
        sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToSecond, msg);
        gTcpSocketHandleGWSecond = 0;
    }
 }

on sysvar_update DoIP::ConnectSrv
{
    char  msg[100];
    BYTE  remoteAddressIPv6[16];
    BYTE  localAddressIPv6[16];
    CHAR  errorText[200];
    LONG  result;

    long TcpServerPorts;
    long TcpClientPort = 13400 ;

    TcpServerPorts = 13400;
  

  
   if(@this)
  {
          TcpClose(gTcpSocketHandleGW);
          gTcpSocketHandleGW = 0;
          TcpClose(gTcpSocketHandleGWSecond);
          gTcpSocketHandleGWSecond = 0;

          gTcpSocketHandleGW = TcpOpen( localAddressIPv6, sysGetVariableInt( sysvar::DoIP::TCPSrcPort ));
          
          stDoIpHandle[0].socketHandle = gTcpSocketHandleGW;
          stDoIpHandle[0].sourceAddr   = sysGetVariableInt(sysvar::DoIP::SrcAddr);
    
          if (IpGetLastSocketError(gTcpSocketHandleGW) != 0)
          {
            IpGetLastSocketErrorAsString( gTcpSocketHandleGW, errorText, elcount(errorText) );
            write( "$$  <%BASE_FILE_NAME%> TcpSocket::open IPv6 failed, %s (Result %d)", errorText, IpGetLastSocketError(gTcpSocketHandleGW) );
            snprintf(msg, elcount(msg), "TcpSocket::open IPv6 failed, %s (Result %d)\n", errorText, IpGetLastSocketError(gTcpSocketHandleGW));
            putValueToControl( kPanelName, "DoIPOutput", msg);
            sysSetVariableInt( sysvar::DoIP::DoIP_ConnectionServStatus, 0);
            sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing1, 0);
            clearBuff(msg, elCount(msg));
            snprintf(msg, elCount(msg), "None");
            sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToOne, msg);
           
          }

          ipGetAddressAsArray(ipv6KombiStr, remoteAddressIPv6);
          IpSetSocketOption(gTcpSocketHandleGW, "IPPROTO_IPV6", "IPV6_TCLASS",0);
          IpSetSocketOption(gTcpSocketHandleGW, "IPPROTO_IPV6", "IPV6_AUTOFLOWLABEL",0);	 

          result = TcpConnect( gTcpSocketHandleGW, remoteAddressIPv6, TcpServerPorts );
          if (result != 0 && ipGetLastSocketError(gTcpSocketHandleGW) != 10035 ) // WSAEWOULDBLOCK
          {
            IpGetLastSocketErrorAsString(gTcpSocketHandleGW, errorText, elcount(errorText) );
            write( "$$  <%BASE_FILE_NAME%> TcpSocket::connect IPv6 failed, %s (Result %d)", errorText,IpGetLastSocketError(gTcpSocketHandleGW) );
            snprintf(msg, elcount(msg), "TcpSocket::connect IPv6 failed, %s (Result %d)\n", errorText, IpGetLastSocketError(gTcpSocketHandleGW));
            putValueToControl( kPanelName, "DoIPOutput", msg);
            sysSetVariableInt( sysvar::DoIP::DoIP_ConnectionServStatus, 0);
            sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing1, 0);
            clearBuff(msg, elCount(msg));
            snprintf(msg, elCount(msg), "None");
            sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToOne, msg);
         
          }
          
          write( "$$  <%BASE_FILE_NAME%> TCP Client 1: connecting to port: %d, from Socket: 0x%x", TcpServerPorts,gTcpSocketHandleGW );
          snprintf(msg, elcount(msg), "\n\nTCP Client 1: connecting to port: %d, from Socket: 0x%x\n", TcpServerPorts, gTcpSocketHandleGW);
          putValueToControl( kPanelName, "DoIPOutput", msg);
  }
     
}

on sysvar_update DoIP::ConnectSrv2
{
    char  msg[100];
    BYTE  remoteAddressIPv6[16];
    BYTE  localAddressIPv6[16];
    CHAR  errorText[200];
    LONG  result;

    long TcpServerPorts;
    long TcpClientPort = 13450 ;

    TcpServerPorts = 13400;
  
   if(@this)
  {
          TcpClose(gTcpSocketHandleGWSecond);
          gTcpSocketHandleGWSecond = 0;

          gTcpSocketHandleGWSecond = TcpOpen( localAddressIPv6, sysGetVariableInt( sysvar::DoIP::TCPSrcPort ));
          stDoIpHandle[1].socketHandle = gTcpSocketHandleGWSecond;
          stDoIpHandle[1].sourceAddr   = sysGetVariableInt(sysvar::DoIP::SrcAddr);
    
          if (IpGetLastSocketError(gTcpSocketHandleGWSecond) != 0)
          {
            IpGetLastSocketErrorAsString( gTcpSocketHandleGWSecond, errorText, elcount(errorText) );
            write( "$$  <%BASE_FILE_NAME%> TcpSocket::open IPv6 failed, %s (Result %d)", errorText, IpGetLastSocketError(gTcpSocketHandleGWSecond) );
            snprintf(msg, elcount(msg), "TcpSocket::open IPv6 failed, %s (Result %d)\n", errorText, IpGetLastSocketError(gTcpSocketHandleGWSecond));
            putValueToControl( kPanelName, "DoIPOutput", msg);
            sysSetVariableInt( sysvar::DoIP::DoIP_ConnectionServStatus2, 0);
            sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing2, 0);
            clearBuff(msg, elCount(msg));
            snprintf(msg, elCount(msg), "None");
            sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToSecond, msg);
           
          }
          
          ipGetAddressAsArray(ipv6KombiStr, remoteAddressIPv6);
          IpSetSocketOption(gTcpSocketHandleGWSecond, "IPPROTO_IPV6", "IPV6_TCLASS",0);
          IpSetSocketOption(gTcpSocketHandleGWSecond, "IPPROTO_IPV6", "IPV6_AUTOFLOWLABEL",0);          
	  
          result = TcpConnect( gTcpSocketHandleGWSecond, remoteAddressIPv6, TcpServerPorts );
          if (result != 0 && ipGetLastSocketError(gTcpSocketHandleGWSecond) != 10035 ) // WSAEWOULDBLOCK
          {
            IpGetLastSocketErrorAsString(gTcpSocketHandleGWSecond, errorText, elcount(errorText) );
            write( "$$  <%BASE_FILE_NAME%> TcpSocket::connect IPv6 failed, %s (Result %d)", errorText,IpGetLastSocketError(gTcpSocketHandleGWSecond) );
            snprintf(msg, elcount(msg), "TcpSocket::connect IPv6 failed, %s (Result %d)\n", errorText, IpGetLastSocketError(gTcpSocketHandleGWSecond));
            putValueToControl( kPanelName, "DoIPOutput", msg);
            sysSetVariableInt( sysvar::DoIP::DoIP_ConnectionServStatus2, 0);
            sysSetVariableInt( sysvar::DoIP::DoIP_Led_Routing2, 0);
            clearBuff(msg, elCount(msg));
            snprintf(msg, elCount(msg), "None");
            sysSetVariableString( sysvar::DoIP::DoIP_RegisteredToSecond, msg);
         
          }
          
          write( "$$  <%BASE_FILE_NAME%> TCP Client 2: connecting to port: %d, from Socket: 0x%x", TcpServerPorts,gTcpSocketHandleGWSecond  );
          snprintf(msg, elcount(msg), "\n\nTCP Client 2: connecting to port: %d, from Socket: 0x%x\n", TcpServerPorts, gTcpSocketHandleGWSecond);
          putValueToControl( kPanelName, "DoIPOutput", msg);
  }
     
}
on timer AutoAliveResponseTimer
{
  DoIP_SenCmd(0x0008, gTcpSocketHandleGW);
}

/// <DoIP>
void DoIP_MessageHeadBuilder(word wMsgID,dword dwLen)
{
  stDoIPHead.wPayloadType = wMsgID;
  stDoIPHead.dwpayloadLen = dwLen;
  
}


/// <DoIP>
dword DoIP_MessageUdpSend(word wLen)
{

  byte TempByte[1] ='\0';
  
  memcpy_h2n(gDoIPPayload,stDoIPHead);

  if(@DoIP::multicast)
    gResult = SendUdpMsg(gUdpSocketHandleGW,ipv6MulticastGrp,dwDstPort,gDoIPPayload,wLen);
  else
    gResult = SendUdpMsg(gUdpSocketHandleGW,ipv6Kombi,dwDstPort,gDoIPPayload,wLen);  
  
  sysSetVariableData( sysvar::DoIP::InputHext, gDoIPPayload, wLen ); //output sent hex 
  
  sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, 0 ); //clear hex output
    
  return gResult;
}

/// <DoIP>
dword DoIP_MessageTcpSend(word wLen, dword handle)
{
  byte TempByte[1] = '\0';
  
  memcpy_h2n(gDoIPPayload,stDoIPHead);
  
   gResult = TcpSendtoServer(gDoIPPayload,wLen, handle);
  
   sysSetVariableData( sysvar::DoIP::InputHext, gDoIPPayload, wLen ); //output sent hex 
  
   sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, 0 ); //clear hex output
  
   sysSetVariableData( sysvar::DoIP::OutputHexRxDiag, TempByte, 0 ); //clear hex output

  return gResult;
}

/// <Udp>
dword SendUdpMsg(dword &UdpSocketHandler,byte ipv6DstAddr[],dword ipv6DstPort,byte textData[], word wLen)
{
  
  if(wLen == 0)
    wLen = elcount(textData);
  
    gResult = UdpSendTo(UdpSocketHandler, ipv6DstAddr, ipv6DstPort, textData,wLen );
  
      // Check for error
    if ( (gResult != 0) && (IpGetLastSocketError(UdpSocketHandler) != 997) )
    {
      IpGetLastSocketErrorAsString(UdpSocketHandler, gErrorText, elcount(gErrorText) );
      write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(UdpSocketHandler) );
    }

    return gResult; 
 }


/// <Udp>
dword ReceiveUdpMsg(dword &UdpSocketHandler)
{
  
       // Optionally receive answer from UDP server
      UdpReceiveFrom(UdpSocketHandler, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(UdpSocketHandler) != 997 )
      {
        IpGetLastSocketErrorAsString(UdpSocketHandler, gErrorText, elcount(gErrorText));
        write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(UdpSocketHandler));
      }

  
 return  gResult;
}


/// <Udp>
void RecvMsghandler(char buffer[], dword size)
{
      byte TempByte[1460];
  
       memcpy(TempByte,buffer,size);
  
      putValueToControl( kPanelName, "DoIPOutput", "Received Udp response from Kombi. \r\n");


      sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, size );
  
}

/// <Udp>
void vConvertIPv6toArray(char acAddrStr[], byte abAddr[])
{
     int i; // loop variable 
  LONG gResult;
  //1nd IPv6 interface 
    write("Converting IPv6 Address %s to bytes...", acAddrStr);

    gResult = IpGetAddressAsArray( acAddrStr, abAddr );
    if (gResult == 0)
    {
      // success...
      write("IpGetAddressAsArray: returned array with IPv6 bytes:");
      for ( i=0; i<16; i++)
      {        
        write("Byte %.2d = 0x%.2x", i, abAddr[i]);
      }
    }
    else
    {
      write("Error converting");
    }       
}

void clearBuff(char Buffer[], dword size)
{
  dword count;
  for (count = 0; count < size; count++)
  {
    Buffer[count] = 0;
  }
}