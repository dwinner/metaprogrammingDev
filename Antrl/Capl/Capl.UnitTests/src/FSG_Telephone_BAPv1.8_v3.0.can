/*@!Encoding:1252*/
includes
{
    #include "..\..\_DLL\latest_BAP_DLL.cin"
}

variables
{
  //***********************************Config Files****************************
  char dbc_path[255]  = "BAP\\_DBC\\BAP_V9.04F.dbc";
  char xml_path[255]  = "BAP\\TEL_DF50_man_FSG40\\XML\\BAP_SW18_MIB3_OI_MQB37W_CP_V1_10_F_mod.xml";
  char dbce_path[255] = "BAP\\TEL_DF50_man_FSG40\\DBs\\MQB_V7.19F_AR421_20170529_Kombi_MQB_OCU_Sound_MIB_ab_Gen3_TVTuner_MQB_ZR_MIB_OPTION_ab_Gen3_FD.arxml";
  char xmle_path[255] = "BAP\\TEL_DF50_man_FSG40\\XML\\BAP_SW18_TEL_P30DF50_v3.01_ETH_FSG.xml";

  //*************************General Variables*************************************
  //Basic
  const FALSE=0;
  const TRUE=1;
  const FORWARD=0;
  const BACKWARD=1;
  byte gKl15=0;
  byte gKlS=0;
  char gstring_reserved[10] = "reserved";
  char gempty_string [3]   ={0,0,0};
  char empty_string[3] = {0,0,0};
  dword gLastAcknowlegdeData[3] = {0, 0, 0};
  //Debug
  const DEBUG_ID = 0x444;
  const DEBUG_CAN_CHANNEL = 2;
  const DEBUG_SWITCH_ON = 1;
  const DEBUG_SWITCH_OFF = 0;
  int gdebug=0;//bap150 - debug
  //Panel control
  dword gRGB_red;
  dword gRGB_yellow;
  dword gRGB_green;
  dword gRGB_grey;
  dword gRGB_white;
  //time, date
  mstimer agetimer;
  char gtime [7];
  char gdate [7];
  char gsday[3], gsmonth[3], gsyear[3], gshour[3], gsmin[3], gssec[3];
  byte gbday, gbmonth, gbyear, gbhour, gbmin, gbsec;
  //BAP data types
  const Bap_Void          = 0;
  const Bap_UInt8         = 1;
  const Bap_UInt16        = 2;
  const Bap_UInt32        = 3;
  const Bap_ByteSequence  = 4;
  const Bap_Error         = 5;
  const Bap_Acknowledge   = 6;
  //BAP request types
  const DataSetGet_REQ  = 0x00;
  const DataSet_REQ     = 0x01;
  const DataGet_REQ     = 0x02;
  const Data_REQ        = 0x03;
  const Changed_REQ     = 0x04;
  const Start_REQ       = 0x05;
  const StartResult_REQ = 0x06;
  const Abort_REQ       = 0x07;
  const Processing_REQ  = 0x08;
  const Result_REQ      = 0x09;
  const Invalid_REQ     = 0x1F;
  //eigene Error-Definition
  const Error_REQ=0x55;
  //BAP indication types // NEU NUMMERIERT für BAP150!!
  const Data_IND        = 0x00;
  const Reset_IND       = 0x01;
  const DataAck_IND     = 0x02;
  const Result_IND      = 0x03;
  const Processing_IND  = 0x04;
  const Changed_IND     = 0x05;
  const DataSetGet_IND  = 0x06;
  const DataSet_IND     = 0x07;
  const DataGet_IND     = 0x08;
  const Ack_IND         = 0x09;
  const Processing_CNF  = 0x0a;
  const Start_IND       = 0x0b;
  const StartResult_IND = 0x0c;
  const Abort_IND       = 0x0d;
  const Invalid_IND     = 0x1F;      // Interne Kennzeichnung fuer eine ungueltige Indication
  //Method_Result values
  const SUCCESSFUL            =0x00;
  const NOT_SUCCESSFUL        =0x01;
  const ABORT_SUCCESSFUL      =0x02;
  const ABORT_NOT_SUCCESSFUL  =0x03;
  //eigene Error-Definition
  const Error_IND   = 0x55;
  const BAP_ERR_OK  = 0x00;
  char gerror_codes_BCL [16][30] = {  0,
                                      "Media not accesible",
                                      "illegal sequence",
                                      "Sequenzfehler Segmentierung",
                                      "Timeout Segmentierung",
                                      "BCL not running",
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0};
  char gerror_codes_BPL [16][30] = {  0,
                                      "Heartbeat Timeout",
                                      "Retry Timeout",
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0};
  char gerror_codes_BAL [16][40] = {  0,
                                      "Falsche Adressierung",
                                      "Inkompatible Protokollversion",
                                      "Inkompatible Version Datenfestlegung",
                                      "Daten ungültig",
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      0};
  const Terror_unknownapllicationerror                    = 0x80;
  const Terror_notsuccessful                              = 0x81;
  const Terror_outofmemory                                = 0x82;
  const Terror_datainvalid                                = 0x83;
  const Terror_nouseractive                               = 0x88;
  const Terror_nonetwork                                  = 0x89;
  const Terror_notsupportedbynetwork                      = 0x8A;
  const Terror_notregisteredemergencycallonly             = 0x8B;
  const Terror_currentcodeinvalid                         = 0x8C;
  const Terror_newcodeinvalid                             = 0x8D;
  const Terror_nocoderequired                             = 0x8E;
  const Terror_noredialnumber                             = 0x8F;
  const Terror_activecallpresentdialing                   = 0x90;
  const Terror_heldcallpresent                            = 0x91;
  const Terror_activeandheldcallpresent                   = 0x92;
  const Terror_nocall                                     = 0x93;
  const Terror_nocallrelatedtoCallID                      = 0x94;
  const Terror_noactivecall                               = 0x95;
  const Terror_nocallonhold                               = 0x96;
  const Terror_noincomingwaitingcall                      = 0x97;
  const Terror_noconference                               = 0x9A;
  const Terror_nomemberofconference                       = 0x9B;
  const Terror_maximumnumberformembersofconferencereached = 0x9C;
  const Terror_functionnotsupportedforconferencecalls     = 0x9D;
  const Terror_phonebookdownloadinprogress                = 0x9E;
  const Terror_notsupportedbymobilephone                  = 0xA0;
  const Terror_noheadsetconnected                         = 0xA1;
  const Terror_nopairedheadset                            = 0xA2;
  char gerror_codes_telephone[35][50] = { "unknown apllication error",
                                          "not successful",
                                          "out of memory",
                                          "data invalid",
                                          0,
                                          0,
                                          0,
                                          0,
                                          "no user active",
                                          "no network",
                                          "not supported by network",
                                          "not registered / emergency call only",
                                          "current code invalid",
                                          "new code invalid",
                                          "no code required",
                                          "no redialnumber",
                                          "active call present / dialing",
                                          "held call present",
                                          "active and held call present",
                                          "no call",
                                          "no call related to CallID",
                                          "no active call",
                                          "no call on hold",
                                          "no incoming / waiting call",
                                          0,
                                          0,
                                          "no conference",
                                          "no member of conference",
                                          "maximum number for members of conference reached",
                                          "function not supported for conference calls",
                                          "phonebook download in progress",
                                          0,
                                          "not supported by mobile phone",
                                          "no headset connected",
                                          "no paired headset"};

  //*************************BAP node*************************************
  //LSG-ID
  const LSG_TELEPHONE   = 0x28;
  const LSGID_Telephone = 0x28;
  //Fct-IDs
  const FctID_GetAll                                = 0x01;
  const FctID_BAP_Config                            = 0x02;
  const FctID_FunctionList                          = 0x03;
  const FctID_HeartBeat                             = 0x04;
  const FctID_FSG_Control                           = 0x0D;
  const FctID_FSG_Setup                             = 0x0E;
  const FctID_FSG_OperationState                    = 0x0F;
  const FctID_MobileServiceSupport                  = 0x10;
  const FctID_DeviceConnectionState                 = 0x11;
  const FctID_NetworkState                          = 0x12;
  const FctID_NetworkProvider                       = 0x13;
  const FctID_ActiveUser                            = 0x14;
  const FctID_MobileBatteryLevel                    = 0x15;
  const FctID_CallState                             = 0x16;
  const FctID_CallInfo                              = 0x17;
  const FctID_CallDuration                          = 0x18;
  const FctID_AudioMuteOnOff                        = 0x19;
  const FctID_MissedCallIndication                  = 0x1A;
  const FctID_AutomaticRedial                       = 0x1B;
  const FctID_DialNumber                            = 0x1C;
  const FctID_ConfirmEmergencyCall                  = 0x1D;
  const FctID_BasicCallHandling                     = 0x1E;
  const FctID_MPCall_CC_Handling                    = 0x1F;
  const FctID_CombinedNumbers                       = 0x20;
  const FctID_Picture                               = 0x21;
  //TaskTimer
  mstimer TaskTimer;          //real communication timer
  //Node Index
  dword NODE_INDEX=0;
  //Power on/off
  byte gFSG_Telephone_PowerOnOff=0;
  byte gBAP_Init=0;
  byte gFSG_Schalter_OnOff = 0;
  char gFSG_Schalter_OnOff_string[2][30]={"FSG Power off",
                                          "FSG Power on"};
  mstimer Powerontimer;
  const Power_off = 0x00;
  const Power_on  = 0x01;
  char gstring_FSG_Telephone_PowerOnOff [2][4]={"Off",
                                                "On"};
  const OFF=0;
  const _ON=1;
  //values for reading *.csv-file
  const TEL_DEFAULT_LIST  =0;
  const TEL_EXTERNAL_LIST =1;
  const TEL_FILENAME_SIZE =50;
  const TEL_BUFFERSIZE    =0xFFFF;
  const TEL_TEXTLENGTH    =100;

  //***********************************BAP buffer****************************
  const Requestbuffer_lines=100;
  const BAP_buffer_size=4100;
  int gBAP_Requestbufffer_status [Requestbuffer_lines];       //datalength
  int gBAP_Requestbufffer_BAPDataTyp [Requestbuffer_lines];   //data type
  dword gBAP_Indication[BAP_buffer_size];                     //Bap-Indication-buffer
  dword gBAP_Request [Requestbuffer_lines] [BAP_buffer_size]; //ringbuffer for BAP-Request
  int gwrite_requestbuffer_line=0;                            //next free position
  int gstatus_requestbuffer=0;                                //next position to send

  //***********************************Output windows****************************
  dword gCombinedNumbers_writeWindow;
  dword gPicture_writeWindow;
  dword gBAP_Trace, gError_Trace;


  //*************************************************************************
  //*****************Fct-IDs*************************************************
  //*************************************************************************

  //*****************FunctionList********************************************
  byte gFunctionListModified=0;
  byte gFunctionList0 = 0;
  byte gFunctionList1 = 0;
  byte gFunctionList2 = 0;
  byte gFunctionList3 = 0;
  byte gFunctionList4 = 0;
  byte gFunctionList5 = 0;
  byte gFunctionList6 = 0;
  byte gFunctionList7 = 0;
  char gstring_FunctionListModified [2][30]={ "generated by XML-File",
                                              "manually configured"};
  //*************************************************************************
  //*****************FSG_Control*********************************************
  byte gFsgControl_Extension1=0;
  byte gFsgControl_Extension2=0;
  byte gFsgControl_Extension3=0;
  byte gFsgControl_Extension4=0;
  byte gFsgControl_Extension5=0;
  byte gFsgControl_Extension6=0;
  //*************************************************************************
  //**************FSG_Setup**************************************************
  byte gPrivacyMode=0;
  byte gPrivacyModeBit=0;
  byte gFsgSetup_FunctionProtection=0;
  byte gFsgSetup_FunctionProtectionBit=0;
  byte gFsgSetup_WebAppState=0;
  byte gFsgSetup_WebAppStateBit=0;
  byte gFsgSetup_Extension1=0;
  byte gFsgSetup_Extension2=0;
  byte gFsgSetup_Extension3=0;
  byte gFsgSetup_Extension4=0;
  //*************************************************************************
  //**************FSG_OperationState*****************************************
  byte gOP_State=0;
  byte gFsgOperationState_Extension1=0;
  byte gFsgOperationState_Extension2=0;
  byte gFsgOperationState_Extension3=0;
  byte gFsgOperationState_Extension4=0;
  byte gFsgOperationState_Extension5=0;
  //*************************************************************************
  //*****************MobilServiceSupport*************************************
  byte gMobilServiceSupport0 = 0;
  byte gMobilServiceSupport1 = 0;
  byte gMobilServiceSupport2 = 0;
  byte gMobilServiceSupport3 = 0;
  byte gMobilServiceSupport4 = 0;
  byte gMobilServiceSupport5 = 0;
  byte gMobilServiceSupport6 = 0;
  byte gMobilServiceSupport7 = 0;
  //*************************************************************************
  //*****************DeviceConnectionState***********************************
  byte gPhoneCharacteristics=0;
    byte gSIMCardReader=0;
    byte gCableConnection=0;
    byte gHFPConnection=0;
    byte gRSAPConnection=0;
    byte gAppleCarPlay=0;
    byte gAndroidAuto=0;
    byte gBaiduCarLife=0;
  byte gMobileConnectionType=0;
    const NO_CONNECTION             = 0x00;
    const INTERNAL_SIM_CARD_READER  = 0x01;
    const CABLE_CONNECTION          = 0x02;
    const HANDS_FREE_PROFILE        = 0x03;
    const REMOTE_SIM_ACCESS_PROFILE = 0x04;
    const APPLE_CARPLAY             = 0x05;
    const ANDROID_AUTO              = 0x06;
    const BAIDU_CARLIFE             = 0x07;
  byte gMobileConnectionTypeAttributes=0;
    byte gBluetooth=0;
    byte gUSB=0;
    byte gWLAN=0;
  byte gTel_State=0;
    const PhoneInitilisation  = 0x00;
    const PhoneModuleOff      = 0x05;
    const PhoneModuleOn       = 0x07;
    const MobileOn            = 0x0F;
  byte gLockState=0;
  byte gPIN_attempts=3;
    const nolock                =0x00;
    const requirePIN            =0x01;
    const requirePIN2           =0x02;
    const PINblockedrequirePUK  =0x03;
    const PIN2blockedrequirePUK2=0x04;
    const PUKblocked            =0x05;
    const PUK2blocked           =0x06;
    const SIMnotavailable       =0x07;
    const PINinvalid            =0x08;
    const PIN2invalid           =0x09;
    const SIMnotfunctional      =0x0A;
    const SIMnotready           =0x0B;
    const requiresecuritycode   =0x0C;
    const securitycodeblocked   =0x0D;
    char gstring_LockState [14] [30] = {"no lock",
                                        "require PIN",
                                        "require PIN2",
                                        "PIN blocked, require PUK",
                                        "PIN2 blocked, require PUK2",
                                        "PUK blocked",
                                        "PUK2 blocked",
                                        "SIM not available",
                                        "PIN invalid",
                                        "PIN2 invalid",
                                        "SIM not functional",
                                        "SIM not ready",
                                        "require security code",
                                        "security code blocked"};
  byte gDeviceConnectionState_Extension1=0;
  byte gDeviceConnectionState_Extension2=0;
  byte gDeviceConnectionState_Extension3=0;
  byte gDeviceConnectionState_Extension4=0;
  byte gDeviceConnectionState_Extension5=0;
  byte gDeviceConnectionState_Extension6=0;
  //*************************************************************************
  //************NetworkState*************************************************
  mstimer registerstatetimer;
  int gtime_registerstatetimer=2000;
  byte gRegisterState=0;
    const notregisteredandnotsearching=0x00;
    const registered=0x01;
    const notregisterdandsearching=0x02;
    const registrationdenied=0x03;
    const registeredandroaming=0x04;
    const registeredandroamingalternative=0x05;
    const emergencycallsonly=0x06;
    const functionnotsupportedbyme=0xFF;
  byte gNetworkType=0;
    const UNKNOWN_NT = 0x00;
    const GSM        = 0x01;
    const UMTS       = 0x02;
    const CDMA       = 0x03;
    const LTE        = 0x04;
    const HSPAplus   = 0x05;
    const LTE_adv    = 0x06;
  byte gPacketDataNetworkType=0;
    const NO_DATA_SERVICE   = 0x00;
    const GSM_GPRS          = 0x01;
    const GSM_EDGE          = 0x02;
    const HSDPA             = 0x03;
    const HSUPA             = 0x04;
    const CDMA_DataNetwork  = 0x05;
    const LTE_DataNetwork   = 0x06;
    const HSPAplus_DN       = 0x07;
    const LTE_adv_DN        = 0x08;
    const UNKNOWN_PACKET_DN = 0xFF;
  timer signalqualitytimer;
  byte gSignalQuality=0;
  byte gNetworkState_Extension1=0;
  byte gNetworkState_Extension2=0;
  //*************************************************************************
  //************NetworkProvider**********************************************
  mstimer nonetworktimer;
  char gstring_networkprovider [5] [20] ={{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
                      "D1",
                      "D2",
                      "E-Plus",
                      "O2"};
  char gNetworkProvider [20];
  byte gNetworkProviderState=0;
  char gNetworkProviderName [40];
  byte gNetworkProvider_Extension=0;
  //*************************************************************************
  //***************************ActiveUser************************************
  char gUserName [50];
  //*************************************************************************
  //*************MobileBatteryLevel******************************************
  timer MobileBatteryLevelTimer;
  byte gChargeLevel=0;
  byte gWarningLevel=0;
  byte gWarningLevelBit0=0;
  const LOW_CHARGE_LEVEL=10;
  byte gMobileBatteryLevel_Extension1=0;
  byte gMobileBatteryLevel_Extension2=0;
  byte gMobileBatteryLevel_Extension3=0;
  byte gMobileBatteryLevel_Extension4=0;
  byte gMobileBatteryLevel_Extension5=0;
  //*************************************************************************
  //*******CallState*********************************************************
  byte gCallState [7]     ={0,0,0,0,0,0,0};
    const idle            =0x00;
    const ringing_waiting =0x01;
    const active          =0x02;
    const dialing         =0x03;
    const disconnecting   =0x04;
    const onhold          =0x05;
    const REMOTE_SIDE_BUSY=0x06;
    const INCOMING_ON_HOLD=0x07;
    char gstring_callstate [8] [24] = { "idle",
                                        "ringing waiting",
                                        "active",
                                        "dialing",
                                        "disconnecting",
                                        "onhold",
                                        "remote side busy",
                                        "incoming on hold"};
  byte gCallType [7]      ={0,0,0,0,0,0,0};
    const unknowncalltype       =0x00;
    const SINGLE_VOICE_CALL     =0x01;
    const datacall              =0x02;
    const faxcall               =0x03;
    const emergencycall         =0x04;
    const CONFERENCE_VOICE_CALL =0x05;
    const infocall              =0x06;
    const servicecall           =0x07;
    const ACNecall              =0x08;
    char gstring_calltype [9] [22] = {"unknown call type",
                                      "single voice call",
                                      "data call",
                                      "fax call",
                                      "emergency call",
                                      "conference voice call",
                                      "info call",
                                      "service call",
                                      "ACN (emergency call)"};
  byte gCallOptions1 [7]  ={0,0,0,0,0,0,0};
    const byte ACCEPT_CALL   = 0x01;  //Bit 0
    const byte HANGUP_CALL   = 0x02;  //Bit 1
    const byte CALL_HOLD     = 0x04;  //Bit 2
    const byte RESUME_CALL   = 0x08;  //Bit 3
    const byte MP_SWAP       = 0x10;  //Bit 4
    const byte MP_RACAWC     = 0x20;  //Bit 5
    const byte MP_SWCOH      = 0x40;  //Bit 6
    const byte MP_RALLCAWC   = 0x80;  //Bit 7
  byte gCallOptions2 [7]  ={0,0,0,0,0,0,0};
    const byte MP_CHAWC      = 0x01;  //Bit 0
    const byte CC_JOIN       = 0x02;  //Bit 1
    const byte CONFIRM_ECALL = 0x04;  //Bit 2
  byte gCallOutgoingDiverted_eCallConfirmationPending [8] ={0,0,0,0,0,0,0,0};
    char gstring_CallDivert [2] [10] = {"Off",
                                        "On"};
  byte gDisconnectReason=0;
    const regulardisconnecting=0x00;
    const noline=0x01;
    const connectedline_busy=0x02;
    const systembusy=0x03;
    const linebusy=0x04;
    const numbernotassigned=0x05;
    const numbernotrechable=0x06;
    const networkfailure=0x07;
    const callbarringactive=0x08;
    const usernotresponding=0x09;
    const callreject=0x0a;
    const numberchanged=0x0b;
    const numberinvalidincomplete=0x0c;
    const servicenotavaillable=0x0d;
    const noinfoavailable=0x0e;
    const temporaryblocked=0x0f;
    const callfailed=0x10;
  byte gCallState_Extension1=0;
  byte gCallState_Extension2=0;
  byte gCallActivity=0;
    const NOCALL=0x00;
    const SINGLECALL=0x01;
    const MULTIPARTYCALL=0x02;
    char gstring_callactivity [3] [20] = {"no call",
                                          "single call",
                                          "multiparty call"};
  //*************************************************************************
  //*******************CallInfo**********************************************
  byte gstatus_dialnumber_changearraytimer=0;
  mstimer checknetworktimer;
  const CALLINFO=7;
  const CALL_INFO_NAME_LENGTH=99;
  const CALL_INFO_NUMBER_LENGTH=40;
  char gCallInfo_PbName [CALLINFO] [CALL_INFO_NAME_LENGTH];
  byte gCallInfo_PbName_hex[CALLINFO][CALL_INFO_NAME_LENGTH];
  char gCallInfo_TelNumber [CALLINFO] [CALL_INFO_NUMBER_LENGTH];
  byte gCallInfo_Category [CALLINFO];
    const UNKNOWN=0x00;
    const general=0x01;
    const MOBILE=0x02;
    const office=0x03;
    const chome=0x04;
    const FAX=0x05;
    const CAR=0x06;
    const SIM=0x07;
    const MAIN_OFFICE=0x08;
    const MAIN_HOME=0x09;
    const CELL_OFFICE=0x0A;
    const CELL_HOME=0x0B;
    const FAX_OFFICE=0x0C;
    const FAX_HOME=0x0D;
    char gnumbertype [14][15]= {"unknown",
                                "General",
                                "Mobile",
                                "Office",
                                "Home",
                                "Fax",
                                "Car",
                                "SIM",
                                "Main office",
                                "Main home",
                                "Cell office",
                                "Cell home",
                                "Fax office",
                                "Fax home"};
  //*************************************************************************
  //**************CallDuration***********************************************
  byte gCallDuration_Relation1[8] ={0,0,0,0,0,0,0,0};
  word gCallDuration_1=0;
  byte gCallDuration_Relation2[8] ={0,0,0,0,0,0,0,0};
  word gCallDuration_2=0;
  //*************************************************************************
  //*********AudioMuteOnOff**************************************************
  byte gAudioControl=0;
    byte gHandsFreeOnOff    =0;
    byte gheadset_available =0;
    byte gMicroMuteOnOff    =0;
    byte gRingToneMuteOnOff =0;
    byte gRingTone_unmute   =0;
    byte gRingTone_incoming_callid=0xff;
  byte gFunctionSupport       =0;
    byte gHandsFreeSupport    =0;
    byte gMicroMuteSupport    =0;
    byte gRingToneMuteSupport =0;
  byte gAudioMuteOnOff_Reserve1   =0;
  byte gAudioMuteOnOff_Extension1 =0;
  byte gAudioMuteOnOff_Extension2 =0;
  byte gAudioMuteOnOff_Extension3 =0;
  byte gAudioMuteOnOff_Extension4 =0;
  //*************************************************************************
  //**************MissedCallIndication***************************************
  word gMissedCalls=0;
  byte gMissedCallIndication_Extension1 =0;
  byte gMissedCallIndication_Extension2 =0;
  byte gMissedCallIndication_Extension3 =0;
  byte gMissedCallIndication_Extension4 =0;
  //*************************************************************************
  //*************AutomaticRedial********************************************
  byte gAutomaticRedialState = 0;
    char gAutomaticRedialState_s[2][30] = {"not active",
                                           "active"};
  byte gAutomaticRedial_Extension1=0;
  byte gAutomaticRedial_Extension2=0;
  byte gAutomaticRedial_Extension3=0;
  byte gAutomaticRedial_Extension4=0;
  byte gAutomaticRedial_Extension5=0;
  //************************************************************************
  //**************dialnumber************************************************
  byte gDialNumber_AsgId    =0;
  byte gDialNumber_Extension=0;
  const DIAL_NUMBER_NAME_LENGTH=150;  //correct value: 150;
  char gDialNumber [CALL_INFO_NUMBER_LENGTH];      //number
  char gDialNumber_name [DIAL_NUMBER_NAME_LENGTH]; //PbName of dialed Number
  byte gDialNumber_Result=0;
    const NS_NUMBER_INVALID           =0x04;
    const NS_AUTOMATIC_REDIAL_ACTIVE  =0x05;
    const NS_CONFIRM_ECALL            =0x06;
    const NS_DATA_INVALID             =0x20;
    const NS_NO_NETWORK               =0x21;
    const NS_NOTREGISTERED_ECALLONLY  =0x22;
    const NS_NOREDIALNUMBER           =0x23;
    const NS_ACTIVECALLPRESENT_DIALING=0x24;
  byte gDialService_type = 0xff; // the type of call: 0x00: voice mailbox, 0x01: info call, 0x02: service call, 0x03: emergency call
  int gDialService_enabled = 1; // method dial service enabled
  int gDialService_status = 0; // method dial service running
  char police [4] = "110";
  char ambulance [4] = "112";
  char emergency_NAR [4] = "911";
  char cerveza [3] = "08";
  char info [6] = "01802";
  char service [6] = "01902";
  char info_pbname [CALL_INFO_NAME_LENGTH] = "Volkswagen Information Center";
  char service_pbname [CALL_INFO_NAME_LENGTH] = "Volkswagen Service Center";
  byte gcallID=0xff;         //Call-ID of this call, which is currently active/dialing, 0xff=no call is active
  byte gemergencycall=0;     //flag for emergency call (0-no emergency call, 1-emergency call & registered, 2-emergency call & not registered, but SIM OK, 3-emergency call & not registered & no SIM)
  byte gDialNumber_status=0; //flag for status of the method dial number (0=no aktiv, 1=aktiv)
  const gtime_checknetworktimer=500;
  const free=0;
  const busy=1;
  byte gConfirmCall = 0; // indicate if call has to be confirmed
  byte gCallStartedFromASG = 0;
  //*************************************************************************
  //************************ConfirmEmergencyCall*****************************
  byte gConfirmEmergencyCall_AsgId    =0;
  byte gConfirmEmergencyCall_Extension=0;
  byte gConfirmEmergencyCall_result  =0;
    const NS_NO_ECALL_PENDING =0x04;
  byte gConfirmEmergencyCall_Control  =0;
  const ECALL_CONTROL_CONFIRM =0x00;
  const ECALL_CONTROL_CANCEL  =0x01;
  //*************************************************************************
  //**************BasicCallHandling******************************************
  byte gBasicCallHandling_AsgId       =0;
  byte gBasicCallHandling_Extension1  =0;
  byte gBasicCallHandling_Extension2  =0;
  byte gBasicCallHandling_CallFunction=0;
    const CALLFUNCTION_ACCEPTCALL =0x00;
    const CALLFUNCTION_HANGUPCALL =0x01;
    const CALLFUNCTION_CALLHOLD   =0x02;
    const CALLFUNCTION_RESUMECALL =0x03;
  byte gBasicCallHandling_CallId=0;
    const CALLID_0 =0x00;
    const CALLID_1 =0x01;
    const CALLID_2 =0x02;
    const CALLID_3 =0x03;
    const CALLID_4 =0x04;
    const CALLID_5 =0x05;
    const CALLID_6 =0x06;
    const CALLID_ALLACTIVECALLS     =0x0C;
    const CALLID_ALLHELDCALLS       =0x0D;
    const CALLID_ALLACTIVEHELDCALLS =0x0E;
    const CALLID_ALLCALLS           =0x0F;
  byte gBasicCallHandling_Result=0;
    const NOT_SUCCESSFUL_NOT_SUPPORTED_BY_NETWORK =0x04;
    const NOT_SUCCESSFUL_ACTIVECALLPRESENT_DIALING=0x24;
    const NOT_SUCCESSFUL_HELDCALLPRESENT          =0x25;
    const NOT_SUCCESSFUL_NOCALLRELATEDTOCALLID    =0x27;
    const NOT_SUCCESSFUL_NOACTIVECALL             =0x28;
    const NOT_SUCCESSFUL_NOCALLONHOLD             =0x29;
    const NOT_SUCCESSFUL_NOINCOMING_WAITINGCALL   =0x2A;
  byte gacceptcall_status=0; //flag for status of the method accept call (0=not activ, 1=activ)
  mstimer acceptcallTimer;
  const acceptcallTimerTime=500;
  byte gCallHold_status=0; //flag for status of the method CallHold (0=not activ, 1=activ)
  mstimer CallHoldTimer;
  const CallHoldTimerTime=500;
  byte ghangupcall_status=0; //flag for status of the method hangup call (0=not activ, 1=activ)
  mstimer disconnectingtimer;
  mstimer disconnectingtimer2;
  const disconnecttime=2000;
  byte gResumeCall_status=0; //flag for status of the method ResumeCAll (0=not activ, 1=activ)
  mstimer ResumeCallTimer;
  const ResumeCallTimerTime=500;
  //*************************************************************************
  //**************MPCall_CC_Handling*****************************************
  byte gMPCall_CC_Handling_AsgId       =0;
  byte gMPCall_CC_Handling_Extension1  =0;
  byte gMPCall_CC_Handling_Extension2  =0;
  byte gMPCall_CC_Handling_CallFunction=0;
    const CALLFUNCTION_MPRACAWC   =0x00;
    const CALLFUNCTION_MPSWAP     =0x01;
    const CALLFUNCTION_MPCHAWC    =0x02;
    const CALLFUNCTION_MPRALLCAWC =0x03;
    const CALLFUNCTION_MPSWCOH    =0x04;
    const CALLFUNCTION_CCJOIN     =0x05;
  byte gMPCall_CC_Handling_Result=0;
    const NOT_SUCCESSFUL_ADDITIONAL_CALL_ALREADY_PRESENT      =0x05;
    const NOT_SUCCESSFUL_NOCALL                               =0x26;
    const NOT_SUCCESSFUL_NOCONFERENCE                         =0x2B;
    const NOT_SUCCESSFUL_NOMEMBEROFCONFERENCE                 =0x2C;
    const NOT_SUCCESSFUL_MAXNUMBERFORCONFERENCEMEMBERSREACHED =0x2D;
    const NOT_SUCCESSFUL_NOTSUPPORTEDBYMOBILEPHONE_HFP        =0x2E;
  byte gMPSwap_status=0; //flag for status of the method MPSwap (0=not activ, 1=activ)
  mstimer MPSwapTimer;
  const MPSwapTimerTime=500;
  byte gCCJoin_status=0; //flag for status of the method CCJoin (0=not activ, 1=activ)
  mstimer CCJoinTimer;
  const CCJoinTimerTime=500;
  byte gMPRACAWC_status=0; //flag for status of the method CCSplit (0=not activ, 1=activ)
  mstimer MPRACAWCTimer;
  const MPRACAWCTimerTime=750;
  byte gMPRAllCAWC_status=0; //flag for status of the method CCSplit (0=not activ, 1=activ)
  mstimer MPRAllCAWCTimer;
  const MPRAllCAWCTimerTime=750;
  byte gMPCHAWC_status=0; //flag for status of the method CCSplit (0=not activ, 1=activ)
  mstimer MPCHAWCTimer;
  const MPCHAWCTimerTime=750;
  byte gMPSWCOH_status=0; //flag for status of the method CCSplit (0=not activ, 1=activ)
  mstimer MPSWCOHTimer;
  const MPSWCOHTimerTime=750;
  //*************************************************************************
  //**************CombinedNumbers********************************************
  byte gCombinedNumbers_ASGID = 0;
  byte gCombinedNumbers_TAID  = 0;
  byte gCombinedNumbers_Extension = 0;
  word gCombinedNumbers_TotalNumListElements = 0;
  const TEL_COMBINEDNUMBERS_ENTRIES = 0xFF;
  word gCombinedNumbers_Pos [TEL_COMBINEDNUMBERS_ENTRIES];
  const TEL_COMBINEDNUMBERS_PBNAME_LENGTH = 100;
  char gCombinedNumbers_PbName [TEL_COMBINEDNUMBERS_ENTRIES][TEL_COMBINEDNUMBERS_PBNAME_LENGTH];
  byte gCombinedNumbers_NumberType[TEL_COMBINEDNUMBERS_ENTRIES];
    char gCombinedNumbers_NumberType_s[16][30] ={ "unknown NumberType",
                                                  "General",
                                                  "Mobile",
                                                  "Office",
                                                  "Home",
                                                  "Fax",
                                                  "Pager",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "Cell office",
                                                  "Cell home",
                                                  "Fax office",
                                                  "Fax home",
                                                  "reserved"};
  byte gCombinedNumbers_CallMode [TEL_COMBINEDNUMBERS_ENTRIES];
    const TEL_COMBINEDNUMBERS_UNKNOWNCALL   = 0x00;
    const TEL_COMBINEDNUMBERS_MISSEDCALL    = 0x01;
    const TEL_COMBINEDNUMBERS_RECEIVEDCALL  = 0x02;
    const TEL_COMBINEDNUMBERS_DIALEDNUMBER  = 0x03;
    char gCombinedNumbers_CallMode_s[4][50] = { "unknown call mode",
                                                "missed call",
                                                "received call",
                                                "dialed number"};
  const TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH = 41;
  char gCombinedNumbers_TelNumber [TEL_COMBINEDNUMBERS_ENTRIES][TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH];
  byte gCombinedNumbers_day [TEL_COMBINEDNUMBERS_ENTRIES];
  byte gCombinedNumbers_month [TEL_COMBINEDNUMBERS_ENTRIES];
  byte gCombinedNumbers_year [TEL_COMBINEDNUMBERS_ENTRIES];
  byte gCombinedNumbers_hour [TEL_COMBINEDNUMBERS_ENTRIES];
  byte gCombinedNumbers_minute [TEL_COMBINEDNUMBERS_ENTRIES];
  byte gCombinedNumbers_second [TEL_COMBINEDNUMBERS_ENTRIES];
  word gCombinedNumbers_Picture_Reference [TEL_COMBINEDNUMBERS_ENTRIES];
  byte gCombinedNumbers_ListEntryValidInformation [TEL_COMBINEDNUMBERS_ENTRIES]; //indicates the existence of the "record element"
  byte gCombinedNumbers_sum =0;
  char gCombinedNumbers_CSV_filename[TEL_FILENAME_SIZE];
  //*************************************************************************
  //**************Picture****************************************************
  byte gPicture_ASGID = 0;
  byte gPicture_TAID  = 0;
  word gPicture_TotalNumListElements = 0;
  const TEL_PICTURE_ENTRIES = 0xFF;
  word gPicture_Pos [TEL_PICTURE_ENTRIES];
  byte gPicture_CallId[TEL_PICTURE_ENTRIES];
    const TEL_PICTURE_CALL0           = 0x00;
    const TEL_PICTURE_CALL1           = 0x01;
    const TEL_PICTURE_CALL2           = 0x02;
    const TEL_PICTURE_CALL3           = 0x03;
    const TEL_PICTURE_CALL4           = 0x04;
    const TEL_PICTURE_CALL5           = 0x05;
    const TEL_PICTURE_CALL6           = 0x06;
    const TEL_PICTURE_UNKNOWN_CALLID  = 0xFF;
  byte gPicture_Type[TEL_PICTURE_ENTRIES];
    const TEL_PICTURE_NOPICTURE       = 0x00;
    const TEL_PICTURE_CONTACT         = 0x01;
    const TEL_PICTURE_INFO            = 0x02;
    const TEL_PICTURE_SERVICE         = 0x03;
    const TEL_PICTURE_EMERGENCY       = 0x04;
    const TEL_PICTURE_CONFERENCE      = 0x05;
    const TEL_PICTURE_DEFAULT         = 0x06;
    const TEL_PICTURE_UNKNOWN_PICTURE = 0xFF;
  const TEL_PICTURE_IPADDRESS_LENGTH = 17;
  char gPicture_IpAddress [TEL_PICTURE_ENTRIES][TEL_PICTURE_IPADDRESS_LENGTH];
  word gPicture_TcpPort [TEL_PICTURE_ENTRIES];
  const TEL_PICTURE_URI_LENGTH = 602;
  char gPicture_URI [TEL_PICTURE_ENTRIES][TEL_PICTURE_URI_LENGTH];
  byte gPicture_ListEntryValidInformation [TEL_PICTURE_ENTRIES]; //indicates the existence of the "record element"
  byte gPicture_sum =0;
  char gPicture_CSV_filename[TEL_FILENAME_SIZE];
  //*************************************************************************

// FLEXRAY NOT ENABLED!

  // ETHERNET VARIABLES
  struct UdpSocket{
    dword Handle;
    dword Id;
  };
  struct UdpSocket gUdpSockets[5];
  dword gUdpSocketCnt;
  int canethdeciderValue = -1;
  // END OF ETHERNET VARIABLES
}

//*************************************************************************
//*****************PreStart************************************************
//*************************************************************************
on preStart
{
  char Path[255];
  char BAPVersion [100];

  // create write window for BAP communication
  gBAP_Trace  =writecreate("BAP-Trace FSG-Telephone");
  writeclear(gBAP_Trace);
  // error window for BAP communication
  gError_Trace=writecreate("FSG-TelephoneSD Error");
  writeclear(gError_Trace);
  // array window CombinedNumbers
  gCombinedNumbers_writeWindow =writecreate("Telephone CombinedNumbers_Array");
  writeclear(gCombinedNumbers_writeWindow);
  // array window Picture
  gPicture_writeWindow =writecreate("Telephone Picture_Array");
  writeclear(gPicture_writeWindow);
  //clear CAPL-window in write-window
  writeclear(1);

  //get version from Stack
  Bap180_GetVersions(BAPVersion, 100);
  write(" ");
  write("***************************************************");
  write(BAPVersion);
  write("***************************************************");
  write(" ");
  write("***************************************************");
  write("FSG-Telephone function catalog: 'BAP-FC_TEL_P30DF50_v3.01_F.pdf'");
  write("FSG-Telephone MSCs: 'BAP-MSC_TEL_P30DF40_v2.00.pdf'");
  write("***************************************************");

  // Create Node
  NODE_INDEX=Bap180_CreateNode();

  // Load DBC and XML files.
  write("*********************************************************************************");
  switch(canethdecider())
  {
    case 1:
      //load dbc-file
      getAbsFilePath(dbc_path, Path, 255);
      write("FSG: Loading BAP_DBC-File: '%s'", Path);
      if(Bap180_LoadDBC(NODE_INDEX, 1, Path) != BAP_ERR_OK)
        writelineEx(gError_Trace, 0, "ASG: Fehler beim Laden: '%s', Path");
      else
        write("FSG: DBC successfully loaded");
      //load xml-file
      getAbsFilePath(xml_path, Path, 255);
      write("FSG: Load BAP-XML-File: '%s'", Path);

      if(Bap160_LoadConfig(NODE_INDEX, Path) != BAP_ERR_OK)
        writelineEx(gError_Trace, 0, "FSG: Fehler beim Laden: '%s' !", Path);
      else
        write("FSG: XML successfully loaded");
      write("*********************************************************************************");
      write("");
      // BAP DLL: Add CAN channel: BAP channel 1 is mapped to CAN card channel 1.
      Bap180_AddCanMap(NODE_INDEX, 1, 1);
      break;
    case 2:
      //load dbc-file
      getAbsFilePath(dbce_path, Path, 255);
      write("FSG: Loading BAP_DBC-File: '%s'", Path);
      if(Bap180_LoadDB(NODE_INDEX, 20, 2, Path) != BAP_ERR_OK)
        writelineEx(gError_Trace, 0, "FSG: Fehler beim Laden: '%s', Path");
      else
        write("FSG: DBC successfully loaded");
      //load xml-file
      getAbsFilePath(xmle_path, Path, 255);
      write("FSG: Load BAP-XML-File: '%s'", Path);

      if(Bap160_LoadConfig(NODE_INDEX, Path) != BAP_ERR_OK)
        writelineEx(gError_Trace, 0, "FSG: Fehler beim Laden: '%s' !", Path);
      else
        write("FSG: XML successfully loaded");
      write("*********************************************************************************");
      write("");
      // BAP DLL: Add CAN channel: BAP channel 1 is mapped to CAN card channel 1.
      Bap180_AddCanMap(NODE_INDEX, 20, 1);
      break;
    default:
      break;
  }
}

//*************************************************************************
//*****************Start***************************************************
//*************************************************************************
on start
{
  //RGB-Values for background colors
  gRGB_red=MakeRGB(255,0,0);
  gRGB_yellow=MakeRGB(255,255,0);
  gRGB_green=MakeRGB(0,255,0);
  gRGB_grey=MakeRGB(192,192,192);
  gRGB_white=MakeRGB(255,255,255);

  //Power on/off
  gBAP_Init = 0;
  gFSG_Telephone_PowerOnOff = 0;
  gFSG_Schalter_OnOff = 0;
  putvalue(env_FSG_string_Power_on_off, gstring_FSG_Telephone_PowerOnOff [gFSG_Telephone_PowerOnOff]);
  putvalue(env_FSG_Schalter_OnOff_string, gFSG_Schalter_OnOff_string[gFSG_Schalter_OnOff]);
  putValue(env_FSG_Schalter_OnOff, gFSG_Schalter_OnOff);

  //FunctionList
  putvalue(env_FSG_Telephone_s_FctList_set, gstring_FunctionListModified[gFunctionListModified]);
  settimer(agetimer, 1000);                     //start timer for getting the date

  EnableControl("BAP_Message_Generator","ExtendedArrayHeader", 0);

  // open main panel
 // OpenPanel("FSG-Telephone_Schalter");
}

//*************************************************************************
//*****************TaskTimer***********************************************
//*************************************************************************
on timer TaskTimer
{

  Bap180_Task(NODE_INDEX); //DLL-Task

  BAP_DLL_Indication();

  BAP_DLL_Request();

  BAP_CAN_TX_Request();

  if(canethdeciderValue == 2) BAP_DLL_SetRxData();

  setTimer(TaskTimer, 10); //restart real CAN-communication timer
}

//*************************************************************************
//******************************Name Decider*******************************
//*************************************************************************
int canethdecider()
{
#if 1
  return (canethdeciderValue = 2); // Ethernet only
#else
  char buffer[255];

  getConfigurationName(buffer,255);

  if(strstr_regex(buffer,"Ethernet") > 0)
  {
    write("This is a Ethernet-Simulation");
    return (canethdeciderValue = 2);
  }
  else if(strstr_regex(buffer,"CAN") > 0)
  {
    write("This is a CAN-Simulation");
    return (canethdeciderValue = 1);
  }
  else
  {
    write("Please edit the name of your configuration name so that either \"CAN\" or \"Ethernet\" is in the name ( lower/upper case sensetiv ) ");
    return (canethdeciderValue = -1);
  }
#endif
}


//*************************************************************************
//*****************TaskTimer Functions*************************************
//*************************************************************************
void BAP_DLL_Indication() //function to get received BAP-data from DLL (at BAL-interface)
{
  int i, length, datalength, temp;
  byte Indication_data[BAP_buffer_size]; //indication data from DLL
  dword Indication_header[6];            //indication header from DLL
  byte BAP_data_type;

  //init lokal variables
  length=0;
  temp=0;
  datalength=0;
  BAP_data_type=0;

  for(i=0;i<6;i++)
    Indication_header[i]=0;

  for(i=0;i<BAP_buffer_size;i++)
    Indication_data[i]=0;
  //********************

  Indication_header[4]=BAP_buffer_size;                               //BAP-Stack need this information for successful BAP_GetIndication

  temp=Bap180_GetInd(NODE_INDEX, Indication_header, Indication_data); //get BAP-Indication data from DLL
  //write("BAP_GetIndication: %d", temp);                             //debug

  if(temp==0){
    //read header
    gBAP_Indication[0]=Indication_header[0];                  //LSG-ID
    gBAP_Indication[1]=Indication_header[1];                  //Function-ID
    gBAP_Indication[2]=Indication_header[2];                  //indication

    BAP_data_type=Indication_header[3];                       //BAP data type
    //write("Data-Type: %d", BAP_data_type);                  //Debug

    switch(BAP_data_type){
      case Bap_Void:
        datalength=3;
        BAP_Indication(datalength);                     //evaluate BAP-Indication data
      break;
      case Bap_UInt8:
        gBAP_Indication[3]=Indication_header[5];        //unit8-value
        datalength=4;
        BAP_Indication(datalength);                     //evaluate BAP-Indication data
      break;
      case Bap_UInt16:
        gBAP_Indication[3]=Indication_header[5];        //unit16-value
        datalength=4;
        BAP_Indication(datalength);                     //evaluate BAP-Indication data
      break;
      case Bap_UInt32:
        gBAP_Indication[3]=Indication_header[5];        //unit32-value
        datalength=4;
        BAP_Indication(datalength);                     //evaluate BAP-Indication data
      break;
      case Bap_ByteSequence:          //BAP-data-type is byte sequence
        //read datalength
        length=Indication_header[4]; //length of date-array
        datalength=length+3;         //length of indication-array
        //read data-array
        for(i=0;i<length;i++)
          gBAP_Indication[i+3]=Indication_data[i];
        BAP_Indication(datalength);                     //evaluate BAP-Indication data
      break;
      case Bap_Acknowledge:
        gBAP_Indication[3] = Indication_header[5];      //unit32-value
        datalength=4;
      break;
      default:
        writelineEx(gError_Trace, 0, "FSG-Telephone BAP_DLL_Indication: invalid BAP-Data-Type: %d", BAP_data_type);
      break;
    }
  }
}

void BAP_Indication(int length) //evaluate LSG-ID
{
  if(length!=0){
    switch(gBAP_Indication[0]){
      case LSG_TELEPHONE:
        telephone_functions(gBAP_Indication [1], length);
      break;
      default:
        writelineEx(gError_Trace, 0, "FSG-Telephone error BAP_Indication: invalid LSG-ID %x", gBAP_Indication[0]);
      break;
    }
  }
}

telephone_functions (byte functionID, int datalength)
{
  switch (functionID){
    case FctID_FSG_Control:
      FSG_Control_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_FSG_Setup:
      FSG_Setup_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_FSG_OperationState:
      FSG_OperationState_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_MobileServiceSupport:
      MobilServiceSupport_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_DeviceConnectionState:
      DeviceConnectionState_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_NetworkState:
      NetworkState_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_NetworkProvider:
      NetworkProvider_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_ActiveUser:
      ActiveUser_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_MobileBatteryLevel:
      MobileBatteryLevel_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_CallState:
      CallState_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_CallInfo:
      CallInfo_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_CallDuration:
      CallDuration_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_AudioMuteOnOff:
      AudioMuteOnOff_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_MissedCallIndication:
      MissedCallIndication_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_AutomaticRedial:
      AutomaticRedial_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_DialNumber:
      DialNumber_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_ConfirmEmergencyCall:
      ConfirmEmergencyCall_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_BasicCallHandling:
      BasicCallHandling_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_MPCall_CC_Handling:
      MPCall_CC_Handling_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
    break;
    case FctID_CombinedNumbers:
      CombinedNumbers_Indication(gBAP_Indication);
    break;
    case FctID_Picture:
      Picture_Indication(gBAP_Indication);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone telephone_functions: unknown funcion-ID %d", functionID);
    break;
  }
}

void BAP_DLL_Request ()
{
  int i, datalength, temp;
  byte Request_data[BAP_buffer_size]; //Request data for DLL
  dword Request_header[6];  //Request header for DLL
  byte Wammw;         //data-error-flag (Geräusch)

  //init local variables
  datalength=0;
  temp=0;
  Wammw=1;
  for(i=0;i<6;i++)
    Request_header[i]=0;
  for(i=0;i<BAP_buffer_size;i++)
    Request_data[i]=0;
  //********************

  if(gBAP_Requestbufffer_status [gstatus_requestbuffer]>0)
  {             //if ready to send
    switch(gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer])
    {
      case Bap_Void:
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];               //LSG-ID
        Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];               //Function-ID
        Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];               //request
        Request_header[3]=gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]; //BAP data type
        Request_header[4]=0;                                                     //not used
        Request_header[5]=0;                                                     //not used
      break;
      case Bap_UInt8:
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];               //LSG-ID
        Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];               //Function-ID
        Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];               //request
        Request_header[3]=gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]; //BAP data type
        Request_header[4]=0;                                                     //not used
        Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];               //unit8-value
      break;
      case Bap_UInt16:
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];               //LSG-ID
        Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];               //Function-ID
        Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];               //request
        Request_header[3]=gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]; //BAP data type
        Request_header[4]=0;                                                     //not used
        Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];               //unit16-value
      break;
      case Bap_UInt32:
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];               //LSG-ID
        Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];               //Function-ID
        Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];               //request
        Request_header[3]=gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]; //BAP data type
        Request_header[4]=0;                                                     //not used
        Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];               //unit32-value
      break;
      case Bap_ByteSequence:          //BAP-data-type is byte sequence
        datalength=gBAP_Requestbufffer_status [gstatus_requestbuffer]-3;
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];               //LSG-ID
        Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];               //Function-ID
        Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];               //request
        Request_header[3]=Bap_ByteSequence;                                      //BAP data type
        Request_header[4]=datalength;                                            //length of date-array
        //data-array for BAP-DLL funcion 'BAP_Request'
        for(i=0;i<=datalength;i++)
          Request_data[i]=gBAP_Request[gstatus_requestbuffer] [i+3];
      break;
      case Bap_Error:
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];               //LSG-ID
        Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];               //Function-ID
        Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];               //request
        Request_header[3]=gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]; //BAP data type
        Request_header[4]=0;                                                     //not used
        Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];               //error code
      break;
      default:
        writelineEx(gError_Trace, 0, "FSG-Telephone BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]);
        Wammw=0;
      break;
    }

    if(Wammw)
    {
      //no data-error
      temp=Bap180_Request(NODE_INDEX, Request_header, Request_data);             //send data to BAP-DLL
      if(temp==0)
      {   //BAP-Request successful
      }
      else
      {       //BAP-Request error
        writelineEx(gBAP_Trace, 0, "FSG-Telephone Error BAP_Request, errorcode: 0x%x FSG-Telephone Request:",temp); //debug
        for (i=0;i<gBAP_Requestbufffer_status [gstatus_requestbuffer];i++)                                          //debug
          writeEX(gBAP_Trace, 0, " 0x%x",gBAP_Request [gstatus_requestbuffer] [i]);                                 //debug
      }
    }

    gBAP_Requestbufffer_status [gstatus_requestbuffer]=0; //reset position status -> free position
    gBAP_Requestbufffer_BAPDataTyp [gstatus_requestbuffer]=0; //reset BAP-datatyp of sendet buffer element

    //delete send request buffer elements
    gBAP_Requestbufffer_status [gstatus_requestbuffer]=0;
    for(i=0;i<BAP_buffer_size;i++)
      gBAP_Request [gstatus_requestbuffer] [i]=0; //delete sended array

    if (gstatus_requestbuffer<(Requestbuffer_lines-1)) //last element of buffer is not reached
      gstatus_requestbuffer++;
    else                                               //last element of buffer is reached
      gstatus_requestbuffer=0;
  }
}

void BAP_CAN_TX_Request() //Function to send BAP-data over CAN
{
  int i;
  byte DestIp[16];
  byte TX_Data[1500];       // CAN-data
  byte TX_Data_FR[10];      // FlexRay-Data
  dword TX_Header[13];      // Header
  message 0x100 TX_Message; // dummy-message, Adresse wird noch modifiziert

  byte send_result;

  if(canethdeciderValue == 1){  // Uses CAN
    TX_Header[0] = 1; /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
    TX_Header[2] = 64; // max-Length of TX_Data

  // Pollen ueber die Queue, die von der DLL zur Verfuegung gestellt wird
  // Diese Daten muessen ueber den CAN Bus gesendet werden
    while (BAP180_GetTxData(NODE_INDEX,TX_Header,TX_Data) == 0) {
      TX_Message.CAN = TX_Header[1];        //CAN channel
      TX_Message.ID = TX_Header[3];         //Can ID
      TX_Message.DataLength = TX_Header[2]; //received length

      for (i=0; i<TX_Message.DataLength; i++) { //CAN data-bytes
        TX_Message.byte(i) = TX_Data[i];
      }

      TX_Message.EDL = 0;
      TX_Message.BRS = 0;
      if(TX_Header[4] & 2)
        TX_Message.EDL = 1;
      if(TX_Header[4] & 4)
        TX_Message.BRS = 1;

      output(TX_Message);         //send CAN message

      //Versions Output
      if(TX_Data[0] == 0x40 && TX_Data[1] == 0x00 && TX_Header[2] == 4)
      {
        writelineEx(gBAP_Trace, 0,"Major Version: %i, Minor Version: %i", TX_Data[2], TX_Data[3]);
      }
      TX_Header[2] = 64; // max-Length of TX_Data
    }
  }
  else if (canethdeciderValue == 2)
  { // Uses Ethernet
    TX_Header[0] = 4; // /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
    TX_Header[2] = 1500; // max-Length of TX_Data
    while( BAP180_GetTxData( NODE_INDEX,TX_Header,TX_Data ) == 0 ) {
      for(i=0; i<8;i++)
      {
         DestIp[2*i]   = (byte)(TX_Header[i+4]>>8);
         DestIp[2*i+1] = (byte)(TX_Header[i+4]&0xFF);
      }
      for (i=0; i<TX_Header[2]; i++) {  //CAN data-bytes
       TX_Data.byte(i) = TX_Data[i];
      }

      send_result = UdpSendTo(gUdpSockets[TX_Header[3]-1].Handle, DestIp, TX_Header[12], TX_Data, TX_Header[2]);

      if (0 == send_result){

      }else{
        writeLineEx(0,3, "UdpSendTo failed, error code %d, last error %d", send_result, IpGetLastError());
      }

      TX_Header[2] = 1500; // max-Length of TX_Data
    }
  }
}

void BAP_DLL_SetRxData()
{
  int i;
  byte gRxBuffer[1500];
  for(i=0;i<gUdpSocketCnt;i++)
    UdpReceiveFrom(gUdpSockets[i].Handle, gRxBuffer, 0);
}

void EthernetCreateSocket()
{
  int index, result;
  dword i, j, Header[200], val, VlanId, VlanPrio, ifIndex;
  byte ipv6_adapter_adresses[5][16];
  byte ipv6_temp[16];
  byte ipv6_zero[16] = {0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0};
  const dword STR_SIZE = 256; // string buffer size
  char ifDescr[STR_SIZE];     // Interface description string.

  gUdpSocketCnt = 0;
  Header[0] = 1;
  if((result=BAP180_GetEthConfig(NODE_INDEX, Header)) == 0)
  {

    for(i=1;i<=3;i++)
    {
      if(IpGetAdapterAddress(i, ipv6_adapter_adresses, 5) == 0)
      {
        val = IpGetAdapterAddressCount(i, 28);
        for(j=0;j<val;j++)
        {
          IpRemoveAdapterAddress(i, ipv6_adapter_adresses[j], 64);
        }
      }
      else
      {
        break;
      }
    }
    for (ifIndex = 1; ifIndex <= IpGetAdapterCount(); ifIndex++)
    {
      result = IpGetAdapterDescription( ifIndex, ifDescr, elcount(ifDescr) );
      if( result == 0 )
      {
        // success.
        write("IpGetAdapterDescription for adapter %d returned: %s", ifIndex, ifDescr);
      }
      else
      {
        writeLineEx(1, 3, "IpGetAdapterDescription for adapter %d: Error %d", ifIndex, result);
      }
    }
    write("FSG_Telephone: Header: VlanId:%d VlanPrio:%d gUdpSocketCnt:%d gUdpSockets[0].Id:%d IPv6:%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X Port:%d gUdpSockets[1].Id:%d IPv6:%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X Port:%d %x %x",
      Header[ 0], Header[ 1], Header[ 2], Header[ 3], Header[ 4], Header[ 5], Header[ 6], Header[ 7], Header[ 8], Header[ 9],
      Header[10], Header[11], Header[12], Header[13], Header[14], Header[15], Header[16], Header[17], Header[18], Header[19],
      Header[20], Header[21], Header[22], Header[23], Header[24]);
    index=0;
    ifIndex = 1;
    VlanId = Header[index++];
    VlanPrio = Header[index++];
    writelineex(0, 1, "FSG_Telephone: VLAN ID: %d", VlanId);
    writelineex(0, 1, "FSG_Telephone: VLAN Prio: %d", VlanPrio);
    if(VlanId != 0xFFFF)
      ifIndex = 2;
    writelineex(0, 1, "FSG_Telephone: ifIndex: %d", ifIndex);

    gUdpSocketCnt = Header[index++];
    for(i=0; i<gUdpSocketCnt;i++)
    {
      gUdpSockets[i].Id = Header[index++];
      for(j=0;j<8;j++)
     {
        ipv6_temp[j*2]   = Header[index]>>8;
        ipv6_temp[j*2+1] = Header[index++]&0xFF;
      }
      write("FSG_Telephone: ipv6_temp: %02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X",
        ipv6_temp[ 0], ipv6_temp[ 1], ipv6_temp[ 2], ipv6_temp[ 3], ipv6_temp[ 4], ipv6_temp[ 5], ipv6_temp[ 6], ipv6_temp[ 7], ipv6_temp[ 8], ipv6_temp[ 9],
        ipv6_temp[10], ipv6_temp[11], ipv6_temp[12], ipv6_temp[13], ipv6_temp[14], ipv6_temp[15]);

      if((result=IpAddAdapterAddress(ifIndex, ipv6_temp, 64)) != 0)
        writelineex(0, 3, "FSG_Telephone: Error: IpAddAdapterAddress failed. Error: %d ErrorCode: %d ifIndex: %d", result, IpGetLastError(), ifIndex);

      if(ipv6_temp[0] == 0xFF)
        gUdpSockets[i].Handle = UdpOpen( ipv6_zero, Header[index++]);
      else
        gUdpSockets[i].Handle = UdpOpen( ipv6_temp, Header[index++]);

      if (gUdpSockets[i].Handle == ~0)
      {
        writelineex(0, 3, "FSG_Telephone: Error: could not create Udp socket! %d", IpGetLastError());
      }
      else
      {
        writelineex(0, 1, "FSG_Telephone: Udp socket is opened successfully.");

        if(ipv6_temp[0] == 0xFF)
        {
          if((result=IpJoinMulticastGroup(gUdpSockets[i].Handle, ifIndex, ipv6_temp)) != 0)
            writelineex(0, 3, "FSG_Telephone: IpJoinMulticastGroup failed. Error: %d ErrorCode: %d ifIndex: %d", result, IpGetLastSocketError(gUdpSockets[i].Handle), ifIndex);
        }

        if((result=IpSetMulticastInterface ( gUdpSockets[i].Handle, ifIndex)) != 0)
          writelineex(0, 3, "FSG_Telephone: IpSetMulticastInterface failed. Error: %d ErrorCode: %d", result, IpGetLastSocketError(gUdpSockets[i].Handle));
      }
    }
  }
  else
  {
    writelineex(0, 3, "FSG_Telephone: Error: BAP180_GetEthConfig failed! = %x", result);
  }
}

OnUdpReceiveFrom( dword socket, long result, byte ipv6Address[], dword port, byte buffer[], dword size)
{
  int i;
  dword Header[13];
  byte Ipv6_temp[16];
  const long  INVALID_SOCKET = ~0;

  if(socket != INVALID_SOCKET)
  {
    if(result == 0)
    {
      Header[0] = 4; // /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
      Header[1] = 1;
      Header[2] = size;

     for(i=0;i<gUdpSocketCnt;i++)
      {
        if(gUdpSockets[i].Handle == socket)
        {
          Header[3] = gUdpSockets[i].Id;
          for(i=0; i<8; i++)
          {
            Header[i+4] = ((dword)ipv6Address[2*i]) << 8;
            Header[i+4] |= ((dword)ipv6Address[2*i+1]) ;
          }
          Header[12] = port;
          BAP180_SetRxData(NODE_INDEX, Header, buffer);
          break;
        }
      }
    }
  }
}

void CloseUdpSocket()
{
  int i;
  const long  INVALID_SOCKET =    ~0;
  for(i=0;i<gUdpSocketCnt;i++)
  {
    if(gUdpSockets[i].Handle != INVALID_SOCKET)
    {
      UdpClose(gUdpSockets[i].Handle);
      gUdpSockets[i].Handle = INVALID_SOCKET;
    }
  }
}

//*************************************************************************
//*****************PowerOnOff Event****************************************
//*************************************************************************
on envVar env_FSG_Power_on_off
{
  int length, temp;

  putvalue(env_FSG_string_Power_on_off, gstring_FSG_Telephone_PowerOnOff[getvalue(env_FSG_Power_on_off)]);
  if(getvalue(env_FSG_Power_on_off)==1)
  {
    if(gBAP_Init==0)
    {
      gBAP_Init=1;
      //BAP-Init Telephone
      temp=Bap180_Init(NODE_INDEX,LSGID_Telephone);
      if(temp==0)
        write("FSG-Telephone BAP_Init successful");
      else
        write("FSG-Telephone error BAP_Init: %d", temp);
    }

    init_variables();             //initialize variables
    CombinedNumbers_init_static();  //initialize CombinedNumbers
    Picture_init_static();          //initialize Picture
    BAP_Set_Cache();              //initialize Cache
    if(canethdeciderValue==2) EthernetCreateSocket();
    //BAP-Start Telephone
    temp=Bap180_Start(NODE_INDEX,LSGID_Telephone);
    if(temp==0)
      write("FSG-Telephone BAP_Start successful");
    else
      write("FSG-Telephone error BAP_Start: %d", temp);
    settimer(Powerontimer, 20);
  }
  else
  {
    Bap180_Shutdown(NODE_INDEX,LSGID_Telephone);
    gFSG_Telephone_PowerOnOff=getvalue(env_FSG_Power_on_off);
    Shutdown_FSG_Telephone();
    if(canethdeciderValue==2)  CloseUdpSocket();
  }
}

on envVar env_FSG_Schalter_OnOff
{
    if(getvalue(this))  //FSG Power on
    {
        putvalue(env_FSG_Power_on_off, 1);
        gFSG_Schalter_OnOff = 1;
        putvalue(env_FSG_Schalter_OnOff_string, gFSG_Schalter_OnOff_string[gFSG_Schalter_OnOff]);

    }
    else                //FSG Power off
    {
        putvalue(env_FSG_Power_on_off, 0);
        gFSG_Schalter_OnOff = 0;
        putvalue(env_FSG_Schalter_OnOff_string, gFSG_Schalter_OnOff_string[gFSG_Schalter_OnOff]);
    }
}

on timer Powerontimer
{
  gFSG_Telephone_PowerOnOff=1;
  settimer(TaskTimer, 10);          //start real CAN-communication timer
  //BAP_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID_Telephone, DEBUG_SWITCH_ON); //BAP-Debug-message
  //BAP_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID_Phonebook, DEBUG_SWITCH_ON); //BAP-Debug-message
}

//*************************************************************************
//*****************init/shutdown functions*********************************
//*************************************************************************
void init_variables ()
{
  int i, j;
  char empty_string [3];

  //init local variables
  for(i=0;i<3;i++)
    empty_string[i]=0;
  //********************
  gKl15=0;
  gKlS=0;

  //BAP-Communication
  for (i=0;i<BAP_buffer_size;i++)
    gBAP_Indication[i]=0;

  for (j=0;j<Requestbuffer_lines;j++)
  {
    gBAP_Requestbufffer_status[j]=0;
    gBAP_Requestbufffer_BAPDataTyp[j]=0;

    for (i=0;i<BAP_buffer_size;i++)
      gBAP_Request[j][i]=0;
  }

  gwrite_requestbuffer_line=0;
  gstatus_requestbuffer=0;

  //IncomingCallnumber
  /*
  gincomingcall=0;
  gstatus_incomingcall_changearraytimer=0;
  gincomingcall_numbertype=0;
  gincomingcall_calltype=SINGLE_VOICE_CALL;
  gincomingcall_divert=0;
  gmissedcall=0;
  greceivedcall_numbertype=0;
  gnumbersearchphonebook=0;
  for (i=0;i<CALL_INFO_NUMBER_LENGTH;i++){
    gincomingcall_number[i]=0;
    greceivedcall_number[i]=0;
  }
  for (i=0;i<40;i++){
    gincomingcall_name[i]=0;
    greceivedcall_name[i]=0;
  }
  putvalue(env_FSG_incomingcallstring, empty_string);
  */

  //*************************************************************************
  //******************************Fct-IDs************************************
  //*************************************************************************

  //FunctionList
  //Byte0
  gFunctionList0=0x40;                   //getvalue(env_FSG_Telephone_FctList_0x01)*0x40;
  gFunctionList0=gFunctionList0+0x20;    //getvalue(env_FSG_Telephone_FctList_0x02)*0x20;
  gFunctionList0=gFunctionList0+0x10;    //getvalue(env_FSG_Telephone_FctList_0x03)*0x10;
  gFunctionList0=gFunctionList0+0x08;    //getvalue(env_FSG_Telephone_FctList_0x04)*0x08;
  //Byte1
  gFunctionList1=0x00;//reset
  gFunctionList1=gFunctionList1+0x04;//getvalue(env_FSG_Telephone_FctList_0x0D)*0x04;
  gFunctionList1=gFunctionList1+0x02;//getvalue(env_FSG_Telephone_FctList_0x0E)*0x02;
  gFunctionList1=gFunctionList1+0x01;//getvalue(env_FSG_Telephone_FctList_0x0F)*0x01;
  //Byte2
  gFunctionList2=0x80;//getvalue(env_FSG_Telephone_FctList_0x10)*0x80;
  gFunctionList2=gFunctionList2+0x40;//getvalue(env_FSG_Telephone_FctList_0x11)*0x40;
  gFunctionList2=gFunctionList2+0x20;//getvalue(env_FSG_Telephone_FctList_0x12)*0x20;
  gFunctionList2=gFunctionList2+0x10;//getvalue(env_FSG_Telephone_FctList_0x13)*0x10;
  gFunctionList2=gFunctionList2+0x08;//getvalue(env_FSG_Telephone_FctList_0x14)*0x08;
  gFunctionList2=gFunctionList2+0x04;//getvalue(env_FSG_Telephone_FctList_0x15)*0x04;
  gFunctionList2=gFunctionList2+0x02;//getvalue(env_FSG_Telephone_FctList_0x16)*0x02;
  gFunctionList2=gFunctionList2+0x01;//getvalue(env_FSG_Telephone_FctList_0x17)*0x01;
  //Byte3
  gFunctionList3=0x80;//getvalue(env_FSG_Telephone_FctList_0x18)*0x80;
  gFunctionList3=gFunctionList3+0x40;//getvalue(env_FSG_Telephone_FctList_0x19)*0x40;
  gFunctionList3=gFunctionList3+0x20;//getvalue(env_FSG_Telephone_FctList_0x1A)*0x20;
  gFunctionList3=gFunctionList3+0x10;//getvalue(env_FSG_Telephone_FctList_0x1B)*0x10;
  gFunctionList3=gFunctionList3+0x08;//gFunctionList3=gFunctionList3+getvalue(env_FSG_Telephone_FctList_0x1C)*0x08;
  gFunctionList3=gFunctionList3+0x04;//getvalue(env_FSG_Telephone_FctList_0x1D)*0x04;
  gFunctionList3=gFunctionList3+0x02;//getvalue(env_FSG_Telephone_FctList_0x1E)*0x02;
  gFunctionList3=gFunctionList3+0x01;//getvalue(env_FSG_Telephone_FctList_0x1F)*0x01;
  //Byte4
  gFunctionList4=0x80;//getvalue(env_FSG_Telephone_FctList_0x20)*0x80;
  gFunctionList4=gFunctionList4+0x40;//getvalue(env_FSG_Telephone_FctList_0x21)*0x40;
  //Byte5-7
  gFunctionList5=0x00;
  gFunctionList6=0x00;
  gFunctionList7=0x00;

  //FSG_Control
  gFsgControl_Extension1=0;
  gFsgControl_Extension2=0;
  gFsgControl_Extension3=0;
  gFsgControl_Extension4=0;
  gFsgControl_Extension5=0;
  gFsgControl_Extension6=0;

  //FSG_Setup (value-setting before Power-On is allowed)
  gPrivacyModeBit=getvalue(env_FSG_PrivacyModeBit);
  gPrivacyMode=gPrivacyModeBit;
  gFsgSetup_FunctionProtection=getvalue(env_FSG_FS_FctProtectBit);
  gFsgSetup_FunctionProtectionBit=getvalue(env_FSG_FS_FctProtectBit);
  gFsgSetup_WebAppState=getvalue(env_FSG_FS_WebAppStateBit);
  gFsgSetup_WebAppStateBit=getvalue(env_FSG_FS_WebAppStateBit);
  gFsgSetup_Extension1=0;
  gFsgSetup_Extension2=0;
  gFsgSetup_Extension3=0;
  gFsgSetup_Extension4=0;

  //FSG_OperationState
  gOP_State=getvalue(env_FSG_OP_State);
  gFsgOperationState_Extension1=0;
  gFsgOperationState_Extension2=0;
  gFsgOperationState_Extension3=0;
  gFsgOperationState_Extension4=0;
  gFsgOperationState_Extension5=0;

  //MobilServiceSupport
  //Byte0
  gMobilServiceSupport0=getvalue(env_FSG_Telephone_MSS_0x01)*0x40;
  gMobilServiceSupport0=gMobilServiceSupport0+getvalue(env_FSG_Telephone_MSS_0x02)*0x20;
  gMobilServiceSupport0=gMobilServiceSupport0+getvalue(env_FSG_Telephone_MSS_0x03)*0x10;
  gMobilServiceSupport0=gMobilServiceSupport0+getvalue(env_FSG_Telephone_MSS_0x04)*0x08;
  //Byte1
  gMobilServiceSupport1=getvalue(env_FSG_Telephone_MSS_0x0D)*0x04;
  gMobilServiceSupport1=gMobilServiceSupport1+getvalue(env_FSG_Telephone_MSS_0x0E)*0x02;
  gMobilServiceSupport1=gMobilServiceSupport1+getvalue(env_FSG_Telephone_MSS_0x0F)*0x01;
  //Byte2
  gMobilServiceSupport2=getvalue(env_FSG_Telephone_MSS_0x10)*0x80;
  gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x11)*0x40;
  gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x12)*0x20;
  gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x13)*0x10;
  gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x14)*0x08;
  gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x15)*0x04;
  gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x16)*0x02;
  gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x17)*0x01;
  //Byte3
  gMobilServiceSupport3=getvalue(env_FSG_Telephone_MSS_0x18)*0x80;
  gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x19)*0x40;
  gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1A)*0x20;
  gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1B)*0x10;
  gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1C)*0x08;
  gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1D)*0x04;
  gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1E)*0x02;
  gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1F)*0x01;
  //Byte4
  gMobilServiceSupport4=getvalue(env_FSG_Telephone_MSS_0x20)*0x80;
  gMobilServiceSupport4=gMobilServiceSupport4+getvalue(env_FSG_Telephone_MSS_0x21)*0x40;
  //Byte5-7
  gMobilServiceSupport5=0;
  gMobilServiceSupport6=0;
  gMobilServiceSupport7=0;

  //DeviceConnectionState
  gSIMCardReader=getvalue(env_FSG_SIMCardReader);
  gCableConnection=getvalue(env_FSG_CableConnection);
  gHFPConnection=getvalue(env_FSG_HFPConnection);
  gRSAPConnection=getvalue(env_FSG_RSAPConnection);
  gAppleCarPlay=getvalue(env_FSG_AppleCarPlay);
  gAndroidAuto=getvalue(env_FSG_AndroidAuto);
  gBaiduCarLife=getvalue(env_FSG_BaiduCarLife);
  gPhoneCharacteristics=gSIMCardReader+2*gCableConnection+4*gHFPConnection+8*gRSAPConnection+16*gAppleCarPlay+32*gAndroidAuto+64*gBaiduCarLife;
  gMobileConnectionType=getvalue(env_FSG_MobileConnectionType);
  gTel_State=getvalue(env_FSG_Tel_State);
  gLockState=getvalue(env_FSG_LockState);
  gPIN_attempts=3;
  gDeviceConnectionState_Extension1=0;
  gDeviceConnectionState_Extension2=0;
  gDeviceConnectionState_Extension3=0;
  gDeviceConnectionState_Extension4=0;
  gDeviceConnectionState_Extension5=0;
  gDeviceConnectionState_Extension6=0;

  //NetworkState
  gRegisterState=getvalue(env_FSG_RegisterState);
  gNetworkType=getvalue(env_FSG_NetworkType);
  gPacketDataNetworkType=getvalue(env_FSG_PacketDataNetworkType);
  gSignalQuality=random(99);
  gSignalQuality=0;
  putvalue(env_FSG_SignalQuality, gSignalQuality);
  gNetworkState_Extension1=0;
  gNetworkState_Extension2=0;

  //NetworkProvider
  for (i=0;i<40;i++)
    gNetworkProviderName[i]=0;
  putvalue(env_FSG_NetworkProviderName, empty_string);
  gNetworkProviderState=0;
  gNetworkProvider_Extension=0;

  //ActiveUser
  for(i=0;i<50;i++)
    gUserName[i]=0;
  putvalue(env_FSG_UserName, empty_string);

  //MobileBatteryLevel
  gChargeLevel=0;
  gWarningLevel=0;
  gMobileBatteryLevel_Extension1=0;
  gMobileBatteryLevel_Extension2=0;
  gMobileBatteryLevel_Extension3=0;
  gMobileBatteryLevel_Extension4=0;
  gMobileBatteryLevel_Extension5=0;

  //CallState
  for(i=0;i<7;i++)
    gCallState[i]=0;
  putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
  putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
  putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
  putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
  putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
  putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
  putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
  for(i=0;i<7;i++)
    gCallType[i]=0;
  putvalue(env_FSG_CallType_CallID_0, empty_string);
  putvalue(env_FSG_CallType_CallID_1, empty_string);
  putvalue(env_FSG_CallType_CallID_2, empty_string);
  putvalue(env_FSG_CallType_CallID_3, empty_string);
  putvalue(env_FSG_CallType_CallID_4, empty_string);
  putvalue(env_FSG_CallType_CallID_5, empty_string);
  putvalue(env_FSG_CallType_CallID_6, empty_string);
  //CallOptions
  putvalue(env_FSG_CallState_Opt0_1_Bit0, 0);
  putvalue(env_FSG_CallState_Opt0_1_Bit1, 0);
  putvalue(env_FSG_CallState_Opt0_1_Bit2, 0);
  putvalue(env_FSG_CallState_Opt0_1_Bit3, 0);
  putvalue(env_FSG_CallState_Opt0_1_Bit4, 0);
  putvalue(env_FSG_CallState_Opt0_1_Bit5, 0);
  putvalue(env_FSG_CallState_Opt0_1_Bit6, 0);
  putvalue(env_FSG_CallState_Opt0_1_Bit7, 0);
  putvalue(env_FSG_CallState_Opt0_2_Bit0, 0);
  putvalue(env_FSG_CallState_Opt0_2_Bit1, 0);
  putvalue(env_FSG_CallState_Opt0_2_Bit2, 0);
  putvalue(env_FSG_CallState_Opt1_1_Bit0, 0);
  putvalue(env_FSG_CallState_Opt1_1_Bit1, 0);
  putvalue(env_FSG_CallState_Opt1_1_Bit2, 0);
  putvalue(env_FSG_CallState_Opt1_1_Bit3, 0);
  putvalue(env_FSG_CallState_Opt1_1_Bit4, 0);
  putvalue(env_FSG_CallState_Opt1_1_Bit5, 0);
  putvalue(env_FSG_CallState_Opt1_1_Bit6, 0);
  putvalue(env_FSG_CallState_Opt1_1_Bit7, 0);
  putvalue(env_FSG_CallState_Opt1_2_Bit0, 0);
  putvalue(env_FSG_CallState_Opt1_2_Bit1, 0);
  putvalue(env_FSG_CallState_Opt1_2_Bit2, 0);
  putvalue(env_FSG_CallState_Opt2_1_Bit0, 0);
  putvalue(env_FSG_CallState_Opt2_1_Bit1, 0);
  putvalue(env_FSG_CallState_Opt2_1_Bit2, 0);
  putvalue(env_FSG_CallState_Opt2_1_Bit3, 0);
  putvalue(env_FSG_CallState_Opt2_1_Bit4, 0);
  putvalue(env_FSG_CallState_Opt2_1_Bit5, 0);
  putvalue(env_FSG_CallState_Opt2_1_Bit6, 0);
  putvalue(env_FSG_CallState_Opt2_1_Bit7, 0);
  putvalue(env_FSG_CallState_Opt2_2_Bit0, 0);
  putvalue(env_FSG_CallState_Opt2_2_Bit1, 0);
  putvalue(env_FSG_CallState_Opt2_2_Bit2, 0);
  putvalue(env_FSG_CallState_Opt3_1_Bit0, 0);
  putvalue(env_FSG_CallState_Opt3_1_Bit1, 0);
  putvalue(env_FSG_CallState_Opt3_1_Bit2, 0);
  putvalue(env_FSG_CallState_Opt3_1_Bit3, 0);
  putvalue(env_FSG_CallState_Opt3_1_Bit4, 0);
  putvalue(env_FSG_CallState_Opt3_1_Bit5, 0);
  putvalue(env_FSG_CallState_Opt3_1_Bit6, 0);
  putvalue(env_FSG_CallState_Opt3_1_Bit7, 0);
  putvalue(env_FSG_CallState_Opt3_2_Bit0, 0);
  putvalue(env_FSG_CallState_Opt3_2_Bit1, 0);
  putvalue(env_FSG_CallState_Opt3_2_Bit2, 0);
  putvalue(env_FSG_CallState_Opt4_1_Bit0, 0);
  putvalue(env_FSG_CallState_Opt4_1_Bit1, 0);
  putvalue(env_FSG_CallState_Opt4_1_Bit2, 0);
  putvalue(env_FSG_CallState_Opt4_1_Bit3, 0);
  putvalue(env_FSG_CallState_Opt4_1_Bit4, 0);
  putvalue(env_FSG_CallState_Opt4_1_Bit5, 0);
  putvalue(env_FSG_CallState_Opt4_1_Bit6, 0);
  putvalue(env_FSG_CallState_Opt4_1_Bit7, 0);
  putvalue(env_FSG_CallState_Opt4_2_Bit0, 0);
  putvalue(env_FSG_CallState_Opt4_2_Bit1, 0);
  putvalue(env_FSG_CallState_Opt4_2_Bit2, 0);
  putvalue(env_FSG_CallState_Opt5_1_Bit0, 0);
  putvalue(env_FSG_CallState_Opt5_1_Bit1, 0);
  putvalue(env_FSG_CallState_Opt5_1_Bit2, 0);
  putvalue(env_FSG_CallState_Opt5_1_Bit3, 0);
  putvalue(env_FSG_CallState_Opt5_1_Bit4, 0);
  putvalue(env_FSG_CallState_Opt5_1_Bit5, 0);
  putvalue(env_FSG_CallState_Opt5_1_Bit6, 0);
  putvalue(env_FSG_CallState_Opt5_1_Bit7, 0);
  putvalue(env_FSG_CallState_Opt5_2_Bit0, 0);
  putvalue(env_FSG_CallState_Opt5_2_Bit1, 0);
  putvalue(env_FSG_CallState_Opt5_2_Bit2, 0);
  putvalue(env_FSG_CallState_Opt6_1_Bit0, 0);
  putvalue(env_FSG_CallState_Opt6_1_Bit1, 0);
  putvalue(env_FSG_CallState_Opt6_1_Bit2, 0);
  putvalue(env_FSG_CallState_Opt6_1_Bit3, 0);
  putvalue(env_FSG_CallState_Opt6_1_Bit4, 0);
  putvalue(env_FSG_CallState_Opt6_1_Bit5, 0);
  putvalue(env_FSG_CallState_Opt6_1_Bit6, 0);
  putvalue(env_FSG_CallState_Opt6_1_Bit7, 0);
  putvalue(env_FSG_CallState_Opt6_2_Bit0, 0);
  putvalue(env_FSG_CallState_Opt6_2_Bit1, 0);
  putvalue(env_FSG_CallState_Opt6_2_Bit2, 0);
  for(i=0;i<8;i++)
    gCallOutgoingDiverted_eCallConfirmationPending[i]=0;
  gDisconnectReason=0;
  gCallState_Extension1=0;
  gCallState_Extension2=0;
  //CallActivity
  gCallActivity=0;
  putvalue(env_FSG_CallActivity, gstring_callactivity[gCallActivity]);

  //CallInfo
  gstatus_dialnumber_changearraytimer=0;
  for(j=0;j<7;j++)
  {
    for(i=0;i<CALL_INFO_NAME_LENGTH;i++)  //delete all call info strings
      gCallInfo_PbName[j][i]=0;
    for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
      gCallInfo_TelNumber[j][i]=0;
  }

  //CallDuration
  gCallDuration_1=0;
  gCallDuration_2=0;
  for(i=0;i<7;i++)
  {
    gCallDuration_Relation1[i]=0;
    gCallDuration_Relation2[i]=0;
  }

  //AudioMuteOnOff
  gAudioControl=0;
    gMicroMuteOnOff=0;
    putvalue(env_FSG_MicroMuteOnOff,gMicroMuteOnOff);
    gHandsFreeOnOff=0;
    putvalue(env_FSG_HandsFreeOnOff,gHandsFreeOnOff);
    gRingToneMuteOnOff=0;
    putvalue(env_FSG_RingToneMuteOnOff,gRingToneMuteOnOff);
  gFunctionSupport=0x00;
    gHandsFreeSupport    =0;
    putvalue(env_FSG_AMOO_FS_Bit0,gHandsFreeSupport);
    gMicroMuteSupport    =0;
    putvalue(env_FSG_AMOO_FS_Bit1,gMicroMuteSupport);
    gRingToneMuteSupport =0;
    putvalue(env_FSG_AMOO_FS_Bit2,gRingToneMuteSupport);
  gAudioMuteOnOff_Extension1=0;
  gAudioMuteOnOff_Extension2=0;
  gAudioMuteOnOff_Extension3=0;
  gAudioMuteOnOff_Extension4=0;

  //MissedCallIndication
  gMissedCalls=getvalue(env_FSG_MissedCalls);
  gMissedCallIndication_Extension1=0;
  gMissedCallIndication_Extension2=0;
  gMissedCallIndication_Extension3=0;
  gMissedCallIndication_Extension4=0;

  //AutomaticRedial
  gAutomaticRedialState = 0;
  putvalue(env_FSG_AutomaticRedial_Active, gAutomaticRedialState);
  putvalue(env_FSG_AutomaticRedial_ActiveS, gAutomaticRedialState_s[gAutomaticRedialState]);
  gAutomaticRedial_Extension1=0;
  gAutomaticRedial_Extension2=0;
  gAutomaticRedial_Extension3=0;
  gAutomaticRedial_Extension4=0;
  gAutomaticRedial_Extension5=0;

  //DialNumber
  for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
    gDialNumber[i]=0;
  for(i=0;i<DIAL_NUMBER_NAME_LENGTH;i++)
    gDialNumber_name[i]=0;
  gDialNumber_AsgId     =0;
  gDialNumber_Extension =0;
  gDialNumber_Result    =0;

  //ConfirmEmergencyCall
  gConfirmEmergencyCall_AsgId     =0;
  gConfirmEmergencyCall_Extension =0;
  gConfirmEmergencyCall_result    =0;
  gConfirmEmergencyCall_Control   =0;

  //BasicCallHandling
  ghangupcall_status=0;
  gacceptcall_status=0;
  gCallHold_status=0;
  gResumeCall_status=0;
  gBasicCallHandling_AsgId=0;
  gBasicCallHandling_CallFunction=0;
  gBasicCallHandling_CallId=0;
  gBasicCallHandling_Result=0;
  gBasicCallHandling_Extension1=0;
  gBasicCallHandling_Extension2=0;

  //MPCall_CC_Handling
  gMPSwap_status=0;
  gCCJoin_status=0;
  gMPRACAWC_status=0;
  gMPRAllCAWC_status=0;
  gMPCHAWC_status=0;
  gMPSWCOH_status=0;
  gMPCall_CC_Handling_AsgId       =0;
  gMPCall_CC_Handling_CallFunction=0;
  gMPCall_CC_Handling_Result      =0;
  gMPCall_CC_Handling_Extension1  =0;
  gMPCall_CC_Handling_Extension2  =0;

  //Array CombinedNumbers
  gCombinedNumbers_ASGID    =0;
  gCombinedNumbers_TAID     =0;
  gCombinedNumbers_Extension=0;
  gCombinedNumbers_TotalNumListElements =0;
  gCombinedNumbers_sum                  =0;
  for(j=0; j<TEL_COMBINEDNUMBERS_ENTRIES; j++)
  {
    gCombinedNumbers_ListEntryValidInformation[j] =0;
    gCombinedNumbers_Pos[j]                       =0;
    for(i=0;i<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;i++)
      gCombinedNumbers_PbName[j][i] =0;
    gCombinedNumbers_NumberType[j]  =0;
    gCombinedNumbers_CallMode[j]    =TEL_COMBINEDNUMBERS_UNKNOWNCALL;
    for(i=0;i<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;i++)
      gCombinedNumbers_TelNumber[j][i] =0;
    gCombinedNumbers_day[j]     =0;
    gCombinedNumbers_month[j]   =0;
    gCombinedNumbers_year[j]    =0;
    gCombinedNumbers_hour[j]    =0;
    gCombinedNumbers_minute[j]  =0;
    gCombinedNumbers_second[j]  =0;
    gCombinedNumbers_Picture_Reference[j]  =0;
  }
  for(i=0; i<TEL_FILENAME_SIZE; i++)
    gCombinedNumbers_CSV_filename[i] =0;
  putvalue(env_FSG_CN_ASGID, gCombinedNumbers_ASGID);
  putvalue(env_FSG_CN_TAID, gCombinedNumbers_TAID);
  putvalue(env_FSG_CN_TotalNumLE, gCombinedNumbers_TotalNumListElements);
  putvalue(env_FSG_CN_AH_shift, FALSE);
  putvalue(env_FSG_CN_AH_dir, FORWARD);
  putvalue(env_FSG_CN_AH_POS, TRUE);
  putvalue(env_FSG_CN_AH_IS, TRUE);
  putvalue(env_FSG_CN_AH_RA, 0);
  putvalue(env_FSG_CN_AH_start, 0);
  putvalue(env_FSG_CN_AH_elements, 3);
  putvalue(env_FSG_CN_DataSource, 0);
  putvalue(env_FSG_CN_CSVPath, empty_string);
  putvalue(env_FSG_CN_DataSource_result, empty_string);
  putvalue(env_FSG_CN_DataSource_file, empty_string);
  putvalue(env_FSG_CN_CA_switch, FALSE);
  putvalue(env_FSG_CN_SetGetArray_behaviour, TRUE);

  //Array Picture
  gPicture_ASGID    =0;
  gPicture_TAID     =0;
  gPicture_TotalNumListElements =0;
  gPicture_sum                  =0;
  for(j=0; j<TEL_PICTURE_ENTRIES; j++)
  {
    gPicture_ListEntryValidInformation[j] =0;
    gPicture_Pos[j]                       =0;
    for(i=0;i<TEL_PICTURE_IPADDRESS_LENGTH;i++)
      gPicture_IpAddress[j][i] =0;
    gPicture_Type[j]  =0;
    gPicture_CallId[j]=0;
    for(i=0;i<TEL_PICTURE_URI_LENGTH;i++)
      gPicture_URI[j][i] =0;
    gPicture_TcpPort[j]     =0;
  }
  for(i=0; i<TEL_FILENAME_SIZE; i++)
    gPicture_CSV_filename[i] =0;
  putvalue(env_FSG2_CallPic_AsgID, gPicture_ASGID);
  putvalue(env_FSG2_CallPic_TAID, gPicture_TAID);
  putvalue(env_FSG2_CallPic_TNLE, gPicture_TotalNumListElements);
  putvalue(env_FSG2_CallPic_Shift, FALSE);
  putvalue(env_FSG2_CallPic_Direction, FORWARD);
  putvalue(env_FSG2_CallPic_TransPos, TRUE);
  putvalue(env_FSG2_CallPic_IndexSize, TRUE);
  putvalue(env_FSG2_CallPic_RecAdr, 0);
  putvalue(env_FSG2_CallPic_Start, 0);
  putvalue(env_FSG2_CallPic_Elements, 3);
  putvalue(env_FSG2_CallPic_DataSource, 0);
  putvalue(env_FSG2_CallPic_CSVPath, empty_string);
  putvalue(env_FSG2_CallPic_DataSource_res, empty_string);
  putvalue(env_FSG2_CallPic_DataSource_file, empty_string);
  putvalue(env_FSG2_CallPic_CA_switch, FALSE);
  putvalue(env_FSG2_CallPic_SetGetArray_beh, TRUE);
}

void CombinedNumbers_init_static()
{
  byte j, i, CombinedNumbersLine;

  //clear
  CombinedNumbersLine   =0;
  gCombinedNumbers_sum  =0;

  for(j=0;j<TEL_COMBINEDNUMBERS_ENTRIES;j++)
  {
    gCombinedNumbers_Pos[j]                       =0;
    strncpy(gCombinedNumbers_PbName[j],"",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
    gCombinedNumbers_CallMode[j]                  =0;
    strncpy(gCombinedNumbers_TelNumber[j],"",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    gCombinedNumbers_day[j]     =0;
    gCombinedNumbers_month[j]   =0;
    gCombinedNumbers_year[j]    =0;
    gCombinedNumbers_hour[j]    =0;
    gCombinedNumbers_minute[j]  =0;
    gCombinedNumbers_second[j]  =0;
    gCombinedNumbers_Picture_Reference[j]=0;
    gCombinedNumbers_ListEntryValidInformation[j] =0;
  }

  //entry 0
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x01;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_0",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = FAX;
  gCombinedNumbers_CallMode [CombinedNumbersLine] = TEL_COMBINEDNUMBERS_MISSEDCALL;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_0",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =1;
  gCombinedNumbers_month [CombinedNumbersLine]    =2;
  gCombinedNumbers_year [CombinedNumbersLine]     =50;
  gCombinedNumbers_hour [CombinedNumbersLine]     =21;
  gCombinedNumbers_minute [CombinedNumbersLine]   =4;
  gCombinedNumbers_second [CombinedNumbersLine]   =9;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=1;
  CombinedNumbersLine++;

  //entry 1
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x02;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_1",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_RECEIVEDCALL;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_1",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =0xFF;
  gCombinedNumbers_month [CombinedNumbersLine]    =0xFF;
  gCombinedNumbers_year [CombinedNumbersLine]     =0xFF;
  gCombinedNumbers_hour [CombinedNumbersLine]     =0xFF;
  gCombinedNumbers_minute [CombinedNumbersLine]   =0xFF;
  gCombinedNumbers_second [CombinedNumbersLine]   =0xFF;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=0;
  CombinedNumbersLine++;

  //entry 2
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x03;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_2",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MAIN_OFFICE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_DIALEDNUMBER;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_2",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =5;
  gCombinedNumbers_month [CombinedNumbersLine]    =4;
  gCombinedNumbers_year [CombinedNumbersLine]     =2;
  gCombinedNumbers_hour [CombinedNumbersLine]     =9;
  gCombinedNumbers_minute [CombinedNumbersLine]   =34;
  gCombinedNumbers_second [CombinedNumbersLine]   =54;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=2;
  CombinedNumbersLine++;

  //entry 3
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x04;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_3",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_UNKNOWNCALL;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_3",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =30;
  gCombinedNumbers_month [CombinedNumbersLine]    =5;
  gCombinedNumbers_year [CombinedNumbersLine]     =84;
  gCombinedNumbers_hour [CombinedNumbersLine]     =5;
  gCombinedNumbers_minute [CombinedNumbersLine]   =0;
  gCombinedNumbers_second [CombinedNumbersLine]   =0;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=3;
  CombinedNumbersLine++;

  //entry 4
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x05;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_4",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_MISSEDCALL;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_4",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =31;
  gCombinedNumbers_month [CombinedNumbersLine]    =7;
  gCombinedNumbers_year [CombinedNumbersLine]     =83;
  gCombinedNumbers_hour [CombinedNumbersLine]     =10;
  gCombinedNumbers_minute [CombinedNumbersLine]   =15;
  gCombinedNumbers_second [CombinedNumbersLine]   =1;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=0;
  CombinedNumbersLine++;

  //entry 5
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x06;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_5",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_UNKNOWNCALL;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_5",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =9;
  gCombinedNumbers_month [CombinedNumbersLine]    =11;
  gCombinedNumbers_year [CombinedNumbersLine]     =4;
  gCombinedNumbers_hour [CombinedNumbersLine]     =8;
  gCombinedNumbers_minute [CombinedNumbersLine]   =7;
  gCombinedNumbers_second [CombinedNumbersLine]   =33;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=1;
  CombinedNumbersLine++;

  //entry 6
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x07;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_6",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_RECEIVEDCALL;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_6",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =6;
  gCombinedNumbers_month [CombinedNumbersLine]    =5;
  gCombinedNumbers_year [CombinedNumbersLine]     =30;
  gCombinedNumbers_hour [CombinedNumbersLine]     =18;
  gCombinedNumbers_minute [CombinedNumbersLine]   =14;
  gCombinedNumbers_second [CombinedNumbersLine]   =45;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=2;
  CombinedNumbersLine++;

  //entry 7
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x08;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_7",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_DIALEDNUMBER;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_7",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =21;
  gCombinedNumbers_month [CombinedNumbersLine]    =1;
  gCombinedNumbers_year [CombinedNumbersLine]     =31;
  gCombinedNumbers_hour [CombinedNumbersLine]     =23;
  gCombinedNumbers_minute [CombinedNumbersLine]   =29;
  gCombinedNumbers_second [CombinedNumbersLine]   =30;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=3;
  CombinedNumbersLine++;

  //entry 8
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x09;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_8",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_RECEIVEDCALL;
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_8",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =16;
  gCombinedNumbers_month [CombinedNumbersLine]    =2;
  gCombinedNumbers_year [CombinedNumbersLine]     =8;
  gCombinedNumbers_hour [CombinedNumbersLine]     =15;
  gCombinedNumbers_minute [CombinedNumbersLine]   =59;
  gCombinedNumbers_second [CombinedNumbersLine]   =59;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=0;
  CombinedNumbersLine++;

  //entry 9
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x0A;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_9",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_MISSEDCALL;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_9",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =31;
  gCombinedNumbers_month [CombinedNumbersLine]    =12;
  gCombinedNumbers_year [CombinedNumbersLine]     =99;
  gCombinedNumbers_hour [CombinedNumbersLine]     =23;
  gCombinedNumbers_minute [CombinedNumbersLine]   =59;
  gCombinedNumbers_second [CombinedNumbersLine]   =59;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=1;
  CombinedNumbersLine++;

  //entry 10
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x0B;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_10",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_RECEIVEDCALL;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_10",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =1;
  gCombinedNumbers_month [CombinedNumbersLine]    =1;
  gCombinedNumbers_year [CombinedNumbersLine]     =0xFF;
  gCombinedNumbers_hour [CombinedNumbersLine]     =0;
  gCombinedNumbers_minute [CombinedNumbersLine]   =0;
  gCombinedNumbers_second [CombinedNumbersLine]   =0;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=2;
  CombinedNumbersLine++;

  //entry 11
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x0C;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_11",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_UNKNOWNCALL;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_11",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =11;
  gCombinedNumbers_month [CombinedNumbersLine]    =11;
  gCombinedNumbers_year [CombinedNumbersLine]     =11;
  gCombinedNumbers_hour [CombinedNumbersLine]     =11;
  gCombinedNumbers_minute [CombinedNumbersLine]   =11;
  gCombinedNumbers_second [CombinedNumbersLine]   =11;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=3;
  CombinedNumbersLine++;

  //entry 12
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x0D;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_12",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_MISSEDCALL;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_12",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =1;
  gCombinedNumbers_month [CombinedNumbersLine]    =1;
  gCombinedNumbers_year [CombinedNumbersLine]     =0;
  gCombinedNumbers_hour [CombinedNumbersLine]     =0;
  gCombinedNumbers_minute [CombinedNumbersLine]   =0;
  gCombinedNumbers_second [CombinedNumbersLine]   =0;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=0;
  CombinedNumbersLine++;

  //entry 13
  gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
  gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x0E;
  strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_13",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
  gCombinedNumbers_NumberType[CombinedNumbersLine] = MOBILE;
  gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_DIALEDNUMBER;
  strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_13",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
  gCombinedNumbers_day [CombinedNumbersLine]      =31;
  gCombinedNumbers_month [CombinedNumbersLine]    =2;
  gCombinedNumbers_year [CombinedNumbersLine]     =20;
  gCombinedNumbers_hour [CombinedNumbersLine]     =8;
  gCombinedNumbers_minute [CombinedNumbersLine]   =9;
  gCombinedNumbers_second [CombinedNumbersLine]   =10;
  gCombinedNumbers_Picture_Reference[CombinedNumbersLine]=1;
  CombinedNumbersLine++;

  gCombinedNumbers_sum                    =CombinedNumbersLine;
  gCombinedNumbers_TotalNumListElements   =gCombinedNumbers_sum;

  putvalue(env_FSG_CN_TotalNumLE, gCombinedNumbers_TotalNumListElements);
}

void Picture_init_static()
{
  byte j, i, PictureLine;

  //clear
  PictureLine   =0;
  gPicture_sum  =0;

  for(j=0;j<TEL_PICTURE_ENTRIES;j++)
  {
    gPicture_Pos[j]                       =0;
    strncpy(gPicture_IpAddress[j],"",TEL_PICTURE_IPADDRESS_LENGTH);
    gPicture_CallId[j]                  =0;
    gPicture_Type[j]                    =0;
    gPicture_TcpPort[j]                 =0;
    strncpy(gPicture_URI[j],"",TEL_PICTURE_URI_LENGTH);
    gPicture_ListEntryValidInformation[j] =0;
  }

  //entry 0
  gPicture_ListEntryValidInformation[PictureLine]     =TRUE;
  gPicture_Pos [PictureLine]                          =0x01;
  strncpy(gPicture_IpAddress [PictureLine], "IPaddress_0",TEL_PICTURE_IPADDRESS_LENGTH);
  gPicture_Type[PictureLine]                          = 1;
  gPicture_CallId [PictureLine]                       = 1;
  strncpy(gPicture_URI [PictureLine], "Uri_0",TEL_PICTURE_URI_LENGTH);
  gPicture_TcpPort [PictureLine]                      =1;
  PictureLine++;

  //entry 1
  gPicture_ListEntryValidInformation[PictureLine]     =TRUE;
  gPicture_Pos [PictureLine]                          =0x02;
  strncpy(gPicture_IpAddress [PictureLine], "IPaddress_1",TEL_PICTURE_IPADDRESS_LENGTH);
  gPicture_Type[PictureLine]                          = 2;
  gPicture_CallId [PictureLine]                       = 2;
  strncpy(gPicture_URI [PictureLine], "Uri_1",TEL_PICTURE_URI_LENGTH);
  gPicture_TcpPort [PictureLine]                      =80;
  PictureLine++;

  //entry 2
  gPicture_ListEntryValidInformation[PictureLine]     =TRUE;
  gPicture_Pos [PictureLine]                          =0x03;
  strncpy(gPicture_IpAddress [PictureLine], "IPaddress_2",TEL_PICTURE_IPADDRESS_LENGTH);
  gPicture_Type[PictureLine]                          = 3;
  gPicture_CallId [PictureLine]                       = 3;
  strncpy(gPicture_URI [PictureLine], "Uri_2",TEL_PICTURE_URI_LENGTH);
  gPicture_TcpPort [PictureLine]                      =0x1234;
  PictureLine++;

  //entry 3
  gPicture_ListEntryValidInformation[PictureLine]     =TRUE;
  gPicture_Pos [PictureLine]                          =0x04;
  strncpy(gPicture_IpAddress [PictureLine], "IPaddress_3",TEL_PICTURE_IPADDRESS_LENGTH);
  gPicture_Type[PictureLine]                          = 4;
  gPicture_CallId [PictureLine]                       = 4;
  strncpy(gPicture_URI [PictureLine], "Uri_3",TEL_PICTURE_URI_LENGTH);
  gPicture_TcpPort [PictureLine]                      =60;
  PictureLine++;

  gPicture_sum                    =PictureLine;
  gPicture_TotalNumListElements   =gPicture_sum;

  putvalue(env_FSG_CN_TotalNumLE, gCombinedNumbers_TotalNumListElements);
}

void BAP_Set_Cache () //initialize BAP-FSG-Cache
{
  dword Cache_Request_Header[6];          //Cache header for DLL
  byte Cache_Request_Data[BAP_buffer_size];   //Cache data for DLL
  byte i, Offset, temp;
  int length_name, length_number;
  Offset=0;

  //-- Property FunctionList -------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;    //LSG-ID
  Cache_Request_Header[1] = FctID_FunctionList; //Fct-ID
  Cache_Request_Header[2] = 0;                  //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;   //data-type
  Cache_Request_Header[4] = 8;                  //length
  Cache_Request_Header[5] = 0;                  //ignored

  Cache_Request_Data[0]=gFunctionList0;
  Cache_Request_Data[1]=gFunctionList1;
  Cache_Request_Data[2]=gFunctionList2;
  Cache_Request_Data[3]=gFunctionList3;
  Cache_Request_Data[4]=gFunctionList4;
  Cache_Request_Data[5]=gFunctionList5;
  Cache_Request_Data[6]=gFunctionList6;
  Cache_Request_Data[7]=gFunctionList7;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init FunctionList errorcode: %d", temp);

  //-- Property FSG_Control ----------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;  //LSG-ID
  Cache_Request_Header[1] = FctID_FSG_Control;//Fct-ID
  Cache_Request_Header[2] = 0;                //ignored
  Cache_Request_Header[3] = Bap_ByteSequence; //data-type
  Cache_Request_Header[4] = 6;                //length
  Cache_Request_Header[5] = 0;                //ignored

  Cache_Request_Data[0]=gFsgControl_Extension1;
  Cache_Request_Data[1]=gFsgControl_Extension2;
  Cache_Request_Data[2]=gFsgControl_Extension3;
  Cache_Request_Data[3]=gFsgControl_Extension4;
  Cache_Request_Data[4]=gFsgControl_Extension5;
  Cache_Request_Data[5]=gFsgControl_Extension6;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init FSG_Control errorcode: %d", temp);

  //-- Property FSG_Setup ----------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;  //LSG-ID
  Cache_Request_Header[1] = FctID_FSG_Setup;  //Fct-ID
  Cache_Request_Header[2] = 0;                //ignored
  Cache_Request_Header[3] = Bap_ByteSequence; //data-type
  Cache_Request_Header[4] = 6;                //length
  Cache_Request_Header[5] = 0;                //ignored

  Cache_Request_Data[0]=gPrivacyMode;
  Cache_Request_Data[1]=gFsgSetup_FunctionProtection;
  Cache_Request_Data[2]=((gFsgSetup_WebAppState*0x10) & 0xF0)+(gFsgSetup_Extension2 & 0x0F);
  Cache_Request_Data[3]=gFsgSetup_Extension2;
  Cache_Request_Data[4]=gFsgSetup_Extension3;
  Cache_Request_Data[5]=gFsgSetup_Extension4;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init FSG_Setup errorcode: %d", temp);


  //-- Property FSG_OperationState --------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;          //LSG-ID
  Cache_Request_Header[1] = FctID_FSG_OperationState; //Fct-ID
  Cache_Request_Header[2] = 0;                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;         //data-type
  Cache_Request_Header[4] = 6;                        //length
  Cache_Request_Header[5] = 0;                        //ignored

  Cache_Request_Data[0]=gOP_State;
  Cache_Request_Data[1]=gFsgOperationState_Extension1;
  Cache_Request_Data[2]=gFsgOperationState_Extension2;
  Cache_Request_Data[3]=gFsgOperationState_Extension3;
  Cache_Request_Data[4]=gFsgOperationState_Extension4;
  Cache_Request_Data[5]=gFsgOperationState_Extension5;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init FSG_OperationState errorcode: %d", temp);


  //-- Property MobileServiceSupport -------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;            //LSG-ID
  Cache_Request_Header[1] = FctID_MobileServiceSupport; //Fct-ID
  Cache_Request_Header[2] = 0;                          //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;           //data-type
  Cache_Request_Header[4] = 8;                          //length
  Cache_Request_Header[5] = 0;                          //ignored

  Cache_Request_Data[0]=gMobilServiceSupport0;
  Cache_Request_Data[1]=gMobilServiceSupport1;
  Cache_Request_Data[2]=gMobilServiceSupport2;
  Cache_Request_Data[3]=gMobilServiceSupport3;
  Cache_Request_Data[4]=gMobilServiceSupport4;
  Cache_Request_Data[5]=gMobilServiceSupport5;
  Cache_Request_Data[6]=gMobilServiceSupport6;
  Cache_Request_Data[7]=gMobilServiceSupport7;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init MobilServiceSupport errorcode: %d", temp);

  //-- Property DeviceConnectionState -----------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;            //LSG-ID
  Cache_Request_Header[1] = FctID_DeviceConnectionState;//Fct-ID
  Cache_Request_Header[2] = 0;                          //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;           //data-type
  Cache_Request_Header[4] = 11;                         //length
  Cache_Request_Header[5] = 0;                          //ignored

  Cache_Request_Data[0]=gPhoneCharacteristics;
  Cache_Request_Data[1]=gMobileConnectionType;
  Cache_Request_Data[2]=gMobileConnectionTypeAttributes;
  Cache_Request_Data[3]=gTel_State;
  Cache_Request_Data[4]=gLockState;
  Cache_Request_Data[5]=gDeviceConnectionState_Extension1;
  Cache_Request_Data[6]=gDeviceConnectionState_Extension2;
  Cache_Request_Data[7]=gDeviceConnectionState_Extension3;
  Cache_Request_Data[8]=gDeviceConnectionState_Extension4;
  Cache_Request_Data[9]=gDeviceConnectionState_Extension5;
  Cache_Request_Data[10]=gDeviceConnectionState_Extension6;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init DeviceConnectionState errorcode: %d", temp);

  //-- Property NetworkState --------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;            //LSG-ID
  Cache_Request_Header[1] = FctID_NetworkState;         //Fct-ID
  Cache_Request_Header[2] = 0;                          //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;           //data-type
  Cache_Request_Header[4] = 6;                          //length
  Cache_Request_Header[5] = 0;                          //ignored

  Cache_Request_Data[0]=gRegisterState;
  Cache_Request_Data[1]=gNetworkType;
  Cache_Request_Data[2]=gPacketDataNetworkType;
  Cache_Request_Data[3]=gSignalQuality;
  Cache_Request_Data[4]=gNetworkState_Extension1;
  Cache_Request_Data[5]=gNetworkState_Extension2;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init NetworkState errorcode: %d", temp);

  //-- Property NetworkProvider -------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;        //LSG-ID
  Cache_Request_Header[1] = FctID_NetworkProvider;  //Fct-ID
  Cache_Request_Header[2] = 0;                      //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;       //data-type
  Cache_Request_Header[4] = 2+strlen(gNetworkProviderName); //length: 1 byte gNetworkProviderState, 1 byte stringlength
  Cache_Request_Header[5] = 0;                      //ignored

  Cache_Request_Data[0]=gNetworkProviderState;
  Cache_Request_Data[1]=strlen(gNetworkProviderName);
    Offset=2;
  for(i=0;i<strlen(gNetworkProviderName);i++)
  {
    Cache_Request_Data[Offset]=gNetworkProviderName[i];
    Offset++;
  }

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init NetworkProvider errorcode: %d", temp);

  //-- Property active user ---------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;      //LSG-ID
  Cache_Request_Header[1] = FctID_ActiveUser;     //Fct-ID
  Cache_Request_Header[2] = 0;                    //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
  Cache_Request_Header[4] = 1+strlen(gUserName);  //length
  Cache_Request_Header[5] = 0;                    //ignored

  Offset=0;
  Cache_Request_Data[Offset]=strlen(gUserName);
  Offset++;
  for(i=0;i<strlen(gUserName);i++){
    Cache_Request_Data[Offset]=gUserName[i];
    Offset++;
  }

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init ActiveUser errorcode: %d", temp);

  //-- Property MobileBatteryLevel -------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;          //LSG-ID
  Cache_Request_Header[1] = FctID_MobileBatteryLevel; //Fct-ID
  Cache_Request_Header[2] = 0;                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;         //data-type
  Cache_Request_Header[4] = 6;                        //length
  Cache_Request_Header[5] = 0;                        //ignored

  Cache_Request_Data[0]=gChargeLevel;
  Cache_Request_Data[1]=((gWarningLevel*0x10) & 0xF0)+(gMobileBatteryLevel_Extension1 & 0x0F);
  Cache_Request_Data[2]=gMobileBatteryLevel_Extension2;
  Cache_Request_Data[3]=gMobileBatteryLevel_Extension3;
  Cache_Request_Data[4]=gMobileBatteryLevel_Extension4;
  Cache_Request_Data[5]=gMobileBatteryLevel_Extension5;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init MobileBatteryLevel errorcode: %d", temp);

  //-- Property CallState -------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;  //LSG-ID
  Cache_Request_Header[1] = FctID_CallState;  //Fct-ID
  Cache_Request_Header[2] = 0;                //ignored
  Cache_Request_Header[3] = Bap_ByteSequence; //data-type
  Cache_Request_Header[4] = 25;               //length
  Cache_Request_Header[5] = 0;                //ignored

  Cache_Request_Data[0]=(gCallType[0]+gCallState[0]*0x10);  //call state 0 (upper nibble) and call type 0 (lower nibble)
  Cache_Request_Data[1]=gCallOptions1[0];
  Cache_Request_Data[2]=gCallOptions2[0];
  Cache_Request_Data[3]=(gCallType[1]+gCallState[1]*0x10);
  Cache_Request_Data[4]=gCallOptions1[1];
  Cache_Request_Data[5]=gCallOptions2[1];
  Cache_Request_Data[6]=(gCallType[2]+gCallState[2]*0x10);
  Cache_Request_Data[7]=gCallOptions1[2];
  Cache_Request_Data[8]=gCallOptions2[2];
  Cache_Request_Data[9]=(gCallType[3]+gCallState[3]*0x10);
  Cache_Request_Data[10]=gCallOptions1[3];
  Cache_Request_Data[11]=gCallOptions2[3];
  Cache_Request_Data[12]=(gCallType[4]+gCallState[4]*0x10);
  Cache_Request_Data[13]=gCallOptions1[4];
  Cache_Request_Data[14]=gCallOptions2[4];
  Cache_Request_Data[15]=(gCallType[5]+gCallState[5]*0x10);
  Cache_Request_Data[16]=gCallOptions1[5];
  Cache_Request_Data[17]=gCallOptions2[5];
  Cache_Request_Data[18]=(gCallType[6]+gCallState[6]*0x10);
  Cache_Request_Data[19]=gCallOptions1[6];
  Cache_Request_Data[20]=gCallOptions2[6];
  Cache_Request_Data[21]=gCallOutgoingDiverted_eCallConfirmationPending[0];                               //bit 0
  Cache_Request_Data[21]=Cache_Request_Data[21]+gCallOutgoingDiverted_eCallConfirmationPending[1]*0x02;   //bit 1
  Cache_Request_Data[21]=Cache_Request_Data[21]+gCallOutgoingDiverted_eCallConfirmationPending[2]*0x04;   //bit 2
  Cache_Request_Data[21]=Cache_Request_Data[21]+gCallOutgoingDiverted_eCallConfirmationPending[3]*0x08;   //bit 3
  Cache_Request_Data[21]=Cache_Request_Data[21]+gCallOutgoingDiverted_eCallConfirmationPending[4]*0x10;   //bit 4
  Cache_Request_Data[21]=Cache_Request_Data[21]+gCallOutgoingDiverted_eCallConfirmationPending[5]*0x20;   //bit 5
  Cache_Request_Data[21]=Cache_Request_Data[21]+gCallOutgoingDiverted_eCallConfirmationPending[6]*0x40;   //bit 6
  Cache_Request_Data[21]=Cache_Request_Data[21]+gCallOutgoingDiverted_eCallConfirmationPending[7]*0x80;   //bit 7
  Cache_Request_Data[22]=gDisconnectReason;
  Cache_Request_Data[23]=gCallState_Extension1;
  Cache_Request_Data[24]=gCallState_Extension2;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init CallState errorcode: %d", temp);

  //-- Property CallInfo -------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;  //LSG-ID
  Cache_Request_Header[1] = FctID_CallInfo;   //Fct-ID
  Cache_Request_Header[2] = 0;                //ignored
  Cache_Request_Header[3] = Bap_ByteSequence; //data-type
  Cache_Request_Header[4] = 21+strlen(gCallInfo_PbName[0])+strlen(gCallInfo_TelNumber[0])
                              +strlen(gCallInfo_PbName[1])+strlen(gCallInfo_TelNumber[1])
                              +strlen(gCallInfo_PbName[2])+strlen(gCallInfo_TelNumber[2])
                              +strlen(gCallInfo_PbName[3])+strlen(gCallInfo_TelNumber[3])
                              +strlen(gCallInfo_PbName[4])+strlen(gCallInfo_TelNumber[4])
                              +strlen(gCallInfo_PbName[5])+strlen(gCallInfo_TelNumber[5])
                              +strlen(gCallInfo_PbName[6])+strlen(gCallInfo_TelNumber[6]);
                              //length: 2x7 byte stringlength + 7 byte categroy = 21 byte
  Cache_Request_Header[5] = 0;                //ignored

  Cache_Request_Data[0]=strlen(gCallInfo_PbName[0]);
  Offset=1;
  for(i=0;i<strlen(gCallInfo_PbName[0]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_PbName[0][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=strlen(gCallInfo_TelNumber[0]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_TelNumber[0]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_TelNumber[0][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=gCallInfo_Category[0];
  Offset++;
  //*************************************************
  //*************************************************
  Cache_Request_Data[Offset]=strlen(gCallInfo_PbName[1]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_PbName[1]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_PbName[1][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=strlen(gCallInfo_TelNumber[1]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_TelNumber[1]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_TelNumber[1][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=gCallInfo_Category[1];
  Offset++;
  //*************************************************
  //*************************************************
  Cache_Request_Data[Offset]=strlen(gCallInfo_PbName[2]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_PbName[2]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_PbName[2][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=strlen(gCallInfo_TelNumber[2]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_TelNumber[2]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_TelNumber[2][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=gCallInfo_Category[2];
  Offset++;
  //*************************************************
  //*************************************************
  Cache_Request_Data[Offset]=strlen(gCallInfo_PbName[3]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_PbName[3]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_PbName[3][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=strlen(gCallInfo_TelNumber[3]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_TelNumber[3]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_TelNumber[3][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=gCallInfo_Category[3];
  Offset++;
  //*************************************************
  //*************************************************
  Cache_Request_Data[Offset]=strlen(gCallInfo_PbName[4]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_PbName[4]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_PbName[4][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=strlen(gCallInfo_TelNumber[4]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_TelNumber[4]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_TelNumber[4][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=gCallInfo_Category[4];
  Offset++;
  //*************************************************
  //*************************************************
  Cache_Request_Data[Offset]=strlen(gCallInfo_PbName[5]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_PbName[5]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_PbName[5][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=strlen(gCallInfo_TelNumber[5]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_TelNumber[5]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_TelNumber[5][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=gCallInfo_Category[5];
  Offset++;
  //*************************************************
  //*************************************************
  Cache_Request_Data[Offset]=strlen(gCallInfo_PbName[6]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_PbName[6]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_PbName[6][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=strlen(gCallInfo_TelNumber[6]);
  Offset++;
  for(i=0;i<strlen(gCallInfo_TelNumber[6]);i++)
  {
    Cache_Request_Data[Offset]=gCallInfo_TelNumber[6][i];
    Offset++;
  }
  Cache_Request_Data[Offset]=gCallInfo_Category[6];
  Offset++;
  //*************************************************

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init CallInfo errorcode: %d", temp);

  //-- Property CallDuration -----------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;        //LSG-ID
  Cache_Request_Header[1] = FctID_CallDuration;     //Fct-ID
  Cache_Request_Header[2] = 0;                      //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;       //data-type
  Cache_Request_Header[4] = 6;                      //length
  Cache_Request_Header[5] = 0;                      //ignored

  Cache_Request_Data[0]=gCallDuration_Relation1[0];                           //bit0
  Cache_Request_Data[0]=Cache_Request_Data[0]+gCallDuration_Relation1[1]*0x02;//bit1
  Cache_Request_Data[0]=Cache_Request_Data[0]+gCallDuration_Relation1[2]*0x04;//bit2
  Cache_Request_Data[0]=Cache_Request_Data[0]+gCallDuration_Relation1[3]*0x08;//bit3
  Cache_Request_Data[0]=Cache_Request_Data[0]+gCallDuration_Relation1[4]*0x10;//bit4
  Cache_Request_Data[0]=Cache_Request_Data[0]+gCallDuration_Relation1[5]*0x20;//bit5
  Cache_Request_Data[0]=Cache_Request_Data[0]+gCallDuration_Relation1[6]*0x40;//bit6
  Cache_Request_Data[1]=gCallDuration_1 & 0xFF;
  Cache_Request_Data[2]=(gCallDuration_1 / 0x10) & 0xFF;
  Cache_Request_Data[3]=gCallDuration_Relation2[0];                           //bit0
  Cache_Request_Data[3]=Cache_Request_Data[3]+gCallDuration_Relation2[1]*0x02;//bit1
  Cache_Request_Data[3]=Cache_Request_Data[3]+gCallDuration_Relation2[2]*0x04;//bit2
  Cache_Request_Data[3]=Cache_Request_Data[3]+gCallDuration_Relation2[3]*0x08;//bit3
  Cache_Request_Data[3]=Cache_Request_Data[3]+gCallDuration_Relation2[4]*0x10;//bit4
  Cache_Request_Data[3]=Cache_Request_Data[3]+gCallDuration_Relation2[5]*0x20;//bit5
  Cache_Request_Data[3]=Cache_Request_Data[3]+gCallDuration_Relation2[6]*0x40;//bit6
  Cache_Request_Data[4]=gCallDuration_2 & 0xFF;
  Cache_Request_Data[5]=(gCallDuration_2 / 0x10) & 0xFF;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init CallDuration errorcode: %d", temp);

  //-- Property AudioMuteOnOff ------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;      //LSG-ID
  Cache_Request_Header[1] = FctID_AudioMuteOnOff;  //Fct-ID
  Cache_Request_Header[2] = 0;                    //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
  Cache_Request_Header[4] = 6;                    //length
  Cache_Request_Header[5] = 0;                    //ignored

  Cache_Request_Data[0]=gAudioControl;
  Cache_Request_Data[1]=gFunctionSupport;
  Cache_Request_Data[2]=gAudioMuteOnOff_Extension1;
  Cache_Request_Data[3]=gAudioMuteOnOff_Extension2;
  Cache_Request_Data[4]=gAudioMuteOnOff_Extension3;
  Cache_Request_Data[5]=gAudioMuteOnOff_Extension4;

  temp=0;
  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init AudioMuteOnOff errorcode: %d", temp);

  //-- Property MissedCallIndication -------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;            //LSG-ID
  Cache_Request_Header[1] = FctID_MissedCallIndication; //Fct-ID
  Cache_Request_Header[2] = 0;                          //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;           //data-type
  Cache_Request_Header[4] = 6;                          //length
  Cache_Request_Header[5] = 0;                          //ignored

  //Data
  Cache_Request_Data[0]=gMissedCalls & 0x00ff;    //Lowbyte of MissedCall
  Cache_Request_Data[1]=(gMissedCalls / 0x10) & 0xff;    //Highbyte of MissedCall
  Cache_Request_Data[2]=gMissedCallIndication_Extension1;
  Cache_Request_Data[3]=gMissedCallIndication_Extension2;
  Cache_Request_Data[4]=gMissedCallIndication_Extension3;
  Cache_Request_Data[5]=gMissedCallIndication_Extension4;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init MissedCallIndication errorcode: %d", temp);

  //-- Property AutomaticRedial -------------------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;        //LSG-ID
  Cache_Request_Header[1] = FctID_AutomaticRedial;  //Fct-ID
  Cache_Request_Header[2] = 0;                      //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;       //data-type
  Cache_Request_Header[4] = 6;                      //length
  Cache_Request_Header[5] = 0;                      //ignored

  Cache_Request_Data[0]=gAutomaticRedialState;
  Cache_Request_Data[1]=gAutomaticRedial_Extension1;
  Cache_Request_Data[2]=gAutomaticRedial_Extension2;
  Cache_Request_Data[3]=gAutomaticRedial_Extension3;
  Cache_Request_Data[4]=gAutomaticRedial_Extension4;
  Cache_Request_Data[5]=gAutomaticRedial_Extension5;

  temp=Bap180_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
  if(temp!=0)
    write("Telephone: BAP_Init AutomaticRedial errorcode: %d", temp);
}

void shutdown_FSG_Telephone ()
{
  int i, j;
  char empty_string [3];
  byte empty_data[3];

  //init local variables
  for(i=0;i<3;i++)
  {
    empty_string[i]=0;
    empty_data[i] = 0;
  }
  //********************

  //Timer
  canceltimer(acceptcallTimer);
  canceltimer(agetimer);
  canceltimer(CallHoldTimer);
  canceltimer(ResumeCallTimer);
  canceltimer(CCJoinTimer);
  canceltimer(checknetworktimer);
  canceltimer(disconnectingtimer);
  canceltimer(disconnectingtimer2);
  canceltimer(MPCHAWCTimer);
  canceltimer(MPRACAWCTimer);
  canceltimer(MPRAllCAWCTimer);
  canceltimer(MPSwapTimer);
  canceltimer(nonetworktimer);
  canceltimer(Powerontimer);
  canceltimer(signalqualitytimer);
  canceltimer(TaskTimer);

  //BAP-DLL
  Bap180_Shutdown(NODE_INDEX,LSGID_Telephone);

  //Panel-values
  //IncomingCallnumber
  putvalue(env_FSG_incomingcallstring, empty_string);

  //FSG_Control
  //...

  //FSG_Setup
  //...

  //FSG_OperationState
  //...

  //MobileServiceSupport
  //...

  //DeviceConnectionState
  putvalue(env_FSG_SIMCardReader, 0);
  putvalue(env_FSG_CableConnection, 0);
  putvalue(env_FSG_HFPConnection, 0);
  putvalue(env_FSG_RSAPConnection, 0);
  putvalue(env_FSG_AppleCarPlay, 0);
  putvalue(env_FSG_AndroidAuto, 0);
  putvalue(env_FSG_BaiduCarLife, 0);
  putvalue(env_FSG_MobileConnectionType, 0);
  gTel_State=PhoneInitilisation;
  putvalue(env_FSG_LockState,0x07);

  //NetworkState
  putvalue(env_FSG_SIMstatus, 0);
  gRegisterState=notregisteredandnotsearching;
  putvalue(env_FSG_SignalQuality, 0);
  putvalue(env_FSG_SignalQuality_Mode, 2);

  //NetworkProvider
  putvalue(env_FSG_NetworkProviderState, 0);

  //active user
  putvalue(env_FSG_UserName, empty_string);

  //MobileBatteryLevel
  putvalue(env_FSG_MBL_ChargeLevel,0xFF);
  putvalue(env_FSG_MBL_WarningLevel_Bit0,0xFF);

  //CallState
  putvalue(env_FSG_CallState_CallID_0, empty_string);
  putvalue(env_FSG_CallState_CallID_1, empty_string);
  putvalue(env_FSG_CallState_CallID_2, empty_string);
  putvalue(env_FSG_CallState_CallID_3, empty_string);
  putvalue(env_FSG_CallState_CallID_4, empty_string);
  putvalue(env_FSG_CallState_CallID_5, empty_string);
  putvalue(env_FSG_CallState_CallID_6, empty_string);
  putvalue(env_FSG_CallType_CallID_0, empty_string);
  putvalue(env_FSG_CallType_CallID_1, empty_string);
  putvalue(env_FSG_CallType_CallID_2, empty_string);
  putvalue(env_FSG_CallType_CallID_3, empty_string);
  putvalue(env_FSG_CallType_CallID_4, empty_string);
  putvalue(env_FSG_CallType_CallID_5, empty_string);
  putvalue(env_FSG_CallType_CallID_6, empty_string);
  putvalue(env_FSG_CallActivity, empty_string);
  putvalue(env_FSG_CallState_CallDivert_0, empty_string);
  putvalue(env_FSG_CallState_CallDivert_1, empty_string);
  putvalue(env_FSG_CallState_CallDivert_2, empty_string);
  putvalue(env_FSG_CallState_CallDivert_3, empty_string);
  putvalue(env_FSG_CallState_CallDivert_4, empty_string);
  putvalue(env_FSG_CallState_CallDivert_5, empty_string);
  putvalue(env_FSG_CallState_CallDivert_6, empty_string);
  putvalue(env_FSG_CallState_CallID_0_set,idle);
  putvalue(env_FSG_CallState_CallID_1_set,idle);
  putvalue(env_FSG_CallState_CallID_2_set,idle);
  putvalue(env_FSG_CallState_CallID_3_set,idle);
  putvalue(env_FSG_CallState_CallID_4_set,idle);
  putvalue(env_FSG_CallState_CallID_5_set,idle);
  putvalue(env_FSG_CallState_CallID_6_set,idle);
  putvalue(env_FSG_CallType_CallID_0_set,unknowncalltype);
  putvalue(env_FSG_CallType_CallID_1_set,unknowncalltype);
  putvalue(env_FSG_CallType_CallID_2_set,unknowncalltype);
  putvalue(env_FSG_CallType_CallID_3_set,unknowncalltype);
  putvalue(env_FSG_CallType_CallID_4_set,unknowncalltype);
  putvalue(env_FSG_CallType_CallID_5_set,unknowncalltype);
  putvalue(env_FSG_CallType_CallID_6_set,unknowncalltype);
  putvalue(env_FSG_CallState_CallOuDive_0_s, 0);
  putvalue(env_FSG_CallState_CallOuDive_1_s, 0);
  putvalue(env_FSG_CallState_CallOuDive_2_s, 0);
  putvalue(env_FSG_CallState_CallOuDive_3_s, 0);
  putvalue(env_FSG_CallState_CallOuDive_4_s, 0);
  putvalue(env_FSG_CallState_CallOuDive_5_s, 0);
  putvalue(env_FSG_CallState_CallOuDive_6_s, 0);
  putvalue(env_FSG_CallState_CallOuDive_7_s, 0);
  putvalue(env_FSG_CallState_Opt0_1_Bit0,0);
  putvalue(env_FSG_CallState_Opt0_1_Bit1,0);
  putvalue(env_FSG_CallState_Opt0_1_Bit2,0);
  putvalue(env_FSG_CallState_Opt0_1_Bit3,0);
  putvalue(env_FSG_CallState_Opt0_1_Bit4,0);
  putvalue(env_FSG_CallState_Opt0_1_Bit5,0);
  putvalue(env_FSG_CallState_Opt0_1_Bit6,0);
  putvalue(env_FSG_CallState_Opt0_1_Bit7,0);
  putvalue(env_FSG_CallState_Opt0_2_Bit0,0);
  putvalue(env_FSG_CallState_Opt0_2_Bit1,0);
  putvalue(env_FSG_CallState_Opt0_2_Bit2,0);
  putvalue(env_FSG_CallState_Opt1_1_Bit0,0);
  putvalue(env_FSG_CallState_Opt1_1_Bit1,0);
  putvalue(env_FSG_CallState_Opt1_1_Bit2,0);
  putvalue(env_FSG_CallState_Opt1_1_Bit3,0);
  putvalue(env_FSG_CallState_Opt1_1_Bit4,0);
  putvalue(env_FSG_CallState_Opt1_1_Bit5,0);
  putvalue(env_FSG_CallState_Opt1_1_Bit6,0);
  putvalue(env_FSG_CallState_Opt1_1_Bit7,0);
  putvalue(env_FSG_CallState_Opt1_2_Bit0,0);
  putvalue(env_FSG_CallState_Opt1_2_Bit1,0);
  putvalue(env_FSG_CallState_Opt1_2_Bit2,0);
  putvalue(env_FSG_CallState_Opt2_1_Bit0,0);
  putvalue(env_FSG_CallState_Opt2_1_Bit1,0);
  putvalue(env_FSG_CallState_Opt2_1_Bit2,0);
  putvalue(env_FSG_CallState_Opt2_1_Bit3,0);
  putvalue(env_FSG_CallState_Opt2_1_Bit4,0);
  putvalue(env_FSG_CallState_Opt2_1_Bit5,0);
  putvalue(env_FSG_CallState_Opt2_1_Bit6,0);
  putvalue(env_FSG_CallState_Opt2_1_Bit7,0);
  putvalue(env_FSG_CallState_Opt2_2_Bit0,0);
  putvalue(env_FSG_CallState_Opt2_2_Bit1,0);
  putvalue(env_FSG_CallState_Opt2_2_Bit2,0);
  putvalue(env_FSG_CallState_Opt3_1_Bit0,0);
  putvalue(env_FSG_CallState_Opt3_1_Bit1,0);
  putvalue(env_FSG_CallState_Opt3_1_Bit2,0);
  putvalue(env_FSG_CallState_Opt3_1_Bit3,0);
  putvalue(env_FSG_CallState_Opt3_1_Bit4,0);
  putvalue(env_FSG_CallState_Opt3_1_Bit5,0);
  putvalue(env_FSG_CallState_Opt3_1_Bit6,0);
  putvalue(env_FSG_CallState_Opt3_1_Bit7,0);
  putvalue(env_FSG_CallState_Opt3_2_Bit0,0);
  putvalue(env_FSG_CallState_Opt3_2_Bit1,0);
  putvalue(env_FSG_CallState_Opt3_2_Bit2,0);
  putvalue(env_FSG_CallState_Opt4_1_Bit0,0);
  putvalue(env_FSG_CallState_Opt4_1_Bit1,0);
  putvalue(env_FSG_CallState_Opt4_1_Bit2,0);
  putvalue(env_FSG_CallState_Opt4_1_Bit3,0);
  putvalue(env_FSG_CallState_Opt4_1_Bit4,0);
  putvalue(env_FSG_CallState_Opt4_1_Bit5,0);
  putvalue(env_FSG_CallState_Opt4_1_Bit6,0);
  putvalue(env_FSG_CallState_Opt4_1_Bit7,0);
  putvalue(env_FSG_CallState_Opt4_2_Bit0,0);
  putvalue(env_FSG_CallState_Opt4_2_Bit1,0);
  putvalue(env_FSG_CallState_Opt4_2_Bit2,0);
  putvalue(env_FSG_CallState_Opt5_1_Bit0,0);
  putvalue(env_FSG_CallState_Opt5_1_Bit1,0);
  putvalue(env_FSG_CallState_Opt5_1_Bit2,0);
  putvalue(env_FSG_CallState_Opt5_1_Bit3,0);
  putvalue(env_FSG_CallState_Opt5_1_Bit4,0);
  putvalue(env_FSG_CallState_Opt5_1_Bit5,0);
  putvalue(env_FSG_CallState_Opt5_1_Bit6,0);
  putvalue(env_FSG_CallState_Opt5_1_Bit7,0);
  putvalue(env_FSG_CallState_Opt5_2_Bit0,0);
  putvalue(env_FSG_CallState_Opt5_2_Bit1,0);
  putvalue(env_FSG_CallState_Opt5_2_Bit2,0);
  putvalue(env_FSG_CallState_Opt6_1_Bit0,0);
  putvalue(env_FSG_CallState_Opt6_1_Bit1,0);
  putvalue(env_FSG_CallState_Opt6_1_Bit2,0);
  putvalue(env_FSG_CallState_Opt6_1_Bit3,0);
  putvalue(env_FSG_CallState_Opt6_1_Bit4,0);
  putvalue(env_FSG_CallState_Opt6_1_Bit5,0);
  putvalue(env_FSG_CallState_Opt6_1_Bit6,0);
  putvalue(env_FSG_CallState_Opt6_1_Bit7,0);
  putvalue(env_FSG_CallState_Opt6_2_Bit0,0);
  putvalue(env_FSG_CallState_Opt6_2_Bit1,0);
  putvalue(env_FSG_CallState_Opt6_2_Bit2,0);
  putvalue(env_FSG_DisconnectReason, 0);

  //CallInfo
  putvalue(env_FSG_CallInfo_PbName_0, empty_string);
  putvalue(env_FSG_CallInfo_PbName_0_data, empty_data);
  putvalue(env_FSG_CallInfo_PbName_1, empty_string);
  putvalue(env_FSG_CallInfo_PbName_1_data, empty_data);
  putvalue(env_FSG_CallInfo_PbName_2, empty_string);
  putvalue(env_FSG_CallInfo_PbName_2_data, empty_data);
  putvalue(env_FSG_CallInfo_PbName_3, empty_string);
  putvalue(env_FSG_CallInfo_PbName_3_data, empty_data);
  putvalue(env_FSG_CallInfo_PbName_4, empty_string);
  putvalue(env_FSG_CallInfo_PbName_4_data, empty_data);
  putvalue(env_FSG_CallInfo_PbName_5, empty_string);
  putvalue(env_FSG_CallInfo_PbName_5_data, empty_data);
  putvalue(env_FSG_CallInfo_PbName_6, empty_string);
  putvalue(env_FSG_CallInfo_PbName_6_data, empty_data);
  putvalue(env_FSG_CallInfo_PbName_0_s,empty_string);
  putvalue(env_FSG_CallInfo_PbName_1_s,empty_string);
  putvalue(env_FSG_CallInfo_PbName_2_s,empty_string);
  putvalue(env_FSG_CallInfo_PbName_3_s,empty_string);
  putvalue(env_FSG_CallInfo_PbName_4_s,empty_string);
  putvalue(env_FSG_CallInfo_PbName_5_s,empty_string);
  putvalue(env_FSG_CallInfo_PbName_6_s,empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_0, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_1, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_2, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_3, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_4, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_5, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_6, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_0_s, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_1_s, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_2_s, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_3_s, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_4_s, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_5_s, empty_string);
  putvalue(env_FSG_CallInfo_TelNumber_6_s, empty_string);
  putvalue(env_FSG_CallInfo_Category_0_s, 0);
  putvalue(env_FSG_CallInfo_Category_1_s, 0);
  putvalue(env_FSG_CallInfo_Category_2_s, 0);
  putvalue(env_FSG_CallInfo_Category_3_s, 0);
  putvalue(env_FSG_CallInfo_Category_4_s, 0);
  putvalue(env_FSG_CallInfo_Category_5_s, 0);
  putvalue(env_FSG_CallInfo_Category_6_s, 0);

  //AudioMuteOnOff
  putvalue(env_FSG_HandsFreeOnOff, 0);
  putvalue(env_FSG_MicroMuteOnOff, 0);
  putvalue(env_FSG_RingToneMuteOnOff,0);

  //MissedCallIndication
  putvalue(env_FSG_MissedCalls, 0);

  //AutomaticRedial
  //...

  //dialnumber
  putvalue(env_FSG_dialednumber_free_busy, 2);

  //CombinedNumbers
  putvalue(env_FSG_CN_ASGID, 0);
  putvalue(env_FSG_CN_TAID, 0);
  putvalue(env_FSG_CN_TotalNumLE, 0);
  putvalue(env_FSG_CN_AH_shift, FALSE);
  putvalue(env_FSG_CN_AH_dir, FORWARD);
  putvalue(env_FSG_CN_AH_POS, FALSE);
  putvalue(env_FSG_CN_AH_IS, FALSE);
  putvalue(env_FSG_CN_AH_RA, 0);
  putvalue(env_FSG_CN_AH_start, 0);
  putvalue(env_FSG_CN_AH_elements, 0);
  putvalue(env_FSG_CN_DataSource, 0);
  putvalue(env_FSG_CN_CSVPath, empty_string);
  putvalue(env_FSG_CN_DataSource_result, empty_string);
  putvalue(env_FSG_CN_DataSource_file, empty_string);
  putvalue(env_FSG_CN_CA_switch, FALSE);

  //Picture
  //...
}

//*************************************************************************
//*****************BAP helper functions************************************
//*************************************************************************
byte get_requestbuffer_line() //function to reserve memory in request-ring-buffer
{
  int line;

  //init lokal variables
  line=0;
  //********************

  line=gwrite_requestbuffer_line;             //next free element in  ring-buffer

  if(gwrite_requestbuffer_line<(Requestbuffer_lines-1)) //last element of ring-buffer is not reached
    gwrite_requestbuffer_line++;
  else                          //last element of ring-buffer is reached
    gwrite_requestbuffer_line=0;

  return (line);                      //return position of free ring-buffer element
}

set_status_requestbuffer (dword Request_array [], int length, byte BAPDataType) //function to write data in reqest-ring-buffer
{
  int bufferline, Offset, i;

//init lokal variables
  Offset=0;
  bufferline=0;
//********************

  bufferline=get_requestbuffer_line();          //get next free position in ring-buffer

  for(i=0;i<length;i++)                 //write data in ring-buffer
    gBAP_Request[bufferline][i]=Request_array[i];

  gBAP_Requestbufffer_status[bufferline]=length;      //datalength
  gBAP_Requestbufffer_BAPDataTyp[bufferline]=BAPDataType; //BAP-data-type
    //if(gdebug)
    //    write("set_status_requestbuffer erfolgreich mit BAP Data Type: %d", BAPDataType);//bap150 - debug
}

//*************************************************************************
//*****************Helper functions****************************************
//*************************************************************************
int tel_number_valid (char tel_number [], byte length)
{
  int valid, i;

  //init local variables
  i=0;
  valid=1;
  //********************

  for (i=0; i<length; ++i)
  {
    switch(tel_number [i])
    {
      case '0': break;
      case '1': break;
      case '2': break;
      case '3': break;
      case '4': break;
      case '5': break;
      case '6': break;
      case '7': break;
      case '8': break;
      case '9': break;
      case '+':
        if(i!=0)
          valid = 0;
      break;
      case '*': break;
      case '#': break;
      case 'p': break;
      case 'w': break;
      default:
        valid = 0;
      break;
    }
  }
  return valid;
}

byte callstates_status (byte event)
{
  int i, finish, freecallstate;
  //init local variables
  finish=0;
  freecallstate=0xff;
  //********************

  switch(event)
  {
    case ringing_waiting:
      if(gCallActivity==NOCALL)
      {               //all callID's "idle"
        freecallstate=0;
        return(freecallstate);
      }
      else
      {                         //one or more callID are not "idle"
        for(i=0;finish!=1;i++)
        {               //check status of each callID
          switch(gCallState [i])
          {
            case idle:
              if(freecallstate==0xff)
                freecallstate=i;
            break;
            case dialing:
              freecallstate=0xff;           //no incoming call possible
              finish=1;               //loop finished
            break;
            case disconnecting:
              freecallstate=0xff;           //no incoming call  possible
              finish=1;               //loop finished
            break;
            default:
            break;
          }
          if (i==6 && finish==0)              //last element is reached and loop in't finished yet
            finish=1;                 //loop finished
        }
        return(freecallstate);
      }
    break;
    case dialing:
      if(gCallActivity==NOCALL)
      {               //all callID's "idle"
        freecallstate=0;
        return(freecallstate);
      }
      else
      {                         //one or more callID are not "idle"
        for(i=0;finish!=1;i++)
        {               //check status of each callID
          switch(gCallState [i])
          {
            case idle:
              if(freecallstate==0xff)
                freecallstate=i;
            break;
            case onhold:
            break;
            case INCOMING_ON_HOLD:
            break;
            default:                  //one callID status is "active/dialing/disconnecting"
              freecallstate=0xff;           //no dialing possible
              finish=1;               //loop finished
            break;
          }
          if (i==6 && finish==0)              //last element is reached and loop in't finished yet
            finish=1;                 //loop finished
        }
        return(freecallstate);
      }
    break;
    default:
      write("FSG-Telephone CallState_status invalid event: %d", event);
    break;
  }
  return(freecallstate);
}

byte check_hangup (byte call_id)  //check, if in this call state hang up is possible (0=impossible, 1=possible)
{
  byte hangup;

  //init lokal variables
  hangup=Terror_nocallrelatedtoCallID;
  //********************

  switch(gCallState[call_id])
  {
    case ringing_waiting:
      hangup=TRUE;
    break;
    case active:
      hangup=TRUE;
    break;
    case dialing:
      hangup=TRUE;
    break;
    case onhold:
      hangup=TRUE;
    break;
    case INCOMING_ON_HOLD:
      hangup=TRUE;
    break;
    default:  //hangup is impossible in this state
      hangup=Terror_nocallrelatedtoCallID;
    break;
  }
  return(hangup);
}

/*byte ActiveUserValidation ()
{
  char na [3] = "na";
  char tna [4] = "tna";

    if(gSIMSerial[0]!=0 && strncmp(gSIMSerial, "tna", 40)!=0 && strncmp(gSIMSerial, "na", 40)!=0){              //IMSI is not empty or "tna" or "na"
    //  write("one");                     //debug
      return(1);
    }
    else if(strncmp(gSIMSerial, "na", 40)==0 && strncmp(gSerialNumber, "tna", 40)!=0 && gSerialNumber[0]!=0){
    //  write("two");                     //debug
      return(1);
    }
    else
      return(0);
  return(1);
}
*/

int compare_strings (char str1[], char str2[], int length)
{
  // note: lenth has to be shorter than max. of strlen of str1 and str2
  int i;
  char ch1, ch2;

  for(i = 0; i < length; i++)
  {
    ch1 = str1[i];
    ch2 = str2[i];
    if(ch1 != ch2)
    {
      // case insensitive
      if(!((((ch1 >= 0x41) && (ch1 <= 0x5A)) /*ch1 capital letter*/ && ((ch1 + 0x20) == ch2)) ||
            (((ch1 >= 0x61) && (ch1 <= 0x7A)) /*ch1 small letter*/ && ((ch1 - 0x20) == ch2))))
        break;
    }
  }
  return i; // return the number of identical characters at the beginning of the strings
}

void hexStringToBapString(char hexStr[], byte bapStr[])
{
    int lengthHexStr;
    int lengthInByte;
    int c;
    int i;

    lengthInByte = 0;
    c = 0;
    i = 0;
    lengthHexStr = strlen(hexStr);

    if(lengthHexStr > 127)
    {
        // 2 Byte lengthinfo
        bapStr[c++] = 0x80 | ((lengthHexStr >> 8) & 0x0000007f);
        bapStr[c++] = lengthHexStr & 0x000000ff;
    }
    else
    {
        // 1 Byte lengthinfo
        bapStr[c++] = lengthHexStr;
    }

    i = 0;
    while(i < lengthHexStr)
    {
        bapStr[c++] = hexCharToVal(hexStr[i++]);
    }
}

byte hexCharToVal(char c)
{
  switch(c)
  {
    case '0':
        return 0x00;
    case '1':
        return 0x01;
    case '2':
        return 0x02;
    case '3':
        return 0x03;
    case '4':
        return 0x04;
    case '5':
        return 0x05;
    case '6':
        return 0x06;
    case '7':
        return 0x07;
    case '8':
        return 0x08;
    case '9':
        return 0x09;
    case 'a':
    case 'A':
        return 0x0a;
    case 'b':
    case 'B':
        return 0x0b;
    case 'c':
    case 'C':
        return 0x0c;
    case 'd':
    case 'D':
        return 0x0d;
    case 'e':
    case 'E':
        return 0x0e;
    case 'f':
    case 'F':
        return 0x0f;
    default:
        writelineEx(gError_Trace, 0, "invalid hex digit %c", c);
        return 0;
  }
}

on timer agetimer //timer for getting the date
{
  int i;
  for(i=0;i<3;i++)
  {
    gsday[i]=0;
    gsmonth[i]=0;
    gsyear[i]=0;
  }
  gbday=0;
  gbmonth=0;
  gbyear=0;
  getvalue(env_FSG_date, gdate);
  gsday[0]=gdate[0];
  gsday[1]=gdate[1];
  gsday[2]=0;
  gsmonth[0]=gdate[2];
  gsmonth[1]=gdate[3];
  gsmonth[2]=0;
  gsyear[0]=gdate[4];
  gsyear[1]=gdate[5];
  gsyear[2]=0;
  gbday=atol(gsday);
  gbmonth=atol(gsmonth);
  gbyear=atol(gsyear);
}

on envVar env_FSG_time
{
  int i;

  for(i=0;i<3;i++)
  {
    gshour[i]=0;
    gsmin[i]=0;
    gssec[i]=0;
  }

  gbhour=0;
  gbmin=0;
  gbsec=0;
  getvalue(env_FSG_time, gtime);

  gshour[0]=gtime[0];
  gshour[1]=gtime[1];
  gshour[2]=0;
  gsmin[0]=gtime[2];
  gsmin[1]=gtime[3];
  gsmin[2]=0;
  gssec[0]=gtime[4];
  gssec[1]=gtime[5];
  gssec[2]=0;
  gbhour=atol(gshour);
  gbmin=atol(gsmin);
  gbsec=atol(gssec);
}

void Kill_Bill_Vol1 ()
{
  int i, j, length;

  //init lokal variables
  i=0;
  j=0;
  length=0;
  //********************
  write("Kill Bill Vol 1");

  //call states
  gCallState[0]=idle;
  gCallState[1]=idle;
  gCallState[2]=idle;
  gCallState[3]=idle;
  gCallState[4]=idle;
  gCallState[5]=idle;
  gCallState[6]=idle;
  putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
  putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[0]]);
  putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[0]]);
  putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[0]]);
  putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[0]]);
  putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[0]]);
  putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[0]]);

  //CallActivity
  gCallActivity=NOCALL;
  putvalue(env_FSG_CallActivity, gstring_callactivity[gCallActivity]);

  //Disconnect Reason
  gDisconnectReason=regulardisconnecting;
  putvalue(env_FSG_DisconnectReason, gDisconnectReason);

  //CallInfo
  for(j=0;j<7;j++)
  {
    for(i=0;i<CALL_INFO_NAME_LENGTH;i++)  //delete all call info strings
      gCallInfo_PbName[j][i]=0;
    for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
      gCallInfo_TelNumber[j][i]=0;
  }
  //PbName
  putvalue(env_FSG_CallInfo_PbName_0, gCallInfo_PbName[0]);
  putvalue(env_FSG_CallInfo_PbName_1, gCallInfo_PbName[1]);
  putvalue(env_FSG_CallInfo_PbName_2, gCallInfo_PbName[2]);
  putvalue(env_FSG_CallInfo_PbName_3, gCallInfo_PbName[3]);
  putvalue(env_FSG_CallInfo_PbName_4, gCallInfo_PbName[4]);
  putvalue(env_FSG_CallInfo_PbName_5, gCallInfo_PbName[5]);
  putvalue(env_FSG_CallInfo_PbName_6, gCallInfo_PbName[6]);
  putvalue(env_FSG_CallInfo_PbName_0_data, gCallInfo_PbName_hex[0]);
  putvalue(env_FSG_CallInfo_PbName_1_data, gCallInfo_PbName_hex[1]);
  putvalue(env_FSG_CallInfo_PbName_2_data, gCallInfo_PbName_hex[2]);
  putvalue(env_FSG_CallInfo_PbName_3_data, gCallInfo_PbName_hex[3]);
  putvalue(env_FSG_CallInfo_PbName_4_data, gCallInfo_PbName_hex[4]);
  putvalue(env_FSG_CallInfo_PbName_5_data, gCallInfo_PbName_hex[5]);
  putvalue(env_FSG_CallInfo_PbName_6_data, gCallInfo_PbName_hex[6]);
  //TelNumber
  putvalue(env_FSG_CallInfo_TelNumber_0, gCallInfo_TelNumber[0]);
  putvalue(env_FSG_CallInfo_TelNumber_1, gCallInfo_TelNumber[1]);
  putvalue(env_FSG_CallInfo_TelNumber_2, gCallInfo_TelNumber[2]);
  putvalue(env_FSG_CallInfo_TelNumber_3, gCallInfo_TelNumber[3]);
  putvalue(env_FSG_CallInfo_TelNumber_4, gCallInfo_TelNumber[4]);
  putvalue(env_FSG_CallInfo_TelNumber_5, gCallInfo_TelNumber[5]);
  putvalue(env_FSG_CallInfo_TelNumber_6, gCallInfo_TelNumber[6]);

  gemergencycall=0;
  //***sending********
  CallState_Request(Data_REQ,0);  //send call state
  CallInfo_Request(Data_REQ,0);//callinfo_Request(Data_REQ, 0, 0, 0, 0);  //send call info
}

byte detect_emergency_number() // detect emergency call, and set. if confirmation is required
{
    if(gDialNumber_status == 1 && gDialService_status == 0)
    {
      if(strncmp(gDialNumber, police, CALL_INFO_NUMBER_LENGTH)==0 || strncmp(gDialNumber, ambulance, CALL_INFO_NUMBER_LENGTH)==0 ||
          strncmp(gDialNumber, emergency_NAR, CALL_INFO_NUMBER_LENGTH)==0 || strncmp(gDialNumber, cerveza, CALL_INFO_NUMBER_LENGTH)==0)
      {
        gConfirmCall = 0x01;
        return 0x01; // emergency call detected
      }
    }
    else if(gDialService_status == 1)
    {
      if(gDialService_type == 0x03)
      {
        gConfirmCall = 0x01;
        return 0x01; // emergency call detected
      }
    }
    gConfirmCall = 0x00; // no confirmition required
    return 0x00; // no emergency call
}

//*************************************************************************
//*****************On BAP Messages****************************************
//*************************************************************************
/*
on message BAP_Telefon_ASG_01 //BAP-message
{
  int i, temp;
  byte RX_Data[8];      //received CAN-DATA
  dword RX_Header[3];     //received CAN-Header

  if(gFSG_Telephone_PowerOnOff==Power_on)
  {
    RX_Header[0]=this.CAN;
    RX_Header[1]=this.ID;
    RX_Header[2]=this.DLC; // received length

    for (i=0; i<this.DLC; i++)
    {             //CAN-data
      RX_Data[i]=this.byte(i);
    }

    temp=Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data); //send recieved CAN-data with CAN-header to BAP-DLL
    if(temp!=0)
      write("BAP_CAN_SetRxData: %d", temp);
  }
}
*/

/*
on message BAP_Telefon_ASG_02 //BAP-message
{
  int i, temp;
  byte RX_Data[8];      //received CAN-DATA
  dword RX_Header[3];     //received CAN-Header

  if(gFSG_Telephone_PowerOnOff==Power_on)
  {
    RX_Header[0]=this.CAN;
    RX_Header[1]=this.ID;
    RX_Header[2]=this.DLC; // received length
    for (i=0; i<this.DLC; i++)
    {             //CAN-data
      RX_Data[i]=this.byte(i);
    }

    temp=Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data); //send recieved CAN-data with CAN-header to BAP-DLL
    if(temp!=0)
      write("BAP_CAN_SetRxData: %d", temp);
  }
}
*/

//on message BAP_Telefon_ASG_07 //BAP-message
/*
{
  //ETHERNET ONLY!!!

  int i, temp;
  byte RX_Data[8];      //received CAN-DATA
  dword RX_Header[3];     //received CAN-Header

  if(gFSG_Telephone_PowerOnOff==Power_on)
  {
    RX_Header[0]=this.CAN;
    RX_Header[1]=this.ID;
    RX_Header[2]=this.DLC; // received length
    for (i=0; i<this.DLC; i++)
    {             //CAN-data
      RX_Data[i]=this.byte(i);
    }

    temp=Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data); //send recieved CAN-data with CAN-header to BAP-DLL
    if(temp!=0)
      write("BAP_CAN_SetRxData: %d", temp);
  }
}
*/

//on message BAP_Telefon_ASG_08 //BAP-message
/*
{
  //ETHERNET ONLY!!!

  int i, temp;
  byte RX_Data[8];      //received CAN-DATA
  dword RX_Header[3];     //received CAN-Header

  if(gFSG_Telephone_PowerOnOff==Power_on)
  {
    RX_Header[0]=this.CAN;
    RX_Header[1]=this.ID;
    RX_Header[2]=this.DLC; // received length
    for (i=0; i<this.DLC; i++)
    {             //CAN-data
      RX_Data[i]=this.byte(i);
    }

    temp=Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data); //send recieved CAN-data with CAN-header to BAP-DLL
    if(temp!=0)
      write("BAP_CAN_SetRxData: %d", temp);
  }
}
*/

//*************************************************************************
//*****************Fct-IDs Events******************************************
//*************************************************************************

//*****************FSG_Control*********************************************
void FSG_Control_Indication (dword Indication_array [], byte indication, int datalength)
{
  switch (indication){
    case DataGet_IND:
      FSG_Control_Request(Data_REQ, 0);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone FSG_Control_Indication: unknown indication %d", indication);
    break;
  }
}

void FSG_Control_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request){
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_FSG_Control;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gFsgControl_Extension1;
      requestarray[4]=gFsgControl_Extension2;
      requestarray[5]=gFsgControl_Extension3;
      requestarray[6]=gFsgControl_Extension4;
      requestarray[7]=gFsgControl_Extension5;
      requestarray[8]=gFsgControl_Extension6;
      Offset=9;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_FSG_Control;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone FSG_Control_Request: unknown request %d", request);
    break;
  }
}

on envVar env_FSG_FSGControl_update
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    gFsgControl_Extension1=getvalue(env_FSG_FC_Extension1);
    gFsgControl_Extension2=getvalue(env_FSG_FC_Extension2);
    gFsgControl_Extension3=getvalue(env_FSG_FC_Extension3);
    gFsgControl_Extension4=getvalue(env_FSG_FC_Extension4);
    gFsgControl_Extension5=getvalue(env_FSG_FC_Extension5);
    gFsgControl_Extension6=getvalue(env_FSG_FC_Extension6);
    FSG_Control_Request(Data_REQ, 0);
  }
}

//*************************************************************************
//*****************FSG_Setup***********************************************
void FSG_Setup_Indication (dword Indication_array [], byte indication, int datalength)
{
  switch (indication){
    case DataGet_IND:
      FSG_Setup_Request(Data_REQ, 0);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone FSG_Setup_Indication: unknown indication %d", indication);
    break;
  }
}

void FSG_Setup_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request){
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_FSG_Setup;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gPrivacyMode;
      requestarray[4]=gFsgSetup_FunctionProtection;
      requestarray[5]=(gFsgSetup_WebAppState*0x10)&0xF0;
      requestarray[5]=requestarray[5]+(gFsgSetup_Extension1 & 0x0F);
      requestarray[6]=gFsgSetup_Extension2;
      requestarray[7]=gFsgSetup_Extension3;
      requestarray[8]=gFsgSetup_Extension4;
      Offset=9;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_FSG_Setup;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone FSG_Setup_Request: unknown request %d", request);
    break;
  }
}

on envVar env_FSG_FSG_Setup_OK
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    gPrivacyMode=getvalue(env_FSG_PrivacyModeBit);
    gFsgSetup_FunctionProtection=getvalue(env_FSG_FS_FctProtectBit);
    gFsgSetup_WebAppState=getvalue(env_FSG_FS_WebAppStateBit);
    gFsgSetup_Extension1=getvalue(env_FSG_FS_Extension1);
    gFsgSetup_Extension2=getvalue(env_FSG_FS_Extension2);
    gFsgSetup_Extension3=getvalue(env_FSG_FS_Extension3);
    gFsgSetup_Extension4=getvalue(env_FSG_FS_Extension4);
    FSG_Setup_Request(Data_REQ, 0);
  }
}

//*************************************************************************
//*****************FSG_OperationState**************************************
on envVar env_FSG_FSG_OperationState_OK
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    gOP_State=getvalue(env_FSG_OP_State);
    gFsgOperationState_Extension1=getvalue(env_FSG_FOS_Extension1);
    gFsgOperationState_Extension2=getvalue(env_FSG_FOS_Extension2);
    gFsgOperationState_Extension3=getvalue(env_FSG_FOS_Extension3);
    gFsgOperationState_Extension4=getvalue(env_FSG_FOS_Extension4);
    gFsgOperationState_Extension5=getvalue(env_FSG_FOS_Extension5);
    FSG_OperationState_Request(Data_REQ, 0);
  }
}

void FSG_OperationState_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request){
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_FSG_OperationState; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gOP_State;
      requestarray[4]=gFsgOperationState_Extension1;
      requestarray[5]=gFsgOperationState_Extension2;
      requestarray[6]=gFsgOperationState_Extension3;
      requestarray[7]=gFsgOperationState_Extension4;
      requestarray[8]=gFsgOperationState_Extension5;
      Offset=9;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_FSG_OperationState; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone FSG_OperationState_Request: unknown request %d", request);
    break;
  }
}

void FSG_OperationState_Indication (dword Indication_array [], byte indication, int datalength)
{
  switch (indication){
    case DataGet_IND:
      FSG_OperationState_Request(Data_REQ, 0);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone FSG_OperationState_Indication: unknown indication %d", indication);
    break;
  }
}

//*************************************************************************
//*****************MobileServiceSupport************************************
on envVar env_FSG_Telephone_MSS_update
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    //Byte0
    gMobilServiceSupport0=getvalue(env_FSG_Telephone_MSS_0x01)*0x40;
    gMobilServiceSupport0=gMobilServiceSupport0+getvalue(env_FSG_Telephone_MSS_0x02)*0x20;
    gMobilServiceSupport0=gMobilServiceSupport0+getvalue(env_FSG_Telephone_MSS_0x03)*0x10;
    gMobilServiceSupport0=gMobilServiceSupport0+getvalue(env_FSG_Telephone_MSS_0x04)*0x08;
    //Byte1
    gMobilServiceSupport1=getvalue(env_FSG_Telephone_MSS_0x0D)*0x04;
    gMobilServiceSupport1=gMobilServiceSupport1+getvalue(env_FSG_Telephone_MSS_0x0E)*0x02;
    gMobilServiceSupport1=gMobilServiceSupport1+getvalue(env_FSG_Telephone_MSS_0x0F)*0x01;
    //Byte2
    gMobilServiceSupport2=getvalue(env_FSG_Telephone_MSS_0x10)*0x80;
    gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x11)*0x40;
    gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x12)*0x20;
    gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x13)*0x10;
    gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x14)*0x08;
    gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x15)*0x04;
    gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x16)*0x02;
    gMobilServiceSupport2=gMobilServiceSupport2+getvalue(env_FSG_Telephone_MSS_0x17)*0x01;
    //Byte3
    gMobilServiceSupport3=getvalue(env_FSG_Telephone_MSS_0x18)*0x80;
    gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x19)*0x40;
    gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1A)*0x20;
    gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1B)*0x10;
    gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1C)*0x08;
    gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1D)*0x04;
    gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1E)*0x02;
    gMobilServiceSupport3=gMobilServiceSupport3+getvalue(env_FSG_Telephone_MSS_0x1F)*0x01;
    //Byte4
    gMobilServiceSupport4=getvalue(env_FSG_Telephone_MSS_0x20)*0x80;
    gMobilServiceSupport4=gMobilServiceSupport4+getvalue(env_FSG_Telephone_MSS_0x21)*0x40;
    //Byte5
    gMobilServiceSupport5=0x00;
    //Byte6
    gMobilServiceSupport6=0x00;
    //Byte7
    gMobilServiceSupport7=0x00;
    MobilServiceSupport_Request(Data_REQ, 0);
  }
}

on envVar env_FSG_Telephone_MSS_mode
{
  if(gFSG_Telephone_PowerOnOff==Power_on)
  {
    switch(getvalue(this))
    {
      case 0: //none
        putvalue(env_FSG_Telephone_MSS_0x01, 0);
        putvalue(env_FSG_Telephone_MSS_0x02, 0);
        putvalue(env_FSG_Telephone_MSS_0x03, 0);
        putvalue(env_FSG_Telephone_MSS_0x04, 0);
        putvalue(env_FSG_Telephone_MSS_0x0D, 0);
        putvalue(env_FSG_Telephone_MSS_0x0E, 0);
        putvalue(env_FSG_Telephone_MSS_0x0F, 0);
        putvalue(env_FSG_Telephone_MSS_0x10, 0);
        putvalue(env_FSG_Telephone_MSS_0x11, 0);
        putvalue(env_FSG_Telephone_MSS_0x12, 0);
        putvalue(env_FSG_Telephone_MSS_0x13, 0);
        putvalue(env_FSG_Telephone_MSS_0x14, 0);
        putvalue(env_FSG_Telephone_MSS_0x15, 0);
        putvalue(env_FSG_Telephone_MSS_0x16, 0);
        putvalue(env_FSG_Telephone_MSS_0x17, 0);
        putvalue(env_FSG_Telephone_MSS_0x18, 0);
        putvalue(env_FSG_Telephone_MSS_0x19, 0);
        putvalue(env_FSG_Telephone_MSS_0x1A, 0);
        putvalue(env_FSG_Telephone_MSS_0x1B, 0);
        putvalue(env_FSG_Telephone_MSS_0x1C, 0);
        putvalue(env_FSG_Telephone_MSS_0x1D, 0);
        putvalue(env_FSG_Telephone_MSS_0x1E, 0);
        putvalue(env_FSG_Telephone_MSS_0x1F, 0);
        putvalue(env_FSG_Telephone_MSS_0x20, 0);
        putvalue(env_FSG_Telephone_MSS_0x21, 0);
      break;
      case 1: //all
        putvalue(env_FSG_Telephone_MSS_0x01, 1);
        putvalue(env_FSG_Telephone_MSS_0x02, 1);
        putvalue(env_FSG_Telephone_MSS_0x03, 1);
        putvalue(env_FSG_Telephone_MSS_0x04, 1);
        putvalue(env_FSG_Telephone_MSS_0x0D, 1);
        putvalue(env_FSG_Telephone_MSS_0x0E, 1);
        putvalue(env_FSG_Telephone_MSS_0x0F, 1);
        putvalue(env_FSG_Telephone_MSS_0x10, 1);
        putvalue(env_FSG_Telephone_MSS_0x11, 1);
        putvalue(env_FSG_Telephone_MSS_0x12, 1);
        putvalue(env_FSG_Telephone_MSS_0x13, 1);
        putvalue(env_FSG_Telephone_MSS_0x14, 1);
        putvalue(env_FSG_Telephone_MSS_0x15, 1);
        putvalue(env_FSG_Telephone_MSS_0x16, 1);
        putvalue(env_FSG_Telephone_MSS_0x17, 1);
        putvalue(env_FSG_Telephone_MSS_0x18, 1);
        putvalue(env_FSG_Telephone_MSS_0x19, 1);
        putvalue(env_FSG_Telephone_MSS_0x1A, 1);
        putvalue(env_FSG_Telephone_MSS_0x1B, 1);
        putvalue(env_FSG_Telephone_MSS_0x1C, 1);
        putvalue(env_FSG_Telephone_MSS_0x1D, 1);
        putvalue(env_FSG_Telephone_MSS_0x1E, 1);
        putvalue(env_FSG_Telephone_MSS_0x1F, 1);
        putvalue(env_FSG_Telephone_MSS_0x20, 1);
        putvalue(env_FSG_Telephone_MSS_0x21, 1);
      break;
    }
  }
}

void MobilServiceSupport_Indication (dword Indication_array [], byte indication, int datalength)
{
  switch (indication)
  {
    case DataGet_IND:
      MobilServiceSupport_Request(Data_REQ, 0);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone MobilServiceSupport_Indication: unknown indication %d", indication);
    break;
  }
}

void MobilServiceSupport_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request)
  {
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_MobileServiceSupport; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gMobilServiceSupport0;
      requestarray[4]=gMobilServiceSupport1;
      requestarray[5]=gMobilServiceSupport2;
      requestarray[6]=gMobilServiceSupport3;
      requestarray[7]=gMobilServiceSupport4;
      requestarray[8]=gMobilServiceSupport5;
      requestarray[9]=gMobilServiceSupport6;
      requestarray[10]=gMobilServiceSupport7;
      Offset=11;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_MobileServiceSupport; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone MobilServiceSupport_Request: unknown request %d", request);
    break;
  }
}

//*************************************************************************
//*****************DeviceConnectionState***********************************
on envVar env_FSG_DCS_update
{
  byte i;

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    gSIMCardReader=getvalue(env_FSG_SIMCardReader);
    gCableConnection=getvalue(env_FSG_CableConnection);
    gHFPConnection=getvalue(env_FSG_HFPConnection);
    gRSAPConnection=getvalue(env_FSG_RSAPConnection);
    gAppleCarPlay=getvalue(env_FSG_AppleCarPlay);
    gAndroidAuto=getvalue(env_FSG_AndroidAuto);
    gBaiduCarLife=getvalue(env_FSG_BaiduCarLife);
    gPhoneCharacteristics=gSIMCardReader+2*gCableConnection+4*gHFPConnection+8*gRSAPConnection
                          +16*gAppleCarPlay+32*gAndroidAuto+64*gBaiduCarLife;
    gMobileConnectionType=getvalue(env_FSG_MobileConnectionType);
    //set MobileConnectionType depending on PhoneCharacteristics
    switch(gMobileConnectionType)
    {
      case INTERNAL_SIM_CARD_READER:
          if(getvalue(env_FSG_SIMCardReader)==FALSE)
              gMobileConnectionType=NO_CONNECTION;
      break;
      case CABLE_CONNECTION:
          if(getvalue(env_FSG_CableConnection)==FALSE)
              gMobileConnectionType=NO_CONNECTION;
      break;
      case HANDS_FREE_PROFILE:
          if(getvalue(env_FSG_HFPConnection)==FALSE)
              gMobileConnectionType=NO_CONNECTION;
      break;
      case REMOTE_SIM_ACCESS_PROFILE:
          if(getvalue(env_FSG_RSAPConnection)==FALSE)
              gMobileConnectionType=NO_CONNECTION;
      break;
      case APPLE_CARPLAY:
          if(getvalue(env_FSG_AppleCarPlay)==FALSE)
              gMobileConnectionType=NO_CONNECTION;
      break;
      case ANDROID_AUTO:
          if(getvalue(env_FSG_AndroidAuto)==FALSE)
              gMobileConnectionType=NO_CONNECTION;
      break;
      case BAIDU_CARLIFE:
          if(getvalue(env_FSG_BaiduCarLife)==FALSE)
              gMobileConnectionType=NO_CONNECTION;
      break;
    }
    putvalue(env_FSG_MobileConnectionType,gMobileConnectionType);
    gMobileConnectionTypeAttributes=getvalue(env_FSG_DCS_MCTA_BT)+(getvalue(env_FSG_DCS_MCTA_USB)*0x02)+(getvalue(env_FSG_DCS_MCTA_WLAN)*0x04);
    gTel_State=getvalue(env_FSG_Tel_State);
    gLockState=getvalue(env_FSG_LockState);
    gDeviceConnectionState_Extension1=getvalue(env_FSG_DCS_Extension1);
    gDeviceConnectionState_Extension2=getvalue(env_FSG_DCS_Extension2);
    gDeviceConnectionState_Extension3=getvalue(env_FSG_DCS_Extension3);
    gDeviceConnectionState_Extension4=getvalue(env_FSG_DCS_Extension4);
    gDeviceConnectionState_Extension5=getvalue(env_FSG_DCS_Extension5);
    gDeviceConnectionState_Extension6=getvalue(env_FSG_DCS_Extension6);
    DeviceConnectionState_Request(Data_REQ, 0);
    //trigger NetworkState depending on LockState
    switch(gLockState)
    {
      case nolock:
        if(gRegisterState!=notregisterdandsearching)
        {
          gRegisterState=notregisterdandsearching;
          gNetworkType=UNKNOWN_NT;
          gPacketDataNetworkType=NO_DATA_SERVICE;
          putvalue(env_FSG_RegisterState, gRegisterState);
          putvalue(env_FSG_NetworkType,gNetworkType);
          putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
          NetworkState_Request(Data_REQ, 0);  //send NetworkState
        }
      break;
      case requirePIN:
        gPIN_attempts=3;
        if(gRegisterState!=notregisteredandnotsearching)
        {
          gRegisterState=notregisteredandnotsearching;
          gNetworkType=UNKNOWN_NT;
          gPacketDataNetworkType=NO_DATA_SERVICE;
          putvalue(env_FSG_RegisterState, gRegisterState);
          putvalue(env_FSG_NetworkType,gNetworkType);
          putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
          NetworkState_Request(Data_REQ, 0);  //send NetworkState
        }
        if(gNetworkProviderState)
        {
          putvalue(env_FSG_NetworkProviderState, 0);
          gNetworkProviderState=0;
          for(i=0;i<40;i++)
            gNetworkProviderName[i]=0;          //delete old name, no network
          putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);
          NetworkProvider_Request(Data_REQ, 0); //send empty provider name
        }
        /*//else necessary?
        else
          putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);//delete name in panel
        */
      break;
      default:                                  //SIM not available or locked
        if(gCallActivity!=0)                    //single or multiparty call active
          Kill_Bill_Vol1();
        canceltimer(registerstatetimer);
        gRegisterState=notregisteredandnotsearching;
        gNetworkType=UNKNOWN_NT;
        gPacketDataNetworkType=NO_DATA_SERVICE;
        putvalue(env_FSG_RegisterState, gRegisterState);
        putvalue(env_FSG_NetworkType,gNetworkType);
        putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
        NetworkState_Request(Data_REQ, 0);      //send NetworkState
        if(gNetworkProviderState)
        {
          putvalue(env_FSG_NetworkProviderState, 0);
          gNetworkProviderState=0;
          for(i=0;i<40;i++)
            gNetworkProviderName[i]=0;          //delete old name, no network
          putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);
          NetworkProvider_Request(Data_REQ, 0); //send empty provider name
        }
        /*//else necessary?
        else
          putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);             //delete name in panel
          putvalue(env_FSG_ServiceProviderName,gServiceProviderName);
          putvalue(env_FSG_ServiceProviderState,0);
        */
      break;
    }
  }
}

void DeviceConnectionState_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request){
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_DeviceConnectionState;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gPhoneCharacteristics;
      requestarray[4]=gMobileConnectionType;
      requestarray[5]=gMobileConnectionTypeAttributes;
      requestarray[6]=gTel_State;
      requestarray[7]=gLockState;
      requestarray[8]=gDeviceConnectionState_Extension1;
      requestarray[9]=gDeviceConnectionState_Extension2;
      requestarray[10]=gDeviceConnectionState_Extension3;
      requestarray[11]=gDeviceConnectionState_Extension4;
      requestarray[12]=gDeviceConnectionState_Extension5;
      requestarray[13]=gDeviceConnectionState_Extension6;
      Offset=14;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_FSG_OperationState; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone DeviceConnectionState_Request: unknown request %d", request);
    break;
  }
}

void DeviceConnectionState_Indication (dword Indication_array [], byte indication, int datalength)
{
  switch (indication){
    case DataGet_IND:
      FSG_OperationState_Request(Data_REQ, 0);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone DeviceConnectionState_Indication: unknown indication %d", indication);
    break;
  }
}

//*************************************************************************
//*****************NetworkState********************************************
on envVar env_FSG_NetS_update
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    gRegisterState=getvalue(env_FSG_RegisterState);
    //verify registerstate & networktypes
    if(gRegisterState==registered || gRegisterState==registeredandroaming ||
        gRegisterState==registeredandroamingalternative || gRegisterState==emergencycallsonly)
    {
      gNetworkType=getvalue(env_FSG_NetworkType);
      switch(gNetworkType)
      {
        case UNKNOWN_NT:
            gPacketDataNetworkType=NO_DATA_SERVICE;
        break;
        case GSM:
            if(getvalue(env_FSG_PacketDataNetworkType)==GSM_GPRS || getvalue(env_FSG_PacketDataNetworkType)==GSM_EDGE ||
                getvalue(env_FSG_PacketDataNetworkType) == CDMA_DataNetwork || getvalue(env_FSG_PacketDataNetworkType) == LTE_DataNetwork ||
                getvalue(env_FSG_PacketDataNetworkType) == HSPAplus_DN || getvalue(env_FSG_PacketDataNetworkType) == LTE_adv_DN)
              gPacketDataNetworkType=getvalue(env_FSG_PacketDataNetworkType);
            else                                      //PacketDataNetworkType is HSDPA/HSUPA
              gPacketDataNetworkType=NO_DATA_SERVICE; //Not available for GSM
        break;
        case UMTS:
            if(getvalue(env_FSG_PacketDataNetworkType)==HSDPA || getvalue(env_FSG_PacketDataNetworkType)==HSUPA ||
                getvalue(env_FSG_PacketDataNetworkType) == CDMA_DataNetwork || getvalue(env_FSG_PacketDataNetworkType) == LTE_DataNetwork ||
                getvalue(env_FSG_PacketDataNetworkType) == HSPAplus_DN || getvalue(env_FSG_PacketDataNetworkType) == LTE_adv_DN)
              gPacketDataNetworkType=getvalue(env_FSG_PacketDataNetworkType);
            else                                      //PacketDataNetworkType is GSM-GPRS/GSM-EDGE
              gPacketDataNetworkType=NO_DATA_SERVICE; //Not available for UMTS
        break;
        case CDMA:
            if(getvalue(env_FSG_PacketDataNetworkType)==HSDPA || getvalue(env_FSG_PacketDataNetworkType)==HSUPA ||
                getvalue(env_FSG_PacketDataNetworkType) == CDMA_DataNetwork || getvalue(env_FSG_PacketDataNetworkType) == LTE_DataNetwork ||
                getvalue(env_FSG_PacketDataNetworkType) == HSPAplus_DN || getvalue(env_FSG_PacketDataNetworkType) == LTE_adv_DN)
              gPacketDataNetworkType=getvalue(env_FSG_PacketDataNetworkType);
            else                                      //PacketDataNetworkType is GSM-GPRS/GSM-EDGE
              gPacketDataNetworkType=NO_DATA_SERVICE; //Not available for CDMA
        break;
        case LTE:
          gPacketDataNetworkType = getvalue(env_FSG_PacketDataNetworkType);
        break;
        case HSPAplus:
          gPacketDataNetworkType = getvalue(env_FSG_PacketDataNetworkType);
        break;
        case LTE_adv:
          gPacketDataNetworkType = getvalue(env_FSG_PacketDataNetworkType);
        break;
      }
    }
    else        //not registered, registration denied or function not supported by ME
    {
      gNetworkType=UNKNOWN_NT;
      gPacketDataNetworkType=NO_DATA_SERVICE;
    }
    putvalue(env_FSG_NetworkType,gNetworkType);
    putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
    gSignalQuality=getvalue(env_FSG_SignalQuality);
    gNetworkState_Extension1=getvalue(env_FSG_NetS_Extension1);
    gNetworkState_Extension2=getvalue(env_FSG_NetS_Extension2);
    NetworkState_Request(Data_REQ, 0);
  }
}

on envVar env_FSG_SignalQuality_Mode
{
  if(getvalue(this)==1){
    settimer(signalqualitytimer, 5);
  }
  else
    canceltimer(signalqualitytimer);
}

on timer registerstatetimer
{
  if(gemergencycall==2 || gemergencycall==3)
  {
    gRegisterState=registered;
    putvalue(env_FSG_RegisterState, gRegisterState);
    NetworkState_Request(Data_REQ, 0);  //send register state
    settimer(checknetworktimer, gtime_checknetworktimer);
  }
  else if(gNetworkProviderState)
  {
    gRegisterState=registered;
    putvalue(env_FSG_RegisterState, gRegisterState);
    NetworkState_Request(Data_REQ, 0);  //send register state
  }
  NetworkProvider_Request(Data_REQ, 0); //send new provider name
}

on timer signalqualitytimer
{
  byte temp;

  temp=gSignalQuality;
  gSignalQuality=random(99);
  putvalue(env_FSG_SignalQuality, gSignalQuality);
  if(temp!=gSignalQuality)
    NetworkState_Request(Data_REQ, 0);
  settimer(signalqualitytimer, 5);
}

void NetworkState_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request){
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_NetworkState; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gRegisterState;
      requestarray[4]=gNetworkType;
      requestarray[5]=gPacketDataNetworkType;
      requestarray[6]=gSignalQuality;
      requestarray[7]=gNetworkState_Extension1;
      requestarray[8]=gNetworkState_Extension2;
      Offset=9;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_FSG_OperationState; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone NetworkState_Request: unknown request %d", request);
    break;
  }
}

void NetworkState_Indication (dword Indication_array [], byte indication, int datalength)
{
  switch (indication){
    case DataGet_IND:
      NetworkState_Request(Data_REQ, 0);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone NetworkState_Indication: unknown indication %d", indication);
    break;
  }
}

//*************************************************************************
//*****************NetworkProvider*****************************************
on envVar env_FSG_NetworkProvider_OK
{
  byte i,length;

  //init lokal variables
  length=0;
  //********************

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    canceltimer(registerstatetimer);
    gNetworkProviderState=getvalue(env_FSG_NetworkProviderState);
    gNetworkProvider_Extension=getvalue(env_FSG_NetP_Extension);
    if (gLockState==nolock)                                               //SIM available and not locked
    {
      if (gNetworkProviderState==0)                                       //no NetworkProvider
      {
        if(gCallActivity!=0)                                              //single or multiparty call active
          Kill_Bill_Vol1();                                               //kill all calls
        for(i=0;i<40;i++)
          gNetworkProviderName[i]=0;                                      //delete old name, no network
        putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);
        gRegisterState=notregisterdandsearching;
        gNetworkType=UNKNOWN_NT;
        gPacketDataNetworkType=NO_DATA_SERVICE;
        putvalue(env_FSG_RegisterState, gRegisterState);
        putvalue(env_FSG_NetworkType,gNetworkType);
        putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
        NetworkState_Request(Data_REQ, 0);                                //send register state
        NetworkProvider_Request(Data_REQ, 0);                             //send empty provider name
      }
      else                                                                //NetworkProvider available
      {
        for(i=0;i<40;i++)
          gNetworkProviderName[i]=0;                                      //delete old name, no network
        gRegisterState=notregisterdandsearching;
        gNetworkType=UNKNOWN_NT;
        gPacketDataNetworkType=NO_DATA_SERVICE;
        putvalue(env_FSG_RegisterState, gRegisterState);
        putvalue(env_FSG_NetworkType,gNetworkType);
        putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
        NetworkState_Request(Data_REQ, 0);                                //send register state
        getvalue(env_FSG_NetworkProviderName,gNetworkProviderName);       //get new name
        if(strlen(gNetworkProviderName))                                  //NetworkProviderName valid
        {
          settimer(registerstatetimer, gtime_registerstatetimer);         //timer for network registration
        }
        else                                                              //NetworkProviderName is empty
        {
          for(i=0;i<40;i++)
            gNetworkProviderName[i]=0;                                    //delete name, no network
          putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);
          gNetworkProviderState=0;                                        //set no NetworkProvider available
          putvalue(env_FSG_NetworkProviderState,gNetworkProviderState);
          NetworkProvider_Request(Data_REQ, 0);
        }
      }
    }
    else if (gemergencycall==2 || gemergencycall==3)                      //SIM not available or locked but emergency call active
    {
      if(gNetworkProviderState==0 && gCallActivity!=0)                    //no network provider (provider lost) and singel or multipaty call active
        Kill_Bill_Vol1();                                                 //kill all calls
      getvalue(env_FSG_NetworkProviderName,gNetworkProviderName);
      gRegisterState=notregisterdandsearching;
      gNetworkType=UNKNOWN_NT;
      gPacketDataNetworkType=NO_DATA_SERVICE;
      putvalue(env_FSG_RegisterState, gRegisterState);
      putvalue(env_FSG_NetworkType,gNetworkType);
      putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
      settimer(registerstatetimer, gtime_registerstatetimer);
      NetworkState_Request(Data_REQ, 0);                                  //send register state
    }
    else                                                                  //LockState !=Nolock
    {
      if(gNetworkProviderState)
        settimer(nonetworktimer,10);
      for(i=0;i<40;i++)
        gNetworkProviderName[i]=0;                                        //delete old name, no network
      putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);
    }
  }
}

on timer nonetworktimer
{
  putvalue(env_FSG_NetworkProviderState, 0);
}

void NetworkProvider_Indication (dword Indication_array [], byte indication, int datalength)
{
  switch (indication){
    case DataGet_IND:
      NetworkProvider_Request(Data_REQ, 0);               //send network provider
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone NetworkProvider_Indication: unknown indication %d", indication);
    break;
  }
}

void NetworkProvider_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;

  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch (request){
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_NetworkProvider;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=((gNetworkProviderState*0x10) & 0xF0) + (gNetworkProvider_Extension & 0x0F);
      requestarray[4]=strlen(gNetworkProviderName);
      Offset=5;
      for(i=0;i<strlen(gNetworkProviderName);i++)
      {
        requestarray[Offset]=gNetworkProviderName[i];
        Offset++;
      }
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_NetworkProvider;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone NetworkProvider_Request: unknown request %d", request);
    break;
  }
}

//*************************************************************************
//*****************ActiveUser**********************************************
on envVar env_FSG_ActiveUser_OK
{
  int i;

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    for(i=0;i<50;i++)
      gUserName[i]=0;
    getvalue(env_FSG_UserName, gUserName);
    ActiveUser_Request(Data_REQ, 0);
  }
}

void ActiveUser_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch (request){
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_ActiveUser; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=strlen(gUserName);  //Stringlänge
      Offset=4;
      for(i=0;i<strlen(gUserName);i++){
        requestarray[Offset]=gUserName[i];
        Offset++;
      }
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);  //send new provider name
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_ActiveUser; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone ActiveUser_Request: unknown request %d", request);
    break;
  }
}

void ActiveUser_Indication (dword Indication_array [], byte indication, int datalength)
{
  switch (indication)
  {
    case DataGet_IND:
      ActiveUser_Request(Data_REQ, 0);        //send network provider
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone ActiveUser indication: unknown indication %d", indication);
    break;
  }
}

//*************************************************************************
//*****************MobileBatteryLevel**************************************
on timer MobileBatteryLevelTimer
{
    MobileBatteryLevel_Request(Data_REQ, 0);
}


//on envVar env_FSG_ChargeLevelM1
/*
{
    if(gFSG_Telephone_PowerOnOff==Power_on)
    {
        gChargeLevel=getvalue(this);                            //Set level by value
        if(gChargeLevel<=LOW_CHARGE_LEVEL)                          //Level under LOW_CHARGE_LEVEL
            gWarningLevel=gWarningLevel|0x01;                       //activate warning mobile1
        else
            gWarningLevel=gWarningLevel&0xFE;                       //deactivate warning mobile1
        settimer(MobileBatteryLevelTimer,1);                        //timer to send request
    }
}
*/

//on envVar env_FSG_ChargeLevelM1_Init
/*
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    gChargeLevel=getvalue(env_FSG_ChargeLevelM1);                                     //Set level by value
    putvalue(env_FSG_ChargeLevelM1,gChargeLevel);
  }
}
*/

on envVar env_FSG_MBL_update
{
  if(getvalue(this))
  {
    gChargeLevel=getvalue(env_FSG_ChargeLevelM1);                                       //Set level by value
    gWarningLevel=getvalue(env_FSG_MBL_WarningLevel_Bit0);                                  //deactivate warning mobile1
    gMobileBatteryLevel_Extension1=getvalue(env_FSG_MBL_Extension1);
    gMobileBatteryLevel_Extension2=getvalue(env_FSG_MBL_Extension2);
    gMobileBatteryLevel_Extension3=getvalue(env_FSG_MBL_Extension3);
    gMobileBatteryLevel_Extension4=getvalue(env_FSG_MBL_Extension4);
    gMobileBatteryLevel_Extension5=getvalue(env_FSG_MBL_Extension5);
    settimer(MobileBatteryLevelTimer,1);
  }
}

void MobileBatteryLevel_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request){
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_MobileBatteryLevel; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gChargeLevel;
      requestarray[4]=((gWarningLevel*0x10) & 0xF0) + (gMobileBatteryLevel_Extension1 & 0x0F);
      requestarray[5]=gMobileBatteryLevel_Extension2;
      requestarray[6]=gMobileBatteryLevel_Extension3;
      requestarray[7]=gMobileBatteryLevel_Extension4;
      requestarray[8]=gMobileBatteryLevel_Extension5;
      Offset=9;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_MobileBatteryLevel; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone MobileBatteryLevel_Request: unknown request %d", request);
    break;
  }
}

void MobileBatteryLevel_Indication (dword Indication_array [], byte indication, int datalength)
{
  switch (indication){
    case DataGet_IND:
      MobileBatteryLevel_Request(Data_REQ, 0);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone MobileBatteryLevel_Indication: unknown indication %d", indication);
    break;
  }
}

//*************************************************************************
//*****************CallState***********************************************
on envVar env_FSG_CallState_update
{
  int i;

  //init lokal variables
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    write("FSG: env_FSG_CallState_update");
    gCallState[0] =getvalue(env_FSG_CallState_CallID_0_set);
    gCallState[1] =getvalue(env_FSG_CallState_CallID_1_set);
    gCallState[2] =getvalue(env_FSG_CallState_CallID_2_set);
    gCallState[3] =getvalue(env_FSG_CallState_CallID_3_set);
    gCallState[4] =getvalue(env_FSG_CallState_CallID_4_set);
    gCallState[5] =getvalue(env_FSG_CallState_CallID_5_set);
    gCallState[6] =getvalue(env_FSG_CallState_CallID_6_set);
    gCallType[0]  =getvalue(env_FSG_CallType_CallID_0_set);
    gCallType[1]  =getvalue(env_FSG_CallType_CallID_1_set);
    gCallType[2]  =getvalue(env_FSG_CallType_CallID_2_set);
    gCallType[3]  =getvalue(env_FSG_CallType_CallID_3_set);
    gCallType[4]  =getvalue(env_FSG_CallType_CallID_4_set);
    gCallType[5]  =getvalue(env_FSG_CallType_CallID_5_set);
    gCallType[6]  =getvalue(env_FSG_CallType_CallID_6_set);
    gCallOptions1[0]= getvalue(env_FSG_CallState_Opt0_1_Bit0)+      (getvalue(env_FSG_CallState_Opt0_1_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt0_1_Bit2)*0x04)+(getvalue(env_FSG_CallState_Opt0_1_Bit3)*0x08)
                    +(getvalue(env_FSG_CallState_Opt0_1_Bit4)*0x10)+(getvalue(env_FSG_CallState_Opt0_1_Bit5)*0x20)
                    +(getvalue(env_FSG_CallState_Opt0_1_Bit6)*0x40)+(getvalue(env_FSG_CallState_Opt0_1_Bit7)*0x80);
    gCallOptions2[0]= getvalue(env_FSG_CallState_Opt0_2_Bit0)+      (getvalue(env_FSG_CallState_Opt0_2_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt0_2_Bit2)*0x04);
    gCallOptions1[1]= getvalue(env_FSG_CallState_Opt1_1_Bit0)+      (getvalue(env_FSG_CallState_Opt1_1_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt1_1_Bit2)*0x04)+(getvalue(env_FSG_CallState_Opt1_1_Bit3)*0x08)
                    +(getvalue(env_FSG_CallState_Opt1_1_Bit4)*0x10)+(getvalue(env_FSG_CallState_Opt1_1_Bit5)*0x20)
                    +(getvalue(env_FSG_CallState_Opt1_1_Bit6)*0x40)+(getvalue(env_FSG_CallState_Opt1_1_Bit7)*0x80);
    gCallOptions2[1]= getvalue(env_FSG_CallState_Opt1_2_Bit0)+      (getvalue(env_FSG_CallState_Opt1_2_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt1_2_Bit2)*0x04);
    gCallOptions1[2]= getvalue(env_FSG_CallState_Opt2_1_Bit0)+      (getvalue(env_FSG_CallState_Opt2_1_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt2_1_Bit2)*0x04)+(getvalue(env_FSG_CallState_Opt2_1_Bit3)*0x08)
                    +(getvalue(env_FSG_CallState_Opt2_1_Bit4)*0x10)+(getvalue(env_FSG_CallState_Opt2_1_Bit5)*0x20)
                    +(getvalue(env_FSG_CallState_Opt2_1_Bit6)*0x40)+(getvalue(env_FSG_CallState_Opt2_1_Bit7)*0x80);
    gCallOptions2[2]= getvalue(env_FSG_CallState_Opt2_2_Bit0)+      (getvalue(env_FSG_CallState_Opt2_2_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt2_2_Bit2)*0x04);
    gCallOptions1[3]= getvalue(env_FSG_CallState_Opt3_1_Bit0)+      (getvalue(env_FSG_CallState_Opt3_1_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt3_1_Bit2)*0x04)+(getvalue(env_FSG_CallState_Opt3_1_Bit3)*0x08)
                    +(getvalue(env_FSG_CallState_Opt3_1_Bit4)*0x10)+(getvalue(env_FSG_CallState_Opt3_1_Bit5)*0x20)
                    +(getvalue(env_FSG_CallState_Opt3_1_Bit6)*0x40)+(getvalue(env_FSG_CallState_Opt3_1_Bit7)*0x80);
    gCallOptions2[3]= getvalue(env_FSG_CallState_Opt3_2_Bit0)+      (getvalue(env_FSG_CallState_Opt3_2_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt3_2_Bit2)*0x04);
    gCallOptions1[4]= getvalue(env_FSG_CallState_Opt4_1_Bit0)+      (getvalue(env_FSG_CallState_Opt4_1_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt4_1_Bit2)*0x04)+(getvalue(env_FSG_CallState_Opt4_1_Bit3)*0x08)
                    +(getvalue(env_FSG_CallState_Opt4_1_Bit4)*0x10)+(getvalue(env_FSG_CallState_Opt4_1_Bit5)*0x20)
                    +(getvalue(env_FSG_CallState_Opt4_1_Bit6)*0x40)+(getvalue(env_FSG_CallState_Opt4_1_Bit7)*0x80);
    gCallOptions2[4]= getvalue(env_FSG_CallState_Opt4_2_Bit0)+      (getvalue(env_FSG_CallState_Opt4_2_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt4_2_Bit2)*0x04);
    gCallOptions1[5]= getvalue(env_FSG_CallState_Opt5_1_Bit0)+      (getvalue(env_FSG_CallState_Opt5_1_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt5_1_Bit2)*0x04)+(getvalue(env_FSG_CallState_Opt5_1_Bit3)*0x08)
                    +(getvalue(env_FSG_CallState_Opt5_1_Bit4)*0x10)+(getvalue(env_FSG_CallState_Opt5_1_Bit5)*0x20)
                    +(getvalue(env_FSG_CallState_Opt5_1_Bit6)*0x40)+(getvalue(env_FSG_CallState_Opt5_1_Bit7)*0x80);
    gCallOptions2[5]= getvalue(env_FSG_CallState_Opt5_2_Bit0)+      (getvalue(env_FSG_CallState_Opt5_2_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt5_2_Bit2)*0x04);
    gCallOptions1[6]= getvalue(env_FSG_CallState_Opt6_1_Bit0)+      (getvalue(env_FSG_CallState_Opt6_1_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt6_1_Bit2)*0x04)+(getvalue(env_FSG_CallState_Opt6_1_Bit3)*0x08)
                    +(getvalue(env_FSG_CallState_Opt6_1_Bit4)*0x10)+(getvalue(env_FSG_CallState_Opt6_1_Bit5)*0x20)
                    +(getvalue(env_FSG_CallState_Opt6_1_Bit6)*0x40)+(getvalue(env_FSG_CallState_Opt6_1_Bit7)*0x80);
    gCallOptions2[6]= getvalue(env_FSG_CallState_Opt6_2_Bit0)+      (getvalue(env_FSG_CallState_Opt6_2_Bit1)*0x02)
                    +(getvalue(env_FSG_CallState_Opt6_2_Bit2)*0x04);
    gCallOutgoingDiverted_eCallConfirmationPending[0]=getvalue(env_FSG_CallState_CallOuDive_0_s);
    gCallOutgoingDiverted_eCallConfirmationPending[1]=getvalue(env_FSG_CallState_CallOuDive_1_s);
    gCallOutgoingDiverted_eCallConfirmationPending[2]=getvalue(env_FSG_CallState_CallOuDive_2_s);
    gCallOutgoingDiverted_eCallConfirmationPending[3]=getvalue(env_FSG_CallState_CallOuDive_3_s);
    gCallOutgoingDiverted_eCallConfirmationPending[4]=getvalue(env_FSG_CallState_CallOuDive_4_s);
    gCallOutgoingDiverted_eCallConfirmationPending[5]=getvalue(env_FSG_CallState_CallOuDive_5_s);
    gCallOutgoingDiverted_eCallConfirmationPending[6]=getvalue(env_FSG_CallState_CallOuDive_6_s);
    gCallOutgoingDiverted_eCallConfirmationPending[7]=getvalue(env_FSG_CallState_CallOuDive_7_s);
    gDisconnectReason=getvalue(env_FSG_DisconnectReason);
    gCallState_Extension1=getvalue(env_FSG_CS_Extension1);
    gCallState_Extension2=getvalue(env_FSG_CS_Extension2);
    CallState_Request(Data_REQ, 0);
  }
}

set_CallState (byte callid, byte callstate)
{
  int i, duration;
  byte num_active_calls;
  char empty_string [3];
  byte any_hold_call;
  byte any_active_call;

  //init lokal variables
  num_active_calls=0;
  duration=0;
  for(i=0;i<3;i++)
    empty_string[i]=0;
  any_hold_call=0;
  any_active_call=0;
  num_active_calls=0;
  //********************

  if(callid<7)                                                              //only one special callid should be set
  {
    gCallState[callid]=callstate;                                           //set call state
    //***********rate active calls and calls on hold*************
    for(i=0;i<7;i++)
    {
        if(gCallState[i]==active)                                           // for active calls
            any_active_call=TRUE;
        else if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)   // for hold calls
            any_hold_call=TRUE;
    }
    //***********************************************************
    switch(callstate)
    {
      case idle:
        gCallType[callid]=unknowncalltype;
        gCallOptions1[callid]=FALSE;                                        //Deactivate all CallOptions for this CallID
        gCallOptions2[callid]=FALSE;                                        //Deactivate all CallOptions for this CallID
        for(i=0;i<7;i++)                                                    //Check other CALLIDs and set corresponding CallOptions
        {
          if(gCallState[i]==active)                                         //for active calls
          {
            if(any_hold_call)
            {
                gCallOptions1[i]= MP_SWAP;
                gCallOptions2[i]= CC_JOIN;
            }
            else                                                            //no call on hold
                gCallOptions1[i]= CALL_HOLD;
            num_active_calls++;                                             //calculate number of active calls
          }
          else if(gCallState[i]==ringing_waiting)                           //for ringing/waiting calls
          {
            if(any_active_call && any_hold_call)                            //both active and hold calls
                gCallOptions1[i]= MP_RACAWC;
            else if(any_active_call && !any_hold_call)                      //only active calls
            {
                gCallOptions1[i]= MP_RACAWC + CALL_HOLD;
                gCallOptions2[i]= MP_CHAWC;
            }
            else if(!any_active_call && any_hold_call)                      //only hold calls
                gCallOptions1[i]= ACCEPT_CALL;
          }
          else if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD) // for hold calls
          {
            if(any_active_call)
            {
                gCallOptions1[i]= MP_SWAP;
                gCallOptions2[i]= CC_JOIN;
            }
            else                                                            //no active call
                gCallOptions1[i]= RESUME_CALL;
          }
        }
        //if only one call is active, set it on SINGLE_VOICE_CALL
        if(num_active_calls==1)
        {
          for(i=0;i<7;i++)
          {
            if(gCallState[i]==active && gCallType[i]==CONFERENCE_VOICE_CALL)//type of active call is "conference"
            {
              gCallType[i]= SINGLE_VOICE_CALL;                              //set call type to "regular voice call"
              gCallOptions1[i]= CALL_HOLD;
              break;                                                        //break loop
            }
          }
        }
      break;
      case dialing:
        if(gemergencycall!=0)                                               //emergency call
          gCallType[callid]=emergencycall;                                  //set call type
        else if(strncmp(gDialNumber, info, CALL_INFO_NUMBER_LENGTH)==0)     //info call
          gCallType[callid]=infocall;
        else if(strncmp(gDialNumber, service, CALL_INFO_NUMBER_LENGTH)==0)  //service call
          gCallType[callid]=servicecall;
        else                                                                //no emergency, info or service call
          gCallType[callid]=SINGLE_VOICE_CALL;                              //set calltype
        for(i=0;i<7;i++)                                                    //Check other CALLIDs and set corresponding CallOptions
        {
          if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)      // for hold calls
          {
            gCallOptions1[i]=FALSE;                                         //Deactivate all CallOptions for call on hold
            gCallOptions2[i]=FALSE;
          }
        }
      break;
      case ringing_waiting:
        gCallType[callid]=1;
        if(any_active_call && any_hold_call)                                //both active and hold calls
            gCallOptions1[callid]= MP_RACAWC;
        else if(any_active_call && !any_hold_call)                          //only active calls
        {
            gCallOptions1[callid]= MP_RACAWC + CALL_HOLD;
            gCallOptions2[callid]= MP_CHAWC;
        }
        else if(!any_active_call)                                           //no active calls
            gCallOptions1[callid]= ACCEPT_CALL;
      break;
      case active:
        if(any_hold_call)
        {
            gCallOptions1[callid]= MP_SWAP;                                 //activate calloptions for active call
            gCallOptions2[callid]= CC_JOIN;
        }
        else                                                                //no hold call
            gCallOptions1[callid]= CALL_HOLD;                               //activate calloptions for active call
        for(i=0;i<7;i++)                                                    //Check other CALLIDs
        {
          if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)      // for hold calls
          {
              gCallOptions1[i]= MP_SWAP;                                    //activate calloptions for call on hold
              gCallOptions2[i]= CC_JOIN;
          }
          else if(gCallState[i]==ringing_waiting)
          {
              if(any_active_call && any_hold_call)                          //both active and hold calls
                  gCallOptions1[i]= MP_RACAWC;
              else if(any_active_call && !any_hold_call)                    //only active calls
              {
                  gCallOptions1[i]= MP_RACAWC + CALL_HOLD;
                  gCallOptions2[i]= MP_CHAWC;
              }
          }
          else if(gCallState[i]==active)                                    //another active call in conference
          {
              if(any_hold_call)
              {
                  gCallOptions1[i]= MP_SWAP;                                //activate calloptions for active call
                  gCallOptions2[i]= CC_JOIN;
              }
              else                                                          //no hold call
                  gCallOptions1[i]= CALL_HOLD;                              //activate calloptions for active call
          }
        }
      break;
      case onhold:
        if(any_active_call)
        {
            gCallOptions1[callid]= MP_SWAP;
            gCallOptions2[callid]= CC_JOIN;
        }
        else                                                              //no active call
            gCallOptions1[callid]= RESUME_CALL;
        for(i=0;i<7;i++)                                                  //Check other CALLIDs
        {
          if(gCallState[i]==ringing_waiting)
          {
              if(any_active_call)
              {
                  gCallOptions1[i]= MP_RACAWC;
                  gCallOptions2[i]= MP_CHAWC;
              }
              else                                                        //no active call
                  gCallOptions1[i]= ACCEPT_CALL;
          }
          else if(gCallState[i]==active)                                  //for active calls
          {
              gCallOptions1[i]= MP_SWAP;
              gCallOptions2[i]= CC_JOIN;
          }
          else if(gCallState[i]==onhold)                                  //another hold call in conference
          {
              if(any_active_call)
              {
                  gCallOptions1[i]= MP_SWAP;                              //activate calloptions for hold call
                  gCallOptions2[i]= CC_JOIN;
              }
              else                                                        //no active call
                  gCallOptions1[i]= RESUME_CALL;                          //activate calloptions for hold call
          }
        }
      break;
      case INCOMING_ON_HOLD:
        if(any_active_call)
        {
            gCallOptions1[callid]= MP_SWAP;
            gCallOptions2[callid]= CC_JOIN;
        }
        else                                                              //no active call
            gCallOptions1[callid]= RESUME_CALL;
        for(i=0;i<7;i++)                                                  //Check other CALLIDs
        {
          if(gCallState[i]==ringing_waiting)
          {
              if(any_active_call)
              {
                  gCallOptions1[i]= MP_RACAWC;
                  gCallOptions2[i]= MP_CHAWC;
              }
              else                                                        //no active call
                  gCallOptions1[i]= ACCEPT_CALL;
          }
          else if(gCallState[i]==active)                                  //for active calls
          {
              gCallOptions1[i]= MP_SWAP;
              gCallOptions2[i]= CC_JOIN;
          }
        }
      break;
      default:
      break;
    }
    //************CallActivity*************
    gCallActivity=NOCALL;
    for(i=0;i<7;i++)
    {
      if(gCallState[i]!=idle)
      {
        if(gCallActivity<MULTIPARTYCALL)
          gCallActivity++;
      }
    }
    putvalue(env_FSG_CallActivity, gstring_callactivity[gCallActivity]);
    //*************************************
    //**********CallStates*****************
    //CallID0
    putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
    if(gCallState[0]==idle)
      putvalue(env_FSG_CallType_CallID_0, empty_string);
    else
      putvalue(env_FSG_CallType_CallID_0, gstring_calltype[gCallType[0]]);
    //CallID1
    putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
    if(gCallState[1]==idle)
      putvalue(env_FSG_CallType_CallID_1, empty_string);
    else
      putvalue(env_FSG_CallType_CallID_1, gstring_calltype[gCallType[1]]);
    //CallID2
    putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
    if(gCallState[2]==idle)
      putvalue(env_FSG_CallType_CallID_2, empty_string);
    else
      putvalue(env_FSG_CallType_CallID_2, gstring_calltype[gCallType[2]]);
    //CallID3
    putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
    if(gCallState[3]==idle)
      putvalue(env_FSG_CallType_CallID_3, empty_string);
    else
      putvalue(env_FSG_CallType_CallID_3, gstring_calltype[gCallType[3]]);
    //CallID4
    putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
    if(gCallState[4]==idle)
      putvalue(env_FSG_CallType_CallID_4, empty_string);
    else
      putvalue(env_FSG_CallType_CallID_4, gstring_calltype[gCallType[4]]);
    //CallID5
    putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
    if(gCallState[5]==idle)
      putvalue(env_FSG_CallType_CallID_5, empty_string);
    else
      putvalue(env_FSG_CallType_CallID_5, gstring_calltype[gCallType[5]]);
    //CallID6
    putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
    if(gCallState[6]==idle)
      putvalue(env_FSG_CallType_CallID_6, empty_string);
    else
      putvalue(env_FSG_CallType_CallID_6, gstring_calltype[gCallType[6]]);
    //***********Display Calloptions****************
    putvalue(env_FSG_CallState_Opt0_1_Bit0, gCallOptions1[0] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt0_1_Bit1,(gCallOptions1[0] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt0_1_Bit2,(gCallOptions1[0] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_Opt0_1_Bit3,(gCallOptions1[0] &0x08)/0x08);  //Bit3
    putvalue(env_FSG_CallState_Opt0_1_Bit4,(gCallOptions1[0] &0x10)/0x10);  //Bit4
    putvalue(env_FSG_CallState_Opt0_1_Bit5,(gCallOptions1[0] &0x20)/0x20);  //Bit5
    putvalue(env_FSG_CallState_Opt0_1_Bit6,(gCallOptions1[0] &0x40)/0x40);  //Bit6
    putvalue(env_FSG_CallState_Opt0_1_Bit7,(gCallOptions1[0] &0x80)/0x80);  //Bit7
    putvalue(env_FSG_CallState_Opt0_2_Bit0, gCallOptions2[0] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt0_2_Bit1,(gCallOptions2[0] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt0_2_Bit2,(gCallOptions2[0] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_CallOuDivert_0,gCallOutgoingDiverted_eCallConfirmationPending[0]);    //Bit0
    putvalue(env_FSG_CallState_Opt1_1_Bit0, gCallOptions1[1] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt1_1_Bit1,(gCallOptions1[1] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt1_1_Bit2,(gCallOptions1[1] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_Opt1_1_Bit3,(gCallOptions1[1] &0x08)/0x08);  //Bit3
    putvalue(env_FSG_CallState_Opt1_1_Bit4,(gCallOptions1[1] &0x10)/0x10);  //Bit4
    putvalue(env_FSG_CallState_Opt1_1_Bit5,(gCallOptions1[1] &0x20)/0x20);  //Bit5
    putvalue(env_FSG_CallState_Opt1_1_Bit6,(gCallOptions1[1] &0x40)/0x40);  //Bit6
    putvalue(env_FSG_CallState_Opt1_1_Bit7,(gCallOptions1[1] &0x80)/0x80);  //Bit7
    putvalue(env_FSG_CallState_Opt1_2_Bit0, gCallOptions2[1] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt1_2_Bit1,(gCallOptions2[1] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt1_2_Bit2,(gCallOptions2[1] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_CallOuDivert_1,gCallOutgoingDiverted_eCallConfirmationPending[1]);    //Bit1
    putvalue(env_FSG_CallState_Opt2_1_Bit0, gCallOptions1[2] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt2_1_Bit1,(gCallOptions1[2] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt2_1_Bit2,(gCallOptions1[2] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_Opt2_1_Bit3,(gCallOptions1[2] &0x08)/0x08);  //Bit3
    putvalue(env_FSG_CallState_Opt2_1_Bit4,(gCallOptions1[2] &0x10)/0x10);  //Bit4
    putvalue(env_FSG_CallState_Opt2_1_Bit5,(gCallOptions1[2] &0x20)/0x20);  //Bit5
    putvalue(env_FSG_CallState_Opt2_1_Bit6,(gCallOptions1[2] &0x40)/0x40);  //Bit6
    putvalue(env_FSG_CallState_Opt2_1_Bit7,(gCallOptions1[2] &0x80)/0x80);  //Bit7
    putvalue(env_FSG_CallState_Opt2_2_Bit0, gCallOptions2[2] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt2_2_Bit1,(gCallOptions2[2] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt2_2_Bit2,(gCallOptions2[2] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_CallOuDivert_2,gCallOutgoingDiverted_eCallConfirmationPending[2]);    //Bit2
    putvalue(env_FSG_CallState_Opt3_1_Bit0, gCallOptions1[3] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt3_1_Bit1,(gCallOptions1[3] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt3_1_Bit2,(gCallOptions1[3] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_Opt3_1_Bit3,(gCallOptions1[3] &0x08)/0x08);  //Bit3
    putvalue(env_FSG_CallState_Opt3_1_Bit4,(gCallOptions1[3] &0x10)/0x10);  //Bit4
    putvalue(env_FSG_CallState_Opt3_1_Bit5,(gCallOptions1[3] &0x20)/0x20);  //Bit5
    putvalue(env_FSG_CallState_Opt3_1_Bit6,(gCallOptions1[3] &0x40)/0x40);  //Bit6
    putvalue(env_FSG_CallState_Opt3_1_Bit7,(gCallOptions1[3] &0x80)/0x80);  //Bit7
    putvalue(env_FSG_CallState_Opt3_2_Bit0, gCallOptions2[3] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt3_2_Bit1,(gCallOptions2[3] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt3_2_Bit2,(gCallOptions2[3] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_CallOuDivert_3,gCallOutgoingDiverted_eCallConfirmationPending[3]);    //Bit3
    putvalue(env_FSG_CallState_Opt4_1_Bit0, gCallOptions1[4] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt4_1_Bit1,(gCallOptions1[4] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt4_1_Bit2,(gCallOptions1[4] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_Opt4_1_Bit3,(gCallOptions1[4] &0x08)/0x08);  //Bit3
    putvalue(env_FSG_CallState_Opt4_1_Bit4,(gCallOptions1[4] &0x10)/0x10);  //Bit4
    putvalue(env_FSG_CallState_Opt4_1_Bit5,(gCallOptions1[4] &0x20)/0x20);  //Bit5
    putvalue(env_FSG_CallState_Opt4_1_Bit6,(gCallOptions1[4] &0x40)/0x40);  //Bit6
    putvalue(env_FSG_CallState_Opt4_1_Bit7,(gCallOptions1[4] &0x80)/0x80);  //Bit7
    putvalue(env_FSG_CallState_Opt4_2_Bit0, gCallOptions2[4] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt4_2_Bit1,(gCallOptions2[4] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt4_2_Bit2,(gCallOptions2[4] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_CallOuDivert_4,gCallOutgoingDiverted_eCallConfirmationPending[4]);    //Bit4
    putvalue(env_FSG_CallState_Opt5_1_Bit0, gCallOptions1[5] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt5_1_Bit1,(gCallOptions1[5] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt5_1_Bit2,(gCallOptions1[5] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_Opt5_1_Bit3,(gCallOptions1[5] &0x08)/0x08);  //Bit3
    putvalue(env_FSG_CallState_Opt5_1_Bit4,(gCallOptions1[5] &0x10)/0x10);  //Bit4
    putvalue(env_FSG_CallState_Opt5_1_Bit5,(gCallOptions1[5] &0x20)/0x20);  //Bit5
    putvalue(env_FSG_CallState_Opt5_1_Bit6,(gCallOptions1[5] &0x40)/0x40);  //Bit6
    putvalue(env_FSG_CallState_Opt5_1_Bit7,(gCallOptions1[5] &0x80)/0x80);  //Bit7
    putvalue(env_FSG_CallState_Opt5_2_Bit0, gCallOptions2[5] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt5_2_Bit1,(gCallOptions2[5] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt5_2_Bit2,(gCallOptions2[5] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_CallOuDivert_5,gCallOutgoingDiverted_eCallConfirmationPending[5]);    //Bit5
    putvalue(env_FSG_CallState_Opt6_1_Bit0, gCallOptions1[6] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt6_1_Bit1,(gCallOptions1[6] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt6_1_Bit2,(gCallOptions1[6] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_Opt6_1_Bit3,(gCallOptions1[6] &0x08)/0x08);  //Bit3
    putvalue(env_FSG_CallState_Opt6_1_Bit4,(gCallOptions1[6] &0x10)/0x10);  //Bit4
    putvalue(env_FSG_CallState_Opt6_1_Bit5,(gCallOptions1[6] &0x20)/0x20);  //Bit5
    putvalue(env_FSG_CallState_Opt6_1_Bit6,(gCallOptions1[6] &0x40)/0x40);  //Bit6
    putvalue(env_FSG_CallState_Opt6_1_Bit7,(gCallOptions1[6] &0x80)/0x80);  //Bit7
    putvalue(env_FSG_CallState_Opt6_2_Bit0, gCallOptions2[6] &0x01);        //Bit0
    putvalue(env_FSG_CallState_Opt6_2_Bit1,(gCallOptions2[6] &0x02)/0x02);  //Bit1
    putvalue(env_FSG_CallState_Opt6_2_Bit2,(gCallOptions2[6] &0x04)/0x04);  //Bit2
    putvalue(env_FSG_CallState_CallOuDivert_6,gCallOutgoingDiverted_eCallConfirmationPending[6]);    //Bit6
  }
  CallState_Request(Data_REQ,0);  //send call state
}

void CallState_Indication(dword Indication_array [], byte indication, int datalength)
{
  byte temp;

  //init lokal variables
  temp=0;
  //********************

  write("FSG: CallState_Indication");
  switch(indication)
  {
    case DataGet_IND:
      CallState_Request(Data_REQ,0);  //send call state
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone callstate indication: unknown indication %d", indication);
    break;
  }
}

void CallState_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  write("FSG: CallState_Request");
  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch (request)
  {
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_CallState;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=(gCallType[0]+gCallState[0]*0x10);  //call state 0 (upper nibble) and call type 0 (lower nibble)
      requestarray[4]=gCallOptions1[0];
      requestarray[5]=gCallOptions2[0];
      requestarray[6]=(gCallType[1]+gCallState[1]*0x10);
      requestarray[7]=gCallOptions1[1];
      requestarray[8]=gCallOptions2[1];
      requestarray[9]=(gCallType[2]+gCallState[2]*0x10);
      requestarray[10]=gCallOptions1[2];
      requestarray[11]=gCallOptions2[2];
      requestarray[12]=(gCallType[3]+gCallState[3]*0x10);
      requestarray[13]=gCallOptions1[3];
      requestarray[14]=gCallOptions2[3];
      requestarray[15]=(gCallType[4]+gCallState[4]*0x10);
      requestarray[16]=gCallOptions1[4];
      requestarray[17]=gCallOptions2[4];
      requestarray[18]=(gCallType[5]+gCallState[5]*0x10);
      requestarray[19]=gCallOptions1[5];
      requestarray[20]=gCallOptions2[5];
      requestarray[21]=(gCallType[6]+gCallState[6]*0x10);
      requestarray[22]=gCallOptions1[6];
      requestarray[23]=gCallOptions2[6];
      requestarray[24]=gCallOutgoingDiverted_eCallConfirmationPending[0];                         //bit 0
      requestarray[24]=requestarray[24]+gCallOutgoingDiverted_eCallConfirmationPending[1]*0x02;   //bit 1
      requestarray[24]=requestarray[24]+gCallOutgoingDiverted_eCallConfirmationPending[2]*0x04;   //bit 2
      requestarray[24]=requestarray[24]+gCallOutgoingDiverted_eCallConfirmationPending[3]*0x08;   //bit 3
      requestarray[24]=requestarray[24]+gCallOutgoingDiverted_eCallConfirmationPending[4]*0x10;   //bit 4
      requestarray[24]=requestarray[24]+gCallOutgoingDiverted_eCallConfirmationPending[5]*0x20;   //bit 5
      requestarray[24]=requestarray[24]+gCallOutgoingDiverted_eCallConfirmationPending[6]*0x40;   //bit 6
      requestarray[24]=requestarray[24]+gCallOutgoingDiverted_eCallConfirmationPending[7]*0x80;   //bit 7
      requestarray[25]=gDisconnectReason;
      requestarray[26]=gCallState_Extension1;
      requestarray[27]=gCallState_Extension2;
      Offset=28;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);  //send CallState
    break;
    case Error_REQ:
      //BAP-header
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_CallState;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error); //send CallState
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone callstate_request: unknown request %d", request);
    break;
  }
}

//*************************************************************************
//*****************CallInfo************************************************
on envVar env_FSG_CallInfo_update
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    getvalue(env_FSG_CallInfo_PbName_0_s, gCallInfo_PbName[0]);
    getvalue(env_FSG_CallInfo_TelNumber_0_s, gCallInfo_TelNumber[0]);
    gCallInfo_Category[0] = getvalue(env_FSG_CallInfo_Category_0_s);
    getvalue(env_FSG_CallInfo_PbName_1_s, gCallInfo_PbName[1]);
    getvalue(env_FSG_CallInfo_TelNumber_1_s, gCallInfo_TelNumber[1]);
    gCallInfo_Category[1] =getvalue(env_FSG_CallInfo_Category_1_s);
    getvalue(env_FSG_CallInfo_PbName_2_s, gCallInfo_PbName[2]);
    getvalue(env_FSG_CallInfo_TelNumber_2_s, gCallInfo_TelNumber[2]);
    gCallInfo_Category[2] =getvalue(env_FSG_CallInfo_Category_2_s);
    getvalue(env_FSG_CallInfo_PbName_3_s, gCallInfo_PbName[3]);
    getvalue(env_FSG_CallInfo_TelNumber_3_s, gCallInfo_TelNumber[3]);
    gCallInfo_Category[3] =getvalue(env_FSG_CallInfo_Category_3_s);
    getvalue(env_FSG_CallInfo_PbName_4_s, gCallInfo_PbName[4]);
    getvalue(env_FSG_CallInfo_TelNumber_4_s, gCallInfo_TelNumber[4]);
    gCallInfo_Category[4] =getvalue(env_FSG_CallInfo_Category_4_s);
    getvalue(env_FSG_CallInfo_PbName_5_s, gCallInfo_PbName[5]);
    getvalue(env_FSG_CallInfo_TelNumber_5_s, gCallInfo_TelNumber[5]);
    gCallInfo_Category[5] =getvalue(env_FSG_CallInfo_Category_5_s);
    getvalue(env_FSG_CallInfo_PbName_6_s, gCallInfo_PbName[6]);
    getvalue(env_FSG_CallInfo_TelNumber_6_s, gCallInfo_TelNumber[6]);
    gCallInfo_Category[6] =getvalue(env_FSG_CallInfo_Category_6_s);
    CallInfo_Request(Data_REQ,0);
  }
}

void CallInfo_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch (request)
  {
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_CallInfo; //Fct.-ID
      requestarray[2]=request;
      Offset=3;
      //*************************************************
      requestarray[Offset]=strlen(gCallInfo_PbName[0]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_PbName[0]);i++)
      {
        requestarray[Offset]=gCallInfo_PbName[0][i];
        Offset++;
      }
      requestarray[Offset]=strlen(gCallInfo_TelNumber[0]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_TelNumber[0]);i++)
      {
        requestarray[Offset]=gCallInfo_TelNumber[0][i];
        Offset++;
      }
      requestarray[Offset]=gCallInfo_Category[0];
      Offset++;
      //*************************************************
      //*************************************************
      requestarray[Offset]=strlen(gCallInfo_PbName[1]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_PbName[1]);i++)
      {
        requestarray[Offset]=gCallInfo_PbName[1][i];
        Offset++;
      }
      requestarray[Offset]=strlen(gCallInfo_TelNumber[1]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_TelNumber[1]);i++)
      {
        requestarray[Offset]=gCallInfo_TelNumber[1][i];
        Offset++;
      }
      requestarray[Offset]=gCallInfo_Category[1];
      Offset++;
      //*************************************************
      //*************************************************
      requestarray[Offset]=strlen(gCallInfo_PbName[2]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_PbName[2]);i++)
      {
        requestarray[Offset]=gCallInfo_PbName[2][i];
        Offset++;
      }
      requestarray[Offset]=strlen(gCallInfo_TelNumber[2]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_TelNumber[2]);i++)
      {
        requestarray[Offset]=gCallInfo_TelNumber[2][i];
        Offset++;
      }
      requestarray[Offset]=gCallInfo_Category[2];
      Offset++;
      //*************************************************
      //*************************************************
      requestarray[Offset]=strlen(gCallInfo_PbName[3]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_PbName[3]);i++)
      {
        requestarray[Offset]=gCallInfo_PbName[3][i];
        Offset++;
      }
      requestarray[Offset]=strlen(gCallInfo_TelNumber[3]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_TelNumber[3]);i++)
      {
        requestarray[Offset]=gCallInfo_TelNumber[3][i];
        Offset++;
      }
      requestarray[Offset]=gCallInfo_Category[3];
      Offset++;
      //*************************************************
      //*************************************************
      requestarray[Offset]=strlen(gCallInfo_PbName[4]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_PbName[4]);i++)
      {
        requestarray[Offset]=gCallInfo_PbName[4][i];
        Offset++;
      }
      requestarray[Offset]=strlen(gCallInfo_TelNumber[4]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_TelNumber[4]);i++)
      {
        requestarray[Offset]=gCallInfo_TelNumber[4][i];
        Offset++;
      }
      requestarray[Offset]=gCallInfo_Category[4];
      Offset++;
      //*************************************************
      //*************************************************
      requestarray[Offset]=strlen(gCallInfo_PbName[5]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_PbName[5]);i++)
      {
        requestarray[Offset]=gCallInfo_PbName[5][i];
        Offset++;
      }
      requestarray[Offset]=strlen(gCallInfo_TelNumber[5]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_TelNumber[5]);i++)
      {
        requestarray[Offset]=gCallInfo_TelNumber[5][i];
        Offset++;
      }
      requestarray[Offset]=gCallInfo_Category[5];
      Offset++;
      //*************************************************
      //*************************************************
      requestarray[Offset]=strlen(gCallInfo_PbName[6]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_PbName[6]);i++)
      {
        requestarray[Offset]=gCallInfo_PbName[6][i];
        Offset++;
      }
      requestarray[Offset]=strlen(gCallInfo_TelNumber[6]);
      Offset++;
      for(i=0;i<strlen(gCallInfo_TelNumber[6]);i++)
      {
        requestarray[Offset]=gCallInfo_TelNumber[6][i];
        Offset++;
      }
      requestarray[Offset]=gCallInfo_Category[6];
      Offset++;
      //*************************************************
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);  //send CallState
    break;
    case Error_REQ:
      //BAP-header
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_CallState;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error); //send CallState
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone CallInfo_Request: unknown request %d", request);
    break;
  }
}

void CallInfo_Indication(dword Indication_array [], byte indication, int datalength)
{
  byte temp;

  //init lokal variables
  temp=0;
  //********************
  switch(indication)
  {
    case DataGet_IND:
      CallInfo_Request(Data_REQ,0); //send call Info
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone CallInfo_Indication: unknown indication %d", indication);
    break;
  }
}

on timer checknetworktimer
{
  int length;
  int strlength;
  int i;

  //init lokal variables
  length=0;
  //********

  //send Disconnect Reason
  gDisconnectReason=connectedline_busy;
  putvalue(env_FSG_DisconnectReason, gDisconnectReason);
  CallState_Request (Data_REQ, 0);

  //call info
  strncpy(gCallInfo_PbName[gcallID], gDialNumber_name, CALL_INFO_NAME_LENGTH);
  strncpy(gCallInfo_TelNumber[gcallID], gDialNumber, CALL_INFO_NUMBER_LENGTH);
  strlength = strlen(gDialNumber_name);
  for(i = 0; i < CALL_INFO_NAME_LENGTH; i++)
  {
      if(i < strlength)
          gCallInfo_PbName_hex[gcallID][i] = gDialNumber_name[i];
      else
          gCallInfo_PbName_hex[gcallID][i] = 0;
  }

  switch(gcallID)
  {
    case 0:
      putvalue(env_FSG_CallInfo_PbName_0, gCallInfo_PbName[0]);
      putvalue(env_FSG_CallInfo_PbName_0_data, gCallInfo_PbName_hex[0]);
      putvalue(env_FSG_CallInfo_TelNumber_0, gCallInfo_TelNumber[0]);
    break;
    case 1:
      putvalue(env_FSG_CallInfo_PbName_1, gCallInfo_PbName[1]);
      putvalue(env_FSG_CallInfo_PbName_1_data, gCallInfo_PbName_hex[1]);
      putvalue(env_FSG_CallInfo_TelNumber_1, gCallInfo_TelNumber[1]);
    break;
    case 2:
      putvalue(env_FSG_CallInfo_PbName_2, gCallInfo_PbName[2]);
      putvalue(env_FSG_CallInfo_PbName_2_data, gCallInfo_PbName_hex[2]);
      putvalue(env_FSG_CallInfo_TelNumber_2, gCallInfo_TelNumber[2]);
    break;
    case 3:
      putvalue(env_FSG_CallInfo_PbName_3, gCallInfo_PbName[3]);
      putvalue(env_FSG_CallInfo_PbName_3_data, gCallInfo_PbName_hex[3]);
      putvalue(env_FSG_CallInfo_TelNumber_3, gCallInfo_TelNumber[3]);
    break;
    case 4:
      putvalue(env_FSG_CallInfo_PbName_4, gCallInfo_PbName[4]);
      putvalue(env_FSG_CallInfo_PbName_4_data, gCallInfo_PbName_hex[4]);
      putvalue(env_FSG_CallInfo_TelNumber_4, gCallInfo_TelNumber[4]);
    break;
    case 5:
      putvalue(env_FSG_CallInfo_PbName_5, gCallInfo_PbName[5]);
      putvalue(env_FSG_CallInfo_PbName_5_data, gCallInfo_PbName_hex[5]);
      putvalue(env_FSG_CallInfo_TelNumber_5, gCallInfo_TelNumber[5]);
    break;
    case 6:
      putvalue(env_FSG_CallInfo_PbName_6, gCallInfo_PbName[6]);
      putvalue(env_FSG_CallInfo_PbName_6_data, gCallInfo_PbName_hex[6]);
      putvalue(env_FSG_CallInfo_TelNumber_6, gCallInfo_TelNumber[6]);
    break;
    default:
      write("error checknetworktimer: unknown call-ID: %d", gcallID);
    break;
  }
  CallInfo_Request(Data_REQ,0);
  //settimer(dialnumber_changearraytimer, 300);
  gstatus_dialnumber_changearraytimer=1;
}

//*************************************************************************
//*****************CallDuration********************************************
on envVar env_FSG_CallDurationSync_OK
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    gCallDuration_1=getvalue(env_FSG_CallDurationSync_1);
    gCallDuration_2=getvalue(env_FSG_CallDurationSync_2);
    gCallDuration_Relation1[0]=getvalue(env_FSG_CallDuration_Rel1_Bit0);
    gCallDuration_Relation2[0]=getvalue(env_FSG_CallDuration_Rel2_Bit0);
    gCallDuration_Relation1[1]=getvalue(env_FSG_CallDuration_Rel1_Bit1);
    gCallDuration_Relation2[1]=getvalue(env_FSG_CallDuration_Rel2_Bit1);
    gCallDuration_Relation1[2]=getvalue(env_FSG_CallDuration_Rel1_Bit2);
    gCallDuration_Relation2[2]=getvalue(env_FSG_CallDuration_Rel2_Bit2);
    gCallDuration_Relation1[3]=getvalue(env_FSG_CallDuration_Rel1_Bit3);
    gCallDuration_Relation2[3]=getvalue(env_FSG_CallDuration_Rel2_Bit3);
    gCallDuration_Relation1[4]=getvalue(env_FSG_CallDuration_Rel1_Bit4);
    gCallDuration_Relation2[4]=getvalue(env_FSG_CallDuration_Rel2_Bit4);
    gCallDuration_Relation1[5]=getvalue(env_FSG_CallDuration_Rel1_Bit5);
    gCallDuration_Relation2[5]=getvalue(env_FSG_CallDuration_Rel2_Bit5);
    gCallDuration_Relation1[6]=getvalue(env_FSG_CallDuration_Rel1_Bit6);
    gCallDuration_Relation2[6]=getvalue(env_FSG_CallDuration_Rel2_Bit6);
    CallDuration_Request(Data_REQ,0);
  }
}

void CallDuration_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request)
  {
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;    //LSG-ID
      requestarray[1]=FctID_CallDuration; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gCallDuration_Relation1[0]+     gCallDuration_Relation1[1]*0x02+
                      gCallDuration_Relation1[2]*0x04+gCallDuration_Relation1[3]*0x08+
                      gCallDuration_Relation1[4]*0x10+gCallDuration_Relation1[5]*0x20+
                      gCallDuration_Relation1[6]*0x40;
      requestarray[4]=gCallDuration_1 & 0xFF;
      requestarray[5]=gCallDuration_1 / 0x100;
      requestarray[6]=gCallDuration_Relation2[0]+     gCallDuration_Relation2[1]*0x02+
                      gCallDuration_Relation2[2]*0x04+gCallDuration_Relation2[3]*0x08+
                      gCallDuration_Relation2[4]*0x10+gCallDuration_Relation2[5]*0x20+
                      gCallDuration_Relation2[6]*0x40;
      requestarray[7]=gCallDuration_2 & 0xFF;
      requestarray[8]=gCallDuration_2 / 0x100;
      Offset=9;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;    //LSG-ID
      requestarray[1]=FctID_CallDuration; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone CallDuration_Request: unknown request %d", request);
    break;
  }
}

void CallDuration_Indication (dword Indication_array [], byte indication, int datalength)
{
  switch (indication)
  {
    case DataGet_IND:
      CallDuration_Request(Data_REQ, 0);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone CallDuration_Indication: unknown indication %d", indication);
    break;
  }
}

//*************************************************************************
//*****************AudioMuteOnOff******************************************
on envVar env_FSG_AMOO_Update
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    gHandsFreeOnOff           =getvalue(env_FSG_HandsFreeOnOff);
    gMicroMuteOnOff           =getvalue(env_FSG_MicroMuteOnOff);
    gRingToneMuteOnOff        =getvalue(env_FSG_RingToneMuteOnOff);
    gHandsFreeSupport         =getvalue(env_FSG_AMOO_FS_Bit0);
    gMicroMuteSupport         =getvalue(env_FSG_AMOO_FS_Bit1);
    gRingToneMuteSupport      =getvalue(env_FSG_AMOO_FS_Bit2);
    gAudioMuteOnOff_Extension1=getvalue(env_FSG_AMOO_Extension1);
    gAudioMuteOnOff_Extension2=getvalue(env_FSG_AMOO_Extension2);
    gAudioMuteOnOff_Extension3=getvalue(env_FSG_AMOO_Extension3);
    gAudioMuteOnOff_Extension4=getvalue(env_FSG_AMOO_Extension4);
    gAudioControl             =gHandsFreeOnOff+(gMicroMuteOnOff*0x02)+(gRingToneMuteOnOff*0x04);
    gFunctionSupport          =gHandsFreeSupport+(gMicroMuteSupport*0x02)+(gRingToneMuteSupport*0x04);
    AudioMuteOnOff_Request(Data_REQ, 0);
  }
}

void AudioMuteOnOff_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request){
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;      //LSG-ID
      requestarray[1]=FctID_AudioMuteOnOff; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gAudioControl;
      requestarray[4]=gFunctionSupport;
      requestarray[5]=gAudioMuteOnOff_Extension1;
      requestarray[6]=gAudioMuteOnOff_Extension2;
      requestarray[7]=gAudioMuteOnOff_Extension3;
      requestarray[8]=gAudioMuteOnOff_Extension4;
      Offset=9;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;      //LSG-ID
      requestarray[1]=FctID_AudioMuteOnOff; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone AudioMuteOnOff_Request: unknown request %d", request);
    break;
  }
}

void AudioMuteOnOff_Indication (dword Indication_array [], byte indication, int datalength)
{
  byte byHandsFree, byMicroMute, byRingTone;

  switch (indication)
  {
    case DataSetGet_IND:
      byHandsFree =Indication_array[3]&0x01;
      byMicroMute =(Indication_array[3]&0x02)/0x02;
      byRingTone  =(Indication_array[3]&0x04)/0x04;
      if(gHandsFreeSupport!=0)
      {
        putValue(env_FSG_HandsFreeOnOff,byHandsFree);
        gHandsFreeOnOff=byHandsFree;
      }
      else
      {
        putValue(env_FSG_HandsFreeOnOff,0);
        gHandsFreeOnOff=0;
      }
      if(gMicroMuteSupport!=0)
      {
        putValue(env_FSG_MicroMuteOnOff,byMicroMute);
        gMicroMuteOnOff=byMicroMute;
      }
      else
      {
        putValue(env_FSG_MicroMuteOnOff,0);
        gMicroMuteOnOff=0;
      }
      if(gRingToneMuteSupport!=0)
      {
        putValue(env_FSG_RingToneMuteOnOff,byRingTone);
        gRingToneMuteOnOff=byRingTone;
      }
      else
      {
        putValue(env_FSG_RingToneMuteOnOff,0);
        gRingToneMuteOnOff=0;
      }
      gAudioControl=gHandsFreeOnOff+(gMicroMuteOnOff*0x02)+(gRingToneMuteOnOff*0x04);
      AudioMuteOnOff_Request(Data_REQ, 0);                //send audiomute status
    break;
    case DataGet_IND:
      AudioMuteOnOff_Request(Data_REQ, 0);                //send audiomute status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone AudioMuteOnOff_Indication: unknown indication %d", indication);
    break;
  }
}

//*************************************************************************
//*****************MissedCallIndication************************************
on envVar env_FSG_MissedCallIndication
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    gMissedCalls=getvalue(env_FSG_MissedCalls);
    gMissedCallIndication_Extension1=getvalue(env_FSG_MCI_Extension1);
    gMissedCallIndication_Extension2=getvalue(env_FSG_MCI_Extension2);
    gMissedCallIndication_Extension3=getvalue(env_FSG_MCI_Extension3);
    gMissedCallIndication_Extension4=getvalue(env_FSG_MCI_Extension4);
    MissedCallIndication_Request(Data_REQ, 0);            //send data to RNS
  }
}

void MissedCallIndication_Indication (dword Indication_array [], byte indication, int datalength)
{
  int missedcalls;

  //init lokal variables
  missedcalls=0;
  //********************

  switch(indication){
    case DataSetGet_IND:
      missedcalls=Indication_array[3]+Indication_array[4]*0x100;
      if(missedcalls!=0)                //invalid value for set/ setget
      {
        writelineEx(gError_Trace, 0, "FSG-Telephone MissedCallIndication_Indication: invalid setget-value for missedcalls %d", missedcalls);
        MissedCallIndication_Request(Error_REQ, Terror_unknownapllicationerror);//send error-message to RNS
      }
      else
      {
        gMissedCalls=0;
        putvalue(env_FSG_MissedCalls, gMissedCalls);
        MissedCallIndication_Request(Data_REQ, 0);            //send data to RNS
      }
    break;
    case DataGet_IND:
      MissedCallIndication_Request(Data_REQ, 0);              //send data to RNS
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone MissedCallIndication_Indication: invalid indication %d", indication);
    break;
    }
}

void MissedCallIndication_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request){
    case Data_REQ:
      requestarray[0]=LSGID_Telephone;                //LSG-ID
      requestarray[1]=FctID_MissedCallIndication;     //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gMissedCalls & 0x00ff;          //Lowbyte of MissedCall
      requestarray[4]=(gMissedCalls & 0xff00)/0x100;  //Highbyte of MissedCall
      requestarray[5]=gMissedCallIndication_Extension1;
      requestarray[6]=gMissedCallIndication_Extension2;
      requestarray[7]=gMissedCallIndication_Extension3;
      requestarray[8]=gMissedCallIndication_Extension4;
      Offset=9;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;                //LSG-ID
      requestarray[1]=FctID_MissedCallIndication;     //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone MissedCallIndication_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************AutomaticRedial*****************************************
on envVar env_FSG_AR_Update
{
  if(gFSG_Telephone_PowerOnOff == Power_on && getvalue(this))
  {
    gAutomaticRedialState = getvalue(env_FSG_AutomaticRedial_Active);
    gAutomaticRedial_Extension1 = getvalue(env_FSG_AR_Extension1);
    gAutomaticRedial_Extension2 = getvalue(env_FSG_AR_Extension2);
    gAutomaticRedial_Extension3 = getvalue(env_FSG_AR_Extension3);
    gAutomaticRedial_Extension4 = getvalue(env_FSG_AR_Extension4);
    gAutomaticRedial_Extension5 = getvalue(env_FSG_AR_Extension5);
    AutomaticRedial_Request(Data_REQ, 0);
  }
}

void AutomaticRedial_Request(byte request, byte errorcode)
{
  int i, offset;
  dword requestarray[BAP_buffer_size];

  offset = 0;
  for(i = 0; i < BAP_buffer_size; i++)
    requestarray[i] = 0;

  switch(request){
    case Data_REQ:
      requestarray[0] = LSGID_Telephone;          //LSG-ID
      requestarray[1] = FctID_AutomaticRedial;    //Fct.-ID
      requestarray[2] = request;
      requestarray[3] = gAutomaticRedialState;
      requestarray[4] = gAutomaticRedial_Extension1;
      requestarray[5] = gAutomaticRedial_Extension2;
      requestarray[6] = gAutomaticRedial_Extension3;
      requestarray[7] = gAutomaticRedial_Extension4;
      requestarray[8] = gAutomaticRedial_Extension5;
      offset = 9;
      set_status_requestbuffer(requestarray, offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0] = LSGID_Telephone;          //LSG-ID
      requestarray[1] = FctID_AutomaticRedial;    //Fct.-ID
      requestarray[2] = request;
      requestarray[3] = errorcode;
      offset = 4;
      set_status_requestbuffer(requestarray, offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone AutomaticRedial_Request: invalid request %d", request);
    break;
  }
}

void AutomaticRedial_Indication (dword indication_array[], byte indication, int datalength)
{
  switch (indication)
  {
    case DataSetGet_IND:
      gAutomaticRedialState = (indication_array[3] & 0x01);
      gAutomaticRedial_Extension1 = (indication_array[4]);
      gAutomaticRedial_Extension2 = (indication_array[5]);
      gAutomaticRedial_Extension3 = (indication_array[6]);
      gAutomaticRedial_Extension4 = (indication_array[7]);
      gAutomaticRedial_Extension5 = (indication_array[8]);
      putvalue(env_FSG_AutomaticRedial_Active, gAutomaticRedialState);
      putvalue(env_FSG_AR_Extension1, gAutomaticRedial_Extension1);
      putvalue(env_FSG_AR_Extension2, gAutomaticRedial_Extension2);
      putvalue(env_FSG_AR_Extension3, gAutomaticRedial_Extension3);
      putvalue(env_FSG_AR_Extension4, gAutomaticRedial_Extension4);
      putvalue(env_FSG_AR_Extension5, gAutomaticRedial_Extension5);
      AutomaticRedial_Request(Data_REQ, 0);
    break;
    case DataGet_IND:
      AutomaticRedial_Request(Data_REQ, 0);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone AutomaticRedial_Indication: unknown indication %d", indication);
    break;
  }
}

//*************************************************************************
//*****************DialNumber**********************************************
on envVar env_FSG_DialNumber
{
  int nulength, nalength, hexnalength, is_emergency_call;
  byte valid=0;
  char empty_string [3];
  int i;
  byte useHexString;
  byte hexName[DIAL_NUMBER_NAME_LENGTH];

  //init lokal variables
  nulength=0;     //stringlength of number
  nalength=0;     //stringlenght of name
  i = 0;
  for(i=0;i<3;i++)
    empty_string[i]=0;
  //********************

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    // check if any call is still dialing
    for(i = 0; i < 7; i++)
    {
      if(gCallState[i] == dialing)
        return;
      if(gCallState[i] == active)
        return;
    }
    if(gDialNumber_status!=0)                                             //method is still active
    {
      //write("FSG-Telephone: Method DialNumber still in process!");      //debug
    }
    else
    {
      gCallStartedFromASG = 0;
      gDialNumber_status = 1;                                             //method "dialnumber" is active
      for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)                              //delete dial-number array
        gDialNumber[i] = 0;
      for(i=0;i<DIAL_NUMBER_NAME_LENGTH;i++)                              //delete dial-number-name array
      {
        hexName[i] = 0;
        gDialNumber_name[i] = 0;
      }
      getvalue(env_FSG_DialNumber_TelNumber, gDialNumber);
      nulength=strlen(gDialNumber);
      // read hex data and determin the length
      getvalue(env_FSG_DialNumber_Name_hex, hexName);
      for(i = 0; i < DIAL_NUMBER_NAME_LENGTH; i++)
      {
        if(hexName[i] == 0)
          break;
      }
      hexnalength = i;
      if(hexnalength > 0)
      {
        useHexString = 1;
        for(i = 0; i < DIAL_NUMBER_NAME_LENGTH; i++)
        {
          if(i < hexnalength)
            gDialNumber_name[i] = hexName[i];
          if(i == hexnalength)
          {
            gDialNumber_name[i] = '\0';
            break;
          }
        }
        putValue(env_FSG_DialNumber_Name, gDialNumber_name);
      }
      else
      {
          getvalue(env_FSG_DialNumber_Name, gDialNumber_name);
          useHexString = 0;
      }
      nalength=strlen(gDialNumber_name);
      //********verify number and PbName**********
      //******Number*********
      if (nulength==0)                                                      //no number
        gDialNumber_status=0;                                               //method "dialnumber" is finished
      else                                                                  //valid
        valid=tel_number_valid (gDialNumber, nulength);                     //check each part of the new number of correctness
      //*****end number*******
      if(valid==TRUE)                                                       //valid number
      {
        //********Name*********
        if(nalength>0)
        {
          //write("FSG-Telephone dialnumber, numbername: %s", gDialNumber_name);//debug
          //gnumbersearchphonebook=2;
          //settimer(numbersearchphonebooktimer, 5);
        }
        else if(strncmp(gDialNumber, info, CALL_INFO_NUMBER_LENGTH)==0)      //InfoCall
        {
          strncpy(gDialNumber_name, info_pbname, CALL_INFO_NAME_LENGTH);
          //gdialnumber_numbertype=infocall;
          //gnumbersearchphonebook=2;
          //settimer(numbersearchphonebooktimer, 5);
        }
        else if(strncmp(gDialNumber, service, CALL_INFO_NUMBER_LENGTH)==0)   //ServiceCall
        {
          strncpy(gDialNumber_name, service_pbname, CALL_INFO_NAME_LENGTH);
          //gdialnumber_numbertype=servicecall;
          //gnumbersearchphonebook=2;
          //settimer(numbersearchphonebooktimer, 5);
        }
        else        //no name available
        {
          //putvalue(env_FSG_phonebook_number, gDialNumber);
          //gnumbersearchphonebook=1;
          //settimer(numbersearchphonebooktimer, 100);
        }
        //******end name*******
      }
      else
      {
        //write("number invalid");          //debug
        gDialNumber_status=0;
      }
      //**********end number-/name-verification*******
      //********check registerstate and callstate***********
      is_emergency_call = detect_emergency_number();
      if(PhoneModuleOn != gTel_State && MobileOn != gTel_State)               //GMS-module or mobile not active
      {
        gDialNumber_status = 0;                                               //method is finished
      }
      else if(gRegisterState != 1)                                            //not registered
      {
        if(is_emergency_call != 1)                                            //not registered and no emergency call
          gDialNumber_status=0;                                               //method "dialnumber" is finished
        else                                                                  //emergency call but not registered
        {
          if (gLockState != nolock)                                           //emergency call but not registered and no SIM
            gemergencycall = 3;
          else                                                                //emergency call but not registered and SIM OK
            gemergencycall = 2;
          putvalue(env_FSG_NetworkProviderState, 1);
        }
      }
      else                                                                    //registered and one call-ID-state is "idle" and no other call-ID-state is "active/dialing/disconnecting"
      {
        gemergencycall = (is_emergency_call == 1) ? 1 : 0;
        if(!valid)                                                            //number invalid
          gDialNumber_status=0;                                               //method "dialnumber" is finished
        else
        {
          if(gConfirmCall == 1)                                               // call needs to be confirmed manually ?
          {
            gCallOutgoingDiverted_eCallConfirmationPending[7] = 1;
            CallState_Request(Data_REQ, 0);                                   // send CallState.Status: 'eCall confirmation pending' = true
            gDialNumber_Result = 0x0a;                                        // not successful - confirm emergency call
            DialNumber_Request(Result_REQ, 0);
          }
          else
          {
            gcallID = callstates_status(dialing);                             //asks for free Call-ID
            if(gcallID == 0xff)
              gDialNumber_status = 0;
            settimer(checknetworktimer, gtime_checknetworktimer);
          }
        }
      }
    }
  }
}

void DialNumber_Indication (dword Indication_array [], byte indication, int datalength)
{
  int number_length, name_length, number_valid, i, provider, is_emergency_call;

  number_length = 0;
  name_length = 0;
  number_valid = 0;
  i = 0;
  provider = 0;

  switch(indication)
  {
    case Processing_CNF:
      gDialNumber_AsgId=Indication_array[3]/0x10;
      putValue(env_FSG_DialNumber_AsgID,gDialNumber_AsgId);
      DialNumber_Request(Processing_REQ, 0);                            //send Processing
    break;
    case StartResult_IND:
      /*
      write("DialNumber - Indication with StartResult...");
      if(gDialNumber_status != 0)                                       //method is still active
      {
        write("DialNumber - Error: method is still active!");
        DialNumber_Request(Error_REQ, Terror_unknownapllicationerror);  // send error-message
        break;
      }
      // check if any call is still dialing
      for(i = 0; i < 7; i++)
      {
        if(gCallState[i] == dialing)
        {
          write("DialNumber - Error: call #%d is still dialing!",i);
          DialNumber_Request(Error_REQ, Terror_activecallpresentdialing);
          return;
        }
      }
      // send error if any call is still active
      for(i = 0; i < 7; i++)
      {
        if(gCallState[i] == active)
        {
          write("DialNumber - Error: call #%d is still active!",i);
          DialNumber_Request(Error_REQ, Terror_notsuccessful);
          return;
        }
      }
      */
      //get ASG-ID
      gDialNumber_AsgId=Indication_array[3]/0x10;
      putValue(env_FSG_DialNumber_AsgID,gDialNumber_AsgId);
      //get Number and Name
      for(i = 0; i < CALL_INFO_NUMBER_LENGTH; i++)
        gDialNumber[i] = 0;
      for(i = 0; i < DIAL_NUMBER_NAME_LENGTH; i++)
        gDialNumber_name[i] = 0;
      number_length = Indication_array[4];
      name_length = Indication_array[number_length + 5];
      if(datalength == number_length + name_length + 6)
      {
        //read
        if(number_length>0)
        {
          for (i = 0; i < number_length; i++)
            gDialNumber[i] = Indication_array[i+5];
          putvalue(env_FSG_DialNumber_TelNumber,gDialNumber);
        }
        if(name_length>0)
        {
          for (i = 0; i < name_length; i++)
            gDialNumber_name[i] = Indication_array[i + 6 + number_length];
          putvalue(env_FSG_DialNumber_Name,gDialNumber_name);
        }
      }
      //get Result & send
      gDialNumber_Result=getvalue(env_FSG_DialNumber_Result);
      DialNumber_Request(Result_REQ, 0);

      /*
      //check data length
      number_length = Indication_array[4];
      name_length = Indication_array[number_length + 5];
      if(datalength != number_length + name_length + 6)                   // BAP-array datalength error
      {
        write("DialNumber - Error: datalength=%d, number_length=%d, name_length=%d!",datalength,number_length,name_length);
        DialNumber_Request(Error_REQ, Terror_datainvalid);                // send error-message
        break;
      }
      gCallStartedFromASG = 1;
      gDialNumber_status = 1;                                             //method "DialNumber" is now active

      for(i = 0; i < CALL_INFO_NUMBER_LENGTH; i++)
        gDialNumber[i] = 0;
      for(i = 0; i < DIAL_NUMBER_NAME_LENGTH; i++)
        gDialNumber_name[i] = 0;

      // verify number and name
      if(number_length == 0)                                              //no number
      {
        write("DialNumber - Error: no number, length=0!");
        DialNumber_Request(Error_REQ, Terror_datainvalid);                //send error-message
        gDialNumber_status = 0;                                           //method "dialnumber" is finished
        break;
      }
      //read number
      for (i = 0; i < number_length; i++)
        gDialNumber[i] = Indication_array[i+5];
      number_valid = tel_number_valid(gDialNumber, number_length);        // check number
      if(number_valid != 1)
      {
        write("DialNumber - Number invalid!");
        gDialNumber_Result = NS_NUMBER_INVALID;
        DialNumber_Request(Result_REQ, 0);
        gDialNumber_status = 0;
        break;
      }
      if(name_length > 0)                                                 // PbName was sent
      {
        write("DialNumber - Get name from indication...");
        for (i = 0; i < name_length; i++)                                 //read name from indication array
          gDialNumber_name[i] = Indication_array[i + 6 + number_length];
        //gnumbersearchphonebook = 2;
        //settimer(numbersearchphonebooktimer, 5);
      }
      else if(strncmp(gDialNumber, info, CALL_INFO_NUMBER_LENGTH) == 0)
      {
        write("DialNumber - Get name from info...");
        strncpy(gDialNumber_name, info_pbname, CALL_INFO_NAME_LENGTH);
        //gdialnumber_numbertype = infocall;
        //gnumbersearchphonebook = 2;
        //settimer(numbersearchphonebooktimer, 5);
      }
      else if(strncmp(gDialNumber, service, CALL_INFO_NUMBER_LENGTH) == 0)
      {
        write("DialNumber - Get name from service...");
        strncpy(gDialNumber_name, service_pbname, CALL_INFO_NAME_LENGTH);
        //gdialnumber_numbertype = servicecall;
        //gnumbersearchphonebook = 2;
        //settimer(numbersearchphonebooktimer, 5);
      }
      else
      {
        write("DialNumber - Get name/number from other...");
        putvalue(env_FSG_phonebook_number, gDialNumber);
        //gnumbersearchphonebook = 1;
        //settimer(numbersearchphonebooktimer, 100);
      }
      // GMS-module or mobile not active ?
      if(PhoneModuleOn != gTel_State && MobileOn != gTel_State)
      {
        write("DialNumber - Network N/A");
        gDialNumber_Result = NS_NO_NETWORK;
        DialNumber_Request(Result_REQ, 0);
        gDialNumber_status = 0;                                           //method is finished
        break;
      }
      is_emergency_call = detect_emergency_number();
      if(gRegisterState != 1 )                                            // not registered
      {
        write("DialNumber - Not registered");
        if(is_emergency_call != 1)                                          // not registered and no emergency call
        {
          write("DialNumber - No eCall");
          gDialNumber_Result = NS_NOTREGISTERED_ECALLONLY;
          DialNumber_Request(Result_REQ, 0);
          gDialNumber_status = 0;                                           // method is finished
          break;
        }
        else
        {
          if (gLockState != nolock)                                         //emergency call but not registered and no SIM
          {
            write("DialNumber - eCall, but not registered and no SIM");
            gemergencycall=3;
          }
          else                                                              //emergency call but not registered and SIM OK
          {
            write("DialNumber - eCall, but not registered and SIM ok");
            gemergencycall=2;
          }
          // search for provider
          write("DialNumber - search for provider...");
          while(provider == 0)
            provider = random(4);
          putvalue(env_FSG_NetworkProviderState, 1);
          //putvalue(env_FSG_networkprovider, provider); //new provider
        }
      }
      else
      {
        gemergencycall = (is_emergency_call == 1) ? 1 : 0;
        if(gConfirmCall == 1)                                               // call needs to be confirmed manually ?
        {
          write("DialNumber - eCall needs to be confirmed manually...");
          gCallOutgoingDiverted_eCallConfirmationPending[7] = 1;
          CallState_Request(Data_REQ, 0);                                   // send CallState.Status: 'eCall confirmation pending' = true
          gDialNumber_Result = 0x0a;                                        // not successful - confirm emergency call
          //settimer(dialnumber_result_timer, 20);
          DialNumber_Request(Result_REQ, 0);
          gDialNumber_status = 0;
        }
        else
        {
          gcallID = callstates_status(dialing);                           //aks for free Call-ID
          if(gcallID == 0xff)
          {
            write("DialNumber - no idle callID...");
            DialNumber_Request(Error_REQ, Terror_activecallpresentdialing); //send error
            gDialNumber_status = 0;
            break;
          }
          write("DialNumber - checknetworktimer..");
          settimer(checknetworktimer, gtime_checknetworktimer);
        }
      }
      write("DialNumber - Indication with StartResult ready...");
      */
    break;
    case Abort_IND:
      //write("DialNumber - Indication with Abort...");
      gDialNumber_AsgId=getvalue(env_FSG_DialNumber_AsgID);
      gDialNumber_Result=getvalue(env_FSG_DialNumber_Result);
      DialNumber_Request(Result_REQ, 0);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone dialnumber indication: unknown indication %d", indication);
    break;
  }
}

void DialNumber_Request (byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request)
  {
    case Processing_REQ:
      requestarray[0]=LSGID_Telephone;    //LSG-ID
      requestarray[1]=FctID_DialNumber;   //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gDialNumber_Extension+(gDialNumber_AsgId*0x10);
      requestarray[4]=0;                      //Dummy
      Offset=5;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Result_REQ:
      requestarray[0]=LSGID_Telephone;    //LSG-ID
      requestarray[1]=FctID_DialNumber; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gDialNumber_Extension+(gDialNumber_AsgId*0x10);
      requestarray[4]=gDialNumber_Result;
      Offset=5;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;  //LSG-ID
      requestarray[1]=FctID_DialNumber; //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone DialNumber_Request: unknown request %d", request);
    break;
  }
}

//*************************************************************************
//*****************ConfirmEmergencyCall************************************
void ConfirmEmergencyCall_Request(byte request, byte errorcode)
{
  int offset, i;
  dword requestarray[BAP_buffer_size];

  offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i] = 0;

  switch(request)
  {
    case Processing_REQ:
      requestarray[0]=LSGID_Telephone;              //LSG-ID
      requestarray[1]=FctID_ConfirmEmergencyCall;   //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gConfirmEmergencyCall_Extension+(gConfirmEmergencyCall_AsgId*0x10);
      requestarray[4]=0;
      offset=5;
      set_status_requestbuffer (requestarray, offset, Bap_ByteSequence);
    break;
    case Result_REQ:
      requestarray[0]=LSGID_Telephone;                //LSG-ID
      requestarray[1]=FctID_ConfirmEmergencyCall;     //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gConfirmEmergencyCall_Extension+(gConfirmEmergencyCall_AsgId*0x10);
      requestarray[4]=gConfirmEmergencyCall_result;
      offset=5;
      set_status_requestbuffer(requestarray, offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;                //LSG-ID
      requestarray[1]=FctID_ConfirmEmergencyCall;     //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      offset=4;
      set_status_requestbuffer (requestarray, offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone ConfirmEmergencyCall_Request: unknown request %d", request);
    break;
  }
}

void ConfirmEmergencyCall_Indication (dword Indication_array[], byte indication, int datalength)
{
  byte control;
  control = 0;

  switch (indication)
  {
    case Processing_CNF:
      gConfirmEmergencyCall_AsgId=Indication_array[3]/0x10;
      putValue(env_FSG_CEC_AsgID,gConfirmEmergencyCall_AsgId);
      ConfirmEmergencyCall_Request(Processing_REQ, 0);
    break;
    case StartResult_IND:
      //get ASG-ID
      gConfirmEmergencyCall_AsgId=Indication_array[3]/0x10;
      putValue(env_FSG_CEC_AsgID,gConfirmEmergencyCall_AsgId);
      //get Result & send
      gConfirmEmergencyCall_result=getvalue(env_FSG_CEC_Result);
      ConfirmEmergencyCall_Request(Result_REQ, 0);
      /*
      if(gDialNumber_status != 1)
        ConfirmEmergencyCall_Request(Error_REQ, Terror_unknownapllicationerror);
      else if(datalength!=4) // datalength error
        ConfirmEmergencyCall_Request(Error_REQ, Terror_unknownapllicationerror);
      else
      {
        if(gDialNumber_status == 1)
        {
          gConfirmEmergencyCall_AsgId=Indication_array[3]/0x10;
          putValue(env_FSG_CEC_AsgID,gConfirmEmergencyCall_AsgId);
          control = Indication_array[4];
          switch(control)
          {
            case ECALL_CONTROL_CONFIRM:
              // ConfirmEmergencyCall_Request(Processing_REQ, 0);
              gcallID = callstates_status(dialing); //aks for free Call-ID
              if(gcallID == 0xff)
              {
                if(gDialService_status == 1)
                {
                  //DialService_Request(Error_REQ, Terror_activecallpresentdialing);  //send error
                  DialNumber_Request(Error_REQ, Terror_activecallpresentdialing); //send error
                  gDialNumber_status = 0;
                  gDialService_status = 0;
                }
                else if(gDialNumber_status == 1)
                {
                  DialNumber_Request(Error_REQ, Terror_activecallpresentdialing); //send error
                  gDialNumber_status = 0;
                }
                gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
                //set_CallState(gcallID, idle);
                CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
                gDialNumber_status = 0;
                gDialService_status = 0;
                gConfirmEmergencyCall_result = NOT_SUCCESSFUL;
                ConfirmEmergencyCall_Request(Result_REQ, 0);
              }
              else
              {
                gCallStartedFromASG = 1;
                gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
                settimer(checknetworktimer, gtime_checknetworktimer);
              }
            break;
            case ECALL_CONTROL_CANCEL:
              gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
              //set_CallState(gcallID, idle);
              CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
              gDialNumber_status = 0;
              gDialService_status = 0;
              gConfirmEmergencyCall_result = SUCCESSFUL;
              ConfirmEmergencyCall_Request(Result_REQ, 0);
            break;
          }
        }
      }
      */
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone ConfirmEmergencyCall Indication: unknown indication %d", indication);
    break;
  }
}

on envVar env_FSG_ConfirmCall_Confirm
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && (gCallOutgoingDiverted_eCallConfirmationPending[7] == 1))
  {
    gcallID = callstates_status(dialing); //aks for free Call-ID
    if(gcallID == 0xff)
    {
      DialNumber_Request(Error_REQ, Terror_activecallpresentdialing); //send error
      if(gDialService_status == 1)
      {
        gDialNumber_status = 0;
        gDialService_status = 0;
      }
      else if(gDialNumber_status == 1)
      {
        gDialNumber_status = 0;
      }
      gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
      CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
      gDialNumber_status = 0;
      gDialService_status = 0;
    }
    else
    {
      gCallStartedFromASG = 0;
      gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
      settimer(checknetworktimer, gtime_checknetworktimer);
    }
  }
}

on envVar env_FSG_ConfirmCall_Cancel
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && (gCallOutgoingDiverted_eCallConfirmationPending[7] == 1) && (gemergencycall == 0x01))
  {
    gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
    //set_CallState(gcallID, idle);
    CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
    gDialNumber_status = 0;
    gDialService_status = 0;
  }
}

//*************************************************************************
//*****************BasicCallHandling***************************************
on envVar env_FSG_HangupCall
{
  byte i;
  byte HangupPossible;

  //init lokal variables
  i=0;
  HangupPossible=0;
  //********************

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    gBasicCallHandling_CallId=getvalue(env_FSG_HangupCall_CallID);
    gBasicCallHandling_AsgId=getvalue(env_FSG_BCH_AsgID);
    gBasicCallHandling_CallFunction=CALLFUNCTION_HANGUPCALL;
    if(gBasicCallHandling_CallId<7)        //Single call hangup
    {
      HangupPossible=check_hangup(gBasicCallHandling_CallId);
      if(HangupPossible==1)          //only when call or emergency call is ring_waiting/dialing/active/hold
      {
        set_CallState(gBasicCallHandling_CallId, disconnecting);
        settimer(disconnectingtimer, disconnecttime);
      }
      else
        writelineEx(gError_Trace, 0, "FSG-Telephone BasicCallHandling-Error: 0x%x (HangupCall)", HangupPossible);
    }
    else
    {
      switch(gBasicCallHandling_CallId)
      {
        case CALLID_ALLACTIVECALLS:
          for(i=0;i<7;i++)
          {
            if(gCallState[i]==active)
              set_CallState(i,disconnecting);
          }
        break;
        case CALLID_ALLHELDCALLS:
          for(i=0;i<7;i++)
          {
            if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
              set_CallState(i,disconnecting);
          }
        break;
        case CALLID_ALLACTIVEHELDCALLS:
          for(i=0;i<7;i++)
          {
            if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD || gCallState[i]==active)
              set_CallState(i,disconnecting);
          }
        break;
        case CALLID_ALLCALLS:
          for(i=0;i<7;i++)
          {
            if(gCallState[i]!=idle)
              set_CallState(i,disconnecting);
          }
        break;
      }
      settimer(disconnectingtimer2, disconnecttime);
    }
  }
}

on timer disconnectingtimer  //for hangup a single call
  {
  byte i, call_id;

  //init lokal variables
  i=0;
  call_id=0xff;
  //********************

  //*******CallID******
  for(i=0;i<7;i++)
  {
    if(gCallState[i]==disconnecting)
      call_id=i;
  }
  //*******************

  if(call_id==0xff) //error, no disconnected callID was found
  {
    write("error disonnecting-timer, no disconnected call-id");
  }
  else
  {
    if (gCallType[call_id]==emergencycall && (gemergencycall==2 || gemergencycall==3))
    {     //disconnected emergency call
      switch(gemergencycall)
      {
        case 2:
          gRegisterState=notregisterdandsearching;  //set register state
          gNetworkType=UNKNOWN_NT;
          gPacketDataNetworkType=NO_DATA_SERVICE;
        break;
        case 3:
          gRegisterState=notregisteredandnotsearching;  //set register state
          gNetworkType=UNKNOWN_NT;
          gPacketDataNetworkType=NO_DATA_SERVICE;
        break;
        default:
          write("error disconnectingtimer: invalid gemergencycall-value: %d",gemergencycall);
        break;
      }
      putvalue(env_FSG_RegisterState, gRegisterState);
      putvalue(env_FSG_NetworkType,gNetworkType);
      putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
      NetworkState_Request(Data_REQ, 0);  //send network state
      putvalue(env_FSG_NetworkProviderState, 0);  //delete network provider
      NetworkProvider_Request(Data_REQ, 0); //send empty provider name
    }
    gemergencycall=0;
    //Disconnect Reason
    if(gCallActivity==NOCALL)
    {
      gDisconnectReason=regulardisconnecting; //set Disconnect Reason to regular disconnecting
      putvalue(env_FSG_DisconnectReason, gDisconnectReason);
    }
    //call state
    set_CallState(call_id, idle); //set call state to idle
    //call info
    for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
      gCallInfo_PbName[call_id][i]=0;
    for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
        gCallInfo_PbName_hex[call_id][i]=0;
    for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
      gCallInfo_TelNumber[call_id][i]=0;
    switch(call_id)
    {
      case 0:
        putvalue(env_FSG_CallInfo_PbName_0, gCallInfo_PbName[0]);
        putvalue(env_FSG_CallInfo_PbName_0_data, gCallInfo_PbName_hex[0]);
        putvalue(env_FSG_CallInfo_TelNumber_0, gCallInfo_TelNumber[0]);
      break;
      case 1:
        putvalue(env_FSG_CallInfo_PbName_1, gCallInfo_PbName[1]);
        putvalue(env_FSG_CallInfo_PbName_1_data, gCallInfo_PbName_hex[1]);
        putvalue(env_FSG_CallInfo_TelNumber_1, gCallInfo_TelNumber[1]);
      break;
      case 2:
        putvalue(env_FSG_CallInfo_PbName_2, gCallInfo_PbName[2]);
        putvalue(env_FSG_CallInfo_PbName_2_data, gCallInfo_PbName_hex[2]);
        putvalue(env_FSG_CallInfo_TelNumber_2, gCallInfo_TelNumber[2]);
      break;
      case 3:
        putvalue(env_FSG_CallInfo_PbName_3, gCallInfo_PbName[3]);
        putvalue(env_FSG_CallInfo_PbName_3_data, gCallInfo_PbName_hex[3]);
        putvalue(env_FSG_CallInfo_TelNumber_3, gCallInfo_TelNumber[3]);
      break;
      case 4:
        putvalue(env_FSG_CallInfo_PbName_4, gCallInfo_PbName[4]);
        putvalue(env_FSG_CallInfo_PbName_4_data, gCallInfo_PbName_hex[4]);
        putvalue(env_FSG_CallInfo_TelNumber_4, gCallInfo_TelNumber[4]);
      break;
      case 5:
        putvalue(env_FSG_CallInfo_PbName_5, gCallInfo_PbName[5]);
        putvalue(env_FSG_CallInfo_PbName_5_data, gCallInfo_PbName_hex[5]);
        putvalue(env_FSG_CallInfo_TelNumber_5, gCallInfo_TelNumber[5]);
      break;
      case 6:
        putvalue(env_FSG_CallInfo_PbName_6, gCallInfo_PbName[6]);
        putvalue(env_FSG_CallInfo_PbName_6_data, gCallInfo_PbName_hex[6]);
        putvalue(env_FSG_CallInfo_TelNumber_6, gCallInfo_TelNumber[6]);
      break;
      default:
        write("error disconnectingtimer: invalid call-ID: %d",call_id);
      break;
    }
    CallInfo_Request(Data_REQ,0);//callinfodelete_Request(Data_REQ, call_id, 1, 1, 0);

    if(call_id == gRingTone_incoming_callid && gRingTone_unmute == 1)
    {
      putvalue("env_FSG_RingToneMuteOnOff", 0); // unmute
      gRingToneMuteOnOff=0;
      AudioMuteOnOff_Request(Data_REQ, 0);
    }
    gRingTone_incoming_callid = 0;
    gRingTone_unmute = 0;
    //Hangup sucessfull
    if(ghangupcall_status==1)
    {
      gBasicCallHandling_Result=SUCCESSFUL;
      BasicCallHandling_Request(Result_REQ, 0);
      ghangupcall_status=0; //method "BasicCallHandling" finished
    }
  }
}

on timer disconnectingtimer2    //hangup all active or hold or actie and hold or all calls
{
  byte i, callID, freeline, disconnected, callinfostart, callinfoelements, callinfochange [7];
  char empty_string [3];

  //init lokal variables
  i=0;
  callID=0xff;
  freeline=1;
  disconnected=0;
  callinfostart=0xff;
  callinfoelements=0;
  for(i=0;i<7;i++)
    callinfochange[i]=0;
  for(i=0;i<3;i++)
    empty_string[i]=0;
  //********************

  for(callID=0;callID<7;callID++)
  {
    if(gCallState[callID]==disconnecting)
    {
      disconnected=1;
      callinfochange[callID]=1;
      if (gCallType[callID]==emergencycall && (gemergencycall==2 || gemergencycall==3))//disconnected emergency call
      {
        switch(gemergencycall)
        {
          case 2:
            gRegisterState=notregisterdandsearching;            //set register state
            gNetworkType=UNKNOWN_NT;
            gPacketDataNetworkType=NO_DATA_SERVICE;
          break;
          case 3:
            gRegisterState=notregisteredandnotsearching;          //set register state
            gNetworkType=UNKNOWN_NT;
            gPacketDataNetworkType=NO_DATA_SERVICE;
          break;
          default:
            write("error disconnectingtimer: invalid gemergencycall-value: %d",gemergencycall);
          break;
        }

        putvalue(env_FSG_RegisterState, gRegisterState);
        putvalue(env_FSG_NetworkType,gNetworkType);
        putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
        NetworkState_Request(Data_REQ, 0);                    //send register state
        putvalue(env_FSG_NetworkProviderState, 0);                  //delete network provider
        NetworkProvider_Request(Data_REQ, 0);                 //send empty provider name
      }
      gemergencycall=0;
      //Disconnect Reason
      if(gCallState[i]==idle)
      {
        gDisconnectReason=regulardisconnecting;
        putvalue(env_FSG_DisconnectReason, gDisconnectReason);
      }
      //**********CallStates*****************
      set_CallState(callID,idle);
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          putvalue(env_FSG_CallType_CallID_0, empty_string);
          putvalue(env_FSG_CallState_CallDivert_0, empty_string);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          putvalue(env_FSG_CallType_CallID_1, empty_string);
          putvalue(env_FSG_CallState_CallDivert_1, empty_string);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          putvalue(env_FSG_CallType_CallID_2, empty_string);
          putvalue(env_FSG_CallState_CallDivert_2, empty_string);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          putvalue(env_FSG_CallType_CallID_3, empty_string);
          putvalue(env_FSG_CallState_CallDivert_3, empty_string);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          putvalue(env_FSG_CallType_CallID_4, empty_string);
          putvalue(env_FSG_CallState_CallDivert_4, empty_string);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          putvalue(env_FSG_CallType_CallID_5, empty_string);
          putvalue(env_FSG_CallState_CallDivert_5, empty_string);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          putvalue(env_FSG_CallType_CallID_6, empty_string);
          putvalue(env_FSG_CallState_CallDivert_6, empty_string);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_CCJoin: unknown call-ID %d", callID);
        break;
      }
      //*************************************
      //call info
      for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
        gCallInfo_PbName[callID][i]=0;
      for(i = 0; i < CALL_INFO_NAME_LENGTH; i++)
        gCallInfo_PbName_hex[callID][i] = 0;
      for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
        gCallInfo_TelNumber[callID][i]=0;
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallInfo_PbName_0, gCallInfo_PbName[0]);
          putvalue(env_FSG_CallInfo_PbName_0_data, gCallInfo_PbName_hex[0]);
          putvalue(env_FSG_CallInfo_TelNumber_0, gCallInfo_TelNumber[0]);
        break;
        case 1:
          putvalue(env_FSG_CallInfo_PbName_1, gCallInfo_PbName[1]);
          putvalue(env_FSG_CallInfo_PbName_1_data, gCallInfo_PbName_hex[1]);
          putvalue(env_FSG_CallInfo_TelNumber_1, gCallInfo_TelNumber[1]);
        break;
        case 2:
          putvalue(env_FSG_CallInfo_PbName_2, gCallInfo_PbName[2]);
          putvalue(env_FSG_CallInfo_PbName_2_data, gCallInfo_PbName_hex[2]);
          putvalue(env_FSG_CallInfo_TelNumber_2, gCallInfo_TelNumber[2]);
        break;
        case 3:
          putvalue(env_FSG_CallInfo_PbName_3, gCallInfo_PbName[3]);
          putvalue(env_FSG_CallInfo_PbName_3_data, gCallInfo_PbName_hex[3]);
          putvalue(env_FSG_CallInfo_TelNumber_3, gCallInfo_TelNumber[3]);
        break;
        case 4:
          putvalue(env_FSG_CallInfo_PbName_4, gCallInfo_PbName[4]);
          putvalue(env_FSG_CallInfo_PbName_4_data, gCallInfo_PbName_hex[4]);
          putvalue(env_FSG_CallInfo_TelNumber_4, gCallInfo_TelNumber[4]);
        break;
        case 5:
          putvalue(env_FSG_CallInfo_PbName_5, gCallInfo_PbName[5]);
          putvalue(env_FSG_CallInfo_PbName_5_data, gCallInfo_PbName_hex[5]);
          putvalue(env_FSG_CallInfo_TelNumber_5, gCallInfo_TelNumber[5]);
        break;
        case 6:
          putvalue(env_FSG_CallInfo_PbName_6, gCallInfo_PbName[6]);
          putvalue(env_FSG_CallInfo_PbName_6_data, gCallInfo_PbName_hex[6]);
          putvalue(env_FSG_CallInfo_TelNumber_6, gCallInfo_TelNumber[6]);
        break;
        default:
          write("error disconnectingtimer: invalid call-ID: %d",callID);
        break;
      }
    }
  }

  if(disconnected==0)
  {                                           //error, no disconected callID was found
    write("error disonnecting-timer, no disconnected call-id");
  }
  else
  {
    //CallInfo
    CallInfo_Request(Data_REQ,0);//callinfodelete_Request(Data_REQ, 0, 7, 1, 0);
    //Hangup successfull
    if(ghangupcall_status==1)
    {
      gBasicCallHandling_Result=SUCCESSFUL;
      BasicCallHandling_Request(Result_REQ, 0);
      ghangupcall_status=0;                             //method "BasicCallHandling" finished
    }
  }
}

on envVar env_FSG_AcceptCall
{
  byte i, incomingcallID, acceptpossible;

  //init lokal variables
  incomingcallID=0xff;
  acceptpossible=1;
  //********************

  for(i=0;i<7;i++)
  {
    if(gCallState[i]==active || gCallState[i]==disconnecting)
      acceptpossible=0;
  }

  if(gFSG_Telephone_PowerOnOff==Power_on && acceptpossible==1)
  {
    for(i=0;i<7;i++)
    { //check call-states for incoming call
      if(gCallState[i]==ringing_waiting)
        incomingcallID=i;
    }

    if(getvalue(this) && incomingcallID!=0xff)
    { //only when button ist pressed and one callID-callstate is "ringing/waiting"
      //putvalue(env_FSG_receivedcall_name, greceivedcall_name);        //write name of received call in callstack
      //putvalue(env_FSG_receivedcall_number, greceivedcall_number);      //write number of received call in callstack
      //putvalue(env_FSG_receivedcall_numbertype, greceivedcall_numbertype);  //write numbertype of dialed number in callstack
      //putvalue(env_FSG_receivedcall_callstack, 1);
      gBasicCallHandling_AsgId=getvalue(env_FSG_BCH_AsgID);
      gBasicCallHandling_CallFunction=CALLFUNCTION_ACCEPTCALL;
      set_CallState(incomingcallID, active);
      if(gRingTone_incoming_callid < 7 && gRingTone_unmute == 1)
      {
        putvalue(env_FSG_RingToneMuteOnOff, 0); // unmute
        gRingToneMuteOnOff=0;
        AudioMuteOnOff_Request(Data_REQ, 0);
      }
      gRingTone_unmute = 0;
      gRingTone_incoming_callid = 0xff;
      gBasicCallHandling_Result=SUCCESSFUL;
      BasicCallHandling_Request(Result_REQ, 0);
    }
  }
}

on envVar env_FSG_CallHold
{
  byte i, callID, callholdpossible;

  //init lokal variables
  callID=0xff;
  callholdpossible=1;
  //********************

  for(i=0;i<7;i++)
  {
    if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
      callholdpossible=0;
  }

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && callholdpossible==1)
  {
    gBasicCallHandling_AsgId=getvalue(env_FSG_BCH_AsgID);
    gBasicCallHandling_CallFunction=CALLFUNCTION_CALLHOLD;
    for(i=0;i<7;i++)
    { //searching for active calls
      if(gCallState[i]==active)
      {
        //**********CallStates*****************
        callID=i;
        set_CallState(callID,onhold);                     //set call state
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_CallHold: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
    }
    gBasicCallHandling_Result=SUCCESSFUL;
    BasicCallHandling_Request(Result_REQ, 0);
  }
}

on envVar env_FSG_CallResume
{
  byte i, callID, callresumepossible;

  //init lokal variables
  callID=0xff;
  callresumepossible=1;
  //********************

  for(i=0;i<7;i++)
  {
    if(gCallState[i]==active || gCallState[i]==disconnecting || gCallState[i]==dialing || gCallState[i]==ringing_waiting)
      callresumepossible=0;
  }

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && callresumepossible==1)
  {
    gBasicCallHandling_AsgId=getvalue(env_FSG_BCH_AsgID);
    gBasicCallHandling_CallFunction=CALLFUNCTION_RESUMECALL;
    for(i=0;i<7;i++)
    { //searching for active calls
      if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
      {
        //**********CallStates*****************
        callID=i;
        set_CallState(callID,active);                       //set call state
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_CallResume: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
    }
    gBasicCallHandling_Result=SUCCESSFUL;
    BasicCallHandling_Request(Result_REQ, 0);
  }
}

void BasicCallHandling_Request (byte request, byte errorcode)
{
  int i, length, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  length=0;
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request){
    case Processing_REQ:
      requestarray[0]=LSGID_Telephone;            //LSG-ID
      requestarray[1]=FctID_BasicCallHandling;    //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gBasicCallHandling_Extension1+(gBasicCallHandling_AsgId*0x10);
      requestarray[4]=gBasicCallHandling_CallFunction;
      requestarray[5]=gBasicCallHandling_Extension2 & 0x0F; //Extension2 lower nibble & Reserve1 is 0
      requestarray[6]=0;                          //Dummy
      Offset=7;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Result_REQ:
      requestarray[0]=LSGID_Telephone;          //LSG-ID
      requestarray[1]=FctID_BasicCallHandling;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gBasicCallHandling_Extension1+(gBasicCallHandling_AsgId*0x10);
      requestarray[4]=gBasicCallHandling_CallFunction;
      requestarray[5]=gBasicCallHandling_Extension2 & 0x0F; //Extension2 lower nibble & Reserve1 is 0
      requestarray[6]=gBasicCallHandling_Result;
      Offset=7;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;          //LSG-ID
      requestarray[1]=FctID_BasicCallHandling;  //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone BasicCallHandling_Request: unknown request %d", request);
    break;
  }
}

void BasicCallHandling_Indication(dword Indication_array [], byte indication, int datalength)
{
  byte i, callID, acceptpossible, hangupcallpossible, callholdpossible, callresumepossible;
  byte indASGID, indCallFunction, indCallID, Debil;

  //init lokal variables
  callID            =0xff;
  acceptpossible    =1;
  callholdpossible  =1;
  callresumepossible=1;
  hangupcallpossible    =0;
  //********************

  //getdata from indication
  indASGID        =Indication_array[3]/0x10;
  indCallFunction =Indication_array[4];
  indCallID       =Indication_array[5]/0x10;

  //checking if CallFunction possible
  /*
  switch(indCallFunction)
  {
    case CALLFUNCTION_ACCEPTCALL:
      for(i=0;i<7;i++)
      {
        if(gCallState[i]==active || gCallState[i]==disconnecting || gCallState[i]==dialing)
          acceptpossible=Terror_activecallpresentdialing;
      }
      if(acceptpossible==1)
      {
        acceptpossible=Terror_noincomingwaitingcall;
        for(i = 0; i < 7; i++)
        {
          if(gCallState[i]==ringing_waiting)
            acceptpossible=1;
        }
      }
    break;
    case CALLFUNCTION_CALLHOLD:
      for(i=0;i<7;i++)
      {
        if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
          callholdpossible=Terror_heldcallpresent;
      }
      if(callholdpossible==1)
      {
        callholdpossible=Terror_noactivecall;
        for(i=0;i<7;i++)
        {
          if(gCallState[i]==active)
            callholdpossible=1;
        }
      }
    break;
    case CALLFUNCTION_RESUMECALL:
      for(i=0;i<7;i++)
      {
        if(gCallState[i]==active || gCallState[i]==disconnecting || gCallState[i]==dialing)
          callresumepossible=Terror_activecallpresentdialing;
      }
      if(callresumepossible==1)
      {
        callresumepossible=Terror_nocallonhold;
        for(i=0;i<7;i++)
        {
          if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
            callresumepossible=1;
        }
      }
    break;
    case CALLFUNCTION_HANGUPCALL:
      if(callID<7)
      {
        hangupcallpossible=check_hangup(callID);
      }
      else if(callID==CALLID_ALLACTIVECALLS)
      {
        hangupcallpossible=Terror_noactivecall;
        for(i=0;i<7;i++)
        {
          if(gCallState[i]==active)
            hangupcallpossible=TRUE;
        }
      }
      else if(callID==CALLID_ALLHELDCALLS)
      {
        hangupcallpossible=Terror_nocallonhold;
        for(i=0;i<7;i++)
        {
          if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
            hangupcallpossible=TRUE;
        }
      }
      else if(callID==CALLID_ALLACTIVEHELDCALLS)
      {
        hangupcallpossible=Terror_noactivecall;
        for(i=0;i<7;i++)
        {
          if(gCallState[i]==active || gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
            hangupcallpossible=TRUE;
        }
      }
      else if(callID==CALLID_ALLCALLS)
      {
        hangupcallpossible=Terror_nocall;
        for(i=0;i<7;i++)
        {
          if(gCallState[i]!=idle)
            hangupcallpossible=TRUE;
        }
      }
    break;
  }
  */

  //handling indication
  switch (indication)
  {
    case Processing_CNF:
      gBasicCallHandling_AsgId=indASGID;
      //putvalue(env_FSG_BCH_AsgID,indASGID);
      gBasicCallHandling_CallFunction=indCallFunction;
      BasicCallHandling_Request(Processing_REQ, 0);                       //send Processing
    break;
    case StartResult_IND:
        gBasicCallHandling_AsgId=indASGID;
        putvalue(env_FSG_BCH_AsgID,indASGID);
        gBasicCallHandling_CallFunction=indCallFunction;
        gBasicCallHandling_CallId=indCallID;
        putvalue(env_FSG_BCH_CallID,indCallID);
        gBasicCallHandling_Result=getvalue(env_FSG_BCH_Result);
        BasicCallHandling_Request(Result_REQ, 0);
        //now send result depending on CallFunction, e.g. accept call...
      /*
        switch(indCallFunction)
        {
          case CALLFUNCTION_ACCEPTCALL:
            if(gacceptcall_status!=0)
              BasicCallHandling_Request(Error_REQ, Terror_datainvalid);               //send error-message to RNS
            else if(datalength!=3)                                //datalength error
              BasicCallHandling_Request(Error_REQ, Terror_datainvalid);               //send error-message to RNS
            else if(acceptpossible!=1)                              //accept call impossible
              BasicCallHandling_Request(Error_REQ, acceptpossible);                 //send error-message to RNS
            else
            {
              gacceptcall_status=1;                             //"acceptcall" active
              settimer(acceptcallTimer, acceptcallTimerTime);
            }
          break;
          case CALLFUNCTION_CALLHOLD:
            if(gCallHold_status!=0)
              BasicCallHandling_Request(Error_REQ, Terror_datainvalid);               //send error-message to RNS
            else if(datalength!=3)                                //datalength error
              BasicCallHandling_Request(Error_REQ, Terror_datainvalid);               //send error-message to RNS
            else if(callholdpossible!=1)                              //call hold impossible
              BasicCallHandling_Request(Error_REQ, callholdpossible);                 //send error-message to RNS
            else
            {
              gCallHold_status=1;                               //"call hold" active
              settimer(CallHoldTimer, CallHoldTimerTime);
            }
          break;
          case CALLFUNCTION_RESUMECALL:
            if(gResumeCall_status!=0)
              BasicCallHandling_Request(Error_REQ, Terror_datainvalid);               //send error-message to RNS
            else if(datalength!=3)                                //datalength error
              BasicCallHandling_Request(Error_REQ, Terror_datainvalid);               //send error-message to RNS
            else if(callresumepossible!=1)                              //call resume impossible
              BasicCallHandling_Request(Error_REQ, callresumepossible);                 //send error-message to RNS
            else
            {
              gResumeCall_status=1;                             //"resume call" active
              settimer(ResumeCallTimer, ResumeCallTimerTime);
            }
          break;
          case CALLFUNCTION_HANGUPCALL:
            if(ghangupcall_status!=0)
              BasicCallHandling_Request(Error_REQ, Terror_datainvalid);               //send error-message to RNS
            else if(datalength!=3)                                //datalength error
              BasicCallHandling_Request(Error_REQ, Terror_datainvalid);               //send error-message to RNS
            else if(hangupcallpossible!=1)                              //accept call impossible
              BasicCallHandling_Request(Error_REQ, hangupcallpossible);                 //send error-message to RNS
            else
            {
              ghangupcall_status=1;                             //"hangup" active
              if (indCallID<7)                                  //hangup feasible, one call-ID
              {
                switch(gCallState[indCallID])
                {
                  case ringing_waiting:
                    if(gacceptcall_status)                      //method "acceptcall" is still active
                    {
                      canceltimer(acceptcallTimer);             //abort method "acceptcall"
                      Debil=random(2);
                      if(Debil)
                        BasicCallHandling_Request(Error_REQ, Terror_unknownapllicationerror);
                      else
                        BasicCallHandling_Request(Result_REQ, 0);
                      gacceptcall_status=0;
                    }
                    set_CallState(indCallID, disconnecting);
                    settimer(disconnectingtimer, disconnecttime);
                  break;
                  case dialing:                           //dialing is still active
                    set_CallState(indCallID, disconnecting);
                    settimer(disconnectingtimer, disconnecttime);
                  break;
                  case active:
                    if(gCallHold_status)                      //method "CallHold" is still active
                    {
                      canceltimer(CallHoldTimer);                 //abort method "CallHold
                      Debil=random(2);
                      if(Debil)
                        BasicCallHandling_Request(Error_REQ, Terror_unknownapllicationerror);
                      else
                        BasicCallHandling_Request(Result_REQ, 0);
                      gCallHold_status=0;
                    }
                    if(gMPSwap_status)                        //method "MPSwap" is still active
                    {
                      canceltimer(MPSwapTimer);                 //abort method "MPSwap"
                      Debil=random(2);
                      if(Debil)
                        MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);
                      else
                        MPCall_CC_Handling_Request(Result_REQ, 0);
                      gMPSwap_status=0;
                    }
                    set_CallState(indCallID, disconnecting);
                    settimer(disconnectingtimer, disconnecttime);
                  break;
                  case onhold:
                    if(gResumeCall_status)                      //method "ResumeCall" is still active
                    {
                      canceltimer(ResumeCallTimer);               //abort method "ResumeCall"
                      Debil=random(2);
                      if(Debil)
                        BasicCallHandling_Request(Error_REQ, Terror_unknownapllicationerror);
                      else
                        BasicCallHandling_Request(Result_REQ, 0);
                      gResumeCall_status=0;
                    }
                    set_CallState(indCallID, disconnecting);
                    settimer(disconnectingtimer, disconnecttime);
                  break;
                  case INCOMING_ON_HOLD:
                    if(gResumeCall_status)                      //method "ResumeCall" is still active
                    {
                      canceltimer(ResumeCallTimer);               //abort method "ResumeCall"
                      Debil=random(2);
                      if(Debil)
                        BasicCallHandling_Request(Error_REQ, Terror_unknownapllicationerror);
                      else
                        BasicCallHandling_Request(Result_REQ, 0);
                      gResumeCall_status=0;
                    }
                    set_CallState(indCallID, disconnecting);
                    settimer(disconnectingtimer, disconnecttime);
                  break;
                  default:
                    write("FSG-Telephone error BasicCallHandling_Indication: invalid call state: %d", gCallState[indCallID]);
                    settimer(disconnectingtimer, disconnecttime);
                  break;
                }
              }
            }
          break;
        }
      */
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone BasicCallHandling_Indication: unknown indication %d", indication);
    break;
  }
}

on timer acceptcallTimer
{
  byte i, callID;

  //init lokal variables
  callID=0xff;
  //********************

  for(i = 0; i < 7; i++)
  {
    if(gCallState[i] == ringing_waiting)
      callID = i;
  }
  if(callID<7)
  { //accept call is feasible
    //write to callstack ReceivedCalls
    //putvalue(env_FSG_receivedcall_name, greceivedcall_name);        //write name of received call in callstack
    //putvalue(env_FSG_receivedcall_number, greceivedcall_number);      //write number of received call in callstack
    //putvalue(env_FSG_receivedcall_numbertype, greceivedcall_numbertype);  //write numbertype of dialed number in callstack
    //putvalue(env_FSG_receivedcall_callstack, 1);              //start callstack
    //*********************************
    set_CallState(callID, active);      //method "acceptcal" finished
    gBasicCallHandling_Result=SUCCESSFUL;
    BasicCallHandling_Request(Result_REQ, 0);
    gacceptcall_status=0;
    if(gRingTone_incoming_callid < 7 && gRingTone_unmute == 1)
    {
      putvalue(env_FSG_RingToneMuteOnOff, 0); // unmute
      gRingToneMuteOnOff=0;
      AudioMuteOnOff_Request(Data_REQ, 0);
    }
    gRingTone_unmute = 0;
    gRingTone_incoming_callid = 0xff;
  }
  else
  {                                     //no incoming call related to call-ID
    BasicCallHandling_Request(Error_REQ, Terror_noincomingwaitingcall);
    gacceptcall_status=0;                           //method "acceptcal" finished
  }
}

on timer CallHoldTimer
{
  byte i, callID;

  //init lokal variables
  callID=0xff;
  //********************

  for(i=0;i<7;i++)
  { //searching for active calls
    if(gCallState[i]==active)
    {
      callID=i;
      set_CallState(callID,onhold); //set call state
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone set_CallState: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
  }
  if(callID<7)
  {                                                 //hold call is possible
    gBasicCallHandling_Result=SUCCESSFUL;
    BasicCallHandling_Request(Result_REQ, 0);
    gCallHold_status=0;                             //"CallHold" finished
  }
  else
  {                                                 //no active call available
    BasicCallHandling_Request(Error_REQ, Terror_noactivecall);
    gCallHold_status=0;                             //"CallHold" finished
  }
}

on timer ResumeCallTimer
{
  byte i, callID;

  //init lokal variables
  callID=0xff;
  //********************

  for(i=0;i<7;i++)
  { //searching for active calls
    if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
    {
      callID=i;
      set_CallState(callID,active);                     //set call state
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone ResumeCallTimer: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
  }
  if(callID<7)
  {                                               //resume is possible
    gBasicCallHandling_Result=SUCCESSFUL;
    BasicCallHandling_Request(Result_REQ, 0);
    gResumeCall_status=0;                         //"ResumeCall" finished
  }
  else
  {                                               //no hold call exist
    BasicCallHandling_Request(Error_REQ, Terror_nocallonhold);
    gResumeCall_status=0;                         //"ResumeCall" finished
  }
}

//*************************************************************************
//*****************MPCall_CC_Handling**************************************
on envVar env_FSG_CCJoin
{
  byte i, callID, ccjoinpossible;

  //init lokal variables
  callID=0xff;
  ccjoinpossible=0;
  //********************

  //search for active calls
  for(i=0;i<7;i++)
  {
    if(gCallState[i]==active)
      ccjoinpossible=1;
  }
  //search for held calls
  if(ccjoinpossible==1)
  { // if there are active calls
    ccjoinpossible=0;
    for(i=0;i<7;i++)
    {
      if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
        ccjoinpossible=1;
    }
  }

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && ccjoinpossible==1)
  {
    for(i=0;i<7;i++)
    { //searching for active & held calls
      if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
      { //held calls
        callID=i;
        gCallType[callID]=CONFERENCE_VOICE_CALL;                  //set call type
        set_CallState(callID,active);                             //set call state
        //**********CallStates*****************
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
            putvalue(env_FSG_CallType_CallID_0, gstring_calltype[gCallType[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
            putvalue(env_FSG_CallType_CallID_1, gstring_calltype[gCallType[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
            putvalue(env_FSG_CallType_CallID_2, gstring_calltype[gCallType[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
            putvalue(env_FSG_CallType_CallID_3, gstring_calltype[gCallType[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
            putvalue(env_FSG_CallType_CallID_4, gstring_calltype[gCallType[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
            putvalue(env_FSG_CallType_CallID_5, gstring_calltype[gCallType[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
            putvalue(env_FSG_CallType_CallID_6, gstring_calltype[gCallType[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_CCJoin: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
      else if(gCallState[i]==active)
      { //active calls
        callID=i;
        gCallType[callID]=CONFERENCE_VOICE_CALL;                  //set call type
        set_CallState(callID,active);                             //update CallOptions
        //**********CallStates*****************
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallType_CallID_0, gstring_calltype[gCallType[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallType_CallID_1, gstring_calltype[gCallType[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallType_CallID_2, gstring_calltype[gCallType[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallType_CallID_3, gstring_calltype[gCallType[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallType_CallID_4, gstring_calltype[gCallType[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallType_CallID_5, gstring_calltype[gCallType[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallType_CallID_6, gstring_calltype[gCallType[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_CCJoin: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
    }
    gMPCall_CC_Handling_AsgId=getvalue(env_FSG_MPCH_AsgID);
    gMPCall_CC_Handling_CallFunction=CALLFUNCTION_CCJOIN;
    putvalue(env_FSG_MPCH_CallFunction,gMPCall_CC_Handling_CallFunction);
    gMPCall_CC_Handling_Result=SUCCESSFUL;
    MPCall_CC_Handling_Request(Result_REQ, 0);
  }
}

on envVar env_FSG_MPSwap
{
  byte i, callID, mpswappossible;

  //init lokal variables
  callID=0xff;
  mpswappossible=0;
  //********************

  //search for active calls
  for(i=0;i<7;i++)
  {
    if(gCallState[i]==active)
      mpswappossible=1;
  }
  //search for held calls
  if(mpswappossible==1)
  {                   // if there are active calls
    mpswappossible=0;
    for(i=0;i<7;i++)
    {
      if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
        mpswappossible=1;
    }
  }

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && mpswappossible==1)
  {
    for(i=0;i<7;i++)
    { //searching for active calls
      if(gCallState[i]==active)
      {
        callID=i;
        set_CallState(callID,onhold);                     //set call state
        //**********CallStates*****************
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MPSwap: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
      else if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
      {
        callID=i;
        set_CallState(callID,active);                     //set call state
        //**********CallStates*****************
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MPSwap: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
    }
    gMPCall_CC_Handling_AsgId=getvalue(env_FSG_MPCH_AsgID);
    gMPCall_CC_Handling_CallFunction=CALLFUNCTION_MPSWAP;
    putvalue(env_FSG_MPCH_CallFunction,gMPCall_CC_Handling_CallFunction);
    gMPCall_CC_Handling_Result=SUCCESSFUL;
    MPCall_CC_Handling_Request(Result_REQ, 0);
  }
}

on envVar env_FSG_MPSWCOH
{
  byte i, callID, incoming_callholdpossible;

  //init lokal variables
  callID=0xff;
  incoming_callholdpossible=0;
  //********************

  for(i=0;i<7;i++)
  {
    if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
      incoming_callholdpossible=Terror_heldcallpresent;
  }

  if(incoming_callholdpossible!=Terror_heldcallpresent)
  {
    incoming_callholdpossible=Terror_noincomingwaitingcall;
    for(i=0;i<7;i++)
    {
      if(gCallState[i]==ringing_waiting)
        incoming_callholdpossible=1;
    }
  }

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && incoming_callholdpossible==1)
  {
    for(i=0;i<7;i++)
    { //searching for ringing/waiting calls
      if(gCallState[i]==ringing_waiting)
      {
        callID=i;
        set_CallState(callID,INCOMING_ON_HOLD);                     //set call state
        //**********CallStates*****************
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MPSWCOH: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
    }
    gMPCall_CC_Handling_AsgId=getvalue(env_FSG_MPCH_AsgID);
    gMPCall_CC_Handling_CallFunction=CALLFUNCTION_MPSWCOH;
    putvalue(env_FSG_MPCH_CallFunction,gMPCall_CC_Handling_CallFunction);
    gMPCall_CC_Handling_Result=SUCCESSFUL;
    MPCall_CC_Handling_Request(Result_REQ, 0);
  }
}

on envVar env_FSG_MP_CHAWC
{
  byte i, callID, mpchawcpossible;

  //init lokal variables
  callID=0xff;
  mpchawcpossible=Terror_noactivecall;
  //********************

  //search for held calls
  for(i=0;i<7;i++)
  {
    if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
      mpchawcpossible=Terror_heldcallpresent;
  }
  //search for active calls
  if(mpchawcpossible!=Terror_heldcallpresent)                   //no held call(s) present
  {
    for(i=0;i<7;i++)
    {
      if(gCallState[i]==active)
        mpchawcpossible=Terror_noincomingwaitingcall;
    }
  }
  //search for waiting calls
  if(mpchawcpossible==Terror_noincomingwaitingcall)               //active call(s) is(are) present
  {
    for(i=0;i<7;i++)
    {
      if(gCallState[i]==ringing_waiting)
        mpchawcpossible=1;
    }
  }

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && mpchawcpossible==1)
  {
    for(i=0;i<7;i++)                              //searching for active calls
    {
      if(gCallState[i]==active)
      {
        callID=i;
        set_CallState(callID,onhold);                       //set call state
        //**********CallStates*****************
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MP_RACAWC: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
    }
    for(i=0;i<7;i++)                                //searching for active calls
    {
      if(gCallState[i]==ringing_waiting)
      {
        callID=i;
        set_CallState(callID,active);                       //set call state
        //**********CallStates*****************
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MP_RACAWC: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
    }
    gMPCall_CC_Handling_AsgId=getvalue(env_FSG_MPCH_AsgID);
    gMPCall_CC_Handling_CallFunction=CALLFUNCTION_MPCHAWC;
    putvalue(env_FSG_MPCH_CallFunction,gMPCall_CC_Handling_CallFunction);
    gMPCall_CC_Handling_Result=SUCCESSFUL;
    MPCall_CC_Handling_Request(Result_REQ, 0);
  }
}

on envVar env_FSG_MP_RACAWC
{
  byte i, callID, mpracawcpossible;

  //init lokal variables
  callID=0xff;
  mpracawcpossible=0;
  //********************

  //search for active calls
  for(i=0;i<7;i++)
  {
    if(gCallState[i]==active)
      mpracawcpossible=1;
  }
  //search for waiting calls
  if(mpracawcpossible==1)                   // if there are active calls
  {
    mpracawcpossible=0;
    for(i=0;i<7;i++)
    {
      if(gCallState[i]==ringing_waiting)
        mpracawcpossible=1;
    }
  }

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && mpracawcpossible==1)
  {
    for(i=0;i<7;i++)                                //searching for active calls
    {
      if(gCallState[i]==active)
      {
        callID=i;
        set_CallState(callID,disconnecting);                    //set call state
        //**********CallStates*****************
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MP_RACAWC: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
    }
    gMPCall_CC_Handling_AsgId=getvalue(env_FSG_MPCH_AsgID);
    gMPCall_CC_Handling_CallFunction=CALLFUNCTION_MPRACAWC;
    putvalue(env_FSG_MPCH_CallFunction,gMPCall_CC_Handling_CallFunction);
    settimer(MPRACAWCTimer, MPRACAWCTimerTime);
  }
}

on timer MPRACAWCTimer
{
  byte i, callID, hangups, hangupid;
  char empty_string [3];

  //init lokal variables
  callID=0xff;
  hangups=0;
  hangupid=0;
  for(i=0;i<3;i++)
    empty_string[i]=0;
  //********************

  for(callID=0;callID<7;callID++)
  { //searching for active calls
    if(gCallState[callID]==disconnecting)
    {
      hangups++;
      hangupid=callID;
      set_CallState(callID,idle);
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          putvalue(env_FSG_CallType_CallID_0, empty_string);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          putvalue(env_FSG_CallType_CallID_1, empty_string);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          putvalue(env_FSG_CallType_CallID_2, empty_string);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          putvalue(env_FSG_CallType_CallID_3, empty_string);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          putvalue(env_FSG_CallType_CallID_4, empty_string);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          putvalue(env_FSG_CallType_CallID_5, empty_string);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          putvalue(env_FSG_CallType_CallID_6, empty_string);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone MPRACAWCTimer: unknown call-ID %d", callID);
        break;
      }
      //*************************************
      //**********call info******************
      for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
        gCallInfo_PbName[callID][i]=0;
      for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
        gCallInfo_PbName_hex[callID][i] = 0;
      for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
        gCallInfo_TelNumber[callID][i]=0;
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallInfo_PbName_0, gCallInfo_PbName[0]);
          putvalue(env_FSG_CallInfo_PbName_0_data, gCallInfo_PbName_hex[0]);
          putvalue(env_FSG_CallInfo_TelNumber_0, gCallInfo_TelNumber[0]);
        break;
        case 1:
          putvalue(env_FSG_CallInfo_PbName_1, gCallInfo_PbName[1]);
          putvalue(env_FSG_CallInfo_PbName_1_data, gCallInfo_PbName_hex[1]);
          putvalue(env_FSG_CallInfo_TelNumber_1, gCallInfo_TelNumber[1]);
        break;
        case 2:
          putvalue(env_FSG_CallInfo_PbName_2, gCallInfo_PbName[2]);
          putvalue(env_FSG_CallInfo_PbName_2_data, gCallInfo_PbName_hex[2]);
          putvalue(env_FSG_CallInfo_TelNumber_2, gCallInfo_TelNumber[2]);
        break;
        case 3:
          putvalue(env_FSG_CallInfo_PbName_3, gCallInfo_PbName[3]);
          putvalue(env_FSG_CallInfo_PbName_3_data, gCallInfo_PbName_hex[3]);
          putvalue(env_FSG_CallInfo_TelNumber_3, gCallInfo_TelNumber[3]);
        break;
        case 4:
          putvalue(env_FSG_CallInfo_PbName_4, gCallInfo_PbName[4]);
          putvalue(env_FSG_CallInfo_PbName_4_data, gCallInfo_PbName_hex[4]);
          putvalue(env_FSG_CallInfo_TelNumber_4, gCallInfo_TelNumber[4]);
        break;
        case 5:
          putvalue(env_FSG_CallInfo_PbName_5, gCallInfo_PbName[5]);
          putvalue(env_FSG_CallInfo_PbName_5_data, gCallInfo_PbName_hex[5]);
          putvalue(env_FSG_CallInfo_TelNumber_5, gCallInfo_TelNumber[5]);
        break;
        case 6:
          putvalue(env_FSG_CallInfo_PbName_6, gCallInfo_PbName[6]);
          putvalue(env_FSG_CallInfo_PbName_6_data, gCallInfo_PbName_hex[6]);
          putvalue(env_FSG_CallInfo_TelNumber_6, gCallInfo_TelNumber[6]);
        break;
        default:
          write("error MPRACAWCTimer: invalid call-ID: %d",callID);
        break;
      }
      //*************************************
    }
    else if(gCallState[callID]==ringing_waiting)
    {
      set_CallState(callID,active);                   //set call state
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone MPRACAWCTimer: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
  }

  if(gMPRACAWC_status)
  {
    gMPCall_CC_Handling_Result=SUCCESSFUL;
    MPCall_CC_Handling_Request(Result_REQ, 0);
    gMPRACAWC_status=0;
  }

}

on envVar env_FSG_MP_RAllCAWC
{
  byte i, callID, mprallcawcpossible;

  //init lokal variables
  callID=0xff;
  mprallcawcpossible=0;
  //********************

  //search for available calls
  for(i=0;i<7;i++)
  {
    if(gCallState[i]!=idle && gCallState[i]!=ringing_waiting)
      mprallcawcpossible=1;
  }
  //search for waiting calls
  if(mprallcawcpossible==1)                   // if there are active calls
  {
    mprallcawcpossible=0;
    for(i=0;i<7;i++)
    {
      if(gCallState[i]==ringing_waiting)
        mprallcawcpossible=1;
    }
  }

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && mprallcawcpossible==1)
  {
    for(i=0;i<7;i++)                                //searching for active calls
    {
      if(gCallState[i]!=idle && gCallState[i]!=ringing_waiting)
      {
        callID=i;
        set_CallState(callID,disconnecting);                    //set call state
        //**********CallStates*****************
        switch(callID)
        {
          case 0:
            putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          break;
          case 1:
            putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          break;
          case 2:
            putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          break;
          case 3:
            putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          break;
          case 4:
            putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          break;
          case 5:
            putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          break;
          case 6:
            putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          break;
          default:
            writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MP_RACAWC: unknown call-ID %d", callID);
          break;
        }
        //*************************************
      }
    }
    gMPCall_CC_Handling_AsgId=getvalue(env_FSG_MPCH_AsgID);
    gMPCall_CC_Handling_CallFunction=CALLFUNCTION_MPRALLCAWC;
    putvalue(env_FSG_MPCH_CallFunction,gMPCall_CC_Handling_CallFunction);
    settimer(MPRAllCAWCTimer, MPRAllCAWCTimerTime);
  }
}

on timer MPRAllCAWCTimer
{
  byte i, callID, hangups, hangupid;
  char empty_string [3];

  //init lokal variables
  callID=0xff;
  hangups=0;
  hangupid=0;
  for(i=0;i<3;i++)
    empty_string[i]=0;
  //********************

  for(callID=0;callID<7;callID++)
  { //searching for active calls
    if(gCallState[callID]==disconnecting)
    {
      hangups++;
      hangupid=callID;
      set_CallState(callID,idle);
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          putvalue(env_FSG_CallType_CallID_0, empty_string);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          putvalue(env_FSG_CallType_CallID_1, empty_string);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          putvalue(env_FSG_CallType_CallID_2, empty_string);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          putvalue(env_FSG_CallType_CallID_3, empty_string);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          putvalue(env_FSG_CallType_CallID_4, empty_string);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          putvalue(env_FSG_CallType_CallID_5, empty_string);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          putvalue(env_FSG_CallType_CallID_6, empty_string);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone MPRAllCAWCTimer: unknown call-ID %d", callID);
        break;
      }
      //*************************************
      //**********call info******************
      for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
        gCallInfo_PbName[callID][i]=0;
      for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
        gCallInfo_PbName_hex[callID][i]=0;
      for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
        gCallInfo_TelNumber[callID][i]=0;
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallInfo_PbName_0, gCallInfo_PbName[0]);
          putvalue(env_FSG_CallInfo_PbName_0_data, gCallInfo_PbName_hex[0]);
          putvalue(env_FSG_CallInfo_TelNumber_0, gCallInfo_TelNumber[0]);
        break;
        case 1:
          putvalue(env_FSG_CallInfo_PbName_1, gCallInfo_PbName[1]);
          putvalue(env_FSG_CallInfo_PbName_1_data, gCallInfo_PbName_hex[1]);
          putvalue(env_FSG_CallInfo_TelNumber_1, gCallInfo_TelNumber[1]);
        break;
        case 2:
          putvalue(env_FSG_CallInfo_PbName_2, gCallInfo_PbName[2]);
          putvalue(env_FSG_CallInfo_PbName_2_data, gCallInfo_PbName_hex[2]);
          putvalue(env_FSG_CallInfo_TelNumber_2, gCallInfo_TelNumber[2]);
        break;
        case 3:
          putvalue(env_FSG_CallInfo_PbName_3, gCallInfo_PbName[3]);
          putvalue(env_FSG_CallInfo_PbName_3_data, gCallInfo_PbName_hex[3]);
          putvalue(env_FSG_CallInfo_TelNumber_3, gCallInfo_TelNumber[3]);
        break;
        case 4:
          putvalue(env_FSG_CallInfo_PbName_4, gCallInfo_PbName[4]);
          putvalue(env_FSG_CallInfo_PbName_4_data, gCallInfo_PbName_hex[4]);
          putvalue(env_FSG_CallInfo_TelNumber_4, gCallInfo_TelNumber[4]);
        break;
        case 5:
          putvalue(env_FSG_CallInfo_PbName_5, gCallInfo_PbName[5]);
          putvalue(env_FSG_CallInfo_PbName_5_data, gCallInfo_PbName_hex[5]);
          putvalue(env_FSG_CallInfo_TelNumber_5, gCallInfo_TelNumber[5]);
        break;
        case 6:
          putvalue(env_FSG_CallInfo_PbName_6, gCallInfo_PbName[6]);
          putvalue(env_FSG_CallInfo_PbName_6_data, gCallInfo_PbName_hex[6]);
          putvalue(env_FSG_CallInfo_TelNumber_6, gCallInfo_TelNumber[6]);
        break;
        default:
          write("error MPRAllCAWCTimer: invalid call-ID: %d",callID);
        break;
      }
      //*************************************
    }
    else if(gCallState[callID]==ringing_waiting)
    {
      set_CallState(callID,active);                   //set call state
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone MPRACAWCTimer: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
  }

  if(gMPRAllCAWC_status)
  {
    gMPCall_CC_Handling_Result=SUCCESSFUL;
    MPCall_CC_Handling_Request(Result_REQ, 0);
    gMPRAllCAWC_status=0;
  }
}

void MPCall_CC_Handling_Indication(dword Indication_array [], byte indication, int datalength)
{
  byte i, callID, ccjoinpossible, mpchawcpossible, mpracawcpossible, mprallcawcpossible, mpswappossible, incoming_callholdpossible;
  byte indASGID, indCallFunction, Debil;

  //init lokal variables
  callID=0xff;
  ccjoinpossible=Terror_noactivecall;
  mpchawcpossible=Terror_noactivecall;
  mpracawcpossible=Terror_noactivecall;
  mprallcawcpossible=Terror_nocall;
  mpswappossible=Terror_noactivecall;
  incoming_callholdpossible=0;
  //********************

  //getdata from indication
  indASGID        =Indication_array[3]/0x10;
  indCallFunction =Indication_array[4];

  //check if Call function possible
  /*
  switch(indCallFunction)
  {
    case CALLFUNCTION_CCJOIN:
      //search for active calls
      for(i=0;i<7;i++)
      {
        if(gCallState[i]==active)
          ccjoinpossible=Terror_nocallonhold;
      }
      //search for held calls
      if(ccjoinpossible==Terror_nocallonhold){                        // if there are active calls
        for(i=0;i<7;i++){
          if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
            ccjoinpossible=1;
        }
      }
    break;
    case CALLFUNCTION_MPCHAWC:
      //search for held calls
      for(i=0;i<7;i++)
      {
        if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
          mpchawcpossible=Terror_heldcallpresent;
      }
      //search for active calls
      if(mpchawcpossible!=Terror_heldcallpresent)                     //no held call(s) present
      {
        for(i=0;i<7;i++)
        {
          if(gCallState[i]==active)
            mpchawcpossible=Terror_noincomingwaitingcall;
        }
      }
      //search for waiting calls
      if(mpchawcpossible==Terror_noincomingwaitingcall)               //active call(s) is(are) present
      {
        for(i=0;i<7;i++)
        {
          if(gCallState[i]==ringing_waiting)
            mpchawcpossible=1;
        }
      }
    break;
    case CALLFUNCTION_MPRACAWC:
      //search for active calls
      for(i=0;i<7;i++)
      {
        if(gCallState[i]==active)
          mpracawcpossible=Terror_noincomingwaitingcall;
      }
      //search for waiting calls
      if(mpracawcpossible==Terror_noincomingwaitingcall)              // if there are active calls
      {
        for(i=0;i<7;i++)
        {
          if(gCallState[i]==ringing_waiting)
            mpracawcpossible=1;
        }
      }
    break;
    case CALLFUNCTION_MPRALLCAWC:
      //search for active calls
      for(i=0;i<7;i++)
      {
        if(gCallState[i]!=idle && gCallState[i]!=ringing_waiting)
          mprallcawcpossible=Terror_noincomingwaitingcall;
      }
      //search for waiting calls
      if(mprallcawcpossible==Terror_noincomingwaitingcall)            // if there are active calls
      {
        for(i=0;i<7;i++)
        {
          if(gCallState[i]==ringing_waiting)
            mprallcawcpossible=1;
        }
      }
    break;
    case CALLFUNCTION_MPSWAP:
      //search for active calls
      for(i=0;i<7;i++)
      {
        if(gCallState[i]==active)
          mpswappossible=Terror_nocallonhold;
      }
      //search for held calls
      if(mpswappossible==Terror_nocallonhold)
      {                       // if there are active calls
        for(i=0;i<7;i++){
          if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
            mpswappossible=TRUE;
        }
      }
    break;
    case CALLFUNCTION_MPSWCOH:
      //search for held calls
      for(i=0;i<7;i++)
      {
        if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
          incoming_callholdpossible=Terror_heldcallpresent;
      }
      //search for incoming call
      if(incoming_callholdpossible!=Terror_heldcallpresent)
      {
        incoming_callholdpossible=Terror_noincomingwaitingcall;
        for(i=0;i<7;i++)
        {
          if(gCallState[i]==ringing_waiting)
            incoming_callholdpossible=1;
        }
      }
    break;
  }
  */

  //handling indication
  switch (indication)
  {
    case Processing_CNF:
      gMPCall_CC_Handling_AsgId=indASGID;
      //putvalue(env_FSG_MPCH_AsgID,indASGID);
      gMPCall_CC_Handling_CallFunction=indCallFunction;
      MPCall_CC_Handling_Request(Processing_REQ, 0);                              //send Processing
    break;
    case StartResult_IND:
      gMPCall_CC_Handling_AsgId=indASGID;
      putvalue(env_FSG_MPCH_AsgID,indASGID);
      gMPCall_CC_Handling_CallFunction=indCallFunction;
      putvalue(env_FSG_MPCH_CallFunction,indCallFunction);
      gMPCall_CC_Handling_Result=getvalue(env_FSG_MPCH_Result);
      MPCall_CC_Handling_Request(Result_REQ, 0);
      //now send result depending on CallFunction, e.g. CC Join...
      /*
      switch(indCallFunction)
      {
        case CALLFUNCTION_CCJOIN:
          if(gCCJoin_status!=0)                                                   //method is still active
            MPCall_CC_Handling_Request(Error_REQ, Terror_datainvalid);
          else if(datalength!=3)                                                  //datalength error
            MPCall_CC_Handling_Request(Error_REQ, Terror_datainvalid);            //send error-message to RNS
          else if(gCallActivity==NOCALL)                                          //CC Join is impossible, no call
            MPCall_CC_Handling_Request(Error_REQ, Terror_nocall);                 //send error-message to RNS
          else if(ccjoinpossible!=1)                                              //CC Join is impossible
            MPCall_CC_Handling_Request(Error_REQ, ccjoinpossible);                //send error-message to RNS
          else
          {
            gCCJoin_status=1;                                                     //"MPSwap" active
            settimer(CCJoinTimer, CCJoinTimerTime);
          }
        break;
        case CALLFUNCTION_MPCHAWC:
          if(gMPCHAWC_status!=0)                                                  //method is still active
            MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);
          else if(datalength!=3)                                                  //datalength error
            MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);//send error-message to RNS
          else if(gCallActivity==NOCALL)                                          //MPRACAWC is impossible, no call
            MPCall_CC_Handling_Request(Error_REQ, Terror_nocall);                 //send error-message to RNS
          else if(mpchawcpossible!=1)                                             //MPRACAWC is impossible
            MPCall_CC_Handling_Request(Error_REQ, mpchawcpossible);               //send error-message to RNS
          else
          {
            gMPCHAWC_status=1;                                                    //"MPRACAWC" active
            settimer(MPCHAWCTimer, MPCHAWCTimerTime);
          }
        break;
        case CALLFUNCTION_MPRACAWC:
          if(gMPRACAWC_status!=0)                                                 //method is still active
            MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);
          else if(datalength!=3)                                                  //datalength error
            MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);//send error-message to RNS
          else if(gCallActivity==NOCALL)                                          //MPRACAWC is impossible, no call
            MPCall_CC_Handling_Request(Error_REQ, Terror_nocall);                 //send error-message to RNS
          else if(mpracawcpossible!=1)                                            //MPRACAWC is impossible
            MPCall_CC_Handling_Request(Error_REQ, mpracawcpossible);              //send error-message to RNS
          else
          {
            gMPRACAWC_status=1;                                                   //method "MPRACAWC" active
            for(i=0;i<7;i++)                                                      //searching for active calls
            {
              if(gCallState[i]==active)
              {
                callID=i;
                set_CallState(callID,disconnecting);                              //set call state
                //**********CallStates*****************
                switch(callID)
                {
                  case 0:
                    putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
                  break;
                  case 1:
                    putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
                  break;
                  case 2:
                    putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
                  break;
                  case 3:
                    putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
                  break;
                  case 4:
                    putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
                  break;
                  case 5:
                    putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
                  break;
                  case 6:
                    putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
                  break;
                  default:
                    writelineEx(gError_Trace, 0, "FSG-Telephone MPCall_CC_Handling_Indication: unknown call-ID %d (MPRACAWC)", callID);
                  break;
                }
                //*************************************
              }
            }
            settimer(MPRACAWCTimer, MPRACAWCTimerTime);
          }
        break;
        case CALLFUNCTION_MPRALLCAWC:
          if(gMPRAllCAWC_status!=0)                                               //method is still active
            MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);
          else if(datalength!=3)                                                  //datalength error
            MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);//send error-message to RNS
          else if(gCallActivity==NOCALL)                                          //MPRACAWC is impossible, no call
            MPCall_CC_Handling_Request(Error_REQ, Terror_nocall);                 //send error-message to RNS
          else if(mprallcawcpossible!=1)                                          //MPRACAWC is impossible
            MPCall_CC_Handling_Request(Error_REQ, mprallcawcpossible);            //send error-message to RNS
          else
          {
            gMPRAllCAWC_status=1;                                                 //method "MPRACAWC" active
            for(i=0;i<7;i++)                                                      //searching for active calls
            {
              if(gCallState[i]!=idle && gCallState[i]!=ringing_waiting)
              {
                callID=i;
                set_CallState(callID,disconnecting);                              //set call state
                //**********CallStates*****************
                switch(callID)
                {
                  case 0:
                    putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
                  break;
                  case 1:
                    putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
                  break;
                  case 2:
                    putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
                  break;
                  case 3:
                    putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
                  break;
                  case 4:
                    putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
                  break;
                  case 5:
                    putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
                  break;
                  case 6:
                    putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
                  break;
                  default:
                    writelineEx(gError_Trace, 0, "FSG-Telephone MPCall_CC_Handling_Indication: unknown call-ID %d (MPRAllCAWC)", callID);
                  break;
                }
                //*************************************
              }
            }
            settimer(MPRAllCAWCTimer, MPRAllCAWCTimerTime);
          }
        break;
        case CALLFUNCTION_MPSWAP:
          if(gMPSwap_status!=0)                                                   //method is still active
            MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);
          else if(datalength!=3)                                                  //datalength error
            MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);//send error-message to RNS
          else if(gCallActivity==NOCALL)                                          //MPSwap is impossible, no call
            MPCall_CC_Handling_Request(Error_REQ, Terror_nocall);                 //send error-message to RNS
          else if(mpswappossible!=TRUE)                                           //MPSwap is impossible
            MPCall_CC_Handling_Request(Error_REQ, mpswappossible);                //send error-message to RNS
          else
          {
            gMPSwap_status=1;                                                     //"MPSwap" active
            settimer(MPSwapTimer, MPSwapTimerTime);
          }
        break;
        case CALLFUNCTION_MPSWCOH:
          if(gMPSWCOH_status!=0)
            MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);
          else if(datalength!=3)                                                  //datalength error
            MPCall_CC_Handling_Request(Error_REQ, Terror_unknownapllicationerror);//send error-message to RNS
          else if(gCallActivity==NOCALL)                                          //incoming_CallHold is impossible, no call
            MPCall_CC_Handling_Request(Error_REQ, Terror_nocall);                 //send error-message to RNS
          else if(incoming_callholdpossible!=1)                                   //incommin_CallHold is impossible
            MPCall_CC_Handling_Request(Error_REQ, incoming_callholdpossible);     //send error-message to RNS
          else
          {
            gMPSWCOH_status=1;                                                    //"MPSWCOH" active
            settimer(MPSWCOHTimer, MPSWCOHTimerTime);
          }
        break;
      }
      */
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG-Telephone MPCall_CC_Handling_Indication: unknown indication %d", indication);
    break;
  }
}

on timer CCJoinTimer
{
  byte i, callID;

  //init lokal variables
  callID=0xff;
  //********************

  for(i=0;i<7;i++)
  { //searching for active calls
    if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
    {
      callID=i;
      gCallType[callID]=CONFERENCE_VOICE_CALL;    //set call type
      set_CallState(callID,active);               //set call state
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
          putvalue(env_FSG_CallType_CallID_0, gstring_calltype[gCallType[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
          putvalue(env_FSG_CallType_CallID_1, gstring_calltype[gCallType[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
          putvalue(env_FSG_CallType_CallID_2, gstring_calltype[gCallType[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
          putvalue(env_FSG_CallType_CallID_3, gstring_calltype[gCallType[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
          putvalue(env_FSG_CallType_CallID_4, gstring_calltype[gCallType[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
          putvalue(env_FSG_CallType_CallID_5, gstring_calltype[gCallType[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
          putvalue(env_FSG_CallType_CallID_6, gstring_calltype[gCallType[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone CCJoinTimer: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
    else if(gCallState[i]==active)
    {
      callID=i;
      gCallType[callID]=CONFERENCE_VOICE_CALL;                  //set call type
      set_CallState(callID,active);                             //update CallOptions
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallType_CallID_0, gstring_calltype[gCallType[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallType_CallID_1, gstring_calltype[gCallType[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallType_CallID_2, gstring_calltype[gCallType[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallType_CallID_3, gstring_calltype[gCallType[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallType_CallID_4, gstring_calltype[gCallType[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallType_CallID_5, gstring_calltype[gCallType[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallType_CallID_6, gstring_calltype[gCallType[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone CCJoinTimer: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
  }
  gMPCall_CC_Handling_Result=SUCCESSFUL;
  MPCall_CC_Handling_Request(Result_REQ, 0);
  gCCJoin_status=0;                             //"CCJoin" finished
}

on timer MPCHAWCTimer
{
  byte i, callID;
  char empty_string [3];

  //init lokal variables
  callID=0xff;
  for(i=0;i<3;i++)
    empty_string[i]=0;
  //********************

  for(i=0;i<7;i++)                              //searching for active calls
  {
    if(gCallState[i]==active)
    {
      callID=i;
      set_CallState(callID,onhold);                       //set call state
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MP_RACAWC: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
  }
  for(i=0;i<7;i++)                                //searching for active calls
  {
    if(gCallState[i]==ringing_waiting)
    {
      callID=i;
      set_CallState(callID,active);                       //set call state
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MP_RACAWC: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
  }
  gMPCall_CC_Handling_Result=SUCCESSFUL;
  MPCall_CC_Handling_Request(Result_REQ, 0);
  gMPCHAWC_status=0;
}

on timer MPSwapTimer
{
  byte i, callID;

  //init lokal variables
  callID=0xff;
  //********************

  for(i=0;i<7;i++)
  { //searching for active calls
    if(gCallState[i]==active)
    {
      callID=i;
      set_CallState(callID,onhold);                     //set call state
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MPSwap: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
    else if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
    {
      callID=i;
      set_CallState(callID,active);                     //set call state
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone env_FSG_MPSwap: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
  }
  gMPCall_CC_Handling_Result=SUCCESSFUL;
  MPCall_CC_Handling_Request(Result_REQ, 0);
  gMPSwap_status=0;                             //method "acceptcal" finished
}

on timer MPSWCOHTimer
{
  byte i, callID;

  //init lokal variables
  callID=0xff;
  //********************

  for(i=0;i<7;i++)
  { //searching for active calls
    if(gCallState[i]==ringing_waiting)
    {
      callID=i;
      set_CallState(callID,INCOMING_ON_HOLD);                       //set call state
      //**********CallStates*****************
      switch(callID)
      {
        case 0:
          putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
        break;
        case 1:
          putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
        break;
        case 2:
          putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
        break;
        case 3:
          putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
        break;
        case 4:
          putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
        break;
        case 5:
          putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
        break;
        case 6:
          putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
        break;
        default:
          writelineEx(gError_Trace, 0, "FSG-Telephone set_CallState: unknown call-ID %d", callID);
        break;
      }
      //*************************************
    }
  }
  if(callID<7)
  {                                                 //incoming_hold call is possible
    gMPCall_CC_Handling_Result=SUCCESSFUL;
    MPCall_CC_Handling_Request(Result_REQ, 0);
    gMPSWCOH_status=0;                              //"MPSWCOH" finished
  }
  else
  {                                                 //no incoming call available
    MPCall_CC_Handling_Request(Error_REQ, Terror_noincomingwaitingcall);
    gMPSWCOH_status=0;                              //"MPSWCOH" finished
  }
}

void MPCall_CC_Handling_Request (byte request, byte errorcode)
{
  int i, length, Offset;
  dword requestarray [BAP_buffer_size];

  //init lokal variables
  length=0;
  Offset=0;
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;
  //********************

  switch(request)
  {
    case Processing_REQ:
      requestarray[0]=LSGID_Telephone;            //LSG-ID
      requestarray[1]=FctID_MPCall_CC_Handling;   //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gMPCall_CC_Handling_Extension1+(gMPCall_CC_Handling_AsgId*0x10);
      requestarray[4]=gMPCall_CC_Handling_CallFunction;
      requestarray[5]=gMPCall_CC_Handling_Extension2 & 0x0F; //Extension2 lower nibble & Reserve1 is 0
      Offset=6;
      set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
    break;
    case Result_REQ:
      requestarray[0]=LSGID_Telephone;            //LSG-ID
      requestarray[1]=FctID_MPCall_CC_Handling;   //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=gMPCall_CC_Handling_Extension1+(gMPCall_CC_Handling_AsgId*0x10);
      requestarray[4]=gMPCall_CC_Handling_CallFunction;
      requestarray[5]=gMPCall_CC_Handling_Extension2;
      requestarray[6]=gMPCall_CC_Handling_Result;
      Offset=7;
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[0]=LSGID_Telephone;            //LSG-ID
      requestarray[1]=FctID_MPCall_CC_Handling;   //Fct.-ID
      requestarray[2]=request;
      requestarray[3]=errorcode;
      Offset=4;
      set_status_requestbuffer (requestarray, Offset, Bap_Error);
    break;
    default:  //error
      writelineEx(gError_Trace, 0, "FSG-Telephone MPCall_CC_Handling_Request: unknown request %d", request);
    break;
  }
}

//*************************************************************************
//*****************CombinedNumbers*****************************************
void CombinedNumbers_Indication(dword Indication_array [])
{
  byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
  word valid_startelement, requested_startelement, startelement, elements, Offset;
  int i=0;

  // Init local variables
  mode = 0;
  direction = 0;
  shift = 0;
  transmitpos = 0;
  recordaddress = 0;
  requested_startelement = 0;
  startelement = 0;
  elements = 0;
  indexsize = 0;
  valid_startelement = 0xff;
  valid_elements = 0;
  Offset = 0;

  write("FSG - CombinedNumbers_Indication...");

  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      //getData
      gCombinedNumbers_ASGID = (gBAP_Indication[3] &0xF0) /0x10;
      gCombinedNumbers_TAID = gBAP_Indication[3] &0x0F;
      gCombinedNumbers_Extension = gBAP_Indication[4];

      //decode BAP-ArrayHeader
      mode = (gBAP_Indication[5] &0xF0) /0x10;

      // decode "mode-byte"
      shift       =  mode &0x01;
      direction   = (mode &0x02)/0x02;
      transmitpos = (mode &0x04)/0x04;
      indexsize   = (mode &0x08)/0x08;

      recordaddress = gBAP_Indication[5] &0x0F;
      if(indexsize)
      {
        startelement = gBAP_Indication[6];
        startelement+= gBAP_Indication[7] *0x100;
        elements = gBAP_Indication[8];
        elements+= gBAP_Indication[9]*0x100;
      }
      else
      {
        startelement = gBAP_Indication[6];
        elements = gBAP_Indication[7];
      }
      requested_startelement = startelement;
      // transmitpos = TRUE;
      mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

      /***Startelement=0***/
      if(startelement == 0) //Startelement-ID =0 -> start at first array-entry
      {
        if(FORWARD==direction)  //forward-start
        {
          valid_startelement =0;
          if(TEL_COMBINEDNUMBERS_ENTRIES <=elements) //1. more elements requested, than in array
          {
            if (shift ==FALSE)
            {
              for(i=0;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
              {
                if(0 !=gCombinedNumbers_ListEntryValidInformation[i]) //if there is an valid element
                  valid_elements++;         //increment elements
                else                        //no valid element, loop finished
                  i =TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
            else if (shift ==TRUE)
            {
              valid_startelement  =1;
              startelement        =valid_startelement;

              for(i=1;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
              {
                if(0 !=gCombinedNumbers_ListEntryValidInformation[i]) //if there is an valid element
                  valid_elements++;         //increment elements
                else                        //no valid element, loop finished
                  i =TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
          }
          else    //2. number of requested elements < elements in array
          {
            if (shift ==FALSE)
            {
              for(i=0;i<elements;i++)
              {
                if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;         //increment elements
                else                        //no valid element, loop finished
                  i =TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
            else if (shift ==TRUE)
            {
              valid_startelement = 1;
              startelement = valid_startelement;

              for(i=1;i<=elements;i++)
              {
                if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;         //increment elements
                else                        //no valid element, loop finished
                  i =TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
          }
        }                                                               //forward ends
        else if(BACKWARD==direction && TRUE==shift)           //backward-start, only if the shift bit is set (this means starting with the last element of the array)
        {
          //searching for valid startelement
          for(i=(TEL_COMBINEDNUMBERS_ENTRIES-1);i>=0;i--)
          {
            if(0!=gCombinedNumbers_ListEntryValidInformation[i])    //found valid startelement
            {
              valid_startelement =i;
              i =0;
            }
          }
          //searching for valid elements
          if(0xff==valid_startelement)                //Startelement-ID doesn't exist in SMSReceived-array
          {
            valid_startelement  =startelement;
            valid_elements      =0;
          }
          else if(0==valid_startelement)
            valid_elements=1;                                      //only 1 element because valid startelement is on position 0
          else if(elements>(valid_startelement+1))          //not enougth array-elements available, because array endet at array-position 0
          {
            for(i=valid_startelement;i>=0;i--)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;               //increment elements
              else                        //no valid element, loop finished
                i=0;
            }
          }
          else                            //enougth array-elements available
          {
            for(i=valid_startelement;i>(valid_startelement-elements);i--)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;               //increment elements
              else                        //no valid element, loop finished
                i=0;
            }

          }
        } //backward-end
      } //startelement ==0 -end
      /***Startelement!=0***/
      else                                //searching for Startelement-ID
      {
        //searching for valid startelement
        for(i=0;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
        {
          if(gCombinedNumbers_Pos[i] ==startelement)              //found a valid element
          {
            if(shift==TRUE)                     //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
            {
              if(i!=0 || BACKWARD!=direction)           //if valid_startelement is not the first array element or direction is not backwards
                valid_startelement =i+1-2*direction;
              else if(i==0 && BACKWARD==direction)
                valid_startelement =gCombinedNumbers_sum;     //valid element is last element in Array
              else if(i==0 && FORWARD==direction)
                valid_startelement =0;                          //valid element is first element in Array
            }
            else
              valid_startelement =i;                              //found element is valid_startelement
            i=TEL_COMBINEDNUMBERS_ENTRIES;
          }
        }
        if(0xff==valid_startelement)                    //Startelement-ID doesn't exist in array
        {
          valid_startelement  =startelement;
          valid_elements      =0;
        }
        else                                //found valid entry for startelement in array
        {
          //verify number of valid elements
          if(BACKWARD==direction)                     //backward-start
          {
            if(valid_startelement==0)                 //only 1 element because valid startelement is on position 0
              valid_elements=1;
            else if(elements>(valid_startelement+1))          //not enougth array-elements available, because array endet at array-position 0
            {
              for(i=valid_startelement;i>=0;i--)
              {
                if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=0;
              }
            }
            else                            //enougth array-elements available
            {
              for(i=valid_startelement;i>(valid_startelement-elements);i--)
              {
                if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=0;
              }
            }
          }                               //backward-end
          else                              //forward-start
          {
            if((valid_startelement+elements)>=TEL_COMBINEDNUMBERS_ENTRIES)
            {
              for(i=valid_startelement;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
              {
                //if(0!=gCombinedNumbers_Pos[i])            //if there is an valid element
                if(gCombinedNumbers_ListEntryValidInformation[i])
                                    valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
            else
            {
              for(i=valid_startelement;i<(valid_startelement+elements);i++)
              {
                //if(0!=gCombinedNumbers_Pos[i])                //if there is an valid element
                if(gCombinedNumbers_ListEntryValidInformation[i])
                                    valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
          }
        }
      }
      write("getarray now respond with statusarray -> indexsize=%d",indexsize);
      mode =0;
      mode =CombinedNumbers_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);
      //send StatusArray
      CombinedNumbers_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
      //Panel
      putvalue(env_FSG_CN_ASGID,gCombinedNumbers_ASGID);
      putvalue(env_FSG_CN_TAID,gCombinedNumbers_TAID);
      putvalue(env_FSG_CN_AH_shift,shift);
      putvalue(env_FSG_CN_AH_dir,direction);
      putvalue(env_FSG_CN_AH_POS,transmitpos);
      putvalue(env_FSG_CN_AH_IS,indexsize);
      putvalue(env_FSG_CN_AH_RA,recordaddress);
      putvalue(env_FSG_CN_AH_start,startelement);
      putvalue(env_FSG_CN_AH_elements,elements);
    break;
    case DataSetGet_IND:
      //getData
      gCombinedNumbers_ASGID = (gBAP_Indication[3] &0xF0) /0x10;
      gCombinedNumbers_TAID = gBAP_Indication[3] &0x0F;
      gCombinedNumbers_Extension = gBAP_Indication[4];
      //decode BAP-ArrayHeader
      mode                =(gBAP_Indication[5] &0xF0) /0x10;
      // decode "mode-byte"
      shift       =mode &0x01;
      direction   =(mode &0x02)/0x02;
      transmitpos =(mode &0x04)/0x04;
      indexsize   =(mode &0x08)/0x08;
      recordaddress       =gBAP_Indication[5] &0x0F;
      if(indexsize)
      {
          startelement        =gBAP_Indication[6];
          startelement        +=gBAP_Indication[7] *0x100;
          elements            =gBAP_Indication[8];
          elements            +=gBAP_Indication[9]*0x100;
          Offset =10;
      }
      else
      {
          startelement        =gBAP_Indication[6];
          elements            =gBAP_Indication[7];
          Offset =8;
      }
      requested_startelement =startelement;
      //transmitpos     =FALSE; //Position must always be sent in the case of *.StatusArray.
      mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

      /***Startelement=0***/
      if(0==startelement) //Startelement-ID =0 -> start at first array-entry
      {
        if(FORWARD==direction)  //forward-start
        {
          valid_startelement =0;
          if(TEL_COMBINEDNUMBERS_ENTRIES <=elements) //1. more elements requested, than in array
          {
            if (shift ==FALSE)
            {
              for(i=0;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
              {
                if(0 !=gCombinedNumbers_ListEntryValidInformation[i]) //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i =TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
            else if (shift ==TRUE)
            {
              valid_startelement  =1;
              startelement        =valid_startelement;
              for(i=1;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
              {
                if(0 !=gCombinedNumbers_ListEntryValidInformation[i]) //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i =TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
          }
          else    //2. number of requested elements < elements in array
          {
            if (shift ==FALSE)
            {
              for(i=0;i<elements;i++)
              {
                if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i =TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
            else if (shift ==TRUE)
            {
              valid_startelement  =1;
              startelement        =valid_startelement;
              for(i=1;i<=elements;i++)
              {
                if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i =TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
          }
        }                                                               //forward ends
        else if(BACKWARD==direction && TRUE==shift)           //backward-start, only if the shift bit is set (this means starting with the last element of the array)
        {
          //searching for valid startelement
          for(i=(TEL_COMBINEDNUMBERS_ENTRIES-1);i>=0;i--)
          {
            if(0!=gCombinedNumbers_ListEntryValidInformation[i])    //found valid startelement
            {
              valid_startelement =i;
              i =0;
            }
          }
          //searching for valid elements
          if(0xff==valid_startelement)                //Startelement-ID doesn't exist in SMSReceived-array
          {
            valid_startelement  =startelement;
            valid_elements      =0;
          }
          else if(0==valid_startelement)
            valid_elements=1;                                       //only 1 element because valid startelement is on position 0

          else if(elements>(valid_startelement+1))          //not enougth array-elements available, because array endet at array-position 0
          {
            for(i=valid_startelement;i>=0;i--)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;               //increment elements
              else                        //no valid element, loop finished
                i=0;
            }
          }
          else                            //enougth array-elements available
          {
            for(i=valid_startelement;i>(valid_startelement-elements);i--)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;               //increment elements
              else                        //no valid element, loop finished
                i=0;
            }

          }
        }                                                               //backward-end
      }                                                                   //startelement ==0 -end
      /***Startelement!=0***/
      else                                //searching for Startelement-ID
      {
        //searching for valid startelement
        for(i=0;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
        {
          if(gCombinedNumbers_Pos[i] ==startelement)              //found a valid element
          {
            if(shift==TRUE)                     //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
            {
              if(i!=0 || BACKWARD!=direction)           //if valid_startelement is not the first array element or direction is not backwards
                valid_startelement =i+1-2*direction;
              else if(i==0 && BACKWARD==direction)
                valid_startelement =gCombinedNumbers_sum;     //valid element is last element in Array
              else if(i==0 && FORWARD==direction)
                valid_startelement =0;                          //valid element is first element in Array
            }
            else
              valid_startelement =i;                              //found element is valid_startelement

            i=TEL_COMBINEDNUMBERS_ENTRIES;
          }
        }
        if(0xff==valid_startelement)                    //Startelement-ID doesn't exist in array
        {
          valid_startelement  =startelement;
          valid_elements      =0;
        }
        else                                //found valid entry for startelement in array
        {
          //verify number of valid elements
          if(BACKWARD==direction)                     //backward-start
          {
            if(valid_startelement==0)                 //only 1 element because valid startelement is on position 0
              valid_elements=1;
            else if(elements>(valid_startelement+1))          //not enougth array-elements available, because array endet at array-position 0
            {
              for(i=valid_startelement;i>=0;i--)
              {
                if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=0;
              }
            }
            else                            //enougth array-elements available
            {
              for(i=valid_startelement;i>(valid_startelement-elements);i--)
              {
                if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=0;
              }
            }
          }                               //backward-end
          else                              //forward-start
          {
            if((valid_startelement+elements)>=TEL_COMBINEDNUMBERS_ENTRIES)
            {
              for(i=valid_startelement;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
              {
                if(0!=gCombinedNumbers_Pos[i])            //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
            else
            {
              for(i=valid_startelement;i<(valid_startelement+elements);i++)
              {
                if(0!=gCombinedNumbers_Pos[i])                //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=TEL_COMBINEDNUMBERS_ENTRIES;
              }
            }
          }
        }
      }
      if(getvalue(env_FSG_CN_SetGetArray_behaviour) && valid_elements>0)
        CombinedNumbers_TakeOverData(Indication_array, Offset, valid_startelement, valid_elements, recordaddress, direction, transmitpos, indexsize);
      write("getarray now respond with statusarray -> indexsize=%d",indexsize);
      mode =0;
      mode =CombinedNumbers_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);
      //send StatusArray
      CombinedNumbers_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
      //Panel
      putvalue(env_FSG_CN_ASGID,gCombinedNumbers_ASGID);
      putvalue(env_FSG_CN_TAID,gCombinedNumbers_TAID);
      putvalue(env_FSG_CN_AH_shift,shift);
      putvalue(env_FSG_CN_AH_dir,direction);
      putvalue(env_FSG_CN_AH_POS,transmitpos);
      putvalue(env_FSG_CN_AH_IS,indexsize);
      putvalue(env_FSG_CN_AH_RA,recordaddress);
      putvalue(env_FSG_CN_AH_start,startelement);
      putvalue(env_FSG_CN_AH_elements,elements);
      //check FSG Cache
      CombinedNumbers_CheckCache();
    break;
    case Error_IND:
      writelineEx(gError_Trace, 0, "FSG_Telepfhone CombinedNumbers_Indication: received error, errorcode:0x%x", Indication_array[3]);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_Telepfhone CombinedNumbers_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void CombinedNumbers_Request (byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{
  int  i;
  byte shift, direction, transmitpos, indexsize, current_element;
  dword requestarray [BAP_buffer_size], Offset;
  word CombinedNumbersLine;

  // Init local variables.
  for(i=0;i<BAP_buffer_size;i++)
  requestarray [i]=0;

  shift               =0;
  direction           =0;
  transmitpos         =0;
  indexsize           =0;
  CombinedNumbersLine =0;
  current_element     =0;
  Offset              =0;

  // decode "mode-byte"
  shift       =mode &0x01;
  direction   =(mode &0x02)/0x02;
  transmitpos =(mode &0x04)/0x04;
  indexsize   =(mode &0x08)/0x08;

  // Handle request.
  requestarray[0] =LSGID_Telephone;       //LSG-ID
  requestarray[1] =FctID_CombinedNumbers;   //Fct.-ID
  requestarray[2] =request;                   //request type
  Offset =3;

  switch(request)
  {
    case Changed_REQ:
      /***Extension***/
      requestarray[Offset] = gCombinedNumbers_Extension;
      Offset++;
      /***ArrayHeader***/
      requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
      Offset++;
      if(indexsize)
      {
        requestarray[Offset] =requested_startelement &0xff;
        Offset++;
        requestarray[Offset] =(requested_startelement &0xff00) /0x100;
        Offset++;
        requestarray[Offset] =elements &0xff;
        Offset++;
        requestarray[Offset] =(elements &0xff00) /0x100;
        Offset++;
      }
      else
      {
        requestarray[Offset] =requested_startelement;
        Offset++;
        requestarray[Offset] =elements;
        Offset++;
      }
      CombinedNumbersLine =startelement;
      if(getvalue(env_FSG_CN_CA_switch)) //if "ArrayHeader + Data"
      {
        //copy data
        switch(recordaddress)
        {
          case 0: //complete record (reserved FRU)
            while(current_element <elements)
            {
              if(CombinedNumbersLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                // Pos
                if (transmitpos) // ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                    Offset++;
                  }
                }
                //PbName
                requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
                Offset++;
                for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
                {
                  requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];
                  Offset++;
                }
                //CallMode & NumberType
                requestarray[Offset] = gCombinedNumbers_NumberType[CombinedNumbersLine] << 4;
                requestarray[Offset] += gCombinedNumbers_CallMode[CombinedNumbersLine];
                Offset++;
                //TelNumber
                requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
                Offset++;
                for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
                {
                  requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];
                  Offset++;
                }
                //Day
                requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
                Offset++;
                //Month
                requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
                Offset++;
                //Year
                requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
                Offset++;
                //Hour
                requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
                Offset++;
                //Minute
                requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
                Offset++;
                //Second
                requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
                Offset++;
                //Picture_Reference
                requestarray[Offset] =gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0x00FF;
                Offset++;
                requestarray[Offset] =(gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0xFF00) / 0x0100;
                Offset++;
              }
              current_element++;
              CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
            }//end while
          break;
          case 1: //complete record
            while(current_element <elements)
            {
              if(CombinedNumbersLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                // Pos
                if (transmitpos) // ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                    Offset++;
                  }
                }
                //PbName
                requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
                Offset++;
                for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
                {
                  requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];
                  Offset++;
                }
                //CallMode & NumberType
                requestarray[Offset] = gCombinedNumbers_NumberType[CombinedNumbersLine] << 4;
                requestarray[Offset] += gCombinedNumbers_CallMode[CombinedNumbersLine];
                Offset++;
                //TelNumber
                requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
                Offset++;
                for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
                {
                  requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];
                  Offset++;
                }
                //Day
                requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
                Offset++;
                //Month
                requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
                Offset++;
                //Year
                requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
                Offset++;
                //Hour
                requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
                Offset++;
                //Minute
                requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
                Offset++;
                //Second
                requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
                Offset++;
                //Picture_Reference
                requestarray[Offset] =gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0x00FF;
                Offset++;
                requestarray[Offset] =(gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0xFF00) / 0x0100;
                Offset++;
              }
              current_element++;
              CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
            }//end while
          break;
          case 2: //PbName, NumberType, CallMode, TelNumber, Day, Month, Year, Hour, Minute, Second
            while(current_element <elements)
            {
              if(CombinedNumbersLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                // Pos
                if (transmitpos) // ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                    Offset++;
                  }
                }
                //PbName
                requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
                Offset++;
                for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
                {
                  requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];
                  Offset++;
                }
                //CallMode & NumberType
                requestarray[Offset] = gCombinedNumbers_NumberType[CombinedNumbersLine] << 4;
                requestarray[Offset] += gCombinedNumbers_CallMode[CombinedNumbersLine];
                Offset++;
                //TelNumber
                requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
                Offset++;
                for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
                {
                  requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];
                  Offset++;
                }
                //Day
                requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
                Offset++;
                //Month
                requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
                Offset++;
                //Year
                requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
                Offset++;
                //Hour
                requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
                Offset++;
                //Minute
                requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
                Offset++;
                //Second
                requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
                Offset++;
              }
              current_element++;
              CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
            }//end while
          break;
          case 3: //PbName, NumberType, CallMode
            while(current_element <elements)
            {
              if(CombinedNumbersLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                // Pos
                if (transmitpos) // ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                    Offset++;
                  }
                }
                //PbName
                requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
                Offset++;
                for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
                {
                  requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];
                  Offset++;
                }
                //CallMode & NumberType
                requestarray[Offset] = gCombinedNumbers_NumberType[CombinedNumbersLine] << 4;
                requestarray[Offset] += gCombinedNumbers_CallMode[CombinedNumbersLine];
                Offset++;
              }
              current_element++;
              CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
            }//end while
          break;
          case 4: //TelNumber, Day, Month, Year, Hour, Minute, Second
            while(current_element <elements)
            {
              if(CombinedNumbersLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                // Pos
                if (transmitpos) // ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                    Offset++;
                  }
                }
                //TelNumber
                requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
                Offset++;
                for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
                {
                  requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];
                  Offset++;
                }
                //Day
                requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
                Offset++;
                //Month
                requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
                Offset++;
                //Year
                requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
                Offset++;
                //Hour
                requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
                Offset++;
                //Minute
                requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
                Offset++;
                //Second
                requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
                Offset++;
              }
              current_element++;
              CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
            }//end while
          break;
          case 5: //Picture_Reference
            while(current_element <elements)
            {
              if(CombinedNumbersLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                // Pos
                if (transmitpos) // ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                    Offset++;
                  }
                }
                //Picture_Reference
                requestarray[Offset] =gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0x00FF;
                Offset++;
                requestarray[Offset] =(gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0xFF00) / 0x0100;
                Offset++;
              }
              current_element++;
              CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
            }//end while
          break;
          case 15: //Pos
            while(current_element <elements)
            {
              if(CombinedNumbersLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                    Offset++;
                  }
                }
              }
              current_element++;
              CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
            }//end while
          break;
          default:
            write("FSG-Telephone CombinedNumbers_Request: invalid recordaddress %d", recordaddress);
          break;
        } //end switch "recordaddress"
      } //end if "ArrayHeader + Data"
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break; //end Changed_REQ
    case Data_REQ:
      /***ASGID & TAID***/
      requestarray[Offset] =((gCombinedNumbers_ASGID *0x10) &0xF0) +(gCombinedNumbers_TAID &0x0F);
      Offset++;
      /***Extension***/
      requestarray[Offset] =gCombinedNumbers_Extension;
      Offset++;
      /***TNLE***/
      requestarray[Offset] =gCombinedNumbers_TotalNumListElements;
      Offset++;
      /***ArrayHeader***/
      requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
      Offset++;
      if(indexsize)
      {
        requestarray[Offset] =requested_startelement &0xff;
        Offset++;
        requestarray[Offset] =(requested_startelement &0xff00) /0x100;
        Offset++;

        requestarray[Offset] =elements &0xff;
        Offset++;
        requestarray[Offset] =(elements &0xff00) /0x100;
        Offset++;
      }
      else
      {
        requestarray[Offset] =requested_startelement;
        Offset++;
        requestarray[Offset] =elements;
        Offset++;
      }
      CombinedNumbersLine =startelement;
      //copy data
      switch(recordaddress)
      {
        case 0: //complete record (reserved FRU)
          while(current_element <elements)
          {
            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              // Pos
              if (transmitpos) // ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                  Offset++;
                }
              }
              //PbName
              requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
              Offset++;
              for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
              {
                requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];
                Offset++;
              }
              //CallMode & NumberType
              requestarray[Offset] = gCombinedNumbers_NumberType[CombinedNumbersLine] << 4;
              requestarray[Offset] += gCombinedNumbers_CallMode[CombinedNumbersLine];
              Offset++;
              //TelNumber
              requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
              Offset++;
              for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
              {
                requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];
                Offset++;
              }
              //Day
              requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
              Offset++;
              //Month
              requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
              Offset++;
              //Year
              requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
              Offset++;
              //Hour
              requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
              Offset++;
              //Minute
              requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
              Offset++;
              //Second
              requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
              Offset++;
              //Picture_Reference
              requestarray[Offset] =gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0x00FF;
              Offset++;
              requestarray[Offset] =(gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0xFF00) / 0x0100;
              Offset++;
            }
            current_element++;
            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
          }//end while
        break;
        case 1: //complete record
          while(current_element <elements)
          {
            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              // Pos
              if (transmitpos) // ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                  Offset++;
                }
              }
              //PbName
              requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
              Offset++;
              for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
              {
                requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];
                Offset++;
              }
              //CallMode & NumberType
              requestarray[Offset] = gCombinedNumbers_NumberType[CombinedNumbersLine] << 4;
              requestarray[Offset] += gCombinedNumbers_CallMode[CombinedNumbersLine];
              Offset++;
              //TelNumber
              requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
              Offset++;
              for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
              {
                requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];
                Offset++;
              }
              //Day
              requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
              Offset++;
              //Month
              requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
              Offset++;
              //Year
              requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
              Offset++;
              //Hour
              requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
              Offset++;
              //Minute
              requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
              Offset++;
              //Second
              requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
              Offset++;
              //Picture_Reference
              requestarray[Offset] =gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0x00FF;
              Offset++;
              requestarray[Offset] =(gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0xFF00) / 0x0100;
              Offset++;
            }
            current_element++;
            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
          }//end while
        break;
        case 2: //PbName, NumberType, CallMode, TelNumber, Day, Month, Year, Hour, Minute, Second
          while(current_element <elements)
          {
            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              // Pos
              if (transmitpos) // ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                  Offset++;
                }
              }
              //PbName
              requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
              Offset++;
              for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
              {
                requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];
                Offset++;
              }
              //CallMode & NumberType
              requestarray[Offset] = gCombinedNumbers_NumberType[CombinedNumbersLine] << 4;
              requestarray[Offset] += gCombinedNumbers_CallMode[CombinedNumbersLine];
              Offset++;
              //TelNumber
              requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
              Offset++;
              for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
              {
                requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];
                Offset++;
              }
              //Day
              requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
              Offset++;
              //Month
              requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
              Offset++;
              //Year
              requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
              Offset++;
              //Hour
              requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
              Offset++;
              //Minute
              requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
              Offset++;
              //Second
              requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
              Offset++;
            }
            current_element++;
            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
          }//end while
        break;
        case 3: //PbName, NumberType, CallMode
          while(current_element <elements)
          {
            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              // Pos
              if (transmitpos) // ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                  Offset++;
                }
              }
              //PbName
              requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
              Offset++;
              for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
              {
                requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];
                Offset++;
              }
              //CallMode & NumberType
              requestarray[Offset] = gCombinedNumbers_NumberType[CombinedNumbersLine] << 4;
              requestarray[Offset] += gCombinedNumbers_CallMode[CombinedNumbersLine];
              Offset++;
            }
            current_element++;
            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
          }//end while
        break;
        case 4: //TelNumber, Day, Month, Year, Hour, Minute, Second
          while(current_element <elements)
          {
            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              // Pos
              if (transmitpos) // ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                  Offset++;
                }
              }
              //TelNumber
              requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
              Offset++;
              for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
              {
                requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];
                Offset++;
              }
              //Day
              requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
              Offset++;
              //Month
              requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
              Offset++;
              //Year
              requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
              Offset++;
              //Hour
              requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
              Offset++;
              //Minute
              requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
              Offset++;
              //Second
              requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
              Offset++;
            }
            current_element++;
            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
          }//end while
        break;
        case 5: //Picture_Reference
          while(current_element <elements)
          {
            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              // Pos
              if (transmitpos) // ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                  Offset++;
                }
              }
              //Picture_Reference
              requestarray[Offset] =gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0x00FF;
              Offset++;
              requestarray[Offset] =(gCombinedNumbers_Picture_Reference[CombinedNumbersLine] & 0xFF00) / 0x0100;
              Offset++;
            }
            current_element++;
            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
          }//end while
        break;
        case 15: //Pos
          while(current_element <elements)
          {
            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              if (transmitpos) // Pos  ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                  Offset++;
                }
              }
            }
            current_element++;
            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
          }//end while
        break;
        default:
          write("FSG-Telephone CombinedNumbers_Request: invalid recordaddress %d", recordaddress);
        break;
      } //end switch "recordaddress"
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break; //end Data_REQ
    case Error_REQ:
      requestarray[3] =errorcode;
      set_status_requestbuffer (requestarray, 4, Bap_Error);
    break; //end Error_REQ
  } //end switch "request"
}

byte CombinedNumbers_nextvalidLine (byte current_CombinedNumbersLine, byte direction)
{
  word next_CombinedNumbersLine;
  int i;

  //init lokal variables
  next_CombinedNumbersLine    =0;
  i                           =0;
  //search next "list entry"
  if(((gCombinedNumbers_sum-1)==current_CombinedNumbersLine && FORWARD ==direction) || (0 ==current_CombinedNumbersLine && BACKWARD ==direction)) //last-/fist-element of array reached
    next_CombinedNumbersLine =0xFF;
  else
  {
    next_CombinedNumbersLine =current_CombinedNumbersLine +1-2*direction;       //increment or decrement array-line (depends on direction);
    if(0 ==gCombinedNumbers_ListEntryValidInformation[next_CombinedNumbersLine])  // check if next element is "valid"
      next_CombinedNumbersLine =0xff;
  }
  return(next_CombinedNumbersLine);
}

void CombinedNumbers_init_CSV () //Byte & file selection
{
  dword CSVfileHandle =0, ConfigFileHandle =0, i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
  char buffer_string[TEL_BUFFERSIZE], Path_CSV[TEL_BUFFERSIZE], Path_Config[TEL_BUFFERSIZE];
  byte CombinedNumbersLine =0, buffer_byte[TEL_BUFFERSIZE];
  char CombinedNumbers_Pos_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv
  char CombinedNumbers_CallMode_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];   //help value ->"CallMode" is stored in the ASCII(UTF-8) code in the *.csv
  char CombinedNumbers_Day_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];        //help value ->"Day" is stored in the ASCII(UTF-8) code in the *.csv
  char CombinedNumbers_Month_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];      //help value ->"Month" is stored in the ASCII(UTF-8) code in the *.csv
  char CombinedNumbers_Year_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];       //help value ->"Year" is stored in the ASCII(UTF-8) code in the *.csv
  char CombinedNumbers_Hour_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];       //help value ->"Hour" is stored in the ASCII(UTF-8) code in the *.csv
  char CombinedNumbers_Minute_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];     //help value ->"Minute" is stored in the ASCII(UTF-8) code in the *.csv
  char CombinedNumbers_Second_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];     //help value ->"Second" is stored in the ASCII(UTF-8) code in the *.csv
  char CombinedNumbers_PicRef_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];     //help value ->"Picture_Reference" is stored in the ASCII(UTF-8) code in the *.csv

  if(getvalue(env_FSG_CN_DataSource) == TEL_EXTERNAL_LIST) //output data in write window "FSGCombinedNumbers"
  {
    writeClear(gCombinedNumbers_writeWindow);
    writelineEx(gCombinedNumbers_writeWindow, 0,"*******External CombinedNumbers*******");
    //clear
    for(j=0;j<TEL_COMBINEDNUMBERS_ENTRIES;j++)
    {
      gCombinedNumbers_Pos[j] = 0;
      for(i=0;i<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;i++)
        gCombinedNumbers_PbName[j][i] = 0;
      gCombinedNumbers_CallMode[j]    = 0;
      gCombinedNumbers_NumberType[j]  = 0;
      for(i=0;i<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;i++)
        gCombinedNumbers_TelNumber[j][i] = 0;
      gCombinedNumbers_day[j]     = 0;
      gCombinedNumbers_month[j]   = 0;
      gCombinedNumbers_year[j]    = 0;
      gCombinedNumbers_hour[j]    = 0;
      gCombinedNumbers_minute[j]  = 0;
      gCombinedNumbers_second[j]  = 0;
      gCombinedNumbers_Picture_Reference[j]         = 0;
      gCombinedNumbers_ListEntryValidInformation[j] = 0;
    }
    for(i=0;i<TEL_FILENAME_SIZE; i++) //clear "filename"
      gCombinedNumbers_CSV_filename[i] =0;
    for(j=0;j<TEL_COMBINEDNUMBERS_ENTRIES; j++) //clear "buffer"
    {
      buffer_string[j]    =0;
      buffer_byte[j]      =0;
      for(i=0;i<TEL_TEXTLENGTH;i++) //clear help value
      {
        CombinedNumbers_Pos_string[j][i]        =0;
        CombinedNumbers_CallMode_string[j][i]   =0;
        CombinedNumbers_Day_string[j][i]        =0;
        CombinedNumbers_Month_string[j][i]      =0;
        CombinedNumbers_Year_string[j][i]       =0;
        CombinedNumbers_Hour_string[j][i]       =0;
        CombinedNumbers_Minute_string[j][i]     =0;
        CombinedNumbers_Second_string[j][i]     =0;
        CombinedNumbers_PicRef_string[j][i]     =0;
      }
    }
    i = 0; j = 0; CombinedNumbersLine = 0; current_CSV_line = 0; //reset values
    getvalue(env_FSG_CN_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
    i =0;
    while (Path_CSV[i] !=0) //scan "path"
    {
      if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename"
        count1++;
      i++;
    }
    i =0; j =0; //reset values
    while (Path_CSV[i] !=0) //seperate "path" and "filename"
    {
      if(count2==count1) //get filename after last "\"
      {
        gCombinedNumbers_CSV_filename[j] =Path_CSV[i];
        j++;
        Path_CSV[i] =0;
      }
      if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"
        count2++;
      i++;
    }
    putvalue(env_FSG_CN_DataSource_file, gCombinedNumbers_CSV_filename); //output current loaded *.csv-file on panel
    setFilePath(Path_CSV, 0); //set path for *.csv file
    CSVfileHandle = openFileRead(gCombinedNumbers_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

    if (CSVfileHandle!=0) //*.csv file access successful
    {
      putvalue(env_FSG_CN_DataSource_result, "successful");   //output result on panel
      Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
      for (i=0; i<Num_of_csv_byte; i++) //copy data into "CombinedNumbers"
      {
        if (buffer_byte[i] != 0x3B) //read data if no ";" is detected
        {
          if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in CombinedNumbers) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
          {
            if(current_CSV_line>0 && CombinedNumbersLine<TEL_COMBINEDNUMBERS_ENTRIES) //ignore first line in *.csv file
            {
              //transform 'string' to 'long' for "POS", "CallMode", "Day", "Month", "Year", "Hour", "Minute", "Second" and "Picture_Reference"
              gCombinedNumbers_Pos[CombinedNumbersLine]         = atol(CombinedNumbers_Pos_string[CombinedNumbersLine]);
              gCombinedNumbers_NumberType[CombinedNumbersLine]  = atol(CombinedNumbers_CallMode_string[CombinedNumbersLine]) >> 4;
              gCombinedNumbers_CallMode[CombinedNumbersLine]    = atol(CombinedNumbers_CallMode_string[CombinedNumbersLine]) & 0x0F;
              gCombinedNumbers_day[CombinedNumbersLine]         = atol(CombinedNumbers_Day_string[CombinedNumbersLine]);
              gCombinedNumbers_month[CombinedNumbersLine]       = atol(CombinedNumbers_Month_string[CombinedNumbersLine]);
              gCombinedNumbers_year[CombinedNumbersLine]        = atol(CombinedNumbers_Year_string[CombinedNumbersLine]);
              gCombinedNumbers_hour[CombinedNumbersLine]        = atol(CombinedNumbers_Hour_string[CombinedNumbersLine]);
              gCombinedNumbers_minute[CombinedNumbersLine]      = atol(CombinedNumbers_Minute_string[CombinedNumbersLine]);
              gCombinedNumbers_second[CombinedNumbersLine]      = atol(CombinedNumbers_Second_string[CombinedNumbersLine]);
              gCombinedNumbers_Picture_Reference[CombinedNumbersLine]= atol(CombinedNumbers_PicRef_string[CombinedNumbersLine]);
              gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]  =TRUE;
              CombinedNumbersLine++; // -> next line in *.csv (next record element)
            }
            current_CSV_line++; //next line in *.csv file
            element =0; //start at 'POS' (first record element of "array data")
            j=0; //reset value
          }
          else if(current_CSV_line>0 && CombinedNumbersLine<TEL_COMBINEDNUMBERS_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
          {
            switch (element)
            {
              case 0: //POS
                CombinedNumbers_Pos_string[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              case 1: //PbName
                gCombinedNumbers_PbName[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              case 2: //CallMode
                CombinedNumbers_CallMode_string[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              case 3: //TelNumber
                gCombinedNumbers_TelNumber[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              case 4: //Day
                CombinedNumbers_Day_string[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              case 5: //Month
                CombinedNumbers_Month_string[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              case 6: //Year
                CombinedNumbers_Year_string[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              case 7: //Hour
                CombinedNumbers_Hour_string[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              case 8: //Minute
                CombinedNumbers_Minute_string[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              case 9: //Second
                CombinedNumbers_Second_string[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              case 10: //Picture_Reference
                CombinedNumbers_PicRef_string[CombinedNumbersLine][j] =buffer_byte[i];
                j++;
              break;
              default:
              break;
            }
          }
        }
        else  // ";" is detected ->next record element of "array data"
        {
          element++;
          j=0; //reset value
        }
      }
      gCombinedNumbers_TotalNumListElements =gCombinedNumbers_sum =CombinedNumbersLine; //get "total number of list elements"
      putvalue(env_FSG_CN_TotalNumLE, gCombinedNumbers_TotalNumListElements);
      if(fileClose (CSVfileHandle) !=0) //close *.csv file
        writelineEx(gCombinedNumbers_writeWindow, 0,"Datei '%s' geschlossen", gCombinedNumbers_CSV_filename); //output result
      else
        writelineEx(gCombinedNumbers_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gCombinedNumbers_CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
      writelineEx(gCombinedNumbers_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gCombinedNumbers_CSV_filename); //output result
      putvalue(env_FSG_CN_DataSource_result,"not successful"); //output result
    }
  }
}

on envVar env_FSG_CN_CA
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables.
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    if(getvalue(env_FSG_CN_AH_start) >255 && getvalue(env_FSG_CN_AH_IS) ==0)// check if 8 or 16 bit
      putvalue(env_FSG_CN_AH_IS,1);
    //get data from Panel
    recordaddress   =getvalue(env_FSG_CN_AH_RA);
    shift           =getvalue(env_FSG_CN_AH_shift);
    direction       =getvalue(env_FSG_CN_AH_dir);
    transmitpos     =getvalue(env_FSG_CN_AH_POS);
    indexsize       =getvalue(env_FSG_CN_AH_IS);
    startelement    =getvalue(env_FSG_CN_AH_start);
    elements        =getvalue(env_FSG_CN_AH_elements);
    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    requested_startelement =startelement;

    /***Startelement=0***/
    if(0==startelement)//Startelement-ID =0 -> start at first array-entry
    {
      if(FORWARD==direction)//forward-start
      {
        valid_startelement =0;
        if(TEL_COMBINEDNUMBERS_ENTRIES <=elements)                          //1. more elements requested, than in array
        {
          if (shift ==FALSE)
          {
            for(i=0;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
            {
              if(0 !=gCombinedNumbers_ListEntryValidInformation[i])         //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i =TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =1;
            startelement        =valid_startelement;
            for(i=1;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
            {
              if(0 !=gCombinedNumbers_ListEntryValidInformation[i])         //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i =TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
        }
        else                                                                //2. number of requested elements < elements in array
        {
          if (shift ==FALSE)
          {
            for(i=0;i<elements;i++)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])          //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i =TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =1;
            startelement        =valid_startelement;
            for(i=1;i<=elements;i++)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])          //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i =TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
        }
      } //forward ends
      else if(BACKWARD==direction && TRUE==shift)//backward-start, only if the shift bit is set (this means starting with the last element of the array)
      {
        //searching for valid startelement
        for(i=(TEL_COMBINEDNUMBERS_ENTRIES-1);i>=0;i--)
        {
          if(0!=gCombinedNumbers_ListEntryValidInformation[i])              //found valid startelement
          {
            valid_startelement =i;
            i =0;
          }
        }
        //searching for valid elements
        if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in SMSReceived-array
        {
          valid_startelement  =startelement;
          valid_elements      =0;
        }
        else if(0==valid_startelement)
          valid_elements=1;                                                 //only 1 element because valid startelement is on position 0
        else if(elements>(valid_startelement+1))                            //not enougth array-elements available, because array endet at array-position 0
        {
          for(i=valid_startelement;i>=0;i--)
          {
            if(0!=gCombinedNumbers_ListEntryValidInformation[i])            //if there is an valid element
              valid_elements++;                                             //increment elements
            else                                                            //no valid element, loop finished
              i=0;
          }
        }
        else                                                                //enougth array-elements available
        {
          for(i=valid_startelement;i>(valid_startelement-elements);i--)
          {
            if(0!=gCombinedNumbers_ListEntryValidInformation[i])            //if there is an valid element
              valid_elements++;                                             //increment elements
            else                                                            //no valid element, loop finished
              i=0;
          }
        }
      }//backward-end
    }  //startelement ==0 -end
    /***Startelement!=0***/
    else//searching for Startelement-ID
    {
      //searching for valid startelement
      for(i=0;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
      {
        if(gCombinedNumbers_Pos[i] ==startelement)                          //found a valid element
        {
          if(shift==TRUE)                                                   //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
          {
            if(i!=0 || BACKWARD!=direction)                                 //if valid_startelement is not the first array element or direction is not backwards
              valid_startelement =i+1-2*direction;
            else if(i==0 && BACKWARD==direction)
              valid_startelement =gCombinedNumbers_sum;                     //valid element is last element in Array
            else if(i==0 && FORWARD==direction)
              valid_startelement =0;                                        //valid element is first element in Array
          }
          else
            valid_startelement =i;                                          //found element is valid_startelement
          i =TEL_COMBINEDNUMBERS_ENTRIES;
        }
        else
          valid_startelement =0xff;
      }
      if(0xff==valid_startelement)                                          //Startelement-ID doesn't exist in array
      {
        valid_startelement  =startelement;
        valid_elements      =0;
      }
      else                                                                  //found valid entry for startelement in array
      {
        //verify number of valid elements
        if(BACKWARD==direction)//backward-start
        {
          if(valid_startelement==0)                                         //only 1 element because valid startelement is on position 0
            valid_elements=1;
          else if(elements>(valid_startelement+1))                          //not enougth array-elements available, because array endet at array-position 0
          {
            for(i=valid_startelement;i>=0;i--)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])          //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i=0;
            }
          }
          else                                                              //enougth array-elements available
          {
            for(i=valid_startelement;i>(valid_startelement-elements);i--)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])          //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i=0;
            }
          }
        }   //backward-end
        else//forward-start
        {
          if((valid_startelement+elements)>=TEL_COMBINEDNUMBERS_ENTRIES)
          {
            for(i=valid_startelement;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
            {
              if(0!=gCombinedNumbers_Pos[i])                                //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i=TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
          else
          {
            for(i=valid_startelement;i<(valid_startelement+elements);i++)
            {
              if(0!=gCombinedNumbers_Pos[i])                                //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i=TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
        }
      }
    }
    putvalue(env_FSG_CN_AH_elements, valid_elements);
    //send ChangedArray
    CombinedNumbers_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
  }
}

on envVar env_FSG_CN_StatusArray
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables.
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    if(getvalue(env_FSG_CN_AH_start) >255 && getvalue(env_FSG_CN_AH_IS) ==0)// check if 8 or 16 bit
        putvalue(env_FSG_CN_AH_IS,1);
    //get data from Panel
    gCombinedNumbers_ASGID                =getvalue(env_FSG_CN_ASGID);
    gCombinedNumbers_TAID                 =getvalue(env_FSG_CN_TAID);
    gCombinedNumbers_Extension            =0x00;  //todo -> envvar for extension...
    gCombinedNumbers_TotalNumListElements  =getvalue(env_FSG_CN_TotalNumLE);
    recordaddress   =getvalue(env_FSG_CN_AH_RA);
    shift           =getvalue(env_FSG_CN_AH_shift);
    direction       =getvalue(env_FSG_CN_AH_dir);
    transmitpos     =getvalue(env_FSG_CN_AH_POS);
    indexsize       =getvalue(env_FSG_CN_AH_IS);
    startelement    =getvalue(env_FSG_CN_AH_start);
    elements        =getvalue(env_FSG_CN_AH_elements);
    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    requested_startelement =startelement;

    /***Startelement=0***/
    if(0==startelement)                           //Startelement-ID =0 -> start at first array-entry
    {
      if(FORWARD==direction)                      //forward-start
      {
        valid_startelement =0;
        if(TEL_COMBINEDNUMBERS_ENTRIES <=elements)//1. more elements requested, than in array
        {
          if (shift ==FALSE)
          {
            for(i=0;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
            {
              if(0 !=gCombinedNumbers_ListEntryValidInformation[i]) //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i =TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =1;
            startelement        =valid_startelement;
            for(i=1;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
            {
              if(0 !=gCombinedNumbers_ListEntryValidInformation[i]) //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i =TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
        }
        else                                      //2. number of requested elements < elements in array
        {
          if (shift ==FALSE)
          {
            for(i=0;i<elements;i++)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
               i =TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =1;
            startelement        =valid_startelement;
            for(i=1;i<=elements;i++)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i =TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
        }
      } //forward ends
      else if(BACKWARD==direction && TRUE==shift) //backward-start, only if the shift bit is set (this means starting with the last element of the array)
      {
        //searching for valid startelement
        for(i=(TEL_COMBINEDNUMBERS_ENTRIES-1);i>=0;i--)
        {
          if(0!=gCombinedNumbers_ListEntryValidInformation[i])//found valid startelement
          {
            valid_startelement =i;
            i =0;
          }
        }
        //searching for valid elements
        if(0xff==valid_startelement)              //Startelement-ID doesn't exist in SMSReceived-array
        {
          valid_startelement  =startelement;
          valid_elements      =0;
        }
        else if(0==valid_startelement)
          valid_elements=1;                       //only 1 element because valid startelement is on position 0
        else if(elements>(valid_startelement+1))  //not enougth array-elements available, because array endet at array-position 0
        {
          for(i=valid_startelement;i>=0;i--)
          {
            if(0!=gCombinedNumbers_ListEntryValidInformation[i])//if there is an valid element
              valid_elements++;                   //increment elements
            else                                  //no valid element, loop finished
              i=0;
          }
        }
        else                                      //enougth array-elements available
        {
          for(i=valid_startelement;i>(valid_startelement-elements);i--)
          {
            if(0!=gCombinedNumbers_ListEntryValidInformation[i])//if there is an valid element
              valid_elements++;                   //increment elements
            else                                  //no valid element, loop finished
              i=0;
          }
        }
      }   //backward-end
    }     //startelement ==0 -end
    /***Startelement!=0***/
    else                                          //searching for Startelement-ID
    {
      //searching for valid startelement
      for(i=0;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
      {
        if(gCombinedNumbers_Pos[i] ==startelement)//found a valid element
        {
          if(shift==TRUE)                         //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
          {
            if(i!=0 || BACKWARD!=direction)       //if valid_startelement is not the first array element or direction is not backwards
              valid_startelement =i+1-2*direction;
            else if(i==0 && BACKWARD==direction)
                valid_startelement =gCombinedNumbers_sum;//valid element is last element in Array
            else if(i==0 && FORWARD==direction)
                valid_startelement =0;            //valid element is first element in Array
          }
          else
            valid_startelement =i;                //found element is valid_startelement
          i =TEL_COMBINEDNUMBERS_ENTRIES;
        }
        else
          valid_startelement =0xff;
      }
      if(0xff==valid_startelement)                //Startelement-ID doesn't exist in array
      {
        valid_startelement  =startelement;
        valid_elements      =0;
      }
      else                                        //found valid entry for startelement in array
      {
        //verify number of valid elements
        if(BACKWARD==direction)                   //backward-start
        {
          if(valid_startelement==0)               //only 1 element because valid startelement is on position 0
            valid_elements=1;
          else if(elements>(valid_startelement+1))//not enougth array-elements available, because array endet at array-position 0
          {
            for(i=valid_startelement;i>=0;i--)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])//if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i=0;
            }
          }
          else                                    //enougth array-elements available
          {
            for(i=valid_startelement;i>(valid_startelement-elements);i--)
            {
              if(0!=gCombinedNumbers_ListEntryValidInformation[i])//if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i=0;
            }
          }
        }     //backward-end
        else  //forward-start
        {
          if((valid_startelement+elements)>=TEL_COMBINEDNUMBERS_ENTRIES)
          {
            for(i=valid_startelement;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
            {
              if(0!=gCombinedNumbers_Pos[i])      //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i=TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
          else
          {
            for(i=valid_startelement;i<(valid_startelement+elements);i++)
            {
              if(0!=gCombinedNumbers_Pos[i])      //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i=TEL_COMBINEDNUMBERS_ENTRIES;
            }
          }
        }
      }
    }
    putvalue(env_FSG_CN_AH_elements, valid_elements);
    //send StatusArray
    CombinedNumbers_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
  }
}

on envVar env_FSG_CN_DataSource
{
  if (getvalue(this) ==TEL_DEFAULT_LIST)
  {
    CombinedNumbers_init_static();
    putvalue(env_FSG_CN_DataSource_file, empty_string);
    putvalue(env_FSG_CN_DataSource_result, empty_string);
  }
}

on envVar env_FSG_CN_reload //load external ReceptionList from *.csv
{
  if(getvalue(this) && getvalue(env_FSG_CN_DataSource) ==TEL_EXTERNAL_LIST)
    CombinedNumbers_init_CSV();
  else if(getvalue(env_FSG_CN_DataSource) != TEL_EXTERNAL_LIST)
    putvalue(env_FSG_CN_DataSource_result,"not successful, select 'external *.csv'");
}

byte CombinedNumbers_buildModeByte (word requested_startelement, word startelement, word elements, byte shift, byte direction, byte transmitpos, byte indexsize)
{
  int  i;
  word CombinedNumbersLine;
  byte mode;

  //init variables
  indexsize           =0;
  i                   =0;
  CombinedNumbersLine =0;
  mode                =0;
  if(requested_startelement >0xFE)
      indexsize =TRUE;
  else
  {
    CombinedNumbersLine =startelement;
    while(i <elements)
    {
      if(CombinedNumbersLine ==0xff) //Invalid "list entry"
        i =elements;
      else //"list entry" valid
      {
        if(gCombinedNumbers_Pos[CombinedNumbersLine] >0xFE)
          indexsize =TRUE;
      }
      i++;
      CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
    }//end while
  }//end else
  //build mode byte
  mode    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
  return (mode);
}

void CombinedNumbers_TakeOverData (dword Indication_array [], word Offset, word startelement, word elements, byte recordaddress, byte direction, byte transmitpos, byte indexsize)
{
  int i =0, j =0, length =0;
  word current_CombinedNumbersLine =0;
  word wTemp=0;

  for(i=0;i<TEL_COMBINEDNUMBERS_ENTRIES;i++)
  {
    if(gCombinedNumbers_Pos[i] ==startelement)
    {
      current_CombinedNumbersLine =i;
      i =TEL_COMBINEDNUMBERS_ENTRIES;
    }
  }

  /***copy elements***/
  for (i=0; i<elements; i++)
  {
    switch (recordaddress)
    {
      case 0: //recordaddress =0 -> complete record (reserved FRU)
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
            Offset++;
            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
          }
          else
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
          Offset++;
        }
        //PbName
        for(j=0; j<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;j++) //clear
            gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        if(length ==0) //list element cleared by ASG ('empty string')
            gCombinedNumbers_ListEntryValidInformation[current_CombinedNumbersLine] =0;
        for(j=0; j<length;j++) //copy data
        {
            gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =Indication_array[Offset];
            Offset++;
        }
        //CallMode
        gCombinedNumbers_CallMode[current_CombinedNumbersLine] =Indication_array[Offset] & 0x0F;
        gCombinedNumbers_NumberType[current_CombinedNumbersLine] =(Indication_array[Offset] & 0xF0)/0x10;
        Offset++;
        //TelNumber
        for(j=0; j<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;j++) //clear
          gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        for(j=0; j<length;j++) //copy data
        {
            gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =Indication_array[Offset];
            Offset++;
        }
        //Day
        gCombinedNumbers_day[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Month
        gCombinedNumbers_month[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Year
        gCombinedNumbers_year[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Hour
        gCombinedNumbers_hour[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Minute
        gCombinedNumbers_minute[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Second
        gCombinedNumbers_second[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Picture_Reference
        gCombinedNumbers_Picture_Reference[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        wTemp =Indication_array[Offset];
        wTemp = (wTemp * 0x0100) & 0xFF00;
        gCombinedNumbers_Picture_Reference[current_CombinedNumbersLine] =gCombinedNumbers_Picture_Reference[current_CombinedNumbersLine] + wTemp;
      break;
      case 1: //recordaddress =1 -> complete record
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
            Offset++;
            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
          }
          else
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
          Offset++;
        }
        //PbName
        for(j=0; j<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;j++) //clear
            gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        if(length ==0) //list element cleared by ASG ('empty string')
            gCombinedNumbers_ListEntryValidInformation[current_CombinedNumbersLine] =0;
        for(j=0; j<length;j++) //copy data
        {
            gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =Indication_array[Offset];
            Offset++;
        }
        //CallMode
        gCombinedNumbers_CallMode[current_CombinedNumbersLine] =Indication_array[Offset] & 0x0F;
        gCombinedNumbers_NumberType[current_CombinedNumbersLine] =(Indication_array[Offset] & 0xF0)/0x10;
        Offset++;
        //TelNumber
        for(j=0; j<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;j++) //clear
          gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        for(j=0; j<length;j++) //copy data
        {
            gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =Indication_array[Offset];
            Offset++;
        }
        //Day
        gCombinedNumbers_day[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Month
        gCombinedNumbers_month[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Year
        gCombinedNumbers_year[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Hour
        gCombinedNumbers_hour[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Minute
        gCombinedNumbers_minute[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Second
        gCombinedNumbers_second[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Picture_Reference
        gCombinedNumbers_Picture_Reference[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        wTemp =Indication_array[Offset];
        wTemp = (wTemp * 0x0100) & 0xFF00;
        gCombinedNumbers_Picture_Reference[current_CombinedNumbersLine] =gCombinedNumbers_Picture_Reference[current_CombinedNumbersLine] + wTemp;
      break;
      case 2: //recordaddress =2 -> PbName, NumberType, CallMode, TelNumber, Day, Month, Year, Hour, Minute, Second
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
            Offset++;
            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
          }
          else
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
          Offset++;
        }
        //PbName
        for(j=0; j<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;j++) //clear
            gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        if(length ==0) //list element cleared by ASG ('empty string')
            gCombinedNumbers_ListEntryValidInformation[current_CombinedNumbersLine] =0;
        for(j=0; j<length;j++) //copy data
        {
            gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =Indication_array[Offset];
            Offset++;
        }
        //CallMode
        gCombinedNumbers_CallMode[current_CombinedNumbersLine] =Indication_array[Offset] & 0x0F;
        gCombinedNumbers_NumberType[current_CombinedNumbersLine] =(Indication_array[Offset] & 0xF0)/0x10;
        Offset++;
        //TelNumber
        for(j=0; j<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;j++) //clear
          gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        for(j=0; j<length;j++) //copy data
        {
            gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =Indication_array[Offset];
            Offset++;
        }
        //Day
        gCombinedNumbers_day[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Month
        gCombinedNumbers_month[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Year
        gCombinedNumbers_year[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Hour
        gCombinedNumbers_hour[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Minute
        gCombinedNumbers_minute[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Second
        gCombinedNumbers_second[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
      break;
      case 3: //recordaddress =3 -> PbName, NumberType, CallMode
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
            Offset++;
            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
          }
          else
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
          Offset++;
        }
        //PbName
        for(j=0; j<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;j++) //clear
            gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        if(length ==0) //list element cleared by ASG ('empty string')
            gCombinedNumbers_ListEntryValidInformation[current_CombinedNumbersLine] =0;
        for(j=0; j<length;j++) //copy data
        {
            gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =Indication_array[Offset];
            Offset++;
        }
        //CallMode
        gCombinedNumbers_CallMode[current_CombinedNumbersLine] =Indication_array[Offset] & 0x0F;
        gCombinedNumbers_NumberType[current_CombinedNumbersLine] =(Indication_array[Offset] & 0xF0)/0x10;
        Offset++;
      break;
      case 4: //recordaddress =4 -> TelNumber, Day, Month, Year, Hour, Minute, Second
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
            Offset++;
            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
          }
          else
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
          Offset++;
        }
        //TelNumber
        for(j=0; j<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;j++) //clear
          gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        for(j=0; j<length;j++) //copy data
        {
            gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =Indication_array[Offset];
            Offset++;
        }
        //Day
        gCombinedNumbers_day[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Month
        gCombinedNumbers_month[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Year
        gCombinedNumbers_year[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Hour
        gCombinedNumbers_hour[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Minute
        gCombinedNumbers_minute[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        //Second
        gCombinedNumbers_second[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
      break;
      case 5: //recordaddress =5 -> Picture_Reference
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
            Offset++;
            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
          }
          else
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
          Offset++;
        }
        //Picture_Reference
        gCombinedNumbers_Picture_Reference[current_CombinedNumbersLine] =Indication_array[Offset];
        Offset++;
        wTemp =Indication_array[Offset];
        wTemp = (wTemp * 0x0100) & 0xFF00;
        gCombinedNumbers_Picture_Reference[current_CombinedNumbersLine] =gCombinedNumbers_Picture_Reference[current_CombinedNumbersLine] + wTemp;
      break;
      case 15: //recordaddress =0xf -> Pos
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
            Offset++;
            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
          }
          else
            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
          Offset++;
        }
      break; //recordaddress =0xf ends
    }// end switch recordaddress
    current_CombinedNumbersLine =CombinedNumbers_nextvalidLine (current_CombinedNumbersLine, direction);
  } //end 'for' -> copy elements
}

void CombinedNumbers_CheckCache ()
{
  int i =0, j =0, k =0;

  for (i=0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
  {
   if(gCombinedNumbers_ListEntryValidInformation[i] !=1)
    {
      for (j=i; j<TEL_COMBINEDNUMBERS_ENTRIES; j++)
      {
        if(gCombinedNumbers_ListEntryValidInformation[j])
        {
          //Pos
          gCombinedNumbers_Pos[i] =0; //clear new position
          gCombinedNumbers_Pos[i] =i; // -> new Pos for consecutive ID
          //PbName
          for(k=0; k<TEL_COMBINEDNUMBERS_PBNAME_LENGTH; k++) //clear new position
              gCombinedNumbers_PbName[i][k]=0;
          for(k=0; k<strlen(gCombinedNumbers_PbName[j]); k++)
              gCombinedNumbers_PbName[i][k]=gCombinedNumbers_PbName[j][k];
          for(k=0; k<TEL_COMBINEDNUMBERS_PBNAME_LENGTH; k++) //clear old position
              gCombinedNumbers_PbName[j][k]=0;
          //CallMode
          gCombinedNumbers_CallMode[i] =0; //clear new position
          gCombinedNumbers_CallMode[i] =gCombinedNumbers_CallMode[j];
          gCombinedNumbers_CallMode[j] =0; //clear old position
          //NumberType
          gCombinedNumbers_NumberType[i] =0; //clear new position
          gCombinedNumbers_NumberType[i] =gCombinedNumbers_NumberType[j];
          gCombinedNumbers_NumberType[j] =0; //clear old position
          //TelNumber
          for(k=0; k<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH; k++) //clear new position
              gCombinedNumbers_TelNumber[i][k]=0;
          for(k=0; k<strlen(gCombinedNumbers_TelNumber[j]); k++)
              gCombinedNumbers_TelNumber[i][k]=gCombinedNumbers_TelNumber[j][k];
          for(k=0; k<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH; k++) //clear old position
              gCombinedNumbers_TelNumber[j][k]=0;
          //Day
          gCombinedNumbers_day[i] =0; //clear new position
          gCombinedNumbers_day[i] =gCombinedNumbers_day[j];
          gCombinedNumbers_day[j] =0; //clear old position
          //Month
          gCombinedNumbers_month[i] =0; //clear new position
          gCombinedNumbers_month[i] =gCombinedNumbers_month[j];
          gCombinedNumbers_month[j] =0; //clear old position
          //Year
          gCombinedNumbers_year[i] =0; //clear new position
          gCombinedNumbers_year[i] =gCombinedNumbers_year[j];
          gCombinedNumbers_year[j] =0; //clear old position
          //Hour
          gCombinedNumbers_hour[i] =0; //clear new position
          gCombinedNumbers_hour[i] =gCombinedNumbers_hour[j];
          gCombinedNumbers_hour[j] =0; //clear old position
          //Minute
          gCombinedNumbers_minute[i] =0; //clear new position
          gCombinedNumbers_minute[i] =gCombinedNumbers_minute[j];
          gCombinedNumbers_minute[j] =0; //clear old position
          //Second
          gCombinedNumbers_second[i] =0; //clear new position
          gCombinedNumbers_second[i] =gCombinedNumbers_second[j];
          gCombinedNumbers_second[j] =0; //clear old position
          //Picture_Reference
          gCombinedNumbers_Picture_Reference[i] =0; //clear new position
          gCombinedNumbers_Picture_Reference[i] =gCombinedNumbers_Picture_Reference[j];
          gCombinedNumbers_Picture_Reference[j] =0; //clear old position
          //ValidInformation
          gCombinedNumbers_ListEntryValidInformation[i] =0; //clear new position
          gCombinedNumbers_ListEntryValidInformation[i] =gCombinedNumbers_ListEntryValidInformation[j];
          gCombinedNumbers_ListEntryValidInformation[j] =0; //clear old position
          j=TEL_COMBINEDNUMBERS_ENTRIES;
        }
      }
    }
  }
  gCombinedNumbers_sum =0;
  for (i=0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
  {
    if(gCombinedNumbers_ListEntryValidInformation[i])
      gCombinedNumbers_sum++;
    else
      i=TEL_COMBINEDNUMBERS_ENTRIES;
  }
  gCombinedNumbers_TotalNumListElements =gCombinedNumbers_sum;
  putvalue(env_FSG_CN_TotalNumLE,gCombinedNumbers_TotalNumListElements);
}

//*************************************************************************
//*****************Picture*************************************************
void Picture_Indication(dword Indication_array [])
{
  byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
  word valid_startelement, requested_startelement, startelement, elements, Offset;
  int i=0;

  // Init local variables
  mode = 0;
  direction = 0;
  shift = 0;
  transmitpos = 0;
  recordaddress = 0;
  requested_startelement = 0;
  startelement = 0;
  elements = 0;
  indexsize = 0;
  valid_startelement = 0xff;
  valid_elements = 0;
  Offset = 0;

  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      //getData
      gPicture_ASGID = (gBAP_Indication[3] &0xF0) /0x10;
      gPicture_TAID = gBAP_Indication[3] &0x0F;

      //decode BAP-ArrayHeader
      mode = (gBAP_Indication[4] &0xF0) /0x10;

      // decode "mode-byte"
      shift       =  mode &0x01;
      direction   = (mode &0x02)/0x02;
      transmitpos = (mode &0x04)/0x04;
      indexsize   = (mode &0x08)/0x08;

      recordaddress = gBAP_Indication[4] &0x0F;
      if(indexsize)
      {
        startelement = gBAP_Indication[5];
        startelement+= gBAP_Indication[6] *0x100;
        elements = gBAP_Indication[7];
        elements+= gBAP_Indication[8]*0x100;
      }
      else
      {
        startelement = gBAP_Indication[5];
        elements = gBAP_Indication[6];
      }
      requested_startelement = startelement;
      // transmitpos = TRUE;
      mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

      /***Startelement=0***/
      if(startelement == 0) //Startelement-ID =0 -> start at first array-entry
      {
        if(FORWARD==direction)  //forward-start
        {
          valid_startelement =0;
          if(TEL_PICTURE_ENTRIES <=elements) //1. more elements requested, than in array
          {
            if (shift ==FALSE)
            {
              for(i=0;i<TEL_PICTURE_ENTRIES;i++)
              {
                if(0 !=gPicture_ListEntryValidInformation[i]) //if there is an valid element
                  valid_elements++;         //increment elements
                else                        //no valid element, loop finished
                  i =TEL_PICTURE_ENTRIES;
              }
            }
            else if (shift ==TRUE)
            {
              valid_startelement  =1;
              startelement        =valid_startelement;

              for(i=1;i<TEL_PICTURE_ENTRIES;i++)
              {
                if(0 !=gPicture_ListEntryValidInformation[i]) //if there is an valid element
                  valid_elements++;         //increment elements
                else                        //no valid element, loop finished
                  i =TEL_PICTURE_ENTRIES;
              }
            }
          }
          else    //2. number of requested elements < elements in array
          {
            if (shift ==FALSE)
            {
              for(i=0;i<elements;i++)
              {
                if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;         //increment elements
                else                        //no valid element, loop finished
                  i =TEL_PICTURE_ENTRIES;
              }
            }
            else if (shift ==TRUE)
            {
              valid_startelement = 1;
              startelement = valid_startelement;

              for(i=1;i<=elements;i++)
              {
                if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;         //increment elements
                else                        //no valid element, loop finished
                  i =TEL_PICTURE_ENTRIES;
              }
            }
          }
        }                                                               //forward ends
        else if(BACKWARD==direction && TRUE==shift)           //backward-start, only if the shift bit is set (this means starting with the last element of the array)
        {
          //searching for valid startelement
          for(i=(TEL_PICTURE_ENTRIES-1);i>=0;i--)
          {
            if(0!=gPicture_ListEntryValidInformation[i])    //found valid startelement
            {
              valid_startelement =i;
              i =0;
            }
          }
          //searching for valid elements
          if(0xff==valid_startelement)                //Startelement-ID doesn't exist in SMSReceived-array
          {
            valid_startelement  =startelement;
            valid_elements      =0;
          }
          else if(0==valid_startelement)
            valid_elements=1;                                      //only 1 element because valid startelement is on position 0
          else if(elements>(valid_startelement+1))          //not enougth array-elements available, because array endet at array-position 0
          {
            for(i=valid_startelement;i>=0;i--)
            {
              if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;               //increment elements
              else                        //no valid element, loop finished
                i=0;
            }
          }
          else                            //enougth array-elements available
          {
            for(i=valid_startelement;i>(valid_startelement-elements);i--)
            {
              if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;               //increment elements
              else                        //no valid element, loop finished
                i=0;
            }

          }
        } //backward-end
      } //startelement ==0 -end
      /***Startelement!=0***/
      else                                //searching for Startelement-ID
      {
        //searching for valid startelement
        for(i=0;i<TEL_PICTURE_ENTRIES;i++)
        {
          if(gPicture_Pos[i] ==startelement)              //found a valid element
          {
            if(shift==TRUE)                     //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
            {
              if(i!=0 || BACKWARD!=direction)           //if valid_startelement is not the first array element or direction is not backwards
                valid_startelement =i+1-2*direction;
              else if(i==0 && BACKWARD==direction)
                valid_startelement =gPicture_sum;     //valid element is last element in Array
              else if(i==0 && FORWARD==direction)
                valid_startelement =0;                          //valid element is first element in Array
            }
            else
              valid_startelement =i;                              //found element is valid_startelement
            i=TEL_PICTURE_ENTRIES;
          }
        }
        if(0xff==valid_startelement)                    //Startelement-ID doesn't exist in array
        {
          valid_startelement  =startelement;
          valid_elements      =0;
        }
        else                                //found valid entry for startelement in array
        {
          //verify number of valid elements
          if(BACKWARD==direction)                     //backward-start
          {
            if(valid_startelement==0)                 //only 1 element because valid startelement is on position 0
              valid_elements=1;
            else if(elements>(valid_startelement+1))          //not enougth array-elements available, because array endet at array-position 0
            {
              for(i=valid_startelement;i>=0;i--)
              {
                if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=0;
              }
            }
            else                            //enougth array-elements available
            {
              for(i=valid_startelement;i>(valid_startelement-elements);i--)
              {
                if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=0;
              }
            }
          }                               //backward-end
          else                              //forward-start
          {
            if((valid_startelement+elements)>=TEL_PICTURE_ENTRIES)
            {
              for(i=valid_startelement;i<TEL_PICTURE_ENTRIES;i++)
              {
                if(gPicture_ListEntryValidInformation[i])
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=TEL_PICTURE_ENTRIES;
              }
            }
            else
            {
              for(i=valid_startelement;i<(valid_startelement+elements);i++)
              {
                if(gPicture_ListEntryValidInformation[i])
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=TEL_PICTURE_ENTRIES;
              }
            }
          }
        }
      }
      mode =0;
      mode =Picture_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);
      //send StatusArray
      Picture_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
      //Panel
      putvalue(env_FSG2_CallPic_AsgID,gPicture_ASGID);
      putvalue(env_FSG2_CallPic_TAID,gPicture_TAID);
      putvalue(env_FSG2_CallPic_Shift,shift);
      putvalue(env_FSG2_CallPic_Direction,direction);
      putvalue(env_FSG2_CallPic_TransPos,transmitpos);
      putvalue(env_FSG2_CallPic_IndexSize,indexsize);
      putvalue(env_FSG2_CallPic_RecAdr,recordaddress);
      putvalue(env_FSG2_CallPic_Start,startelement);
      putvalue(env_FSG2_CallPic_Elements,elements);
    break;
    case DataSetGet_IND:
      //getData
      gPicture_ASGID = (gBAP_Indication[3] &0xF0) /0x10;
      gPicture_TAID = gBAP_Indication[3] &0x0F;
      //decode BAP-ArrayHeader
      mode                =(gBAP_Indication[4] &0xF0) /0x10;
      // decode "mode-byte"
      shift       =mode &0x01;
      direction   =(mode &0x02)/0x02;
      transmitpos =(mode &0x04)/0x04;
      indexsize   =(mode &0x08)/0x08;
      recordaddress       =gBAP_Indication[4] &0x0F;
      if(indexsize)
      {
        startelement        =gBAP_Indication[5];
        startelement        +=gBAP_Indication[6] *0x100;
        elements            =gBAP_Indication[7];
        elements            +=gBAP_Indication[8]*0x100;
        Offset =9;
      }
      else
      {
        startelement        =gBAP_Indication[5];
        elements            =gBAP_Indication[6];
        Offset =7;
      }
      requested_startelement =startelement;
      //transmitpos     =FALSE; //Position must always be sent in the case of *.StatusArray.
      mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

      /***Startelement=0***/
      if(0==startelement) //Startelement-ID =0 -> start at first array-entry
      {
        if(FORWARD==direction)  //forward-start
        {
          valid_startelement =0;
          if(TEL_PICTURE_ENTRIES <=elements) //1. more elements requested, than in array
          {
            if (shift ==FALSE)
            {
              for(i=0;i<TEL_PICTURE_ENTRIES;i++)
              {
                if(0 !=gPicture_ListEntryValidInformation[i]) //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i =TEL_PICTURE_ENTRIES;
              }
            }
            else if (shift ==TRUE)
            {
              valid_startelement  =1;
              startelement        =valid_startelement;
              for(i=1;i<TEL_PICTURE_ENTRIES;i++)
              {
                if(0 !=gPicture_ListEntryValidInformation[i]) //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i =TEL_PICTURE_ENTRIES;
              }
            }
          }
          else    //2. number of requested elements < elements in array
          {
            if (shift ==FALSE)
            {
              for(i=0;i<elements;i++)
              {
                if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i =TEL_PICTURE_ENTRIES;
              }
            }
            else if (shift ==TRUE)
            {
              valid_startelement  =1;
              startelement        =valid_startelement;
              for(i=1;i<=elements;i++)
              {
                if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i =TEL_PICTURE_ENTRIES;
              }
            }
          }
        }                                                               //forward ends
        else if(BACKWARD==direction && TRUE==shift)           //backward-start, only if the shift bit is set (this means starting with the last element of the array)
        {
          //searching for valid startelement
          for(i=(TEL_PICTURE_ENTRIES-1);i>=0;i--)
          {
            if(0!=gPicture_ListEntryValidInformation[i])    //found valid startelement
            {
              valid_startelement =i;
              i =0;
            }
          }
          //searching for valid elements
          if(0xff==valid_startelement)                //Startelement-ID doesn't exist in SMSReceived-array
          {
            valid_startelement  =startelement;
            valid_elements      =0;
          }
          else if(0==valid_startelement)
            valid_elements=1;                                       //only 1 element because valid startelement is on position 0

          else if(elements>(valid_startelement+1))          //not enougth array-elements available, because array endet at array-position 0
          {
            for(i=valid_startelement;i>=0;i--)
            {
              if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;               //increment elements
              else                        //no valid element, loop finished
                i=0;
            }
          }
          else                            //enougth array-elements available
          {
            for(i=valid_startelement;i>(valid_startelement-elements);i--)
            {
              if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;               //increment elements
              else                        //no valid element, loop finished
                i=0;
            }
          }
        }                                                               //backward-end
      }                                                                   //startelement ==0 -end
      /***Startelement!=0***/
      else                                //searching for Startelement-ID
      {
        //searching for valid startelement
        for(i=0;i<TEL_PICTURE_ENTRIES;i++)
        {
          if(gPicture_Pos[i] ==startelement)              //found a valid element
          {
            if(shift==TRUE)                     //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
            {
              if(i!=0 || BACKWARD!=direction)           //if valid_startelement is not the first array element or direction is not backwards
                valid_startelement =i+1-2*direction;
              else if(i==0 && BACKWARD==direction)
                valid_startelement =gPicture_sum;     //valid element is last element in Array
              else if(i==0 && FORWARD==direction)
                valid_startelement =0;                          //valid element is first element in Array
            }
            else
              valid_startelement =i;                              //found element is valid_startelement
            i=TEL_PICTURE_ENTRIES;
          }
        }
        if(0xff==valid_startelement)                    //Startelement-ID doesn't exist in array
        {
          valid_startelement  =startelement;
          valid_elements      =0;
        }
        else                                //found valid entry for startelement in array
        {
          //verify number of valid elements
          if(BACKWARD==direction)                     //backward-start
          {
            if(valid_startelement==0)                 //only 1 element because valid startelement is on position 0
              valid_elements=1;
            else if(elements>(valid_startelement+1))          //not enougth array-elements available, because array endet at array-position 0
            {
              for(i=valid_startelement;i>=0;i--)
              {
                if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=0;
              }
            }
            else                            //enougth array-elements available
            {
              for(i=valid_startelement;i>(valid_startelement-elements);i--)
              {
                if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=0;
              }
            }
          }                               //backward-end
          else                              //forward-start
          {
            if((valid_startelement+elements)>=TEL_PICTURE_ENTRIES)
            {
              for(i=valid_startelement;i<TEL_PICTURE_ENTRIES;i++)
              {
                if(0!=gPicture_Pos[i])            //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=TEL_PICTURE_ENTRIES;
              }
            }
            else
            {
              for(i=valid_startelement;i<(valid_startelement+elements);i++)
              {
                if(0!=gPicture_Pos[i])                //if there is an valid element
                  valid_elements++;               //increment elements
                else                        //no valid element, loop finished
                  i=TEL_PICTURE_ENTRIES;
              }
            }
          }
        }
      }
      if(getvalue(env_FSG2_CallPic_SetGetArray_beh) && valid_elements>0)
        Picture_TakeOverData(Indication_array, Offset, valid_startelement, valid_elements, recordaddress, direction, transmitpos, indexsize);
      mode =0;
      mode =Picture_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);
      //send StatusArray
      Picture_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
      //Panel
      putvalue(env_FSG2_CallPic_AsgID,gPicture_ASGID);
      putvalue(env_FSG2_CallPic_TAID,gPicture_TAID);
      putvalue(env_FSG2_CallPic_Shift,shift);
      putvalue(env_FSG2_CallPic_Direction,direction);
      putvalue(env_FSG2_CallPic_TransPos,transmitpos);
      putvalue(env_FSG2_CallPic_IndexSize,indexsize);
      putvalue(env_FSG2_CallPic_RecAdr,recordaddress);
      putvalue(env_FSG2_CallPic_Start,startelement);
      putvalue(env_FSG2_CallPic_Elements,elements);
      //check FSG Cache
      Picture_CheckCache();
    break;
    case Error_IND:
      writelineEx(gError_Trace, 0, "FSG_Telepfhone Picture_Indication: received error, errorcode:0x%x", Indication_array[3]);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_Telepfhone Picture_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void Picture_Request (byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{
  int  i;
  byte shift, direction, transmitpos, indexsize, current_element;
  dword requestarray [BAP_buffer_size], Offset;
  word PictureLine;

  // Init local variables.
  for(i=0;i<BAP_buffer_size;i++)
  requestarray [i]=0;

  shift               =0;
  direction           =0;
  transmitpos         =0;
  indexsize           =0;
  PictureLine         =0;
  current_element     =0;
  Offset              =0;

  // decode "mode-byte"
  shift       =mode &0x01;
  direction   =(mode &0x02)/0x02;
  transmitpos =(mode &0x04)/0x04;
  indexsize   =(mode &0x08)/0x08;

  // Handle request.
  requestarray[0] =LSGID_Telephone;       //LSG-ID
  requestarray[1] =FctID_Picture;         //Fct.-ID
  requestarray[2] =request;               //request type
  Offset =3;

  switch(request)
  {
    case Changed_REQ:
      /***ArrayHeader***/
      requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
      Offset++;
      if(indexsize)
      {
        requestarray[Offset] =requested_startelement &0xff;
        Offset++;
        requestarray[Offset] =(requested_startelement &0xff00) /0x100;
        Offset++;
        requestarray[Offset] =elements &0xff;
        Offset++;
        requestarray[Offset] =(elements &0xff00) /0x100;
        Offset++;
      }
      else
      {
        requestarray[Offset] =requested_startelement;
        Offset++;
        requestarray[Offset] =elements;
        Offset++;
      }
      PictureLine =startelement;
      if(getvalue(env_FSG2_CallPic_CA_switch)) //if "ArrayHeader + Data"
      {
        //copy data
        switch(recordaddress)
        {
          case 0: //complete record (reserved FRU)
            while(current_element <elements)
            {
              if(PictureLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone Picture_Request: invalid PictureLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                // Pos
                if (transmitpos) // ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gPicture_Pos[PictureLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gPicture_Pos[PictureLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gPicture_Pos[PictureLine];
                    Offset++;
                  }
                }
                //CallID
                requestarray[Offset] =gPicture_CallId[PictureLine];
                Offset++;
                //PictureType
                requestarray[Offset] =gPicture_Type[PictureLine];
                Offset++;
                //IPaddress
                requestarray[Offset] =strlen(gPicture_IpAddress[PictureLine]);
                Offset++;
                for(i=0;i<strlen(gPicture_IpAddress[PictureLine]);i++)
                {
                  requestarray[Offset] =gPicture_IpAddress[PictureLine][i];
                  Offset++;
                }
                //TCP port
                requestarray[Offset] =gPicture_TcpPort[PictureLine] & 0x00FF;
                Offset++;
                requestarray[Offset] =(gPicture_TcpPort[PictureLine] & 0xFF00) / 0x0100;
                Offset++;
                //URI
                requestarray[Offset] =strlen(gPicture_URI[PictureLine]);
                Offset++;
                for(i=0;i<strlen(gPicture_URI[PictureLine]);i++)
                {
                  requestarray[Offset] =gPicture_URI[PictureLine][i];
                  Offset++;
                }
              }
              current_element++;
              PictureLine =Picture_nextvalidLine(PictureLine, direction);
            }//end while
          break;
          case 1: //complete record
            while(current_element <elements)
            {
              if(PictureLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone Picture_Request: invalid PictureLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                // Pos
                if (transmitpos) // ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gPicture_Pos[PictureLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gPicture_Pos[PictureLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gPicture_Pos[PictureLine];
                    Offset++;
                  }
                }
                //CallID
                requestarray[Offset] =gPicture_CallId[PictureLine];
                Offset++;
                //PictureType
                requestarray[Offset] =gPicture_Type[PictureLine];
                Offset++;
                //IPaddress
                requestarray[Offset] =strlen(gPicture_IpAddress[PictureLine]);
                Offset++;
                for(i=0;i<strlen(gPicture_IpAddress[PictureLine]);i++)
                {
                  requestarray[Offset] =gPicture_IpAddress[PictureLine][i];
                  Offset++;
                }
                //TCP port
                requestarray[Offset] =gPicture_TcpPort[PictureLine] & 0x00FF;
                Offset++;
                requestarray[Offset] =(gPicture_TcpPort[PictureLine] & 0xFF00) / 0x0100;
                Offset++;
                //URI
                requestarray[Offset] =strlen(gPicture_URI[PictureLine]);
                Offset++;
                for(i=0;i<strlen(gPicture_URI[PictureLine]);i++)
                {
                  requestarray[Offset] =gPicture_URI[PictureLine][i];
                  Offset++;
                }
              }
              current_element++;
              PictureLine =Picture_nextvalidLine(PictureLine, direction);
            }//end while
          break;
          case 2: //CallID, PictureType, TCP port, URI
            while(current_element <elements)
            {
              if(PictureLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone Picture_Request: invalid PictureLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                // Pos
                if (transmitpos) // ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gPicture_Pos[PictureLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gPicture_Pos[PictureLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gPicture_Pos[PictureLine];
                    Offset++;
                  }
                }
                //CallID
                requestarray[Offset] =gPicture_CallId[PictureLine];
                Offset++;
                //PictureType
                requestarray[Offset] =gPicture_Type[PictureLine];
                Offset++;
                //TCP port
                requestarray[Offset] =gPicture_TcpPort[PictureLine] & 0x00FF;
                Offset++;
                requestarray[Offset] =(gPicture_TcpPort[PictureLine] & 0xFF00) / 0x0100;
                Offset++;
                //URI
                requestarray[Offset] =strlen(gPicture_URI[PictureLine]);
                Offset++;
                for(i=0;i<strlen(gPicture_URI[PictureLine]);i++)
                {
                  requestarray[Offset] =gPicture_URI[PictureLine][i];
                  Offset++;
                }
              }
              current_element++;
              PictureLine =Picture_nextvalidLine(PictureLine, direction);
            }//end while
          break;
          case 15: //Pos
            while(current_element <elements)
            {
              if(PictureLine ==0xff) //Invalid "list entry"
              {
                write("FSG-Telephone Picture_Request: invalid PictureLine");
                current_element =elements;
              }
              else //"list entry" valid
              {
                /***Array Data***/
                // Pos
                if (transmitpos) // ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gPicture_Pos[PictureLine] &0xFF);
                    Offset++;
                    requestarray[Offset] =((gPicture_Pos[PictureLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gPicture_Pos[PictureLine];
                    Offset++;
                  }
                }
              }
              current_element++;
              PictureLine =Picture_nextvalidLine(PictureLine, direction);
            }//end while
          break;
          default:
            write("FSG-Telephone Picture_Request: invalid recordaddress %d", recordaddress);
          break;
        } //end switch "recordaddress"
      } //end if "ArrayHeader + Data"
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break; //end Changed_REQ
    case Data_REQ:
      /***ASGID & TAID***/
      requestarray[Offset] =((gPicture_ASGID *0x10) &0xF0) +(gPicture_TAID &0x0F);
      Offset++;
      /***TNLE***/
      requestarray[Offset] =gPicture_TotalNumListElements;
      Offset++;
      /***ArrayHeader***/
      requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
      Offset++;
      if(indexsize)
      {
        requestarray[Offset] =requested_startelement &0xff;
        Offset++;
        requestarray[Offset] =(requested_startelement &0xff00) /0x100;
        Offset++;

        requestarray[Offset] =elements &0xff;
        Offset++;
        requestarray[Offset] =(elements &0xff00) /0x100;
        Offset++;
      }
      else
      {
        requestarray[Offset] =requested_startelement;
        Offset++;
        requestarray[Offset] =elements;
        Offset++;
      }
      PictureLine =startelement;
      //copy data
      switch(recordaddress)
      {
        case 0: //complete record (reserved FRU)
          while(current_element <elements)
          {
            if(PictureLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone Picture_Request: invalid PictureLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              // Pos
              if (transmitpos) // ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gPicture_Pos[PictureLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gPicture_Pos[PictureLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gPicture_Pos[PictureLine];
                  Offset++;
                }
              }
              //CallID
              requestarray[Offset] =gPicture_CallId[PictureLine];
              Offset++;
              //PictureType
              requestarray[Offset] =gPicture_Type[PictureLine];
              Offset++;
              //IPaddress
              requestarray[Offset] =strlen(gPicture_IpAddress[PictureLine]);
              Offset++;
              for(i=0;i<strlen(gPicture_IpAddress[PictureLine]);i++)
              {
                requestarray[Offset] =gPicture_IpAddress[PictureLine][i];
                Offset++;
              }
              //TCP port
              requestarray[Offset] =gPicture_TcpPort[PictureLine] & 0x00FF;
              Offset++;
              requestarray[Offset] =(gPicture_TcpPort[PictureLine] & 0xFF00) / 0x0100;
              Offset++;
              //URI
              requestarray[Offset] =strlen(gPicture_URI[PictureLine]);
              Offset++;
              for(i=0;i<strlen(gPicture_URI[PictureLine]);i++)
              {
                requestarray[Offset] =gPicture_URI[PictureLine][i];
                Offset++;
              }
            }
            current_element++;
            PictureLine =Picture_nextvalidLine(PictureLine, direction);
          }//end while
        break;
        case 1: //complete record
          while(current_element <elements)
          {
            if(PictureLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone Picture_Request: invalid PictureLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              // Pos
              if (transmitpos) // ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gPicture_Pos[PictureLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gPicture_Pos[PictureLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gPicture_Pos[PictureLine];
                  Offset++;
                }
              }
              //CallID
              requestarray[Offset] =gPicture_CallId[PictureLine];
              Offset++;
              //PictureType
              requestarray[Offset] =gPicture_Type[PictureLine];
              Offset++;
              //IPaddress
              requestarray[Offset] =strlen(gPicture_IpAddress[PictureLine]);
              Offset++;
              for(i=0;i<strlen(gPicture_IpAddress[PictureLine]);i++)
              {
                requestarray[Offset] =gPicture_IpAddress[PictureLine][i];
                Offset++;
              }
              //TCP port
              requestarray[Offset] =gPicture_TcpPort[PictureLine] & 0x00FF;
              Offset++;
              requestarray[Offset] =(gPicture_TcpPort[PictureLine] & 0xFF00) / 0x0100;
              Offset++;
              //URI
              requestarray[Offset] =strlen(gPicture_URI[PictureLine]);
              Offset++;
              for(i=0;i<strlen(gPicture_URI[PictureLine]);i++)
              {
                requestarray[Offset] =gPicture_URI[PictureLine][i];
                Offset++;
              }
            }
            current_element++;
            PictureLine =Picture_nextvalidLine(PictureLine, direction);
          }//end while
        break;
        case 2: //CallID, PictureType, TCP port, URI
          while(current_element <elements)
          {
            if(PictureLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone Picture_Request: invalid PictureLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              // Pos
              if (transmitpos) // ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gPicture_Pos[PictureLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gPicture_Pos[PictureLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gPicture_Pos[PictureLine];
                  Offset++;
                }
              }
              //CallID
              requestarray[Offset] =gPicture_CallId[PictureLine];
              Offset++;
              //PictureType
              requestarray[Offset] =gPicture_Type[PictureLine];
              Offset++;
              //TCP port
              requestarray[Offset] =gPicture_TcpPort[PictureLine] & 0x00FF;
              Offset++;
              requestarray[Offset] =(gPicture_TcpPort[PictureLine] & 0xFF00) / 0x0100;
              Offset++;
              //URI
              requestarray[Offset] =strlen(gPicture_URI[PictureLine]);
              Offset++;
              for(i=0;i<strlen(gPicture_URI[PictureLine]);i++)
              {
                requestarray[Offset] =gPicture_URI[PictureLine][i];
                Offset++;
              }
            }
            current_element++;
            PictureLine =Picture_nextvalidLine(PictureLine, direction);
          }//end while
        break;
        case 15: //Pos
          while(current_element <elements)
          {
            if(PictureLine ==0xff) //Invalid "list entry"
            {
              write("FSG-Telephone Picture_Request: invalid PictureLine");
              current_element =elements;
            }
            else //"list entry" valid
            {
              /***Array Data***/
              // Pos
              if (transmitpos) // ->Array position transmitted
              {
                if (indexsize)
                {
                  requestarray[Offset] =(gPicture_Pos[PictureLine] &0xFF);
                  Offset++;
                  requestarray[Offset] =((gPicture_Pos[PictureLine]&0xFF00) /0x100);
                  Offset++;
                }
                else
                {
                  requestarray[Offset] =gPicture_Pos[PictureLine];
                  Offset++;
                }
              }
            }
            current_element++;
            PictureLine =Picture_nextvalidLine(PictureLine, direction);
          }//end while
        break;
        default:
          write("FSG-Telephone Picture_Request: invalid recordaddress %d", recordaddress);
        break;
      } //end switch "recordaddress"
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break; //end Data_REQ
    case Error_REQ:
      requestarray[3] =errorcode;
      set_status_requestbuffer (requestarray, 4, Bap_Error);
    break; //end Error_REQ
  } //end switch "request"
}

byte Picture_nextvalidLine (byte current_PictureLine, byte direction)
{
  word next_PictureLine;
  int i;

  //init lokal variables
  next_PictureLine    =0;
  i                   =0;
  //search next "list entry"
  if(((gPicture_sum-1)==current_PictureLine && FORWARD ==direction) || (0 ==current_PictureLine && BACKWARD ==direction)) //last-/fist-element of array reached
    next_PictureLine =0xFF;
  else
  {
    next_PictureLine =current_PictureLine +1-2*direction;       //increment or decrement array-line (depends on direction);
    if(0 ==gPicture_ListEntryValidInformation[next_PictureLine])  // check if next element is "valid"
      next_PictureLine =0xff;
  }
  return(next_PictureLine);
}

void Picture_init_CSV () //Byte & file selection
{
  dword CSVfileHandle =0, ConfigFileHandle =0, i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
  char buffer_string[TEL_BUFFERSIZE], Path_CSV[TEL_BUFFERSIZE], Path_Config[TEL_BUFFERSIZE];
  byte PictureLine =0, buffer_byte[TEL_BUFFERSIZE];
  char Picture_Pos_string [TEL_PICTURE_ENTRIES][TEL_TEXTLENGTH];      //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv
  char Picture_CallID_string [TEL_PICTURE_ENTRIES][TEL_TEXTLENGTH];   //help value ->"CallMode" is stored in the ASCII(UTF-8) code in the *.csv
  char Picture_Type_string [TEL_PICTURE_ENTRIES][TEL_TEXTLENGTH];     //help value ->"Day" is stored in the ASCII(UTF-8) code in the *.csv
  char Picture_TcpPort_string [TEL_PICTURE_ENTRIES][TEL_TEXTLENGTH];  //help value ->"Month" is stored in the ASCII(UTF-8) code in the *.csv

  if(getvalue(env_FSG2_CallPic_DataSource) == TEL_EXTERNAL_LIST) //output data in write window "FSGPicture"
  {
    writeClear(gPicture_writeWindow);
    writelineEx(gPicture_writeWindow, 0,"*******External Picture*******");
    //clear
    for(j=0;j<TEL_PICTURE_ENTRIES;j++)
    {
      gPicture_Pos[j] = 0;
      for(i=0;i<TEL_PICTURE_IPADDRESS_LENGTH;i++)
        gPicture_IpAddress[j][i] = 0;
      gPicture_CallId[j]      = 0;
      gPicture_Type[j]        = 0;
      for(i=0;i<TEL_PICTURE_URI_LENGTH;i++)
        gPicture_URI[j][i]    = 0;
      gPicture_TcpPort[j]     = 0;
      gCombinedNumbers_ListEntryValidInformation[j] = 0;
    }
    for(i=0;i<TEL_FILENAME_SIZE; i++) //clear "filename"
      gPicture_CSV_filename[i] =0;
    for(j=0;j<TEL_PICTURE_ENTRIES; j++) //clear "buffer"
    {
      buffer_string[j]    =0;
      buffer_byte[j]      =0;
      for(i=0;i<TEL_TEXTLENGTH;i++) //clear help value
      {
        Picture_Pos_string[j][i]        =0;
        Picture_CallID_string[j][i]   =0;
        Picture_Type_string[j][i]        =0;
        Picture_TcpPort_string[j][i]      =0;
      }
    }
    i = 0; j = 0; PictureLine = 0; current_CSV_line = 0; //reset values
    getvalue(env_FSG2_CallPic_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
    i =0;
    while (Path_CSV[i] !=0) //scan "path"
    {
      if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename"
        count1++;
      i++;
    }
    i =0; j =0; //reset values
    while (Path_CSV[i] !=0) //seperate "path" and "filename"
    {
      if(count2==count1) //get filename after last "\"
      {
        gPicture_CSV_filename[j] =Path_CSV[i];
        j++;
        Path_CSV[i] =0;
      }
      if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"
        count2++;
      i++;
    }
    putvalue(env_FSG2_CallPic_DataSource_file, gPicture_CSV_filename); //output current loaded *.csv-file on panel
    setFilePath(Path_CSV, 0); //set path for *.csv file
    CSVfileHandle = openFileRead(gPicture_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

    if (CSVfileHandle!=0) //*.csv file access successful
    {
      putvalue(env_FSG2_CallPic_DataSource_res, "successful");   //output result on panel
      Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
      for (i=0; i<Num_of_csv_byte; i++) //copy data into "CombinedNumbers"
      {
        if (buffer_byte[i] != 0x3B) //read data if no ";" is detected
        {
          if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in CombinedNumbers) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
          {
            if(current_CSV_line>0 && PictureLine<TEL_PICTURE_ENTRIES) //ignore first line in *.csv file
            {
              //transform 'string' to 'long' for "POS", and other
              gPicture_Pos[PictureLine]         = atol(Picture_Pos_string[PictureLine]);
              gPicture_Type[PictureLine]        = atol(Picture_Type_string[PictureLine]);
              gPicture_CallId[PictureLine]      = atol(Picture_CallID_string[PictureLine]);
              gPicture_TcpPort[PictureLine]     = atol(Picture_TcpPort_string[PictureLine]);
              gPicture_ListEntryValidInformation[PictureLine]  =TRUE;
              PictureLine++; // -> next line in *.csv (next record element)
            }
            current_CSV_line++; //next line in *.csv file
            element =0; //start at 'POS' (first record element of "array data")
            j=0; //reset value
          }
          else if(current_CSV_line>0 && PictureLine<TEL_PICTURE_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
          {
            switch (element)
            {
              case 0: //POS
                Picture_Pos_string[PictureLine][j] =buffer_byte[i];
                j++;
              break;
              case 1: //CallID
                Picture_CallID_string[PictureLine][j] =buffer_byte[i];
                j++;
              break;
              case 2: //PictureType
                Picture_Type_string[PictureLine][j] =buffer_byte[i];
                j++;
              break;
              case 3: //IPaddress
                gPicture_IpAddress[PictureLine][j] =buffer_byte[i];
                j++;
              break;
              case 4: //TCP port
                Picture_TcpPort_string[PictureLine][j] =buffer_byte[i];
                j++;
              break;
              case 5: //URI
                gPicture_URI[PictureLine][j] =buffer_byte[i];
                j++;
              break;
              default:
              break;
            }
          }
        }
        else  // ";" is detected ->next record element of "array data"
        {
          element++;
          j=0; //reset value
        }
      }
      gPicture_TotalNumListElements =gPicture_sum =PictureLine; //get "total number of list elements"
      putvalue(env_FSG2_CallPic_TNLE, gPicture_TotalNumListElements);
      if(fileClose (CSVfileHandle) !=0) //close *.csv file
        writelineEx(gPicture_writeWindow, 0,"Datei '%s' geschlossen", gPicture_CSV_filename); //output result
      else
        writelineEx(gPicture_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gPicture_CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
      writelineEx(gPicture_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gPicture_CSV_filename); //output result
      putvalue(env_FSG2_CallPic_DataSource_res,"not successful"); //output result
    }
  }
}

on envVar env_FSG2_CallPic_ChangedBtn
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables.
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    if(getvalue(env_FSG2_CallPic_Start) >255 && getvalue(env_FSG2_CallPic_IndexSize) ==0)// check if 8 or 16 bit
      putvalue(env_FSG2_CallPic_IndexSize,1);
    //get data from Panel
    recordaddress   =getvalue(env_FSG2_CallPic_RecAdr);
    shift           =getvalue(env_FSG2_CallPic_Shift);
    direction       =getvalue(env_FSG2_CallPic_Direction);
    transmitpos     =getvalue(env_FSG2_CallPic_TransPos);
    indexsize       =getvalue(env_FSG2_CallPic_IndexSize);
    startelement    =getvalue(env_FSG2_CallPic_Start);
    elements        =getvalue(env_FSG2_CallPic_Elements);
    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    requested_startelement =startelement;

    /***Startelement=0***/
    if(0==startelement)//Startelement-ID =0 -> start at first array-entry
    {
      if(FORWARD==direction)//forward-start
      {
        valid_startelement =0;
        if(TEL_PICTURE_ENTRIES <=elements)                          //1. more elements requested, than in array
        {
          if (shift ==FALSE)
          {
            for(i=0;i<TEL_PICTURE_ENTRIES;i++)
            {
              if(0 !=gPicture_ListEntryValidInformation[i])         //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i =TEL_PICTURE_ENTRIES;
            }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =1;
            startelement        =valid_startelement;
            for(i=1;i<TEL_PICTURE_ENTRIES;i++)
            {
              if(0 !=gPicture_ListEntryValidInformation[i])         //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i =TEL_PICTURE_ENTRIES;
            }
          }
        }
        else                                                                //2. number of requested elements < elements in array
        {
          if (shift ==FALSE)
          {
            for(i=0;i<elements;i++)
            {
              if(0!=gPicture_ListEntryValidInformation[i])          //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i =TEL_PICTURE_ENTRIES;
            }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =1;
            startelement        =valid_startelement;
            for(i=1;i<=elements;i++)
            {
              if(0!=gPicture_ListEntryValidInformation[i])          //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i =TEL_PICTURE_ENTRIES;
            }
          }
        }
      } //forward ends
      else if(BACKWARD==direction && TRUE==shift)//backward-start, only if the shift bit is set (this means starting with the last element of the array)
      {
        //searching for valid startelement
        for(i=(TEL_PICTURE_ENTRIES-1);i>=0;i--)
        {
          if(0!=gPicture_ListEntryValidInformation[i])              //found valid startelement
          {
            valid_startelement =i;
            i =0;
          }
        }
        //searching for valid elements
        if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in SMSReceived-array
        {
          valid_startelement  =startelement;
          valid_elements      =0;
        }
        else if(0==valid_startelement)
          valid_elements=1;                                                 //only 1 element because valid startelement is on position 0
        else if(elements>(valid_startelement+1))                            //not enougth array-elements available, because array endet at array-position 0
        {
          for(i=valid_startelement;i>=0;i--)
          {
            if(0!=gPicture_ListEntryValidInformation[i])            //if there is an valid element
              valid_elements++;                                             //increment elements
            else                                                            //no valid element, loop finished
              i=0;
          }
        }
        else                                                                //enougth array-elements available
        {
          for(i=valid_startelement;i>(valid_startelement-elements);i--)
          {
            if(0!=gPicture_ListEntryValidInformation[i])            //if there is an valid element
              valid_elements++;                                             //increment elements
            else                                                            //no valid element, loop finished
              i=0;
          }
        }
      }//backward-end
    }  //startelement ==0 -end
    /***Startelement!=0***/
    else//searching for Startelement-ID
    {
      //searching for valid startelement
      for(i=0;i<TEL_PICTURE_ENTRIES;i++)
      {
        if(gPicture_Pos[i] ==startelement)                          //found a valid element
        {
          if(shift==TRUE)                                                   //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
          {
            if(i!=0 || BACKWARD!=direction)                                 //if valid_startelement is not the first array element or direction is not backwards
              valid_startelement =i+1-2*direction;
            else if(i==0 && BACKWARD==direction)
              valid_startelement =gPicture_sum;                     //valid element is last element in Array
            else if(i==0 && FORWARD==direction)
              valid_startelement =0;                                        //valid element is first element in Array
          }
          else
            valid_startelement =i;                                          //found element is valid_startelement
          i =TEL_PICTURE_ENTRIES;
        }
        else
          valid_startelement =0xff;
      }
      if(0xff==valid_startelement)                                          //Startelement-ID doesn't exist in array
      {
        valid_startelement  =startelement;
        valid_elements      =0;
      }
      else                                                                  //found valid entry for startelement in array
      {
        //verify number of valid elements
        if(BACKWARD==direction)//backward-start
        {
          if(valid_startelement==0)                                         //only 1 element because valid startelement is on position 0
            valid_elements=1;
          else if(elements>(valid_startelement+1))                          //not enougth array-elements available, because array endet at array-position 0
          {
            for(i=valid_startelement;i>=0;i--)
            {
              if(0!=gPicture_ListEntryValidInformation[i])          //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i=0;
            }
          }
          else                                                              //enougth array-elements available
          {
            for(i=valid_startelement;i>(valid_startelement-elements);i--)
            {
              if(0!=gPicture_ListEntryValidInformation[i])          //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i=0;
            }
          }
        }   //backward-end
        else//forward-start
        {
          if((valid_startelement+elements)>=TEL_PICTURE_ENTRIES)
          {
            for(i=valid_startelement;i<TEL_PICTURE_ENTRIES;i++)
            {
              if(0!=gPicture_Pos[i])                                //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i=TEL_PICTURE_ENTRIES;
            }
          }
          else
          {
            for(i=valid_startelement;i<(valid_startelement+elements);i++)
            {
              if(0!=gPicture_Pos[i])                                //if there is an valid element
                valid_elements++;                                           //increment elements
              else                                                          //no valid element, loop finished
                i=TEL_PICTURE_ENTRIES;
            }
          }
        }
      }
    }
    putvalue(env_FSG2_CallPic_Elements, valid_elements);
    //send ChangedArray
    Picture_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
  }
}

on envVar env_FSG2_CallPic_StatusBtn
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables.
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;

  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
  {
    if(getvalue(env_FSG2_CallPic_Start) >255 && getvalue(env_FSG2_CallPic_IndexSize) ==0)// check if 8 or 16 bit
        putvalue(env_FSG2_CallPic_IndexSize,1);
    //get data from Panel
    gPicture_ASGID                =getvalue(env_FSG2_CallPic_AsgID);
    gPicture_TAID                 =getvalue(env_FSG2_CallPic_TAID);
    gPicture_TotalNumListElements =getvalue(env_FSG2_CallPic_TNLE);
    recordaddress   =getvalue(env_FSG2_CallPic_RecAdr);
    shift           =getvalue(env_FSG2_CallPic_Shift);
    direction       =getvalue(env_FSG2_CallPic_Direction);
    transmitpos     =getvalue(env_FSG2_CallPic_TransPos);
    indexsize       =getvalue(env_FSG2_CallPic_IndexSize);
    startelement    =getvalue(env_FSG2_CallPic_Start);
    elements        =getvalue(env_FSG2_CallPic_Elements);
    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    requested_startelement =startelement;

    /***Startelement=0***/
    if(0==startelement)                           //Startelement-ID =0 -> start at first array-entry
    {
      if(FORWARD==direction)                      //forward-start
      {
        valid_startelement =0;
        if(TEL_PICTURE_ENTRIES <=elements)//1. more elements requested, than in array
        {
          if (shift ==FALSE)
          {
            for(i=0;i<TEL_PICTURE_ENTRIES;i++)
            {
              if(0 !=gPicture_ListEntryValidInformation[i]) //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i =TEL_PICTURE_ENTRIES;
            }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =1;
            startelement        =valid_startelement;
            for(i=1;i<TEL_PICTURE_ENTRIES;i++)
            {
              if(0 !=gPicture_ListEntryValidInformation[i]) //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i =TEL_PICTURE_ENTRIES;
            }
          }
        }
        else                                      //2. number of requested elements < elements in array
        {
          if (shift ==FALSE)
          {
            for(i=0;i<elements;i++)
            {
              if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
               i =TEL_PICTURE_ENTRIES;
            }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =1;
            startelement        =valid_startelement;
            for(i=1;i<=elements;i++)
            {
              if(0!=gPicture_ListEntryValidInformation[i])  //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i =TEL_PICTURE_ENTRIES;
            }
          }
        }
      } //forward ends
      else if(BACKWARD==direction && TRUE==shift) //backward-start, only if the shift bit is set (this means starting with the last element of the array)
      {
        //searching for valid startelement
        for(i=(TEL_PICTURE_ENTRIES-1);i>=0;i--)
        {
          if(0!=gPicture_ListEntryValidInformation[i])//found valid startelement
          {
            valid_startelement =i;
            i =0;
          }
        }
        //searching for valid elements
        if(0xff==valid_startelement)              //Startelement-ID doesn't exist in SMSReceived-array
        {
          valid_startelement  =startelement;
          valid_elements      =0;
        }
        else if(0==valid_startelement)
          valid_elements=1;                       //only 1 element because valid startelement is on position 0
        else if(elements>(valid_startelement+1))  //not enougth array-elements available, because array endet at array-position 0
        {
          for(i=valid_startelement;i>=0;i--)
          {
            if(0!=gPicture_ListEntryValidInformation[i])//if there is an valid element
              valid_elements++;                   //increment elements
            else                                  //no valid element, loop finished
              i=0;
          }
        }
        else                                      //enougth array-elements available
        {
          for(i=valid_startelement;i>(valid_startelement-elements);i--)
          {
            if(0!=gPicture_ListEntryValidInformation[i])//if there is an valid element
              valid_elements++;                   //increment elements
            else                                  //no valid element, loop finished
              i=0;
          }
        }
      }   //backward-end
    }     //startelement ==0 -end
    /***Startelement!=0***/
    else                                          //searching for Startelement-ID
    {
      //searching for valid startelement
      for(i=0;i<TEL_PICTURE_ENTRIES;i++)
      {
        if(gPicture_Pos[i] ==startelement)//found a valid element
        {
          if(shift==TRUE)                         //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
          {
            if(i!=0 || BACKWARD!=direction)       //if valid_startelement is not the first array element or direction is not backwards
              valid_startelement =i+1-2*direction;
            else if(i==0 && BACKWARD==direction)
                valid_startelement =gPicture_sum;//valid element is last element in Array
            else if(i==0 && FORWARD==direction)
                valid_startelement =0;            //valid element is first element in Array
          }
          else
            valid_startelement =i;                //found element is valid_startelement
          i =TEL_PICTURE_ENTRIES;
        }
        else
          valid_startelement =0xff;
      }
      if(0xff==valid_startelement)                //Startelement-ID doesn't exist in array
      {
        valid_startelement  =startelement;
        valid_elements      =0;
      }
      else                                        //found valid entry for startelement in array
      {
        //verify number of valid elements
        if(BACKWARD==direction)                   //backward-start
        {
          if(valid_startelement==0)               //only 1 element because valid startelement is on position 0
            valid_elements=1;
          else if(elements>(valid_startelement+1))//not enougth array-elements available, because array endet at array-position 0
          {
            for(i=valid_startelement;i>=0;i--)
            {
              if(0!=gPicture_ListEntryValidInformation[i])//if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i=0;
            }
          }
          else                                    //enougth array-elements available
          {
            for(i=valid_startelement;i>(valid_startelement-elements);i--)
            {
              if(0!=gPicture_ListEntryValidInformation[i])//if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i=0;
            }
          }
        }     //backward-end
        else  //forward-start
        {
          if((valid_startelement+elements)>=TEL_PICTURE_ENTRIES)
          {
            for(i=valid_startelement;i<TEL_PICTURE_ENTRIES;i++)
            {
              if(0!=gPicture_Pos[i])      //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i=TEL_PICTURE_ENTRIES;
            }
          }
          else
          {
            for(i=valid_startelement;i<(valid_startelement+elements);i++)
            {
              if(0!=gPicture_Pos[i])      //if there is an valid element
                valid_elements++;                 //increment elements
              else                                //no valid element, loop finished
                i=TEL_PICTURE_ENTRIES;
            }
          }
        }
      }
    }
    putvalue(env_FSG2_CallPic_Elements, valid_elements);
    //send StatusArray
    Picture_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
  }
}

on envVar env_FSG2_CallPic_DataSource
{
  if (getvalue(this) ==TEL_DEFAULT_LIST)
  {
    Picture_init_static();
    putvalue(env_FSG2_CallPic_DataSource_file, empty_string);
    putvalue(env_FSG2_CallPic_DataSource_res, empty_string);
  }
}

on envVar env_FSG2_CallPic_reload //load external ReceptionList from *.csv
{
  if(getvalue(this) && getvalue(env_FSG2_CallPic_DataSource) ==TEL_EXTERNAL_LIST)
    Picture_init_CSV();
  else if(getvalue(env_FSG2_CallPic_DataSource) != TEL_EXTERNAL_LIST)
    putvalue(env_FSG2_CallPic_DataSource_res,"not successful, select 'external *.csv'");
}

byte Picture_buildModeByte (word requested_startelement, word startelement, word elements, byte shift, byte direction, byte transmitpos, byte indexsize)
{
  int  i;
  word PictureLine;
  byte mode;

  //init variables
  indexsize           =0;
  i                   =0;
  PictureLine =0;
  mode                =0;
  if(requested_startelement >0xFE)
      indexsize =TRUE;
  else
  {
    PictureLine =startelement;
    while(i <elements)
    {
      if(PictureLine ==0xff) //Invalid "list entry"
        i =elements;
      else //"list entry" valid
      {
        if(gPicture_Pos[PictureLine] >0xFE)
          indexsize =TRUE;
      }
      i++;
      PictureLine =Picture_nextvalidLine(PictureLine, direction);
    }//end while
  }//end else
  //build mode byte
  mode    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
  return (mode);
}

void Picture_TakeOverData (dword Indication_array [], word Offset, word startelement, word elements, byte recordaddress, byte direction, byte transmitpos, byte indexsize)
{
  int i =0, j =0, length =0;
  word current_PictureLine =0;
  word wTemp=0;

  for(i=0;i<TEL_PICTURE_ENTRIES;i++)
  {
    if(gPicture_Pos[i] ==startelement)
    {
      current_PictureLine =i;
      i =TEL_PICTURE_ENTRIES;
    }
  }

  /***copy elements***/
  for (i=0; i<elements; i++)
  {
    switch (recordaddress)
    {
      case 0: //recordaddress =0 -> complete record (reserved FRU)
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gPicture_Pos[current_PictureLine] =Indication_array [Offset];
            Offset++;
            gPicture_Pos[current_PictureLine] +=Indication_array[Offset] *0x100;
          }
          else
            gPicture_Pos[current_PictureLine] =Indication_array[Offset];
          Offset++;
        }
        //CallID
        gPicture_CallId[current_PictureLine] =Indication_array[Offset];
        Offset++;
        //PictureType
        gPicture_Type[current_PictureLine] =Indication_array[Offset];
        Offset++;
        //IPaddress
        for(j=0; j<TEL_PICTURE_IPADDRESS_LENGTH;j++) //clear
            gPicture_IpAddress[current_PictureLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        if(length ==0) //list element cleared by ASG ('empty string')
            gPicture_ListEntryValidInformation[current_PictureLine] =0;
        for(j=0; j<length;j++) //copy data
        {
            gPicture_IpAddress[current_PictureLine][j] =Indication_array[Offset];
            Offset++;
        }
        //TCP port
        gPicture_TcpPort[current_PictureLine] =Indication_array[Offset];
        Offset++;
        wTemp =Indication_array[Offset];
        wTemp = (wTemp * 0x0100) & 0xFF00;
        gPicture_TcpPort[current_PictureLine] =gPicture_TcpPort[current_PictureLine] + wTemp;
        //URI
        for(j=0; j<TEL_PICTURE_URI_LENGTH;j++) //clear
          gPicture_URI[current_PictureLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        for(j=0; j<length;j++) //copy data
        {
            gPicture_URI[current_PictureLine][j] =Indication_array[Offset];
            Offset++;
        }
      break;
      case 1: //recordaddress =1 -> complete record
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gPicture_Pos[current_PictureLine] =Indication_array [Offset];
            Offset++;
            gPicture_Pos[current_PictureLine] +=Indication_array[Offset] *0x100;
          }
          else
            gPicture_Pos[current_PictureLine] =Indication_array[Offset];
          Offset++;
        }
        //CallID
        gPicture_CallId[current_PictureLine] =Indication_array[Offset];
        Offset++;
        //PictureType
        gPicture_Type[current_PictureLine] =Indication_array[Offset];
        Offset++;
        //IPaddress
        for(j=0; j<TEL_PICTURE_IPADDRESS_LENGTH;j++) //clear
            gPicture_IpAddress[current_PictureLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        if(length ==0) //list element cleared by ASG ('empty string')
            gPicture_ListEntryValidInformation[current_PictureLine] =0;
        for(j=0; j<length;j++) //copy data
        {
            gPicture_IpAddress[current_PictureLine][j] =Indication_array[Offset];
            Offset++;
        }
        //TCP port
        gPicture_TcpPort[current_PictureLine] =Indication_array[Offset];
        Offset++;
        wTemp =Indication_array[Offset];
        wTemp = (wTemp * 0x0100) & 0xFF00;
        gPicture_TcpPort[current_PictureLine] =gPicture_TcpPort[current_PictureLine] + wTemp;
        //URI
        for(j=0; j<TEL_PICTURE_URI_LENGTH;j++) //clear
          gPicture_URI[current_PictureLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        for(j=0; j<length;j++) //copy data
        {
            gPicture_URI[current_PictureLine][j] =Indication_array[Offset];
            Offset++;
        }
      break;
      case 2: //recordaddress =2 -> CallID, PictureType, TCP port, URI
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gPicture_Pos[current_PictureLine] =Indication_array [Offset];
            Offset++;
            gPicture_Pos[current_PictureLine] +=Indication_array[Offset] *0x100;
          }
          else
            gPicture_Pos[current_PictureLine] =Indication_array[Offset];
          Offset++;
        }
        //CallID
        gPicture_CallId[current_PictureLine] =Indication_array[Offset];
        Offset++;
        //PictureType
        gPicture_Type[current_PictureLine] =Indication_array[Offset];
        Offset++;
        //TCP port
        gPicture_TcpPort[current_PictureLine] =Indication_array[Offset];
        Offset++;
        wTemp =Indication_array[Offset];
        wTemp = (wTemp * 0x0100) & 0xFF00;
        gPicture_TcpPort[current_PictureLine] =gPicture_TcpPort[current_PictureLine] + wTemp;
        //URI
        for(j=0; j<TEL_PICTURE_URI_LENGTH;j++) //clear
          gPicture_URI[current_PictureLine][j] =0;
        length =Indication_array[Offset];
        Offset++;
        for(j=0; j<length;j++) //copy data
        {
            gPicture_URI[current_PictureLine][j] =Indication_array[Offset];
            Offset++;
        }
      break;
      case 15: //recordaddress =0xf -> Pos
        //Pos
        if(transmitpos)
        {
          if(indexsize)
          {
            gPicture_Pos[current_PictureLine] =Indication_array [Offset];
            Offset++;
            gPicture_Pos[current_PictureLine] +=Indication_array[Offset] *0x100;
          }
          else
            gPicture_Pos[current_PictureLine] =Indication_array[Offset];
          Offset++;
        }
      break; //recordaddress =0xf ends
    }// end switch recordaddress
    current_PictureLine =Picture_nextvalidLine (current_PictureLine, direction);
  } //end 'for' -> copy elements
}

void Picture_CheckCache ()
{
  int i =0, j =0, k =0;

  for (i=0; i<TEL_PICTURE_ENTRIES; i++)
  {
   if(gPicture_ListEntryValidInformation[i] !=1)
    {
      for (j=i; j<TEL_PICTURE_ENTRIES; j++)
      {
        if(gPicture_ListEntryValidInformation[j])
        {
          //Pos
          gPicture_Pos[i] =0; //clear new position
          gPicture_Pos[i] =i; // -> new Pos for consecutive ID
          //CallID
          gPicture_CallId[i] =0; //clear new position
          gPicture_CallId[i] =gPicture_CallId[j];
          gPicture_CallId[j] =0; //clear old position
          //PictureType
          gPicture_Type[i] =0; //clear new position
          gPicture_Type[i] =gPicture_Type[j];
          gPicture_Type[j] =0; //clear old position
          //IPaddress
          for(k=0; k<TEL_PICTURE_IPADDRESS_LENGTH; k++) //clear new position
              gPicture_IpAddress[i][k]=0;
          for(k=0; k<strlen(gPicture_IpAddress[j]); k++)
              gPicture_IpAddress[i][k]=gPicture_IpAddress[j][k];
          for(k=0; k<TEL_PICTURE_IPADDRESS_LENGTH; k++) //clear old position
              gPicture_IpAddress[j][k]=0;
          //TCP port
          gPicture_TcpPort[i] =0; //clear new position
          gPicture_TcpPort[i] =gPicture_TcpPort[j];
          gPicture_TcpPort[j] =0; //clear old position
          //URI
          for(k=0; k<TEL_PICTURE_URI_LENGTH; k++) //clear new position
              gPicture_URI[i][k]=0;
          for(k=0; k<strlen(gPicture_URI[j]); k++)
              gPicture_URI[i][k]=gPicture_URI[j][k];
          for(k=0; k<TEL_PICTURE_URI_LENGTH; k++) //clear old position
              gPicture_URI[j][k]=0;
          //ValidInformation
          gPicture_ListEntryValidInformation[i] =0; //clear new position
          gPicture_ListEntryValidInformation[i] =gPicture_ListEntryValidInformation[j];
          gPicture_ListEntryValidInformation[j] =0; //clear old position
          j=TEL_PICTURE_ENTRIES;
        }
      }
    }
  }
  gPicture_sum =0;
  for (i=0; i<TEL_PICTURE_ENTRIES; i++)
  {
    if(gPicture_ListEntryValidInformation[i])
      gPicture_sum++;
    else
      i=TEL_PICTURE_ENTRIES;
  }
  gPicture_TotalNumListElements =gPicture_sum;
  putvalue(env_FSG2_CallPic_TNLE,gPicture_TotalNumListElements);
}

//*************************************************************************
//*****************DUMMY***************************************************

//*************************************************************************
void fct_DUMMY()
{
}
