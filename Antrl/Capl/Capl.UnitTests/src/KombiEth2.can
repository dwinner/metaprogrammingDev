/*@!Encoding:1252*/
includes
{
 //   #include "UDPNM.cin"
}

variables
{
    dword gUdpSocketHandleKombi = 0;
    char ipv6SourceAddrStr[40] = "fd53:7cb8:383:5::14";//"FD53:7CB8:383:5::73";//fe80::b1a0:9103:1645:37e4
    char ipv6DestAddrStr[40]   = "fd53:7cb8:383:5::73";
    byte ipv6SourceAddr[16]; //ipv6 ::76
    byte ipv6DestAddr[16]; 
  
    dword ipv6SourceUdpPort = 0xA63D;//42557; 
    dword ipv6DestinationUdpPort =  0xA7F2;//42994;
  
    CHAR gRxBuffer[1472]; // Max. UDP payload without fragmentation
    LONG gResult;
    CHAR gErrorText[200];
  
    msTimer t_TxMsg;
    const dword  TxMsgCycleTime = 3000;
  
      msTimer t_BAPTxMsg;
    const dword  BAPTxMsgCycleTime = 3000;
  
    char textData[24] = "Kombi: Hello UDP Server";
  
    char NM_PduMarshallingData[1452];  
  
    word PduReadPtrNM =0;
    word PduWritePtrNM = 0;
  
    char BAP_PduMarshallingData[1452];    
    word PduReadPtrBAP =0;
    word PduWritePtrBAP = 0; 
  
    struct stNMPduHeadPdu
    {
      byte PduID[4];
      byte PduLen[4];
      byte PduData[256];

    } tstNMPduHeadPdu[8];
    
    struct stBAPPduHeadPdu
    {
      byte PduID[4];
      byte PduLen[4];
      byte PduData[256];

    } tstBAPPduHeadPdu[8];
    
     word NM_PduReadOffset =0;
    word NM_PduWriteOffset = 0;
    
    word BAP_PduReadOffset =0;
    word BAP_PduWriteOffset = 0;      

  char NM_PduData[256];
  char BAP_PduData[256];
    
    
    const dword IPV6_STR_SIZE_UDP = 40; // IPv6 string size
    
    const byte gnBapAudio = 0;
    const byte gnBapNav = 1;
    const byte gnBapSDS = 2;
    const byte gnBapTelefon = 3;
    const byte gnBapTelefon2 = 4; 
  
    const byte gnMaxBapIndex = 4;     
    dword gUdpSocketHandleNM = 0;
    dword gUdpSocketHandleBAP = 0;
    dword gUdpSocketHandleRTP = 0;
    
    dword gUdpSocketHandleNMRecv = 0;
    dword gUdpSocketHandleBAPRecv = 0;
    dword gUdpSocketHandleRTPRecv= 0;   
    
      
    dword gUdpSocketHandleBAPRecvS[5]={0,0,0,0,0}; 
  
    //IPv6 Data string
    char ipv6MainUnitStr[IPV6_STR_SIZE_UDP] = "fd53:7cb8:383:5::73";//"FD53:7CB8:383:5::73";//fe80::b1a0:9103:1645:37e4
    //char ipv6KombiStr[IPV6_STR_SIZE_UDP]   = "fe80::7036:55bd:8ea0:5677";
    char ipv6KombiStr[IPV6_STR_SIZE_UDP]   = "fd53:7cb8:383:5::14";
  
    char ipv6NM_MulticastGrpStr[IPV6_STR_SIZE_UDP]   = "ff14::5";   //ff14::5 //ff02::2
  
    char ipv6BAP_AudioMulticastGrpStr[IPV6_STR_SIZE_UDP] = "ff14::1:31"; //ff14::1:31
    char ipv6BAP_NavMulticastGrpStr[IPV6_STR_SIZE_UDP] = "ff14::1:32";  
    char ipv6BAP_SDSMulticastGrpStr[IPV6_STR_SIZE_UDP] = "ff14::1:46";
    char ipv6BAP_TelefonMulticastGrpStr[IPV6_STR_SIZE_UDP] = "ff14::1:28";   
    char ipv6BAP_Telefon2MulticastGrpStr[IPV6_STR_SIZE_UDP] = "ff14::1:29"; 
    
     char ipv6BAP_MulticastGrpStr[5][IPV6_STR_SIZE_UDP]={
      "ff14::1:31", //Audio
      "ff14::1:32", //Nav
      "ff14::1:46", //SDS
      "ff14::1:28", //Telefon
      "ff14::1:29"  //Telefon2
    };

    char ipv6RTP_NavMulticastGrpStr[IPV6_STR_SIZE_UDP] = "ff14::2:4";   
  
  
  //IPv6 Data Byte Array
  
    byte ipv6MainUnit[16]; //ipv6 ::76
    byte ipv6Kombi[16]; 
    byte ipv6NM_MulticastGrp[16];   
  
    byte ipv6BAP_AudioMulticastGrp[16];
    byte ipv6BAP_NavMulticastGrp[16];  
    byte ipv6BAP_SDSMulticastGrp[16];
    byte ipv6BAP_TelefonMulticastGrp[16];   
    byte ipv6BAP_Telefon2MulticastGrp[16]; 
    
     
    byte ipv6BAP_MulticastGrp[5][16];
        
  
    byte ipv6RTP_NavMulticastGrp[16];   
  
   dword ipv6NM_SrcPort = 42994;//42994;
   dword ipv6NM_DstPort = 42557;//42993; 
  
   dword ipv6BAP_SrcPort = 42993;//42993;
   dword ipv6BAP_DstPort = 42514;//42993;
  
   dword ipv6RTP_SrcPort = 42993;//42993;
   dword ipv6RTP_DstPort = 42800;//42993;
    
   dword ifIdx = 2; //2 is adapter vlan 1.5
    
   byte gBAP_Send_State;

    
    const dword IPV6_STR_SIZE = 40; 
    
    byte ICMP_abSrcIP[16];
    byte ICMP_abDstIP[16];
    
}

on ethernetPacket *
{
  dword ipHeaderLength;
  byte ipProtocol;
  byte icmpType;
  byte i;
  byte cmpResult;
  byte cmpResult2;

  //Type Ethertype byte 12-13 , 16-17 if with VLAN
  switch(this.type)
  {
    case 0x0800: // IPv4
      ipHeaderLength = (this.Byte(0) & 0x0F) * 4;
      
    // byte(x) Message data byte (unsigned 8 bit); Offset 0 is the byte directly after the Ethertype.      
      ipProtocol = this.Byte(9); //byte 0 = 14,  + 9 = byte 23
 

      switch(ipProtocol)
      {
        case 17: //UDP  //TCP = 6
       // HandleUDP( this, ipHeaderLength+8, swapWord(this.Word(ipHeaderLength)), swapWord(this.Word(ipHeaderLength+2)) );
        break;
      }

    break;
      
    case 0x86DD: // IPv6
          
       //Type Ethertype byte 12-13 , 16-17 if with VLAN     
      ipHeaderLength = (this.Byte(0) & 0x0F) * 4;
      ipProtocol = this.Byte(6); //byte 0 = 14, + 6 = byte 20

      switch(ipProtocol)
      {
        case 58: //ICMP = 58

   // byte(x) Message data byte (unsigned 8 bit); Offset 0 is the byte directly after the Ethertype.                
         icmpType = this.Byte(40); //byte 0 = 14, + 40 = byte 54
         // write("<%BASE_FILE_NAME%>[ICMP] Received ICMP Message of type: %d",icmpType);
          
                      //22-37 = source IP6, 38-53 = dest IP6,  - 14 = 8, 24
            for(i=0;i<16;i++)
            {
              ICMP_abSrcIP[i] =  this.Byte(8+i);
            }
            
            for(i=0;i<16;i++)
            {
              ICMP_abDstIP[i] =  this.Byte(24+i);
            }
            
            cmpResult = u8IPv6Compare(ICMP_abSrcIP,ipv6Kombi);
            cmpResult2 = u8IPv6Compare(ICMP_abDstIP,ipv6Kombi);
          
            if(cmpResult2 == 0) //this message is for me
            {
                if(icmpType == 128) //128 = echo request, 129 = echo reply
                {  

                     write("<%BASE_FILE_NAME%>[ICMP] Received ICMP Message request type: %d",icmpType);
                     Ethernet_ReplyICMP6( this, ICMP_abSrcIP, ICMP_abDstIP );
                   
                 }
                else if(icmpType == 129) //128 = echo request, 129 = echo reply
                {  


                    write("<%BASE_FILE_NAME%>[ICMP] Received ICMP Message Reply type: %d",icmpType);
                  
                 }
              }
        break;
      }

    break;  
  }
  
}

on envVar eUDPSendKombiSimulationNMMsg // a synchronization between Mainunit and simulated Kombi UDPNM status
{
  if((getValue( this ) == 1) && (getValue(eUDPSynWithKombiSimulationNode) == 1 ))
  {
    
      NM_u16SendIPv6NMMulticastCastMessage(NM_PduMarshallingData);// NM-Nachricht senden            
  }
  
  putValue(eUDPSendKombiSimulationNMMsg,0);
}

OnUdpReceiveFrom(dword socket, long result, byte ipv6Address[], dword port, char buffer[], dword size)
{

  vUdpReceiveInternal( socket,result,ipv6Address,buffer,size);


}

on timer t_TxMsg
{

   setTimer( t_TxMsg, TxMsgCycleTime );
}






on timer t_BAPTxMsg
{
  
  if(gBAP_Send_State)
  {
      BAP_u16SendIPv6BAPAudioMulticastCastMessage(BAP_PduMarshallingData);
      BAP_u16SendIPv6BAPNavMulticastCastMessage(BAP_PduMarshallingData);
      BAP_u16SendIPv6BAPSDSMulticastCastMessage(BAP_PduMarshallingData);
      BAP_u16SendIPv6BAPTelefonMulticastCastMessage(BAP_PduMarshallingData);
      BAP_u16SendIPv6BAPTelefon2MulticastCastMessage(BAP_PduMarshallingData);
  }
  setTimer( t_BAPTxMsg, BAPTxMsgCycleTime );
}


on preStart
{
  vConvertIPv6toArray(ipv6SourceAddrStr,ipv6SourceAddr);
  vConvertIPv6toArray(ipv6DestAddrStr,ipv6DestAddr);
  vConvertIPv6toArray(ipv6MainUnitStr, ipv6MainUnit);
  vConvertIPv6toArray(ipv6KombiStr, ipv6Kombi);
  vConvertIPv6toArray(ipv6NM_MulticastGrpStr, ipv6NM_MulticastGrp);  
  vConvertIPv6toArray(ipv6BAP_AudioMulticastGrpStr, ipv6BAP_AudioMulticastGrp);    
  
  vConvertIPv6toArray(ipv6BAP_MulticastGrpStr[0], ipv6BAP_MulticastGrp[0]); 
  vConvertIPv6toArray(ipv6BAP_MulticastGrpStr[1], ipv6BAP_MulticastGrp[1]);    
  vConvertIPv6toArray(ipv6BAP_MulticastGrpStr[2], ipv6BAP_MulticastGrp[2]); 
  vConvertIPv6toArray(ipv6BAP_MulticastGrpStr[3], ipv6BAP_MulticastGrp[3]); 
  vConvertIPv6toArray(ipv6BAP_MulticastGrpStr[4], ipv6BAP_MulticastGrp[4]); 
}

on start
{

  //a Unitcast socket to Main unit
 // vOpenIPv6UdpPort(gUdpSocketHandleKombi,ipv6Kombi,ipv6NM_DstPort,ipv6MainUnit,ipv6NM_SrcPort);
  
  //NM Multicast UDP socket
    NM_vOpenIPv6MulticastUdpPort(ipv6Kombi,ipv6NM_SrcPort,ipv6NM_MulticastGrp,ipv6NM_DstPort);
    
    NM_vJoinIPv6MulticastGrp(ipv6NM_MulticastGrp,ipv6NM_DstPort);
  
  //BAP Multicast UDP socket

    BAP_vOpenIPv6MulticastUdpPort(ipv6Kombi,ipv6BAP_SrcPort,ipv6BAP_MulticastGrp[gnBapAudio],ipv6BAP_DstPort);
    BAP_vOpenIPv6MulticastUdpPort(ipv6Kombi,ipv6BAP_SrcPort,ipv6BAP_MulticastGrp[gnBapNav],ipv6BAP_DstPort);
    BAP_vOpenIPv6MulticastUdpPort(ipv6Kombi,ipv6BAP_SrcPort,ipv6BAP_MulticastGrp[gnBapSDS],ipv6BAP_DstPort);
    BAP_vOpenIPv6MulticastUdpPort(ipv6Kombi,ipv6BAP_SrcPort,ipv6BAP_MulticastGrp[gnBapTelefon],ipv6BAP_DstPort);
    BAP_vOpenIPv6MulticastUdpPort(ipv6Kombi,ipv6BAP_SrcPort,ipv6BAP_MulticastGrp[gnBapTelefon2],ipv6BAP_DstPort);
    
    
    BAP_vJoinIPv6MulticastGrp(ipv6BAP_MulticastGrp[gnBapAudio],ipv6BAP_DstPort,gnBapAudio);
    BAP_vJoinIPv6MulticastGrp(ipv6BAP_MulticastGrp[gnBapNav],ipv6BAP_DstPort,gnBapNav);
    BAP_vJoinIPv6MulticastGrp(ipv6BAP_MulticastGrp[gnBapSDS],ipv6BAP_DstPort,gnBapSDS);
    BAP_vJoinIPv6MulticastGrp(ipv6BAP_MulticastGrp[gnBapTelefon],ipv6BAP_DstPort,gnBapTelefon);
    BAP_vJoinIPv6MulticastGrp(ipv6BAP_MulticastGrp[gnBapTelefon2],ipv6BAP_DstPort,gnBapTelefon2); 
  
    setTimer( t_TxMsg, TxMsgCycleTime );

    setTimer( t_BAPTxMsg, BAPTxMsgCycleTime );


  vBuildUdpTestMessage();
  
 
}

void vBuildUdpTestMessage()
{
  memcpy(NM_PduData,"12345678",8);
  NM_u16SetPduMarshallingUdp(8,0x50140C00,NM_PduData); 
  
  memcpy(NM_PduData,"ABCDEFGH",8);
  NM_u16SetPduMarshallingUdp(8,0x20140C00,NM_PduData); 
  
 
  
  
  memcpy(BAP_PduData,"12345678",8);
  BAP_u16SetPduMarshallingUdp(8,0x30003106,BAP_PduData); 
  
  memcpy(NM_PduData,"ABCDEFGH",8);
  BAP_u16SetPduMarshallingUdp(8,0x30003206,BAP_PduData); 
  
 
  
}

void vConvertIPv6toArray(char acAddrStr[], byte abAddr[])
{
     int i; // loop variable 
  
  //1nd IPv6 interface 
    write("Converting IPv6 Address %s to bytes...", acAddrStr);

    gResult = IpGetAddressAsArray( acAddrStr, abAddr );
    if (gResult == 0)
    {
      // success...
      write("IpGetAddressAsArray: returned array with IPv6 bytes:");
      for ( i=0; i<16; i++)
      {        
        write("Byte %.2d = 0x%.2x", i, abAddr[i]);
      }
    }
    else
    {
      write("Error converting");
    } 
     
}

void vOpenIPv6UdpPort( dword &UdpSocketHandler, byte ipv6SrcAddr[],dword ipv6SrcPort,byte ipv6DstAddr[],dword ipv6DstPort)
{
    int i;                          // loop variable  
    dword result;  
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
    char textData[20] = "Hello UDP Server";
  
  //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
      // success...
      write("<%BASE_FILE_NAME%>IpGetAddressAsArray: returned wildcard array with IPv6 bytes:");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6WildcardAddrArray[i]);
      }
    }
    else
    {
      writeLineEx(1, 3, "IpGetAddressAsArray: The wildcard address string was invalid.");
    }
 
      


    // Open UDP socket
    UdpSocketHandler = UdpOpen(ipv6SrcAddr, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
   // UdpSocketHandler = UdpOpen(ipv6WildcardAddrArray, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
    
    // Check for valid socket handle
    if (UdpSocketHandler == ~0)
    {
      write("<%BASE_FILE_NAME%> UdpOpen failed: Result %d", IpGetLastError());
    }
    else // Socket handle valid
    {
      // Send UDP data
      gResult = UdpSendTo(UdpSocketHandler, ipv6DstAddr, ipv6DstPort, textData, strlen(textData));
      write( "<%BASE_FILE_NAME%>UdpSendTo to ipv6: ");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6DstAddr[i]);
      }
      
 
      
      
      // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(UdpSocketHandler) != 997) )
      {
        IpGetLastSocketErrorAsString(UdpSocketHandler, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(UdpSocketHandler) );
      }
 
      // Optionally receive answer from UDP server
      UdpReceiveFrom(UdpSocketHandler, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(UdpSocketHandler) != 997 )
      {
        IpGetLastSocketErrorAsString(UdpSocketHandler, gErrorText, elcount(gErrorText));
        write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(UdpSocketHandler));
      }

      
      
    }
 }


void NM_vOpenIPv6MulticastUdpPort( byte ipv6SrcAddr[],dword ipv6SrcPort,byte ipv6DstAddr[],dword ipv6DstPort)
{
    int i;                          // loop variable  
    dword result,result2;   
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
    char textData[30] = "KombiNM: Hello UDP Server";

  //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
      // success...
      write("<%BASE_FILE_NAME%>IpGetAddressAsArray: returned wildcard array with IPv6 bytes:");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6WildcardAddrArray[i]);
      }
    }
    else
    {
      writeLineEx(1, 3, "<%BASE_FILE_NAME%>IpGetAddressAsArray: The wildcard address string was invalid.");
    }
 
      


    // Open UDP socket
    gUdpSocketHandleNM = UdpOpen(ipv6SrcAddr, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
   // gUdpSocketHandleNM = UdpOpen(ipv6WildcardAddrArray, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
    
    // Check for valid socket handle
    if (gUdpSocketHandleNM == ~0)
    {
      write("<%BASE_FILE_NAME%> UdpOpen failed: Result %d", IpGetLastError());
    }
    else // Socket handle valid
    {

      
      result = IpSetMulticastInterface( gUdpSocketHandleNM, ifIdx );
      if (result == 0)
      {
        write("<%BASE_FILE_NAME%>Socket %d set to send multicast on adapter %d.", gUdpSocketHandleNM, ifIdx);
        write("<%BASE_FILE_NAME%>Sending some multicast messages to :%d ...", ipv6DstPort);
        
       }
      else
      {
        writeLineEx(1, 3, "<%BASE_FILE_NAME%>IpSetMulticastInterface: Error %d", result);
      }
      // Send UDP data
      gResult = UdpSendTo(gUdpSocketHandleNM, ipv6DstAddr, ipv6DstPort, textData, strlen(textData));
      write( "<%BASE_FILE_NAME%>UdpSendTo to ipv6: ");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6DstAddr[i]);
      }
      
 
      
      
      // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleNM) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleNM, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNM) );
      }
 
      // Optionally receive answer from UDP server
      UdpReceiveFrom(gUdpSocketHandleNM, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(gUdpSocketHandleNM) != 997 )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleNM, gErrorText, elcount(gErrorText));
        write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNM));
      }

      
      
    }
 }


void NM_vJoinIPv6MulticastGrp( byte ipv6MultiCastAddr[],dword ipv6MulticastPort)
{
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
  //wildcard IP binding
  long result; // function result
  dword ifIdx = 2;
  Dword port = 12345;
  
    //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
  
        gUdpSocketHandleNMRecv = UdpOpen(ipv6WildcardAddrArray, ipv6MulticastPort); // open an UDP socket...
        if (gUdpSocketHandleNMRecv != ~0)
        {
          result = IpJoinMulticastGroup( gUdpSocketHandleNMRecv, ifIdx, ipv6MultiCastAddr );
          if (result == 0)
          {
            // successfully joined.
            write("successfully joined:  %d", result);
            
            // Optionally receive answer from UDP server
            UdpReceiveFrom(gUdpSocketHandleNMRecv, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

            // Check for error
            if ( IpGetLastSocketError(gUdpSocketHandleNMRecv) != 997 )
            {
              IpGetLastSocketErrorAsString(gUdpSocketHandleNMRecv, gErrorText, elcount(gErrorText));
              write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNMRecv));
              }  

          }
          else
          {
            writeLineEx(1, 3, "IpJoinMulticastGroup: Error %d", result);
          }
        }

    }
    else
     {
       writeLineEx(1, 3, "IpGetAddressAsArray: The wildcard address string was invalid.");
     }
  
  
}


void NM_u16SendIPv6NMMulticastCastMessage(char abUdpNm[])
{

    gResult = UdpSendTo(gUdpSocketHandleNM, ipv6NM_MulticastGrp, ipv6NM_DstPort, abUdpNm, PduWritePtrNM);
    // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleNM) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleNM, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNM) );  
      }
}

void BAP_vOpenIPv6MulticastUdpPort( byte ipv6SrcAddr[],dword ipv6SrcPort,byte ipv6DstAddr[],dword ipv6DstPort)
{
    int i;                          // loop variable  
    dword result,result2;   
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
    char textData[30] = "KombiBAP: Hello UDP Server";

          
    if(gUdpSocketHandleBAP == 0) //firstly check whether port is open, open socket if not 
    {

      // Open UDP socket
      gUdpSocketHandleBAP = UdpOpen(ipv6SrcAddr, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
      // gUdpSocketHandleBAP = UdpOpen(ipv6WildcardAddrArray, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
    }
    
    // Check for valid socket handle
    if (gUdpSocketHandleBAP == ~0)
    {
      write("<%BASE_FILE_NAME%> UdpOpen failed: Result %d", IpGetLastError());
    }
    else // Socket handle valid
    {
      result = IpSetMulticastInterface( gUdpSocketHandleBAP, ifIdx );
      if (result == 0)
      {
        write("<%BASE_FILE_NAME%>Socket %d set to send multicast on adapter %d.", gUdpSocketHandleBAP, ifIdx);
        write("<%BASE_FILE_NAME%>Sending some multicast messages to :%d ...", ipv6DstPort);
        
       }
      else
      {
        writeLineEx(1, 3, "<%BASE_FILE_NAME%>IpSetMulticastInterface: Error %d", result);
      }
      // Send UDP data
      gResult = UdpSendTo(gUdpSocketHandleBAP, ipv6DstAddr, ipv6DstPort, textData, strlen(textData));
      write( "<%BASE_FILE_NAME%>UdpSendTo to ipv6: ");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6DstAddr[i]);
      }
      
 
      
      
      // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleBAP) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleBAP, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleBAP) );
      }
 
      // Optionally receive answer from UDP server
      UdpReceiveFrom(gUdpSocketHandleBAP, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(gUdpSocketHandleBAP) != 997 )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleBAP, gErrorText, elcount(gErrorText));
        write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleBAP));
      }

      
      
    }
 }

void BAP_vJoinIPv6MulticastGrp( byte ipv6MultiCastAddr[],dword ipv6MulticastPort,byte u8Index)
{
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
  //wildcard IP binding
  long result; // function result
  dword ifIdx = 2;
  Dword port = 12345;
  
    //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
        // To be fixed
      if(u8Index == 0)
      {
        gUdpSocketHandleBAPRecvS[u8Index] = UdpOpen(ipv6WildcardAddrArray, ipv6MulticastPort); // open an UDP socket...
      }
      else //reuse same port 
      {
         gUdpSocketHandleBAPRecvS[u8Index] = gUdpSocketHandleBAPRecvS[0];
        
      }
      
        if (gUdpSocketHandleBAPRecvS[u8Index] != ~0)
        {
          write("<%BASE_FILE_NAME%>Socket %d opened at index %d",gUdpSocketHandleBAPRecvS[u8Index],u8Index);
          result = IpJoinMulticastGroup( gUdpSocketHandleBAPRecvS[u8Index], ifIdx, ipv6MultiCastAddr );
          if (result == 0)
          {
            // successfully joined.
            write("<%BASE_FILE_NAME%>Bap moudle %d successfully joined Multicast grp:  %d", u8Index,result);
            
            // Optionally receive answer from UDP server
            UdpReceiveFrom(gUdpSocketHandleBAPRecvS[u8Index], gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

            write("<%BASE_FILE_NAME%>Bap moudle %d started Receiving from Multicast grp:  ", u8Index);
            // Check for error
            if ( IpGetLastSocketError(gUdpSocketHandleBAPRecvS[u8Index]) != 997 )
            {
              IpGetLastSocketErrorAsString(gUdpSocketHandleBAPRecvS[u8Index], gErrorText, elcount(gErrorText));
              write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleBAPRecvS[u8Index]));
              }  

          }
          else
          {
            writeLineEx(1, 3, "IpJoinMulticastGroup: Error %d", result);
          }
        }
        else
        {
           writeLineEx(1, 3, "Open New port failed at index: %d", u8Index);
        }

    }
    else
     {
       writeLineEx(1, 3, "IpGetAddressAsArray: The wildcard address string was invalid.");
     }
  
}

void BAP_u16SendIPv6BAPAudioMulticastCastMessage(char abUdpBAPMsg[])
{

    gResult = UdpSendTo(gUdpSocketHandleBAP, ipv6BAP_MulticastGrp[gnBapAudio], ipv6BAP_DstPort, abUdpBAPMsg, PduWritePtrBAP);
    // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleNM) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleNM, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNM) );  
      }
}



void BAP_u16SendIPv6BAPNavMulticastCastMessage(char abUdpBAPMsg[])
{

    gResult = UdpSendTo(gUdpSocketHandleBAP, ipv6BAP_MulticastGrp[gnBapNav], ipv6BAP_DstPort, abUdpBAPMsg, PduWritePtrBAP);
    // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleNM) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleNM, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNM) );  
      }
}

void BAP_u16SendIPv6BAPSDSMulticastCastMessage(char abUdpBAPMsg[])
{

    gResult = UdpSendTo(gUdpSocketHandleBAP, ipv6BAP_MulticastGrp[gnBapSDS], ipv6BAP_DstPort, abUdpBAPMsg, PduWritePtrBAP);
    // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleNM) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleNM, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNM) );  
      }
}

void BAP_u16SendIPv6BAPTelefonMulticastCastMessage(char abUdpBAPMsg[])
{

    gResult = UdpSendTo(gUdpSocketHandleBAP, ipv6BAP_MulticastGrp[gnBapTelefon], ipv6BAP_DstPort, abUdpBAPMsg, PduWritePtrBAP);
    // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleNM) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleNM, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNM) );  
      }
}

void BAP_u16SendIPv6BAPTelefon2MulticastCastMessage(char abUdpBAPMsg[])
{

    gResult = UdpSendTo(gUdpSocketHandleBAP, ipv6BAP_MulticastGrp[gnBapTelefon2], ipv6BAP_DstPort, abUdpBAPMsg, PduWritePtrBAP);
    // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleNM) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleNM, gErrorText, elcount(gErrorText) );
        write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNM) );  
      }
}

word u16SendIPv6TestMessage()
{
  dword result; 

  write("<%BASE_FILE_NAME%> Send simulated NM message every %d ms...", TxMsgCycleTime);
  
  //Unicast to Mainunit
 // gResult = UdpSendTo(gUdpSocketHandleKombi, ipv6MainUnit, ipv6NM_SrcPort, PduMarshallingData, PduWritePtr);

  //Multicast to NM grp
  gResult = UdpSendTo(gUdpSocketHandleNM, ipv6NM_MulticastGrp, ipv6NM_DstPort, NM_PduMarshallingData, PduWritePtrNM);

  write("<%BASE_FILE_NAME%> Send simulated BAP message every %d ms...", TxMsgCycleTime);
  //Multicast to BAP 
  gResult = UdpSendTo(gUdpSocketHandleBAP, ipv6BAP_AudioMulticastGrp, ipv6BAP_DstPort, BAP_PduMarshallingData, PduWritePtrNM);


  return gResult;
}

//Hence, 1452 bytes per datagram are available for the transmission of signals according to
//the SoAd-approach
word NM_u16SetPduMarshallingUdp(long Len,long ID,char Data[])
 {
  char PduLen[4]; //Pdu length of the user data in byte according to the data
  char PduID[4]; 

  
  PduID[0] = (char)(ID & 0x000000ff);
  PduID[1] = (char)((ID & 0x0000ff00) >> 8);
  PduID[2] = (char)((ID & 0x00ff0000) >> 16);
  PduID[3] = (char)((ID & 0xff000000) >> 24);
  
  
  PduLen[0] = (char)(Len & 0x000000ff);
  PduLen[1] = (char)((Len & 0x0000ff00) >> 8);
  PduLen[2] = (char)((Len & 0x00ff0000) >> 16);
  PduLen[3] = (char)((Len & 0xff000000) >> 24); 
  
  write("PDU ID: %d \r",Len);
  write("%x \r",PduLen[0]);
  write("%x \r",PduLen[1]);
  write("%x \r",PduLen[2]);
  write("%x \r",PduLen[3]);
  
  write("PDU Len: %d \r",ID);
  write("%x \r",PduID[0]);
  write("%x \r",PduID[1]);
  write("%x \r",PduID[2]);
  write("%x \r",PduID[3]);
   
  if(1452 <= PduWritePtrNM) /* Udp Payload is full */
    return 0;
  

  memcpy_off( NM_PduMarshallingData,  PduWritePtrNM + 0, PduID,0,4 );
  
  memcpy_off( NM_PduMarshallingData,  PduWritePtrNM + 4, PduLen,0,4 ); 
  
  memcpy_off( NM_PduMarshallingData,  PduWritePtrNM + 8, Data,0,Len );  
  
  PduWritePtrNM = PduWritePtrNM + 8 + Len;

  return 0;
 }


//Hence, 1452 bytes per datagram are available for the transmission of signals according to
//the SoAd-approach
word BAP_u16SetPduMarshallingUdp(long Len,long ID,char Data[])
 {
  char PduLen[4]; //Pdu length of the user data in byte according to the data
  char PduID[4]; 

  
  PduID[0] = (char)(ID & 0x000000ff);
  PduID[1] = (char)((ID & 0x0000ff00) >> 8);
  PduID[2] = (char)((ID & 0x00ff0000) >> 16);
  PduID[3] = (char)((ID & 0xff000000) >> 24);
  
  
  PduLen[0] = (char)(Len & 0x000000ff);
  PduLen[1] = (char)((Len & 0x0000ff00) >> 8);
  PduLen[2] = (char)((Len & 0x00ff0000) >> 16);
  PduLen[3] = (char)((Len & 0xff000000) >> 24); 
  
  write("PDU ID: %d \r",Len);
  write("%x \r",PduLen[0]);
  write("%x \r",PduLen[1]);
  write("%x \r",PduLen[2]);
  write("%x \r",PduLen[3]);
  
  write("PDU Len: %d \r",ID);
  write("%x \r",PduID[0]);
  write("%x \r",PduID[1]);
  write("%x \r",PduID[2]);
  write("%x \r",PduID[3]);
   
  if(1452 <= PduWritePtrBAP) /* Udp Payload is full */
    return 0;
  

  memcpy_off( BAP_PduMarshallingData,  PduWritePtrBAP + 0, PduID,0,4 );
  
  memcpy_off( BAP_PduMarshallingData,  PduWritePtrBAP + 4, PduLen,0,4 ); 
  
  memcpy_off( BAP_PduMarshallingData,  PduWritePtrBAP + 8, Data,0,Len );  
  
  PduWritePtrBAP = PduWritePtrBAP + 8 + Len;

  return 0;
 }


void vUdpReceiveInternal(dword socket, long result, byte ipv6Address[], char buffer[], dword size)
{
 long cmpResult;
  
   
  if(result!=0)
  {
    vReceivedMessageIPv6();
    return;
   }
    //Check whether received Loopback from own multicast IP
    cmpResult = u8IPv6Compare(ipv6Address,ipv6Kombi);

    if(cmpResult == 0)
    {
       vReceivedMessageIPv6();
      return; //skip message from own IP
    }

  write("<%BASE_FILE_NAME%> Received Udp Message.");
    
 if(socket == gUdpSocketHandleNM) 
  {
    write("<%BASE_FILE_NAME%> Received %d bytes of NM message: %s", size, buffer);
    NM_u16GetPduMarshallingUdp(buffer,size);
  }
  else if(socket == gUdpSocketHandleBAP)
  {
    write("<%BASE_FILE_NAME%> Received %d bytes of BAP message: %s", size, buffer);
    BAP_u16GetPduMarshallingUdp(buffer,size);
    
  }
  
 else if(socket == gUdpSocketHandleNMRecv)
  {
    write("<%BASE_FILE_NAME%> Received %d bytes of NMRecv message: %s", size, buffer);
    NM_u16GetPduMarshallingUdp(buffer,size);
  }

   else if((socket == gUdpSocketHandleBAPRecvS[0])||
           (socket == gUdpSocketHandleBAPRecvS[1])||
            (socket == gUdpSocketHandleBAPRecvS[2])||
            (socket == gUdpSocketHandleBAPRecvS[3])||
            (socket == gUdpSocketHandleBAPRecvS[4])
  )
  {
    write("<%BASE_FILE_NAME%> Received %d bytes of BAPRev message: %s", size, buffer);
    BAP_u16GetPduMarshallingUdp(buffer,size);
    
  }

  
  else
  {
     write("<%BASE_FILE_NAME%> Received %d bytes of Unknown message at %d: %s", size,socket, buffer);
    
  }
 


  vReceivedMessageIPv6();
  
}

void vReceivedMessageIPv6()
{
 byte u8Index;
  
      // Optionally receive answer from UDP server
      UdpReceiveFrom(gUdpSocketHandleNM, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(gUdpSocketHandleNM) != 997 )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleNM, gErrorText, elcount(gErrorText));
        write("<%BASE_FILE_NAME%> UdpReceiveFrom NM failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNM));
      }  
      
      // Optionally receive answer from UDP server
      UdpReceiveFrom(gUdpSocketHandleBAP, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(gUdpSocketHandleBAP) != 997 )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleBAP, gErrorText, elcount(gErrorText));
        write("<%BASE_FILE_NAME%> UdpReceiveFrom BAP failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleBAP));
      }  
        
       // Optionally receive answer from UDP server
      UdpReceiveFrom(gUdpSocketHandleNMRecv, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(gUdpSocketHandleNMRecv) != 997 )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleNMRecv, gErrorText, elcount(gErrorText));
        write("<%BASE_FILE_NAME%> UdpReceiveFrom NMRecv failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleNMRecv));
      }  
      
      for(u8Index = 0; u8Index < gnMaxBapIndex; u8Index++)
      {
        // Optionally receive answer from UDP server
        UdpReceiveFrom(gUdpSocketHandleBAPRecvS[u8Index], gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

        // Check for error
        if ( IpGetLastSocketError(gUdpSocketHandleBAPRecvS[u8Index]) != 997 )
        {
          IpGetLastSocketErrorAsString(gUdpSocketHandleBAPRecvS[u8Index], gErrorText, elcount(gErrorText));
          write("<%BASE_FILE_NAME%> UdpReceiveFrom BAPRecv Index: %d failed, %s (Result %d)",u8Index, gErrorText, IpGetLastSocketError(gUdpSocketHandleBAPRecvS[u8Index]));
        }  
         
      }
  
  
}


//Call in OnUdpReceiveFrom()
// get the payload of the packet

word NM_u16GetPduMarshallingUdp(char acData[],dword len)
{

  BYTE TempPduData[1452];
  CHAR error[100];
  
  long PduLength=0;
  long u32PkgLenBit =0;
  
  long u32PkgLen =0;
  
  byte PduCnt = 0;
  byte MsgCnt = 0;
  dword u32PduID =0;
  
  NM_vClearPduRecvBuff();


  u32PkgLen = len;
  
 // write("Payload length = %d",u32PkgLen);
  
  // get udp payload of the receive packet
  memcpy_off(TempPduData,0,acData,0,u32PkgLen);


    PduCnt = 0;
    // do something with data
    while(NM_PduReadOffset < u32PkgLen)
    {
      //write("Pdu Index = %d",PduCnt);
      memcpy_off(tstNMPduHeadPdu[PduCnt].PduID,0,(TempPduData),NM_PduReadOffset,4);
      u32PduID = 0;
      u32PduID +=  (long)(tstNMPduHeadPdu[PduCnt].PduID[3]&0x000000ff);
      u32PduID = u32PduID<<8;
      u32PduID += (long)(tstNMPduHeadPdu[PduCnt].PduID[2]&0x000000ff);
      u32PduID = u32PduID<<8;
      u32PduID += (long)(tstNMPduHeadPdu[PduCnt].PduID[1]&0x000000ff);
      u32PduID = u32PduID<<8;
      u32PduID += (long)(tstNMPduHeadPdu[PduCnt].PduID[0]&0x000000ff);

      memcpy_off(tstNMPduHeadPdu[PduCnt].PduLen,0,(TempPduData),NM_PduReadOffset+4,4);
      
      PduLength = 0;
      
      PduLength += (long)(tstNMPduHeadPdu[PduCnt].PduLen[3]&0x000000ff);
      PduLength = PduLength<<8;
      PduLength += (long)(tstNMPduHeadPdu[PduCnt].PduLen[2]&0x000000ff);;
      PduLength = PduLength<<8;
      PduLength += (long)(tstNMPduHeadPdu[PduCnt].PduLen[1]&0x000000ff);;
      PduLength = PduLength<<8;
      PduLength += (long)(tstNMPduHeadPdu[PduCnt].PduLen[0]&0x000000ff);;

      
      
     // write("Pdu Length = %d",PduLength);
      
      if(PduLength > 255) // Do a PUD length check to confirm whether it is a PDU msg or other format
      {
        PduLength = 0;
        
        write("Received message is not in PDU format.");
        
        return 0;
        
      }
      
      if(PduLength != 0)
      {
          memcpy_off(tstNMPduHeadPdu[PduCnt].PduData,0,TempPduData,NM_PduReadOffset+8,PduLength);
          
          NM_PduReadOffset += PduLength+8;
         // write("NM_PduReadOffset Length = %d",NM_PduReadOffset);
                  
          PduCnt++;
         // write("PduCnt  = %d",PduCnt);
        
         write("<%BASE_FILE_NAME%> Pdu Index=%d, Len=%d,PDU ID = %x, NM_PduReadOffset=%d",PduCnt,PduLength,u32PduID,NM_PduReadOffset);


       }
      
      
       else if(u32PkgLen != 0)
       {
            write("Pdu Length is 0, msg is not in PDU Marshalling format: ");
            while(MsgCnt<u32PkgLen)
            {
              write("%x ",TempPduData[MsgCnt]);
              MsgCnt++;
            }
              return 1;    
            
      }
      
      else
      {
            return 0;
      }
      
     
      
   }
     write("<%BASE_FILE_NAME%> PDU Marshalling recieve finished...\r");
    
    return 0;


}


//Call in OnUdpReceiveFrom()
// get the payload of the packet

word BAP_u16GetPduMarshallingUdp(char acData[],dword len)
{

  BYTE TempPduData[1452];
  CHAR error[100];
  
  long PduLength=0;
  long u32PkgLenBit =0;
  
  long u32PkgLen =0;
  
  byte PduCnt = 0;
  byte MsgCnt = 0;
  dword u32PduID = 0;
  
  BAP_vClearPduRecvBuff();


  u32PkgLen = len;
  
 // write("Payload length = %d",u32PkgLen);
  
  // get udp payload of the receive packet
  memcpy_off(TempPduData,0,acData,0,u32PkgLen);


    PduCnt = 0;
    // do something with data
    while(BAP_PduReadOffset < u32PkgLen)
    {
      //write("Pdu Index = %d",PduCnt);
      memcpy_off(tstBAPPduHeadPdu[PduCnt].PduID,0,(TempPduData),BAP_PduReadOffset,4);
      
      u32PduID = 0;
      u32PduID +=  (long)(tstBAPPduHeadPdu[PduCnt].PduID[3]&0x000000ff);
      u32PduID = u32PduID<<8;
      u32PduID += (long)(tstBAPPduHeadPdu[PduCnt].PduID[2]&0x000000ff);
      u32PduID = u32PduID<<8;
      u32PduID += (long)(tstBAPPduHeadPdu[PduCnt].PduID[1]&0x000000ff);
      u32PduID = u32PduID<<8;
      u32PduID += (long)(tstBAPPduHeadPdu[PduCnt].PduID[0]&0x000000ff);         

      memcpy_off(tstBAPPduHeadPdu[PduCnt].PduLen,0,(TempPduData),BAP_PduReadOffset+4,4);
      
      PduLength = 0;
      
      PduLength += (long)(tstBAPPduHeadPdu[PduCnt].PduLen[3]&0x000000ff);
      PduLength = PduLength<<8;
      PduLength += (long)(tstBAPPduHeadPdu[PduCnt].PduLen[2]&0x000000ff);;
      PduLength = PduLength<<8;
      PduLength += (long)(tstBAPPduHeadPdu[PduCnt].PduLen[1]&0x000000ff);;
      PduLength = PduLength<<8;
      PduLength += (long)(tstBAPPduHeadPdu[PduCnt].PduLen[0]&0x000000ff);;

      
      
     // write("Pdu Length = %d",PduLength);
      
      if(PduLength > 255) // Do a PUD length check to confirm whether it is a PDU msg or other format
      {
        PduLength = 0;
        
        write("Received message is not in PDU format.");
        
        return 0;
        
      }
      
      if(PduLength != 0)
      {
          memcpy_off(tstBAPPduHeadPdu[PduCnt].PduData,0,TempPduData,BAP_PduReadOffset+8,PduLength);
          
          BAP_PduReadOffset += PduLength+8;
         // write("BAP_PduReadOffset Length = %d",BAP_PduReadOffset);
                  
          PduCnt++;
         // write("PduCnt  = %d",PduCnt);
        
         write("<%BASE_FILE_NAME%> Pdu Index=%d, Len=%d, PDU ID = %x, BAP_PduReadOffset=%d",PduCnt,PduLength,u32PduID,BAP_PduReadOffset);


       }
      
      
       else if(u32PkgLen != 0)
       {
            write("Pdu Length is 0, msg is not in PDU Marshalling format: ");
            while(MsgCnt<u32PkgLen)
            {
              write("%x ",TempPduData[MsgCnt]);
              MsgCnt++;
            }
              return 1;    
            
      }
      
      else
      {
            return 0;
      }
      
     
      
   }
     write("<%BASE_FILE_NAME%> PDU Marshalling recieve finished...\r");
    
    return 0;


}


void NM_vClearPduSendBuff()
{
  NM_PduWriteOffset = 0;
}

void NM_vClearPduRecvBuff()
{
  NM_PduReadOffset = 0;
}

void BAP_vClearPduSendBuff()
{
  BAP_PduWriteOffset = 0;
}

void BAP_vClearPduRecvBuff()
{
  BAP_PduReadOffset = 0;
}

byte u8IPv6Compare(byte ipv6Address1[],byte ipv6Address2[])
{
  byte Cnt;
  
  for(Cnt=0;Cnt<16;Cnt++)
  {
    if(ipv6Address1[Cnt] != ipv6Address2[Cnt])
    {
      return 1;
    }
  }
  
  return 0; //IPs are equal
  
  
}

on sysvar BAP::BAPMulticast
{
   gBAP_Send_State = @this;
}


/// <Ethernet_Packet>
void Ethernet_RequestICMP6(ethernetPacket * pkt)
{
  LONG packetHdl;
  
  char ICMP_ipv6SourceAddrStr[IPV6_STR_SIZE] = "fd53:7cb8:383:5::73";//"FD53:7CB8:383:5::73";//fe80::b1a0:9103:1645:37e4

  char ICMP_ipv6DestAddrStr[IPV6_STR_SIZE]   = "fd53:7cb8:383:5::14";

  byte ICMP_ipv6SourceAddr[16];              // IPv6 address bytes.  

  byte ICMP_ipv6DestAddr[16];  
  CHAR error[100];

  vConvertIPv6toArray(ICMP_ipv6SourceAddrStr, ICMP_ipv6SourceAddr);

  vConvertIPv6toArray(ICMP_ipv6DestAddrStr, ICMP_ipv6DestAddr);
    // create packet
  packetHdl = EthInitPacket("ipv6");
  
    // init UDP protocol
  EthInitProtocol(packetHdl, "icmpv6" );

  if (EthGetLastError() == 0)
  {

      EthAddToken( packetHdl, "eth", "vlanTpid" );
      EthAddToken( packetHdl, "eth", "vlanTci" );
      EthSetTokenInt( packetHdl, "eth", "vlantpid", 0x8100 );
      EthSetTokenInt( packetHdl, "eth", "vlanTci", 0x0005 );
        // set protocol fields    
      EthSetTokenData( packetHdl, "ipv6", "source", 16, ICMP_ipv6SourceAddr ); // 255.255.255.255
      EthSetTokenData( packetHdl, "ipv6", "destination", 16, ICMP_ipv6DestAddr ); // 255.255.255.255
     // EthSetTokenInt( packetHdl, "udp", "source", 23 );
     // EthSetTokenInt( packetHdl, "udp", "destination", 23 );
     EthSetTokenInt( packetHdl, "icmpv6", "type", 128 ); //echo reply
     EthSetTokenInt( packetHdl, "icmpv6", "code", 0 );
      
      EthResizeToken( packetHdl, "icmpv6", "data", 5*8 /*bits*/ );
      EthSetTokenData(packetHdl,"icmpv6","data",5,"Hello");
      
        // Complete and send packet
      EthCompletePacket( packetHdl );
      EthOutputPacket( packetHdl );

      // release packet
      EthReleasePacket( packetHdl );
    }
    else
    {
      EthGetLastErrorText( elCount(error), error );
      write("Error: %s", error );
    }    
  
  write("ICMP Sent...");
}

/// <Ethernet_Packet>
void Ethernet_ReplyICMP6(ethernetPacket * pkt, byte srcIP[],byte dstIP[] )
{
  LONG packetHdl;
 
  CHAR error[100];
  
    // create packet
  packetHdl = EthInitPacket("ipv6");
  
    // init UDP protocol
  EthInitProtocol(packetHdl, "icmpv6" );

  if (EthGetLastError() == 0)
  {
      EthAddToken( packetHdl, "eth", "vlanTpid" );
      EthAddToken( packetHdl, "eth", "vlanTci" );
      EthSetTokenInt( packetHdl, "eth", "vlantpid", 0x8100 );
      EthSetTokenInt( packetHdl, "eth", "vlanTci", 0x0005 );
        // set protocol fields    
      EthSetTokenData( packetHdl, "ipv6", "source", 16, dstIP ); // 255.255.255.255
      EthSetTokenData( packetHdl, "ipv6", "destination", 16, srcIP  ); // 255.255.255.255
     // EthSetTokenInt( packetHdl, "udp", "source", 23 );
     // EthSetTokenInt( packetHdl, "udp", "destination", 23 );
     EthSetTokenInt( packetHdl, "icmpv6", "type", 129 );  //echo reply
    EthSetTokenInt( packetHdl, "icmpv6", "code", 0 );
      
      EthResizeToken( packetHdl, "icmpv6", "data", 5*8 /*bits*/ );
      EthSetTokenData(packetHdl,"icmpv6","data",5,"Hello");
      
        // Complete and send packet
      EthCompletePacket( packetHdl );
      EthOutputPacket( packetHdl );

      // release packet
      EthReleasePacket( packetHdl );
    }
    else
    {
      EthGetLastErrorText( elCount(error), error );
      write("Error: %s", error );
    }    
  
  write("<%BASE_FILE_NAME%> ICMP Sent Reply...");
}