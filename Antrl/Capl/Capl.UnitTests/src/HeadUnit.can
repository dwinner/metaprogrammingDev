//-----------------------------------------------------------------------------
//  Copyright (C) Continental Automotive All Right Reserved
//            File        : HeadUnit.can
//            Author      : Ratheesh
//            Environment : CAPL
//-----------------------------------------------------------------------------
//  Type        : CAPL script
//  Description : This file contains the Head unit simulation
//  Code Status : Not tested
//  Reference   : MIB_MOST_KMatrix_V1.13.00F_20121108_MT.html
//-----------------------------------------------------------------------------
//  Revision History
//  Version     Modified by         Date            Description
//  1.0         Ratheesh            02-Jan-2013     Initial version
//  1.1         Ratheesh            22-Feb-2013     Added reliability test
//  1.2         Ratheesh            09-Apr-2013     Added Isochronous panel
//  1.3         Ratheesh            17-Apr-2013     Rel. test modified
//  1.4         Ratheesh            17-Sep-2014     TvTest NodeState polling modified
//-----------------------------------------------------------------------------

includes
{
  #include "MostDefs.cin"
  #include "FCatDefs.cin"
  #include "GenFunc.cin"
  #include "MOST_MHP.cin"
}

//
// Simulation of a MOST head unit
//
// The function blocks supported are given below.
// 1. PowerMaster
// 2. Diagnosis
// 3. GfxStreamSink
// 4. SoftwareDownload
//
// Abbreviations used are
// HU   - HeadUnit
// DIAG - Diagnosis
// GFX  - GfxStreamSink
// SWDL - SoftwareDownload
//
variables
{
  // Application phase
  const byte kAppOff      = 0; // no power; no communication
  const byte kAppOn       = 1; // power on
  const byte kAppShutdown = 2; // power on; shutdown started
  byte gAppPhase = kAppOff;

  // Diagnosis
  long gInstId_Diag = -1; // -1: InstID not known yet

  // Diagnosis properties of interest
  word gShadowProp_Diag[2] = {
    kFct_DIAG_NodeState,
    kFct_DIAG_WakeupReason
  };

  // GfxStreamSink
  long gInstId_Gfx = -1;  // -1: InstID not known yet

  // GfxStreamSink properties of interest
  word gShadowProp_Gfx[3] = {
    kFct_GFX_FGLayer,
    kFct_GFX_RequestSync,
    kFct_GFX_DataRate
  };

  // SoftwareDownload
  long gInstId_Swdl = -1; // -1: InstID not known yet

  // SoftwareDownload properties of interest
  word gShadowProp_Swdl[1] = {
    kFct_SWDL_DownloadControl
  };

  // This variable indicates test status; 0 - OFF, 1 - ON
  byte gReliabilityTestStatus = 0;
  // Reliability test timer
  msTimer tReliabilityTest;
  // Reliability test timeout
  long gReliabilityTestTOut = 1;
  //Max device list
  const int kDevListMax = 50;
  //Max Nodes
  int gMaxNode;
  // Variable to store reliability test state
  int gRelTestState;
  // Node to be scanned
  int gCurrNode;
  // Reliability test response time
  msTimer tRelTestResponse;
  // Rel. test response interval
  long gRelTestResponseTOut = 50;
  // Response flag
  int gResponseFlag = 0;
  // Timer to repeat test after an interval
  msTimer tRelTestRepeat;
  // Rel test repeat interval
  long gRelTestRepeatTOut = 5000;
  // File handle
  dword gFileHandle;
  // LED state values
  enum RelTest_LEDState
  {
    LEDState_Error = 0,    // red/orange
    LEDState_Start = 1,    // green
    LEDState_Idle  = 2     // yellow
  };
  // Reliability test states
  enum RelTestState
  {
    kRelTest_Init           = 1,
    kRelTest_PrepNodeAddr   = 2,
    kRelTest_SendNodeState  = 3,
    kRelTest_NodeAddr_Wait  = 4,
    kRelTest_NodeState_Wait = 5
  };
  // Device list
  struct {
    int logNodeAddr;
    int nodeStateStatusFlag;
  } gsDevList[kDevListMax];
  
  // NavigationInfo
  long gInstId_Nav = 1;

  
  // RouteGuidance
  msTimer tRGTimer;
  msTimer tRGMsgReset;
  
  dword   gRGState = 0;
  enum gRGState
  {
    kRG_OFF               = 0,
    kRG_WaitActive        = 1,
    kRG_ON                = 2,
    kRG_SendManeuverDesc1 = 3,
    kRG_SendManeuverDesc2 = 4
  };

  // NodeState timer
  msTimer tNodeState;
  long NodeStateTOutms = 4000;
  
  //Wakeup timer
  msTimer tWakeup;
  long WakeupTOutms = 2000;
  
  //WakeupReason send Tout
  msTimer tWakeupReason;
  long WakeupReasonTOut = 1000;
  
  // ---------------------------Enhanced Testability ---------------------------
  long gInstId_ET = kINST_ET;
  long gDA_ET = 0x517;

  // Prefix for callback functions of port is passed to DLL on port creation (see PreStart())
  // If we change it, callback functions with corresponding prefixes need to be renamed too 
  char  gDSO5_Prefix[50] = "ET_DSI1_";
  dword gDSO5_PortHandle;

  // Data Source 5
  dword gDSO5_FBlockID  = kFB_ET;
  dword gDSO5_InstID    = kINST_ET;
  dword gDSO5_FktID     = kFct_ET_DSI_1;
  dword gDSO5_OpTypeID  = kOpTStartResultAck;

  // Prefix for callback functions of port is passed to DLL on port creation (see PreStart())
  // If we change it, callback functions with corresponding prefixes need to be renamed too 
  char  gDSO6_Prefix[50] = "ET_DSI2_";
  dword gDSO6_PortHandle;

  // Data Source 6
  dword gDSO6_FBlockID  = kFB_ET;
  dword gDSO6_InstID    = kINST_ET;
  dword gDSO6_FktID     = kFct_ET_DSI_2;
  dword gDSO6_OpTypeID  = kOpTStartResultAck;

  // Prefix for callback functions of port is passed to DLL on port creation (see PreStart())
  // If we change it, callback functions with corresponding prefixes need to be renamed too 
  char  gDSO7_Prefix[50] = "ET_DSI3_";
  dword gDSO7_PortHandle;

  // Data Source 7
  dword gDSO7_FBlockID  = kFB_ET;
  dword gDSO7_InstID    = kINST_ET;
  dword gDSO7_FktID     = kFct_ET_DSI_3;
  dword gDSO7_OpTypeID  = kOpTStartResultAck;
  // ---------------------------------------------------------------------------
}

on preStart
{
  // configure CAPL node as application node (don't receive spy messages...)
  mostApplicationNode();

  // enable FBlock requests
  // node will poll the Network Master for addresses of these FBlocks after ConfigOk
  mostAsShdEnable(kFB_DIAG, kInstIdBroadcast);
  mostAsShdEnable(kFB_GFX, kInstIdBroadcast);
//  mostAsShdEnable(kFB_SWDL, kInstIdBroadcast);

  // Set Rel. test panel LED to idle state
  @RELTEST::LED_State = LEDState_Idle;

  // register MHP tx port for DSO5 instance 
  gDSO5_PortHandle = MH_CreateTxPort(gDSO5_Prefix);
  gDSO6_PortHandle = MH_CreateTxPort(gDSO6_Prefix);
  gDSO7_PortHandle = MH_CreateTxPort(gDSO7_Prefix);
}

on start
{
  setTimerCyclic(tNodeState, NodeStateTOutms);
}

OnMostNetOn()
{
  AppInit();
  // send a dealloc all
  mostSyncDealloc(0x7F);
  setTimer(tWakeupReason, WakeupReasonTOut);
}

on timer tWakeupReason
{
  // Send WakeupReason.Get
  WakeupReason_Get();
}

/*
Mode
0     FOT disabled: TX light off
1     FOT enabled:  TimingMaster: Modulated light on
                    TimingSlave/Bypass: TX light = RX light
2     FOT enabled:  Constant light on
*/
onMostTxLight(long mode)
{
  if (0 == mode)
  {
    mostAmsClearTxQueue(mostGetChannel());
  }
}

/*
state values
mostNetState_Undefined		 	    0
mostNetState_PowerOff		 		    2
mostNetState_NetInterfaceInit		3
mostNetState_ConfigNotOk			  4
mostNetState_ConfigOk				    5
*/
OnMostNetState(long oldstate, long newstate)
{
  if(newstate == kNetStatePowerOff)
  {
    AppExit();
  }
  else if(newstate == kNetStateConfigOk)
  {
    // Do nothing
  }
  else if(newstate == kNetStateConfigNotOk)
  {
    // :TBD: Stop MHP Tx/Rx
  }

//  if(0 == newstate)
//  {
//    write("mostNetState_Undefined");
//  }
//  else 
  if(2 == newstate)
  {
//    write("mostNetState_PowerOff");
    setTimer(tWakeup, WakeupTOutms);
  }
//  else if(3 == newstate)
//  {
//    write("mostNetState_NetInterfaceInit");
//  }
//  else if(4 == newstate)
//  {
//    write("mostNetState_ConfigNotOk");
//  }
//  else if(5 == newstate)
//  {
//    write("mostNetState_ConfigOk");
//  }

  ConfigureShadowFBlocks();
}

on timer tWakeup
{
  if (1 == @PM::Wakeup_Active)
  {
    MostWakeup(mostGetChannel(), 800);
  }
}

OnMostAsRegistry(long rgtype)
{
  // The event procedure indicates a change in the 
  // Local FBlock list or Bus Registry

  if(gAppPhase != kAppOn)
    return;

  if(rgtype == kBusRegistry)
  {
    // Bus Registy has changed -> re-configure FBlock shadows
    ConfigureShadowFBlocks();
  }
}

long GetInstIdOfFirstFBlock(byte fblockId)
{
  // Finds the first FBlock with fblockId in the Bus Registry
  // and returns its InstId.
  // Returns -1 if FBlock is not available.

  long i;

  if(mostGetNetState() != kNetStateConfigOk)
    return -1;

  for(i = 0; i < mostAsRgGetSize(kBusRegistry); ++i)
  {
    if(mostAsRgGetFBlockID(kBusRegistry, i) == fblockId)
    {
       return mostAsRgGetInstID(kBusRegistry, i);
    }
  }
  return -1;
}

void ConfigureShadowFBlocks(void)
{
  // Configures the shadow FBlocks of interest.
  // Therefore the properties of interest will be registered at the
  // Notification Shadow Service, which registers the device in the
  // Notification Matrix of the FBlocks as soon as the FBlock is
  // known to the device.

  long instId_Diag;
  long instId_Gfx;
//  long instId_Swdl;

  // Check InstIds of Navigation shadow
  instId_Diag = GetInstIdOfFirstFBlock(kFB_DIAG);
  if(instId_Diag != gInstId_Diag)
  {
    // InstId has changed; update entries in notification matrix
    if(gInstId_Diag != -1)
    {
      // Unregister old
      ConfigureShadowProperties(kFB_DIAG, gInstId_Diag, gShadowProp_Diag, 0);
    }

    if(instId_Diag != -1)
    {
      // Register new
      ConfigureShadowProperties(kFB_DIAG, instId_Diag, gShadowProp_Diag, 1);
    }

    // set new InstId
    gInstId_Diag = instId_Diag;
  }

  // Check InstIds of GfxStreamSink shadow
  instId_Gfx = GetInstIdOfFirstFBlock(kFB_GFX);
  if (instId_Gfx != gInstId_Gfx)
  {
    // InstId has changed; update entries in notification matrix
    if (gInstId_Gfx != -1)
    {
      // Unregister old
      ConfigureShadowProperties(kFB_GFX, gInstId_Gfx, gShadowProp_Gfx, 0);
    }

    if (instId_Gfx != -1)
    {
      // MSC_51 first send NaviagationInfo.RG_Select
      mostAMSMessage NavigationInfo.RG_Select.Status msg;
      msg.MsgChannel = mostGetChannel();
      msg.DA = 0x512;
      msg.InstanceId = MostApGetInstID();
      msg.RG_MODE = @NAV::RG_Mode;
      msg.DLC = 0x01;
      output(msg);
      
      // Register new
      ConfigureShadowProperties(kFB_GFX, instId_Gfx, gShadowProp_Gfx, 1);
    }

    // set new InstId
    gInstId_Gfx = instId_Gfx;
  }

//  // Check InstId of SoftwareDownload shadow
//  instId_Swdl = GetInstIdOfFirstFBlock(kFB_SWDL);
//  if (instId_Swdl != gInstId_Swdl)
//  {
//    // InstId has changed; upate entries in notification matrix
//    if (gInstId_Swdl != -1)
//    {
//      // Unregister old
//      ConfigureShadowProperties(kFB_SWDL, gInstId_Swdl, gShadowProp_Swdl, 0);
//    }
//
//    if (instId_Swdl != -1)
//    {
//      // Register new
//      ConfigureShadowProperties(kFB_SWDL, instId_Swdl, gShadowProp_Swdl, 1);
//    }
//
//    // set new InstId
//    gInstId_Swdl = instId_Swdl;
//  }
}

void ConfigureShadowProperties(byte fblockId, byte instId, word shadowProp[], long init)
{
  // Registers/unregisters properties at the Notification Shadow Service.
  // Service will send Notification.Set(SetFunction/ClearFunction) as soon
  // as the FBlock is known to this device.

  long i;

  if(init)
  {
    // Register properties in Notification Shadow Service
    for(i = 0; i < elcount(shadowProp); ++i)
    {
      mostAsNtfShdFunctionEnable(fblockId, instId, shadowProp[i]);
    }
  }
  else
  {
    // Unregister properties from Notification Shadow Service
    for(i = 0; i < elcount(shadowProp); ++i)
    {
      mostAsNtfShdFunctionDisable(fblockId, instId, shadowProp[i]);
    }
  }
}

void AppInit()
{
  // Called on first start of the application.
  byte oldAppPhase;

  if(gAppPhase == kAppOn)
    return;

  oldAppPhase = gAppPhase;

  // application has started now
  gAppPhase = kAppOn;

  // initialize FBlock shadows
  ConfigureShadowFBlocks();

  if(oldAppPhase == kAppShutdown)
  {
    // cancel shut down procedure in PowerMaster
    // :TBD: Need to implement functionality for cancelling shutdown procedure
  }
  else
  {
    if(mostGetSpeedGrade(mostGetChannel()) == kMost150)
    {
      mostWakeUp(mostGetChannel(), 500); 
    }
    else
    {
      mostSetTxLight(mostGetChannel(), 1); // generate an optical wake-up
    }
  }
}

void AppExit()
{
  // Called on final exit of the application.

  if(gAppPhase == kAppOff)
    return;

  // power off
  gAppPhase = kAppOff;
}

//---------------------------------------------------------------------------------
//                             Diagnosis
//---------------------------------------------------------------------------------
on sysvar DIAG::Button_Notification_Set
{
  mostAMSMessage Diagnosis.Notification.Set msg;
  byte FktIDListData[50];
  long FktIDListBytes;
  int i;

  if (@this == 0)
    return;

  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Diag;
  if ((@DIAG::Notification_Set_Ctrl == kNtfn_ClearAll) ||
      (@DIAG::Notification_Set_Ctrl == kNtfn_SetAll))
  {
    // Prepare message
    msg.Control = @DIAG::Notification_Set_Ctrl;
    msg.DeviceID = @DIAG::Notification_Set_DeviceID;
//    mostParamSet(msg, "Control", @DIAG::Notification_Set_Ctrl);
//    mostParamSet(msg, "DeviceID", @DIAG::Notification_Set_DeviceID);
    msg.DLC = 0x03;
  }
  else if ((@DIAG::Notification_Set_Ctrl == kNtfn_ClearFunc)||
           (@DIAG::Notification_Set_Ctrl == kNtfn_SetFunc))
  {
    // Get data
    sysGetVariableData(sysvar::DIAG::Notification_Set_FuncIDList, FktIDListData, FktIDListBytes);

    // Prepare message
    msg.Control = @DIAG::Notification_Set_Ctrl;
    msg.DeviceID = @DIAG::Notification_Set_DeviceID;
//    mostParamSet(msg, "Control", @DIAG::Notification_Set_Ctrl);
//    mostParamSet(msg, "DeviceID", @DIAG::Notification_Set_DeviceID);
    for (i = 0; i < FktIDListBytes; i++)
    {
      msg.BYTE(0x03 + i) = FktIDListData[i];
    }
    msg.DLC = 0x03 + FktIDListBytes;
  }
  else
  {
    // Do nothing
  }

  output(msg);
}

on sysvar DIAG::Button_Notification_Get
{
  mostAMSMessage Diagnosis.Notification.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Diag;
  msg.FktID = @DIAG::Notification_Get_FktID;
//  mostParamSet(msg, "FktID", @DIAG::Notification_Get_FktID);
  output(msg);
}

on sysvar DIAG::Button_FBlockInfo_Get
{
  mostAMSMessage Diagnosis.FBlockInfo.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Diag;
  mostParamSet(msg, "ID", @DIAG::FBlockInfo_Get_ID);
  output(msg);
}

on sysvar DIAG::Button_CompProtection_Set
{
  mostAMSMessage Diagnosis.ComponentProtection.Set msg;
  byte PayloadData[50];
  long PayloadBytes;

  if (@this == 0)
    return;

  // Get data
  sysGetVariableData(sysvar::DIAG::CompProtection_Set_Payload, PayloadData, PayloadBytes);

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Diag;
  mostParamSetData(msg, "Payload", PayloadData, PayloadBytes);
  output(msg);
}

on sysvar DIAG::Button_FktIDs_Get
{
  mostAMSMessage Diagnosis.FktIDs.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Diag;
  msg.DLC = 0x00;
  output(msg);
}

on sysvar DIAG::Button_NodeState_Get
{
  mostAMSMessage Diagnosis.NodeState.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Diag;
  msg.DLC = 0x00;
  output(msg);
}

on sysvar DIAG::Button_WakeupReason_Get
{
  mostAMSMessage Diagnosis.WakeupReason.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Diag;
  msg.DLC = 0x00;
  output(msg);
}

//---------------------------------------------------------------------------------
//                             GfxStreamSink
//---------------------------------------------------------------------------------
on sysvar GFX::Button_FktIDs_Get
{
  mostAMSMessage GfxStreamSink.FktIDs.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.DLC = 0x00;

  output(msg);
}

on sysvar GFX::Button_Notification_Set
{
  mostAMSMessage GfxStreamSink.Notification.Set msg;
  byte FktIDListData[50];
  long FktIDListBytes;
  int i;

  if (@this == 0)
    return;

  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  if ((@GFX::Notification_Set_Cntrl == kNtfn_ClearAll) ||
      (@GFX::Notification_Set_Cntrl == kNtfn_SetAll))
  {
    // Prepare message
    msg.Control = @GFX::Notification_Set_Cntrl;
    msg.DeviceID = @GFX::Notification_Set_DeviceID;
//    mostParamSet(msg, "Control", @GFX::Notification_Set_Cntrl);
//    mostParamSet(msg, "DeviceID", @GFX::Notification_Set_DeviceID);
    msg.DLC = 0x03;
  }
  else if ((@GFX::Notification_Set_Cntrl == kNtfn_ClearFunc)||
           (@GFX::Notification_Set_Cntrl == kNtfn_SetFunc))
  {
    // Get data
    sysGetVariableData(sysvar::GFX::Notification_Set_FuncIDList, FktIDListData, FktIDListBytes);

    // Prepare message
    msg.Control = @GFX::Notification_Set_Cntrl;
    msg.DeviceID = @GFX::Notification_Set_DeviceID;
//    mostParamSet(msg, "Control", @GFX::Notification_Set_Cntrl);
//    mostParamSet(msg, "DeviceID", @GFX::Notification_Set_DeviceID);
    for (i = 0; i < FktIDListBytes; i++)
    {
      msg.BYTE(0x03 + i) = FktIDListData[i];
    }
    msg.DLC = 0x03 + FktIDListBytes;
  }
  else
  {
    // Do nothing
  }

  output(msg);
}

on sysvar GFX::Button_Notification_Get
{
  mostAMSMessage GfxStreamSink.Notification.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.FktID = @GFX::Notification_Get_FktID;
//  mostParamSet(msg, "FktID", @GFX::Notification_Get_FktID);
  output(msg);
}

on sysvar GFX::Button_FBlockInfo_Get
{
  mostAMSMessage GfxStreamSink.FBlockInfo.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  mostParamSet(msg, "ID", @GFX::FBlockInfo_Get_ID);
  output(msg);
}

on sysvar GFX::Button_Connect_StartResult
{
  mostAMSMessage GfxStreamSink.Connect.StartResult msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.SinkNr = @GFX::Connect_SinkNr;
  msg.BlockWidth = @GFX::Connect_BlockWidth;
  msg.ConnectionLabel = @GFX::Connect_ConnLabel;
//  mostParamSet(msg, "SinkNr", @GFX::Connect_SinkNr);
//  mostParamSet(msg, "BlockWidth", @GFX::Connect_BlockWidth);
//  mostParamSet(msg, "ConnectionLabel", @GFX::Connect_ConnLabel);
  output(msg);
}

on sysvar GFX::Button_Connect_StartResultAck
{
  mostAMSMessage GfxStreamSink.Connect.StartResultAck msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.SenderHandle = @GFX::Connect_SenderHandle;
  msg.SinkNr = @GFX::Connect_SinkNr;
  msg.BlockWidth = @GFX::Connect_BlockWidth;
  msg.ConnectionLabel = @GFX::Connect_ConnLabel;
//  mostParamSet(msg, "SenderHandle", @GFX::Connect_SenderHandle);
//  mostParamSet(msg, "SinkNr", @GFX::Connect_SinkNr);
//  mostParamSet(msg, "BlockWidth", @GFX::Connect_BlockWidth);
//  mostParamSet(msg, "ConnectionLabel", @GFX::Connect_ConnLabel);
  output(msg);
}

on sysvar GFX::Button_Disconnect_StartResult
{
  mostAMSMessage GfxStreamSink.DisConnect.StartResult msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.SinkNr = @GFX::Disconnect_SinkNr;
//  mostParamSet(msg, "SinkNr", @GFX::Disconnect_SinkNr);
  output(msg);
}

on sysvar GFX::Button_Disconnect_StartResultAck
{
  mostAMSMessage GfxStreamSink.DisConnect.StartResultAck msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.SenderHandle = @GFX::Disconnect_SenderHandle;
  msg.SinkNr = @GFX::Disconnect_SinkNr;
//  mostParamSet(msg, "SenderHandle", @GFX::Disconnect_SenderHandle);
//  mostParamSet(msg, "SinkNr", @GFX::Disconnect_SinkNr);
  output(msg);
}

on sysvar GFX::Button_FGLayer_Get
{
  mostAMSMessage GfxStreamSink.FGLayer.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.DLC = 0x00;
  output(msg);
}

on sysvar GFX::Button_FGLayer_SetGet
{
  mostAMSMessage GfxStreamSink.FGLayer.SetGet msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  mostParamSet(msg, "FGRefPic", @GFX::FGLayer_FGRefPic);
  output(msg);
}

on sysvar GFX::Button_RequestSync_Get
{
  mostAMSMessage GfxStreamSink.RequestSync.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.DLC = 0x00;
  output(msg);
}

on sysvar GFX::Button_DataRate_Get
{
  mostAMSMessage GfxStreamSink.DataRate.Get msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.DLC = 0x00;
  output(msg);  
}

on sysvar GFX::Button_FadeIn_StartResultAck
{
  mostAMSMessage GfxStreamSink.FadeIn.StartResultAck msg;

  if (@this == 0)
    return;  

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.SenderHandle = @GFX::FadeIn_SenderHandle;
  msg.FadeSpeed = @GFX::FadeIn_FadeSpeed;
  msg.posOffH = @GFX::FadeIn_PosOffH;
  msg.posOffV = @GFX::FadeIn_PosOffV;
//  mostParamSet(msg, "SenderHandle", @GFX::FadeIn_SenderHandle);
//  mostParamSet(msg, "FadeSpeed", @GFX::FadeIn_FadeSpeed);
//  mostParamSet(msg, "posOffH", @GFX::FadeIn_PosOffH);
//  mostParamSet(msg, "posOffV", @GFX::FadeIn_PosOffV);
  output(msg);
}

on sysvar GFX::Button_FadeOut_StartResultAck
{
  mostAMSMessage GfxStreamSink.FadeOut.StartResultAck msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  msg.SenderHandle = @GFX::FadeOut_SenderHandle;
  msg.FadeSpeed = @GFX::FadeOut_FadeSpeed;
//  mostParamSet(msg, "SenderHandle", @GFX::FadeOut_SenderHandle);
//  mostParamSet(msg, "FadeSpeed", @GFX::FadeOut_FadeSpeed);
  output(msg);
}

//---------------------------------------------------------------------------------
//                             SoftwareDownload
//---------------------------------------------------------------------------------

// SoftwareDownload.DeviceDescription.Set message transmission
on sysvar SWDL::Button_DeviceDescription_Set
{
  mostAMSMessage SoftwareDownload.DeviceDescription.Set msg;
  char deviceName[50];
  char moduleName[50];
  word maxBlockSize;

  if (@this == 0)
    return;

  // Get string value
  sysGetVariableString(sysvar::SWDL::DevDesc_Set_DeviceName, deviceName, elcount(deviceName));
  sysGetVariableString(sysvar::SWDL::DevDesc_Set_SwInf_ModuleName, moduleName, elcount(moduleName));

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Swdl;
  mostParamSetString(msg, "DeviceName", deviceName);
  mostParamSet(msg, "HardwareInstance", @SWDL::DevDesc_Set_HwInstance);
  mostParamSet(msg, "Language", @SWDL::DevDesc_Set_Language);
  mostParamSet(msg, "Channel", @SWDL::DevDesc_Set_Channel);
  maxBlockSize = (word)@SWDL::DevDesc_Set_MaxBlockSize;
  mostParamSet(msg,"MaxBlockSize", maxBlockSize);
  mostParamSet(msg, "ModuleCount", @SWDL::DevDesc_Set_ModuleCount);
  mostParamSetString(msg, "SWInfo.ModuleName", moduleName);
  mostParamSet(msg, "SWInfo.HardwareIndex", @SWDL::DevDesc_Set_SwInf_HwIndex);
  mostParamSet(msg, "SWInfo.BLVersion", @SWDL::DevDesc_Set_SwInf_BLVer);
  mostParamSet(msg, "SWInfo.AppVersion", @SWDL::DevDesc_Set_SwInf_AppVer);
  output(msg);
}

// SoftwareDownload.DeviceDescription.Get message transmission
on sysvar SWDL::Button_DeviceDescription_Get
{
  mostAMSMessage SoftwareDownload.DeviceDescription.Get msg;
  char deviceName[50];

  if (@this == 0)
    return;

  // Get string value
  sysGetVariableString(sysvar::SWDL::DevDesc_Get_DeviceName, deviceName, elcount(deviceName));

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Swdl;
  mostParamSetString(msg, "DeviceName", deviceName);
  output(msg);
}

// SoftwareDownload.DownloadStatus.SetGet message transmission
on sysvar SWDL::Button_DownloadStatus_SetGet
{
  mostAMSMessage SoftwareDownload.DownloadStatus.SetGet msg;
  char deviceName[50];

  if (@this == 0)
    return;

  // Get string value
  sysGetVariableString(sysvar::SWDL::DldStatus_SetGet_DeviceName, deviceName, elcount(deviceName));

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Swdl;
  mostParamSetString(msg, "DeviceName", deviceName);
  mostParamSet(msg, "DownloadState", @SWDL::DldStatus_SetGet_DownloadState);
  output(msg);
}

// SoftwareDownload.DeviceReadyState.SetGet message transmission
on sysvar SWDL::Button_DeviceReadyState_SetGet
{
  mostAMSMessage SoftwareDownload.DeviceReadyState.SetGet msg;
  char deviceName[50];

  if (@this == 0)
    return;

  // Get string value
  sysGetVariableString(sysvar::SWDL::DevReadyState_SetGet_DeviceName, deviceName, elcount(deviceName));

  // Prepare message
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Swdl;
  mostParamSetString(msg, "DeviceName", deviceName);
  mostParamSet(msg, "HardwareInstance", @SWDL::DevReadyState_SetGet_HWInstance);
  mostParamSet(msg, "ReadyState", @SWDL::DevReadyState_SetGet_ReadyState);
  output(msg);
}

//---------------------------------------------------------------------------------
//                                  Reliability Test
//---------------------------------------------------------------------------------
on sysvar RELTEST::Button_Measurement_StartStop
{
  long stat;
  long tm[9];
  dword d;
  word ms, us, ns;
  char fileName[50];
  char buf[100];
  byte h, m, s;

  if (@this == 0)
    return;

  if (gReliabilityTestStatus == 0)
  {
    gReliabilityTestStatus = 1;
    // Get time out value
    gRelTestRepeatTOut = @RELTEST::TimerVal;

    // Set file name according to date and time
    getLocalTime(tm);
    convertTimestampNS(timeNowNS(), d, h, m, s, ms, us, ns);
    snprintf(fileName, elcount(fileName),
      "NodeState_%.2d_%.2d_%.4d__%.2d_%.2d_%.2d.asc",
      tm[3], tm[4]+1, tm[5]+1900, tm[2], tm[1], tm[0]);

    // Open file with write permission
    gFileHandle = openFileWrite(fileName, 2);
    if (gFileHandle == 0)
    {
      gReliabilityTestStatus = 0;
      write("%FILE_NAME%: Button_Measurement_StartStop: Error: File open failed!");
      return;
    }
    else
    {
      write("File opened with name %s\n", fileName);
    }

    // Write msg to file
    snprintf(buf, elcount(buf), "Start of Measuring\n");
    // Write to file
    stat = RelTestLog(gFileHandle, buf);
    if (stat == 0)
    {
      write("%FILE_NAME%: Button_Measurement_StartStop: Error: RelTestLog() failed!");
    }

    snprintf(buf, elcount(buf), "User Press Button to start Cyclic Method\n");
    // Write to file
    stat = RelTestLog(gFileHandle, buf);
    if (stat == 0)
    {
      write("%FILE_NAME%: Button_Measurement_StartStop: Error: RelTestLog() failed!");
    }

    gRelTestState = kRelTest_Init;
    // Start measurement
    setTimerCyclic(tReliabilityTest, gReliabilityTestTOut);

    // Set Rel. test panel LED to start state
    @RELTEST::LED_State = LEDState_Start;
  }
  else
  {
    // Resume 4000ms polling
    setTimerCyclic(tNodeState, NodeStateTOutms);
    // Write msg to file
    snprintf(buf, elcount(buf), "User Press Button to stop Cyclic Method\n");
    stat = RelTestLog(gFileHandle, buf);
    if (stat == 0)
    {
      write("%FILE_NAME%: Button_Measurement_StartStop: Error: RelTestLog() failed!");
    }

    gReliabilityTestStatus = 0;
    // Close file
    fileClose(gFileHandle);
    // Stop measurement
    cancelTimer(tReliabilityTest);
    // Set Rel. test panel LED to start state
    @RELTEST::LED_State = LEDState_Idle;
  }
}

on sysvar NAV::RG_Mode
{
  if (@NAV::RG_Mode == kRG_Mode_RGI)
  {
    //send ManeuverDescriptor.STATUS
	  //putValue(env_NaviSD_MD_update,0x01);
  }
}
on timer tReliabilityTest
{
  switch(gRelTestState)
  {
    case kRelTest_Init:
    {
      int i;

      // reset the device list
      for (i = 0; i < kDevListMax; i++)
      {
        gsDevList[i].logNodeAddr = 0xFFFF;
        gsDevList[i].nodeStateStatusFlag = 0;
      }

      // Max nodes
      gMaxNode = mostGetMPR(mostGetChannel());
      // Set current node to be scanned
      gCurrNode = 1;
      if (gCurrNode < gMaxNode)
      {
        gRelTestState = kRelTest_PrepNodeAddr;
      }
      else
      {
        long stat;
        char buf[100];

        write("%FILE_NAME%: tReliabilityTest: MPR = 1 Could not start reliability test!");
        // Write msg to file
        snprintf(buf, elcount(buf), "Test stopped automatically\n");
        stat = RelTestLog(gFileHandle, buf);
        if (stat == 0)
        {
          write("%FILE_NAME%: Button_Measurement_StartStop: Error: RelTestLog() failed!");
        }
        // Set Rel. test panel LED to start state
        @RELTEST::LED_State = LEDState_Idle;
        gReliabilityTestStatus = 0;
        // Close file
        fileClose(gFileHandle);
        cancelTimer(tReliabilityTest);
      }
    }
    break;
    case kRelTest_PrepNodeAddr:
    {
      mostAMSMessage NetBlock.NodeAddress.Get msg;

      msg.DA = 0x400 + gCurrNode;
      msg.MsgChannel = mostGetChannel();
      msg.InstanceId = 0x00;
      output(msg);

      gResponseFlag = 0;
      setTimer(tRelTestResponse, gRelTestResponseTOut);
      gRelTestState = kRelTest_NodeAddr_Wait;
    }
    break;
    case kRelTest_SendNodeState:
    {
      mostAMSMessage Diagnosis.NodeState.Get msg;

      if (gCurrNode < gMaxNode)
      {
        if (gsDevList[gCurrNode].logNodeAddr == 0xFFFF)
        {
          gCurrNode++;
        }
        else
        {
          msg.DA = gsDevList[gCurrNode].logNodeAddr;
          msg.MsgChannel = mostGetChannel();
          msg.InstanceId = 0x00;
          output(msg);

          gResponseFlag = 0;
          setTimer(tRelTestResponse, gRelTestResponseTOut);
          gRelTestState = kRelTest_NodeState_Wait;
        }
      }
      else
      {
        gRelTestState = kRelTest_NodeState_Wait;
        setTimer(tRelTestRepeat, gRelTestRepeatTOut);
      }
    }
    break;
    case kRelTest_NodeAddr_Wait:
    {
      if((gResponseFlag == 1) || (!isTimerActive(tRelTestResponse)))
      {
        // Scan for next node
        gCurrNode++;
        if (gCurrNode < gMaxNode)
        {
          gRelTestState = kRelTest_PrepNodeAddr;
        }
        else
        {
          gCurrNode = 1;
          gRelTestState = kRelTest_SendNodeState;
          // Cancel the normal 4000ms polling
          cancelTimer(tNodeState);
        }

        // Cancel timer
        cancelTimer(tRelTestResponse);
      }
    }
    break;
    case kRelTest_NodeState_Wait:
    {
      long stat;
      char buf[100];

      if (gCurrNode < gMaxNode)
      {
        if(gResponseFlag == 1)
        {
          // Scan for next node
          gCurrNode++;
          gRelTestState = kRelTest_SendNodeState;
          // Cancel timer
          cancelTimer(tRelTestResponse);
        }
        else if (!isTimerActive(tRelTestResponse))
        {
          // Response not received
          // Check the node is alive
          if (IsNodeAlive(gsDevList[gCurrNode].logNodeAddr))
          {
            // Write msg to file
            snprintf(buf, elcount(buf), "NodeAddr: %.3X  No response received\n", gsDevList[gCurrNode].logNodeAddr);
            // Write to file
            stat = RelTestLog(gFileHandle, buf);
            if (stat == 0)
            {
              write("%FILE_NAME%: tReliabilityTest: Error: RelTestLog() failed!");
            }
            // Set Rel. test panel LED to start state
            @RELTEST::LED_State = LEDState_Error;
          }
          else
          {
            write("%FILE_NAME%: RelTest Not logging error - Node is not alive!");
          }

          // Scan for next node
          gCurrNode++;
          gRelTestState = kRelTest_SendNodeState;
        }
        else
        {
          // Do nothing
        }
      }
      else
      {
        if (!isTimerActive(tRelTestRepeat))
        {
          gCurrNode = 1;
          gRelTestState = kRelTest_SendNodeState;
        }
      }
    }
    break;
    default:
    {
      write("%FILE_NAME%: tReliabilityTest: Invalid state!");
      
    }
    break;
  }
}

on timer tRelTestResponse
{
  // Dummy
}

on timer tRelTestRepeat
{
  // Dummy
}

on mostAmsMessage NetBlock.NodeAddress.Status
{
  if (gReliabilityTestStatus == 0)
    return;

  gsDevList[gCurrNode].logNodeAddr = ((this.BYTE(0) << 8) | this.BYTE(1));
  gResponseFlag = 1;
}

on mostAmsMessage Diagnosis.NodeState.Status
{
  if (gReliabilityTestStatus == 0)
    return;
    
  if (gsDevList[gCurrNode].logNodeAddr == this.SA)
  {
    gResponseFlag = 1;
  }
  else
  {
    write("Diagnosis.NodeState.Status received from other node");
  }
}

on mostAmsMessage NetworkMaster.Configuration.Status
{
  long stat;
  long bytesWritten = 0;
  int i;
  char buf[100];
  
  
  if (this.ConfigurationControl == kConfigStat_NewExt)
  {
    mostAMSMessage NetworkMaster.Configuration.Status msg;
    msg.ConfigurationControl = kConfigStat_OK;
    msg.DLC = 0x01;
    msg.DA = 0x3C8;
    output(msg);
  }
  

  if (gReliabilityTestStatus == 0)
    return;

  // Check whether measurement is ON or not
  if (gReliabilityTestStatus == 1)
  {
    switch(this.ConfigurationControl)
    {
      case kConfigStat_NotOK:
      case kConfigStat_OK:
      {
        snprintf(buf, elcount(buf),
          "NetworkMaster.Configuration.Status(%s)\n",
          gConfigStat[this.ConfigurationControl]);
      }
      break;
      case kConfigStat_Invalid:
      case kConfigStat_NewExt:
      {
        bytesWritten = snprintf(buf, elcount(buf),
          "NetworkMaster.Configuration.Status(%s,",
          gConfigStat[this.ConfigurationControl]);
        bytesWritten--; // To discard the NULL character
        for(i = 1; i < this.DLC; i++)
        {
          buf[bytesWritten++] = this.BYTE(i);
          buf[bytesWritten++] = ' ';
        }
        buf[bytesWritten++] = ')';
        buf[bytesWritten++] = '\n';
      }
      break;
      default:
      {
        snprintf(buf, elcount(buf),
          "NetworkMaster.Configuration.Status(Unknown)\n");
      }
      break;
    }

    // Write to file
    stat = RelTestLog(gFileHandle, buf);
    if (stat == 0)
    {
      write("%FILE_NAME%: NetworkMaster.Configuration.Status:Error: RelTestLog() failed!");
    }
  }
}

// Function to write time stamp and message to a file
// The format of the time stamp is DD.MM.YYYY-HH:MM:SS:XXX - 
// Return: 0 - Error
//         1 - No Error
long RelTestLog(dword fHandle, char buf[])
{
  long ret;
  long tm[9];
  dword d;
  word ms, us, ns;
  char tempBuf[256];
  byte h, m, s;

  // Get date and time
  getLocalTime(tm);
  convertTimestampNS(timeNowNS(), d, h, m, s, ms, us, ns);
  // Prepare string
  snprintf(tempBuf, elcount(tempBuf),
    "%.2d.%.2d.%.4d-%.2d:%.2d:%.2d:%.3d - %s",
    tm[3], tm[4]+1, tm[5]+1900, tm[2], tm[1], tm[0], ms, buf);
  // Write to file
  ret = filePutString(tempBuf, elcount(tempBuf), fHandle);
  return ret;
}

//---------------------------------------------------------------------------------
//                             Isochronous Connection
//---------------------------------------------------------------------------------
on sysvar ISOCHR::Button_Connect_VideoData
{
  mostAMSMessage GfxStreamSink.Connect.StartResultAck msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.DA = 0x03C8;
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = 0x01;
  msg.SenderHandle = @ISOCHR::Connect_VideoData_SenderHandle;
  msg.SinkNr = @ISOCHR::Connect_VideoData_SinkNr;
  msg.BlockWidth = @ISOCHR::Connect_VideoData_BlockWidth;
  msg.ConnectionLabel = @ISOCHR::Connect_VideoData_ConnectionLabel;
  output(msg);
}

on sysvar ISOCHR::Button_Connect_PhaseData
{
  mostAMSMessage GfxStreamSink.Connect.StartResultAck msg;

  if (@this == 0)
    return;

  // Prepare message
  msg.DA = 0x03C8;
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = 0x01;
  msg.SenderHandle = @ISOCHR::Connect_PhaseData_SenderHandle;
  msg.SinkNr = @ISOCHR::Connect_PhaseData_SinkNr;
  msg.BlockWidth = @ISOCHR::Connect_PhaseData_BlockWidth;
  msg.ConnectionLabel = @ISOCHR::Connect_PhaseData_ConnectionLabel;
  output(msg);
}
//---------------------------------------------------------------------------------
//                             NavigationInfo
//---------------------------------------------------------------------------------

on sysvar_update NAV::Button_Capabilities_update
{
  mostAMSMessage NavigationInfo.Capabilities.Status msg;

  if (@this == 0)
    return;
  msg.DA = 0x03C8;
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Nav;
    // Prepare message
  msg.SuppNavType = @NAV::SuppNavType;
  
  output(msg);
}

on sysvar_update NAV::Button_DistToDest_update
{
  mostAMSMessage NavigationInfo.DistanceToDestination.Status msg;

  if (@this == 0)
    return;
  
  msg.DA = 0x03C8;
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Nav;
    // Prepare message
  msg.distance = @NAV::DistToDest_Distance;
  msg.unit = @NAV::DistToDest_Unit;
  msg.validity = @NAV::DistToDest_Valid;
  
  output(msg);
}

on sysvar_update NAV::Button_DistToNextMan_update
{
  mostAMSMessage NavigationInfo.DistanceToNextManeuver.Status msg;

  if (@this == 0)
    return;

  msg.DA = 0x03C8;
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Nav;
    // Prepare message
  msg.distance = @NAV::DistToNxtMan_Distance;
  msg.unit = @NAV::DistToNxtMan_Unit;
  msg.validity = @NAV::DistToNxtMan_Valid;
  
  output(msg);
}

on sysvar_update NAV::Button_ETA_update
{
  mostAMSMessage NavigationInfo.ETA.Status msg;

  if (@this == 0)
    return;

  msg.DA = 0x03C8;
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Nav;
    // Prepare message
  msg.TimeFormat = @NAV::ETA_TimeFormat;
  msg.day = @NAV::ETA_Day;
  msg.hour = @NAV::ETA_Hour;
  msg.min = @NAV::ETA_Minute;
  msg.validity = @NAV::ETA_Valid;
  msg.TimeInfo = @NAV::ETA_TimeInfo;
  
  output(msg);
}

on sysvar_update NAV::Button_RGMode_update
{
  mostAMSMessage NavigationInfo.RG_Select.Status msg;

  if (@this == 0)
    return;
  
  msg.DA = 0x03C8;
  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Nav;
    // Prepare message
  msg.RG_MODE = @NAV::RG_Mode;

  output(msg);
}

on sysvar_update NAV::Button_RTT_update
{
  mostAMSMessage NavigationInfo.RTT.Status msg;

  if (@this == 0)
    return;

  msg.MsgChannel = mostGetChannel();
  msg.DA = 0x03C8;
  msg.InstanceId = gInstId_Nav;
    // Prepare message
  msg.hour = @NAV::RTT_Hour;
  msg.min = @NAV::RTT_Minute;
  msg.validity = @NAV::RTT_Valid;

  output(msg);
}

//---------------------------------------------------------------------------------
//                             Route Guidance
//---------------------------------------------------------------------------------
on sysvar sysvar::RouteGuidance::Button_Start
{
  mostAMSMessage GfxStreamSink.FadeOut.StartResultAck msg;

  byte FktIDListData[50];
  long FktIDListBytes;
  int i;

  if (@this == 0)
  {
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_RG_Status_update, 0);
    //putValue(env_NaviSD_MD_update, 0);
    
    putValue(P_FSG_50_0_0_17Status_BTN, 0);
    putValue(P_FSG_50_0_0_23Status_BTN, 0);
  }
  else
  {
    // Send BAP message
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_MD_update, 1);

    //putValue(env_NaviSD_RG_Status, 1);
    //putValue(env_NaviSD_RG_Status_update, 1);
    
    putValue(P_FSG_50_0_0_23Status_BTN, 1);

    putValue(P_FSG_50_0_0_17_1, 1);
    putValue(P_FSG_50_0_0_17Status_BTN, 1);
    
    gRGState = kRG_WaitActive;
    setTimer(tRGTimer, 5);   
    
    // Send MOST message
    msg.MsgChannel = mostGetChannel();
    msg.InstanceId = gInstId_Gfx;
    msg.SenderHandle = @GFX::FadeOut_SenderHandle;
    @GFX::FadeOut_FadeSpeed = 0x01;
    msg.FadeSpeed = @GFX::FadeOut_FadeSpeed;
    output(msg);
  }
}

on sysvar sysvar::RouteGuidance::Button_Stop
{
  mostAMSMessage NavigationInfo.RG_Select.Status msg;
  byte Element[1];
  
  if (@this == 0)
  {
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_RG_Status_update, 0);
    //putValue(env_NaviSD_MD_update, 0);
    //putValue(env_NaviSD_CompassInfo_update, 0);
    //putValue(env_NaviSD_ActRGTy_RGType_update,0);
    
    putValue(P_FSG_50_0_0_17Status_BTN, 0);
    putValue(P_FSG_50_0_0_23Status_BTN, 0);
    putValue(P_FSG_50_0_0_16Status_BTN, 0);
    putValue(P_FSG_50_0_0_39Status_BTN,0);
  }
  else
  {
    gRGState = kRG_OFF;
    cancelTimer(tRGTimer);
    // Send BAP message
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_RG_Status, 0);
    //putValue(env_NaviSD_RG_Status_update, 1);
    
 		//putValue(env_NaviSD_MD_MainElement1,0);
    //putValue(env_NaviSD_MD_Direction1,0);
    //putValue(env_NaviSD_MD_Z_Level1,0);
    //putValue(env_NaviSD_MD_update, 1);

    //putValue(env_NaviSD_CompassInfo_update, 1);
    
    putValue(P_FSG_50_0_0_17_1, 0);
    putValue(P_FSG_50_0_0_17Status_BTN, 1);
    Element[0] = 0;
    
 		putValue(P_FSG_50_0_0_23_1,Element);
    putValue(P_FSG_50_0_0_23_2_Direction_range,0);
    putValue(P_FSG_50_0_0_23_3, Element);
    putValue(P_FSG_50_0_0_23Status_BTN, 1);

    putValue(P_FSG_50_0_0_16Status_BTN, 1);
    
    // RG Type: Compass
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_ActRGTy_RGType, 0x02);
    //putValue(env_NaviSD_ActRGTy_RGType_update,1);
    putValue(P_FSG_50_0_0_39_1, 0x02);
    putValue(P_FSG_50_0_0_39Status_BTN,1);
    
    msg.MsgChannel = mostGetChannel();
    msg.InstanceId = gInstId_Nav;
    @NAV::RG_Mode = 0x02;
    msg.RG_MODE = @NAV::RG_Mode;
    output(msg);
  }
}

on sysvar sysvar::RouteGuidance::Button_KL15
{
  if (@this == 0)
  {
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_RG_Status_update, 0);
    //putValue(env_NaviSD_ActRGTy_RGType_update,0);
    putValue(P_FSG_50_0_0_17Status_BTN, 0);
    putValue(P_FSG_50_0_0_39Status_BTN,0);
    
  }
  else
  {
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_RG_Status_update, 1);
    //putValue(env_NaviSD_ActRGTy_RGType, 0xFF);
    //putValue(env_NaviSD_ActRGTy_RGType_update,1);
    putValue(P_FSG_50_0_0_17Status_BTN, 1);
    putValue(P_FSG_50_0_0_39_1, 0xFF);
    putValue(P_FSG_50_0_0_39Status_BTN,1);

  }    
}

on sysvar sysvar::RouteGuidance::Button_ActiceRGType
{
  if (@this == 0)
  {
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_ActRGTy_RGType_update,0);
    putValue(P_FSG_50_0_0_39Status_BTN,1);
    
  }
  else
  {
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_ActRGTy_RGType_update,1);
    putValue(P_FSG_50_0_0_39Status_BTN,1);
  }    
}
  

on mostAmsMessage GfxStreamSink.FadeOut.ResultAck
{
  mostAMSMessage NavigationInfo.RG_Select.Status msg;

  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Nav;
  @NAV::RG_Mode = 0x01;
  msg.RG_MODE = @NAV::RG_Mode;
  output(msg);
}

on mostAmsMessage GfxStreamSink.DataRate.Status
{
  mostAMSMessage GfxStreamSink.FadeIn.StartResultAck msg;

  msg.MsgChannel = mostGetChannel();
  msg.InstanceId = gInstId_Gfx;
  
  @GFX::FadeIn_FadeSpeed = 1;
  msg.SenderHandle = @GFX::FadeIn_SenderHandle;;
  msg.FadeSpeed = @GFX::FadeIn_FadeSpeed;
  msg.posOffH = @GFX::FadeIn_PosOffH;
  msg.posOffV = @GFX::FadeIn_PosOffV;
  output(msg);
}

on Timer tRGTimer
{
  byte Element[1];
  if (gRGState == kRG_WaitActive)
  {
    setTimerCyclic(tRGTimer, 1000);   
    
    // RG Type: Most
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_ActRGTy_RGType, 0x01);
    putValue(P_FSG_50_0_0_39_1, 0x01);
    
    //putValue(env_NaviSD_ActRGTy_RGType_update,1);
    putValue(P_FSG_50_0_0_39Status_BTN,1);
    
    gRGState = kRG_ON;
    setTimer(tRGMsgReset, 1);
  }
  else if ((gRGState == kRG_SendManeuverDesc1) || (gRGState == kRG_ON))
  {
    Element[0] = 0xB;
    
    //MainElement
    //FPK_15S1 simulation update for Navi
		//putValue(env_NaviSD_MD_MainElement1, 0x0B);
    putValue(P_FSG_50_0_0_23_1, Element);
    
    //Direction
   
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_MD_Direction1, 0);
    putValue(P_FSG_50_0_0_23_2_Direction_range, 0);
    
    //FPK_15S1 simulation update for Navi
    // putValue(env_NaviSD_MD_update, 1);
    putValue(P_FSG_50_0_0_23Status_BTN, 1);
    
     
    gRGState = kRG_SendManeuverDesc2;
    setTimer(tRGMsgReset, 1);
  }
  else if (gRGState == kRG_SendManeuverDesc2)
  {
    Element[0] = 0xD;
		//FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_MD_MainElement1, 0x0D);
    putValue(P_FSG_50_0_0_23_1, Element);
    //Direction
    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_MD_Direction1, 0x40);
    putValue(P_FSG_50_0_0_23_2_Direction_range, 0x40);
    

    //FPK_15S1 simulation update for Navi
    //putValue(env_NaviSD_MD_update, 1);
    putValue(P_FSG_50_0_0_23Status_BTN, 1);
    
    
    gRGState = kRG_SendManeuverDesc1;
    setTimer(tRGMsgReset, 1);
  }
  @NAV::Button_ETA_update = 1;
  @NAV::Button_RTT_update = 1;
  @NAV::Button_DistToDest_update = 1;
  @NAV::Button_DistToNextMan_update = 1;
}

on Timer tRGMsgReset
{
  switch(gRGState)
  {
    case kRG_ON:
      //FPK_15S1 simulation update for Navi
      //putValue(env_NaviSD_ActRGTy_RGType_update,0);
      putValue(P_FSG_50_0_0_39Status_BTN,0);
      
    break;
    case kRG_SendManeuverDesc1:
    case kRG_SendManeuverDesc2:
      //FPK_15S1 simulation update for Navi
      //putValue(env_NaviSD_MD_update, 0);
      putValue(P_FSG_50_0_0_23Status_BTN, 0);
      break;
    
    default:
      break;
      
  }
}

//---------------------------------------------------------------------------------
//                              NodeState.Get
//                              Target Address = 0x3FF
//                              InstID = 0xFF
//                              Interval 4000ms
//                              Start automatically when simulation starts
//---------------------------------------------------------------------------------
on timer tNodeState
{
  mostAMSMessage Diagnosis.NodeState.Get msg;
  /*
  mostGetLockEx()
  0: Unlock
  1: Lock
  2: Stable Lock
  3: Critical Unlock
  */
  if(2 == mostGetLockEx(mostGetChannel()))
  {
    msg.MsgChannel = mostGetChannel();
    msg.DA = 0x3FF;
    msg.InstanceId = 0xFF;
    output(msg);
  }
}

//---------------------------------------------------------------------------------
//                             WakeupReason.Get
//                             Normal startup - NetOFF to NetON
//---------------------------------------------------------------------------------
void WakeupReason_Get(void)
{
  mostAMSMessage Diagnosis.WakeupReason.Get msg;
  msg.MsgChannel = mostGetChannel();
  msg.DA = 0x3FF;
  msg.InstanceId = 0xFF;
  output(msg);
}

//---------------------------------------------------------------------------------
//                             Enhanced Testability
//---------------------------------------------------------------------------------
on sysvar ET::Button_AutoWakeup_Set
{
  mostAMSMessage EnhancedTestability.AutoWakeup.Set msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  mostParamSet(msg, "DelayTime", @ET::AutoWakeup_Set_DelayTime);
  mostParamSet(msg, "Diagnosis", @ET::AutoWakeup_Set_Diagnosis);
  mostParamSet(msg, "Reserved", 0);
  mostParamSet(msg, "Duration", @ET::AutoWakeup_Set_Duration);
  msg.DLC = 0x04;
  output(msg);
}

on sysvar ET::Button_AutoWakeup_SetGet
{
  mostAMSMessage EnhancedTestability.AutoWakeup.SetGet msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  mostParamSet(msg, "DelayTime", @ET::AutoWakeup_Set_DelayTime);
  mostParamSet(msg, "Diagnosis", @ET::AutoWakeup_Set_Diagnosis);
  mostParamSet(msg, "Reserved", 0);
  mostParamSet(msg, "Duration", @ET::AutoWakeup_Set_Duration);
  msg.DLC = 0x04;
  output(msg);
}

on sysvar ET::Button_AutoWakeup_Get
{
  mostAMSMessage EnhancedTestability.AutoWakeup.Get msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_DiagResult_Get
{
  mostAMSMessage EnhancedTestability.DiagResult.Get msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_Shutdown_Start
{
  mostAMSMessage *msg;

  if (@this == 0)
    return;

  msg.MsgChannel = mostGetChannel();
  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.FunctionID = kFct_ET_Shutdown;
  msg.InstanceId = gInstId_ET;
  msg.OpType = kOpTStart;
  msg.BYTE(0) = @ET::Shutdown_Start_Type;
  msg.DLC = 0x01;
  output(msg);
}

on sysvar ET::Button_ShutdownSuspendMode_Set
{
  mostAMSMessage EnhancedTestability.ShutdownSuspendMode.Set msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  mostParamSet(msg, "Suspend", @ET::ShutdownSuspendMode_Set_Suspend);
  msg.DLC = 0x01;
  output(msg);
}

on sysvar ET::Button_ShutdownSuspendMode_SetGet
{
  mostAMSMessage EnhancedTestability.ShutdownSuspendMode.SetGet msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  mostParamSet(msg, "Suspend", @ET::ShutdownSuspendMode_Set_Suspend);
  msg.DLC = 0x01;
  output(msg);
}

on sysvar ET::Button_ShutdownSuspendMode_Get
{
  mostAMSMessage EnhancedTestability.ShutdownSuspendMode.Get msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_SendMessage_StartResult
{
  mostAMSMessage *msg;

  if (@this == 0)
    return;

  msg.MsgChannel = mostGetChannel();
  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.FunctionID = kFct_ET_SendMessage;
  msg.InstanceId = gInstId_ET;
  msg.OpType = kOpTStartResult;
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_EchoMessage_StartResult
{
  mostAMSMessage *msg;
  byte data[250];
  long len;
  long i;

  if (@this == 0)
    return;

  sysGetVariableData(sysvar::ET::EchoMessage_StartResult_Data, data, len);

  msg.MsgChannel = mostGetChannel();
  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.FunctionID = kFct_ET_EchoMessage;
  msg.InstanceId = gInstId_ET;
  msg.OpType = kOpTStartResult;
  for (i = 0; i < len; i++)
  {
    msg.BYTE(i) = data[i];
  }
  msg.DLC = len;;
  output(msg);
}

on sysvar ET::Button_MessageBufSize_Get
{
  mostAMSMessage EnhancedTestability.MessageBufSize.Get msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_CodingErrors_Get
{
  mostAMSMessage EnhancedTestability.CodingErrors.Get msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_CodingErrors_Set
{
  mostAMSMessage EnhancedTestability.CodingErrors.Set msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  mostParamSet(msg, "State", @ET::CodingErrors_Set_State);
  mostParamSet(msg, "Reserved", 0);
  mostParamSet(msg, "Timeout", @ET::CodingErrors_Set_TimeOut);
  output(msg);
}

on sysvar ET::Button_Reset_Start
{
  mostAMSMessage *msg;

  if (@this == 0)
    return;

  msg.MsgChannel = mostGetChannel();
  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.FunctionID = kFct_ET_Reset;
  msg.InstanceId = gInstId_ET;
  msg.OpType = kOpTStart;
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_CentralRegistrySize_Get
{
  mostAMSMessage EnhancedTestability.CentralRegistrySize.Get msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_NotificationMatrixSize_Get
{
  mostAMSMessage EnhancedTestability.NotificationMatrixSize.Get msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_SystemState_Get
{
  mostAMSMessage EnhancedTestability.SystemState.Get msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_MostRemoteReset_SetGet
{
  mostAMSMessage EnhancedTestability.MOSTRemoteReset.SetGet msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  mostParamSet(msg, "Settings", @ET::MostRemoteReset_SetGet_Settings);
  output(msg);
}

on sysvar ET::Button_PhysicalLayerTest_StartResultAck
{
  mostAMSMessage EnhancedTestability.PhysicalLayerTest.StartResultAck msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.BYTE(0) = (byte)((@ET::PhysicalLayerTest_StartResultAck_SenderHandle & 0xFF00) >> 8);
  msg.BYTE(1) = (byte)(@ET::PhysicalLayerTest_StartResultAck_SenderHandle & 0x00FF);
  msg.BYTE(2) = @ET::PhysicalLayerTest_StartResultAck_Type;
  msg.BYTE(3) = (byte)((@ET::PhysicalLayerTest_StartResultAck_Leadin & 0xFF00) >> 8);
  msg.BYTE(4) = (byte)(@ET::PhysicalLayerTest_StartResultAck_Leadin & 0x00FF);
  msg.BYTE(5) = 0x00;
  msg.BYTE(6) = 0x00;
  msg.BYTE(7) = (byte)((@ET::PhysicalLayerTest_StartResultAck_Duration & 0xFF00) >> 8);
  msg.BYTE(8) = (byte)(@ET::PhysicalLayerTest_StartResultAck_Duration & 0x00FF);
  msg.BYTE(9) = (byte)((@ET::PhysicalLayerTest_StartResultAck_Leadout & 0xFF00) >> 8);
  msg.BYTE(10) = (byte)(@ET::PhysicalLayerTest_StartResultAck_Leadout & 0x00FF);
  msg.DLC = 0x0B;
  output(msg);
}

on sysvar ET::Button_PhysicalLayerTestResult_Get
{
  mostAMSMessage EnhancedTestability.PhysicalLayerTestResult.Get msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_DSIDSOCount_Get
{
  mostAMSMessage EnhancedTestability.DSIDSOCount.Get msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  msg.DLC = 0x00;
  output(msg);
}

on sysvar ET::Button_DSIHold_StartAck
{
  mostAMSMessage EnhancedTestability.DSIHold.StartAck msg;

  if (@this == 0)
    return;

  msg.DA = gDA_ET;
  msg.FBlockID =kFB_ET;
  msg.InstanceId = gInstId_ET;
  msg.MsgChannel = mostGetChannel();
  mostParamSet(msg, "SenderHandle", @ET::DSIHold_StartAck_SenderHandle);
  mostParamSet(msg, "Hold", @ET::DSIHold_StartAck_Hold);
  mostParamSet(msg, "DSIIndex", @ET::DSIHold_StartAck_DSIIndex);
  output(msg);
}

on sysvar ET::Button_DSI_1_StartResultAck
{
  byte buf[10000];
  byte tempBuf[10000];
  long len;
  long i;

  if (@this == 0)
    return;
  
  // Get data
  sysGetVariableData(sysvar::ET::DSI_1_StartResultAck_Data, tempBuf, len);
  buf[0] = (byte)((@ET::DSI_1_StartResultAck_SenderHandle & 0xFF00) >> 8);
  buf[1] = (byte)(@ET::DSI_1_StartResultAck_SenderHandle & 0x00FF);
  for(i = 0; i < len; i++)
  {
    buf[2 + i] = tempBuf[i];
  }
  len +=2;
  // MH_ReqTrans creates a sender instance and tries to open a connection
  // to the destination address. Once the connection is established, the
  // callback ...MH_IndTxBufferRequested is called to provide the data to 
  // be transmitted.
  if(MH_ReqTrans(gDSO5_PortHandle, 
                 gDA_ET, 
                 gDSO5_FBlockID, 
                 gDSO5_InstID, 
                 gDSO5_FktID, 
                 gDSO5_OpTypeID,
                 buf,
                 len) == kAPIResult_Ok)  
  {
    write("%FILE_NAME%: DSO5 requests transmission on tx port %d.", gDSO5_PortHandle);
  }
  else
  {
    write("%FILE_NAME%: DSO5 failed to request transmission on tx port %d. Port is busy or callback is missing.", gDSO5_PortHandle);
  }
}

on sysvar ET::Button_DSI_2_StartResultAck
{
  byte buf[10000];
  byte tempBuf[10000];
  long len;
  long i;

  if (@this == 0)
    return;
  
  // Get data
  sysGetVariableData(sysvar::ET::DSI_2_StartResultAck_Data, tempBuf, len);
  buf[0] = (byte)((@ET::DSI_2_StartResultAck_SenderHandle & 0xFF00) >> 8);
  buf[1] = (byte)(@ET::DSI_2_StartResultAck_SenderHandle & 0x00FF);
  for(i = 0; i < len; i++)
  {
    buf[2 + i] = tempBuf[i];
  }
  len +=2;
  // MH_ReqTrans creates a sender instance and tries to open a connection
  // to the destination address. Once the connection is established, the
  // callback ...MH_IndTxBufferRequested is called to provide the data to 
  // be transmitted.
  if(MH_ReqTrans(gDSO6_PortHandle, 
                 gDA_ET, 
                 gDSO6_FBlockID, 
                 gDSO6_InstID, 
                 gDSO6_FktID, 
                 gDSO6_OpTypeID,
                 buf,
                 len) == kAPIResult_Ok)  
  {
    write("%FILE_NAME%: DSO6 requests transmission on tx port %d.", gDSO6_PortHandle);
  }
  else
  {
    write("%FILE_NAME%: DSO6 failed to request transmission on tx port %d. Port is busy or callback is missing.", gDSO6_PortHandle);
  }
}

on sysvar ET::Button_DSI_3_StartResultAck
{
  byte buf[10000];
  byte tempBuf[10000];
  long len;
  long i;

  if (@this == 0)
    return;
  
  // Get data
  sysGetVariableData(sysvar::ET::DSI_3_StartResultAck_Data, tempBuf, len);
  buf[0] = (byte)((@ET::DSI_3_StartResultAck_SenderHandle & 0xFF00) >> 8);
  buf[1] = (byte)(@ET::DSI_3_StartResultAck_SenderHandle & 0x00FF);
  for(i = 0; i < len; i++)
  {
    buf[2 + i] = tempBuf[i];
  }
  len +=2;
  // MH_ReqTrans creates a sender instance and tries to open a connection
  // to the destination address. Once the connection is established, the
  // callback ...MH_IndTxBufferRequested is called to provide the data to 
  // be transmitted.
  if(MH_ReqTrans(gDSO7_PortHandle, 
                 gDA_ET, 
                 gDSO7_FBlockID, 
                 gDSO7_InstID, 
                 gDSO7_FktID, 
                 gDSO7_OpTypeID,
                 buf,
                 len) == kAPIResult_Ok)  
  {
    write("%FILE_NAME%: DSO6 requests transmission on tx port %d.", gDSO7_PortHandle);
  }
  else
  {
    write("%FILE_NAME%: DSO6 failed to request transmission on tx port %d. Port is busy or callback is missing.", gDSO7_PortHandle);
  }
}

// MHP callback function
ET_DSI1_MH_IndTxBufferRequested(dword handle, long isPacketBegin)
{
  write("%FILE_NAME%: Called ET_DSI1_MH_IndTxBufferRequested()");
}

// MHP callback function
ET_DSI2_MH_IndTxBufferRequested(dword handle, long isPacketBegin)
{
  write("%FILE_NAME%: Called ET_DSI2_MH_IndTxBufferRequested()");
}

// MHP callback function
ET_DSI3_MH_IndTxBufferRequested(dword handle, long isPacketBegin)
{
  write("%FILE_NAME%: Called ET_DSI3_MH_IndTxBufferRequested()");
}

// MHP callback function
ET_DSI1_MH_IndTxPktFinished(dword handle, long packetSize)
{
  MH_TxStopTrans(gDSO5_PortHandle);
  write("%FILE_NAME%: DSO5 completed transmission of packet with %d bytes.", packetSize);
}

// MHP callback function
ET_DSI2_MH_IndTxPktFinished(dword handle, long packetSize)
{
  MH_TxStopTrans(gDSO6_PortHandle);
  write("%FILE_NAME%: DSO6 completed transmission of packet with %d bytes.", packetSize);
}

// MHP callback function
ET_DSI3_MH_IndTxPktFinished(dword handle, long packetSize)
{
  MH_TxStopTrans(gDSO7_PortHandle);
  write("%FILE_NAME%: DSO7 completed transmission of packet with %d bytes.", packetSize);
}

// MHP callback function
ET_DSI1_MH_IndTxConnectionClosed(dword handle, long res)
{
  ReportErrorsToWrite (5, res);
}

// MHP callback function
ET_DSI2_MH_IndTxConnectionClosed(dword handle, long res)
{
  ReportErrorsToWrite (6, res);
}

// MHP callback function
ET_DSI3_MH_IndTxConnectionClosed(dword handle, long res)
{
  ReportErrorsToWrite (7, res);
}

ReportErrorsToWrite (long dsoNum, long res)
{
  switch (res)
  {
    case 0:     write("%FILE_NAME%: DSO%d Result (%d): OK", dsoNum, res);     break;
    case 1:     write("%FILE_NAME%: DSO%d Error (%d): Number of Send retries exceeded", dsoNum, res);          break;
    case 2:     write("%FILE_NAME%: DSO%d Error (%d): Number of Trans retries exceeded", dsoNum, res);         break;
    case 3:     write("%FILE_NAME%: DSO%d Error (%d): Number of End retries exceeded", dsoNum, res);           break;
    case 4:     write("%FILE_NAME%: DSO%d Error (%d): Number of Ready retries exceeded", dsoNum, res);         break;
    case 5:     write("%FILE_NAME%: DSO%d Error (%d): Number of Frame Retries exceeded", dsoNum, res);         break;
    case 6:     write("%FILE_NAME%: DSO%d Error (%d): Number of Receive retries execeeded", dsoNum, res);      break;
    case 10:    write("%FILE_NAME%: DSO%d Error (%d): Receive buffer could not be provided", dsoNum, res);     break;
    case 11:    write("%FILE_NAME%: DSO%d Error (%d): Connection rejected via higher priority", dsoNum, res);  break;
    case 13:    write("%FILE_NAME%: DSO%d Result (%d): Transmission terminated by receiver", dsoNum, res);     break;
    case 14:    write("%FILE_NAME%: DSO%d Result (%d): Transmission terminated by sender", dsoNum, res);       break;
    case 15:    write("%FILE_NAME%: DSO%d Error (%d): Transmission killed by sender", dsoNum, res);            break;
    case 16:    write("%FILE_NAME%: DSO%d Error (%d): Parameter out of range", dsoNum, res);                   break;
    default:    write("%FILE_NAME%: DSO%d Error (%d): Unknown error", dsoNum, res);                            break;
  }
}

on sysvar PM::Wakeup_Active
{
  if (0 == @this)
    return;
  setTimer(tWakeup, 1);
}