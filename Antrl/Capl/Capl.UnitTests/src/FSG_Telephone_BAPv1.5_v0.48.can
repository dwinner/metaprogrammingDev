/*@!Encoding:1252*/
includes
{
    #include "..\..\_DLL\latest_BAP_DLL.cin"

    #include "FCatDefs.cin"
    #include "PicServerInterface.cin"
}

variables
{
    char dbc_path[255] = "BAP\\_DBC\\BAP_only_MQB_MLBevo_v1.50.dbc";  //BAP_V9.04F.dbc";													
    char xml_path[255] = "BAP\\TelephoneSD_DF4x_FSG40\\XML\\BAP_SW17_TEL_FSG_Telefon_v1.0.xml";

    dword gBAP_Trace, gError_Trace, gMissedCalls_writeWindow;

    byte  gKl15=0;
    byte  gKlS=0;

    int   gdebug=0; //bap150 - debug

    //***********************************BAP-Buffer****************************
    const Requestbuffer_lines=100;
    const BAP_buffer_size=4100;

    int gBAP_Requestbufffer_status [Requestbuffer_lines];		//datalength
    int gBAP_Requestbufffer_BAPDataTyp [Requestbuffer_lines];	//data type

    dword gBAP_Indication[BAP_buffer_size];								//Bap-Indication-buffer
    dword gBAP_Request [Requestbuffer_lines] [BAP_buffer_size];			//ringbuffer for BAP-Request

    mstimer TaskTimer;					//real communication timer
    //timer test;

    //byte Unrockbar=0;

    int gwrite_requestbuffer_line=0;	//next free position
    int gstatus_requestbuffer=0;		//next position to send

    // adresses of output Windows
    dword gCombinedNumbers_writeWindow;
    dword gReceivedCalls_writeWindow;
    dword gDialedNumbers_writeWindow;
    //IssueList #24
    dword gPhonebook_writeWindow;
	dword gFavoriteList_writeWindow;

    char gstring_reserved [10]      ="reserved";
    char empty_string[3] = {0,0,0};

    dword gLastAcknowlegdeData[3] = {0, 0, 0};	 // acknowledge

//BAP Data Type 
const Bap_Void			=0;
const Bap_UInt8			=1;
const Bap_UInt16		=2;
const Bap_UInt32		=3;
const Bap_ByteSequence	=4;
const Bap_Error			=5;
const Bap_Acknowledge   =6;//ab bap150

//BAP request types
const DataSetGet_REQ	=0x00;
const DataSet_REQ		=0x01;
const DataGet_REQ		=0x02;
const Data_REQ			=0x03;
const Changed_REQ		=0x04;
const Start_REQ			=0x05;
const StartResult_REQ	=0x06;
const Abort_REQ			=0x07;
const Processing_REQ	=0x08;
const Result_REQ		=0x09;
const Invalid_REQ    	=0x1F;      // Interne Kennzeichnung fuer einen ungueltigen Request

//eigene Error-Definition
const Error_REQ=0x55;


//BAP indication types // NEU NUMMERIERT für BAP150!!
const Data_IND          =0x00;
const Reset_IND         =0x01;
const DataAck_IND	    =0x02;
const Result_IND		=0x03;
const Processing_IND	=0x04;
const Changed_IND   	=0x05;
const DataSetGet_IND	=0x06;
const DataSet_IND	    =0x07;
const DataGet_IND		=0x08;
const Ack_IND	        =0x09;
const Processing_CNF	=0x0a;
const Start_IND         =0x0b;
const StartResult_IND   =0x0c;
const Abort_IND         =0x0d;         
const Invalid_IND		=0x1F;      // Interne Kennzeichnung fuer eine ungueltige Indication

//eigene Error-Definition
const Error_IND=0x55;

// Debug 
  const DEBUG_ID=0x444;
  const DEBUG_CAN_CHANNEL=2;
  const DEBUG_SWITCH_ON=1;
  const DEBUG_SWITCH_OFF=0;

//Node Index
dword NODE_INDEX=0;
//*************************************************************************

//*********************************general*********************************
//***********time, date
mstimer agetimer;

char gtime [7];
char gdate [7];
char gsday[3], gsmonth[3], gsyear[3], gshour[3], gsmin[3], gssec[3];
byte gbday, gbmonth, gbyear, gbhour, gbmin, gbsec;
//********************

//Power on/off
byte gFSG_Telephone_PowerOnOff=0;
byte gBAP_Init=0;

byte gFSG_Schalter_OnOff = 0;
char gFSG_Schalter_OnOff_string[2][30]={"FSG Power off",
                                        "FSG Power on"};

mstimer Powerontimer;

const Power_off = 0x00;
const Power_on	= 0x01;
char gstring_FSG_Telephone_PowerOnOff [2][4]={"Off",
									"On"};

const FALSE	=0;
const TRUE	=1;
const FORWARD =0;
const BACKWARD =1;

const OFF=0;
const _ON=1;

const CALLSTACK=40;
const CALL_INFO_NUMBER_LENGTH=40;
const CALL_INFO_NAME_LENGTH=99;

char gempty_string [3]   ={0,0,0};

//IncomingCall
char gunknown [15] = "unknown";

mstimer incomingcall_changearraytimer;

byte gincomingcall=0;
byte gstatus_incomingcall_changearraytimer=0;
char gincomingcall_number [CALL_INFO_NUMBER_LENGTH];
char gincomingcall_name [CALL_INFO_NAME_LENGTH];
byte gincomingcall_numbertype=0;
byte gincomingcall_calltype=0;
byte gincomingcall_divert=0;

byte gmissedcall=0;

char greceivedcall_number [CALL_INFO_NUMBER_LENGTH];
char greceivedcall_name [CALL_INFO_NAME_LENGTH];
byte greceivedcall_numbertype=0;

//search number in phonebook
mstimer numbersearchphonebooktimer;
byte gnumbersearchphonebook=0;			//status of phonebook-number-search (0-no search active, 1-searching is still active, 2-searching finished)

//CallStacks and Phonebook
const PbNameLength=99;
const TelNumberLength=CALL_INFO_NUMBER_LENGTH;

//CallStacks
const NEWCALL=0;
const INSERT_ID=0x0f;
const CHANGE_ID=0xf0;
const DELETE_ID=0xff;

char gnumbertype [15][15]= { "unknown",
							"General",
							"Mobile",
							"Office",
							"Home", 
							"Fax",
							"Pager",
							"Car",
							"SIM",
                            "Main office",
                            "Main home",
                            "Cell office",
                            "Cell home",
                            "Fax office",
                            "Fax home"};


//Numbertypes
const UNKNOWN=0x00;
const general=0x01;
const MOBILE=0x02;
const office=0x03;
const chome=0x04;
const FAX=0x05;
const PAGER=0x06;
const CAR=0x07;
const SIM=0x08;
const MAIN_OFFICE=0x09;
const MAIN_HOME=0x0A;
const CELL_OFFICE=0x0B;
const CELL_HOME=0x0C;
const FAX_OFFICE=0x0D;
const FAX_HOME=0x0E;
//************************

//Panel control
dword gRGB_red;
dword gRGB_yellow;
dword gRGB_green;
dword gRGB_grey;
dword gRGB_white;

//LSG-IDs
const LSG_KLIMA		=0x01;
const LSG_KLIMA2	=0x02;
const LSG_KLIMA3	=0x16;
const LSG_OPS		=0x0A;
const LSG_RVC		=0x0B;
const LSG_TELEPHONE	=0x28;
const LSG_PHONEBOOK	=0x29;
const LSG_DVBT		=0x2C;
const LSG_RSE		=0x2E;
const LSG_MDI		=0x2F;
//***********************************************************************************************************************************

//*************************error codes*************************************
char gerror_codes_BCL [16][30] = {  "",
									"Media not accesible",
									"illegal sequence",
									"Sequenzfehler Segmentierung",
									"Timeout Segmentierung",
									"BCL not running",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									""};

char gerror_codes_BPL [16][30] = {  "",
									"Heartbeat Timeout",
									"Retry Timeout",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									""};

char gerror_codes_BAL [16][40] = {  "",
									"Falsche Adressierung",
									"Inkompatible Protokollversion",
									"Inkompatible Version Datenfestlegung",
									"Daten ungültig",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									"",
									""};
//Telephone
const Terror_unknownapllicationerror						=0x80;
const Terror_notsuccessful									=0x81;
const Terror_outofmemory									=0x82;
const Terror_datainvalid									=0x83;
const Terror_nouseractive									=0x88;
const Terror_nonetwork										=0x89;
const Terror_notsupportedbynetwork							=0x8A;
const Terror_notregisteredemergencycallonly					=0x8B;
const Terror_currentcodeinvalid								=0x8C;
const Terror_newcodeinvalid									=0x8D;
const Terror_nocoderequired									=0x8E;
const Terror_noredialnumber									=0x8F;
const Terror_activecallpresentdialing						=0x90;
const Terror_heldcallpresent								=0x91;
const Terror_activeandheldcallpresent						=0x92;
const Terror_nocall											=0x93;
const Terror_nocallrelatedtoCallID							=0x94;
const Terror_noactivecall									=0x95;
const Terror_nocallonhold									=0x96;
const Terror_noincomingwaitingcall							=0x97;
const Terror_noconference									=0x9A;
const Terror_nomemberofconference							=0x9B;
const Terror_maximumnumberformembersofconferencereached		=0x9C;
const Terror_functionnotsupportedforconferencecalls			=0x9D;
const Terror_phonebookdownloadinprogress					=0x9E;
const Terror_notsupportedbymobilephone						=0xA0;
const Terror_noheadsetconnected								=0xA1;
const Terror_nopairedheadset								=0xA2;
char gerror_codes_telephone[35][50] = { "unknown apllication error",
										"not successful",
										"out of memory",
										"data invalid",
										"",
										"",
										"",
										"",
										"no user active",
										"no network",
										"not supported by network",
										"not registered / emergency call only",
										"current code invalid",
										"new code invalid",
										"no code required",
										"no redialnumber",
										"active call present / dialing",
										"held call present",
										"active and held call present",
										"no call",
										"no call related to CallID",
										"no active call",
										"no call on hold",
										"no incoming / waiting call",
										"",
										"",
										"no conference",
										"no member of conference",
										"maximum number for members of conference reached",
										"function not supported for conference calls",
										"phonebook download in progress",
										"",
										"not supported by mobile phone",
										"no headset connected",
										"no paired headset"};
//*************************************************************************


//********************************************Global Function-ID's*******************************************************************
const FctID_GetAll				=0x01;
const FctID_BAP_Config			=0x02;
const FctID_FunctionList		=0x03;
const FctID_HeartBeat			=0x04;
const FctID_FSG_Setup			=0x0E;
const FctID_FSG_OperationState	=0x0F;
const FctID_MobilServiceSupport	=0x10;
//***********************************************************************************************************************************

//***********************************************************************************************************************************
//************************************************TELEPHONE**************************************************************************
//***********************************************************************************************************************************
//LSG-ID
const LSGID_Telephone=LSG_TELEPHONE;
//********************************************Function-ID's**************************************************************************

const FctID_ActiveUser			                    =0x11;
const FctID_RegisterState		                    =0x12;
const FctID_LockState			                    =0x13;
const FctID_NetworkProvider		                    =0x14;
const FctID_SignalQuality		                    =0x15;
const FctID_CallState			                    =0x16;
const FctID_CallInfo			                    =0x17;
const FctID_CallDurationSync                        =0x18;
const FctID_DisconnectReason                        =0x19;
const FctID_DialNumber			                    =0x1A;
const FctID_DialService                             =0x1B;
const FctID_ConfirmEmergencyCall                    =0x1C;
const FctID_HangupCall			                    =0x1D;
const FctID_AcceptCall			                    =0x1E;
const FctID_CallHold			                    =0x1F;
const FctID_ResumeCall			                    =0x20;
const FctID_HandsFreeOnOff		                    =0x21;
const FctID_MicroMuteOnOff	                    	=0x22;
const FctID_MPReleaseActiveCallAcceptWaitingCall	=0x23;
const FctID_MPSwap									=0x24;
const FctID_MPCallHoldAcceptWaitingCall				=0x25;
const FctID_MPReleaseAllCallsAcceptWaitingCall		=0x26;
const FctID_MPSetWaitingCallOnHold                  =0x27;
const FctID_CCJoin									=0x28;
const FctID_CCSplit									=0x29;
const FctID_Keypad									=0x2A;
const FctID_MobileBatteryLevel                      =0x2B;
const FctID_DataConnectionIndication                =0x2C;
const FctID_MissedCallIndication                    =0x2D;
const FctID_MissedCalls                             =0x2E;
const FctID_ReceivedCalls                           =0x2F;
const FctID_DialedNumbers                           =0x30;
const FctID_CombinedNumbers                         =0x31;
const FctID_CallStackDeleteAll                      =0x32;
const FctID_PbState                                 =0x33;
const FctID_Phonebook                               =0x34;
const FctID_PbSpeller                               =0x35;
const FctID_GetNextListPos                          =0x36;
const FctID_SMSState                                =0x37;
const FctID_RingToneMuteOnOff                       =0x38;
const FctID_AutomaticRedial                         =0x39;
//IssueList #16
const FctID_AutomaticRedialExtInfo                  =0x3A;

//IssueList #206
const FctID_SupportedServiceNumbers                 =0x3B;
const FctID_FavoriteList                            =0x3C;

//alte FctIDs
const FctID_UserList		                    	=0xf5;
const FctID_PhoneEnable	                         	=0xf6;
const FctID_NetInfo	                       		    =0xf7;
const FctID_MPReleaseActiveCallAcceptHeldCall		=0xfB;
const FctID_MPExplicitCallTransfer				    =0xfC;
const FctID_PhoneOnOff							    =0xfD;
const FctID_RestoreFactorySettings			    	=0xff;
//***********************************************************************************************************************************

//************************************************properties*************************************************************************
//***********************************************************************************************************************************

//*****************FunctionList********************************************
byte gFunctionListModified=0;

byte gFunctionList0=0;
byte gFunctionList1=0;
byte gFunctionList2=0;
byte gFunctionList3=0;
byte gFunctionList4=0;
byte gFunctionList5=0;
byte gFunctionList6=0;
byte gFunctionList7=0;

char gstring_FunctionListModified [2][30]={ "generated by XML-File",
											"manually configured"};
//*************************************************************************

//**************FSG_Setup*****************************************
byte gPhoneCharacteristics=0;
    byte gSIMCardReader=0;
    byte gCableConnection=0;
    byte gHFPConnection=0;
    byte gRSAPConnection=0;
    byte gAppleLinkConnection=0;
    byte gGoogleLinkConnection=0;
    byte gBaiduConnection=0;

byte gMobileConnectionType=0;
const NO_CONNECTION             =0x00;
const INTERNAL_SIM_CARD_READER  =0x01;
const CABLE_CONNECTION          =0x02;
const HANDS_FREE_PROFILE        =0x03;
const REMOTE_SIM_ACCESS_PROFILE =0x04;
const APPLELINK_CONNECTION      =0x05;
const GOOGLELINK_CONNECTION     =0x06;
const BAIDULINK_CONNECTION      =0x07;

//*************************************************************************

//**************FSG_OperationState********************************
byte gOP_State=0;

byte gTel_State=0;

const PhoneInitilisation  =0x00;
const PhoneModuleOff			=0x05;
const PhoneModuleOn				=0x07;
const MobileOn					=0x0F;

byte gPrivacyMode=0;
byte gPrivacyModeBit=0;
byte gEnhancedPrivacyMode=0;

//*************************************************************************

//*****************MobilServiceSupport*************************************
byte gMobilServiceSupport0=0;
byte gMobilServiceSupport1=0;
byte gMobilServiceSupport2=0;
byte gMobilServiceSupport3=0;
byte gMobilServiceSupport4=0;
byte gMobilServiceSupport5=0;
byte gMobilServiceSupport6=0;
byte gMobilServiceSupport7=0;
//*************************************************************************

//***************************ActiveUser***********************************
char gSIMSerial [40];
char gSerialNumber [40];
char gUserName [50];

//*************************************************************************

//************RegisterState***************************************
mstimer registerstatetimer;
//IssueList #69
msTimer registerstatetimerDelay;

int gtime_registerstatetimer=2000;
byte gRegisterState=0;

const notregisteredandnotsearching=0x00;
const registered=0x01;
const notregisterdandsearching=0x02;
const registrationdenied=0x03;
const registeredandroaming=0x04;
const registeredandroamingalternative=0x05;

byte gNetworkType=0;

const UNKNOWN_NT    =0x00;
const GSM           =0x01;
const UMTS          =0x02;
const CDMA          =0x03;

byte gPacketDataNetworkType=0;

const NO_DATA_SERVICE   =0x00;
const GSM_GPRS          =0x01;
const GSM_EDGE          =0x02;
const HSDPA             =0x03;
const HSUPA             =0x04;

//*************************************************************************

//***************************LockState************************************
byte gLockState=0;
byte gPIN_attempts=3;

const nolock=0x00;
const requirePIN=0x01;
const requirePIN2=0x02;
const PINblockedrequirePUK=0x03;
const PIN2blockedrequirePUK2=0x04;
const PUKblocked=0x05;
const PUK2blocked=0x06;
const keypadblocked=0x07;
const SIMnotavailable=0x08;
const PINinvalid=0x09;
const PIN2invalid=0x0A;
const SIMnotfunctional=0x0B;
const SIMnotready=0x0C;
const requirelockcode=0x0D;
const requiresecuritycode=0x0E;
const securitycodeblocked=0x0F;

//*************************************************************************

//************NetworkProvider*************************************
mstimer nonetworktimer;
//changes from Jöran Karl (28.03.2012)
const NETWORKPROVIDER_STRING_LENGTH=40;
char gstring_networkprovider [6] [20] ={{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
										"D1",
										"D2",
										"E-Plus",
										"O2",
                                        "Test-Mobile"};
//end of changes from Jöran Karl (28.03.2012)
char gNetworkProvider [20];
byte gNetworkProviderStatus=0;

byte gNetworkProviderState=0;
//changes from Jöran Karl (28.03.2012)
char gNetworkProviderName [NETWORKPROVIDER_STRING_LENGTH];
byte gServiceProviderState=0;
//changes from Jöran Karl (28.03.2012)
char gServiceProviderName [NETWORKPROVIDER_STRING_LENGTH];

//*************************************************************************

//************SignalQuality***************************************
timer signalqualitytimer;
byte gSignalQuality=0;
//*************************************************************************

//************property NetInfo***************************************
byte gNetInfoCallDivert=0;
byte gNetInfoCiphering=0;
//*************************************************************************

//*******property CallState************************************************
byte gCallState [7] = {0,0,0,0,0,0,0};
byte gCallType [7] = {0,0,0,0,0,0,0};
byte gCallOptions [7] ={0,0,0,0,0,0,0};
byte gCallIncomingDiverted [7] ={0,0,0,0,0,0,0};//gCallDivert
byte gCallOutgoingDiverted_eCallConfirmationPending [8] ={0,0,0,0,0,0,0,0};
// changes from Jan Swoboda (01.03.2012)
byte gCallStateRequestPending = 0;

//CallState
const idle=0x00;
const ringing_waiting=0x01;
const active=0x02;
const dialing=0x03;
const disconnecting=0x04;
const onhold=0x05;
const connected_CIB=0x06;
const REMOTE_SIDE_BUSY=0x07;
//IssueList #48
//const AUTOMATIC_REDIAL_ACTIVE=0x08;
//const INCOMING_ON_HOLD=0x09;
const INCOMING_ON_HOLD=0x08;

char gstring_callstate [10] [24] = {	"idle",
									"ringing waiting",
									"active",
									"dialing",
									"disconnecting",
									"onhold",
									"connected CIB",
                                    "remote side busy",
                                    "automatic redial active",
                                    "incoming on hold"};
//CallType
const unknowncalltype=0x00;
const SINGLE_VOICE_CALL=0x01;
const datacall=0x02;
const faxcall=0x03;
const emergencycall=0x04;
const CONFERENCE_VOICE_CALL=0x05;
const infocall=0x06;
const servicecall=0x07;

char gstring_calltype [8] [22] = {	"unknown call type",
									"single voice call",
									"data call",
									"fax call",
									"emergency call",
									"conference voice call",
									"info call",
									"service call"};
//CallOptions
const byte ACCEPT_CALL   =0x01;  //Bit 0
const byte MP_CHAWC      =0x02;  //Bit 1
const byte MP_RACAWC     =0x04;  //Bit 2
const byte CALL_HOLD     =0x08;  //Bit 3
const byte RESUME_CALL   =0x10;  //Bit 4
const byte MP_SWAP       =0x20;  //Bit 5
const byte CC_JOIN       =0x40;  //Bit 6
const byte CC_SPLIT      =0x80;  //Bit 7

char gstring_CallDivert [2] [10] = {"Off",
									"On"};
//CallActivity
byte gCallActivity=0;
const NOCALL=0x00;
const SINGLECALL=0x01;
const MULTIPARTYCALL=0x02;

char gstring_callactivity [3] [20] = {"no call",
									"singel call",
									"multiparty call"};
//*************************************************************************

//*******************property CallInfo****************************************
mstimer dialnumber_changearraytimer;
byte gstatus_dialnumber_changearraytimer=0;

const CALLINFO=7;
//const CALL_INFO_NAME_LENGTH=100;      //already defined in general
//const CALL_INFO_NUMBER_LENGTH=41;     //already defined in general

char gCallInfo_PbName [CALLINFO] [CALL_INFO_NAME_LENGTH];
//IssueList #206
byte gCallInfo_PbName_hex[CALLINFO][CALL_INFO_NAME_LENGTH];

char gCallInfo_TelNumber [CALLINFO] [CALL_INFO_NUMBER_LENGTH];
byte gCallInfo_Category [CALLINFO];
//*************************************************************************

//*********DisconnectReason**********************************************
byte gDisconnectReason=0;

//DisconnectReasons
const regulardisconnecting=0x00;
const noline=0x01;
const connectedline_busy=0x02;
const systembusy=0x03;
const linebusy=0x04;
const numbernotassigned=0x05;
const numbernotrechable=0x06;
const networkfailure=0x07;
const callbarringactive=0x08;
const usernotresponding=0x09;
const callreject=0x0a;
const numberchanged=0x0b;
const numberinvalidincomplete=0x0c;
const servicenotavaillable=0x0d;
const noinfoavailable=0x0e; 

//*************************************************************************

//**************property CallDurationSync**********************************
word gTimeStampCall [7];
//*************************************************************************

//*********property HandsFreeOnOff*****************************************
mstimer handsfreeresettimer;

byte gHandsFreeOnOff=0;
byte gheadset_available=0;
//*************************************************************************

//*********property MicroMuteOnOff*****************************************
byte gMicroMuteOnOff=0;
//*************************************************************************

//*********property Keypad*************************************************
byte gKeypadStatus=0;
mstimer KeypadTimer;
const KeypadTimerTime=1000;
byte gKeypadTimer_status=0;
const INFO=0x02;
const SERVICE=0x80;
//*************************************************************************

//*************MobileBatteryLevel********************************
timer MobileBatteryLevelTimer;
byte gChargeLevelMobile1=0;
byte gChargeLevelMobile2=0;
byte gChargeLevelHandset1=0;
byte gChargeLevelHandset2=0;
byte gWarningLevel=0;
const LOW_CHARGE_LEVEL=10;
//***************************************************************

//**************DataConnectionIndication*************************
timer DataConnectionIndicationTimer;
const TESTRATE=12345;
byte gConnectionIndication=0;
dword gDataVolumeUplink=0;
dword gDataVolumeDownlink=0;
//***************************************************************

//**************MissedCallIndication******************************
word gMissedCalls=0;
word gMissedNumbers=0;
//****************************************************************

//************************PbState*********************************
byte gDownLoadState=0;
byte gDownLoadState_old=0;
word gPbEntriesUHV=0;
word gPbEntriesUHV_old=0;

const NO_PHONEBOOK_AVAILABLE=0x00;
const CURRENTLY_BEING_LOADED=0x01;
const COMPLETELY_LOADED=0x02;
const INCOMPLETELY_LOADED=0x03;
const DOWNLOAD_ABORTED=0x04;

char gstring_DownLoadState [5][30]= {"no phone book available",
									"currently beeing loaded",
									"completely loaded",
									"incompletely loaded",
									"download aborted"};
//*************************************************************************

//************property SMSState********************************************
byte gSIMReady=0;
byte gStorageState=0;
word gNumberOfNewSMS=0;
//************************************************************************

//************ RingToneMuteOnOff *****************************************
byte gRingToneMuteOnOff = 0;
byte gRingTone_unmute = 0;
byte gRingTone_incoming_callid = 0xff;
//************************************************************************

//*************AutomaticRedial********************************************
byte gAutomaticRedialState = 0;
char gAutomaticRedialState_s[2][30] = {"not active",
									   "active"};
//************************************************************************

//************************************************method's***************************************************************************
//***********************************************************************************************************************************
//Global Method_Result values
const SUCCESSFUL            =0x00;
const NOT_SUCCESSFUL        =0x01;
const ABORT_SUCCESSFUL      =0x02;
const ABORT_NOT_SUCCESSFUL  =0x03;
//********************method PhoneEnable***********************************
char gPINCodeUHV [9]= "1234";
char gPINCodeRNS [20];

const PIN=0x01;
//*************************************************************************

//**************method dialnumber******************************************
mstimer checknetworktimer;
mstimer dialtimer;
mstimer busy_hangup_timer;

//IssueList #160 MR49588 -s
//addition of assumed 5 second time out for confirmPending flag check
timer checkEcallConfirmPending;

//IssueList #160 MR49588 -e

//IssueList #104
//changes from Jan Swoboda 21.06.2012
mstimer dialnumber_result_timer;

const DIAL_NUMBER_NAME_LENGTH=100;  //correct value: 150;

char gDialNumber [CALL_INFO_NUMBER_LENGTH];			//number
char gDialNumber_name [DIAL_NUMBER_NAME_LENGTH];	//PbName of dialed Number
byte gdialnumber_numbertype=0;	//numbertype of dialed number
byte gDialNumber_Result=0;

//IssueList #26
int gDialbuttonOn=0;
byte gFirstPress = 0;

char police [4] = "110";
char ambulance [4] = "112";
char emergency_NAR [4] = "911";
char cerveza [3] = "08";
char info [6] = "01802";
char service [6] = "01902";
char info_pbname [CALL_INFO_NAME_LENGTH] = "Volkswagen Information Center";
char service_pbname [CALL_INFO_NAME_LENGTH] = "Volkswagen Service Center";
byte gcallID=0xff;				//Call-ID of this call, which is currently active/dialing, 0xff=no call is active
byte gemergencycall=0;			//flag for emergency call (0-no emergency call, 1-emergency call & registered, 2-emergency call & not registered, but SIM OK, 3-emergency call & not registered & no SIM)
byte gDialNumber_status=0;		//flag for status of the method dial number (0=no aktiv, 1=aktiv)

const gtime_checknetworktimer=500;
const free=0;
const busy=1;
//Method_Result values
const NS_NUMBER_INVALID        =0x04;
const NS_NO_NETWORK            =0x05;
const NS_NOT_REG_EC_ONLY       =0x0B;

byte gConfirmCall = 0; // indicate if call has to be confirmed
byte gCallStartedFromASG = 0;
//*************************************************************************

//**************method dialservice*****************************************
byte gDialService_type = 0xff; // the type of call: 0x00: voice mailbox, 0x01: info call, 0x02: service call, 0x03: emergency call 
int gDialService_enabled = 1; // method dial service enabled
int gDialService_status = 0; // method dial service running
char gDialService_ServiceNumbers[4][CALL_INFO_NUMBER_LENGTH] = { "0012345678",   // voice mailbox
                                                           "0112345678",   // info call
                                                           "0212345678",   // service call
                                                           "0312345678" }; // emergency call
char gDialService_ServiceNames[4][DIAL_NUMBER_NAME_LENGTH] = { "Voice Mailbox",
                                                              "Info Call",
                                                              "Service Call",
                                                              "Emergency Call"};
byte gDialService_Result=0;                 //"0x00 successful",
                                            //"0x01 not successful",
                                            //"0x02 abort successful",
                                            //"abort not successful",
                                            //"not successful - service not available",
                                            //"not successful - no network",
                                            //"not successful - not supported by network",
                                            //"not successful - not supported by mobile",
                                            //"(reserved)",
                                            //"(reserved)",
                                            //"not successful - confirm emergency call",
                                            //"(reserved)",
                                            //"not successful - automatic redial active"

//*************************************************************************

//************************ method ConfirmEmergencyCall ******************** 
byte gConfirmErmergencyCall_result = 0;
const ECALL_CONTROL_CONFIRM = 0x00;
const ECALL_CONTROL_CANCEL = 0x01;
//*************************************************************************

//**************method hangupcall******************************************
byte ghangupcall_status=0;	//flag for status of the method hangup call (0=not activ, 1=activ)
mstimer	disconnectingtimer;
mstimer	disconnectingtimer2;
//changes from Jöran Karl (28.03.2012)
mstimer DisconnectReason_Timer;
//IssueList #156 - Aghil: Changed from 2000 to 1500
//const disconnecttime=2000;
const disconnecttime=1500; 
//changes from Jöran Karl (28.03.2012)
const disconnectreasontime=500;

//CallID
byte gHangupCall_CallID=0;
const ALL_ACTIVE_CALLS	    	=0xFC;
const ALL_HELD_CALLS			=0xFD;
const ALL_ACTIVE_AND_HELD_CALLS	=0xFE;
const ALL_CALLS			    	=0xFF;

byte gHangupCall_Result=0;

//*************************************************************************

//**************method acceptcall******************************************
byte gacceptcall_status=0;	//flag for status of the method accept call (0=not activ, 1=activ)
mstimer acceptcallTimer;
const acceptcallTimerTime=500;

byte gAcceptCall_Result=0;
const NOT_SUCCESSFUL_NO_CALL=0x04;
//*************************************************************************

//**************method CallHold********************************************
byte gCallHold_status=0;	//flag for status of the method CallHold (0=not activ, 1=activ)
mstimer CallHoldTimer;
const CallHoldTimerTime=500;
byte gCallHold_Result=0;
//*************************************************************************

//**************method ResumeCall******************************************
byte gResumeCall_status=0;	//flag for status of the method ResumeCAll (0=not activ, 1=activ)
mstimer ResumeCallTimer;
const ResumeCallTimerTime=500;
byte gResumeCall_Result=0;
//*************************************************************************

//**************method MPSwap**********************************************
byte gMPSwap_status=0;	//flag for status of the method MPSwap (0=not activ, 1=activ)
mstimer MPSwapTimer;
const MPSwapTimerTime=500;
byte gMPSwap_Result=0;
//*************************************************************************

//**************method CCJoin**********************************************
byte gCCJoin_status=0;	//flag for status of the method CCJoin (0=not activ, 1=activ)
mstimer CCJoinTimer;
const CCJoinTimerTime=500;
byte gCCJoin_Result=0;
//*************************************************************************

//**************method CCSplit*********************************************
byte gCCSplit_status=0;	//flag for status of the method CCSplit (0=not activ, 1=activ)
byte gCCSplitCallID=0xff;
mstimer CCSplitTimer;
const CCSplitTimerTime=500;
byte gCCSplit_Result=0;
//*************************************************************************

//**************method MPRACAWC********************************************
byte gMPRACAWC_status=0;	//flag for status of the method CCSplit (0=not activ, 1=activ)
mstimer MPRACAWCTimer;
const MPRACAWCTimerTime=750;
byte gMPRACAWC_Result=0;
//*************************************************************************

//**************method MPRAllCAWC********************************************
byte gMPRAllCAWC_status=0;	//flag for status of the method CCSplit (0=not activ, 1=activ)
mstimer MPRAllCAWCTimer;
const MPRAllCAWCTimerTime=750;
byte gMPRAllCAWC_Result=0;
//*************************************************************************

//**************method MPCHAWC********************************************
byte gMPCHAWC_status=0;	//flag for status of the method CCSplit (0=not activ, 1=activ)
mstimer MPCHAWCTimer;
const MPCHAWCTimerTime=750;
byte gMPCHAWC_Result=0;
//*************************************************************************

//**************method MPSWCOH********************************************
byte gMPSWCOH_status=0;	//flag for status of the method CCSplit (0=not activ, 1=activ)
mstimer MPSWCOHTimer;
const MPSWCOHTimerTime=750;
byte gMPSWCOH_Result=0;
//*************************************************************************

//**************method PhoneOnOff******************************************
byte gPhoneOnOff_status=0;	//flag for status of the method RestoreFactorySettings (0=not activ, 1=activ)
byte gPhoneOnOff_mode=0;
mstimer PhoneOnOffTimer;
const PhoneOnOffTimerTime=500;
const SHUTDOWN=0;
const STARTUP=1;
//*************************************************************************

//**************method RestoreFactorySettings******************************
byte gRestoreFactorySettings_status=0;	//flag for status of the method RestoreFactorySettings (0=not activ, 1=activ)
mstimer RestoreFactorySettingsTimer;
const RestoreFactorySettingsTimerTime=500;
//*************************************************************************

//***********************************************************************************************************************************
//***********************************************************************************************************************************
//***********************************************************************************************************************************



//***********************************************************************************************************************************
//************************************************PHONEBOOK**************************************************************************
//***********************************************************************************************************************************
//LSG-ID
const LSGID_Phonebook=LSG_PHONEBOOK;
//********************************************Function-ID's**************************************************************************
//const FctID_MissedCallIndication	=0xe1;
//const FctID_MissedCalls			=0xe2;
//const FctID_ReceivedCalls			=0xe3;
//const FctID_DialedNumbers			=0xe4;
//const FctID_CallStackDeleteAll	=0xe5;
//const FctID_PbState				=0xe6;
//const FctID_Phonebook				=0xe7;
//const FctID_PbSpeller				=0xe8;
const FctID_PbStartDownload			=0xeA;
//************************************************************************************************************************************

//************************************************properties*************************************************************************
//***********************************************************************************************************************************

//************************************************method's***************************************************************************
//***********************************************************************************************************************************

//************method CallStackDeleteAll************************************
byte gCallStackDeleteAll_status=0;
byte gCallStackDeleteAllStorage=0;
mstimer CallStackDeleteAllTimer;
const CallStackDeleteAllTimerTime=500;
//*************************************************************************

//**************method PbStartDownload*************************************
timer PbDownload_timer;
mstimer PbStartDownload_timer;
mstimer PbDownloadAborted_timer;
const gPbDownloadtime=5;
byte gPbStartDownload_status=0;	//flag for status of the method PbStartDownload (0=no aktiv, 1=aktiv)
//*************************************************************************

//************method PbSpeller*********************************************
byte gSearchMode=0;
const PbSpeller_MatchSpeller = 0;
const PbSpeller_NextCharacter = 1;
const PbSpeller_PreviousCharacter = 2;
char gSearchString [CALL_INFO_NAME_LENGTH];	

byte gPbSpeller_Result = 0;
word gMatchingEntries = 0;
word gFoundPos = 0;
//*************************************************************************

//************method GetNextListPos****************************************
word gGetNextListPos_currentPos = 0;
word gGetNextListPos_nextPos = 0;
word gGetNextListPos_absoluteListPos = 0;
int gGetNextListPos_Offset = 0; 
byte gGetNextListPos_ListType = 0x00; // 0x00: phone book, 0x01..0xff: reserved
byte gGetNextListPos_Result = 0x00; 
mstimer GetNextListPos_timer;
byte gGetNextListPos_req = 0x00;
byte gGetNextListPos_abort_active = 0x00;
//changes from Jöran Karl (28.03.2012)
word gGetNextListPos_Time = 100;
//*************************************************************************

//IssueList #16
//************method AutomaticRedialExtInfo********************************
word gAutomaticRedialTimeStamp;
int gAutomaticRedialCategory;
msTimer updateEnvRedialTimeStamp;

char gAutoRedialExtInfo_Number [CALL_INFO_NUMBER_LENGTH];			//number
char gAutoRedialExtInfo_Name [DIAL_NUMBER_NAME_LENGTH];
//*************************************************************************


//************************************************array's****************************************************************************
//***********************************************************************************************************************************

//values for reading *.csv-file
const TEL_DEFAULT_LIST  =0;
const TEL_EXTERNAL_LIST =1;
//IssueList #24
//const TEL_FILENAME_SIZE =50;
const TEL_FILENAME_SIZE =100;

const TEL_BUFFERSIZE    =0xFFFF;
const TEL_TEXTLENGTH    =100;

//**************array CallStack MissedCalls******************************
char gMissedCalls_CSV_filename[TEL_FILENAME_SIZE];

byte gmissedcalls_AutoOnOff=OFF;
char gmissedcalls_AutoOnOff_s [2][30]= {"Off / manual StatusArray",
									"On / automatic StatusArray"};

byte gmissedcalls_ASG_ID;
byte gmissedcalls_TAID;
byte gmissedcalls_TotalNumListElements;
word gmissedcalls_pos [CALLSTACK];
char gmissedcalls_pbname [CALLSTACK][CALL_INFO_NAME_LENGTH];
char gmissedcalls_telnumber [CALLSTACK][CALL_INFO_NUMBER_LENGTH];
byte gmissedcalls_numbertype [CALLSTACK];
char gmissedcalls_date [CALLSTACK][7];
char gmissedcalls_time [CALLSTACK][7];

char gmissedcallname_new [CALL_INFO_NAME_LENGTH];
byte gmissedcallnumbertype_new;
char gmissedcallnumber_new[CALL_INFO_NUMBER_LENGTH];

byte gmissedcall_DeleteStatus=0;
byte gmissedcall_DateTime=0;

mstimer MissedCallsDeleteEntryTimer;
//*************************************************************************

//**************array CallStack ReceivedCalls******************************
byte greceivedcalls_ASG_ID;
byte greceivedcalls_TAID;
byte greceivedcalls_TotalNumListElements;
word greceivedcalls_pos [CALLSTACK];
char greceivedcalls_pbname [CALLSTACK][CALL_INFO_NAME_LENGTH];
char greceivedcalls_telnumber [CALLSTACK][CALL_INFO_NUMBER_LENGTH];
char greceivedcalls_date [CALLSTACK][7];
char greceivedcalls_time [CALLSTACK][7];
byte greceivedcalls_numbertype [CALLSTACK];

char greceivedcallnumber_new[CALL_INFO_NUMBER_LENGTH];
char greceivedcallname_new [CALL_INFO_NAME_LENGTH];
byte greceivedcallnumbertype_new;
byte greceivedcall_DeleteStatus=0;
byte greceivedcall_DateTime=0;

mstimer ReceivedCallsDeleteEntryTimer;
//*************************************************************************

//**************array CallStack DialedNumbers******************************
byte gdialedcalls_ASG_ID;
byte gdialedcalls_TAID;
byte gdialedcalls_TotalNumListElements;
word gdialedcalls_pos [CALLSTACK];
char gdialednumbers_pbname [CALLSTACK][CALL_INFO_NAME_LENGTH];
char gdialednumbers_telnumber [CALLSTACK][CALL_INFO_NUMBER_LENGTH];
char gdialednumbers_date [CALLSTACK][7];
char gdialednumbers_time [CALLSTACK][7];
byte gdialednumbers_numbertype [CALLSTACK];

char gdialednumber_new[CALL_INFO_NUMBER_LENGTH];
char gdialednumbername_new [CALL_INFO_NAME_LENGTH];
byte gdialednumbersnumbertype_new;
byte gdialednumbers_DeleteStatus=0;
byte gdialednumbers_DateTime=0;

mstimer DialedNumbersDeleteEntryTimer;
//*************************************************************************

//**************array Phonebook********************************************
char gPhonebook_CSV_filename[TEL_FILENAME_SIZE];

byte gPhonebook_DeleteStatus=0;

byte gPhonebook_AutoOnOff=OFF;
char gPhonebook_AutoOnOff_s [2][30]= {"Off / manual StatusArray",
									"On / automatic StatusArray"};
const PHONEBOOK_ENTRIES=1000;
const PHONEBOOK_PBNAME_LENGTH       =CALL_INFO_NAME_LENGTH;
const PHONEBOOK_TELNUMBER_LENGTH    =CALL_INFO_NUMBER_LENGTH;
//changes from Jöran Karl (28.03.2012)
const PHONEBOOK_N_MAX               = 10;

byte gPhonebook_ASG_ID;
byte gPhonebook_TAID;
word gPhonebook_TotalNumListElements;

word gPhonebook_Pos [PHONEBOOK_ENTRIES];						//ID des Phonebook-Eintrages
char gPhonebook_PbName [PHONEBOOK_ENTRIES][PHONEBOOK_PBNAME_LENGTH];
byte gPhonebook_Storage [PHONEBOOK_ENTRIES];
byte gPhonebook_AnyVoiceTag [PHONEBOOK_ENTRIES];				//array for a variable, which indicates, if there is an voice tag for any phone number of this phonebook entry available
byte gPhonebook_TelNumberQuantity [PHONEBOOK_ENTRIES];		//array for quantity of telnumbers of an entry in phonebook

//changes from Jöran Karl (28.03.2012)
char gPhonebook_TelNumbers [PHONEBOOK_N_MAX][PHONEBOOK_ENTRIES][PHONEBOOK_TELNUMBER_LENGTH];			//array for telnumber 1 of an entry in phonebook

byte gPhonebook_VoiceTags [PHONEBOOK_N_MAX][PHONEBOOK_ENTRIES];				//array for availabe voice tag of telnumber 1 of an entry in phonebook

byte gPhonebook_NumberTypes [PHONEBOOK_N_MAX][PHONEBOOK_ENTRIES];				//array for numbertype of telnumber 1 of an entry in phonebook

byte gPhonebook_AddressIndication[PHONEBOOK_ENTRIES];

//IssueList #24
byte gPhonebook_ListEntryValidInformation [PHONEBOOK_ENTRIES]; //indicates the existence of the "record element" 
byte gPhonebook_Reserved [PHONEBOOK_ENTRIES];	

char gphonebook_number[CALL_INFO_NUMBER_LENGTH];					//variable for name-/ numbersearch in phonebook
char gphonebook_name [CALL_INFO_NAME_LENGTH];					//variable for name-/ numbersearch in phonebook
byte gphonebook_numbertype;		                    			//variable for name-/ numbersearch in phonebook



//**************array CombinedNumbers**************************************

    byte gCombinedNumbers_ASGID    =0;
    byte gCombinedNumbers_TAID     =0;

    word gCombinedNumbers_TotalNumListElements =0;

    const TEL_COMBINEDNUMBERS_ENTRIES =0xFF;

    word gCombinedNumbers_Pos [TEL_COMBINEDNUMBERS_ENTRIES];

    const TEL_COMBINEDNUMBERS_PBNAME_LENGTH =100;
    char gCombinedNumbers_PbName [TEL_COMBINEDNUMBERS_ENTRIES][TEL_COMBINEDNUMBERS_PBNAME_LENGTH];

    const TEL_COMBINEDNUMBERS_UNKNOWNCALL    =0x00;
    const TEL_COMBINEDNUMBERS_MISSEDCALL     =0x01;
    const TEL_COMBINEDNUMBERS_RECEIVEDCALL   =0x02;
    const TEL_COMBINEDNUMBERS_DIALEDNUMBER   =0x03;
    byte gCombinedNumbers_CallMode [TEL_COMBINEDNUMBERS_ENTRIES];
    char gCombinedNumbers_CallMode_s[4][50] ={  "unknown call mode",
                                                "missed call",
                                                "received call",
                                                "dialed number"};
    
    const TEL_COMBINEDNUMBERS_UNKNOWN     =0x00;
    const TEL_COMBINEDNUMBERS_GENERAL     =0x01;
    const TEL_COMBINEDNUMBERS_MOBILE      =0x02;
    const TEL_COMBINEDNUMBERS_OFFICE      =0x03;
    const TEL_COMBINEDNUMBERS_HOME        =0x04;
    const TEL_COMBINEDNUMBERS_FAX         =0x05;
    const TEL_COMBINEDNUMBERS_PAGER       =0x06;
    const TEL_COMBINEDNUMBERS_CAR         =0x07;
    const TEL_COMBINEDNUMBERS_SIM         =0x08;
    const TEL_COMBINEDNUMBERS_MAINOFFICE  =0x09;
    const TEL_COMBINEDNUMBERS_MAINHOME    =0x0A;
    const TEL_COMBINEDNUMBERS_CELLOFFICE  =0x0B;
    const TEL_COMBINEDNUMBERS_CELLHOME    =0x0C;
    const TEL_COMBINEDNUMBERS_FAXOFFICE   =0x0D;
    const TEL_COMBINEDNUMBERS_FAXHOME     =0x0E;
    byte gCombinedNumbers_NumberType[TEL_COMBINEDNUMBERS_ENTRIES];
    char gCombinedNumbers_NumberType_s[15][50] ={ "unknown NumberType",
                                                "General",
                                                "Mobile",
                                                "Office",
                                                "Home",
                                                "Fax",
                                                "Pager",
                                                "Car",
                                                "SIM",
                                                "Main office",
                                                "Main home",
                                                "Cell office",
                                                "Cell home",
                                                "Fax office",
                                                "Fax home"};													
                                                
    const TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH =41;
    char gCombinedNumbers_TelNumber [TEL_COMBINEDNUMBERS_ENTRIES][TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH];
    
    byte gCombinedNumbers_day [TEL_COMBINEDNUMBERS_ENTRIES];

    byte gCombinedNumbers_month [TEL_COMBINEDNUMBERS_ENTRIES];
    
    byte gCombinedNumbers_year [TEL_COMBINEDNUMBERS_ENTRIES];
    
    byte gCombinedNumbers_hour [TEL_COMBINEDNUMBERS_ENTRIES];
    
    byte gCombinedNumbers_minute [TEL_COMBINEDNUMBERS_ENTRIES];
    
    byte gCombinedNumbers_second [TEL_COMBINEDNUMBERS_ENTRIES]; 
    
    byte gCombinedNumbers_ListEntryValidInformation [TEL_COMBINEDNUMBERS_ENTRIES]; //indicates the existence of the "record element" 
    
    byte gCombinedNumbers_sum =0;
       
    char gCombinedNumbers_CSV_filename[TEL_FILENAME_SIZE];

//**************array ReceivedCalls**************************************

    byte gReceivedCalls_ASGID    =0;
    byte gReceivedCalls_TAID     =0;

    word gReceivedCalls_TotalNumListElements =0;

    const TEL_RECEIVEDCALLS_ENTRIES =0xFF;

    word gReceivedCalls_Pos [TEL_RECEIVEDCALLS_ENTRIES];

    const TEL_RECEIVEDCALLS_PBNAME_LENGTH =100;
    char gReceivedCalls_PbName [TEL_RECEIVEDCALLS_ENTRIES][TEL_RECEIVEDCALLS_PBNAME_LENGTH];

    const TEL_RECEIVEDCALLS_UNKNOWN     =0x00;
    const TEL_RECEIVEDCALLS_GENERAL     =0x01;
    const TEL_RECEIVEDCALLS_MOBILE      =0x02;
    const TEL_RECEIVEDCALLS_OFFICE      =0x03;
    const TEL_RECEIVEDCALLS_HOME        =0x04;
    const TEL_RECEIVEDCALLS_FAX         =0x05;
    const TEL_RECEIVEDCALLS_PAGER       =0x06;
    const TEL_RECEIVEDCALLS_CAR         =0x07;
    const TEL_RECEIVEDCALLS_SIM         =0x08;
    const TEL_RECEIVEDCALLS_MAINOFFICE  =0x09;
    const TEL_RECEIVEDCALLS_MAINHOME    =0x0A;
    const TEL_RECEIVEDCALLS_CELLOFFICE  =0x0B;
    const TEL_RECEIVEDCALLS_CELLHOME    =0x0C;
    const TEL_RECEIVEDCALLS_FAXOFFICE   =0x0D;
    const TEL_RECEIVEDCALLS_FAXHOME     =0x0E;
    byte gReceivedCalls_NumberType [TEL_RECEIVEDCALLS_ENTRIES];
    char gReceivedCalls_NumberType_s[15][30] ={ "unknown NumberType",
                                                "General",
                                                "Mobile",
                                                "Office",
                                                "Home",
                                                "Fax",
                                                "Pager",
                                                "Car",
                                                "SIM",
                                                "Main office",
                                                "Main home",
                                                "Cell office",
                                                "Cell home",
                                                "Fax office",
                                                "Fax home"};
                                                
    const TEL_RECEIVEDCALLS_TELNUMBER_LENGTH =41;
    char gReceivedCalls_TelNumber [TEL_RECEIVEDCALLS_ENTRIES][TEL_RECEIVEDCALLS_TELNUMBER_LENGTH];
    
    byte gReceivedCalls_day [TEL_RECEIVEDCALLS_ENTRIES];

    byte gReceivedCalls_month [TEL_RECEIVEDCALLS_ENTRIES];
    
    byte gReceivedCalls_year [TEL_RECEIVEDCALLS_ENTRIES];
    
    byte gReceivedCalls_hour [TEL_RECEIVEDCALLS_ENTRIES];
    
    byte gReceivedCalls_minute [TEL_RECEIVEDCALLS_ENTRIES];
    
    byte gReceivedCalls_second [TEL_RECEIVEDCALLS_ENTRIES]; 
    
    byte gReceivedCalls_ListEntryValidInformation [TEL_RECEIVEDCALLS_ENTRIES]; //indicates the existence of the "record element" 
    
    byte gReceivedCalls_sum =0;
       
    char gReceivedCalls_CSV_filename[TEL_FILENAME_SIZE];

    //**************array DialedNumbers**************************************

    byte gDialedNumbers_ASGID    =0;
    byte gDialedNumbers_TAID     =0;

    word gDialedNumbers_TotalNumListElements =0;

    const TEL_DIALEDNUMBERS_ENTRIES =0xFF;

    word gDialedNumbers_Pos [TEL_DIALEDNUMBERS_ENTRIES];

    const TEL_DIALEDNUMBERS_PBNAME_LENGTH =100;
    char gDialedNumbers_PbName [TEL_DIALEDNUMBERS_ENTRIES][TEL_DIALEDNUMBERS_PBNAME_LENGTH];

    const TEL_DIALEDNUMBERS_UNKNOWN     =0x00;
    const TEL_DIALEDNUMBERS_GENERAL     =0x01;
    const TEL_DIALEDNUMBERS_MOBILE      =0x02;
    const TEL_DIALEDNUMBERS_OFFICE      =0x03;
    const TEL_DIALEDNUMBERS_HOME        =0x04;
    const TEL_DIALEDNUMBERS_FAX         =0x05;
    const TEL_DIALEDNUMBERS_PAGER       =0x06;
    const TEL_DIALEDNUMBERS_CAR         =0x07;
    const TEL_DIALEDNUMBERS_SIM         =0x08;
    const TEL_DIALEDNUMBERS_MAINOFFICE  =0x09;
    const TEL_DIALEDNUMBERS_MAINHOME    =0x0A;
    const TEL_DIALEDNUMBERS_CELLOFFICE  =0x0B;
    const TEL_DIALEDNUMBERS_CELLHOME    =0x0C;
    const TEL_DIALEDNUMBERS_FAXOFFICE   =0x0D;
    const TEL_DIALEDNUMBERS_FAXHOME     =0x0E;
    byte gDialedNumbers_NumberType [TEL_DIALEDNUMBERS_ENTRIES];
    char gDialedNumbers_NumberType_s[15][30] ={ "unknown NumberType",
                                                "General",
                                                "Mobile",
                                                "Office",
                                                "Home",
                                                "Fax",
                                                "Pager",
                                                "Car",
                                                "SIM",
                                                "Main office",
                                                "Main home",
                                                "Cell office",
                                                "Cell home",
                                                "Fax office",
                                                "Fax home"};
                                                
    const TEL_DIALEDNUMBERS_TELNUMBER_LENGTH =41;
    char gDialedNumbers_TelNumber [TEL_DIALEDNUMBERS_ENTRIES][TEL_DIALEDNUMBERS_TELNUMBER_LENGTH];
    
    byte gDialedNumbers_day [TEL_DIALEDNUMBERS_ENTRIES];

    byte gDialedNumbers_month [TEL_DIALEDNUMBERS_ENTRIES];
    
    byte gDialedNumbers_year [TEL_DIALEDNUMBERS_ENTRIES];
    
    byte gDialedNumbers_hour [TEL_DIALEDNUMBERS_ENTRIES];
    
    byte gDialedNumbers_minute [TEL_DIALEDNUMBERS_ENTRIES];
    
    byte gDialedNumbers_second [TEL_DIALEDNUMBERS_ENTRIES]; 
    
    byte gDialedNumbers_ListEntryValidInformation [TEL_DIALEDNUMBERS_ENTRIES]; //indicates the existence of the "record element" 
    
    byte gDialedNumbers_sum =0;
       
    char gDialedNumbers_CSV_filename[TEL_FILENAME_SIZE];

  //IssueList #206
  //************** arrays FavoriteList **************************************

  byte gFavoriteList_ASGID = 0;
  byte gFavoriteList_TAID  = 0;

  word gFavoriteList_TotalNumListElements = 0;

  const TEL_FAVORITELIST_ENTRIES = 0xFF;
  
  const TEL_FAVORITE_PBNAME_LENGTH = 100;
  char gFavoriteList_PbName [TEL_FAVORITELIST_ENTRIES][TEL_FAVORITE_PBNAME_LENGTH];
 
  const TEL_FAVORITE_NUMBERTYPE_UNKNOWN     = 0x00;
  const TEL_FAVORITE_NUMBERTYPE_GENERAL     = 0x01;
  const TEL_FAVORITE_NUMBERTYPE_MOBILE      = 0x02;
  const TEL_FAVORITE_NUMBERTYPE_OFFICE      = 0x03;
  const TEL_FAVORITE_NUMBERTYPE_HOME        = 0x04;
  const TEL_FAVORITE_NUMBERTYPE_FAX         = 0x05;
  const TEL_FAVORITE_NUMBERTYPE_PAGER       = 0x06;
  const TEL_FAVORITE_NUMBERTYPE_CAR         = 0x07;
  const TEL_FAVORITE_NUMBERTYPE_SIM         = 0x08;
  const TEL_FAVORITE_NUMBERTYPE_MAINOFFICE  = 0x09;
  const TEL_FAVORITE_NUMBERTYPE_MAINHOME    = 0x0A;
  const TEL_FAVORITE_NUMBERTYPE_CELLOFFICE  = 0x0B;
  const TEL_FAVORITE_NUMBERTYPE_CELLHOME    = 0x0C;
  const TEL_FAVORITE_NUMBERTYPE_FAXOFFICE   = 0x0D;
  const TEL_FAVORITE_NUMBERTYPE_FAXHOME     = 0x0E;
  byte gFavoriteList_NumberType[TEL_FAVORITELIST_ENTRIES]; 
  char gFavoriteList_NumberType_s[15][50] = { "unknown number type",
                                              "General",
                                              "Mobile",
                                              "Office",
                                              "Home",
                                              "Fax",
                                              "Pager",
                                              "Car",
                                              "SIM",
                                              "Main office",
                                              "Main home",
                                              "Cell office",
                                              "Cell home",
                                              "Fax office",
                                              "Fax home"};

  word gFavoriteList_Pos [TEL_FAVORITELIST_ENTRIES];                                          
                                              
  const TEL_FAVORITE_TELNUMBER_LENGTH = 41;
  char gFavoriteList_TelNumber [TEL_FAVORITELIST_ENTRIES][TEL_FAVORITE_PBNAME_LENGTH];

  byte gFavoriteList_ListEntryValidInformation [TEL_FAVORITELIST_ENTRIES]; //indicates the existence of the "record element" 

  byte gFavoriteList_sum =0;
     
  char gFavoriteList_CSV_filename[TEL_FILENAME_SIZE];


    //IssueList #22
  	char  NODE_NAME[100]            = "FSG_Telephone";
	const LSGID                     = 0x28;
    
    //IssueList #23
    long Tel_HBdata[2];


    //IssueList #49
    msTimer _tfreeBusyTimer;

    //IssueList #41
    byte gIncomingCallPress = 0;
    char gCallInfoDialNumber_name [DIAL_NUMBER_NAME_LENGTH];		

    //IssueList #40
    char gDialNumber_name2 [DIAL_NUMBER_NAME_LENGTH];		//PbName of dialed Number
   
    //IssueList #20 & #40
    byte gPhonebookRequestActive;
    byte gPhonebook_TelNum_index;
    byte gDialNumber_Category;
    byte gDialNumber_PhoneBook_Category[20];


    //IssueList #74
    byte gTelFctList_0x1A_TimeOut_flg=0;
    byte gTelFctList_0x1E_TimeOut_flg=0;
    byte gTelFctList_0x20_TimeOut_flg=0;
    byte gTelFctList_0x1F_TimeOut_flg=0;
    byte gTelFctList_0x1B_TimeOut_flg=0;
    byte gTelFctList_0x1D_TimeOut_flg=0;
    byte gTelFctList_0x23_TimeOut_flg=0;
    byte gTelFctList_0x24_TimeOut_flg=0;
    byte gTelFctList_0x25_TimeOut_flg=0;
    byte gTelFctList_0x35_TimeOut_flg=0;
    byte gTelFctList_0x1C_TimeOut_flg=0;
    byte gTelFctList_0x28_TimeOut_flg=0;
    byte gTelFctList_0x26_TimeOut_flg=0;
    byte gTelFctList_0x27_TimeOut_flg=0;
    byte gTelFctList_0x36_TimeOut_flg=0;

    //IssueList #68
    const TELMAXPROCESSINGTIME = 180;
    //const TELMAXPROCESSINGTIME = 5;
    Timer TelFctList_0x1A_ProcessingTimer;
    Timer TelFctList_0x1E_ProcessingTimer;
    Timer TelFctList_0x20_ProcessingTimer;
    Timer TelFctList_0x1F_ProcessingTimer;
    Timer TelFctList_0x1B_ProcessingTimer;

    Timer TelFctList_0x1D_ProcessingTimer;
    Timer TelFctList_0x23_ProcessingTimer;
    Timer TelFctList_0x24_ProcessingTimer;
    Timer TelFctList_0x25_ProcessingTimer;
    Timer TelFctList_0x35_ProcessingTimer;

    Timer TelFctList_0x1C_ProcessingTimer;
    Timer TelFctList_0x28_ProcessingTimer;
    Timer TelFctList_0x26_ProcessingTimer;
    Timer TelFctList_0x27_ProcessingTimer;
    Timer TelFctList_0x36_ProcessingTimer;

    byte gTelFctList_0x1A_Processing_flg=0;
    byte gTelFctList_0x1E_Processing_flg=0;
    byte gTelFctList_0x20_Processing_flg=0;
    byte gTelFctList_0x1F_Processing_flg=0;
    byte gTelFctList_0x1B_Processing_flg=0;

    byte gTelFctList_0x1D_Processing_flg=0;
    byte gTelFctList_0x23_Processing_flg=0;
    byte gTelFctList_0x24_Processing_flg=0;
    byte gTelFctList_0x25_Processing_flg=0;
    byte gTelFctList_0x35_Processing_flg=0;

    byte gTelFctList_0x1C_Processing_flg=0;
    byte gTelFctList_0x28_Processing_flg=0;
    byte gTelFctList_0x26_Processing_flg=0;
    byte gTelFctList_0x27_Processing_flg=0;
    byte gTelFctList_0x36_Processing_flg=0;

    //IssueList #101
    byte gDialNumActive =0;

     //IssueList #122
    byte allCallsHangUpFlg;
    
    //IssueList #104
    //changes from Jan Swoboda 21.06.2012
    byte gAcknowledgePending[64];

    //IssueList #155 - Aghil
    byte gFSGOpStateFlg=0,gCallIDTemp;
    char bCallstate[7][24];

    //IssueList #76  MR49870
    //Phonebook
    //delete
    word gPhonebook_Pos_insDel [PHONEBOOK_ENTRIES][2];
    byte gPB_InvalidDel[PHONEBOOK_ENTRIES];
    byte gPB_DelInvalidCtr,gPB_DelValidCtr;
    byte gPhonebook_Send[PHONEBOOK_ENTRIES][1];
    word gPB_totalDELctr;

    //insert
    byte gPB_InvalidIns[PHONEBOOK_ENTRIES];
    byte gPB_InsInvalidCtr,gPB_InsValidCtr;
    word gPB_TotalElem, gPB_CSVtotalElem;

    //CombinedNumbers
    //delete
    word gCombinedNum_Pos_insDel [TEL_COMBINEDNUMBERS_ENTRIES][2];
    byte gCN_InvalidDel[TEL_COMBINEDNUMBERS_ENTRIES];
    byte gCN_DelInvalidCtr,gCN_DelValidCtr;
    byte gCombinedNum_Send[TEL_COMBINEDNUMBERS_ENTRIES][1];
    word gCN_totalDELctr;

    //insert
    byte gCN_InvalidIns[TEL_COMBINEDNUMBERS_ENTRIES];
    byte gCN_InsInvalidCtr,gCN_InsValidCtr;
    word gCN_TotalElem, gCN_CSVtotalElem;
	
	//FavoriteList
    //delete
    word gFavoriteList_Pos_insDel [TEL_FAVORITELIST_ENTRIES][2];
    byte gFL_InvalidDel[TEL_FAVORITELIST_ENTRIES];
    byte gFL_DelInvalidCtr,gFL_DelValidCtr;
    byte gFavoriteList_Send[TEL_FAVORITELIST_ENTRIES][1];
    word gFL_totalDELctr;

    //insert
    byte gFL_InvalidIns[TEL_FAVORITELIST_ENTRIES];
    byte gFL_InsInvalidCtr,gFL_InsValidCtr;
    word gFL_TotalElem, gFL_CSVtotalElem;
    

    msTimer fsgOperationState_delayTimer;

    //IssueList #180
    byte gConfirmEcall_3minProc_flg;

    //IssueList #201
    char gCurrent_NetworkProviderName[40];
    char gCurrent_ServiceProviderName[40];

    //BAP_MOST sync during activeCall
    char gActiveCallPictureFile [TEL_TEXTLENGTH];

    //MR 60227 - Simulation improvement for Integration Testing
    
    byte gActiveCallPictureType;
    byte gBapMostCallID;
    byte gBapMostDisconnectID;
    timer _tBAP_delayTime; 
    timer _tMOST_delayTime; 
    dword gTel_Requestarray [BAP_buffer_size];
    int gTel_Offset;

    byte gTel_BAPdataType;
    byte gActiveCall_active = 0;
    byte gActiveCall_CallMethodActive = 0;
    byte gActiveCall_HangUpMethodActive = 0;
    byte gActiveCall_BAPdelayFlag=0;
    byte gActiveCall_MPswapActive=0;

    byte gActiveCall_DisconnectReasonDelay = 0;
    byte gActiveCall_CallInfoDelay = 0;
    byte gActiveCall_IncomingCall = 0;
    byte gActiveCall_Dialled = 0;
    byte gActiveCall_HangUpPressed = 0;
    byte gActiveCall_ActiveFlag=0;

    //callState
    dword gTel_CallStateArray [BAP_buffer_size];
    int gTel_CSoffset;
    byte gTel_CSbapDataType;
    byte gActiveCall_idleCtr=0;

    //MR 60899
    msTimer _tReleaseUpdate_buttons;


    //MR 63665

    byte gHookTasteFlag_MPRACAWC =0;
    byte gHookTasteFlag_AcceptCall =0;
    byte gHookTasteFlag_MPCHAWC = 0;

    //MR63666 (bap_most synch)
    msTimer _tReleaseSetImage_button;
    //VAGH-10511	
    byte ASGID, TAID;
}

on envVar ON_OFF_FSG40_0
{
	if (getValue(this))
	putValue(env_FSG_Schalter_OnOff,0 );
}

on timer _tReleaseSetImage_button
{
putValue(env_PIC_bapMOST_setImage_button,0);
}

//BAP_MOST sync
void setActiveCall_Picture()
{
	dword ctr1;
     dword d;
   byte h, m, s;
   word ms, us, ns;

 for(ctr1=0;ctr1<TEL_TEXTLENGTH; ctr1++) //clear "buffer"
 gActiveCallPictureFile[ctr1]=0;
                     
 switch(gBapMostCallID)
 {
  case 0: gActiveCallPictureType = getValue(env_FSG_MOST_ActiveCallPicType_0);
          if (gActiveCallPictureType > 0)
          strncpy(gActiveCallPictureFile,"CallID_0.png",13);
          break;
  case 1: gActiveCallPictureType = getValue(env_FSG_MOST_ActiveCallPicType_1);
          if (gActiveCallPictureType > 0)
          strncpy(gActiveCallPictureFile,"CallID_1.png",13);
          break;
  case 2: gActiveCallPictureType = getValue(env_FSG_MOST_ActiveCallPicType_2);
          if (gActiveCallPictureType > 0)
          strncpy(gActiveCallPictureFile,"CallID_2.png",13);
          break;
  case 3: gActiveCallPictureType = getValue(env_FSG_MOST_ActiveCallPicType_3);
          if (gActiveCallPictureType > 0)
          strncpy(gActiveCallPictureFile,"CallID_3.png",13);
          break;
  case 4: gActiveCallPictureType = getValue(env_FSG_MOST_ActiveCallPicType_4);
          if (gActiveCallPictureType > 0)
          strncpy(gActiveCallPictureFile,"CallID_4.png",13);
          break;
  case 5: gActiveCallPictureType = getValue(env_FSG_MOST_ActiveCallPicType_5);
          if (gActiveCallPictureType > 0)
          strncpy(gActiveCallPictureFile,"CallID_5.png",13);
          break;
  case 6: gActiveCallPictureType = getValue(env_FSG_MOST_ActiveCallPicType_6);
          if (gActiveCallPictureType > 0)
          strncpy(gActiveCallPictureFile,"CallID_6.png",13);
          break;
default: break;
}
//NO PICTURE
if (gActiveCallPictureType == 0 ||gActiveCallPictureType == 6 )
strncpy(gActiveCallPictureFile,gempty_string,strlen(gempty_string));

write("gActiveCallPictureFile = %s",gActiveCallPictureFile);
 //consider delay timer if MOST is active
    if (gActiveCall_active == 1)
    {
    gActiveCall_IncomingCall=0;
        //BAP FIRST before MOST
        if (gActiveCall_BAPdelayFlag== 0) //delay timer
        {
        //send BAP first
        CallState_Request(Data_REQ,0);	//send call state
        //call MOST function after the delay
        setTimer (_tMOST_delayTime, (-1)*getValue(env_AudioTel_bapMost_delayTimer));
        }

        //MOST FIRST before BAP
        else if (gActiveCall_BAPdelayFlag == 1) //delay timer
        {
        //send MOST first
            if (gActiveCall_idleCtr>=6 && gActiveCall_HangUpMethodActive == 0x01 && gCallOptions[gBapMostCallID]!=0x10)
            write("MostFirst:No Picture"); 
            else 
            {
            write("MostFirst: PicServTrigActiveCallPic (seconds) = %.3f", timeNowFloat()/100000.0);
            PicServTrigActiveCallPic(gActiveCallPictureFile, gBapMostCallID,gActiveCallPictureType);
            }
              

        //call CallState after the delay
        setTimer (_tBAP_delayTime, getValue(env_AudioTel_bapMost_delayTimer));

        }
    }

}

//MR 60227
on timer _tMOST_delayTime
{
gActiveCall_active= 0;
gActiveCall_CallMethodActive =0;
gActiveCall_HangUpPressed = 0;

    if (gActiveCall_idleCtr>=6 && gActiveCall_HangUpMethodActive == 0x01 && gCallOptions[gBapMostCallID]!=0x10)
    write("BAPfirst: No Picture");
    else
    {
    write("BAPfirst: PicServTrigActiveCallPic (seconds) = %.3f", timeNowFloat()/100000.0);
    PicServTrigActiveCallPic(gActiveCallPictureFile, gBapMostCallID,gActiveCallPictureType);
    }

}

on start
{
	//RGB-Values for background colors
	gRGB_red=MakeRGB(255,0,0);
	gRGB_yellow=MakeRGB(255,255,0);
	gRGB_green=MakeRGB(0,255,0);
	gRGB_grey=MakeRGB(192,192,192);
	gRGB_white=MakeRGB(255,255,255);
	
	//Power on/off
	gBAP_Init=0;
	gFSG_Telephone_PowerOnOff=0;
	putvalue(env_FSG_string_Power_on_off, gstring_FSG_Telephone_PowerOnOff [gFSG_Telephone_PowerOnOff]);

	//FunctionList
	putvalue(env_FSG_Telephone_s_FctList_set, gstring_FunctionListModified[gFunctionListModified]);
	settimer(agetimer, 1000);											//start timer for getting the date
	//enablecontrol("FSG-Telephone-Phonebook", "ActiveDownload", 0);

	//JagÄlskarSverige
	EnableControl("BAP_Message_Generator","ExtendedArrayHeader", 0);

    
    putvalue(env_FSG_Schalter_OnOff_string, gFSG_Schalter_OnOff_string[gFSG_Schalter_OnOff]);
    //OpenPanel("FSG-Telephone_Schalter");


}

init_variables ()
{

int i, j;
char empty_string [3];

//init lokal variables
	for(i=0;i<3;i++)
		empty_string[i]=0;
//********************

	
	gKl15=0;
	gKlS=0;	

	//BAP-Communication
	for (i=0;i<BAP_buffer_size;i++)
		gBAP_Indication[i]=0;
	
	for (j=0;j<Requestbuffer_lines;j++){
		gBAP_Requestbufffer_status[j]=0;
		gBAP_Requestbufffer_BAPDataTyp[j]=0;
	
		for (i=0;i<BAP_buffer_size;i++)
			gBAP_Request[j][i]=0;
	}

	gwrite_requestbuffer_line=0;
	gstatus_requestbuffer=0;

//***********************************************************************************************************************************
//***********************************************Telephone***************************************************************************
//***********************************************************************************************************************************


	//IncomingCallnumber
	gincomingcall=0;
	gstatus_incomingcall_changearraytimer=0;
	gincomingcall_numbertype=0;
	gincomingcall_calltype=SINGLE_VOICE_CALL;
	gincomingcall_divert=0;
	gmissedcall=0;
	greceivedcall_numbertype=0;
	gnumbersearchphonebook=0;
	for (i=0;i<CALL_INFO_NUMBER_LENGTH;i++){
		gincomingcall_number[i]=0;
		greceivedcall_number[i]=0;
	}
	for (i=0;i<40;i++){
		gincomingcall_name[i]=0;
		greceivedcall_name[i]=0;
	}
	putvalue(env_FSG_incomingcallstring, empty_string);
	

//*************************************************************************
//******************************properties*********************************
//*************************************************************************

	//FunctionList
	initFunctionList(); 
  
	//FSG_Setup (value-setting before Power-On is allowed)
	gSIMCardReader=getvalue(env_FSG_SIMCardReader);
	gCableConnection=getvalue(env_FSG_CableConnection);
	gHFPConnection=getvalue(env_FSG_HFPConnection);
	gRSAPConnection=getvalue(env_FSG_RSAPConnection);
	gAppleLinkConnection=getvalue(env_FSG_AppleLink);
	gGoogleLinkConnection=getvalue(env_FSG_GoogleLink);
	gBaiduConnection=getvalue(env_FSG_BaiduLink);
	gPhoneCharacteristics=gSIMCardReader+(2*gCableConnection)+(4*gHFPConnection)+(8*gRSAPConnection)+(16*gAppleLinkConnection)+(32*gGoogleLinkConnection)+(64*gBaiduConnection);
	gMobileConnectionType=getvalue(env_FSG_MobileConnectionType);


	//FSG_OperationState
    gOP_State=getvalue(env_FSG_OP_State);
	gTel_State=getvalue(env_FSG_Tel_State);
    gPrivacyModeBit=getvalue(env_FSG_PrivacyModeBit);
    gEnhancedPrivacyMode=getvalue(env_FSG_EnhancedPrivacyMode);
    gPrivacyMode=gPrivacyModeBit+2*gEnhancedPrivacyMode;
    

	//MobilServiceSupport
	//Byte0
    //IssueList #17
     gMobilServiceSupport0=0;
     gMobilServiceSupport1=0;
     gMobilServiceSupport2=0;
     gMobilServiceSupport3=0;
     gMobilServiceSupport4=0;
     gMobilServiceSupport5=0;
     gMobilServiceSupport6=0;
     gMobilServiceSupport7=0;
	//gMobilServiceSupport0=getvalue(env_FSG_Telephone_MSS_0x01)*0x40;
	//gMobilServiceSupport0=gMobilServiceSupport0+getvalue(env_FSG_Telephone_MSS_0x02)*0x20;
	//gMobilServiceSupport0=gMobilServiceSupport0+getvalue(env_FSG_Telephone_MSS_0x03)*0x10;
	//gMobilServiceSupport0=gMobilServiceSupport0+getvalue(env_FSG_Telephone_MSS_0x04)*0x08;
	//Byte1
	//gMobilServiceSupport1=getvalue(env_FSG_Telephone_MSS_0x0E)*0x02;
	//gMobilServiceSupport1=gMobilServiceSupport1+getvalue(env_FSG_Telephone_MSS_0x0F)*0x01;
	//Byte2
	//gMobilServiceSupport2  =getvalue(env_FSG_Telephone_MSS_0x10)*0x80;
	//changes from Jöran Karl (28.03.2012)
	gMobilServiceSupport2 =getvalue(env_FSG_Telephone_MSS_0x11)*0x40;
	gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x12)*0x20;
	gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x13)*0x10;
	gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x14)*0x08;
	gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x15)*0x04;
	gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x16)*0x02;
	gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x17)*0x01;
	//Byte3
	gMobilServiceSupport3  =getvalue(env_FSG_Telephone_MSS_0x18)*0x80;
	gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x19)*0x40;
	gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1A)*0x20;
	gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1B)*0x10;
	gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1C)*0x08;
	gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1D)*0x04;
	gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1E)*0x02;
	gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1F)*0x01;
	//Byte4
	gMobilServiceSupport4  =getvalue(env_FSG_Telephone_MSS_0x20)*0x80;
	gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x21)*0x40;
	gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x22)*0x20;
	gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x23)*0x10;
	gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x24)*0x08;
	gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x25)*0x04;
	gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x26)*0x02;
	gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x27)*0x01;
	//Byte5
	gMobilServiceSupport5  =getvalue(env_FSG_Telephone_MSS_0x28)*0x80;
	gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x29)*0x40;
	gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2A)*0x20;
	gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2B)*0x10;
	gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2C)*0x08;
	gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2D)*0x04;
	gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2E)*0x02;
	gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2F)*0x01;
	//Byte6
	gMobilServiceSupport6  =getvalue(env_FSG_Telephone_MSS_0x30)*0x80;
    gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x31)*0x40;
	gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x32)*0x20;
	gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x33)*0x10;
	gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x34)*0x08;
	gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x35)*0x04;
	gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x36)*0x02;
	gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x37)*0x01;
    // jok 20120321
	//Byte7
    gMobilServiceSupport7  =getvalue(env_FSG_Telephone_MSS_0x38)*0x80;
    gMobilServiceSupport7 +=getvalue(env_FSG_Telephone_MSS_0x39)*0x40;
    //IssueList #144 - uncommented
    gMobilServiceSupport7 +=getvalue(env_FSG_Telephone_MSS_0x3A)*0x20;

	//active user
	for(i=0;i<50;i++)
		gUserName[i]=0;
	putvalue(env_FSG_UserName, empty_string);

	//registerstate
	gRegisterState=getvalue(env_FSG_RegisterState);
    gNetworkType=getvalue(env_FSG_NetworkType);
    gPacketDataNetworkType=getvalue(env_FSG_PacketDataNetworkType);

	//lock state
	gLockState=getvalue(env_FSG_LockState);
	gPIN_attempts=3;

	//phone enable
	for(i=0;i<20;i++)
		gPINCodeRNS[i]=0;
		
	//networkprovidername
	for (i=0;i<40;i++)	gNetworkProviderName[i]=0;
    gNetworkProviderState=0;
    //changes from Jöran Karl (28.03.2012)
    for(i=0;i<40;i++) gServiceProviderName[i]=0;
    gServiceProviderState=0;
    //changes from Jöran Karl (28.03.2012)
    //for(i=0;i<40;i++) gServiceProviderName[i]=0;

	//property SignalQuality
	gSignalQuality=random(99);
	/*
    if(getvalue(env_FSG_SignalQuality_Mode)!=1)
		putvalue(env_FSG_SignalQuality_Mode, 1);
	else
		settimer(signalqualitytimer, 5);
    */
    gSignalQuality=0;
	putvalue(env_FSG_SignalQuality, gSignalQuality);

	//NetInfo
	gNetInfoCallDivert=0;
	gNetInfoCiphering=0;
	putvalue(env_FSG_NetInfoCallDivert, gNetInfoCallDivert);
	putvalue(env_FSG_NetInfoCiphering, gNetInfoCiphering);

	
	
	//CallState
    // changes from Jan Swoboda (01.03.2012)
    gCallStateRequestPending = 0;
    
	for(i=0;i<7;i++)
		gCallState[i]=0;
	putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
	putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
	putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
	putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
	putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
	putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
	putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
	for(i=0;i<7;i++)
		gCallType[i]=0;
	putvalue(env_FSG_CallType_CallID_0, empty_string);
	putvalue(env_FSG_CallType_CallID_1, empty_string);
	putvalue(env_FSG_CallType_CallID_2, empty_string);
	putvalue(env_FSG_CallType_CallID_3, empty_string);
	putvalue(env_FSG_CallType_CallID_4, empty_string);
	putvalue(env_FSG_CallType_CallID_5, empty_string);
	putvalue(env_FSG_CallType_CallID_6, empty_string);
	//CallActivity
	gCallActivity=0;
	putvalue(env_FSG_CallActivity, gstring_callactivity[gCallActivity]);
	//CallDivert
	for(i=0;i<7;i++)
		gCallIncomingDiverted[i]=0;
	putvalue(env_FSG_CallState_CallDivert_0, empty_string);
	putvalue(env_FSG_CallState_CallDivert_1, empty_string);
	putvalue(env_FSG_CallState_CallDivert_2, empty_string);
	putvalue(env_FSG_CallState_CallDivert_3, empty_string);
	putvalue(env_FSG_CallState_CallDivert_4, empty_string);
	putvalue(env_FSG_CallState_CallDivert_5, empty_string);
	putvalue(env_FSG_CallState_CallDivert_6, empty_string);

    for(i=0;i<7;i++)
		gCallOutgoingDiverted_eCallConfirmationPending[i]=0;
	putvalue(env_FSG_CallState_CallDivert_0, empty_string);
	putvalue(env_FSG_CallState_CallDivert_1, empty_string);
	putvalue(env_FSG_CallState_CallDivert_2, empty_string);
	putvalue(env_FSG_CallState_CallDivert_3, empty_string);
	putvalue(env_FSG_CallState_CallDivert_4, empty_string);
	putvalue(env_FSG_CallState_CallDivert_5, empty_string);
	putvalue(env_FSG_CallState_CallDivert_6, empty_string);

	
    putvalue(env_FSG_CallState_CallID_0_set,idle);
	putvalue(env_FSG_CallState_CallID_1_set,idle);
	putvalue(env_FSG_CallState_CallID_2_set,idle);
	putvalue(env_FSG_CallState_CallID_3_set,idle);
	putvalue(env_FSG_CallState_CallID_4_set,idle);
	putvalue(env_FSG_CallState_CallID_5_set,idle);
	putvalue(env_FSG_CallState_CallID_6_set,idle);

	putvalue(env_FSG_CallType_CallID_0_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_1_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_2_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_3_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_4_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_5_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_6_set,unknowncalltype);
	
	putvalue(env_FSG_CallState_CallInDive_0_s, 0);
	putvalue(env_FSG_CallState_CallInDive_1_s, 0);
	putvalue(env_FSG_CallState_CallInDive_2_s, 0);
	putvalue(env_FSG_CallState_CallInDive_3_s, 0);
	putvalue(env_FSG_CallState_CallInDive_4_s, 0);
	putvalue(env_FSG_CallState_CallInDive_5_s, 0);
	putvalue(env_FSG_CallState_CallInDive_6_s, 0);

	putvalue(env_FSG_CallState_CallOuDive_0_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_1_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_2_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_3_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_4_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_5_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_6_s, 0);
    putvalue(env_FSG_CallState_CallOuDive_7_s, 0);

    putvalue(env_FSG_CallState_Opt_AcCall_0_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_1_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_2_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_3_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_4_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_5_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_6_s, 0);

    putvalue(env_FSG_CallState_Opt_HoldAc_0_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_1_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_2_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_3_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_4_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_5_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_6_s, 0);

    putvalue(env_FSG_CallState_Opt_CallAc_0_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_1_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_2_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_3_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_4_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_5_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_6_s, 0);

    putvalue(env_FSG_CallState_Opt_CallHo_0_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_1_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_2_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_3_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_4_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_5_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_6_s, 0);

    putvalue(env_FSG_CallState_Opt_ResCal_0_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_1_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_2_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_3_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_4_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_5_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_6_s, 0);

    putvalue(env_FSG_CallState_Opt_MPSwap_0_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_1_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_2_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_3_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_4_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_5_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_6_s, 0);

    putvalue(env_FSG_CallState_Opt_CCJoin_0_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_1_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_2_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_3_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_4_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_5_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_6_s, 0);
    
    putvalue(env_FSG_CallState_Opt_CCSpli_0_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_1_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_2_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_3_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_4_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_5_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_6_s, 0);
    
    
    //CallInfo
	gstatus_dialnumber_changearraytimer=0;
	for(j=0;j<7;j++)
	{
		for(i=0;i<CALL_INFO_NAME_LENGTH;i++)	//delete all call info strings
			gCallInfo_PbName[j][i]=0;
		for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
			gCallInfo_TelNumber[j][i]=0;
	}

	//PbName
	putvalue(env_FSG_CallInfo_PbName_0, gCallInfo_PbName[0]);
	putvalue(env_FSG_CallInfo_PbName_1, gCallInfo_PbName[1]);
	putvalue(env_FSG_CallInfo_PbName_2, gCallInfo_PbName[2]);
	putvalue(env_FSG_CallInfo_PbName_3, gCallInfo_PbName[3]);
	putvalue(env_FSG_CallInfo_PbName_4, gCallInfo_PbName[4]);
	putvalue(env_FSG_CallInfo_PbName_5, gCallInfo_PbName[5]);
	putvalue(env_FSG_CallInfo_PbName_6, gCallInfo_PbName[6]);
    //IssueList #206 -s
  putvalue(env_FSG_CallInfo_PbName_0_data, gCallInfo_PbName_hex[0]);
  putvalue(env_FSG_CallInfo_PbName_1_data, gCallInfo_PbName_hex[1]);
  putvalue(env_FSG_CallInfo_PbName_2_data, gCallInfo_PbName_hex[2]);
  putvalue(env_FSG_CallInfo_PbName_3_data, gCallInfo_PbName_hex[3]);
  putvalue(env_FSG_CallInfo_PbName_4_data, gCallInfo_PbName_hex[4]);
  putvalue(env_FSG_CallInfo_PbName_5_data, gCallInfo_PbName_hex[5]);
  putvalue(env_FSG_CallInfo_PbName_6_data, gCallInfo_PbName_hex[6]);
    //IssueList #206 -e

    putvalue(env_FSG_CallInfo_PbName_0_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_1_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_2_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_3_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_4_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_5_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_6_s,empty_string);

	//TelNumber
	putvalue(env_FSG_CallInfo_TelNumber_0, gCallInfo_TelNumber[0]);
	putvalue(env_FSG_CallInfo_TelNumber_1, gCallInfo_TelNumber[1]);
	putvalue(env_FSG_CallInfo_TelNumber_2, gCallInfo_TelNumber[2]);
	putvalue(env_FSG_CallInfo_TelNumber_3, gCallInfo_TelNumber[3]);
	putvalue(env_FSG_CallInfo_TelNumber_4, gCallInfo_TelNumber[4]);
	putvalue(env_FSG_CallInfo_TelNumber_5, gCallInfo_TelNumber[5]);
	putvalue(env_FSG_CallInfo_TelNumber_6, gCallInfo_TelNumber[6]);

    putvalue(env_FSG_CallInfo_TelNumber_0_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_1_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_2_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_3_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_4_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_5_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_6_s, empty_string);

    //Category
    putvalue(env_FSG_CallInfo_Category_0_s, 0);
    putvalue(env_FSG_CallInfo_Category_1_s, 0);
    putvalue(env_FSG_CallInfo_Category_2_s, 0);
    putvalue(env_FSG_CallInfo_Category_3_s, 0);
    putvalue(env_FSG_CallInfo_Category_4_s, 0);
    putvalue(env_FSG_CallInfo_Category_5_s, 0);
    putvalue(env_FSG_CallInfo_Category_6_s, 0);
    
    //IssueList #20
    putvalue(env_FSG_CallInfo_Category_0, empty_string);
    putvalue(env_FSG_CallInfo_Category_1, empty_string);
    putvalue(env_FSG_CallInfo_Category_2, empty_string);
    putvalue(env_FSG_CallInfo_Category_3, empty_string);
    putvalue(env_FSG_CallInfo_Category_4, empty_string);
    putvalue(env_FSG_CallInfo_Category_5, empty_string);
    putvalue(env_FSG_CallInfo_Category_6, empty_string);
    
    
    //CallDurationSync
    gTimeStampCall[0]=getvalue(env_FSG_CallDurationSync_0);
    gTimeStampCall[1]=getvalue(env_FSG_CallDurationSync_1);
    gTimeStampCall[2]=getvalue(env_FSG_CallDurationSync_2);
    gTimeStampCall[3]=getvalue(env_FSG_CallDurationSync_3);
    gTimeStampCall[4]=getvalue(env_FSG_CallDurationSync_4);
    gTimeStampCall[5]=getvalue(env_FSG_CallDurationSync_5);
    gTimeStampCall[6]=getvalue(env_FSG_CallDurationSync_6);


    //DisconnectReason
	gDisconnectReason=0;
	putvalue(env_FSG_DisconnectReason, gDisconnectReason);


	//HandsFree
    gHandsFreeOnOff=getvalue(env_FSG_HandsFreeOnOff);
	//gHandsFreeOnOff=1;
	//gheadset_available=0xA2;
	//putvalue(env_FSG_HandsFreeOnOff, gHandsFree);
	//putvalue(env_FSG_Headset_available, gheadset_available);
	//EnableControl("FSG-Telephone-Premium", "FSG-Telephone_HandsFree", 0);

	//MicroMuteOnOff
	gMicroMuteOnOff=getvalue(env_FSG_MicroMuteOnOff);

	//property Keypad
	gKeypadStatus=0;
	gKeypadTimer_status=0;

    //MobileBatteryLevel
    gChargeLevelMobile1=getvalue(env_FSG_ChargeLevelM1);
    gChargeLevelMobile2=getvalue(env_FSG_ChargeLevelM2);
    gChargeLevelHandset1=getvalue(env_FSG_ChargeLevelH1);
    gChargeLevelHandset2=getvalue(env_FSG_ChargeLevelH2);
    gWarningLevel=0;
	
    //DataConnectionIndication
    gConnectionIndication=getvalue(env_FSG_ConnectionIndication);
    gDataVolumeUplink=0;
    gDataVolumeDownlink=0;
    if(gConnectionIndication)
        settimer(DataConnectionIndicationTimer,2);
    //MissedCallIndication
	gMissedCalls=getvalue(env_FSG_MissedCalls);
	gMissedNumbers=getvalue(env_FSG_MissedNumbers);

    //SMSState
	gSIMReady=getvalue(env_FSG_SIMReady);
	gStorageState=getvalue(env_FSG_StorageState);
	gNumberOfNewSMS=getvalue(env_FSG_NumberOfNewSMS);

    //RingToneMuteOnOff
    gRingToneMuteOnOff =0;
    putvalue(env_FSG_RingToneMuteOnOff,gRingToneMuteOnOff);

    //AutomaticRedial
    gAutomaticRedialState = 0;
    putvalue(env_FSG_AutomaticRedial_Active, gAutomaticRedialState);
    putvalue(env_FSG_AutomaticRedial_ActiveS, gAutomaticRedialState_s[gAutomaticRedialState]);


//*************************************************************************
//******************************methods************************************
//*************************************************************************	

	//phone enable
	for(i=0;i<20;i++)
		gPINCodeRNS[i]=0;
	
	//dialnumber
	for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
		gDialNumber[i]=0;
	for(i=0;i<DIAL_NUMBER_NAME_LENGTH;i++)
		gDialNumber_name[i]=0;
	gdialnumber_numbertype=0;
	gcallID=0xff;
	gemergencycall=0;
	gDialNumber_status=0;
	putvalue(env_FSG_dialednumber_free_busy, free);
	EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);

	//hangupcall
	ghangupcall_status=0;

	//acceptcall
	gacceptcall_status=0;

	//CallHold
	gCallHold_status=0;
	
	//ResumeCall
	gResumeCall_status=0;
	
	//MPSwap
	gMPSwap_status=0;
	
	//CCJoin
	gCCJoin_status=0;
	
	//CCSplit
	gCCSplit_status=0;
	
	//MPRACAWC
	gMPRACAWC_status=0;
	
	//MPRAllCAWC
	gMPRAllCAWC_status=0;
	
	//MPCHAWC
	gMPCHAWC_status=0;

    //MPSWCOH
	gMPSWCOH_status=0;
	
	//PhoneOnOff
	gPhoneOnOff_status=0;
	
	//RestoreFactorySettings
	gRestoreFactorySettings_status=0;
	putvalue(env_FSG_Restore_PhoneOne, 1);


	//*************************************************************************
	//******************************arrays*************************************
	//*************************************************************************	

//***********************************************************************************************************************************
//***********************************************************************************************************************************
//***********************************************************************************************************************************



//***********************************************************************************************************************************
//**********************************************Phonebook****************************************************************************
//***********************************************************************************************************************************



	//Callstack MissedCalls
    putvalue(env_FSG_MissedCalls_AutoOnOff,gmissedcalls_AutoOnOff);
    putvalue(env_FSG_MissedCalls_AutoOnOff_s,gmissedcalls_AutoOnOff_s[gmissedcalls_AutoOnOff]);
	gmissedcall_DeleteStatus=0;
    gmissedcall_DateTime=1;
    putvalue(env_FSG_missedcall_DateTime,gmissedcall_DateTime);
	greceivedcall_DeleteStatus=0;
	gdialednumbers_DeleteStatus=0;

    gmissedcalls_AutoOnOff=_ON;
    putvalue(env_FSG_MissedCalls_AutoOnOff,gmissedcalls_AutoOnOff);
    putvalue(env_FSG_MissedCalls_AutoOnOff_s,gmissedcalls_AutoOnOff_s[gmissedcalls_AutoOnOff]);
    //EnableControl("FSG-Telephone_MissedCalls(array)", "MissedCalls_StatusArray",0); //disable SatusArray button

    //array Phonebook
    putvalue(env_FSG_Phonebook_AutoOnOff,gPhonebook_AutoOnOff);
    putvalue(env_FSG_Phonebook_AutoOnOff_s,gPhonebook_AutoOnOff_s[gPhonebook_AutoOnOff]);
	gPhonebook_DeleteStatus=0;

    gPhonebook_AutoOnOff=_ON;
    putvalue(env_FSG_Phonebook_AutoOnOff,gPhonebook_AutoOnOff);
    putvalue(env_FSG_Phonebook_AutoOnOff_s,gPhonebook_AutoOnOff_s[gPhonebook_AutoOnOff]);
    //EnableControl("FSG-Telephone_MissedCalls(array)", "MissedCalls_StatusArray",0); //disable SatusArray button

	//property PbState
	gDownLoadState=0;
	gDownLoadState_old=0;
	gPbEntriesUHV=0;
	gPbEntriesUHV_old=0;
	putvalue(env_FSG_s_PbState_DownloadState, gstring_DownLoadState[gDownLoadState]);
	putvalue(env_FSG_PbState_EntriesUHV, gPbEntriesUHV);

	//method PbStartDownload
	gPbStartDownload_status=0;
	putvalue(env_FSG_PbStartDownload_Result, TRUE);

	//method PbSpeller
	gSearchMode=0;
	for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
		gSearchString[i]=0;	
	gMatchingEntries=0;
	gFoundPos=0;
	putvalue(env_FSG_PbSpeller_Matching, 0);

    //Array CombinedNumbers
    gCombinedNumbers_ASGID    =0;
    gCombinedNumbers_TAID     =0;

    gCombinedNumbers_TotalNumListElements =0;
    gCombinedNumbers_sum                  =0;

    for(j=0; j<TEL_COMBINEDNUMBERS_ENTRIES; j++)
    {
        gCombinedNumbers_ListEntryValidInformation[j] =0;
        gCombinedNumbers_Pos[j]                       =0;
        
        for(i=0;i<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;i++)
		    gCombinedNumbers_PbName[j][i] =0;
        
        gCombinedNumbers_NumberType[j]  =TEL_COMBINEDNUMBERS_UNKNOWN;		
		gCombinedNumbers_CallMode[j]    =TEL_COMBINEDNUMBERS_UNKNOWNCALL;
        
        for(i=0;i<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;i++)
		    gCombinedNumbers_TelNumber[j][i] =0;

        gCombinedNumbers_day[j]     =0;
        gCombinedNumbers_month[j]   =0;
        gCombinedNumbers_year[j]    =0;
        gCombinedNumbers_hour[j]    =0;
        gCombinedNumbers_minute[j]  =0;
        gCombinedNumbers_second[j]  =0;
    }
    
    for(i=0; i<TEL_FILENAME_SIZE; i++)
        gCombinedNumbers_CSV_filename[i] =0;

    putvalue(env_FSG_CN_ASGID, gCombinedNumbers_ASGID);
    putvalue(env_FSG_CN_TAID, gCombinedNumbers_TAID);
    putvalue(env_FSG_CN_TotalNumLE, gCombinedNumbers_TotalNumListElements);
    putvalue(env_FSG_CN_AH_shift, FALSE);
    putvalue(env_FSG_CN_AH_dir, FORWARD);
    putvalue(env_FSG_CN_AH_POS, TRUE);
    putvalue(env_FSG_CN_AH_IS, TRUE);
    putvalue(env_FSG_CN_AH_RA, 0);
    putvalue(env_FSG_CN_AH_start, 0);
    putvalue(env_FSG_CN_AH_elements, 3);
    putvalue(env_FSG_CN_DataSource, 0);
    putvalue(env_FSG_CN_CSVPath, empty_string);
    putvalue(env_FSG_CN_DataSource_result, empty_string);
    putvalue(env_FSG_CN_DataSource_file, empty_string);
    putvalue(env_FSG_CN_CA_switch, FALSE);

    putvalue(env_FSG_CN_SetGetArray_behaviour, TRUE);


    //Array ReceivedCalls
    gReceivedCalls_ASGID    =0;
    gReceivedCalls_TAID     =0;

    gReceivedCalls_TotalNumListElements =0;
    gReceivedCalls_sum                  =0;

    for(j=0; j<TEL_RECEIVEDCALLS_ENTRIES; j++)
    {
        gReceivedCalls_ListEntryValidInformation[j] =0;
        gReceivedCalls_Pos[j]                       =0;
        
        for(i=0;i<TEL_RECEIVEDCALLS_PBNAME_LENGTH;i++)
		    gReceivedCalls_PbName[j][i] =0;
        
        gReceivedCalls_NumberType[j]    =TEL_RECEIVEDCALLS_UNKNOWN;
        
        for(i=0;i<TEL_RECEIVEDCALLS_TELNUMBER_LENGTH;i++)
		    gReceivedCalls_TelNumber[j][i] =0;

        gReceivedCalls_day[j]     =0;
        gReceivedCalls_month[j]   =0;
        gReceivedCalls_year[j]    =0;
        gReceivedCalls_hour[j]    =0;
        gReceivedCalls_minute[j]  =0;
        gReceivedCalls_second[j]  =0;
    }
    
    for(i=0; i<TEL_FILENAME_SIZE; i++)
        gReceivedCalls_CSV_filename[i] =0;

    putvalue(env_FSG_RC_ASGID, gReceivedCalls_ASGID);
    putvalue(env_FSG_RC_TAID, gReceivedCalls_TAID);
    putvalue(env_FSG_RC_TotalNumLE, gReceivedCalls_TotalNumListElements);
    putvalue(env_FSG_RC_AH_shift, FALSE);
    putvalue(env_FSG_RC_AH_dir, FORWARD);
    putvalue(env_FSG_RC_AH_POS, TRUE);
    putvalue(env_FSG_RC_AH_IS, TRUE);
    putvalue(env_FSG_RC_AH_RA, 0);
    putvalue(env_FSG_RC_AH_start, 0);
    putvalue(env_FSG_RC_AH_elements, 3);
    putvalue(env_FSG_RC_DataSource, 0);
    putvalue(env_FSG_RC_CSVPath, empty_string);
    putvalue(env_FSG_RC_DataSource_result, empty_string);
    putvalue(env_FSG_RC_DataSource_file, empty_string);
    putvalue(env_FSG_RC_CA_switch, FALSE);

    putvalue(env_FSG_RC_SetGetArray_behaviour, TRUE);


    //Array DialedNumbers
    gDialedNumbers_ASGID    =0;
    gDialedNumbers_TAID     =0;

    gDialedNumbers_TotalNumListElements =0;
    gDialedNumbers_sum                  =0;

    for(j=0; j<TEL_DIALEDNUMBERS_ENTRIES; j++)
    {
        gDialedNumbers_ListEntryValidInformation[j] =0;
        gDialedNumbers_Pos[j]                       =0;
        
        for(i=0;i<TEL_DIALEDNUMBERS_PBNAME_LENGTH;i++)
		    gDialedNumbers_PbName[j][i] =0;
        
        gDialedNumbers_NumberType[j]    =TEL_DIALEDNUMBERS_UNKNOWN;
        
        for(i=0;i<TEL_DIALEDNUMBERS_TELNUMBER_LENGTH;i++)
		    gDialedNumbers_TelNumber[j][i] =0;

        gDialedNumbers_day[j]     =0;
        gDialedNumbers_month[j]   =0;
        gDialedNumbers_year[j]    =0;
        gDialedNumbers_hour[j]    =0;
        gDialedNumbers_minute[j]  =0;
        gDialedNumbers_second[j]  =0;
    }
    
    for(i=0; i<TEL_FILENAME_SIZE; i++)
        gDialedNumbers_CSV_filename[i] =0;

    putvalue(env_FSG_DN_ASGID, gDialedNumbers_ASGID);
    putvalue(env_FSG_DN_TAID, gDialedNumbers_TAID);
    putvalue(env_FSG_DN_TotalNumLE, gDialedNumbers_TotalNumListElements);
    putvalue(env_FSG_DN_AH_shift, FALSE);
    putvalue(env_FSG_DN_AH_dir, FORWARD);
    putvalue(env_FSG_DN_AH_POS, TRUE);
    putvalue(env_FSG_DN_AH_IS, TRUE);
    putvalue(env_FSG_DN_AH_RA, 0);
    putvalue(env_FSG_DN_AH_start, 0);
    putvalue(env_FSG_DN_AH_elements, 3);
    putvalue(env_FSG_DN_DataSource, 0);
    putvalue(env_FSG_DN_CSVPath, empty_string);
    putvalue(env_FSG_DN_DataSource_result, empty_string);
    putvalue(env_FSG_DN_DataSource_file, empty_string);
    putvalue(env_FSG_DN_CA_switch, FALSE);

    putvalue(env_FSG_DN_SetGetArray_behaviour, TRUE);
    
    //IssueList #27
    /* Error Codes and State */
    putvalue(env_Tel_AutoRedial_Error_On, FALSE);
    putvalue(env_Tel_AutoRedial_Error_Code, 0); 

    putvalue(env_Tel_RingToneMute_Error_On, FALSE);
    putvalue(env_Tel_RingToneMute_Error_Code, 0);

    putvalue(env_Tel_MissedCallInd_Error_On, FALSE);
    putvalue(env_Tel_MissedCallInd_Error_Code, 0);
    
    putvalue(env_Tel_HandsFree_Error_On, FALSE);
    putvalue(env_Tel_HandsFree_Error_Code, 0);
    
    putvalue(env_Tel_MicroMute_Error_On, FALSE);
    putvalue(env_Tel_MicroMute_Error_Code, 0); 
    
    
    //IssueList #26
    putValue(env_FSG_ConfirmECall_Result, 0);
    putValue(env_FSG_ConfirmECall_Control, 0);
    putValue(env_FSG_HangupCall_CallID_M, 0);
    putValue(env_FSG_HangUpCall_Result, 0);
    putValue(env_FSG_AcceptCall_Result, 0);
    putValue(env_FSG_CallResume_Result, 0);
    putValue(env_FSG_CallHold_Result, 0);
    putValue(env_FSG_DialService_Type, 0);
    putValue(env_FSG_DialService_Result, 0);
    putValue(env_FSG_MPRACAWC_Result, 0);
    putValue(env_FSG_MPSwap_Result, 0);
    putValue(env_FSG_MPCHAWC_Result, 0);
    putValue(env_FSG_MPSWCOH_Result, 0);
    putValue(env_FSG_CCJoin_Result, 0);
    putValue(env_FSG_MPRAllCAWC_Result, 0);
    putValue(env_FSG_DialNumber_TelNumber_M, empty_string);
    putValue(env_FSG_DialNumber_Name_M, empty_string);
    putValue(env_FSG_DialNumber_Result, 0);
    putValue(env_FSG_DialNumber_TelNumber, empty_string);
    putValue(env_FSG_DialNumber_Name, empty_string);

    putValue(env_FSG_GetNextListPos_ListType,0);
    putValue(env_FSG_GetNextListPos_current,0);
    putValue(env_FSG_GetNextListPos_Offset,0);
    putValue(env_FSG_GetNextListPos_nextPos,0);
    putValue(env_FSG_GetNextListPos_AbsLpos,0);
    putValue(env_FSG_GetNextListPos_Result,0);

    putValue(env_FSG_PbSpeller_Result,0);
    putValue(env_FSG_PbSpeller_Mode,0);
    putValue(env_FSG_PbSpeller_SearchString,empty_string);
    putValue(env_FSG_PbSpeller_Matching,0);
    putValue(env_FSG_PbSpeller_Pos,0);
    gDialbuttonOn = 0;
    gFirstPress = 0;      
    	
   
    //IssueList #47
    putValue(env_FSG_Tel_AcceptCall_Error_On, 0);
    putValue(env_FSG_Tel_AcceptCall_ErrorCode, 0);
    putValue(env_FSG_Tel_CallHold_Error_On, 0);
    putValue(env_FSG_Tel_CallHold_ErrorCode, 0);
    putValue(env_FSG_Tel_CCJoin_Error_On, 0);
    putValue(env_FSG_Tel_CCJoin_ErrorCode, 0);
    putValue(env_FSG_Tel_DialNumber_Error_On, 0);
    putValue(env_FSG_Tel_DialNumber_ErrorCode, 0);
    putValue(env_FSG_Tel_DialServ_Error_On, 0);
    putValue(env_FSG_Tel_DialServ_ErrorCode, 0);
    putValue(env_FSG_Tel_ECall_Error_On, 0);
    putValue(env_FSG_Tel_ECall_ErrorCode, 0);
    putValue(env_FSG_Tel_GetNextListPos_E_O, 0);
    putValue(env_FSG_Tel_GetNextListPos_EC, 0);
    putValue(env_FSG_Tel_HangUpCall_Error_On, 0);
    putValue(env_FSG_Tel_HangUpCall_ErrorCode, 0);
    putValue(env_FSG_Tel_MPCHAWC_Error_On, 0);
    putValue(env_FSG_Tel_MPCHAWC_ErrorCode, 0);
    putValue(env_FSG_Tel_MPRACAWC_Error_On, 0);
    putValue(env_FSG_Tel_MPRACAWC_ErrorCode, 0);
    putValue(env_FSG_Tel_MPRAllCAWC_Error_On, 0);
    putValue(env_FSG_Tel_MPRAllCAWC_ErrorCode, 0);
    putValue(env_FSG_Tel_MPSWAP_Error_On, 0);
    putValue(env_FSG_Tel_MPSWAP_ErrorCode, 0);
    putValue(env_FSG_Tel_MPSWCOH_Error_On, 0);
    putValue(env_FSG_Tel_MPSWCOH_ErrorCode, 0);
    putValue(env_FSG_Tel_PbSpeller_Error_On, 0);
    putValue(env_FSG_Tel_PbSpeller_ErrorCode, 0);
    putValue(env_FSG_Tel_ResumeCall_Error_On, 0);
    putValue(env_FSG_Tel_ResumeCall_ErrorCode, 0);
   
   //IssueList #23
   putValue(env_FSG_Telephone_FctList_0x0E_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x0F_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x10_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x11_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x12_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x13_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x14_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x15_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x16_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x17_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x19_HB , 1);

   putValue(env_FSG_Telephone_FctList_0x21_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x22_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x2A_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x2B_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x2C_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x2D_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x33_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x37_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x38_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x39_HB , 1);
   putValue(env_FSG_Telephone_FctList_0x3A_HB , 1);

//IssueList #16
    putValue(env_FSG_AutoRedialExtInfo_Name,empty_string);
    putValue(env_FSG_AutoRedialExtInfo_TelNo,empty_string);
    gAutomaticRedialTimeStamp = 65535;
    putValue(env_FSG_AutoRedialExtInfo_Tstamp,gAutomaticRedialTimeStamp);
    putValue(env_FSG_AutoRedialExtInfo_Cat,0);
    strncpy(gAutoRedialExtInfo_Number,empty_string,strlen(empty_string));
    strncpy(gAutoRedialExtInfo_Name,empty_string,strlen(empty_string));
    gAutomaticRedialCategory =0;
    
    //IssueList #104
    //changes from Jan Swoboda 21.06.2012
    for (i = 0; i < 64; i++)
        gAcknowledgePending[i] = 0;

//***********************************************************************************************************************************
//***********************************************************************************************************************************
//***********************************************************************************************************************************
 
// Usefull Defaults
//changes from Jöran Karl (28.03.2012)
    gSIMCardReader = 1;
    gCableConnection = 1;
    gHFPConnection = 1;
    gRSAPConnection = 1;
    gAppleLinkConnection=1;
    gGoogleLinkConnection=1;
    gBaiduConnection=1;
    gPhoneCharacteristics=gSIMCardReader+(2*gCableConnection)+(4*gHFPConnection)+(8*gRSAPConnection)+(16*gAppleLinkConnection)+(32*gGoogleLinkConnection)+(64*gBaiduConnection);
    gMobileConnectionType = HANDS_FREE_PROFILE;
    putvalue(env_FSG_HFPConnection, gHFPConnection);
    putvalue(env_FSG_MobileConnectionType, gMobileConnectionType);

    //MR 60899
    putValue(env_FSG_FSG_Setup_OK, 0x1); 

    gLockState = nolock;
    putvalue(env_FSG_LockState, gLockState);
        //MR 60899
    putValue(env_FSG_LockState_OK, 0x1); 

    //for (i=0;i<4;i++) gNetworkProviderName[i]='A' + i;
    strncpy(gNetworkProviderName, gstring_networkprovider[5], NETWORKPROVIDER_STRING_LENGTH);
    gNetworkProviderState = 1;
    putvalue(env_FSG_NetworkProviderName, gNetworkProviderName);
    putvalue(env_FSG_NetworkProviderState, gNetworkProviderState);

    //MR 60899
    putValue(env_FSG_NetworkProvider_OK, 0x1);

    gRegisterState = registered;
    putvalue(env_FSG_RegisterState, gRegisterState);
    gNetworkType = GSM;
    putvalue(env_FSG_NetworkType, gNetworkType);
    
    //MR 60899
    putValue(env_FSG_RegisterState_OK, 0x1); 

    gDownLoadState = 2;
    putvalue(env_FSG_PbState_DownloadState, gDownLoadState);
    putvalue(env_FSG_s_PbState_DownloadState, gstring_DownLoadState[gDownLoadState]);
    //MR 60899
    putValue(env_FSG_PbState_OK, 0x1); 

    gOP_State = 0;
    gTel_State = PhoneModuleOn;
    gPrivacyMode = 0;
    gPrivacyModeBit =0;
    gEnhancedPrivacyMode =0;
    putValue(env_FSG_OP_State, gOP_State);  
    putValue(env_FSG_Tel_State, gTel_State);   
    putValue(env_FSG_PrivacyModeBit, gPrivacyModeBit);
    putValue(env_FSG_EnhancedPrivacyMode,gEnhancedPrivacyMode);
    putValue(env_FSG_FSG_OperationState_OK, 0x1); 

    setTimer (_tReleaseUpdate_buttons,200);

   putValue(env_FSG_CallDurationSync_0,65535);
   putValue(env_FSG_CallDurationSync_1,65535);
   putValue(env_FSG_CallDurationSync_2,65535);
   putValue(env_FSG_CallDurationSync_3,65535);
   putValue(env_FSG_CallDurationSync_4,65535);
   putValue(env_FSG_CallDurationSync_5,65535);
   putValue(env_FSG_CallDurationSync_6,65535);
   //end MR 60899
  
    //IssueList #41
    gIncomingCallPress = 0;

   
     //IssueList #76 - MR49870 
    //Phonebook
    //insert
   putValue(env_FSG_Phonebook_insert_Err,1);
   putValue(env_FSG_PB_insert_successor, 0);
   putValue(env_FSG_PB_insert_UPD_button,0);
   putValue(env_FSG_PB_insert_size, 0);

    //delete
    putValue(env_FSG_Phonebook_delete_ErrHandler,1);
    putValue(env_FSG_PB_delete_size, 0);
   
    //Disable BIT16 controls
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Envar:env_FSG_PB_insert_size", 0); 
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Envar:env_FSG_PB_delete_size", 0); 
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Envar:env_FSG_Phonebook_insert_POS_16", 0); 
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Envar:env_FSG_Phonebook_delete_POS_16", 0); 

    //MR62005 - Auto Testing
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_16_A", 0); 
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_16_A", 0);
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_16_A_label", 0);
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_16_A_label", 0);

    //CN
    //insert
   putValue(env_FSG_CN_insert_ErrHandler,1);
   putValue(env_FSG_CN_insert_successor, 0);
   putValue(env_FSG_CN_insert_UPD_button,0);
   putValue(env_FSG_CN_insert_size, 0);

    //delete
    putValue(env_FSG_CN_delete_ErrHandler,1);
    putValue(env_FSG_CN_delete_size, 0);

}

//changes from Jöran Karl (28.03.2012)
putvalue_CallInfo(byte callID)
{
    switch(callID)
    {
        case 0:
            putvalue(env_FSG_CallInfo_PbName_0, gCallInfo_PbName[0]);
            //IssueList #206
            putvalue(env_FSG_CallInfo_PbName_0_data, gCallInfo_PbName_hex[0]);

            putvalue(env_FSG_CallInfo_TelNumber_0, gCallInfo_TelNumber[0]);
            break;
        case 1:
            putvalue(env_FSG_CallInfo_PbName_1, gCallInfo_PbName[1]);
            //IssueList #206
            putvalue(env_FSG_CallInfo_PbName_1_data, gCallInfo_PbName_hex[1]);

            putvalue(env_FSG_CallInfo_TelNumber_1, gCallInfo_TelNumber[1]);
            break;
        case 2:
            putvalue(env_FSG_CallInfo_PbName_2, gCallInfo_PbName[2]);
            //IssueList #206
            putvalue(env_FSG_CallInfo_PbName_2_data, gCallInfo_PbName_hex[2]);

            putvalue(env_FSG_CallInfo_TelNumber_2, gCallInfo_TelNumber[2]);
            break;
        case 3:
            putvalue(env_FSG_CallInfo_PbName_3, gCallInfo_PbName[3]);
            //IssueList #206
            putvalue(env_FSG_CallInfo_PbName_3_data, gCallInfo_PbName_hex[3]);

            putvalue(env_FSG_CallInfo_TelNumber_3, gCallInfo_TelNumber[3]);
            break;
        case 4:
            putvalue(env_FSG_CallInfo_PbName_4, gCallInfo_PbName[4]);
            //IssueList #206
            putvalue(env_FSG_CallInfo_PbName_4_data, gCallInfo_PbName_hex[4]);

            putvalue(env_FSG_CallInfo_TelNumber_4, gCallInfo_TelNumber[4]);
            break;
        case 5:
            putvalue(env_FSG_CallInfo_PbName_5, gCallInfo_PbName[5]);
            //IssueList #206
            putvalue(env_FSG_CallInfo_PbName_5_data, gCallInfo_PbName_hex[5]);

            putvalue(env_FSG_CallInfo_TelNumber_5, gCallInfo_TelNumber[5]);
            break;
        case 6:
            putvalue(env_FSG_CallInfo_PbName_6, gCallInfo_PbName[6]);
            //IssueList #206
            putvalue(env_FSG_CallInfo_PbName_6_data, gCallInfo_PbName_hex[6]);

            putvalue(env_FSG_CallInfo_TelNumber_6, gCallInfo_TelNumber[6]);
            break;
        default:
            write("putvalue_CallInfo: invalid call-ID: %d", callID);
            break;
    }
}

int tel_number_valid (char tel_number [], byte length)
{

int valid, i;

//init lokal variables
	i=0;
	valid=1;
//********************

	for (i=0; i<length; i++){
		switch(tel_number [i]){
			case '0':
			break;
			case '1':
			break;
			case '2':
			break;
			case '3':
			break;
			case '4':
			break;
			case '5':
			break;
			case '6':
			break;
			case '7':
			break;
			case '8':
			break;
			case '9':
			break;
			case '+':
				if(i!=0)
					valid=0;	
			break;
			case '*':
			break;
			case '#':
			break;
            case 'p':
			break;
            case 'w':
			break;
			default:
				valid=0;
			break;

		}
	}

	return(valid);

}

DialNumber_Indication (dword Indication_array [], byte indication, int datalength)
{
    //changes from Jöran Karl (28.03.2012)
    int number_length, name_length, number_valid, i, provider, is_emergency_call;
  //IssueList #26
  int result;

  int ret,j;;

	number_length = 0;
	name_length = 0;
	number_valid = 0;
	i = 0;
	provider = 0;
    //IssueList #26
    result = getValue(env_FSG_DialNumber_Result);

	switch(indication)
	{
		case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_FSG_Tel_DialNumber_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_DialNumber_ErrorCode) > 0x3F)) && (gTelFctList_0x1A_TimeOut_flg==0x00))
            {
            DialNumber_Request(Processing_REQ, 0);							//send Processing

                //IssueList #68
                if ((isTimerActive(TelFctList_0x1A_ProcessingTimer) == 0x00) && (gTelFctList_0x1A_Processing_flg == 0x01))
                setTimer(TelFctList_0x1A_ProcessingTimer,TELMAXPROCESSINGTIME);
            }
		    break;
		case StartResult_IND:
            //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x1A_TimeOut)!=TRUE)
            {
            gTelFctList_0x1A_TimeOut_flg = 0x00;
			
                //IssueList #57
                if (getValue(env_FSG_Tel_DialNumber_Error_On)==0x00)
                putValue(env_FSG_Tel_DialNumber_ErrorCode,0);
            
            //IssueList #47
            if (getValue(env_FSG_Tel_DialNumber_Error_On))
            {
                DialNumber_Request(Error_REQ, getValue(env_FSG_Tel_DialNumber_ErrorCode)); // send error-message
                break;
            }

            if(gDialNumber_status != 0)	//method is still active
			{
				DialNumber_Request(Error_REQ, Terror_unknownapllicationerror); // send error-message
                break;
			}
           
            number_length = Indication_array[3];
            //IssueList #40 
            //name_length = Indication_array[number_length + 4];
            
            //IssueList #26
            if ((result!=0x00)&&(result!=0x04))
            {
            gDialNumber_Result = result;
            DialNumber_Request(Result_REQ, 0);	
            gDialNumber_status = 0;
            break;
            }
		    else
            {
            gCallStartedFromASG = 1; 
			gDialNumber_status = 1;	//method "DialNumber" is now active
            }
			for(i = 0; i < CALL_INFO_NUMBER_LENGTH; i++)
				gDialNumber[i] = 0;
			for(i = 0; i < DIAL_NUMBER_NAME_LENGTH; i++)
				gDialNumber_name[i] = 0;

            // verify number and name
            if(number_length == 0)	//no number
			{
				DialNumber_Request(Error_REQ, Terror_datainvalid);	//send error-message
				gDialNumber_status = 0;	//method "dialnumber" is finished
                break;
			}
            
            //read number
            for (i = 0; i < number_length; i++)
				gDialNumber[i] = Indication_array[i+4];
    
            number_valid = tel_number_valid(gDialNumber, number_length); // check number
            
            //IssueList #40

              for (i=0; i<50;i++)
              {
                if (gPhonebookRequestActive == 0x00)
                {
                for(j = 0; j < DIAL_NUMBER_NAME_LENGTH; j++)	//delete all call info strings
			    gDialNumber_name2[i]=0;
                
                
                CombinedNumbers_PBname ();
                //IssueList #101
                //ret = strncmp(gCombinedNumbers_TelNumber[i],gDialNumber,strlen(gCombinedNumbers_TelNumber[i]));
	      	ret = strncmp(gCombinedNumbers_TelNumber[i],gDialNumber,strlen(gDialNumber)+1);
                    if (ret==0)
                    {
                     strncpy(gDialNumber_name2,gCombinedNumbers_PbName[i],strlen(gCombinedNumbers_PbName[i])+1);
                       break;
                    }
                }

                else if (gPhonebookRequestActive == 0x01)
                {
                 ret = strncmp(gPhonebook_TelNumbers[i][gPhonebook_TelNum_index],gDialNumber,strlen(gDialNumber));
                  if (ret==0)
                   {
                    gDialNumber_Category = gDialNumber_PhoneBook_Category[i];

                    break;
                    }

                }//else
              } //for


              name_length = strlen(gDialNumber_name2);

            datalength = number_length +name_length+5;
            //end of IssueList #40

            if(datalength != number_length + name_length + 5) // BAP-array datalength error
			{
				DialNumber_Request(Error_REQ, Terror_datainvalid); // send error-message
				break;
			}


            //IssueList #26
            if((number_valid != 1) || (result==NS_NUMBER_INVALID))
            {
                gDialNumber_Result = NS_NUMBER_INVALID;								
                DialNumber_Request(Result_REQ, 0);
                gDialNumber_status = 0;
                break;
            }
 
			if(name_length > 0) // PbName was sent
			{
				//IssueList #40
				//for (i = 0; i < name_length; i++) //read name from indication array
				//gDialNumber_name[i] = Indication_array[i + 5 + number_length];							
				strncpy(gDialNumber_name,gDialNumber_name2,strlen(gDialNumber_name2)+1);;
                		gnumbersearchphonebook = 2;
                
				settimer(numbersearchphonebooktimer, 5);
			}
			else if(strncmp(gDialNumber, info, CALL_INFO_NUMBER_LENGTH) == 0)
			{
				strncpy(gDialNumber_name, info_pbname, CALL_INFO_NAME_LENGTH);
				gdialnumber_numbertype = infocall;
				gnumbersearchphonebook = 2;
				settimer(numbersearchphonebooktimer, 5);
                

			}
			else if(strncmp(gDialNumber, service, CALL_INFO_NUMBER_LENGTH) == 0)
			{
				strncpy(gDialNumber_name, service_pbname, CALL_INFO_NAME_LENGTH);
				gdialnumber_numbertype = servicecall;
				gnumbersearchphonebook = 2;
				settimer(numbersearchphonebooktimer, 5);
			}
			else
			{
				putvalue(env_FSG_phonebook_number, gDialNumber);

                gnumbersearchphonebook = 1;
				settimer(numbersearchphonebooktimer, 100);
			}
			
            // GMS-module or mobile not active ?
            //IssueList #26
            //if(PhoneModuleOn != gTel_State && MobileOn != gTel_State) 
            if((PhoneModuleOn != gTel_State && MobileOn != gTel_State)  || (result==NS_NO_NETWORK))
      
			{
                gDialNumber_Result = NS_NO_NETWORK;
				DialNumber_Request(Result_REQ, 0);
				gDialNumber_status = 0; //method is finished
                break;
			}

            is_emergency_call = detect_emergency_number();
            
            //IssueList #42
			//if(gRegisterState != 1 ) // not registered
            if((gRegisterState != 1)&&(gRegisterState != 4)&&(gRegisterState != 5))
			{
              
                if(is_emergency_call != 1) // not registered and no emergency call
                          
               {
                    gDialNumber_Result = NS_NOT_REG_EC_ONLY;								
    				DialNumber_Request(Result_REQ, 0);	
    				gDialNumber_status = 0; // method is finished
                    break;
                }
                else
                {
                    if (gLockState != nolock) //emergency call but not registered and no SIM
    					gemergencycall=3;
    				else //emergency call but not registered and SIM OK
    					gemergencycall=2;	

                    // search for provider
    				while(provider == 0)
    					provider = random(4);
	            
                    putvalue(env_FSG_NetworkProviderState, 1);
    				//putvalue(env_FSG_networkprovider, provider); //new provider
                }
            }
            else
            {
                gemergencycall = (is_emergency_call == 1) ? 1 : 0;
               
                if(gConfirmCall == 1) // call needs to be confirmed manually ?
                 {
                    //write("call needs confirmation");                    

                    gCallOutgoingDiverted_eCallConfirmationPending[7] = 1;
                    CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = true
                    
                    //IssueList #160 MR49588
                    //setTimer (checkEcallConfirmPending,5); //addition of assumed 5 second time out for confirmPending flag check
                    //IssueList #167
                    setTimer (checkEcallConfirmPending,10); //changed to 10s
       
                    //IssueList #104
                    //changes from Jan Swoboda 21.06.2012
		            gAcknowledgePending[FctID_CallState] = 1;
                    gDialNumber_Result = 0x0a; // not successful - confirm emergency call
                    //changes from Jan Swoboda 21.06.2012
		            settimer(dialnumber_result_timer, 20);
                    //DialNumber_Request(Result_REQ, 0);
                   
                }
                else
                {
                    //write("call does not need confirmation");

                    gcallID = callstates_status(dialing); //aks for free Call-ID

                    //MR60227
                if (getValue(env_PIC_bapMOST_active_flag)==0x01)
                {
                 gBapMostCallID= gcallID;
                 gActiveCall_active = 1;
                 gActiveCall_CallMethodActive=1;
                 gActiveCall_Dialled =1;
                 setActiveCall_Picture();

                if (gActiveCall_BAPdelayFlag==0)
                settimer(checknetworktimer, gtime_checknetworktimer);					//start timer for searching in phonebook
                else
                settimer(checknetworktimer, getValue(env_AudioTel_bapMost_delayTimer)*1000);
                } 

                    
                    if(gcallID == 0xff)
                    {
                        DialNumber_Request(Error_REQ, Terror_activecallpresentdialing);	//send error
						gDialNumber_status = 0;
                        break;
                    }
                    
                    if (getValue(env_PIC_bapMOST_active_flag)==0x00)
                    settimer(checknetworktimer, gtime_checknetworktimer);
                }               
            }
            }//issueList #74
            else
            gTelFctList_0x1A_TimeOut_flg = 0x01;
             break;
          
        case Abort_IND:
            //IssueList #81
            //gDialNumber_Result = ABORT_SUCCESSFUL;
            gDialNumber_Result = result;
            DialNumber_Request(Result_REQ, 0);
            break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone dialnumber indication: unknown indication %d", indication);
		    break;
	}
}

NetworkProvider_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

	
//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch (request){
		case Data_REQ:
            //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x14_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_NetworkProvider;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gNetworkProviderState;

            requestarray[4]=strlen(gNetworkProviderName);
			Offset=5;		
    			for(i=0;i<strlen(gNetworkProviderName);i++)
                {
    				requestarray[Offset]=gNetworkProviderName[i];
    				Offset++;
    			}

			requestarray[Offset]=gServiceProviderState;
			Offset++;

            requestarray[Offset]=strlen(gServiceProviderName);
            Offset++;
    			for(i=0;i<strlen(gServiceProviderName);i++)
                {
    				requestarray[Offset]=gServiceProviderName[i];
    				Offset++;
    			}
			
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_NetworkProvider;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone NetworkProvider_Request: unknown request %d", request);
		break;
	}
}

byte get_requestbuffer_line()	//function to reserve memory in request-ring-buffer
{
int line;

//init lokal variables
	line=0;
//********************	
	
	line=gwrite_requestbuffer_line;							//next free element in  ring-buffer

	if(gwrite_requestbuffer_line<(Requestbuffer_lines-1))	//last element of ring-buffer is not reached
		gwrite_requestbuffer_line++;
	else													//last element of ring-buffer is reached
		gwrite_requestbuffer_line=0;
	
	return (line);											//return position of free ring-buffer element
}

set_status_requestbuffer (dword Request_array [], int length, byte BAPDataType)	//function to write data in request-ring-buffer
{
int bufferline, Offset, i;

//init lokal variables
	Offset=0;
	bufferline=0;
//********************

	bufferline=get_requestbuffer_line();					//get next free position in ring-buffer

	for(i=0;i<length;i++)									//write data in ring-buffer
		gBAP_Request[bufferline][i]=Request_array[i];			

	gBAP_Requestbufffer_status[bufferline]=length;			//datalength
	gBAP_Requestbufffer_BAPDataTyp[bufferline]=BAPDataType;	//BAP-data-type
    //if(gdebug)
    //    write("set_status_requestbuffer erfolgreich mit BAP Data Type: %d", BAPDataType);//bap150 - debug
}

byte callstates_status (byte event)
{
int i, finish, freecallstate;

//init lokal variables
	finish=0;
	freecallstate=0xff;
//********************

	//write("CallState_status event: %d", event);						//debug

	switch(event){
		case ringing_waiting:
		//	write("CallState_status ringing_waiting");				//debug
			if(gCallActivity==NOCALL){								//all callID's "idle"
				freecallstate=0;
				return(freecallstate);
			}
			else{													//one or more callID are not "idle"
				for(i=0;finish!=1;i++){								//check status of each callID
					switch(gCallState [i]){
						case idle:
							if(freecallstate==0xff)
								freecallstate=i;
						break;
						case dialing:
							freecallstate=0xff;						//no incoming call possible
							finish=1;								//loop finished
						break;
						case disconnecting:
							freecallstate=0xff;						//no incoming call  possible
							finish=1;								//loop finished
						break;
						default:
						break;
					}
					if (i==6 && finish==0)							//last element is reached and loop in't finished yet
						finish=1;									//loop finished
				}
				return(freecallstate);
			}
		break;
		case dialing:
		//	write("CallState_status dialing");						//debug
			if(gCallActivity==NOCALL){								//all callID's "idle"
				freecallstate=0;
				return(freecallstate);
			}
			else{													//one or more callID are not "idle"
				for(i=0;finish!=1;i++){								//check status of each callID
					switch(gCallState [i]){
						case idle:
							if(freecallstate==0xff)
								freecallstate=i;
						break;
						case onhold:
						break;
                        case INCOMING_ON_HOLD:
                        break;
						default:									//one callID status is "active/dialing/disconnecting"
							freecallstate=0xff;						//no dialing possible
							finish=1;								//loop finished
						break;
					}
					if (i==6 && finish==0)							//last element is reached and loop in't finished yet
						finish=1;									//loop finished
				}
				return(freecallstate);
			}
		break;
		default:
			write("FSG-Telephone CallState_status invalid event: %d", event);
		//	return(freecallstate);
		break;
	}
    // changes from Jan Swoboda (01.03.2012)
    return(freecallstate);
}

DialNumber_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************


	length=strlen(gDialNumber);

	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_DialNumber;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x1A_Processing_flg == 0x00)
            {
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_DialNumber;	//Fct.-ID
			requestarray[2]=request;
            requestarray[3]=gDialNumber_Result;	
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);

                if (gDialNumber_Result==0x00)
                {
                	//IssueList #26
                    putvalue(env_FSG_DialNumber_TelNumber_M, gDialNumber);
                    //IssueList #16
                    putvalue(env_FSG_AutoRedialExtInfo_TelNo, gDialNumber);
                                //IssueList #26
                    if (gDialbuttonOn==0x00)
                    {
                    putvalue(env_FSG_DialNumber_Name_M, gDialNumber_name);
                    //IssueList #16
                    putvalue(env_FSG_AutoRedialExtInfo_Name, gDialNumber_name);
                    }
            
                 
                }
                if (gActiveCall_CallMethodActive ==0x01)
                gActiveCall_CallMethodActive=0x00;
            
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_DialNumber;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
            //IssueList #68
            cancelTimer(TelFctList_0x1A_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone DialNumber_Request: unknown request %d", request);
		break;
	}

}

telephone_functions (byte functionID, int datalength)	
{

	switch (functionID){
		case FctID_FSG_Setup:
			FSG_Setup_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_FSG_OperationState:
			FSG_OperationState_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_MobilServiceSupport:
			MobilServiceSupport_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_ActiveUser:	
			ActiveUser_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_RegisterState:	
			RegisterState_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_LockState:
			LockState_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_NetworkProvider:	
			NetworkProvider_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_SignalQuality:
			SignalQuality_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_CallState:	
			CallState_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_CallInfo:	
			CallInfo_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_CallDurationSync:	
			CallDurationSync_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_DisconnectReason:	
			DisconnectReason_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_DialNumber:	
			DialNumber_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_DialService:	
			DialService_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_ConfirmEmergencyCall:	
			ConfirmEmergencyCall_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_HangupCall:	
			HangupCall_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_AcceptCall:
            AcceptCall_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_CallHold:
			CallHold_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_ResumeCall:
			ResumeCall_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_HandsFreeOnOff:	
			HandsFreeOnOff_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_MicroMuteOnOff:	
			        //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x22_TimeOut)!=TRUE)
              MicroMuteOnOff_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_MPReleaseActiveCallAcceptWaitingCall:
			MPRACAWC_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_MPSwap:
			MPSwap_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_MPCallHoldAcceptWaitingCall:
			MPCHAWC_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_MPReleaseAllCallsAcceptWaitingCall:
			MPRAllCAWC_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_MPSetWaitingCallOnHold:
			MPSWCOH_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_CCJoin:
			CCJoin_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_CCSplit:
			CCSplit_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_Keypad:
			Keypad_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_MobileBatteryLevel:
			MobileBatteryLevel_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_DataConnectionIndication:
			DataConnectionIndication_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_MissedCallIndication:
			MissedCallIndication_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
/*
        case FctID_MissedCalls:
			MissedCalls_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_ReceivedCalls:
			ReceivedCalls_Indication(gBAP_Indication);
		break;
		case FctID_DialedNumbers:
			DialedNumbers_Indication(gBAP_Indication);
		break;
*/
        case FctID_CombinedNumbers:
			CombinedNumbers_Indication(gBAP_Indication);
		break;
		case FctID_CallStackDeleteAll:
			CallStackDeleteAll_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_PbState:
			PbState_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_Phonebook:
			Phonebook_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_FavoriteList:
			FavoriteList_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_PbSpeller:
			PbSpeller_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_GetNextListPos:
			GetNextListPos_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_SMSState:
			SMSState_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_RingToneMuteOnOff:
			RingToneMuteOnOff_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        case FctID_AutomaticRedial:
			AutomaticRedial_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
        //IssueList #16
        case FctID_AutomaticRedialExtInfo:
			AutomaticRedialExtInfo_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone telephone_functions: unknown funcion-ID %d", functionID);
		break;
	}	

}

on timer checknetworktimer
{
    int length;
    //IssueList #206
     int strlength, i;

	//init lokal variables
	length=0;
	//********

//changes from Jöran Karl (28.03.2012)
    if(getvalue(env_FSG_DisconnectReason_Active) != FALSE)
    {
    	gDisconnectReason=connectedline_busy;
    	putvalue(env_FSG_DisconnectReason, gDisconnectReason);
    	DisconnectReason_Request (Data_REQ, 0);	//send Disconnect Reason
	}

	//call info
    if (gcallID <7)
	{
        strncpy(gCallInfo_PbName[gcallID], gDialNumber_name, CALL_INFO_NAME_LENGTH);
    	strncpy(gCallInfo_TelNumber[gcallID], gDialNumber, CALL_INFO_NUMBER_LENGTH);
    

    	//IssueList #206 -s
        strlength = strlen(gDialNumber_name);
        for(i = 0; i < CALL_INFO_NAME_LENGTH; i++)
        {
            if(i < strlength)                    
                gCallInfo_PbName_hex[gcallID][i] = gDialNumber_name[i];
            else
                gCallInfo_PbName_hex[gcallID][i] = 0;
        }

    }
    //IssueList #206 -e

	//changes from Jöran Karl (28.03.2012)
	putvalue_CallInfo(gcallID);

	CallInfo_Request(Data_REQ,0);
	settimer(dialnumber_changearraytimer, 300);
	gstatus_dialnumber_changearraytimer=1;

	

}

DisconnectReason_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************
//IssueList #26
gDialbuttonOn = 0;


	switch(request)
	{
		case Data_REQ:
              //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x19_TimeOut)!=TRUE)
            {
    			requestarray[0]=LSGID_Telephone;	//LSG-ID
    			requestarray[1]=FctID_DisconnectReason;	//Fct.-ID
    			requestarray[2]=request;	
    			requestarray[3]=gDisconnectReason;
    			Offset=4;
    			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);

            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_DisconnectReason;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone DisconnectReason_Request: unknown request %d", request);
		break;
	}
}

// changes from Jan Swoboda (01.03.2012)
set_CallState_noReq (byte callid, byte callstate)
{
// JanSwo 20120110: noReq for for-loops
int i, duration,ctr1,ctr2;
byte num_active_calls;
char empty_string [3];
byte any_hold_call;
byte any_active_call;
//IssueList #88
byte num_current_calls;
byte conference_members;

//BAP_MOST sync
byte activeCallPictureType;
byte bapMost_callid;

//init lokal variables
	num_active_calls=0;
	duration=0;
	for(i=0;i<3;i++)
		empty_string[i]=0;
    any_hold_call=0;
    any_active_call=0;
    num_active_calls=0;
    num_current_calls=0;
    conference_members = 0;

    activeCallPictureType = 0;
    gBapMostCallID = 0;
//********************

	if(callid<7)      								//only one special callid should be set
	{
		gCallState[callid]=callstate;								//set call state
        //write("new callstate %d", gCallState[callid]);  //debug
        
        //***********rate active calls and calls on hold*************
        for(i=0;i<7;i++)
        {
            if(gCallState[i]==active)   // for active calls
                any_active_call=TRUE;
                
            else if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)   // for hold calls
                any_hold_call=TRUE;
            
            //IssueList #111
            if (gCallState[i]!=idle)
            num_current_calls++;

        }
        //***********************************************************
        //write("active calls %d, hold calls %d", any_active_call, any_hold_call);  //debug

		switch(callstate)
		{
			case idle:
				gCallType[callid]=unknowncalltype;
                gCallOptions[callid]=FALSE;	        //Deactivate all CallOptions for this CallID
                gCallIncomingDiverted[callid]=0;

				
				for(i=0;i<7;i++)    //Check other CALLIDs and set corresponding CallOptions
				{
					if(gCallState[i]==active)   // for active calls
                    {
                        if(any_hold_call)
                            gCallOptions[i]= MP_SWAP + CC_JOIN;
                        else //no call on hold
                            gCallOptions[i]= CALL_HOLD;

						num_active_calls++;//calculate number of active calls
                    }

                    else if(gCallState[i]==ringing_waiting)   // for ringing/waiting calls
                    {
                        if(any_active_call && any_hold_call)        //both active and hold calls
                            gCallOptions[i]= MP_RACAWC;
                        else if(any_active_call && !any_hold_call)  //only active calls
                            gCallOptions[i]= MP_CHAWC + MP_RACAWC + CALL_HOLD;
                        else if(!any_active_call && any_hold_call)  //only hold calls
                            gCallOptions[i]= ACCEPT_CALL;
                    }

                    else if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)   // for hold calls
                    {
                        if(any_active_call)
                            gCallOptions[i]= MP_SWAP + CC_JOIN;
                        else //no active call
                            gCallOptions[i]= RESUME_CALL;
                    }
				}
				
				//if only one call is active, set it on SINGLE_VOICE_CALL
				if(num_active_calls==1)
				{
					for(i=0;i<7;i++)
					{
						if(gCallState[i]==active && gCallType[i]==CONFERENCE_VOICE_CALL)	//type of active call is "conference"
						{
							gCallType[i]=       SINGLE_VOICE_CALL;					//set call type to "regular voice call"
                            gCallOptions[i]=    CALL_HOLD;
							i=7;                                                    //break loop
						}
					}
				}
			break;
			case dialing:
				if(gemergencycall!=0)													//emergency call
					gCallType[callid]=emergencycall;									//set call type
				else if(strncmp(gDialNumber, info, CALL_INFO_NUMBER_LENGTH)==0)								//info call
					gCallType[callid]=infocall;
				else if(strncmp(gDialNumber, service, CALL_INFO_NUMBER_LENGTH)==0)							//service call
					gCallType[callid]=servicecall;
				else																	//no emergency, info or service call
					gCallType[callid]=SINGLE_VOICE_CALL;						        //set calltype
                
                //MR 63763: Scenario 2: code commented
                /*for(i=0;i<7;i++)    //Check other CALLIDs and set corresponding CallOptions
				{
					if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)   // for hold calls
                        gCallOptions[i]=FALSE;	        //Deactivate all CallOptions for call on hold
                }
                */
                //MR63666
                if (getValue(env_PIC_bapMOST_active_flag)==0x00) //nonCoupled
                {
                 if (getValue(env_PIC_bapMOST_setImage_Cat) == 0x01)   //ActiveCall
                 {
                    if (getValue(env_FSG_MOST_ActiveCallPicType_NC)> 0x00 && getValue(env_FSG_MOST_ActiveCallPicType_NC)< 0x06) //not NoPicture/DefaultPicture
                    {
                    putValue(env_PIC_bapMOST_setImage_button,1);
                    setTimer (_tReleaseSetImage_button,50);
                    }
                 }  
                }
			break;
			case ringing_waiting:
				gCallType[callid]=gincomingcall_calltype;
				gCallIncomingDiverted[callid]=getvalue(env_FSG_IncomingCall_Divert);

				if(any_active_call && any_hold_call)        //both active and hold calls
                    gCallOptions[callid]= MP_RACAWC;
                else if(any_active_call && !any_hold_call)  //only active calls
                    gCallOptions[callid]= MP_CHAWC + MP_RACAWC + CALL_HOLD;
                else if(!any_active_call)  //no active calls
                    gCallOptions[callid]= ACCEPT_CALL;

 		//MR63666
                if (getValue(env_PIC_bapMOST_active_flag)==0x00) //nonCoupled
                {
                 if (getValue(env_PIC_bapMOST_setImage_Cat) == 0x01)   //ActiveCall
                 {
                    if (getValue(env_FSG_MOST_ActiveCallPicType_NC)> 0x00 && getValue(env_FSG_MOST_ActiveCallPicType_NC)< 0x06) //not NoPicture/DefaultPicture
                    {
                    putValue(env_PIC_bapMOST_setImage_button,1);
                    setTimer (_tReleaseSetImage_button,100);
                    }
                 }  
                }
			break;
            case active:
                if(any_hold_call)
                    gCallOptions[callid]= MP_SWAP + CC_JOIN; //activate calloptions for active call
                else    //no hold call
                    gCallOptions[callid]= CALL_HOLD; //activate calloptions for active call

                for(i=0;i<7;i++)    //Check other CALLIDs
				{
					if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)   // for hold calls
                        {
                        gCallOptions[i]= MP_SWAP + CC_JOIN;       //activate calloptions for call on hold
                        }

                    else if(gCallState[i]==ringing_waiting)
                    {
                        if(any_active_call && any_hold_call)        //both active and hold calls
                            gCallOptions[i]= MP_RACAWC;
                        else if(any_active_call && !any_hold_call)  //only active calls
                            gCallOptions[i]= MP_CHAWC + MP_RACAWC + CALL_HOLD;
                    }

                    else if(gCallState[i]==active) //another active call in conference
                    {
                        if(any_hold_call)
                            gCallOptions[i]= MP_SWAP + CC_JOIN; //activate calloptions for active call
                        else    //no hold call
                            gCallOptions[i]= CALL_HOLD; //activate calloptions for active call
                    
                    if (getValue(env_PIC_bapMOST_active_flag) == 0x01 && gActiveCall_HangUpPressed == 0x01) //MR59817
                    bapMost_callid = i;
                    }
				}

                //BAP_MOST sync
                gActiveCall_active = 0;
                 if (getValue(env_PIC_bapMOST_active_flag) == 0x01)
                 {
                     if (gActiveCall_HangUpPressed == 0x01) //MR59817
                     {
                     gBapMostCallID= bapMost_callid;
                     gActiveCall_active = 1;
                     setActiveCall_Picture();
                     gActiveCall_HangUpPressed = 0;
                     }

                 } //MOST_active_flag*/
                   //MR63666
                /*else if (getValue(env_PIC_bapMOST_active_flag)==0x00) //nonCoupled
                {
                 if (getValue(env_PIC_bapMOST_setImage_Cat) == 0x01)   //ActiveCall
                 {
                    if (getValue(env_FSG_MOST_ActiveCallPicType_NC)> 0x00 && getValue(env_FSG_MOST_ActiveCallPicType_NC)< 0x06) //not NoPicture/DefaultPicture
                    {
                    putValue(env_PIC_bapMOST_setImage_button,1);
                    setTimer (_tReleaseSetImage_button,100);
                    }
                 }  
                }*/
                //BAP_MOST sync - end
            break;
            case onhold:
                if(any_active_call)
                    gCallOptions[callid]= MP_SWAP + CC_JOIN;
                else //no active call
                    gCallOptions[callid]= RESUME_CALL;
                
                for(i=0;i<7;i++)    //Check other CALLIDs
				{
                    if(gCallState[i]==ringing_waiting)
                    {
                        if(any_active_call)
                            gCallOptions[i]= MP_CHAWC + MP_RACAWC;
                        else    //no active call
                            gCallOptions[i]= ACCEPT_CALL;
                    }

                    else if(gCallState[i]==active)  //for active calls
                    {
                        gCallOptions[i]= MP_SWAP + CC_JOIN;
                        bapMost_callid = i;
                    }

                    else if(gCallState[i]==onhold) //another hold call in conference
                    {
                        if(any_active_call)
                            gCallOptions[i]= MP_SWAP + CC_JOIN; //activate calloptions for hold call
                        else    //no active call
                            gCallOptions[i]= RESUME_CALL; //activate calloptions for hold call

                    if (getValue(env_PIC_bapMOST_active_flag) == 0x01 && gActiveCall_HangUpPressed == 0x01) //MR59817
                    bapMost_callid = i;
                    }
				}
                //BAP_MOST sync
                gActiveCall_active = 0;
                 if (getValue(env_PIC_bapMOST_active_flag) == 0x01)
                 {
                     if (gActiveCall_HangUpPressed == 0x01) //MR59817
                     {
                     gBapMostCallID= bapMost_callid;
                     gActiveCall_active = 1;
                     setActiveCall_Picture();
                     gActiveCall_HangUpPressed = 0;
                     }

                 } //MOST_active_flag*/
                //BAP_MOST sync - end
            break;
            case INCOMING_ON_HOLD:
                if(any_active_call)
                    gCallOptions[callid]= MP_SWAP + CC_JOIN;
                else //no active call
                    gCallOptions[callid]= RESUME_CALL;
                
                for(i=0;i<7;i++)    //Check other CALLIDs
				{
                    if(gCallState[i]==ringing_waiting)
                    {
                        if(any_active_call)
                            gCallOptions[i]= MP_CHAWC + MP_RACAWC;
                        else    //no active call
                            gCallOptions[i]= ACCEPT_CALL;
                    }

                    else if(gCallState[i]==active)  //for active calls
                        gCallOptions[i]= MP_SWAP + CC_JOIN; 
				}
            break;   
            //IssueList #79 - MR50008
            case disconnecting:
              
             gCallOptions[callid] = FALSE;

            //Related Issues: IssueList# 79,88, 110, 111, 122
            //if ((num_current_calls==0x02) && (allCallsHangUpFlg == 0x00))
            //MR61324
            if ((num_current_calls>=0x02) && (allCallsHangUpFlg == 0x00))
            {
                for(i=0;i<7;i++)
                //MR 63764 - conference
                if (gCallType[i] ==0x05 && (gCallState[i] ==active ||gCallState[i] ==onhold))
                conference_members++;

                for(i=0;i<7;i++)
                {
                if (gCallType[i] ==0x05 && conference_members<2 && callid != i)
                gCallType[i] = 0x01;
                }

                //MR 63764
               gCallType[callid] = 0x01;
            }

             //MR61158 - set the CallOption to CallHold of Active call if the other(onHold) is disconnecting 
             //callid = disconnecting
             for(i=0;i<7;i++)
             {
                    if (callid!=i)
                    {
                    if (gCallState[i] ==active &&  gCallOptions[i]== MP_SWAP + CC_JOIN) //active
                    gCallOptions[i] = CALL_HOLD;
                    
                    //MR63763
                    else if (gCallState[i] ==INCOMING_ON_HOLD &&  gCallOptions[i]== MP_SWAP + CC_JOIN) //active
                    gCallOptions[i]= RESUME_CALL;
                 
                    }
              }
            
            //MR61158
            if (allCallsHangUpFlg == 1) //all active
            {
                for(i=0;i<7;i++)
                {
                    if (callid!=i)
                    {
                    if (gCallState[i] ==onhold &&  gCallOptions[i]== MP_SWAP + CC_JOIN) //on hold
                    gCallOptions[i]= RESUME_CALL;
                    }
                }
            }
	    //MR59817
             if (getValue(env_PIC_bapMOST_active_flag) == 0x01 && gActiveCall_HangUpPressed == 0x01) 
             gActiveCall_HangUpPressed = 0;
            break;


			default:
			break; 
		}
	
		//************CallActivity*************
		gCallActivity=NOCALL;
	
		for(i=0;i<7;i++)
        {
			if(gCallState[i]!=idle)
            {
				if(gCallActivity<MULTIPARTYCALL)
					gCallActivity++;
			}
		}

		putvalue(env_FSG_CallActivity, gstring_callactivity[gCallActivity]);
		//*************************************

		//**************MicroMute**************
		//if(gCallActivity==NOCALL)
		//{
		//	putvalue(env_FSG_MicroMuteOnOff, gMicroMute);
		//}
		//*************************************

		//**********CallStates*****************
        //		case 0:
        putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
        if(gCallState[0]==idle)
        {
            putvalue(env_FSG_CallType_CallID_0, empty_string);
            putvalue(env_FSG_CallState_CallDivert_0, empty_string);
        }
        else
        {
            putvalue(env_FSG_CallType_CallID_0, gstring_calltype[gCallType[0]]);
            putvalue(env_FSG_CallState_CallDivert_0, gstring_CallDivert[gCallIncomingDiverted[0]]);
        }
        //		case 1:
        putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
        if(gCallState[1]==idle)
        {
            putvalue(env_FSG_CallType_CallID_1, empty_string);
            putvalue(env_FSG_CallState_CallDivert_1, empty_string);
        }
        else
        {
            putvalue(env_FSG_CallType_CallID_1, gstring_calltype[gCallType[1]]);
            putvalue(env_FSG_CallState_CallDivert_1, gstring_CallDivert[gCallIncomingDiverted[1]]);
        }
        //		case 2:
        putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
        if(gCallState[2]==idle)
        {
            putvalue(env_FSG_CallType_CallID_2, empty_string);
            putvalue(env_FSG_CallState_CallDivert_2, empty_string);
        }
        else
        {
            putvalue(env_FSG_CallType_CallID_2, gstring_calltype[gCallType[2]]);
            putvalue(env_FSG_CallState_CallDivert_2, gstring_CallDivert[gCallIncomingDiverted[2]]);
        }
        //		case 3:
        putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
        if(gCallState[3]==idle)
        {
            putvalue(env_FSG_CallType_CallID_3, empty_string);
            putvalue(env_FSG_CallState_CallDivert_3, empty_string);
        }
        else
        {
            putvalue(env_FSG_CallType_CallID_3, gstring_calltype[gCallType[3]]);
            putvalue(env_FSG_CallState_CallDivert_3, gstring_CallDivert[gCallIncomingDiverted[3]]);
        }
        //		case 4:
        putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
        if(gCallState[4]==idle)
        {
            putvalue(env_FSG_CallType_CallID_4, empty_string);
            putvalue(env_FSG_CallState_CallDivert_4, empty_string);
        }
        else
        {
            putvalue(env_FSG_CallType_CallID_4, gstring_calltype[gCallType[4]]);
            putvalue(env_FSG_CallState_CallDivert_4, gstring_CallDivert[gCallIncomingDiverted[4]]);
        }
        //		case 5:
        putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
        if(gCallState[5]==idle)
        {
            putvalue(env_FSG_CallType_CallID_5, empty_string);
            putvalue(env_FSG_CallState_CallDivert_5, empty_string);
        }
        else
        {
            putvalue(env_FSG_CallType_CallID_5, gstring_calltype[gCallType[5]]);
            putvalue(env_FSG_CallState_CallDivert_5, gstring_CallDivert[gCallIncomingDiverted[5]]);
        }
        //		case 6:
        putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
        if(gCallState[6]==idle)
        {
            putvalue(env_FSG_CallType_CallID_6, empty_string);
            putvalue(env_FSG_CallState_CallDivert_6, empty_string);
        }
        else
        {
            putvalue(env_FSG_CallType_CallID_6, gstring_calltype[gCallType[6]]);
            putvalue(env_FSG_CallState_CallDivert_6, gstring_CallDivert[gCallIncomingDiverted[6]]);
        }

		//***********Display Calloptions****************
        putvalue(env_FSG_CallState_Opt_AcCall_0,gCallOptions[0] &0x01);         //Bit0
        putvalue(env_FSG_CallState_Opt_HoldAc_0,(gCallOptions[0] &0x02)/0x02);  //Bit1
        putvalue(env_FSG_CallState_Opt_CallAc_0,(gCallOptions[0] &0x04)/0x04);  //Bit2
        putvalue(env_FSG_CallState_Opt_CallHold_0,(gCallOptions[0] &0x08)/0x08);//Bit3
        putvalue(env_FSG_CallState_Opt_ResCall_0,(gCallOptions[0] &0x10)/0x10); //Bit4
        putvalue(env_FSG_CallState_Opt_MPSwap_0,(gCallOptions[0] &0x20)/0x20);  //Bit5
        putvalue(env_FSG_CallState_Opt_CCJoin_0,(gCallOptions[0] &0x40)/0x40);  //Bit6
		putvalue(env_FSG_CallState_Opt_CCSplit_0,(gCallOptions[0] &0x80)/0x80); //Bit7
        
        putvalue(env_FSG_CallState_CallInDivert_0,gCallIncomingDiverted[0]);     //Bit0
        putvalue(env_FSG_CallState_CallOuDivert_0,gCallOutgoingDiverted_eCallConfirmationPending[0]);    //Bit0

        putvalue(env_FSG_CallState_Opt_AcCall_1,gCallOptions[1] &0x01);         //Bit0
        putvalue(env_FSG_CallState_Opt_HoldAc_1,(gCallOptions[1] &0x02)/0x02);  //Bit1
        putvalue(env_FSG_CallState_Opt_CallAc_1,(gCallOptions[1] &0x04)/0x04);  //Bit2
        putvalue(env_FSG_CallState_Opt_CallHold_1,(gCallOptions[1] &0x08)/0x08);//Bit3
        putvalue(env_FSG_CallState_Opt_ResCall_1,(gCallOptions[1] &0x10)/0x10); //Bit4
        putvalue(env_FSG_CallState_Opt_MPSwap_1,(gCallOptions[1] &0x20)/0x20);  //Bit5
        putvalue(env_FSG_CallState_Opt_CCJoin_1,(gCallOptions[1] &0x40)/0x40);  //Bit6
		putvalue(env_FSG_CallState_Opt_CCSplit_1,(gCallOptions[1] &0x80)/0x80); //Bit7
        
        putvalue(env_FSG_CallState_CallInDivert_1,gCallIncomingDiverted[1]);     //Bit1
        putvalue(env_FSG_CallState_CallOuDivert_1,gCallOutgoingDiverted_eCallConfirmationPending[1]);    //Bit1

        putvalue(env_FSG_CallState_Opt_AcCall_2,gCallOptions[2] &0x01);         //Bit0
        putvalue(env_FSG_CallState_Opt_HoldAc_2,(gCallOptions[2] &0x02)/0x02);  //Bit1
        putvalue(env_FSG_CallState_Opt_CallAc_2,(gCallOptions[2] &0x04)/0x04);  //Bit2
        putvalue(env_FSG_CallState_Opt_CallHold_2,(gCallOptions[2] &0x08)/0x08);//Bit3
        putvalue(env_FSG_CallState_Opt_ResCall_2,(gCallOptions[2] &0x10)/0x10); //Bit4
        putvalue(env_FSG_CallState_Opt_MPSwap_2,(gCallOptions[2] &0x20)/0x20);  //Bit5
        putvalue(env_FSG_CallState_Opt_CCJoin_2,(gCallOptions[2] &0x40)/0x40);  //Bit6
		putvalue(env_FSG_CallState_Opt_CCSplit_2,(gCallOptions[2] &0x80)/0x80); //Bit7
        
        putvalue(env_FSG_CallState_CallInDivert_2,gCallIncomingDiverted[2]);     //Bit2
        putvalue(env_FSG_CallState_CallOuDivert_2,gCallOutgoingDiverted_eCallConfirmationPending[2]);    //Bit2

        putvalue(env_FSG_CallState_Opt_AcCall_3,gCallOptions[3] &0x01);         //Bit0
        putvalue(env_FSG_CallState_Opt_HoldAc_3,(gCallOptions[3] &0x02)/0x02);  //Bit1
        putvalue(env_FSG_CallState_Opt_CallAc_3,(gCallOptions[3] &0x04)/0x04);  //Bit2
        putvalue(env_FSG_CallState_Opt_CallHold_3,(gCallOptions[3] &0x08)/0x08);//Bit3
        putvalue(env_FSG_CallState_Opt_ResCall_3,(gCallOptions[3] &0x10)/0x10); //Bit4
        putvalue(env_FSG_CallState_Opt_MPSwap_3,(gCallOptions[3] &0x20)/0x20);  //Bit5
        putvalue(env_FSG_CallState_Opt_CCJoin_3,(gCallOptions[3] &0x40)/0x40);  //Bit6
		putvalue(env_FSG_CallState_Opt_CCSplit_3,(gCallOptions[3] &0x80)/0x80); //Bit7
        
        putvalue(env_FSG_CallState_CallInDivert_3,gCallIncomingDiverted[3]);     //Bit3
        putvalue(env_FSG_CallState_CallOuDivert_3,gCallOutgoingDiverted_eCallConfirmationPending[3]);    //Bit3

        putvalue(env_FSG_CallState_Opt_AcCall_4,gCallOptions[4] &0x01);         //Bit0
        putvalue(env_FSG_CallState_Opt_HoldAc_4,(gCallOptions[4] &0x02)/0x02);  //Bit1
        putvalue(env_FSG_CallState_Opt_CallAc_4,(gCallOptions[4] &0x04)/0x04);  //Bit2
        putvalue(env_FSG_CallState_Opt_CallHold_4,(gCallOptions[4] &0x08)/0x08);//Bit3
        putvalue(env_FSG_CallState_Opt_ResCall_4,(gCallOptions[4] &0x10)/0x10); //Bit4
        putvalue(env_FSG_CallState_Opt_MPSwap_4,(gCallOptions[4] &0x20)/0x20);  //Bit5
        putvalue(env_FSG_CallState_Opt_CCJoin_4,(gCallOptions[4] &0x40)/0x40);  //Bit6
		putvalue(env_FSG_CallState_Opt_CCSplit_4,(gCallOptions[4] &0x80)/0x80); //Bit7
        
        putvalue(env_FSG_CallState_CallInDivert_4,gCallIncomingDiverted[4]);     //Bit4
        putvalue(env_FSG_CallState_CallOuDivert_4,gCallOutgoingDiverted_eCallConfirmationPending[4]);    //Bit4

        putvalue(env_FSG_CallState_Opt_AcCall_5,gCallOptions[5] &0x01);         //Bit0
        putvalue(env_FSG_CallState_Opt_HoldAc_5,(gCallOptions[5] &0x02)/0x02);  //Bit1
        putvalue(env_FSG_CallState_Opt_CallAc_5,(gCallOptions[5] &0x04)/0x04);  //Bit2
        putvalue(env_FSG_CallState_Opt_CallHold_5,(gCallOptions[5] &0x08)/0x08);//Bit3
        putvalue(env_FSG_CallState_Opt_ResCall_5,(gCallOptions[5] &0x10)/0x10); //Bit4
        putvalue(env_FSG_CallState_Opt_MPSwap_5,(gCallOptions[5] &0x20)/0x20);  //Bit5
        putvalue(env_FSG_CallState_Opt_CCJoin_5,(gCallOptions[5] &0x40)/0x40);  //Bit6
		putvalue(env_FSG_CallState_Opt_CCSplit_5,(gCallOptions[5] &0x80)/0x80); //Bit7
        
        putvalue(env_FSG_CallState_CallInDivert_5,gCallIncomingDiverted[5]);     //Bit5
        putvalue(env_FSG_CallState_CallOuDivert_5,gCallOutgoingDiverted_eCallConfirmationPending[5]);    //Bit5

        putvalue(env_FSG_CallState_Opt_AcCall_6,gCallOptions[6] &0x01);         //Bit0
        putvalue(env_FSG_CallState_Opt_HoldAc_6,(gCallOptions[6] &0x02)/0x02);  //Bit1
        putvalue(env_FSG_CallState_Opt_CallAc_6,(gCallOptions[6] &0x04)/0x04);  //Bit2
        putvalue(env_FSG_CallState_Opt_CallHold_6,(gCallOptions[6] &0x08)/0x08);//Bit3
        putvalue(env_FSG_CallState_Opt_ResCall_6,(gCallOptions[6] &0x10)/0x10); //Bit4
        putvalue(env_FSG_CallState_Opt_MPSwap_6,(gCallOptions[6] &0x20)/0x20);  //Bit5
        putvalue(env_FSG_CallState_Opt_CCJoin_6,(gCallOptions[6] &0x40)/0x40);  //Bit6
		putvalue(env_FSG_CallState_Opt_CCSplit_6,(gCallOptions[6] &0x80)/0x80); //Bit7
        
        putvalue(env_FSG_CallState_CallInDivert_6,gCallIncomingDiverted[6]);     //Bit6
        putvalue(env_FSG_CallState_CallOuDivert_6,gCallOutgoingDiverted_eCallConfirmationPending[6]);    //Bit6
	}  
// changes from Jan Swoboda (01.03.2012)
    gCallStateRequestPending = 1;



}

set_CallState (byte callid, byte callstate)
{
    set_CallState_noReq(callid, callstate);
	CallState_Request(Data_REQ,0);	//send call state
}

CallState_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//write("FSG: CallState_Request");

//init lokal variables
	Offset=0;
	
	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch (request){
		case Data_REQ:
             //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x16_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_CallState;	//Fct.-ID
			requestarray[2]=request;	
            //changes from Jöran Karl (28.03.2012)
        	    Offset = 3;

        	//changes from Jöran Karl (28.03.2012)
        			for (i = 0; i < 7; i++)
                    {
                        requestarray[Offset++]=(gCallType[i]+gCallState[i]*0x10);	//call state (upper nibble) and call type (lower nibble)
                        requestarray[Offset++]=gCallOptions[i];
                    }
			
        	//changes from Jöran Karl (28.03.2012)
        			for (i = 0; i < 7; i++)
                    {
                        requestarray[Offset] += gCallIncomingDiverted[i] << i;
                    }
                    //bit 7 reserved
                   //changes from Jöran Karl (28.03.2012)
        	    Offset++;
            
        			for (i = 0; i < 8; i++)
                    {
                        requestarray[Offset] += gCallOutgoingDiverted_eCallConfirmationPending[i] << i;
                    }
        			Offset++;
                    //MR60227 BAP_MOST delayTimer -s
                    for (i=0;i<Offset;i++)
                    gTel_CallStateArray[i]=0;

                    gTel_CSoffset = 0;
                    gTel_CSbapDataType =0;
                    
                    for (i=0;i<Offset;i++)
                    gTel_CallStateArray[i]=requestarray[i];

                    gTel_CSoffset = Offset;
                    gTel_CSbapDataType = Bap_ByteSequence;
                    //MR60227 BAP_MOST delayTimer -e
        			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);	//send CallState
                    // changes from Jan Swoboda (01.03.2012)
        	    gCallStateRequestPending = 0;
            }
		break;
		case Error_REQ:
			//BAP-header
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_CallState;	//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);	//send CallState
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone callstate_request: unknown request %d", request);
		break;
	}
}

on timer dialtimer
{
    //changes from Jöran Karl (28.03.2012)
    if(getvalue(env_FSG_DisconnectReason_Active) != FALSE)
    {
        //send Disconnect Reason
        gDisconnectReason=linebusy;
		putvalue(env_FSG_DisconnectReason, gDisconnectReason);
		DisconnectReason_Request(Data_REQ, 0);
    }
    
    //dialed number is busy
	if(getvalue(env_FSG_dialednumber_free_busy) == busy)
    {
		settimer(busy_hangup_timer,3000);
          //IssueList #26 - CANoe crash
           gFirstPress = 0x00;  
           //IssueList #49
        setTimer(_tfreeBusyTimer,3000);
	}

}

RegisterState_Request (byte request, byte errorcode)
{
int i;
word Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Data_REQ:
            //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x12_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_RegisterState;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gRegisterState;
            requestarray[4]=gNetworkType;
            requestarray[5]=gPacketDataNetworkType;
			Offset=6;
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_RegisterState;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone RegisterState_Request: unknown request %d", request);
		break;
	}
}

on envVar env_FSG_SIMstatus
{
int length;

//init lokal variables
	length=0;
//********************

/*	if(gFSG_Phone_PowerOnOff==Power_on){
		gSIM_status=getvalue(env_FSG_SIMstatus);
		length=strlen(gNetworkProvider);
	
		if(!gSIM_status){
			if(gCallActivity!=0)	//singel or multipaty call active
				Kill_Bill_Vol1();

			canceltimer(registerstatetimer);
			gRegisterState=notregisteredandnotsearching;
			putvalue(env_FSG_RegisterState, gstring_registerstate[gRegisterState]);
			registerstate_Request(Data_REQ, 0);	//send register state
			if (length!=0){
				strncpy(gNetworkProvider, gstring_networkprovider[0], 20);	//delete old name
				putvalue(env_FSG_networkprovider, 0);
				networkprovider_Request(Data_REQ, 0);	//send empty provider name
			}
		}
		else{
			gRegisterState=notregisterdandsearching;
			putvalue(env_FSG_RegisterState, gstring_registerstate[gRegisterState]);
			RegisterState_Request(Data_REQ, 0);	//send register state
		}
	}*/
}

on timer registerstatetimer
{

//init lokal variables

  //*******************
  NetworkProvider_Request(Data_REQ, 0);	  //send new provider name

  //IssueList #69

  //IssueList #131 - Aghil
  //Increased the time delay to 200, from 100.
  //Thus, the RegisterState.Status would be sent by FSG, only after all 
  //NetworkProvider.Status bytes have been already received by ASG. 
  //This probably avoids the flicker in display.
  //setTimer (registerstatetimerDelay,100);
  setTimer (registerstatetimerDelay, 200);
  
  
}

on timer nonetworktimer
{
	putvalue(env_FSG_NetworkProviderState, 0);
}

on timer busy_hangup_timer
{
	//IssueList #70
    //set_CallState(gcallID, disconnecting);

    if (gCallState[gcallID] == 0x07)        //REMOTE_SIDE_BUSY
    {
    set_CallState(gcallID, disconnecting);
    settimer(disconnectingtimer, disconnecttime);
    }
    else
    {
    set_CallState(gcallID, REMOTE_SIDE_BUSY);
    setTimer(busy_hangup_timer, 1000);
    }

}

on timer disconnectingtimer  //for hangup a single call
{
byte i, call_id;
//MR 63212
byte disconnecttime2;

//init lokal variables
	i=0;
	call_id=0xff;
//********************
//MR 63212
disconnecttime2 = disconnecttime;

//*******CallID******
	for(i=0;i<7;i++)
	{
		if(gCallState[i]==disconnecting)
			call_id=i;	
	}
//*******************

	if(call_id==0xff)	//error, no disconected callID was found
	{
		write("error disonnecting-timer, no disconnected call-id");
	}
	else
	{
		if (gCallType[call_id]==emergencycall && (gemergencycall==2 || gemergencycall==3)){//disconnected emergency call
			switch(gemergencycall)
			{
				case 2:
					gRegisterState=notregisterdandsearching;	//set register state
                    gNetworkType=UNKNOWN_NT;
                    gPacketDataNetworkType=NO_DATA_SERVICE;
				break;
				case 3:
					gRegisterState=notregisteredandnotsearching;	//set register state
                    gNetworkType=UNKNOWN_NT;
                    gPacketDataNetworkType=NO_DATA_SERVICE;
				break;
				default:
					write("error disconnectingtimer: invalid gemergencycall-value: %d",gemergencycall);
				break;
			}
			
			putvalue(env_FSG_RegisterState, gRegisterState);
            putvalue(env_FSG_NetworkType,gNetworkType);
            putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
			RegisterState_Request(Data_REQ, 0);	//send register state
			putvalue(env_FSG_NetworkProviderState, 0);	//delete network provider
			NetworkProvider_Request(Data_REQ, 0);	//send empty provider name
		}

		gemergencycall=0;
		
		//call state
		set_CallState(call_id, idle);	//set call state to idle
		
		//changes from Jöran Karl (28.03.2012)
		//Disconnect Reason	
		//if(gCallActivity==NOCALL)
		//{
		//	gDisconnectReason=regulardisconnecting;	//set Disconnect Reason to regular disconnecting
		//	putvalue(env_FSG_DisconnectReason, gDisconnectReason);
		//	DisconnectReason_Request(Data_REQ, 0);	//send Disconnect Reason
		//}

		//call info
		for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
			gCallInfo_PbName[call_id][i]=0;
		for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
			gCallInfo_TelNumber[call_id][i]=0;
        
        //IssueList #206 -s
         for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
            gCallInfo_PbName_hex[call_id][i]=0;
        //IssueList #206 -e

	//changes from Jöran Karl (28.03.2012)
        putvalue_CallInfo(call_id);
		
		CallInfo_Request(Data_REQ,0);//callinfodelete_Request(Data_REQ, call_id, 1, 1, 0);

        if(call_id == gRingTone_incoming_callid && gRingTone_unmute == 1)
            putvalue("env_FSG_RingToneMuteOnOff", 0); // unmute
            //IssueList #51
            putValue(env_FSG_RingToneMuteOnOff_OK,1);


        gRingTone_incoming_callid = 0;
        gRingTone_unmute = 0;

        //changes from Jöran Karl (28.03.2012)
	//DisconnectReason & Result
    if (gActiveCall_BAPdelayFlag == 0x00)
        settimer(DisconnectReason_Timer, disconnectreasontime);
    else
    settimer(DisconnectReason_Timer, 10);

  
   //IssueList #155 - Aghil
	}
    if (gFSGOpStateFlg>7)
    gFSGOpStateFlg=0;

   if(0xFF != gCallIDTemp)
    {
       gFSGOpStateFlg++;

       //MR59817 BAP_MOST delaytimer
       if (gActiveCall_BAPdelayFlag == 0x01)
       //MR 63212
       //disconnecttime = 10;
       disconnecttime2 = 10;

       if(1==gFSGOpStateFlg)
       {
         set_CallState((gCallIDTemp), disconnecting);			   //disconnect call
          //MR 63212
	 //settimer(disconnectingtimer, disconnecttime);
         settimer(disconnectingtimer, disconnecttime2);
       }
       if(2==gFSGOpStateFlg)
       {
         set_CallState((gCallIDTemp), disconnecting);			   //disconnect call
          //MR 63212
	 //settimer(disconnectingtimer, disconnecttime);
         settimer(disconnectingtimer, disconnecttime2);
       }
       if(3==gFSGOpStateFlg)
       {
         set_CallState((gCallIDTemp), disconnecting);			   //disconnect call
          //MR 63212
	 //settimer(disconnectingtimer, disconnecttime);
         settimer(disconnectingtimer, disconnecttime2);
       }
       if(4==gFSGOpStateFlg)
       {
         set_CallState((gCallIDTemp), disconnecting);			   //disconnect call
          //MR 63212
	 //settimer(disconnectingtimer, disconnecttime);
         settimer(disconnectingtimer, disconnecttime2);
       }
       if(5==gFSGOpStateFlg)
       {
         set_CallState((gCallIDTemp), disconnecting);			   //disconnect call
          //MR 63212
	 //settimer(disconnectingtimer, disconnecttime);
         settimer(disconnectingtimer, disconnecttime2);
       }
       if(6==gFSGOpStateFlg)
       {
         set_CallState((gCallIDTemp), disconnecting);			   //disconnect call
          //MR 63212
	 //settimer(disconnectingtimer, disconnecttime);
         settimer(disconnectingtimer, disconnecttime2);
       }
       if(7==gFSGOpStateFlg)
       {
         set_CallState((gCallIDTemp), disconnecting);			   //disconnect call
          //MR 63212
	 //settimer(disconnectingtimer, disconnecttime);
         settimer(disconnectingtimer, disconnecttime2);
       }

       //write("gCallIDTemp %d gFSGOpStateFlg %d", gCallIDTemp, gFSGOpStateFlg);
       gCallIDTemp--;
       setTimer (fsgOperationState_delayTimer, 1500);

	 }
}

Kill_Bill_Vol1 ()
{

int i, j, length;

//init lokal variables
	i=0;
	j=0;
	length=0;
//********************


	write("Kill Bill Vol 1");

	//call states
	gCallState[0]=idle;
	gCallState[1]=idle;
	gCallState[2]=idle;
	gCallState[3]=idle;
	gCallState[4]=idle;
	gCallState[5]=idle;
	gCallState[6]=idle;

	putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
	putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[0]]);
	putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[0]]);
	putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[0]]);
	putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[0]]);
	putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[0]]);
	putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[0]]);
	
	//CallActivity
	gCallActivity=NOCALL;
	putvalue(env_FSG_CallActivity, gstring_callactivity[gCallActivity]);

    //changes from Jöran Karl (28.03.2012)
    if(getvalue(env_FSG_DisconnectReason_Active) != FALSE)
    {
    	//Disconnect Reason
    	gDisconnectReason=regulardisconnecting;
    	putvalue(env_FSG_DisconnectReason, gDisconnectReason);
    }
	
	//CallInfo
	for(j=0;j<7;j++){
		for(i=0;i<CALL_INFO_NAME_LENGTH;i++)	//delete all call info strings
			gCallInfo_PbName[j][i]=0;
		for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
			gCallInfo_TelNumber[j][i]=0;
        		 //IssueList #20
	    gCallInfo_Category[j]=0;
	}
	//PbName
	putvalue(env_FSG_CallInfo_PbName_0, gCallInfo_PbName[0]);
	putvalue(env_FSG_CallInfo_PbName_1, gCallInfo_PbName[1]);
	putvalue(env_FSG_CallInfo_PbName_2, gCallInfo_PbName[2]);
	putvalue(env_FSG_CallInfo_PbName_3, gCallInfo_PbName[3]);
	putvalue(env_FSG_CallInfo_PbName_4, gCallInfo_PbName[4]);
	putvalue(env_FSG_CallInfo_PbName_5, gCallInfo_PbName[5]);
	putvalue(env_FSG_CallInfo_PbName_6, gCallInfo_PbName[6]);
	//TelNumber
	putvalue(env_FSG_CallInfo_TelNumber_0, gCallInfo_TelNumber[0]);
	putvalue(env_FSG_CallInfo_TelNumber_1, gCallInfo_TelNumber[1]);
	putvalue(env_FSG_CallInfo_TelNumber_2, gCallInfo_TelNumber[2]);
	putvalue(env_FSG_CallInfo_TelNumber_3, gCallInfo_TelNumber[3]);
	putvalue(env_FSG_CallInfo_TelNumber_4, gCallInfo_TelNumber[4]);
	putvalue(env_FSG_CallInfo_TelNumber_5, gCallInfo_TelNumber[5]);
	putvalue(env_FSG_CallInfo_TelNumber_6, gCallInfo_TelNumber[6]);
	
    //IssueList #20
    	//Category
	putvalue(env_FSG_CallInfo_Category_0_s, gCallInfo_Category[0]);
	putvalue(env_FSG_CallInfo_Category_1_s, gCallInfo_Category[1]);
	putvalue(env_FSG_CallInfo_Category_2_s, gCallInfo_Category[2]);
	putvalue(env_FSG_CallInfo_Category_3_s, gCallInfo_Category[3]);
	putvalue(env_FSG_CallInfo_Category_4_s, gCallInfo_Category[4]);
	putvalue(env_FSG_CallInfo_Category_5_s, gCallInfo_Category[5]);
	putvalue(env_FSG_CallInfo_Category_6_s, gCallInfo_Category[6]);

	gemergencycall=0;

    //IssueList #155 - Aghil
    putvalue(env_FSG_CallType_CallID_0, empty_string);
    putvalue(env_FSG_CallType_CallID_1, empty_string);
    putvalue(env_FSG_CallType_CallID_2, empty_string);
    putvalue(env_FSG_CallType_CallID_3, empty_string);
    putvalue(env_FSG_CallType_CallID_4, empty_string);
    putvalue(env_FSG_CallType_CallID_5, empty_string);
    putvalue(env_FSG_CallType_CallID_6, empty_string);

//***sending********
	CallState_Request(Data_REQ,0);	//send call state

	DisconnectReason_Request (Data_REQ, 0);	//send Disconnect Reason

	CallInfo_Request(Data_REQ,0);//callinfo_Request(Data_REQ, 0, 0, 0, 0);	//send call info

}

byte check_hangup (byte call_id)	//check, if in this call state hang up is possible (0=impossible, 1=possible)
{
byte hangup;

//init lokal variables
	hangup=Terror_nocallrelatedtoCallID;
//********************


	switch(gCallState[call_id])
	{
				case ringing_waiting:
					hangup=TRUE;
				break;
				case active:
					hangup=TRUE;
				break;
				case dialing:
					hangup=TRUE;
				break;
				case onhold:
					hangup=TRUE;
				break;
                case INCOMING_ON_HOLD:
					hangup=TRUE;
				break;
				default:	//hangup is impossible in this state 
					hangup=Terror_nocallrelatedtoCallID;
				break;
	}
			
	return(hangup);

}

HangupCall_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, callID, hangupcallpossible;
byte Debil;	//flag

//init lokal variables
	callID=0;
//********************
//IssueList #26 - CANoe crashes
gFirstPress = 0x00;

//IssueList #122
allCallsHangUpFlg = 0x00;
gActiveCall_ActiveFlag=0;

	switch (indication)
	{
		case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_FSG_Tel_HangUpCall_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_HangUpCall_ErrorCode) > 0x3F)) && (gTelFctList_0x1D_TimeOut_flg == 0x00))
			{
            HangupCall_Request(Processing_REQ, 0);											//send Processing
		    
                //IssueList #68
                if (gTelFctList_0x1D_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x1D_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x1D_ProcessingTimer,TELMAXPROCESSINGTIME);

                HangupCall_Request(Processing_REQ, 0);
                }
            }
        break;
		case StartResult_IND:
          //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x1D_TimeOut)!=TRUE)
            {
            gTelFctList_0x1D_TimeOut_flg = 0x00;
                
                //IssueList #57
                if (getValue(env_FSG_Tel_HangUpCall_Error_On)==0x00)
                putValue(env_FSG_Tel_HangUpCall_ErrorCode,0);

                //IssueList #47
                if (getValue(env_FSG_Tel_HangUpCall_Error_On))
                    HangupCall_Request(Error_REQ, getValue(env_FSG_Tel_HangUpCall_ErrorCode)); // send error-message

                else if(ghangupcall_status!=0)
    				HangupCall_Request(Error_REQ, Terror_unknownapllicationerror);				//send error-message to RNS
    			else if(datalength!=4)															//datalength error
    				HangupCall_Request(Error_REQ, Terror_unknownapllicationerror);				//send error-message to RNS
    			else{
    				callID=Indication_array[3];
    				if(callID<7)
    				{
    					hangupcallpossible=check_hangup(callID);
    				}
    				else if(callID==ALL_ACTIVE_CALLS)
    				{
    					hangupcallpossible=Terror_noactivecall;

    					for(i=0;i<7;i++)
    					{
    						if(gCallState[i]==active)
    							hangupcallpossible=TRUE;
    					}
    				}
    				else if(callID==ALL_HELD_CALLS)
    				{
    					hangupcallpossible=Terror_nocallonhold;
    					for(i=0;i<7;i++)
    					{
    						if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
    							hangupcallpossible=TRUE;
    					}
    				}
    				else if(callID==ALL_ACTIVE_AND_HELD_CALLS)
    				{
    					hangupcallpossible=Terror_noactivecall;
    					for(i=0;i<7;i++)
    					{
    						if(gCallState[i]==active || gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
    							hangupcallpossible=TRUE;
    					}
    				}
    				else if(callID==ALL_CALLS)
    				{
    					hangupcallpossible=Terror_nocall;
    					for(i=0;i<7;i++)
    					{
    						if(gCallState[i]!=idle)
    							hangupcallpossible=TRUE;
    					}
    				}
    				ghangupcall_status=1;
                    //IssueList #26
    		putvalue(env_FSG_HangupCall_CallID_M, callID);													//method "hangupcall" active
									
    				//IssueList #26
                    if (getValue(env_FSG_HangUpCall_Result)!=0x00)
                    hangupcallpossible = FALSE;
       
                    if(hangupcallpossible!=TRUE)												//hangup not feasible
    				{   //IssueList #26	 
                        gHangupCall_Result = getValue(env_FSG_HangUpCall_Result);
                        HangupCall_Request(Result_REQ, hangupcallpossible);
    					//HangupCall_Request(Error_REQ, hangupcallpossible);	
    					ghangupcall_status=0;													//method "hangupcall" finished
    				}
    				else if (callID<7)															//hangup feasible, one call-ID
    				{
    					switch(gCallState[callID])
    					{
    					    case ringing_waiting:
    							if(gacceptcall_status)											//method "acceptcall" is still active
    							{
    								canceltimer(acceptcallTimer);								//abort method "acceptcall"
    								Debil=random(2);
    								if(Debil)
    									AcceptCall_Request(Error_REQ, Terror_unknownapllicationerror);
    								else
    									AcceptCall_Request(Result_REQ, 0);
								
    								gacceptcall_status=0;
    							}
                                if (gActiveCall_BAPdelayFlag == 0)
                                {
    							set_CallState(callID, disconnecting);
    							settimer(disconnectingtimer, disconnecttime);
                                }
                                else
                                {
                                gBapMostDisconnectID = callID;
                                 gActiveCall_idleCtr=0;

                                    for(i=0;i<7;i++)																//searching for active calls
                					{
                                        if (gCallState[i] == idle)
                                        gActiveCall_idleCtr++;
                                    }
                                    if (gActiveCall_idleCtr == 5)
                                    {
                                        gActiveCall_HangUpMethodActive=1;
                                        setTimer (_tBAP_delayTime, getValue(env_AudioTel_bapMost_delayTimer));
                                    }
                                }

                            
    						break;
    						case dialing:														//dialing is still active
    							canceltimer(dialtimer);

                                if (gActiveCall_BAPdelayFlag == 0)
                                {
    							set_CallState(callID, disconnecting);
    							settimer(disconnectingtimer, disconnecttime);
                                }
                                else
                                {
                                gBapMostDisconnectID = callID;
                                gActiveCall_HangUpMethodActive=1;
                                setTimer (_tBAP_delayTime, getValue(env_AudioTel_bapMost_delayTimer));
                                }

    						break;
    						case active:
    							if(gCallHold_status)											//method "CallHold" is still active
    							{
    								canceltimer(CallHoldTimer);									//abort method "CallHold
    								Debil=random(2);
    								if(Debil)
    									CallHold_Request(Error_REQ, Terror_unknownapllicationerror);
    								else
    									CallHold_Request(Result_REQ, 0);
								
    								gCallHold_status=0;
    							}
							
    							if(gMPSwap_status)												//method "MPSwap" is still active
    							{
    								canceltimer(MPSwapTimer);									//abort method "MPSwap"
    								Debil=random(2);
    								if(Debil)
    									MPSwap_Request(Error_REQ, Terror_unknownapllicationerror);
    								else
    									MPSwap_Request(Result_REQ, 0);
								
    								gMPSwap_status=0;
    							}
                                if (gActiveCall_BAPdelayFlag == 0)
                                {
    							set_CallState(callID, disconnecting);
    							settimer(disconnectingtimer, disconnecttime);
                                }
                                else
                                gBapMostDisconnectID=callID;

                               
                                //IssueList #79 - MR50008
                               // if (callID>0)
                                //{
                                   // for(i=0;i<callID;i++)	
                                    for(i=0;i<7;i++)																//searching for active calls
                    				{
                    				    if(gCallState[i]==onhold)
                    					{
                    					callID=i;
                                        set_CallState(callID,gCallState[i]);										//set call state
                    					}
                    				}
                                //}
    						break;
    						case onhold:
    							if(gResumeCall_status)											//method "ResumeCall" is still active
    							{
    								canceltimer(ResumeCallTimer);								//abort method "ResumeCall"
    								Debil=random(2);
    								if(Debil)
    									ResumeCall_Request(Error_REQ, Terror_unknownapllicationerror);
    								else
    									ResumeCall_Request(Result_REQ, 0);
								
    								gResumeCall_status=0;
    							}
                                if (gActiveCall_BAPdelayFlag == 0)
                                {
    							set_CallState(callID, disconnecting);
    							settimer(disconnectingtimer, disconnecttime);
                                }
                                else
                                gBapMostDisconnectID = callID;

                                
    						break;
                            case INCOMING_ON_HOLD:
    							if(gResumeCall_status)											//method "ResumeCall" is still active
    							{
    								canceltimer(ResumeCallTimer);								//abort method "ResumeCall"
    								Debil=random(2);
    								if(Debil)
    									ResumeCall_Request(Error_REQ, Terror_unknownapllicationerror);
    								else
    									ResumeCall_Request(Result_REQ, 0);
								
    								gResumeCall_status=0;
    							}

                                if (gActiveCall_BAPdelayFlag == 0)
                                {
    							set_CallState(callID, disconnecting);
    							settimer(disconnectingtimer, disconnecttime);
                                }
                                else
                                gBapMostDisconnectID = callID;

    						break;
    						default:
    							write("FSG-Telephone error HangupCall_Indication: invalid call state: %d", gCallState[callID]);
    							settimer(disconnectingtimer, disconnecttime);
    						break;
    					}
    				}
    				else if(callID==ALL_ACTIVE_CALLS)														//hangup feasible, all active call-IDs
    				{
    					//IssueList #122
                        allCallsHangUpFlg = 0x01;
                        for(i=0;i<7;i++)																//searching for active calls
    					{
    						if(gCallState[i]==active)
    						{
    							callID=i;
    							set_CallState(callID,disconnecting);										//set call state
    				// changes from Jan Swoboda (01.03.2012)		
    						}
    					}
    					settimer(disconnectingtimer2, disconnecttime);;
    				}
    				else if(callID==ALL_HELD_CALLS)														//hangup feasible, all held call-IDs
    				{
    					//IssueList #122
                        allCallsHangUpFlg = 0x01;
                        for(i=0;i<7;i++)																//searching for active calls
    					{
    						if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
    						{
    							callID=i;
    							set_CallState(callID,disconnecting);										//set call state
    						// changes from Jan Swoboda (01.03.2012)
    						}
    					}
    					settimer(disconnectingtimer2, disconnecttime);
    				}
    				else if(callID==ALL_ACTIVE_AND_HELD_CALLS)												//hangup feasible, all held and active call-IDs
    				{
    					//IssueList #122
                        allCallsHangUpFlg = 0x01;
                        for(i=0;i<7;i++)																//searching for active calls
    					{
    						if(gCallState[i]==active || gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
    						{
    							callID=i;
    							set_CallState(callID,disconnecting);										//set call state
    						// changes from Jan Swoboda (01.03.2012)
    						}
    					}
    					settimer(disconnectingtimer2, disconnecttime);
    				}
    				else if(callID==ALL_CALLS)															//hangup feasible, all call-IDs
    				{
    					//IssueList #122
                        allCallsHangUpFlg = 0x01;
                        for(i=0;i<7;i++)																//searching for active calls
    					{
    						if(gCallState[i]!=idle)
    						{
    							callID=i;
    							set_CallState(callID,disconnecting);										//set call state
    					// changes from Jan Swoboda (01.03.2012)
    						}
    					}
    					settimer(disconnectingtimer2, disconnecttime);
    				}
                     //MR60227
                     if (getValue(env_PIC_bapMOST_active_flag)==0x01)
                     {
                     gActiveCall_idleCtr=0;
                        for(i=0;i<7;i++)																//searching for active calls
    					{
                            if (gCallState[i] == idle)
                            gActiveCall_idleCtr++;
                
                            
                            if (gCallState[i] == active &&  i!= gBapMostDisconnectID)
                            {
                            gActiveCall_ActiveFlag = 1;
                            gBapMostCallID=i;
                            }

                        }
                        
                        for(i=0;i<7;i++)																//searching for active calls
    					{
    					  if (gActiveCall_BAPdelayFlag == 0x00)
                          {
                            if(gCallState[i]==active || gCallOptions[i]==0x10)
                            {
                                 gBapMostCallID = i;
                                 gActiveCall_active = 1;
                                 gActiveCall_CallMethodActive = 1;
                                 gActiveCall_HangUpMethodActive = 1;
                                 setActiveCall_Picture();
                                 break;
                            }//if
                          }//gActiveCall_BAPdelayFlag
                          else if (gActiveCall_BAPdelayFlag == 0x01)
                          {
                               if (gActiveCall_ActiveFlag == 0x01)
                                 {
                                 gActiveCall_active = 1;
                                 gActiveCall_CallMethodActive = 1;
                                 gActiveCall_HangUpMethodActive = 1;
                                 setActiveCall_Picture();
                                 break;
                                 }
                                //ringing rejected
                                else if (gCallState[i]==onhold && gActiveCall_idleCtr <6)
                                {
                                 gBapMostCallID = i;
                                 gActiveCall_active = 1;
                                 gActiveCall_CallMethodActive = 1;
                                 gActiveCall_HangUpMethodActive = 1;
                                 setActiveCall_Picture();
                                 break;
                                }
                                //1 call hanged up
                               else if (gActiveCall_idleCtr==6 )
                                {
                                gActiveCall_HangUpMethodActive = 1;
                                setTimer (_tBAP_delayTime, getValue(env_AudioTel_bapMost_delayTimer));
                                break;
                                }
                           }//else if
                           
                        }//for
                      }//if
                    
                }//else

            }//IssueList #74
            else
            gTelFctList_0x1D_TimeOut_flg = 0x01;

		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone HangupCall_Indication: unknown indication %d", indication);
		break;
	}
}

HangupCall_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_HangupCall;		//Fct.-ID
			requestarray[2]=request;
            requestarray[3]=0;                      //dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x1D_Processing_flg == 0x00)
            {
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_HangupCall;	//Fct.-ID
			requestarray[2]=request;
            requestarray[3]=gHangupCall_Result;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);

            //MR59817
            if (gActiveCall_CallMethodActive ==0x01)
            gActiveCall_CallMethodActive=0x00;

            if (gActiveCall_HangUpMethodActive == 0x01)
            gActiveCall_HangUpMethodActive = 0x00;
            
                 //IssueList #49
                 EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);
                 //IssueList #20
                putvalue(env_FSG_CallInfo_Category_0, empty_string);
                putvalue(env_FSG_CallInfo_Category_1, empty_string);
                putvalue(env_FSG_CallInfo_Category_2, empty_string);
                putvalue(env_FSG_CallInfo_Category_3, empty_string);
                putvalue(env_FSG_CallInfo_Category_4, empty_string);
                putvalue(env_FSG_CallInfo_Category_5, empty_string);
                putvalue(env_FSG_CallInfo_Category_6, empty_string);
            }

		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_HangupCall;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x1D_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone HangupCall_Request: unknown request %d",request );
		break;
	}
}

byte callinfo (byte current_callID, byte direction)	
{
byte next_callID;
int i, finish;	


//init lokal variables
	next_callID=0;
	finish=0;	
//********************

	next_callID=0xFF;
	
	
	if(direction==0 && current_callID<6){
		for(i=(current_callID+1);finish!=1;i++){						//check, which next call-id is a call-id with changed call info
			if(strlen(gCallInfo_PbName[i])!=0){
				finish=1;
				next_callID=i;
			}

			if(i==6)
				finish=1;
		}
	}
	else if(current_callID>0) {
		for(i=(current_callID-1);finish!=1;i--){						//check, which next call-id is a call-id with changed call info
			if(strlen(gCallInfo_PbName[i])!=0){
				finish=1;
				next_callID=i;
			}

			if(i==0)
				finish=1;		
		}
	}

	return(next_callID);

}

on timer dialnumber_changearraytimer
{
	//write("dialnumber_changearraytimer");			//debug	

	gstatus_dialnumber_changearraytimer = 0;	

	set_CallState(gcallID, dialing);
	EnableControl("FSG-Telephone_Remote_Side", "free_busy", 0);
		
	settimer(dialtimer,3000);

    if(gDialService_status == 0) // dial number running?
    {

        // write("dialnumber Result");	//debug
        gDialNumber_Result = SUCCESSFUL;
        gDialNumber_status = 0;							//method "dialnumber" is finished

        if(gCallStartedFromASG == 1)
        {
            //if(gemergencycall == 0x01) // emergency call
            if(gConfirmCall == 1)
            {
                gConfirmErmergencyCall_result = SUCCESSFUL;
                ConfirmEmergencyCall_Request(Result_REQ, 0);
            }
            else
            {
                DialNumber_Request(Result_REQ, 0);		//send result for method dialnumer
            }
        }
        else
        {
        }
    }
    else 
    {       
        // write("dialservice Result");
        gDialNumber_Result = SUCCESSFUL;
        gDialService_Result = SUCCESSFUL;
        
        gDialNumber_status = 0;	
        gDialService_status = 0;

        if(gCallStartedFromASG == 1)
        {
            //if(gemergencycall == 0x01)
            if(gConfirmCall == 1)
            {
                gConfirmErmergencyCall_result = SUCCESSFUL;
                ConfirmEmergencyCall_Request(Result_REQ, 0);
            }
            else
            {
                DialService_Request(Result_REQ, 0);		//send result for method dialservice
            }
        }
    }
}

byte checkcallinfoarray (dword array[], int arraylength)
{
byte valid, mode, indexsize;
word elements;


//init lokal variables
	mode=0;
	indexsize=0;
	elements=0;
//********************

	valid=1;

	//***mode***
	mode=array[3];
	indexsize=(mode & 0x80)/0x80;
	//write("FSG-Telephone checkarray indexsize: %d", indexsize);

	switch(array[2]){
		case DataGet_IND:
			//********arraylength*******
			if(indexsize){
				elements=array[6]+array[7]*256;
				if(arraylength!=8)
					return(0xff);
			}
			else{
				elements=array[5];
				if(arraylength!=6)
					return(0xff);
			}
			//**************************

			//***elements***
			if(elements==0)
				return(0xff);
			//**************

		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone checkcallinfoarray: unknown opcode %d", array[2]);
		break;
		
	}
	
	return(valid);

}

DisconnectReason_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			if(datalength!=4)													//datalength error
				DisconnectReason_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message
			else
				DisconnectReason_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone DisconnectReason indication: unknown indication %d", indication);
		break;
	}
}

RegisterState_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			//check array
			if(datalength!=4)														//datalength error
				RegisterState_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message
			else
				RegisterState_Request(Data_REQ, 0);									//send register state
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone RegisterState_Indication: unknown indication %d", indication);
		break;
	}
}

NetworkProvider_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			//check BAP-array
			if(datalength!=3)														//datalength error
				NetworkProvider_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message
			else
				NetworkProvider_Request(Data_REQ, 0);								//send network provider 
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone NetworkProvider_Indication: unknown indication %d", indication);
		break;
	}
}

CallState_Indication(dword Indication_array [], byte indication, int datalength)
{
byte temp;

//init lokal variables
	temp=0;
//********************

	switch(indication){
		case DataGet_IND:
			//check BAP-array
			if(datalength!=4)	//datalength error
				CallState_Request(Error_REQ, Terror_datainvalid);	//send error-message to RNS
			else
				CallState_Request(Data_REQ,0);	//send call state
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone callstate indication: unknown indication %d", indication);
		break;

	}
}

//IssueList #51
//on envVar env_FSG_MicroMuteOnOff
on envVar env_FSG_MicroMuteOnOff_OK
{
	//if(gFSG_Telephone_PowerOnOff==Power_on && gMicroMuteOnOff!=getvalue(this))
    if(gFSG_Telephone_PowerOnOff==Power_on && getValue(this))
    {
        if (gMicroMuteOnOff!=getvalue(env_FSG_MicroMuteOnOff))
        {
        gMicroMuteOnOff=getvalue(env_FSG_MicroMuteOnOff);
        }
		
        MicroMuteOnOff_Request(Data_REQ, 0);
	}
}

//IssueList #51
//on envVar env_FSG_HandsFreeOnOff
on envVar env_FSG_HandsFreeOnOff_OK
{
	//if(gFSG_Telephone_PowerOnOff==Power_on && gHandsFreeOnOff!=getvalue(this))
    if(gFSG_Telephone_PowerOnOff==Power_on && getValue(this))
    {
		if (gHandsFreeOnOff!=getvalue(env_FSG_HandsFreeOnOff))
        {
        
        //gHandsFreeOnOff=getvalue(this);
        gHandsFreeOnOff=getvalue(env_FSG_HandsFreeOnOff);
        
			//if(gHandsFreeOnOff==0 && gheadset_available!=TRUE){
			//	gHandsFreeOnOff=1;
			//	settimer(handsfreeresettimer, 5);
			//}
			//else	
        }
		HandsFreeOnOff_Request(Data_REQ, 0);
	}
}

HandsFreeOnOff_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Data_REQ:
            //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x21_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_HandsFreeOnOff;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gHandsFreeOnOff;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_HandsFreeOnOff;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone HandsFreeOnOff_Request: unknown request %d", request);
		break;
	}
//IssueList #51
putvalue(env_FSG_HandsFreeOnOff_OK, 0);
}

MicroMuteOnOff_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Data_REQ:
            //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x22_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_MicroMuteOnOff;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gMicroMuteOnOff;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_MicroMuteOnOff;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone MicroMuteOnOff_Request: unknown request %d", request);
		break;
	}
//IssueList #51
putvalue(env_FSG_MicroMuteOnOff_OK, 0);
}

MicroMuteOnOff_Indication (dword Indication_array [], byte indication, int datalength)
{
	
	switch (indication){
		case DataSetGet_IND:

    			//check array
    			if(datalength!=4)														//datalength error
    				MicroMuteOnOff_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message
    			//else if(gCallActivity==NOCALL){											//all call-states on state 'idle'
    			//	MicroMuteOnOff_Request(Error_REQ, Terror_noactivecall);				//send error-message
    			//}
    			 //IssueList #27
                else if (getValue(env_Tel_MicroMute_Error_On))
                MicroMuteOnOff_Request(Error_REQ, getValue(env_Tel_MicroMute_Error_Code));
            
                else{
    				gMicroMuteOnOff=Indication_array[3];
    				putvalue(env_FSG_MicroMuteOnOff, gMicroMuteOnOff);
    				//IssueList #51
                    putvalue(env_FSG_MicroMuteOnOff_OK, 1);
                    //MicroMuteOnOff_Request(Data_REQ, 0);								//send micromute status
    			}
            
		break;
		case DataGet_IND:
			//check array
			if(datalength!=4)														//datalength error
				MicroMuteOnOff_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message
			else
				MicroMuteOnOff_Request(Data_REQ, 0);								//send micromute status
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone MicroMuteOnOff_Indication: unknown indication %d", indication);
		break;
	}
}

HandsFreeOnOff_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication)
    {
		case DataSetGet_IND:
			//check array
			if(datalength!=4)												//datalength error
				HandsFreeOnOff_Request(Error_REQ, Terror_datainvalid);		//send error-message
			
            //IssueList #27
            else if (getValue(env_Tel_HandsFree_Error_On))
            HandsFreeOnOff_Request(Error_REQ, getValue(env_Tel_HandsFree_Error_Code));		//send error-message
            
            else
            {
				gHandsFreeOnOff=Indication_array[3];
				//if(gHandsFreeOnOff==0 && gheadset_available!=TRUE)
                //{
				//	gHandsFreeOnOff=1;
				//	HandsFreeOnOff_Request(Error_REQ, gheadset_available);	//send error-message
				//}
				//else{
					putvalue(env_FSG_HandsFreeOnOff, gHandsFreeOnOff);
					//IssueList #51
                    putvalue(env_FSG_HandsFreeOnOff_OK, 1);
                    //HandsFreeOnOff_Request(Data_REQ, 0);					//send handsfree status
				//}
			}
		break;
		case DataGet_IND:
			//check array
			if(datalength!=3)												//datalength error
				HandsFreeOnOff_Request(Error_REQ, Terror_datainvalid);		//send error-message
			else
				HandsFreeOnOff_Request(Data_REQ, 0);						//send micromute status
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone HandsFreeOnOff_Indication: unknown indication %d", indication);
		break;
	}
}

on envVar env_FSG_Headset_available
{
	if(gFSG_Telephone_PowerOnOff==Power_on){
		gheadset_available=getvalue(this);
		if(gheadset_available==TRUE){
			EnableControl("FSG-Telephone-Premium", "FSG-Telephone_HandsFree", 1);
		}
		else{
			gHandsFreeOnOff=1;
			putvalue(env_FSG_HandsFreeOnOff, gHandsFreeOnOff);
			//IssueList #51
            putvalue(env_FSG_HandsFreeOnOff_OK, 1);
            EnableControl("FSG-Telephone-Premium", "FSG-Telephone_HandsFree", 0);
		}
	}
}

on timer handsfreeresettimer
{
	putvalue(env_FSG_HandsFreeOnOff, gHandsFreeOnOff);
    //IssueList #51
    putvalue(env_FSG_HandsFreeOnOff_OK, 1);
}

on envVar env_FSG_dialednumber_accepted
{
int i;

	if(gFSG_Telephone_PowerOnOff==Power_on)
	{
		if(getvalue(this) && getvalue(env_FSG_dialednumber_free_busy)==free)
		{
			//search for dialing calls 
			for(i=0;i<7;i++)
			{
				if(gCallState[i]==dialing)
				{
					// changes from Jan Swoboda (01.03.2012)
					set_CallState_noReq(gcallID, active);
					EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);
					i=7;
				}
			}
            // changes from Jan Swoboda (01.03.2012)
	    if (gCallStateRequestPending)
                CallState_Request(Data_REQ,0);
	
		}
	}
}

on envVar env_FSG_IncomingCall
{
int i, length, valid;
byte possible;
byte RegisterStateOK;
//IssueList #206
int strlength;

//init lokal variables
	length=0;
	valid=0;
	possible=1;
    RegisterStateOK = 0;
//********************	

//IssueList #41
if (getValue(this))
gIncomingCallPress = 0x01;

	for(i = 0; i < 7; i++){
		if(gCallState[i] == dialing || gCallState[i] == ringing_waiting || gCallState[i] ==  disconnecting)
			possible = 0;
	}

    if( (gRegisterState == registered) || (gRegisterState == registeredandroaming) || (gRegisterState == registeredandroamingalternative))
    {
        RegisterStateOK = 1;
    }

	if((gFSG_Telephone_PowerOnOff == Power_on) && getvalue(this) && (possible == 1) && (RegisterStateOK == 1) ) //incoming call is possible
	{
		for (i=0;i<CALL_INFO_NUMBER_LENGTH;i++)													//initialize array for incoming call number
			gincomingcall_number[i] = 0;
		for (i=0;i<CALL_INFO_NAME_LENGTH;i++)													//initialize array for incoming call name
			gincomingcall_name[i] = 0;
		
		getvalue(env_FSG_incomingcallstring, gincomingcall_number);		//read incoming call number fromm panel
		length=strlen(gincomingcall_number);		

		if(length==0)														//incognito incoming call
		{
			gincomingcall=1;
			write("Incoming Call: unknown number");
			strncpy(gincomingcall_name, gunknown, CALL_INFO_NAME_LENGTH);						//write "unknown" in name-variable for incommming-call
			gincomingcall_numbertype=0;
			gcallID=callstates_status(ringing_waiting);						//check for free call-ID
			write("FSG-Telephone-Call incomingcall CallID: %d", gcallID);

            gRingTone_incoming_callid = gcallID; // save callid for RingtoneMuteOnOff

			//save incoming call data for received calls callstack
			for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
				greceivedcall_number[i]=0;
			for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
				greceivedcall_name[i]=0;

			strncpy(greceivedcall_number, gincomingcall_number, CALL_INFO_NUMBER_LENGTH);
			strncpy(greceivedcall_name, gunknown, CALL_INFO_NAME_LENGTH);
			greceivedcall_numbertype=gincomingcall_numbertype;
			//*****************************************************
			
			// VAGF-25378 start
			/*//changes from Jöran Karl (28.03.2012)
			if(getvalue(env_FSG_DisconnectReason_Active) != FALSE)
			{
    			//DisconnectReason
    			gDisconnectReason=connectedline_busy;
    			putvalue(env_FSG_DisconnectReason, gDisconnectReason);
    			DisconnectReason_Request(Data_REQ, 0);									//send Disconnect Reason
			}*/
			// VAGF-25378 end

			//Handsfreeonoff
			if(gHandsFreeOnOff==0)
			{
				//IssueList #135 - commented
                //gHandsFreeOnOff=1;
				//putvalue(env_FSG_HandsFreeOnOff, gHandsFreeOnOff);

				//IssueList #51
                putvalue(env_FSG_HandsFreeOnOff_OK, 1);
                //HandsFreeOnOff_Request(Data_REQ, 0);						//send handsfree status
			}

			//callinfo
			strncpy(gCallInfo_PbName[gcallID], gincomingcall_name, CALL_INFO_NAME_LENGTH);
			strncpy(gCallInfo_TelNumber[gcallID], gincomingcall_number, CALL_INFO_NUMBER_LENGTH);
			
            //IssueList #206 -s
            strlength = strlen(gincomingcall_name);
            for(i = 0; i < CALL_INFO_NAME_LENGTH; i++)
            {
                if(i < strlength)                    
                    gCallInfo_PbName_hex[gcallID][i] = gincomingcall_name[i];
                else
                    gCallInfo_PbName_hex[gcallID][i] = 0;
            }
            //IssueList #206 -e

            //changes from Jöran Karl (28.03.2012)
			putvalue_CallInfo(gcallID);

			CallInfo_Request(Data_REQ,0);//callinfo_Request(Changed_REQ, gcallID, 1, 0, 0);
			settimer(incomingcall_changearraytimer, 300);
			gstatus_incomingcall_changearraytimer=1;
		}
		else																//no incognito incoming call
		{
			valid=tel_number_valid (gincomingcall_number, length);			//check each part of the new number of correctness
				
			if (valid)														//when new number only includes valid characters
			{
				write("Incoming Call: valid number");
				gincomingcall=1;
				gcallID=callstates_status(ringing_waiting);					//check for free call-ID
				write("FSG-Telephone-Call incomingcall CallID: %d", gcallID);

                gRingTone_incoming_callid = gcallID; // save callid for RingtoneMuteOnOff

				putvalue(env_FSG_phonebook_number, gincomingcall_number);	//search for phonebook-entry for incoming call number
				gnumbersearchphonebook=1;
				
                //BAP_MOST sync
                if (getValue(env_PIC_bapMOST_active_flag)==0x01 && getValue(this) ==0x01)
                {
                 
                 gBapMostCallID= gcallID;
                 gActiveCall_active = 1;
                 gActiveCall_IncomingCall =1;
                 setActiveCall_Picture();

                if (gActiveCall_BAPdelayFlag==0)
                settimer(numbersearchphonebooktimer, 100);					//start timer for searching in phonebook
                else
                settimer(numbersearchphonebooktimer, getValue(env_AudioTel_bapMost_delayTimer)*1000);
                }
                
		 //MR 63212
                else if (getValue(env_PIC_bapMOST_active_flag)==0x00)
                settimer(numbersearchphonebooktimer, 100);

			
            }
			else															//new number is invalid
			{
				write("Incoming Call: invalid number");
				for (i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
					gincomingcall_number [i]=0;
			
				putvalue(env_FSG_incomingcallstring,gincomingcall_number);//delete number in display
			}
		}
	}
	else if(getvalue(this))													//incoming call is impossible --> missed incoming call
	{
		write("Incoming Call: impossible");
		getvalue(env_FSG_incomingcallstring, gincomingcall_number);
		length=strlen(gincomingcall_number);

		if(length==0)														//incognito incoming call
		{
			write("Incoming Call: unknown number");
			strncpy(gincomingcall_name, gunknown, CALL_INFO_NAME_LENGTH);						//write "unknown" in name-variable for incommming-call
			gincomingcall_numbertype=0;
			putvalue(env_FSG_missedcall_name, gincomingcall_name);				//write number of missed call in callstack
			putvalue(env_FSG_missedcall_number, gincomingcall_number);			//write number of missed call in callstack
			putvalue(env_FSG_missedcall_numbertype, gincomingcall_numbertype);	//write numbertype of dialed number in callstack
			putvalue(env_FSG_missedcall_callstack, 1);
			
		//	putvalue(env_FSG_missedcall_unknown, 1);						//write unknown missedcall number in callstack
		}
		else																//no incognito incoming call
		{
			valid=tel_number_valid (gincomingcall_number, length);			//check each part of the new number of correctness
				
			if (valid)														//when new number only includes valid characters
			{
				write("Incoming Call: valid number");
				gmissedcall=1;
				putvalue(env_FSG_phonebook_number, gincomingcall_number);
				gnumbersearchphonebook=1;
				settimer(numbersearchphonebooktimer, 100);
			}
			else															//new number is invalid
			{
				write("Incoming Call: invalid number");
				for (i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
					gincomingcall_number [i]=0;
			
				putvalue(env_FSG_incomingcallstring,gincomingcall_number);	//delete number in display
			}
		}

	}
}

on timer incomingcall_changearraytimer
{

	gstatus_incomingcall_changearraytimer=0;

	set_CallState(gcallID, ringing_waiting);
}

AcceptCall_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************
 
	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_AcceptCall;		//Fct.-ID
			requestarray[2]=request;
            requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68
	
            requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_AcceptCall;	//Fct.-ID
			requestarray[2]=request;
            requestarray[3]=gAcceptCall_Result;
			Offset=4;

            if (gTelFctList_0x1E_Processing_flg == 0x00)
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);

		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_AcceptCall;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);

            //IssueList #68
               cancelTimer(TelFctList_0x1E_ProcessingTimer);

		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone AcceptCall_Request: unknown request %d", request);
		break;
	}
}

AcceptCall_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, callID, acceptpossible;

//init lokal variables
	callID=0xff;
	//acceptpossible=1;

    gHookTasteFlag_AcceptCall = 0;
//********************

	//IssueList #26
	if (getValue(env_FSG_AcceptCall_Result)==0x00)	
		acceptpossible=1;
	else
		acceptpossible=0;

	for(i=0;i<7;i++){
		if(gCallState[i]==active || gCallState[i]==disconnecting || gCallState[i]==dialing)
			acceptpossible=Terror_activecallpresentdialing;
	}

	if(acceptpossible==1){
		acceptpossible=Terror_noincomingwaitingcall;
		for(i = 0; i < 7; i++){
			if(gCallState[i]==ringing_waiting)
				{
                acceptpossible=1;
                callID = i;  //MR59817
                }
		}
	}

	switch (indication){
		case Processing_CNF:
           //IssueList #57  and #74
           if (((getValue(env_FSG_Tel_AcceptCall_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_AcceptCall_ErrorCode) > 0x3F)) && (gTelFctList_0x1E_TimeOut_flg ==0x00))
           {
           AcceptCall_Request(Processing_REQ, 0);												//send Processing
		   
                //IssueList #68
                if (gTelFctList_0x1E_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x1E_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x1E_ProcessingTimer,TELMAXPROCESSINGTIME);

                AcceptCall_Request(Processing_REQ, 0);
                }
           }
        break;
		case StartResult_IND:
			 //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x1E_TimeOut)!=TRUE)
            {
             gTelFctList_0x1E_TimeOut_flg = 0x00;   

                //MR 63665
                if (getValue(env_FSG_CallState_CallID_0_set)!=0x00 || getValue(env_FSG_CallState_CallID_1_set)!=0x00 ||
                getValue(env_FSG_CallState_CallID_2_set)!=0x00 || getValue(env_FSG_CallState_CallID_3_set)!=0x00 ||
                getValue(env_FSG_CallState_CallID_4_set)!=0x00 || getValue(env_FSG_CallState_CallID_5_set)!=0x00 ||
                getValue(env_FSG_CallState_CallID_6_set)!=0x00)
                gHookTasteFlag_AcceptCall = 1;
                

                //IssueList #57
                if (getValue(env_FSG_Tel_AcceptCall_Error_On)==0x00)
                putValue(env_FSG_Tel_AcceptCall_ErrorCode,0);

                //IssueList #47
                if (getValue(env_FSG_Tel_AcceptCall_Error_On))
                    AcceptCall_Request(Error_REQ, getValue(env_FSG_Tel_AcceptCall_ErrorCode)); // send error-message

                else if(gacceptcall_status!=0)
    				AcceptCall_Request(Error_REQ, Terror_datainvalid);								//send error-message to RNS
    			else if(datalength!=3)																//datalength error
    				AcceptCall_Request(Error_REQ, Terror_datainvalid);								//send error-message to RNS
    			else if(acceptpossible!=1)	
                     //IssueList #26														           //accept call impossible
    				//AcceptCall_Request(Error_REQ, acceptpossible);
                    {
                    gAcceptCall_Result=getValue(env_FSG_AcceptCall_Result);							                         //send error-message to RNS
                    AcceptCall_Request(Result_REQ, acceptpossible);
                    }
    			else{
                     gacceptcall_status=1;															//method "acceptcal" active
    				settimer(acceptcallTimer, acceptcallTimerTime);
                    //write("debug: start acceptcallTimer");
    			}
            }
            else
            gTelFctList_0x1E_TimeOut_flg = 0x01;
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone AcceptCall_Indication: unknown indication %d", indication);
		break;
		}
}

on envVar env_FSG_AcceptCall
{
byte i, incomingcallID, acceptpossible;

//init lokal variables
	incomingcallID=0xff;
	acceptpossible=1;
//********************
    if (getValue(this))
    {
    	for(i=0;i<7;i++){
    		//IssueList #65
            //if(gCallState[i]==active || gCallState[i]==disconnecting)
             if(gCallState[i]==active) 
                {
                gCallState[i] = onhold;
                set_CallState(i, onhold);
                }
            if(gCallState[i]==disconnecting)
    			acceptpossible=0;
    	}

    	if(gFSG_Telephone_PowerOnOff==Power_on && acceptpossible==1){
    		for(i=0;i<7;i++){															//check call-states for incoming call
    			if(gCallState[i]==ringing_waiting)
    				incomingcallID=i;
    		}
	
    		if(getvalue(this) && incomingcallID!=0xff){		//only when button ist pressed and one callID-callstate is "ringing/waiting"
    			putvalue(env_FSG_receivedcall_name, greceivedcall_name);				//write name of received call in callstack
    			putvalue(env_FSG_receivedcall_number, greceivedcall_number);			//write number of received call in callstack
    			putvalue(env_FSG_receivedcall_numbertype, greceivedcall_numbertype);	//write numbertype of dialed number in callstack
    			//putvalue(env_FSG_receivedcall_callstack, 1);

    			set_CallState(incomingcallID, active);

                if(gRingTone_incoming_callid < 7 && gRingTone_unmute == 1)
                    putvalue(env_FSG_RingToneMuteOnOff, 0); // unmute
                    //IssueList #51
                    putValue(env_FSG_RingToneMuteOnOff_OK,1);

                gRingTone_unmute = 0;
                gRingTone_incoming_callid = 0xff;
    		}
    	}
    }//getValue this
}

numbersearchphonebook ()
{





}

on timer numbersearchphonebooktimer
{
byte searchstatus;
int length;
//IssueList #206
int i,strlength;

//init lokal variables
	searchstatus=0;
	length=0;
//********************
	searchstatus=gnumbersearchphonebook;
	gnumbersearchphonebook=0;

	if(gDialNumber_status==1)													//dialed number								
	{
		if(searchstatus==1)
		{
			//IssueList #40
			if (strncmp(gDialNumber_name2, gempty_string, 3) == 0)
            strncpy(gDialNumber_name, gDialNumber, strlen(gDialNumber)+1);
            else
            strncpy(gDialNumber_name, gDialNumber_name2, strlen(gDialNumber_name2)+1);
            gdialnumber_numbertype=0;
		}
		
		if(searchstatus==1 || searchstatus==2)									//numbersearching in phonebook finished
		{
			putvalue(env_FSG_dialednumber_name, gDialNumber_name);				//write name of dialed number in callstack
			putvalue(env_FSG_dialednumber_numbertype, gdialnumber_numbertype);	//write numbertype of dialed number in callstack

            //putvalue(env_FSG_dialednumber_callstack, gDialNumber);				//write dialed number in callstack
		}
		else
			write("error numbersearchphonebooktimer: invalid gnumbersearchphonebook-value: %d",searchstatus);
	}
	else if(gincomingcall==1)													//incoming call
	{
		if(searchstatus==1){
			strncpy(gincomingcall_name, gincomingcall_number, CALL_INFO_NUMBER_LENGTH);
			gincomingcall_numbertype=0;
		}

		if(searchstatus==1 || searchstatus==2){
			//save incoming call data for received calls callstack
			for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
				greceivedcall_number[i]=0;
			for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
				greceivedcall_name[i]=0;

			strncpy(greceivedcall_number, gincomingcall_number, CALL_INFO_NUMBER_LENGTH);
			strncpy(greceivedcall_name, gincomingcall_name, CALL_INFO_NAME_LENGTH);
			greceivedcall_numbertype=gincomingcall_numbertype;
			//*****************************************************

			length=strlen(gincomingcall_name);
			
            //changes from Jöran Karl (28.03.2012)
	    if(getvalue(env_FSG_DisconnectReason_Active) != FALSE)
            {
    			//DisconnectReason
    			gDisconnectReason=connectedline_busy;
    			putvalue(env_FSG_DisconnectReason, gDisconnectReason);
    			DisconnectReason_Request(Data_REQ, 0);										//send Disconnect Reason
            }

			//Handsfreeonoff
			if(gHandsFreeOnOff==0){
				//IssueList #135
                //gHandsFreeOnOff=1;
				//putvalue(env_FSG_HandsFreeOnOff, gHandsFreeOnOff);

				//IssueList #51
                putvalue(env_FSG_HandsFreeOnOff_OK, 1);
                //HandsFreeOnOff_Request(Data_REQ, 0);							//send handsfree status
			}

	    //during Incoming Call - displaying name in Panel
            for (i=0;i<gCombinedNumbers_TotalNumListElements;i++)
            {
                if (strncmp(gCombinedNumbers_TelNumber[i],gincomingcall_number,strlen(gincomingcall_number)+1)==0)
                {
                strncpy(gincomingcall_name, gCombinedNumbers_PbName[i], CALL_INFO_NAME_LENGTH);
                }

            }
            //callinfo
			strncpy(gCallInfo_PbName[gcallID], gincomingcall_name, CALL_INFO_NAME_LENGTH);
			strncpy(gCallInfo_TelNumber[gcallID], gincomingcall_number, CALL_INFO_NUMBER_LENGTH);
            
            //IssueList #206 -s
             strlength = strlen(gincomingcall_name);
            for(i = 0; i < CALL_INFO_NAME_LENGTH; i++)
            {
                if(i < strlength)                    
                    gCallInfo_PbName_hex[gcallID][i] = gincomingcall_name[i];
                else
                    gCallInfo_PbName_hex[gcallID][i] = 0;
            }
             //IssueList #206 -e

			//changes from Jöran Karl (28.03.2012)
			putvalue_CallInfo(gcallID);

			CallInfo_Request(Data_REQ,0);//callinfo_Request(Changed_REQ, gcallID, 1, 0, 0);
			settimer(incomingcall_changearraytimer, 300);
			gstatus_incomingcall_changearraytimer=1;

			gincomingcall=0;
		}
		else
			write("error numbersearchphonebooktimer: invalid gnumbersearchphonebook-value: %d",searchstatus);
	}
	else if(gmissedcall==1){													//missed call
		gmissedcall=0;
				
		if(searchstatus==1){
			strncpy(gincomingcall_name, gincomingcall_number, CALL_INFO_NUMBER_LENGTH);
			gincomingcall_numbertype=0;
		}

		if(searchstatus==1 || searchstatus==2){
			putvalue(env_FSG_missedcall_name, gincomingcall_name);				//write number of missed call in callstack
			putvalue(env_FSG_missedcall_number, gincomingcall_number);			//write number of missed call in callstack
			putvalue(env_FSG_missedcall_numbertype, gincomingcall_numbertype);	//write numbertype of dialed number in callstack
			//putvalue(env_FSG_missedcall_callstack, 1);							//start call-stack
		}
		else
			write("error numbersearchphonebooktimer: invalid gnumbersearchphonebook-value: %d",searchstatus);
	}
}

on preStart
{
    char Path[255];
    char BAPVersion [100];
    
	// create write window for BAP communication
    gBAP_Trace  =writecreate("BAP-Trace FSG-Telephone");								
	
    // clear BAP trace window
    writeclear(gBAP_Trace);													
	
    // error window for BAP communication
	gError_Trace=writecreate("FSG-TelephoneSD Error");									
	writeclear(gError_Trace);
    
    gCombinedNumbers_writeWindow =writecreate("Telephone CombinedNumbers_Array");
    writeclear(gCombinedNumbers_writeWindow);
	//changes from Jöran Karl (28.03.2012)
    gPhonebook_writeWindow =writecreate("Telephone Phonebook_Array");
    writeclear(gPhonebook_writeWindow);
    
    gReceivedCalls_writeWindow =writecreate("Telephone ReceivedCalls_Array");
    writeclear(gReceivedCalls_writeWindow);	
    
    gDialedNumbers_writeWindow =writecreate("Telephone DialedNumbers_Array");
    writeclear(gDialedNumbers_writeWindow);	
    
    //IssueList #24
    gPhonebook_writeWindow =writecreate("Phonebook_Array");
    writeclear(gPhonebook_writeWindow);	
        											
    //clear CAPL-window in write-window
    writeclear(1);
    
    gMissedCalls_writeWindow =writecreate("Telephone MissedCalls_Array");
    writeclear(gMissedCalls_writeWindow);															

	//get version from Stack
	Bap150_GetVersions(BAPVersion, 100);
	write(" ");
	write("***************************************************");
	write(BAPVersion);
	write("***************************************************");
	write(" ");
	
    
    write("***************************************************");
	write("FSG-Telephone function catalog: 'BAP-FC_TEL_P30DF40_v2.02_F.pdf'");
	write("FSG-Telephone MSCs: 'BAP-MSC_TEL_P30DF40_v2.00.pdf'");
	write("***************************************************");
	

	// Create Node
	NODE_INDEX=Bap150_CreateNode();

    // Debug info
	// write("NODE_INDEX = 0x%x", NODE_INDEX); 

    // Load DBC and XML files. 
	write("*********************************************************************************");

    //load dbc-file
    getAbsFilePath(dbc_path, Path, 255);
	write("FSG-Telephone: Loading BAP_DBC-File: '%s'", Path);
   
	if(Bap150_LoadDBC(NODE_INDEX, 1, Path) != 0)						
		writelineEx(gError_Trace, 0, "FSG-Telephone Fehler beim Laden: '%s'", Path);
    else
        writelineEx(gError_Trace, 0, "FSG-Telephone DBC successfuly loaded");
	//load xml-file 
	getAbsFilePath(xml_path, Path, 255);
    write("FSG-Telephone: Load BAP-XML-File: '%s'", Path);
	
    if (Bap150_LoadConfig(NODE_INDEX, Path) != 0) 
	    writelineEx(gError_Trace, 0, "FSG-Telephone: Fehler beim Laden: '%s' !", Path);
    else
        writelineEx(gError_Trace, 0, "FSG-Telephone XML successfuly loaded");	   
    write("*********************************************************************************");
    write("");

    // BAP DLL: Add CAN channel: BAP channel 1 is mapped to CAN card channel 1.
	Bap150_AddCanMap(NODE_INDEX, 1, 1);
    
} /* end of method */

BAP_CAN_TX_Request()
{
   int i;
   byte TX_Data[8];				//CAN-data
   dword TX_Header[3];			//CAN-header
   message 0x100 TX_Message;	//dummy-message
   
   TX_Header[2] = 8; // max-Length of TX_Data

   while (BAP150_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) {	//get BAP-data in CAN-format from DLL
      TX_Message.CAN = TX_Header[0]; 		//CAN channel
      TX_Message.ID =TX_Header[1]; 			//Can ID
      TX_Message.DLC = TX_Header[2]; 		// received length
      for (i=0; i<TX_Message.DLC; i++) {	//CAN data-bytes
	    TX_Message.byte(i) = TX_Data[i];
      }
      output(TX_Message);					//send CAN message

	  TX_Header[2] = 8; 					// max-Length of TX_Data
   } 
}

BAP_DLL_Indication()	//function to get received BAP-data from DLL (at BAL-interface)
{
int i, length, datalength, temp;
byte Indication_data[BAP_buffer_size];		//indication data from DLL
dword Indication_header[6];					//indication header from DLL
byte BAP_data_type;

//init lokal variables
	length=0;
	temp=0;
	datalength=0;
	BAP_data_type=0;

	for(i=0;i<6;i++)
		Indication_header[i]=0;

	for(i=0;i<BAP_buffer_size;i++)
		Indication_data[i]=0;
//********************

	Indication_header[4]=BAP_buffer_size;											//BAP-Stack need this information for successful BAP_GetIndication 


	temp=BAP150_GetInd(NODE_INDEX, Indication_header, Indication_data);				//get BAP-Indication data from DLL
											//debug

	if(temp==0){
		//read header
		gBAP_Indication[0]=Indication_header[0];									//LSG-ID
		gBAP_Indication[1]=Indication_header[1];									//Function-ID
		gBAP_Indication[2]=Indication_header[2];									//indication

		BAP_data_type=Indication_header[3];											//BAP data type
		
		switch(BAP_data_type){
			case Bap_Void:
				datalength=3;

				BAP_Indication(datalength);											//evaluate BAP-Indication data
			break;
			case Bap_UInt8:
				gBAP_Indication[3]=Indication_header[5];							//unit8-value
				
				datalength=4;
				
	/*			writelineEx(gBAP_Trace, 0, "Indication_header:");					//debug
				for (i=0;i<6;i++)													//debug
					writeEX(gBAP_Trace, 0, " %x",Indication_header [i]);			//debug
		*/		
				//writelineEx(gBAP_Trace, 0, "FSG-Telephone Indication: ");			//BAL-Trace
				//for (i=0;i<datalength;i++)											//BAL-Trace
				//	writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace

				BAP_Indication(datalength);											//evaluate BAP-Indication data
			break;
			case Bap_UInt16:
				gBAP_Indication[3]=Indication_header[5];							//unit16-value
				
				datalength=4;
				
	/*			writelineEx(gBAP_Trace, 0, "Indication_header:");					//debug
				for (i=0;i<6;i++)													//debug
					writeEX(gBAP_Trace, 0, " %x",Indication_header [i]);			//debug
		*/		
				//writelineEx(gBAP_Trace, 0, "FSG-Telephone Indication: ");			//BAL-Trace
				//for (i=0;i<datalength;i++)											//BAL-Trace
				//	writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace

				BAP_Indication(datalength);											//evaluate BAP-Indication data
			break;
			case Bap_UInt32:
				gBAP_Indication[3]=Indication_header[5];							//unit32-value
				
				datalength=4;
				
	/*			writelineEx(gBAP_Trace, 0, "Indication_header:");					//debug
				for (i=0;i<6;i++)													//debug
					writeEX(gBAP_Trace, 0, " %x",Indication_header [i]);			//debug
		*/		
				//writelineEx(gBAP_Trace, 0, "FSG-Telephone Indication: ");			//BAL-Trace
				//for (i=0;i<datalength;i++)											//BAL-Trace
				//	writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace

				BAP_Indication(datalength);											//evaluate BAP-Indication data
			break;
			case Bap_ByteSequence:					//BAP-data-type is byte sequence
				//read datalength
				length=Indication_header[4];		//length of date-array
				datalength=length+3;				//length of indication-array

				//read data-array
				for(i=0;i<length;i++)
					gBAP_Indication[i+3]=Indication_data[i];

/*				writelineEx(1, 0, "Indication_header:");							//debug
				for (i=0;i<6;i++)													//debug
					writeEX(1, 0, " %x",Indication_header [i]);						//debug
		
				writelineEx(1, 0, "Indication_data:");								//debug
				for (i=0;i<datalength;i++)											//debug
					writeEX(1, 0, " %x",Indication_data [i]);						//debug
	*/			
				//writelineEx(gBAP_Trace, 0, "FSG-Telephone Indication: ");						//BAL-Trace
				//for (i=0;i<datalength;i++){											//BAL-Trace
				//	writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace
				//	if(i>20){
				//		i=datalength;
				//		writeEX(gBAP_Trace, 0, "...");
				//	}
				//}

				BAP_Indication(datalength);											//evaluate BAP-Indication data
			break;

            //ab bap150

           case Bap_Acknowledge:
           //IssueList #104
	        //changes from Jan Swoboda 21.06.2012
                gAcknowledgePending[gBAP_Indication[1]] = 0;

				gBAP_Indication[3] = Indication_header[5];							//unit32-value
				datalength=4;
                    
                ////+
                //write("Fct-ID: %x, ack type: %x", gBAP_Indication[1], gBAP_Indication[3]);
                //gLastAcknowlegdeData[0] = gBAP_Indication[0]; // LSG-ID
                //gLastAcknowlegdeData[1] = gBAP_Indication[1]; // Function-ID
                //gLastAcknowlegdeData[2] = gBAP_Indication[3]; // Acknowledge type
                ////+
	/* 			
				//writelineEx(gBAP_Trace, 0, "Indication_header:");					//debug
				//for (i=0;i<6;i++)													//debug
				//	writeEX(gBAP_Trace, 0, " %x",Indication_header [i]);			//debug
				
		*/		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                writelineEx(gBAP_Trace, 0, "FSG-Telephone Indication-Ack: ");			//BAL-Trace
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
				////for (i=0;i<datalength;i++)											//BAL-Trace
				////	writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace										//evaluate BAP-Indication data
			break;
            
			default:
				writelineEx(gError_Trace, 0, "FSG-Telephone BAP_DLL_Indication: invalid BAP-Data-Type: %d", BAP_data_type);
			break;
		}	
	}
}

BAP_DLL_Request ()
{
int i, datalength, temp;
byte Request_data[BAP_buffer_size];	//Request data for DLL
dword Request_header[6];	//Request header for DLL
byte Wammw;					//data-error-flag (Geräusch)

//init lokal variables
	datalength=0;
	temp=0;
	Wammw=1;

	for(i=0;i<6;i++)
		Request_header[i]=0;

	for(i=0;i<BAP_buffer_size;i++)
		Request_data[i]=0;
//********************

   
	if(gBAP_Requestbufffer_status [gstatus_requestbuffer]>0){							//if ready to send
		switch(gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]){
			case Bap_Void:
				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
				Request_header[4]=0;														//not used
				Request_header[5]=0;														//not used
			break;
			case Bap_UInt8:
				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
				Request_header[4]=0;														//not used
				Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit8-value
			break;
			case Bap_UInt16:
				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
				Request_header[4]=0;														//not used
				Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit16-value
			break;
			case Bap_UInt32:
				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
				Request_header[4]=0;														//not used
				Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit32-value
			break;
			case Bap_ByteSequence:					//BAP-data-type is byte sequence
				datalength=gBAP_Requestbufffer_status [gstatus_requestbuffer]-3;

				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=Bap_ByteSequence;											//BAP data type
				Request_header[4]=datalength;												//length of date-array
                
				//data-array for BAP-DLL funcion 'BAP_Request'
				for(i=0;i<datalength;i++)
					Request_data[i]=gBAP_Request[gstatus_requestbuffer] [i+3];

				/* writelineEx(1, 0, "Request_header:");							//debug
				for (i=0;i<6;i++)												//debug
					writeEX(1, 0, " %x",Request_header [i]);					//debug
				
				writelineEx(1, 0, "Request_data:");								//debug
				for (i=0;i<datalength;i++)										//debug
					writeEX(1, 0, " %x",Request_data [i]);						//debug
				*/

			break;
			case Bap_Error:
				//request-array for BAP-DLL funcion 'BAP_Request'
				Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
				Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
				Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
				Request_header[3]=gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
				Request_header[4]=0;														//not used
				Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//error code
			break;
			default:
				writelineEx(gError_Trace, 0, "FSG-Telephone BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]);
				Wammw=0;
			break;			
		}
		
		if(Wammw){																			//no data-error
			temp=BAP180_Request(NODE_INDEX, Request_header, Request_data);						//send data to BAP-DLL
		
			if(temp==0){		//BAP-Request successful
				////if(gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]==Bap_Error){
				////	writelineEx(gBAP_Trace, 0, "FSG-Telephone Error-Request: ");				//BAL-Trace
				////	writeEX(gBAP_Trace, 0, "LSG-ID: 0x%x   ", gBAP_Request[gstatus_requestbuffer][0]);			//BAL-Trace
				////	writeEX(gBAP_Trace, 0, "Fct-ID: 0x%x   ", gBAP_Request[gstatus_requestbuffer][1]);			//BAL-Trace
				////	writeEX(gBAP_Trace, 0, "Error-Code: 0x%x   ", gBAP_Request[gstatus_requestbuffer][3]);		//BAL-Trace
				////}
				////else{
				////	writelineEx(gBAP_Trace, 0, "FSG-Telephone Request:    ");								//BAL-Trace		
				////	for (i=0;i<gBAP_Requestbufffer_status [gstatus_requestbuffer];i++)			//BAL-Trace	
				////		writeEX(gBAP_Trace, 0, " 0x%x",gBAP_Request [gstatus_requestbuffer] [i]);	//BAL-Trace	
				//	write("Send buffer-element %d to BAP-DLL", gstatus_requestbuffer); 			//debug
				////}
			}
			else{				//BAP-Request error
				writelineEx(gBAP_Trace, 0, "FSG-Telephone Error BAP_Request, errorcode: 0x%x FSG-Telephone Request:",temp);				//debug
				for (i=0;i<gBAP_Requestbufffer_status [gstatus_requestbuffer];i++)														//debug
					writeEX(gBAP_Trace, 0, " 0x%x",gBAP_Request [gstatus_requestbuffer] [i]);														//debug
			}
		}

		gBAP_Requestbufffer_status [gstatus_requestbuffer]=0;	//reset position status -> free position 
		gBAP_Requestbufffer_BAPDataTyp [gstatus_requestbuffer]=0;	//reset BAP-datatyp of sendet buffer element

		//delete sendet request buffer elements
		gBAP_Requestbufffer_status [gstatus_requestbuffer]=0;
		for(i=0;i<BAP_buffer_size;i++)
			gBAP_Request [gstatus_requestbuffer] [i]=0;		//delete sended array
		
		if (gstatus_requestbuffer<(Requestbuffer_lines-1))	//last element of buffer is not reached
			gstatus_requestbuffer++;
		else												//last element of buffer is reached
			gstatus_requestbuffer=0;
	}
}

BAP_Indication(int length)	//evaluate LSG-ID
{
	if(length!=0){
		switch(gBAP_Indication[0]){
			case LSG_TELEPHONE:
				telephone_functions(gBAP_Indication [1], length);
			break;
			case LSG_PHONEBOOK:
				phonebook_functions(gBAP_Indication [1], length);
			break;
			default:
				writelineEx(gError_Trace, 0, "FSG-Telephone error BAP_Indication: invalid LSG-ID %x", gBAP_Indication[0]);
			break;
		}
	}
}

BAP_Set_Cache ()	//initialize BAP-FSG-Cache
{
dword Cache_Request_Header[6];					//Cache header for DLL
byte Cache_Request_Data[BAP_buffer_size];		//Cache data for DLL
//changes from Jöran Karl (28.03.2012)
byte i, j, Offset, temp;

	Offset=0;

//***********************************************************************************************************************************
//************************************************Telephone**************************************************************************
//***********************************************************************************************************************************
//*********************FunctionList**********************************
//	if(gFunctionListModified)
//	{
		//header
		Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
		Cache_Request_Header[1] = FctID_FunctionList;			//Fct-ID
		Cache_Request_Header[2] = 0;							//ignored
		Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
		Cache_Request_Header[4] = 8;							//length
		Cache_Request_Header[5] = 0;              				//ignored

        initFunctionList();	

		Cache_Request_Data[0]=gFunctionList0;
		Cache_Request_Data[1]=gFunctionList1;
		Cache_Request_Data[2]=gFunctionList2;
		Cache_Request_Data[3]=gFunctionList3;
		Cache_Request_Data[4]=gFunctionList4;
		Cache_Request_Data[5]=gFunctionList5;
		Cache_Request_Data[6]=gFunctionList6;
		Cache_Request_Data[7]=gFunctionList7;

        //write("Debug Fctlist-values: %x, %x, %x, %x, %x, %x, %x, %x", gFunctionList0, gFunctionList1, gFunctionList2, gFunctionList3, gFunctionList4, gFunctionList5, gFunctionList6, gFunctionList7);

		temp=0;
		temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
		if(temp!=0)
			write("Telephone: BAP_Init FunctionList errorcode: %d", temp);
//	}
//*******************************************************************

//IssueList #23
//*********************HeartBeat************************************

    //header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_HeartBeat;		    	//Fct-ID
	Cache_Request_Header[2] = 0;						    //ignored
	Cache_Request_Header[3] = Bap_UInt8;				    //data-type
//	Cache_Request_Header[4] = 0;						    //ignored
	if (getValue(env_FSG_Telephone_HB_button))
    Cache_Request_Header[5] = getValue(env_FSG_Telephone_HB_input);
    else
    Cache_Request_Header[5] = 0;

    
    Tel_HBdata[0] = LSGID_Telephone;
    Tel_HBdata[1] = Cache_Request_Header[5];
    
    ChangeConfig(0x00,Tel_HBdata);
    
    temp=0;
    temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
		if(temp!=0)
			write("Telephone: BAP_Init FunctionList errorcode: %d", temp);

//*******************************************************************

//*********************FSG_Setup************************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_FSG_Setup;		    	//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	Cache_Request_Header[4] = 2;							//length
	Cache_Request_Header[5] = 0;              				//ignored
	
	Cache_Request_Data[0]=gPhoneCharacteristics;
	Cache_Request_Data[1]=gMobileConnectionType;

	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init FSG_Setup errorcode: %d", temp);
//*******************************************************************

//*********************FSG_OperationState************************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_FSG_OperationState;    	//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	Cache_Request_Header[4] = 3;							//length
	Cache_Request_Header[5] = 0;              				//ignored
	
	Cache_Request_Data[0]=gOP_State;
	Cache_Request_Data[1]=gTel_State;
    Cache_Request_Data[2]=gPrivacyMode;

	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init FSG_OperationState errorcode: %d", temp);
//*******************************************************************

//*********************MobilServiceSupport***************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_MobilServiceSupport;	//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	Cache_Request_Header[4] = 8;							//length
	Cache_Request_Header[5] = 0;              				//ignored

	Cache_Request_Data[0]=gMobilServiceSupport0;
	Cache_Request_Data[1]=gMobilServiceSupport1;
	Cache_Request_Data[2]=gMobilServiceSupport2;
	Cache_Request_Data[3]=gMobilServiceSupport3;
	Cache_Request_Data[4]=gMobilServiceSupport4;
	Cache_Request_Data[5]=gMobilServiceSupport5;
	Cache_Request_Data[6]=gMobilServiceSupport6;
	Cache_Request_Data[7]=gMobilServiceSupport7;


	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init MobilServiceSupport errorcode: %d", temp);
//*******************************************************************

//***************************active user*****************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_ActiveUser;		    	//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	Cache_Request_Header[4] = 1+strlen(gUserName);			//length
	Cache_Request_Header[5] = 0;              				//ignored

	Offset=0;
	Cache_Request_Data[Offset]=strlen(gUserName);
	Offset++;
	for(i=0;i<strlen(gUserName);i++){
		Cache_Request_Data[Offset]=gUserName[i];
		Offset++;
	}

	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init ActiveUser errorcode: %d", temp);
//*******************************************************************

//*********************RegisterState************************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_RegisterState;	    	//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	Cache_Request_Header[4] = 3;							//length
	Cache_Request_Header[5] = 0;              				//ignored
	
	Cache_Request_Data[0]=gRegisterState;
	Cache_Request_Data[1]=gNetworkType;
    Cache_Request_Data[2]=gPacketDataNetworkType;

	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init RegisterState errorcode: %d", temp);
//*******************************************************************

//*********************Lock state************************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;			//LSG-ID
	Cache_Request_Header[1] = FctID_LockState;			//Fct-ID
	Cache_Request_Header[2] = 0;						//ignored
	Cache_Request_Header[3] = Bap_UInt8;				//data-type
	Cache_Request_Header[4] = 0;						//ignored
	Cache_Request_Header[5] = gLockState;              	//unit8- value
	
	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init LockState errorcode: %d", temp);
//*******************************************************************

//*********************NetworkProvider************************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_NetworkProvider;    	//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	Cache_Request_Header[4] = 4+strlen(gNetworkProviderName)+strlen(gServiceProviderName);	//length: 1 byte gNetworkProviderState, 1 byte gServiceProviderState, 2 x 1 byte stringlength
	Cache_Request_Header[5] = 0;              				//ignored
	
	Cache_Request_Data[0]=gNetworkProviderState;
	Cache_Request_Data[1]=strlen(gNetworkProviderName);
    Offset=2;		
	for(i=0;i<strlen(gNetworkProviderName);i++)
        {
		Cache_Request_Data[Offset]=gNetworkProviderName[i];
			Offset++;
	    }

	Cache_Request_Data[Offset]=gServiceProviderState;
	Offset++;

    Cache_Request_Data[Offset]=strlen(gServiceProviderName);
    Offset++;
	for(i=0;i<strlen(gServiceProviderName);i++)
        {
		Cache_Request_Data[Offset]=gServiceProviderName[i];
		Offset++;
		}

	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init NetworkProvider errorcode: %d", temp);
//*******************************************************************

//*********************Signal Quality********************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_SignalQuality;			//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_UInt8		;				//data-type
	Cache_Request_Header[4] = 0;							//ignored
	Cache_Request_Header[5] = gSignalQuality;              	//unit8- value
	
	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init Signal Quality errorcode: %d", temp);
//*******************************************************************

//*********************CallState************************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_CallState;				//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	//changes from Jöran Karl (28.03.2012)
	//Cache_Request_Header[4] = 16;							//length
	Cache_Request_Header[5] = 0;              				//ignored
	
   //changes from Jöran Karl (28.03.2012)
    Offset = 0;
    for (j = 0; j < 7; j++)
    {
        Cache_Request_Data[Offset++]=(gCallType[j]+gCallState[j]*0x10);	//call state (upper nibble) and call type (lower nibble)
        Cache_Request_Data[Offset++]=gCallOptions[j];
    }
			
   //changes from Jöran Karl (28.03.2012)
    Cache_Request_Data[Offset] = 0;
    for (j = 0; j < 7; j++)
    {
        Cache_Request_Data[Offset] += gCallIncomingDiverted[j] << j;
    }
    //bit 7 reserved
    //changes from Jöran Karl (28.03.2012)
    Offset++;
    
    Cache_Request_Data[Offset] = 0;
    for (j = 0; j < 8; j++)
    {
        Cache_Request_Data[Offset] += gCallOutgoingDiverted_eCallConfirmationPending[j] << j;
    }
    Offset++;
	Cache_Request_Header[4] = Offset;
            
	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init CallState errorcode: %d", temp);
//*******************************************************************

//*********************CallInfo************************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_CallInfo;    	//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	//changes from Jöran Karl (28.03.2012)
	//Cache_Request_Header[4] = 21+strlen(gCallInfo_PbName[0])+strlen(gCallInfo_TelNumber[0])+strlen(gCallInfo_PbName[1])+strlen(gCallInfo_TelNumber[1])+strlen(gCallInfo_PbName[2])+strlen(gCallInfo_TelNumber[2])+strlen(gCallInfo_PbName[3])+strlen(gCallInfo_TelNumber[3])+strlen(gCallInfo_PbName[4])+strlen(gCallInfo_TelNumber[4])+strlen(gCallInfo_PbName[5])+strlen(gCallInfo_TelNumber[5])+strlen(gCallInfo_PbName[6])+strlen(gCallInfo_TelNumber[6]);	//length: 2x7 byte stringlength + 7 byte categroy = 21 byte
	Cache_Request_Header[5] = 0;              				//ignored
	
   //changes from Jöran Karl (28.03.2012)
    Offset = 0;
    for (j = 0; j < CALLINFO; j++)
    {
        Cache_Request_Data[Offset++]=strlen(gCallInfo_PbName[j]);
        for(i=0;i<strlen(gCallInfo_PbName[j]);i++)
        {
            Cache_Request_Data[Offset++]=gCallInfo_PbName[j][i];
        }
        Cache_Request_Data[Offset++]=strlen(gCallInfo_TelNumber[j]);
        for(i=0;i<strlen(gCallInfo_TelNumber[j]);i++)
        {
            Cache_Request_Data[Offset++]=gCallInfo_TelNumber[j][i];
        }
        Cache_Request_Data[Offset++]=gCallInfo_Category[j];
    }
    Cache_Request_Header[4] = Offset;

	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init CallInfo errorcode: %d", temp);
//*******************************************************************

//*********************CallDurationSync************************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_CallDurationSync;				//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	Cache_Request_Header[4] = 14;							//length
	Cache_Request_Header[5] = 0;              				//ignored
            	
	Cache_Request_Data[0]=gTimeStampCall[0];
    Cache_Request_Data[1]=gTimeStampCall[0]/0x100;

	Cache_Request_Data[2]=gTimeStampCall[1];
    Cache_Request_Data[3]=gTimeStampCall[1]/0x100;

	Cache_Request_Data[4]=gTimeStampCall[2];
    Cache_Request_Data[5]=gTimeStampCall[2]/0x100;

	Cache_Request_Data[6]=gTimeStampCall[3];
    Cache_Request_Data[7]=gTimeStampCall[3]/0x100;

	Cache_Request_Data[8]=gTimeStampCall[4];
    Cache_Request_Data[9]=gTimeStampCall[4]/0x100;

	Cache_Request_Data[10]=gTimeStampCall[5];
    Cache_Request_Data[11]=gTimeStampCall[5]/0x100;

	Cache_Request_Data[12]=gTimeStampCall[6];
    Cache_Request_Data[13]=gTimeStampCall[6]/0x100;

	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init CallDurationSync errorcode: %d", temp);

//*********************DisconnectReason************************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_DisconnectReason;		//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_UInt8;					//data-type
	Cache_Request_Header[4] = 0;							//ignored
	Cache_Request_Header[5] = gDisconnectReason;           	//unit8- value
	
	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init Disconnect Reason errorcode: %d", temp);
//*******************************************************************

//*********************HandsFreeOnOff********************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_HandsFreeOnOff;			//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_UInt8;					//data-type
	Cache_Request_Header[4] = 0;							//ignored
	Cache_Request_Header[5] = gHandsFreeOnOff;      		//unit8- value
	
	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init HandsFreeOnOff errorcode: %d", temp);
//*******************************************************************

//*********************MicroMuteOnOff********************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_MicroMuteOnOff;			//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_UInt8;					//data-type
	Cache_Request_Header[4] = 0;							//ignored
	Cache_Request_Header[5] = gMicroMuteOnOff;  					//unit8- value
	
	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init MicroMuteOnOff errorcode: %d", temp);
//*******************************************************************

//********************************Keypad*****************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_Keypad;					//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_UInt8;					//data-type
	Cache_Request_Header[4] = 0;							//ignored
	Cache_Request_Header[5] = gKeypadStatus;      			//unit8- value
	
	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init Keypad errorcode: %d", temp);
//*******************************************************************

//*********************MobileBatteryLevel************************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_MobileBatteryLevel;	    	//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	Cache_Request_Header[4] = 5;							//length
	Cache_Request_Header[5] = 0;              				//ignored
	
	Cache_Request_Data[0]=gChargeLevelMobile1;
	Cache_Request_Data[1]=gChargeLevelMobile2;
    Cache_Request_Data[2]=gChargeLevelHandset1;
    Cache_Request_Data[3]=gChargeLevelHandset2;
    Cache_Request_Data[4]=gWarningLevel;

	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init MobileBatteryLevel errorcode: %d", temp);
//*******************************************************************

//*********************DataConnectionIndication***************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_DataConnectionIndication;	//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	Cache_Request_Header[4] = 9;							//length
	Cache_Request_Header[5] = 0;              				//ignored

	Cache_Request_Data[0]=gConnectionIndication;
    //changes from Jöran Karl (28.03.2012)
    Cache_Request_Data[1]=(gDataVolumeUplink        ) & 0xFF;  //mask lowest byte
    Cache_Request_Data[2]=(gDataVolumeUplink   >>  8) & 0xFF;  //mask second byte
    Cache_Request_Data[3]=(gDataVolumeUplink   >> 16) & 0xFF;  //mask third byte
    Cache_Request_Data[4]=(gDataVolumeUplink   >> 24) & 0xFF;  //mask highest byte

    Cache_Request_Data[5]=(gDataVolumeDownlink      ) & 0xFF; //mask lowest byte
    Cache_Request_Data[6]=(gDataVolumeDownlink >>  8) & 0xFF; //mask second byte
    Cache_Request_Data[7]=(gDataVolumeDownlink >> 16) & 0xFF; //mask third byte
    Cache_Request_Data[8]=(gDataVolumeDownlink >> 24) & 0xFF; //mask highest byte

	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init DataConnectionIndication errorcode: %d", temp);
//*******************************************************************

//*********************MissedCallIndication**************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;           	//LSG-ID
	Cache_Request_Header[1] = FctID_MissedCallIndication;	//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
	Cache_Request_Header[4] = 4;							//length
	Cache_Request_Header[5] = 0;              				//ignored

	//Data
	Cache_Request_Data[0]=gMissedCalls & 0x00ff;			//Lowbyte of MissedCall
	Cache_Request_Data[1]=gMissedCalls & 0xff00;			//Highbyte of MissedCall
	Cache_Request_Data[2]=gMissedNumbers & 0x00ff;			//Lowbyte of MissedCall
	Cache_Request_Data[3]=gMissedNumbers & 0xff00;			//Highbyte of MissedCall
				
	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init MissedCallIndication errorcode: %d", temp);
//*******************************************************************

//*********************PbState**************************************
    //header
 	Cache_Request_Header[0] = LSGID_Telephone;           	//LSG-ID
 	Cache_Request_Header[1] = FctID_PbState;				//Fct-ID
 	Cache_Request_Header[2] = 0;							//ignored
 	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
 	Cache_Request_Header[4] = 3;							//length
 	Cache_Request_Header[5] = 0;              				//ignored
 
 	//Data
 	Cache_Request_Data[0]=gDownLoadState;
 	Cache_Request_Data[1]=gPbEntriesUHV & 0x00ff;			//lowbyte
 	Cache_Request_Data[2]=(gPbEntriesUHV & 0xff00)/0x100;	//highbyte
 		
 	Offset=3;		
 
 	temp=0;
 	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
 	if(temp!=0)
 		write("Telephone: BAP_Init PbState errorcode: %d", temp);
// //*******************************************************************

//*********************SMSState**************************************
    //header
 	Cache_Request_Header[0] = LSGID_Telephone;           	//LSG-ID
 	Cache_Request_Header[1] = FctID_SMSState;				//Fct-ID
 	Cache_Request_Header[2] = 0;							//ignored
 	Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
 	Cache_Request_Header[4] = 4;							//length
 	Cache_Request_Header[5] = 0;              				//ignored
 
 	//Data
 	Cache_Request_Data[0]=gSIMReady;
 	Cache_Request_Data[1]=gStorageState;
 	Cache_Request_Data[2]=gNumberOfNewSMS & 0x00ff;			//lowbyte
 	Cache_Request_Data[3]=(gNumberOfNewSMS & 0xff00)/0x100;	//highbyte
 		
 	Offset=4;		
 
 	temp=0;
 	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
 	if(temp!=0)
 		write("Telephone: BAP_Init SMSState errorcode: %d", temp);
// //*******************************************************************

//*********************RingToneMuteOnOff********************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_RingToneMuteOnOff;		//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_UInt8;					//data-type
	Cache_Request_Header[4] = 0;							//ignored
	Cache_Request_Header[5] = gRingToneMuteOnOff;  					//unit8- value
	
	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init RingToneMuteOnOff errorcode: %d", temp);
//*******************************************************************

//*********************AutomaticRedial*******************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_AutomaticRedial;		//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_UInt8;					//data-type
	Cache_Request_Header[4] = 0;							//ignored
	Cache_Request_Header[5] = gAutomaticRedialState;		//unit8- value
	
	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init AutomaticRedial errorcode: %d", temp);
//*******************************************************************
 
 //IssueList #16
//*********************AutomaticRedialExtendedinfo*******************************
	//header
	Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
	Cache_Request_Header[1] = FctID_AutomaticRedialExtInfo;		//Fct-ID
	Cache_Request_Header[2] = 0;							//ignored
	Cache_Request_Header[3] = Bap_ByteSequence;					//data-type
	//Cache_Request_Header[4] = 16;                         	//length
    Cache_Request_Header[5] = 0;		                    //ignored

	//Data
    //gAutomaticRedialTimeStamp = inputRedialTimeStamp - gSystemTime_seconds;
    //gAutomaticRedialTimeStamp = gInputRedialTimeStamp;

  	Cache_Request_Data[0]=gAutomaticRedialTimeStamp & 0x00ff;			//Lowbyte of RedialTimeStamp
	Cache_Request_Data[1]=(gAutomaticRedialTimeStamp & 0xff00)/0x100;			//Highbyte of RedialTimeStamp

    Offset=2;
            
            Cache_Request_Data[Offset]=strlen(gAutoRedialExtInfo_Name);
            Offset++;

            for(i=0;i<strlen(gAutoRedialExtInfo_Name);i++)
            {
				Cache_Request_Data[Offset]=gAutoRedialExtInfo_Name[i];
				Offset++;
			}
           
            Cache_Request_Data[Offset]=strlen(gAutoRedialExtInfo_Number);
            Offset++;
			
            for(i=0;i<strlen(gAutoRedialExtInfo_Number);i++)
            {
				Cache_Request_Data[Offset]=gAutoRedialExtInfo_Number[i];
				Offset++;
			}
             
             //Category
            Cache_Request_Data[Offset] =gAutomaticRedialCategory;
            Offset++;
  
  Cache_Request_Header[4] = Offset;

	temp=0;
	temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
	if(temp!=0)
		write("Telephone: BAP_Init AutomaticRedial errorcode: %d", temp);

//IssueList #206
//-- Property SupportedServiceNumbers -----------------------------------------------
  Cache_Request_Header[0] = LSGID_Telephone;				        //LSG-ID
  Cache_Request_Header[1] = FctID_SupportedServiceNumbers;	//Fct-ID
  Cache_Request_Header[2] = 0;							                //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;					      //data-type
  Cache_Request_Header[4] = 3;	                            //length
  Cache_Request_Header[5] = 0;              				        //ignored


  Cache_Request_Data[0] = 0x00;
  Cache_Request_Data[1] = 0x00;
  Cache_Request_Data[2] = 0x00;
 
  if(BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data))
    write("Telephone: BAP_Init SupportetServiceNumbers errorcode: %d", temp);






//******************************************************************* 

}

on timer TaskTimer
{

	BAP150_Task(NODE_INDEX);	//DLL-Task

	BAP_DLL_Indication();

	BAP_DLL_Request();

    if (getValue(eSendEnabled))
    {
	    if (getValue(KCAN__NMH_ICAS1_Gateway_CommActive))
	    {
		    BAP_CAN_TX_Request();
	    }
    }

	setTimer(TaskTimer, 10);	//restart real CAN-communication timer
}

on envVar env_FSG_Power_on_off
{
int length, temp;

	putvalue(env_FSG_string_Power_on_off, gstring_FSG_Telephone_PowerOnOff [getvalue(env_FSG_Power_on_off)]);	

	if(getvalue(env_FSG_Power_on_off)==1)
    {
	//	EnableControl("FSG-Telephone-FctList", "Telephone_FctList", 0);

		if(gBAP_Init==0)
		{
			gBAP_Init=1;
			//BAP-Init Telephone
			temp=BAP150_Init(NODE_INDEX,LSGID_Telephone);
		 	if(temp==0)
				write("FSG-Telephone BAP_Init successful");
			else
				write("FSG-Telephone error BAP_Init: %d", temp);

		}       

		init_variables();							//initialize variables

		// init data for bapconfig message.
        initBapConfig();

        //MissedCalls_init_static();                    //initialize callstacks

		//IssueList #80 - loading of short lists
        //Phonebook_init_static();							//initialize phonebook
        putValue(env_Phone_Phonebook_list_short,1);
        
        //ReceivedCalls_init_static();                     //initialize ReceivedCalls

        //DialedNumbers_init_static();                     //initialize DialedNumbers
        
        //IssueList #80 and IssueList #194 - loading of short lists
        //CombinedNumbers_init_static();					//initialize CombinedNumbers
        putValue(env_Phone_CombNum_list_short,1);


        BAP_Set_Cache();							//initialize Cache	

		//BAP-Start Telephone
		temp=BAP150_Start(NODE_INDEX,LSGID_Telephone);
		if(temp==0)
			write("FSG-Telephone BAP_Start successful");
		else
			write("FSG-Telephone error BAP_Start: %d", temp);

		settimer(Powerontimer, 20);

	//	settimer(test, 10);

	}
	else
    {
		BAP150_Shutdown(NODE_INDEX,LSGID_Telephone);

		gFSG_Telephone_PowerOnOff=getvalue(env_FSG_Power_on_off);
		Shutdown_FSG_Telephone();

	//	EnableControl("FSG-Telephone-FctList", "Telephone_FctList", 1);
	}
}

shutdown_FSG_Telephone ()
{
int i, j;
char empty_string [3];

//IssueList #206
byte empty_data[3];

//init lokal variables
	for(i=0;i<3;i++)
    {
		empty_string[i]=0;
        //IssueList #206
        empty_data[i] = 0;
    }
//********************

	//Timer
	canceltimer(acceptcallTimer);
	canceltimer(agetimer);
	canceltimer(busy_hangup_timer);
	canceltimer(CallHoldTimer);
	canceltimer(ResumeCallTimer);
	canceltimer(CallStackDeleteAllTimer);
	canceltimer(CCJoinTimer);
	canceltimer(CCSplitTimer);
	canceltimer(checknetworktimer);
    canceltimer(DataConnectionIndicationTimer);
	canceltimer(DialedNumbersDeleteEntryTimer);
	canceltimer(dialnumber_changearraytimer);
	canceltimer(dialtimer);
	canceltimer(disconnectingtimer);
	canceltimer(disconnectingtimer2);
	canceltimer(handsfreeresettimer);
	canceltimer(incomingcall_changearraytimer);
	canceltimer(KeypadTimer);
	canceltimer(MissedCallsDeleteEntryTimer);
	canceltimer(MPCHAWCTimer);
	canceltimer(MPRACAWCTimer);
	canceltimer(MPRAllCAWCTimer);
	canceltimer(MPSwapTimer);
	canceltimer(nonetworktimer);
	canceltimer(numbersearchphonebooktimer);
	canceltimer(PbDownload_timer);
	canceltimer(PbDownloadAborted_timer);
	canceltimer(PbStartDownload_timer);
	canceltimer(PhoneOnOffTimer);
	canceltimer(Powerontimer);
	canceltimer(registerstatetimer);
	canceltimer(ReceivedCallsDeleteEntryTimer);
	canceltimer(RestoreFactorySettingsTimer);
	canceltimer(signalqualitytimer);
	canceltimer(TaskTimer);

    //IssueList #104
	//changes from Jan Swoboda 21.06.2012
    canceltimer(dialnumber_result_timer);


	//BAP-DLL
	BAP150_Shutdown(NODE_INDEX,LSGID_Telephone);

	//Panel-values
	//IncomingCallnumber
	putvalue(env_FSG_incomingcallstring, empty_string);

//***********************************************************************************************************************************
//**********************************************Phone****************************************************************************
//***********************************************************************************************************************************

	//FSG_Setup
	putvalue(env_FSG_SIMCardReader, 0);
	putvalue(env_FSG_CableConnection, 0);
	putvalue(env_FSG_HFPConnection, 0);
	putvalue(env_FSG_RSAPConnection, 0);
	putvalue(env_FSG_MobileConnectionType, 0);

	//FSG_OperationState
	gTel_State=PhoneInitilisation;

	//active user
	putvalue(env_FSG_SIMSerial, empty_string);
	putvalue(env_FSG_SerialNumber, empty_string);
	putvalue(env_FSG_UserName, empty_string);

	//lockstate
	putvalue(env_FSG_LockState,0x08);

	//registerstate
	putvalue(env_FSG_SIMstatus, 0);
    gRegisterState=notregisteredandnotsearching;
    putvalue(env_FSG_RegisterState, gRegisterState);
    gNetworkType=UNKNOWN_NT;
    putvalue(env_FSG_NetworkType,gNetworkType);

			
	//networkprovidername
	putvalue(env_FSG_NetworkProviderState, 0);

	//SignalQuality
	putvalue(env_FSG_SignalQuality, 0);
	putvalue(env_FSG_SignalQuality_Mode, 2);

	//NetInfo
	gNetInfoCallDivert=2;
	gNetInfoCiphering=2;
	putvalue(env_FSG_NetInfoCallDivert, gNetInfoCallDivert);
	putvalue(env_FSG_NetInfoCiphering, gNetInfoCiphering);

	//DisconnectReason
	putvalue(env_FSG_DisconnectReason, 0);
	
	//CallState
	putvalue(env_FSG_CallState_CallID_0, empty_string);
	putvalue(env_FSG_CallState_CallID_1, empty_string);
	putvalue(env_FSG_CallState_CallID_2, empty_string);
	putvalue(env_FSG_CallState_CallID_3, empty_string);
	putvalue(env_FSG_CallState_CallID_4, empty_string);
	putvalue(env_FSG_CallState_CallID_5, empty_string);
	putvalue(env_FSG_CallState_CallID_6, empty_string);
	//CallType
	putvalue(env_FSG_CallType_CallID_0, empty_string);
	putvalue(env_FSG_CallType_CallID_1, empty_string);
	putvalue(env_FSG_CallType_CallID_2, empty_string);
	putvalue(env_FSG_CallType_CallID_3, empty_string);
	putvalue(env_FSG_CallType_CallID_4, empty_string);
	putvalue(env_FSG_CallType_CallID_5, empty_string);
	putvalue(env_FSG_CallType_CallID_6, empty_string);

	//CallActivity
	putvalue(env_FSG_CallActivity, empty_string);
	//CallIncomingDiverted
	putvalue(env_FSG_CallState_CallDivert_0, empty_string);
	putvalue(env_FSG_CallState_CallDivert_1, empty_string);
	putvalue(env_FSG_CallState_CallDivert_2, empty_string);
	putvalue(env_FSG_CallState_CallDivert_3, empty_string);
	putvalue(env_FSG_CallState_CallDivert_4, empty_string);
	putvalue(env_FSG_CallState_CallDivert_5, empty_string);
	putvalue(env_FSG_CallState_CallDivert_6, empty_string);

	putvalue(env_FSG_CallState_CallID_0_set,idle);
	putvalue(env_FSG_CallState_CallID_1_set,idle);
	putvalue(env_FSG_CallState_CallID_2_set,idle);
	putvalue(env_FSG_CallState_CallID_3_set,idle);
	putvalue(env_FSG_CallState_CallID_4_set,idle);
	putvalue(env_FSG_CallState_CallID_5_set,idle);
	putvalue(env_FSG_CallState_CallID_6_set,idle);

	putvalue(env_FSG_CallType_CallID_0_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_1_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_2_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_3_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_4_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_5_set,unknowncalltype);
	putvalue(env_FSG_CallType_CallID_6_set,unknowncalltype);
	
	putvalue(env_FSG_CallState_CallInDive_0_s, 0);
	putvalue(env_FSG_CallState_CallInDive_1_s, 0);
	putvalue(env_FSG_CallState_CallInDive_2_s, 0);
	putvalue(env_FSG_CallState_CallInDive_3_s, 0);
	putvalue(env_FSG_CallState_CallInDive_4_s, 0);
	putvalue(env_FSG_CallState_CallInDive_5_s, 0);
	putvalue(env_FSG_CallState_CallInDive_6_s, 0);

	putvalue(env_FSG_CallState_CallOuDive_0_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_1_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_2_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_3_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_4_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_5_s, 0);
	putvalue(env_FSG_CallState_CallOuDive_6_s, 0);
    putvalue(env_FSG_CallState_CallOuDive_7_s, 0);

    putvalue(env_FSG_CallState_Opt_AcCall_0_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_1_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_2_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_3_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_4_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_5_s, 0);
	putvalue(env_FSG_CallState_Opt_AcCall_6_s, 0);

    putvalue(env_FSG_CallState_Opt_HoldAc_0_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_1_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_2_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_3_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_4_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_5_s, 0);
	putvalue(env_FSG_CallState_Opt_HoldAc_6_s, 0);

    putvalue(env_FSG_CallState_Opt_CallAc_0_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_1_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_2_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_3_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_4_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_5_s, 0);
	putvalue(env_FSG_CallState_Opt_CallAc_6_s, 0);

    putvalue(env_FSG_CallState_Opt_CallHo_0_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_1_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_2_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_3_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_4_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_5_s, 0);
	putvalue(env_FSG_CallState_Opt_CallHo_6_s, 0);

    putvalue(env_FSG_CallState_Opt_ResCal_0_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_1_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_2_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_3_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_4_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_5_s, 0);
	putvalue(env_FSG_CallState_Opt_ResCal_6_s, 0);

    putvalue(env_FSG_CallState_Opt_MPSwap_0_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_1_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_2_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_3_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_4_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_5_s, 0);
	putvalue(env_FSG_CallState_Opt_MPSwap_6_s, 0);

    putvalue(env_FSG_CallState_Opt_CCJoin_0_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_1_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_2_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_3_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_4_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_5_s, 0);
	putvalue(env_FSG_CallState_Opt_CCJoin_6_s, 0);
    
    putvalue(env_FSG_CallState_Opt_CCSpli_0_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_1_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_2_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_3_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_4_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_5_s, 0);
	putvalue(env_FSG_CallState_Opt_CCSpli_6_s, 0);
    
    
    
    //HandsFree
	//gheadset_available=0;
	putvalue(env_FSG_HandsFreeOnOff, 0);
	//putvalue(env_FSG_Headset_available, 0);

	//MicroMuteOnOff
	putvalue(env_FSG_MicroMuteOnOff, 0);

	//CallInfo
	//PbName
	putvalue(env_FSG_CallInfo_PbName_0, empty_string);
	putvalue(env_FSG_CallInfo_PbName_1, empty_string);
	putvalue(env_FSG_CallInfo_PbName_2, empty_string);
	putvalue(env_FSG_CallInfo_PbName_3, empty_string);
	putvalue(env_FSG_CallInfo_PbName_4, empty_string);
	putvalue(env_FSG_CallInfo_PbName_5, empty_string);
	putvalue(env_FSG_CallInfo_PbName_6, empty_string);

    //IssueList #206 - s
    //Pbname_hex
    putvalue(env_FSG_CallInfo_PbName_0_data, empty_data);
    putvalue(env_FSG_CallInfo_PbName_1_data, empty_data);
    putvalue(env_FSG_CallInfo_PbName_2_data, empty_data);
    putvalue(env_FSG_CallInfo_PbName_3_data, empty_data);
    putvalue(env_FSG_CallInfo_PbName_4_data, empty_data);
    putvalue(env_FSG_CallInfo_PbName_5_data, empty_data);
    putvalue(env_FSG_CallInfo_PbName_6_data, empty_data);
    //IssueList #206 - e
	
    putvalue(env_FSG_CallInfo_PbName_0_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_1_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_2_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_3_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_4_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_5_s,empty_string);
    putvalue(env_FSG_CallInfo_PbName_6_s,empty_string);

    //TelNumber
	putvalue(env_FSG_CallInfo_TelNumber_0, empty_string);
	putvalue(env_FSG_CallInfo_TelNumber_1, empty_string);
	putvalue(env_FSG_CallInfo_TelNumber_2, empty_string);
	putvalue(env_FSG_CallInfo_TelNumber_3, empty_string);
	putvalue(env_FSG_CallInfo_TelNumber_4, empty_string);
	putvalue(env_FSG_CallInfo_TelNumber_5, empty_string);
	putvalue(env_FSG_CallInfo_TelNumber_6, empty_string);

    putvalue(env_FSG_CallInfo_TelNumber_0_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_1_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_2_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_3_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_4_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_5_s, empty_string);
    putvalue(env_FSG_CallInfo_TelNumber_6_s, empty_string);

    //Category
    putvalue(env_FSG_CallInfo_Category_0_s, 0);
    putvalue(env_FSG_CallInfo_Category_1_s, 0);
    putvalue(env_FSG_CallInfo_Category_2_s, 0);
    putvalue(env_FSG_CallInfo_Category_3_s, 0);
    putvalue(env_FSG_CallInfo_Category_4_s, 0);
    putvalue(env_FSG_CallInfo_Category_5_s, 0);
    putvalue(env_FSG_CallInfo_Category_6_s, 0);

    //IssueList #20
    putvalue(env_FSG_CallInfo_Category_0, empty_string);
    putvalue(env_FSG_CallInfo_Category_1, empty_string);
    putvalue(env_FSG_CallInfo_Category_2, empty_string);
    putvalue(env_FSG_CallInfo_Category_3, empty_string);
    putvalue(env_FSG_CallInfo_Category_4, empty_string);
    putvalue(env_FSG_CallInfo_Category_5, empty_string);
    putvalue(env_FSG_CallInfo_Category_6, empty_string);
    
	//dialnumber
	putvalue(env_FSG_dialednumber_free_busy, 2);

    //MobileBatteryLevel
    putvalue(env_FSG_ChargeLevelM1,0xFF);
    putvalue(env_FSG_ChargeLevelM2,0xFF);
    putvalue(env_FSG_ChargeLevelH1,0xFF);
    putvalue(env_FSG_ChargeLevelH2,0xFF);
    
    //MissedCallIndication
	putvalue(env_FSG_MissedCalls, 0);
	putvalue(env_FSG_MissedNumbers, 0);

    //SMSState
	putvalue(env_FSG_SIMReady, 0);
	putvalue(env_FSG_StorageState, 0);
	putvalue(env_FSG_NumberOfNewSMS, 0);

    //RingToneMuteOnOff
    putvalue(env_FSG_RingToneMuteOnOff,0);

    //***********************************arrays******************************************************************************

    //Array CombinedNumbers
    putvalue(env_FSG_CN_ASGID, 0);
    putvalue(env_FSG_CN_TAID, 0);
    putvalue(env_FSG_CN_TotalNumLE, 0);
    putvalue(env_FSG_CN_AH_shift, FALSE);
    putvalue(env_FSG_CN_AH_dir, FORWARD);
    putvalue(env_FSG_CN_AH_POS, FALSE);
    putvalue(env_FSG_CN_AH_IS, FALSE);
    putvalue(env_FSG_CN_AH_RA, 0);
    putvalue(env_FSG_CN_AH_start, 0);
    putvalue(env_FSG_CN_AH_elements, 0);
    putvalue(env_FSG_CN_DataSource, 0);
    putvalue(env_FSG_CN_CSVPath, empty_string);
    putvalue(env_FSG_CN_DataSource_result, empty_string);
    putvalue(env_FSG_CN_DataSource_file, empty_string);
    putvalue(env_FSG_CN_CA_switch, FALSE);

    //Array ReceivedCalls
    putvalue(env_FSG_RC_ASGID, 0);
    putvalue(env_FSG_RC_TAID, 0);
    putvalue(env_FSG_RC_TotalNumLE, 0);
    putvalue(env_FSG_RC_AH_shift, FALSE);
    putvalue(env_FSG_RC_AH_dir, FORWARD);
    putvalue(env_FSG_RC_AH_POS, FALSE);
    putvalue(env_FSG_RC_AH_IS, FALSE);
    putvalue(env_FSG_RC_AH_RA, 0);
    putvalue(env_FSG_RC_AH_start, 0);
    putvalue(env_FSG_RC_AH_elements, 0);
    putvalue(env_FSG_RC_DataSource, 0);
    putvalue(env_FSG_RC_CSVPath, empty_string);
    putvalue(env_FSG_RC_DataSource_result, empty_string);
    putvalue(env_FSG_RC_DataSource_file, empty_string);
    putvalue(env_FSG_RC_CA_switch, FALSE);

    //Array DialedNumbers
    putvalue(env_FSG_DN_ASGID, 0);
    putvalue(env_FSG_DN_TAID, 0);
    putvalue(env_FSG_DN_TotalNumLE, 0);
    putvalue(env_FSG_DN_AH_shift, FALSE);
    putvalue(env_FSG_DN_AH_dir, FORWARD);
    putvalue(env_FSG_DN_AH_POS, FALSE);
    putvalue(env_FSG_DN_AH_IS, FALSE);
    putvalue(env_FSG_DN_AH_RA, 0);
    putvalue(env_FSG_DN_AH_start, 0);
    putvalue(env_FSG_DN_AH_elements, 0);
    putvalue(env_FSG_DN_DataSource, 0);
    putvalue(env_FSG_DN_CSVPath, empty_string);
    putvalue(env_FSG_DN_DataSource_result, empty_string);
    putvalue(env_FSG_DN_DataSource_file, empty_string);
    putvalue(env_FSG_DN_CA_switch, FALSE);	

    //IssueList #27	
    /* Error Codes and State */
    putvalue(env_Tel_AutoRedial_Error_On, FALSE);
    putvalue(env_Tel_AutoRedial_Error_Code, 0); 

    putvalue(env_Tel_RingToneMute_Error_On, FALSE);
    putvalue(env_Tel_RingToneMute_Error_Code, 0);

    putvalue(env_Tel_MissedCallInd_Error_On, FALSE);
    putvalue(env_Tel_MissedCallInd_Error_Code, 0);
    
    putvalue(env_Tel_HandsFree_Error_On, FALSE);
    putvalue(env_Tel_HandsFree_Error_Code, 0);
    
    putvalue(env_Tel_MicroMute_Error_On, FALSE);
    putvalue(env_Tel_MicroMute_Error_Code, 0);  
    
  
  
    //IssueList #47
    putValue(env_FSG_Tel_AcceptCall_Error_On, 0);
    putValue(env_FSG_Tel_AcceptCall_ErrorCode, 0);
    putValue(env_FSG_Tel_CallHold_Error_On, 0);
    putValue(env_FSG_Tel_CallHold_ErrorCode, 0);
    putValue(env_FSG_Tel_CCJoin_Error_On, 0);
    putValue(env_FSG_Tel_CCJoin_ErrorCode, 0);
    putValue(env_FSG_Tel_DialNumber_Error_On, 0);
    putValue(env_FSG_Tel_DialNumber_ErrorCode, 0);
    putValue(env_FSG_Tel_DialServ_Error_On, 0);
    putValue(env_FSG_Tel_DialServ_ErrorCode, 0);
    putValue(env_FSG_Tel_ECall_Error_On, 0);
    putValue(env_FSG_Tel_ECall_ErrorCode, 0);
    putValue(env_FSG_Tel_GetNextListPos_E_O, 0);
    putValue(env_FSG_Tel_GetNextListPos_EC, 0);
    putValue(env_FSG_Tel_HangUpCall_Error_On, 0);
    putValue(env_FSG_Tel_HangUpCall_ErrorCode, 0);
    putValue(env_FSG_Tel_MPCHAWC_Error_On, 0);
    putValue(env_FSG_Tel_MPCHAWC_ErrorCode, 0);
    putValue(env_FSG_Tel_MPRACAWC_Error_On, 0);
    putValue(env_FSG_Tel_MPRACAWC_ErrorCode, 0);
    putValue(env_FSG_Tel_MPRAllCAWC_Error_On, 0);
    putValue(env_FSG_Tel_MPRAllCAWC_ErrorCode, 0);
    putValue(env_FSG_Tel_MPSWAP_Error_On, 0);
    putValue(env_FSG_Tel_MPSWAP_ErrorCode, 0);
    putValue(env_FSG_Tel_MPSWCOH_Error_On, 0);
    putValue(env_FSG_Tel_MPSWCOH_ErrorCode, 0);
    putValue(env_FSG_Tel_PbSpeller_Error_On, 0);
    putValue(env_FSG_Tel_PbSpeller_ErrorCode, 0);
    putValue(env_FSG_Tel_ResumeCall_Error_On, 0);
    putValue(env_FSG_Tel_ResumeCall_ErrorCode, 0);

    //IssueList #62
    putValue(env_FSG_Tel_FctList_0x01_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x02_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x03_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x04_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x05_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x06_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x07_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x08_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x09_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x0A_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x0B_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x0C_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x0D_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x0F_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x10_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x11_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x12_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x13_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x14_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x15_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x16_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x17_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x18_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x19_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x1A_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x1B_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x1C_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x1D_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x1E_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x1F_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x20_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x21_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x23_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x24_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x25_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x26_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x27_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x28_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x29_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x2A_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x2B_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x2C_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x2D_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x2E_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x2F_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x30_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x31_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x32_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x33_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x34_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x35_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x36_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x37_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x38_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x39_TimeOut, 0);
    putValue(env_FSG_Tel_FctList_0x3A_TimeOut, 0);
	//putValue(env_FSG_Tel_FctList_0x3C_TimeOut, 0);


    //IssueList #74
    gTelFctList_0x1A_TimeOut_flg=0;
    gTelFctList_0x1E_TimeOut_flg=0;
    gTelFctList_0x20_TimeOut_flg=0;
    gTelFctList_0x1F_TimeOut_flg=0;
    gTelFctList_0x1B_TimeOut_flg=0;
    gTelFctList_0x1D_TimeOut_flg=0;
    gTelFctList_0x23_TimeOut_flg=0;
    gTelFctList_0x24_TimeOut_flg=0;
    gTelFctList_0x25_TimeOut_flg=0;
    gTelFctList_0x35_TimeOut_flg=0;
    gTelFctList_0x1C_TimeOut_flg=0;
    gTelFctList_0x28_TimeOut_flg=0;
    gTelFctList_0x26_TimeOut_flg=0;
    gTelFctList_0x27_TimeOut_flg=0;
    gTelFctList_0x36_TimeOut_flg=0;

}

FSG_OperationState_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Data_REQ:
             //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x0F_TimeOut)!=TRUE)
            {
            requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_FSG_OperationState;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gOP_State;
			requestarray[4]=gTel_State;
            requestarray[5]=gPrivacyMode;
			Offset=6;
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_FSG_OperationState;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone FSG_OperationState_Request: unknown request %d", request);
		break;
	}
}

FSG_OperationState_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			if(datalength!=3)															//datalength error
				FSG_OperationState_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				FSG_OperationState_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone FSG_OperationState_Indication: unknown indication %d", indication);
		break;
	}
}

FSG_Setup_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			if(datalength!=3)													//datalength error
				FSG_Setup_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				FSG_Setup_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone FSG_Setup_Indication: unknown indication %d", indication);
		break;
	}
}

FSG_Setup_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Data_REQ:
             //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x0E_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_FSG_Setup;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gPhoneCharacteristics;
			requestarray[4]=gMobileConnectionType;
			Offset=5;
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_FSG_Setup;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone FSG_Setup_Request: unknown request %d", request);
		break;
	}
}

on timer signalqualitytimer
{
byte temp;

	temp=gSignalQuality;
	gSignalQuality=random(99);
	putvalue(env_FSG_SignalQuality, gSignalQuality);

	if(temp!=gSignalQuality)
		SignalQuality_Request(Data_REQ, 0);

	settimer(signalqualitytimer, 5);

}

SignalQuality_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************


	switch(request){
		case Data_REQ:
            //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x15_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_SignalQuality;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gSignalQuality;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_SignalQuality;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone SignalQuality_Request: unknown request %d", request);
		break;
	}
}

SignalQuality_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			if(datalength!=4)														//datalength error
				SignalQuality_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				SignalQuality_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone SignalQuality_Indication: unknown indication %d", indication);
		break;
	}
}

NetInfo_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************


	switch(request){
		case Data_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_NetInfo;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gNetInfoCallDivert+2*gNetInfoCiphering;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_NetInfo;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone NetInfo_Request: unknown request %d", request);
		break;
	}
}

NetInfo_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			if(datalength!=3)												//datalength error
				NetInfo_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				NetInfo_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone NetInfo_Indication: unknown indication %d", indication);
		break;
	}
}

on envVar env_FSG_NetInfoCiphering
{
	if(gFSG_Telephone_PowerOnOff == Power_on)
	{
	    if(gNetInfoCiphering != getValue(this))
		{
			gNetInfoCiphering=getvalue(env_FSG_NetInfoCiphering);
		    NetInfo_Request(Data_REQ, 0);
		}
	}

}

on envVar env_FSG_NetInfoCallDivert
{
	if(gFSG_Telephone_PowerOnOff==Power_on){
		gNetInfoCallDivert=getvalue(env_FSG_NetInfoCallDivert);
		NetInfo_Request(Data_REQ, 0);
	}


}

on envVar env_FSG_LockState_OK
{
byte i;
//init lokal variables

//IssueList #155 - Aghil
gCallIDTemp = gcallID;

//********************
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
        gLockState=getvalue(env_FSG_LockState);
        LockState_Request(Data_REQ, 0);

        //IssueList #155 - Aghil
		getValue(env_FSG_CallState_CallID_0, bCallstate[0]);
		getValue(env_FSG_CallState_CallID_1, bCallstate[1]);
		getValue(env_FSG_CallState_CallID_2, bCallstate[2]);
		getValue(env_FSG_CallState_CallID_3, bCallstate[3]);
		getValue(env_FSG_CallState_CallID_4, bCallstate[4]);
		getValue(env_FSG_CallState_CallID_5, bCallstate[5]);
		getValue(env_FSG_CallState_CallID_6, bCallstate[6]);

		if(0x01 == gLockState)
        {
           //IssueList #163 - if condition
           if(0xFF != gCallIDTemp)
           {
		     if(strncmp(gstring_callstate[0], bCallstate[gCallIDTemp], strlen(gstring_callstate[0])) ||
			    strncmp(gstring_callstate[4], bCallstate[gCallIDTemp], strlen(gstring_callstate[4])) ||
			    strncmp(gstring_callstate[8], bCallstate[gCallIDTemp], strlen(gstring_callstate[8]))
			   )
             {
				EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);
                set_CallState(gCallIDTemp, disconnecting);			   //disconnect call

                settimer(disconnectingtimer, disconnecttime);

                gCallIDTemp--;
             }
            }
        }
      // end of #155
        switch(gLockState){
			case nolock:
				if(gRegisterState!=notregisterdandsearching){
					//IssueList #117
                    //gRegisterState=notregisterdandsearching;
                    //gNetworkType=UNKNOWN_NT;
                    gPacketDataNetworkType=NO_DATA_SERVICE;
					putvalue(env_FSG_RegisterState, gRegisterState);
                    putvalue(env_FSG_NetworkType,gNetworkType);
                    putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);

                    //IssueList #163 - RegisterState_Request commented
                    //RegisterState_Request(Data_REQ, 0);	//send register state
				}
			break;
			case requirePIN:
				gPIN_attempts=3;
				if(gRegisterState!=notregisteredandnotsearching)
                {
					gRegisterState=notregisteredandnotsearching;
                    gNetworkType=UNKNOWN_NT;
                    gPacketDataNetworkType=NO_DATA_SERVICE;
					putvalue(env_FSG_RegisterState, gRegisterState);
                    putvalue(env_FSG_NetworkType,gNetworkType);
                    putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
				
					//IssueList #163 - RegisterState_Request commented
                    //RegisterState_Request(Data_REQ, 0);	//send register state
				}
				if (gNetworkProviderState)
                {
					putvalue(env_FSG_NetworkProviderState, 0);
                    gNetworkProviderState=0;
                    for(i=0;i<40;i++)
		                gNetworkProviderName[i]=0;											//delete old name, no network
                    putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);
                    for(i=0;i<40;i++)
				        gServiceProviderName[i]=0;                                          //delete old name
                    putvalue(env_FSG_ServiceProviderName,gServiceProviderName);            
			        gServiceProviderState=0;                                                //set ServiceProvider not available
			        putvalue(env_FSG_ServiceProviderState,gServiceProviderState);
					//IssueList #163 - NetworkProvider_Request commented
                    //NetworkProvider_Request(Data_REQ, 0);									//send empty provider name
				}
                else 
                    putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);             //delete name in panel
			break;
			default:																		//SIM not available or locked	
				if(gCallActivity!=0)														//singel or multipaty call active
					Kill_Bill_Vol1();

				canceltimer(registerstatetimer);
				gRegisterState=notregisteredandnotsearching;
                gNetworkType=UNKNOWN_NT;
                gPacketDataNetworkType=NO_DATA_SERVICE;
				putvalue(env_FSG_RegisterState, gRegisterState);
                putvalue(env_FSG_NetworkType,gNetworkType);
                putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);

				//IssueList #163 - RegisterState_Request commented
                //RegisterState_Request(Data_REQ, 0);											//send register state
				
                if(gNetworkProviderState){
					putvalue(env_FSG_NetworkProviderState, 0);
                    gNetworkProviderState=0;
                    for(i=0;i<40;i++)
		                gNetworkProviderName[i]=0;											//delete old name, no network
                    putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);
                    for(i=0;i<40;i++)
				        gServiceProviderName[i]=0;                                          //delete old name
                    putvalue(env_FSG_ServiceProviderName,gServiceProviderName);            
			        gServiceProviderState=0;                                                // set ServiceProvider not available
			        putvalue(env_FSG_ServiceProviderState,gServiceProviderState);
					
                    //IssueList #163 - NetworkProvider_Request commented
                    //NetworkProvider_Request(Data_REQ, 0);									//send empty provider name
				}
                else
                    putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);             //delete name in panel
                    putvalue(env_FSG_ServiceProviderName,gServiceProviderName);
                    putvalue(env_FSG_ServiceProviderState,0);

			break;
		}
	}
}

LockState_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************


	switch(request){
		case Data_REQ:
            //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x13_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_LockState;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gLockState;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_LockState;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone LockState_Request: unknown request %d", request);
		break;
	}
}

LockState_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			if(datalength!=4)													//datalength error
				LockState_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				LockState_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone LockState_Indication: unknown indication %d", indication);
		break;
	}
}

PhoneEnable_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, length;

//init lokal variables
	length=0;
//********************

	for(i=0;i<20;i++)
		gPINCodeRNS[i]=0;

	switch (indication){
		case Processing_CNF:
			PhoneEnable_Request(Processing_REQ, 0);								//send Processing
		break;
		case StartResult_IND:
			if(gLockState!=requirePIN){											//no PIN required
				PhoneEnable_Request(Error_REQ, Terror_nocoderequired);
			}
			else if(Indication_array[3]!=1){									//invalid CodeType
				PhoneEnable_Request(Error_REQ, Terror_datainvalid);
			}
			else{																//PIN required and valid CodeType
				length=Indication_array[4];
				if(datalength!=(length+5))
					PhoneEnable_Request(Error_REQ, Terror_datainvalid);
				else{
					for(i=0;i<length;i++)
						gPINCodeRNS[i]=Indication_array[5+i];
					
					if(strncmp(gPINCodeRNS, gPINCodeUHV, 20)!=0){
						gPIN_attempts--;
					//	write("Versuche: %d", gPIN_attempts);					//debug
						PhoneEnable_Request(Error_REQ, Terror_datainvalid);
						if(gPIN_attempts==0){
							gLockState=PINblockedrequirePUK;
							putvalue(env_FSG_LockState, gLockState);
							LockState_Request(Data_REQ, 0);
						}
					}
					else{
						gLockState=nolock;
						putvalue(env_FSG_LockState, gLockState);
						PhoneEnable_Request(Result_REQ, 0);
						LockState_Request(Data_REQ, 0);
					}
				}
			}
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone PhoneEnable_Indication: unknown indication %d", indication);
		break;
	}
}

PhoneEnable_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;				//LSG-ID
			requestarray[1]=FctID_PhoneEnable;		//Fct.-ID
			requestarray[2]=request;
			Offset=3;
			set_status_requestbuffer (requestarray, Offset, Bap_Void);
		break;
		case Result_REQ:
			requestarray[Offset]=LSGID_Telephone;		//LSG-ID
			requestarray[Offset+1]=FctID_PhoneEnable;	//Fct.-ID
			requestarray[Offset+2]=request;
			Offset=3;
			set_status_requestbuffer (requestarray, Offset, Bap_Void);
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_PhoneEnable;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone PhoneEnable_Request: unknown request %d",request );
		break;
	}
}

on envVar env_FSG_ActiveUser_OK
{
int i;
byte length;
char empty_string [3];
char SIMSerial [40];

//init lokal variables
	length=0;	

	for(i=0;i<3;i++)
		empty_string[i]=0;
//********************


	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
		for(i=0;i<50;i++)
			gUserName[i]=0;
		getvalue(env_FSG_UserName, gUserName);
        ActiveUser_Request(Data_REQ, 0);

		//if(strlen(gUserName)==0)
        //{
			//LockState
			//gLockState=SIMnotavailable;
			//putvalue(env_FSG_LockState, gLockState);
			//SMSState
			//gSIMReady=1;
			//gStorageState=0;
			//gNumberOfNewSMS=0;
			//putvalue(env_FSG_SIMReady, gSIMReady);
			//putvalue(env_FSG_StorageState, gStorageState);
			//putvalue(env_FSG_NumberOfNewSMS, gNumberOfNewSMS);
			//PBState
			//canceltimer(PbDownload_timer);
			//canceltimer(PbStartDownload_timer);
			//canceltimer(PbDownloadAborted_timer);
			//if(gDownLoadState==CURRENTLY_BEING_LOADED){
			//	gDownLoadState=DOWNLOAD_ABORTED;
			//	gDownLoadState_old=0;
			//	gPbEntriesUHV=0;
			//	gPbEntriesUHV_old=0;
			//	settimer(PbDownloadAborted_timer, 1000);
			//}
			//else{
			//	gDownLoadState=NO_PHONEBOOK_AVAILABLE;
			//	gDownLoadState_old=0;
			//	gPbEntriesUHV=0;
			//	gPbEntriesUHV_old=0;
			//}
		//}
		//else{
			//LockState
		//	gLockState=requirePIN;
		//	putvalue(env_FSG_LockState, gLockState);
			//SMSState
		//	gSIMReady=0;
		//	gStorageState=0;
		//	gNumberOfNewSMS=0;
		//	putvalue(env_FSG_SIMReady, gSIMReady);
		//	putvalue(env_FSG_StorageState, gStorageState);
		//	putvalue(env_FSG_NumberOfNewSMS, gNumberOfNewSMS);
		//}
		
	//	write("FSG-Telephone env_FSG_ActiveUser_enter User valid: %d", ActiveUserValidation());			//debug

		//LockState_Request(Data_REQ, 0);
		
		//PbDownloadState
		//putvalue(env_FSG_PbState_DownloadState, gDownLoadState);
		//putvalue(env_FSG_PbState_EntriesUHV, gPbEntriesUHV);
        //PbState_Request(Data_REQ, 0);
		
		//SMSState
		//SMSState_Request(Data_REQ, 0);
		
		//CallStacks
		//dialednumbers_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);
		//MissedCalls_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);
		//receivedcalls_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);

	}
}

ActiveUser_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch (request){
		case Data_REQ:
             //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x11_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_ActiveUser;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=strlen(gUserName);	//Stringlänge
			Offset=4;
    			for(i=0;i<strlen(gUserName);i++){
    				requestarray[Offset]=gUserName[i];
    				Offset++;
    			}
						
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);	//send new provider name
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_ActiveUser;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone ActiveUser_Request: unknown request %d", request);
		break;
	}
}

ActiveUser_Indication (dword Indication_array [], byte indication, int datalength)
{
int length;

//init lokal variables
	length=0;
//*******************

	//length=strlen(gNetworkProvider);
				
	switch (indication){
		case DataGet_IND:
			//check BAP-array
			if(datalength!=3)	//datalength error
				ActiveUser_Request(Error_REQ, Terror_datainvalid);	//send error-message 
			else
				ActiveUser_Request(Data_REQ, 0);				//send network provider 
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone ActiveUser indication: unknown indication %d", indication);
		break;
	}
}

on envVar env_FSG_SignalQuality
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(env_FSG_SignalQuality_Mode)==0){
		gSignalQuality=getvalue(this);
		SignalQuality_Request(Data_REQ, 0);
	}
}

//IssueList #51
/*on envVar env_FSG_SignalQuality_Mode
{
	if(getvalue(this)==1){
		settimer(signalqualitytimer, 5);
	}
	else
		canceltimer(signalqualitytimer);

}*/
on envVar env_FSG_SignalQuality_OK
{
  if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))	
  {
	if(getvalue(env_FSG_SignalQuality_Mode)==0x01)
		settimer(signalqualitytimer, 5);
	else
		canceltimer(signalqualitytimer);
   }
}

on timer Powerontimer
{
	gFSG_Telephone_PowerOnOff=1;

	settimer(TaskTimer, 10);					//start real CAN-communication timer

	//BAP_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID_Telephone, DEBUG_SWITCH_ON); //BAP-Debug-message
	//BAP_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID_Phonebook, DEBUG_SWITCH_ON); //BAP-Debug-message	

}

//MR 60227
on timer _tBAP_delayTime
{
gActiveCall_active= 0;

if  (gActiveCall_HangUpMethodActive == 0x01 || gActiveCall_HangUpPressed == 0x01)
{
set_CallState(gBapMostDisconnectID, disconnecting);
settimer(disconnectingtimer, 10);
gActiveCall_HangUpMethodActive = 0;
gActiveCall_HangUpPressed = 0;
}

}

//MR 60227
on envVar env_AudioTel_bapMost_delayTimer
{
    if (getValue(env_PIC_bapMOST_active_flag) == 0x01)
    {
        if (getValue(this) > 0) 
        gActiveCall_BAPdelayFlag = 1;
        else
        gActiveCall_BAPdelayFlag = 0;
    }

}

on envVar env_FSG_FSG_OperationState_OK
{
byte i;
byte notIdleFlg=0;

    //IssueList #155 - Aghil
    gCallIDTemp = gcallID;

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
        gOP_State = getvalue(env_FSG_OP_State);
        gTel_State = getvalue(env_FSG_Tel_State);
		gPrivacyModeBit= getvalue(env_FSG_PrivacyModeBit);
		gEnhancedPrivacyMode = getvalue(env_FSG_EnhancedPrivacyMode);
		gPrivacyMode = gPrivacyModeBit+2*gEnhancedPrivacyMode;

        //IssueList #155
		getValue(env_FSG_CallState_CallID_0, bCallstate[0]);
		getValue(env_FSG_CallState_CallID_1, bCallstate[1]);
		getValue(env_FSG_CallState_CallID_2, bCallstate[2]);
		getValue(env_FSG_CallState_CallID_3, bCallstate[3]);
		getValue(env_FSG_CallState_CallID_4, bCallstate[4]);
		getValue(env_FSG_CallState_CallID_5, bCallstate[5]);
		getValue(env_FSG_CallState_CallID_6, bCallstate[6]);
        

        notIdleFlg = 0;
        for (i=0; i<7;i++)
        if (strncmp(bCallstate[i],"idle",strlen(bCallstate[i]) != 0x00))
        {
        notIdleFlg = 0x01;
        break;
        }
        
		//IssueList #177
        //if(((0x00 != gOP_State) || (0x02 != gOP_State) && (0x07 != gTel_State))
        if (notIdleFlg == 0x01)
        {
            if(((0x00 != gOP_State) || (0x02 != gOP_State) && (0x07 != gTel_State))&& gCallIDTemp!=0xFF)
            {
    			//if(strncmp(gstring_callstate[0], bCallstate[gCallIDTemp], strlen(gstring_callstate[0])) ||
    			  // strncmp(gstring_callstate[4], bCallstate[gCallIDTemp], strlen(gstring_callstate[4])) ||
    			 //  strncmp(gstring_callstate[8], bCallstate[gCallIDTemp], strlen(gstring_callstate[8])))

                //{
    				EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);
                    set_CallState(gCallIDTemp, disconnecting);			   //disconnect call
                    //MR63212
		   // settimer(disconnectingtimer, 2000);
		    settimer(disconnectingtimer, disconnecttime);

                    gCallIDTemp--;
    			//}
            }
	// end of #155
        }
        else
		FSG_OperationState_Request(Data_REQ, 0);
       
	}
}

on envVar env_FSG_FSG_Setup_OK
{
    //IssueList #155 - Aghil
    gCallIDTemp = gcallID;

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
		gSIMCardReader=getvalue(env_FSG_SIMCardReader);
        gCableConnection=getvalue(env_FSG_CableConnection);
		gHFPConnection=getvalue(env_FSG_HFPConnection);
		gRSAPConnection=getvalue(env_FSG_RSAPConnection);
		gAppleLinkConnection=getvalue(env_FSG_AppleLink);
		gGoogleLinkConnection=getvalue(env_FSG_GoogleLink);
		gBaiduConnection=getvalue(env_FSG_BaiduLink);
		gPhoneCharacteristics=gSIMCardReader+(2*gCableConnection)+(4*gHFPConnection)+(8*gRSAPConnection)+(16*gAppleLinkConnection)+(32*gGoogleLinkConnection)+(64*gBaiduConnection);
		gMobileConnectionType=getvalue(env_FSG_MobileConnectionType);
        switch(gMobileConnectionType)
        {
            case INTERNAL_SIM_CARD_READER:
                if(getvalue(env_FSG_SIMCardReader)==FALSE)
                    gMobileConnectionType=NO_CONNECTION;
            break;
            case CABLE_CONNECTION:
                if(getvalue(env_FSG_CableConnection)==FALSE)
                    gMobileConnectionType=NO_CONNECTION;
            break;
            case HANDS_FREE_PROFILE:
                if(getvalue(env_FSG_HFPConnection)==FALSE)
                    gMobileConnectionType=NO_CONNECTION;
            break;
            case REMOTE_SIM_ACCESS_PROFILE:
                if(getvalue(env_FSG_RSAPConnection)==FALSE)
                    gMobileConnectionType=NO_CONNECTION;
            break;
            case APPLELINK_CONNECTION:
                if(getvalue(env_FSG_AppleLink)==FALSE)
                    gMobileConnectionType=NO_CONNECTION;
            break;
            case GOOGLELINK_CONNECTION:
                if(getvalue(env_FSG_GoogleLink)==FALSE)
                    gMobileConnectionType=NO_CONNECTION;
            break;
            case BAIDULINK_CONNECTION:
                if(getvalue(env_FSG_BaiduLink)==FALSE)
                    gMobileConnectionType=NO_CONNECTION;
            break;
        }

        putvalue(env_FSG_MobileConnectionType,gMobileConnectionType);

        //IssueList #155
		getValue(env_FSG_CallState_CallID_0, bCallstate[0]);
		getValue(env_FSG_CallState_CallID_1, bCallstate[1]);
		getValue(env_FSG_CallState_CallID_2, bCallstate[2]);
		getValue(env_FSG_CallState_CallID_3, bCallstate[3]);
		getValue(env_FSG_CallState_CallID_4, bCallstate[4]);
		getValue(env_FSG_CallState_CallID_5, bCallstate[5]);
		getValue(env_FSG_CallState_CallID_6, bCallstate[6]);

		//IssueList #177
        //if(0x00 == gMobileConnectionType )
        if(0x00 == gMobileConnectionType && gCallIDTemp!=0xFF)
        {
		   if(strncmp(gstring_callstate[0], bCallstate[gCallIDTemp], strlen(gstring_callstate[0])) ||
			  strncmp(gstring_callstate[4], bCallstate[gCallIDTemp], strlen(gstring_callstate[4])) ||
			  strncmp(gstring_callstate[8], bCallstate[gCallIDTemp], strlen(gstring_callstate[8]))
			 )
            {
				EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);
                set_CallState(gCallIDTemp, disconnecting);			   //disconnect call
                //MR63212
		//settimer(disconnectingtimer, 1500);
		settimer(disconnectingtimer, disconnecttime);

                gCallIDTemp--;
			}
        }
	// end of #155
		FSG_Setup_Request(Data_REQ, 0);
 
        //IssueList #26 - CANoe crash
        gFirstPress = 0x00;
	}
}

on timer agetimer	//timer for getting the date
{
int i;

	for(i=0;i<3;i++){
		gsday[i]=0;
		gsmonth[i]=0;
		gsyear[i]=0;
	}

	gbday=0;
	gbmonth=0;
	gbyear=0;

	getvalue(env_FSG_date, gdate);

	gsday[0]=gdate[0];
	gsday[1]=gdate[1];
	gsday[2]=0;
	gsmonth[0]=gdate[2];
	gsmonth[1]=gdate[3];
	gsmonth[2]=0;
	gsyear[0]=gdate[4];
	gsyear[1]=gdate[5];
	gsyear[2]=0;
	gbday=atol(gsday);
	gbmonth=atol(gsmonth);
	gbyear=atol(gsyear);

}

on timer PbDownload_timer
{
byte mode;

mode=0;

	gDownLoadState=getvalue(env_FSG_PbState_DownloadState);
	gPbEntriesUHV=getvalue(env_FSG_PbState_EntriesUHV);
	//putvalue(env_FSG_s_PbState_DownloadState, gstring_DownLoadState[gDownLoadState]);
	//putvalue(env_FSG_PbState_EntriesUHV, gPbEntriesUHV);
		
//	if(gPbEntriesUHV<128)
//		mode=0;
//	else
		mode=0x80;
	
	If(gDownLoadState==COMPLETELY_LOADED || gDownLoadState==INCOMPLETELY_LOADED)
	    //MR 63667 11.07.2014 -TNLE with SA-button
    	//Phonebook_Request(Changed_REQ, 0, 0, 0xffff, mode, 0);
        Phonebook_Request(Changed_REQ, 0, 0, 0, 0xffff, mode, 0);
	
	PbState_Request(Data_REQ, 0);
}

on timer PbDownloadAborted_timer
{
	if(gDownLoadState_old==COMPLETELY_LOADED || gDownLoadState_old==INCOMPLETELY_LOADED)
		gDownLoadState=gDownLoadState_old;
	else
		gDownLoadState=NO_PHONEBOOK_AVAILABLE;
		

	putvalue(env_FSG_PbState_DownloadState, gDownLoadState);
	putvalue(env_FSG_PbState_EntriesUHV, gPbEntriesUHV);
	PbState_Request(Data_REQ, 0);
}

on timer PbStartDownload_timer
{
	if(gDownLoadState!=DOWNLOAD_ABORTED)					//save old values for PbState
	{
		gDownLoadState_old=gDownLoadState;
		gPbEntriesUHV_old=gPbEntriesUHV;
	}
	
	if(FALSE==getvalue(env_FSG_PbStartDownload_Result))
	{
		PbStartDownload_Request(Error_REQ, Terror_unknownapllicationerror);			//send data to RNS
		gPbStartDownload_status=0;													//method PbStartDownload finished
	}
	else
	{
		gDownLoadState=CURRENTLY_BEING_LOADED;				
		settimer(PbDownload_timer, gPbDownloadtime);
		putvalue(env_FSG_PbState_DownloadState, gDownLoadState);
		PbState_Request(Data_REQ, 0);
		PbStartDownload_Request(Result_REQ, 0);										//send data to RNS
		gPbStartDownload_status=0;													//method PbStartDownload finished
	}
}

callstack_dialednumbers (byte StackMode, word Stack_ID)
{/*

int callstackline, i;
byte neo, newnumber;
char dialtime [7];


	
//init lokal variables
	callstackline=0;
	neo=0xff;
	newnumber=0;
	strncpy(dialtime, gtime, 7);
//********************

	switch(StackMode)
	{	
		case DELETE_ID:
			//********shift calls in call stack**********************************
			for(callstackline=Stack_ID;callstackline<(CALLSTACK-2);callstackline++)			//star at the position of deleted entry
			{
				//PbName
				strncpy(gdialednumbers_pbname[callstackline], gdialednumbers_pbname[callstackline+1], CALL_INFO_NAME_LENGTH);
	
				//TelNumber
				strncpy(gdialednumbers_telnumber[callstackline], gdialednumbers_telnumber[callstackline+1], CALL_INFO_NUMBER_LENGTH);
	
				//Date
				strncpy(gdialednumbers_date[callstackline], gdialednumbers_date[callstackline+1], 7);
	
				//Time
				strncpy(gdialednumbers_time[callstackline], gdialednumbers_time[callstackline+1], 7);
	
				//NumberType
				gdialednumbers_numbertype[callstackline]=gdialednumbers_numbertype[callstackline+1];
			}
			//*******************************************************************

			display_callstack_dialednumbers();
		break;
		case NEWCALL:
			if(strncmp(gdialednumbername_new, gdialednumbers_pbname[0], 40)!=0)										//dialed number is not last dialed number
			{
			//**********analyze new number****************	
				for(callstackline=1;callstackline<CALLSTACK;callstackline++)
				{
					if(strncmp(gdialednumbername_new, gdialednumbers_pbname[callstackline], 40)==0)					//number already exists in callstack
					{
						//write("gleich");
						neo=callstackline;
						callstackline=19;																			//loop finished
					}
				}

				if(neo==0xff)	//new number
				{
					neo=19;
					newnumber=1;
				}
			//********************************************
	
			//********shift numbers in callstack array 'dialednumbers'***********
				for(callstackline=neo;callstackline>0;callstackline--)												//shift position of all callstack-entries down (1 step) 
				{
					//PbName
					strncpy(gdialednumbers_pbname[callstackline], gdialednumbers_pbname[callstackline-1], CALL_INFO_NAME_LENGTH);
		
					//TelNumber
					strncpy(gdialednumbers_telnumber[callstackline], gdialednumbers_telnumber[callstackline-1], CALL_INFO_NUMBER_LENGTH);
		
					//Date
					strncpy(gdialednumbers_date[callstackline], gdialednumbers_date[callstackline-1], 7);
		
					//Time
					strncpy(gdialednumbers_time[callstackline], gdialednumbers_time[callstackline-1], 7);
		
					//NumberType
					gdialednumbers_numbertype[callstackline]=gdialednumbers_numbertype[callstackline-1];
				}
			//*******************************************************************

			//******new dialed number*****
				//PbName
				for(i=0;i<40;i++)																					//write PbName of new dialed number on first callstack-position
					gdialednumbers_pbname[0][i]=gdialednumbername_new[i];
		

				//TelNumber
				for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)																					//write TelNumber of new dialed number on first callstack-position
					gdialednumbers_telnumber[0][i]=gdialednumber_new[i];
	
				//Date
				for(i=0;i<6;i++)																					//write date of new dialed number on first callstack-position
					gdialednumbers_date[0][i]=gdate[i];
	
				//Time
				for(i=0;i<6;i++)																					//write time of new dialed number on first callstack-position
					gdialednumbers_time[0][i]=dialtime[i];
		
				//NumberType
				gdialednumbers_numbertype[0]=gdialednumbersnumbertype_new;
			//****************************
			}
			else																									//new dialed number is the same as the last dialed number
			{
				//******new dialed number*****
				//PbName
				for(i=0;i<40;i++){																					//write PbName of new dialed number on first callstack-position
					gdialednumbers_pbname[0][i]=gdialednumbername_new[i];
				}

				//TelNumber
				for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)																					//write TelNumber of new dialed number on first callstack-position
					gdialednumbers_telnumber[0][i]=gdialednumber_new[i];
	
				//Date
				for(i=0;i<6;i++)																					//write date of new dialed number on first callstack-position
					gdialednumbers_date[0][i]=gdate[i];
	
				//Time
				for(i=0;i<6;i++)																					//write time of new dialed number on first callstack-position
					gdialednumbers_time[0][i]=dialtime[i];
		
				//NumberType
				gdialednumbers_numbertype[0]=gdialednumbersnumbertype_new;
			//****************************
			}

			display_callstack_dialednumbers();

			if(gFSG_Telephone_PowerOnOff==Power_on && ActiveUserValidation()==1)												//Power on and active User available)
			{
				if(newnumber==TRUE)																					//new number was inserted
					dialednumbers_Request(Changed_REQ, 0, 0, 1, 0x10, 0);												//set shift bit
				else																								//no new number, array was re-sorted
					dialednumbers_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);												//whole array has changed
			}
		break;
		default:
			write("FSG-Telephone callstack_dialednumbers: invalid Stack-Mode %d", StackMode);
		break;
	}*/
}

callstack_missedcalls(byte StackMode, word Stack_ID, word Stack_elements)
{

int callstackline, i;
byte neo, newnumber;
char missedcalltime [7];


	
//init lokal variables
	callstackline=0;
	neo=0xff;
	newnumber=0;
	strncpy(missedcalltime, gtime, 7);
//********************


	switch(StackMode)
	{	
        case INSERT_ID:
            if(Stack_ID>(gmissedcalls_TotalNumListElements-1)) //insert new entries at end of stack
            {
                Stack_ID=gmissedcalls_TotalNumListElements;
                //********insert IDs after last entry**********************
                for(callstackline=gmissedcalls_TotalNumListElements;callstackline<(Stack_ID+Stack_elements);callstackline++)
               {
	    	        strncpy(gmissedcalls_pbname[callstackline], gmissedcallname_new, CALL_INFO_NAME_LENGTH);
	                //NumberType
			    	gmissedcalls_numbertype[callstackline]=gmissedcallnumbertype_new;
        			//TelNumber
	        		strncpy(gmissedcalls_telnumber[callstackline], gmissedcallnumber_new, CALL_INFO_NUMBER_LENGTH);
                    //write("insert callstackline = %d", callstackline);     //debug
                }
             }
              else  //insert new entries in stack
              {  
                //********shift down calls in call stack**********************************
                //start at entry, which will be the last; stop at next to last new entry
                for(callstackline=((gmissedcalls_TotalNumListElements-1)-Stack_elements);callstackline>=Stack_ID;callstackline--)
                {
                    //PbName
				    strncpy(gmissedcalls_pbname[callstackline+Stack_elements], gmissedcalls_pbname[callstackline], CALL_INFO_NAME_LENGTH);
    	            //NumberType
	    			gmissedcalls_numbertype[callstackline+Stack_elements]=gmissedcalls_numbertype[callstackline];
    	    		//TelNumber
	    	    	strncpy(gmissedcalls_telnumber[callstackline+Stack_elements], gmissedcalls_telnumber[callstackline], CALL_INFO_NUMBER_LENGTH);
	                //Date
    			    strncpy(gmissedcalls_date[callstackline+Stack_elements], gmissedcalls_date[callstackline], 7);
	                //Time
		    		strncpy(gmissedcalls_time[callstackline+Stack_elements], gmissedcalls_time[callstackline], 7);
                    //write("shift callstackline = %d", callstackline);     //debug
                }
                //**********insert new entries********************************
                for(callstackline=Stack_ID;callstackline<(Stack_ID+Stack_elements);callstackline++)
                {
		            strncpy(gmissedcalls_pbname[callstackline], gmissedcallname_new, CALL_INFO_NAME_LENGTH);
    	            //NumberType
	    			gmissedcalls_numbertype[callstackline]=gmissedcallnumbertype_new;
    	    		//TelNumber
	    	    	strncpy(gmissedcalls_telnumber[callstackline], gmissedcallnumber_new, CALL_INFO_NUMBER_LENGTH);
                    //write("insert callstackline = %d", callstackline);     //debug
              }
            }

            //************update gmissedcalls_TotalNumListElements
            if(gmissedcalls_TotalNumListElements+Stack_elements<CALLSTACK)
                gmissedcalls_TotalNumListElements=gmissedcalls_TotalNumListElements+Stack_elements;
            else
                gmissedcalls_TotalNumListElements=CALLSTACK;
        break;
            
		case DELETE_ID:
            //********shift up calls in call stack**********************************
            //start at next to last deleted entry, stop at last entry
            for(callstackline=(Stack_ID+1);callstackline<gmissedcalls_TotalNumListElements;callstackline++)
            {
                //PbName
				strncpy(gmissedcalls_pbname[callstackline-Stack_elements], gmissedcalls_pbname[callstackline], CALL_INFO_NAME_LENGTH);
	            //NumberType
				gmissedcalls_numbertype[callstackline-Stack_elements]=gmissedcalls_numbertype[callstackline];
    			//TelNumber
	    		strncpy(gmissedcalls_telnumber[callstackline-Stack_elements], gmissedcalls_telnumber[callstackline], CALL_INFO_NUMBER_LENGTH);
	            //Date
			    strncpy(gmissedcalls_date[callstackline-Stack_elements], gmissedcalls_date[callstackline], 7);
	            //Time
				strncpy(gmissedcalls_time[callstackline-Stack_elements], gmissedcalls_time[callstackline], 7);
                //write("shift callstackline = %d", callstackline);     //debug
            }
          
            //**********delete last entries********************************
            for(callstackline=(gmissedcalls_TotalNumListElements-Stack_elements);callstackline<gmissedcalls_TotalNumListElements;callstackline++)
            {
		        for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
			        gmissedcalls_pbname[callstackline][i] =0;
                gmissedcalls_numbertype[callstackline] =0;
                for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
		    	    gmissedcalls_telnumber[callstackline][i] =0;
                for(i=0;i<7;i++)
	    		    gmissedcalls_date[callstackline][i] =0;
                for(i=0;i<7;i++)
			        gmissedcalls_time[callstackline][i] =0;
                //write("erase callstackline = %d", callstackline);     //debug
            }

            //************update gmissedcalls_TotalNumListElements
            gmissedcalls_TotalNumListElements=gmissedcalls_TotalNumListElements-Stack_elements;
		break;

        case CHANGE_ID:
            if(Stack_ID>(gmissedcalls_TotalNumListElements-1)) //change new entries at end of stack
            {
                Stack_ID=gmissedcalls_TotalNumListElements;
                //********change IDs after last entry**********************
                for(callstackline=gmissedcalls_TotalNumListElements;callstackline<(Stack_ID+Stack_elements);callstackline++)
               {
	    	        strncpy(gmissedcalls_pbname[callstackline], gmissedcallname_new, CALL_INFO_NAME_LENGTH);
	                //NumberType
			    	gmissedcalls_numbertype[callstackline]=gmissedcallnumbertype_new;
        			//TelNumber
	        		strncpy(gmissedcalls_telnumber[callstackline], gmissedcallnumber_new, CALL_INFO_NUMBER_LENGTH);
                    //write("change callstackline = %d", callstackline);     //debug
                }
             }
             else  //change entries in stack
             {  
                //**********change entries********************************
                for(callstackline=Stack_ID;callstackline<(Stack_ID+Stack_elements);callstackline++)
                {
		            strncpy(gmissedcalls_pbname[callstackline], gmissedcallname_new, CALL_INFO_NAME_LENGTH);
    	            //NumberType
	    			gmissedcalls_numbertype[callstackline]=gmissedcallnumbertype_new;
    	    		//TelNumber
	    	    	strncpy(gmissedcalls_telnumber[callstackline], gmissedcallnumber_new, CALL_INFO_NUMBER_LENGTH);
                    //write("erase callstackline = %d", callstackline);     //debug
                }
            }

            //************update gmissedcalls_TotalNumListElements
            if(gmissedcalls_TotalNumListElements+Stack_elements<CALLSTACK)
                gmissedcalls_TotalNumListElements=gmissedcalls_TotalNumListElements+Stack_elements;
            else
                gmissedcalls_TotalNumListElements=CALLSTACK;
        break;

		case NEWCALL:
			gMissedCalls++;
			if(strncmp(gmissedcallname_new, gmissedcalls_pbname[0], 40)!=0){			//missed call number is not last missed call number
			//**********analyze new number****************	
				for(callstackline=1;callstackline<CALLSTACK;callstackline++){
					if(strncmp(gmissedcallname_new, gmissedcalls_pbname[callstackline], 40)==0){	//number already exists in callstack
						//write("gleich");
						neo=callstackline;
						callstackline=19;											//loop finished
					}
				}

				if(neo==0xff)														//new number
				{
					neo=19;
					newnumber=1;
				}
			//********************************************
	
			//********shift numbers in callstack array 'missedcalls'***********
				for(callstackline=neo;callstackline>0;callstackline--){				//shift position of all callstack-entries down (1 step) 
					//PbName
					strncpy(gmissedcalls_pbname[callstackline], gmissedcalls_pbname[callstackline-1], CALL_INFO_NAME_LENGTH);
		
					//TelNumber
					strncpy(gmissedcalls_telnumber[callstackline], gmissedcalls_telnumber[callstackline-1], CALL_INFO_NUMBER_LENGTH);
		
					//Date
					strncpy(gmissedcalls_date[callstackline], gmissedcalls_date[callstackline-1], 7);
		
					//Time
					strncpy(gmissedcalls_time[callstackline], gmissedcalls_time[callstackline-1], 7);
		
					//NumberType
					gmissedcalls_numbertype[callstackline]=gmissedcalls_numbertype[callstackline-1];
				}
			//*******************************************************************

			//******new missed call number*****
				//PbName
				for(i=0;i<40;i++){													//write PbName of new dialed number on first callstack-position
					gmissedcalls_pbname[0][i]=gmissedcallname_new[i];
				}

				//TelNumber
				for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)													//write TelNumber of new dialed number on first callstack-position
					gmissedcalls_telnumber[0][i]=gmissedcallnumber_new[i];
	
				//Date
				for(i=0;i<6;i++)													//write date of new dialed number on first callstack-position
					gmissedcalls_date[0][i]=gdate[i];
	
				//Time
				for(i=0;i<6;i++)													//write time of new dialed number on first callstack-position
					gmissedcalls_time[0][i]=missedcalltime[i];
		
				//NumberType
				gmissedcalls_numbertype[0]=gmissedcallnumbertype_new;
			//****************************
			}
			else																	//new missed call number is the same as the last missed call number
			{
			//******new missed call number*****
				//PbName
				for(i=0;i<40;i++){													//write PbName of new dialed number on first callstack-position
					gmissedcalls_pbname[0][i]=gmissedcallname_new[i];
				}

				//TelNumber
				for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)													//write TelNumber of new dialed number on first callstack-position
					gmissedcalls_telnumber[0][i]=gmissedcallnumber_new[i];
	
				//Date
				for(i=0;i<6;i++)													//write date of new dialed number on first callstack-position
					gmissedcalls_date[0][i]=gdate[i];
	
				//Time
				for(i=0;i<6;i++)													//write time of new dialed number on first callstack-position
					gmissedcalls_time[0][i]=missedcalltime[i];
		
				//NumberType
				gmissedcalls_numbertype[0]=gmissedcallnumbertype_new;
			//****************************
			}
	
			display_callstack_missedcalls();

			if(gFSG_Telephone_PowerOnOff==Power_on && ActiveUserValidation()==1)				//Power on and active User available)
			{
				if(newnumber==TRUE)													//new number was inserted
				{
					gMissedNumbers++;
					MissedCallIndication_Request(Data_REQ, 0);
					MissedCalls_Request(Changed_REQ, 0, 0, 1, 0x10, 0);				//set shift bit
				}
				else																//no new number, array was re-sorted
				{
					MissedCallIndication_Request(Data_REQ, 0);
					MissedCalls_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);		//whole array has changed
				}
			}
		break;
	}
}

callstack_receivedcalls (byte StackMode, word Stack_ID)
{

int callstackline, i;
byte neo, newnumber;
char receivedcalltime [7];


	
//init lokal variables
	callstackline=0;
	neo=0xff;
	newnumber=0;
	strncpy(receivedcalltime, gtime, 7);
//********************


	switch(StackMode)
	{	
		case DELETE_ID:
			//********shift calls in call stack**********************************
			for(callstackline=Stack_ID;callstackline<(CALLSTACK-2);callstackline++)			//star at the position of deleted entry
			{
				//PbName
				strncpy(greceivedcalls_pbname[callstackline], greceivedcalls_pbname[callstackline+1], CALL_INFO_NAME_LENGTH);
	
				//TelNumber
				strncpy(greceivedcalls_telnumber[callstackline], greceivedcalls_telnumber[callstackline+1], CALL_INFO_NUMBER_LENGTH);
	
				//Date
				strncpy(greceivedcalls_date[callstackline], greceivedcalls_date[callstackline+1], 7);
	
				//Time
				strncpy(greceivedcalls_time[callstackline], greceivedcalls_time[callstackline+1], 7);
	
				//NumberType
				greceivedcalls_numbertype[callstackline]=greceivedcalls_numbertype[callstackline+1];
			}
			//*******************************************************************

			display_callstack_receivedcalls();
		break;
		case NEWCALL:
			if(strncmp(greceivedcallname_new, greceivedcalls_pbname[0], 40)!=0){	//received call number is not last received call number
			//**********analyze new number****************	
				for(callstackline=1;callstackline<CALLSTACK;callstackline++){
					if(strncmp(greceivedcallname_new, greceivedcalls_pbname[callstackline], 40)==0){	//number already exists in callstack
						//write("gleich oder frei");
						neo=callstackline;
						callstackline=19;											//loop finished
					}
				}

				if(neo==0xff)														//new number
				{
					neo=19;
					newnumber=1;
				}
			//********************************************
	
			//********shift numbers in callstack array 'receivedcalls'***********
				for(callstackline=neo;callstackline>0;callstackline--){				//shift position of all callstack-entries down (1 step) 
					//PbName
					strncpy(greceivedcalls_pbname[callstackline], greceivedcalls_pbname[callstackline-1], CALL_INFO_NAME_LENGTH);
		
					//TelNumber
					strncpy(greceivedcalls_telnumber[callstackline], greceivedcalls_telnumber[callstackline-1], CALL_INFO_NUMBER_LENGTH);
		
					//Date
					strncpy(greceivedcalls_date[callstackline], greceivedcalls_date[callstackline-1], 7);
		
					//Time
					strncpy(greceivedcalls_time[callstackline], greceivedcalls_time[callstackline-1], 7);
		
					//NumberType
					greceivedcalls_numbertype[callstackline]=greceivedcalls_numbertype[callstackline-1];
				}
			//*******************************************************************

			//******new received call number*****
				//PbName
				for(i=0;i<40;i++){													//write PbName of new dialed number on first callstack-position
					greceivedcalls_pbname[0][i]=greceivedcallname_new[i];
				}

				//TelNumber
				for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)													//write TelNumber of new dialed number on first callstack-position
					greceivedcalls_telnumber[0][i]=greceivedcallnumber_new[i];
	
				//Date
				for(i=0;i<6;i++)													//write date of new dialed number on first callstack-position
					greceivedcalls_date[0][i]=gdate[i];
	
				//Time
				for(i=0;i<6;i++)													//write time of new dialed number on first callstack-position
					greceivedcalls_time[0][i]=receivedcalltime[i];
		
				//NumberType
				greceivedcalls_numbertype[0]=greceivedcallnumbertype_new;
			//****************************
			}
			else{																	//received call number is last received call number
			//******new received call number*****
				//PbName
				for(i=0;i<40;i++){													//write PbName of new dialed number on first callstack-position
					greceivedcalls_pbname[0][i]=greceivedcallname_new[i];
				}

				//TelNumber
				for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)													//write TelNumber of new dialed number on first callstack-position
					greceivedcalls_telnumber[0][i]=greceivedcallnumber_new[i];
	
				//Date
				for(i=0;i<6;i++)													//write date of new dialed number on first callstack-position
					greceivedcalls_date[0][i]=gdate[i];
	
				//Time
				for(i=0;i<6;i++)													//write time of new dialed number on first callstack-position
					greceivedcalls_time[0][i]=receivedcalltime[i];
		
				//NumberType
				greceivedcalls_numbertype[0]=greceivedcallnumbertype_new;
			//****************************
			}
	
			display_callstack_receivedcalls();

			if(gFSG_Telephone_PowerOnOff==Power_on && ActiveUserValidation()==1)				//Power on and active User available)
			{
				if(newnumber==TRUE)
					receivedcalls_Request(Changed_REQ, 0, 0, 1, 0x10, 0);
				else
					receivedcalls_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);
			}
		break;
	}
}

byte checkcallstackarray (dword array[], int arraylength)
{
byte valid, mode, indexsize, recordaddress;
word elements;


//init lokal variables
	mode=0;
	indexsize=0;
	recordaddress=0;
	elements=0;
//********************

	valid=1;

	//***mode***
	mode=array[3];
	indexsize=(mode & 0x80)/0x80;
	recordaddress=mode & 0x0f;
	//write("FSG-Telephone checkarray: indexsize: %d recordaddress:%d", indexsize, recordaddress);

	switch(array[2]){
		case DataSetGet_IND:
			//********arraylength*******
			if(arraylength!=8)
					return(0xff);
			//**************************

			//***elements***
			if(indexsize)
				elements=array[6]+array[7]*256;
			else
				elements=array[5];

			if(elements!=1){
				write("FSG-Telephone checkcallstackarray: elements-error");
				return(0xff);
			}
			//**************
			
			//***recordaddress***
			if(recordaddress!=1){
				write("FSG-Telephone checkcallstackarray: recordaddress-error");
				return(0xff);
			}
			//*******************
		break;
		case DataGet_IND:
			//********arraylength*******
			if(indexsize){
				elements=array[6]+array[7]*256;
				if(arraylength!=8)
					return(0xff);
			}
			else{
				elements=array[5];
				if(arraylength!=6)
					return(0xff);
			}
			//**************************

			//***elements***
			if(elements==0){
				write("FSG-Telephone checkcallstackarray: elements-error");
				return(0xff);
			}
			//**************
			
			//***recordaddress***
			if(recordaddress!=0 && recordaddress!=1 && recordaddress!=2){
				write("FSG-Telephone checkcallstackarray: recordaddress-error");
				return(0xff);
			}
			//*******************

		break;
		default:	//error
			write("FSG-Telephone checkcallstackarray: invalid request %d", array[2]);
		break;
		
	}
	
	return(valid);

}

display_callstack_dialednumbers ()
{
int callstackline, i;
char dialdate[CALLSTACK][9];
char dialtime[CALLSTACK][9];
char numbertype[CALLSTACK][10];


	//PbName
	putvalue(env_FSG_dialednumber0_PbName, gdialednumbers_pbname [0]);
	putvalue(env_FSG_dialednumber1_PbName, gdialednumbers_pbname [1]);
	putvalue(env_FSG_dialednumber2_PbName, gdialednumbers_pbname [2]);
	putvalue(env_FSG_dialednumber3_PbName, gdialednumbers_pbname [3]);
	putvalue(env_FSG_dialednumber4_PbName, gdialednumbers_pbname [4]);
	putvalue(env_FSG_dialednumber5_PbName, gdialednumbers_pbname [5]);
	putvalue(env_FSG_dialednumber6_PbName, gdialednumbers_pbname [6]);
	putvalue(env_FSG_dialednumber7_PbName, gdialednumbers_pbname [7]);
	putvalue(env_FSG_dialednumber8_PbName, gdialednumbers_pbname [8]);
	putvalue(env_FSG_dialednumber9_PbName, gdialednumbers_pbname [9]);
	putvalue(env_FSG_dialednumber10_PbName, gdialednumbers_pbname [10]);
	putvalue(env_FSG_dialednumber11_PbName, gdialednumbers_pbname [11]);
	putvalue(env_FSG_dialednumber12_PbName, gdialednumbers_pbname [12]);
	putvalue(env_FSG_dialednumber13_PbName, gdialednumbers_pbname [13]);
	putvalue(env_FSG_dialednumber14_PbName, gdialednumbers_pbname [14]);
	putvalue(env_FSG_dialednumber15_PbName, gdialednumbers_pbname [15]);
	putvalue(env_FSG_dialednumber16_PbName, gdialednumbers_pbname [16]);
	putvalue(env_FSG_dialednumber17_PbName, gdialednumbers_pbname [17]);
	putvalue(env_FSG_dialednumber18_PbName, gdialednumbers_pbname [18]);
	putvalue(env_FSG_dialednumber19_PbName, gdialednumbers_pbname [19]);

	//TelNumber
	putvalue(env_FSG_dialednumber0_TelNumber, gdialednumbers_telnumber [0]);
	putvalue(env_FSG_dialednumber1_TelNumber, gdialednumbers_telnumber [1]);
	putvalue(env_FSG_dialednumber2_TelNumber, gdialednumbers_telnumber [2]);
	putvalue(env_FSG_dialednumber3_TelNumber, gdialednumbers_telnumber [3]);
	putvalue(env_FSG_dialednumber4_TelNumber, gdialednumbers_telnumber [4]);
	putvalue(env_FSG_dialednumber5_TelNumber, gdialednumbers_telnumber [5]);
	putvalue(env_FSG_dialednumber6_TelNumber, gdialednumbers_telnumber [6]);
	putvalue(env_FSG_dialednumber7_TelNumber, gdialednumbers_telnumber [7]);
	putvalue(env_FSG_dialednumber8_TelNumber, gdialednumbers_telnumber [8]);
	putvalue(env_FSG_dialednumber9_TelNumber, gdialednumbers_telnumber [9]);
	putvalue(env_FSG_dialednumber10_TelNumber, gdialednumbers_telnumber [10]);
	putvalue(env_FSG_dialednumber11_TelNumber, gdialednumbers_telnumber [11]);
	putvalue(env_FSG_dialednumber12_TelNumber, gdialednumbers_telnumber [12]);
	putvalue(env_FSG_dialednumber13_TelNumber, gdialednumbers_telnumber [13]);
	putvalue(env_FSG_dialednumber14_TelNumber, gdialednumbers_telnumber [14]);
	putvalue(env_FSG_dialednumber15_TelNumber, gdialednumbers_telnumber [15]);
	putvalue(env_FSG_dialednumber16_TelNumber, gdialednumbers_telnumber [16]);
	putvalue(env_FSG_dialednumber17_TelNumber, gdialednumbers_telnumber [17]);
	putvalue(env_FSG_dialednumber18_TelNumber, gdialednumbers_telnumber [18]);
	putvalue(env_FSG_dialednumber19_TelNumber, gdialednumbers_telnumber [19]);
	
	

	//Date
	for(callstackline=0;callstackline<CALLSTACK;callstackline++){
		dialdate[callstackline][0]=gdialednumbers_date[callstackline][0];
		dialdate[callstackline][1]=gdialednumbers_date[callstackline][1];
		dialdate[callstackline][2]='.';
		dialdate[callstackline][3]=gdialednumbers_date[callstackline][2];
		dialdate[callstackline][4]=gdialednumbers_date[callstackline][3];
		dialdate[callstackline][5]='.';
		dialdate[callstackline][6]=gdialednumbers_date[callstackline][4];
		dialdate[callstackline][7]=gdialednumbers_date[callstackline][5];
	}

	putvalue(env_FSG_dialednumber0_date, dialdate [0]);
	putvalue(env_FSG_dialednumber1_date, dialdate [1]);
	putvalue(env_FSG_dialednumber2_date, dialdate [2]);
	putvalue(env_FSG_dialednumber3_date, dialdate [3]);
	putvalue(env_FSG_dialednumber4_date, dialdate [4]);
	putvalue(env_FSG_dialednumber5_date, dialdate [5]);
	putvalue(env_FSG_dialednumber6_date, dialdate [6]);
	putvalue(env_FSG_dialednumber7_date, dialdate [7]);
	putvalue(env_FSG_dialednumber8_date, dialdate [8]);
	putvalue(env_FSG_dialednumber9_date, dialdate [9]);
	putvalue(env_FSG_dialednumber10_date, dialdate [10]);
	putvalue(env_FSG_dialednumber11_date, dialdate [11]);
	putvalue(env_FSG_dialednumber12_date, dialdate [12]);
	putvalue(env_FSG_dialednumber13_date, dialdate [13]);
	putvalue(env_FSG_dialednumber14_date, dialdate [14]);
	putvalue(env_FSG_dialednumber15_date, dialdate [15]);
	putvalue(env_FSG_dialednumber16_date, dialdate [16]);
	putvalue(env_FSG_dialednumber17_date, dialdate [17]);
	putvalue(env_FSG_dialednumber18_date, dialdate [18]);
	putvalue(env_FSG_dialednumber19_date, dialdate [19]);

	//time
	for(callstackline=0;callstackline<CALLSTACK;callstackline++){
		dialtime[callstackline][0]=gdialednumbers_time[callstackline][0];
		dialtime[callstackline][1]=gdialednumbers_time[callstackline][1];
		dialtime[callstackline][2]=':';
		dialtime[callstackline][3]=gdialednumbers_time[callstackline][2];
		dialtime[callstackline][4]=gdialednumbers_time[callstackline][3];
		dialtime[callstackline][5]=':';
		dialtime[callstackline][6]=gdialednumbers_time[callstackline][4];
		dialtime[callstackline][7]=gdialednumbers_time[callstackline][5];
	}
	putvalue(env_FSG_dialednumber0_time, dialtime [0]);
	putvalue(env_FSG_dialednumber1_time, dialtime [1]);
	putvalue(env_FSG_dialednumber2_time, dialtime [2]);
	putvalue(env_FSG_dialednumber3_time, dialtime [3]);
	putvalue(env_FSG_dialednumber4_time, dialtime [4]);
	putvalue(env_FSG_dialednumber5_time, dialtime [5]);
	putvalue(env_FSG_dialednumber6_time, dialtime [6]);
	putvalue(env_FSG_dialednumber7_time, dialtime [7]);
	putvalue(env_FSG_dialednumber8_time, dialtime [8]);
	putvalue(env_FSG_dialednumber9_time, dialtime [9]);
	putvalue(env_FSG_dialednumber10_time, dialtime [10]);
	putvalue(env_FSG_dialednumber11_time, dialtime [11]);
	putvalue(env_FSG_dialednumber12_time, dialtime [12]);
	putvalue(env_FSG_dialednumber13_time, dialtime [13]);
	putvalue(env_FSG_dialednumber14_time, dialtime [14]);
	putvalue(env_FSG_dialednumber15_time, dialtime [15]);
	putvalue(env_FSG_dialednumber16_time, dialtime [16]);
	putvalue(env_FSG_dialednumber17_time, dialtime [17]);
	putvalue(env_FSG_dialednumber18_time, dialtime [18]);
	putvalue(env_FSG_dialednumber19_time, dialtime [19]);

	//numbertype
	for(i=0;i<CALLSTACK;i++){
		if(gdialednumbers_numbertype[i]<5)
			strncpy(numbertype[i], gnumbertype[gdialednumbers_numbertype[i]],10);
	}
	putvalue(env_FSG_dialednumber0_numbertype, numbertype [0]);
	putvalue(env_FSG_dialednumber1_numbertype, numbertype [1]);
	putvalue(env_FSG_dialednumber2_numbertype, numbertype [2]);
	putvalue(env_FSG_dialednumber3_numbertype, numbertype [3]);
	putvalue(env_FSG_dialednumber4_numbertype, numbertype [4]);
	putvalue(env_FSG_dialednumber5_numbertype, numbertype [5]);
	putvalue(env_FSG_dialednumber6_numbertype, numbertype [6]);
	putvalue(env_FSG_dialednumber7_numbertype, numbertype [7]);
	putvalue(env_FSG_dialednumber8_numbertype, numbertype [8]);
	putvalue(env_FSG_dialednumber9_numbertype, numbertype [9]);
	putvalue(env_FSG_dialednumber10_numbertyp, numbertype [10]);
	putvalue(env_FSG_dialednumber11_numbertyp, numbertype [11]);
	putvalue(env_FSG_dialednumber12_numbertyp, numbertype [12]);
	putvalue(env_FSG_dialednumber13_numbertyp, numbertype [13]);
	putvalue(env_FSG_dialednumber14_numbertyp, numbertype [14]);
	putvalue(env_FSG_dialednumber15_numbertyp, numbertype [15]);
	putvalue(env_FSG_dialednumber16_numbertyp, numbertype [16]);
	putvalue(env_FSG_dialednumber17_numbertyp, numbertype [17]);
	putvalue(env_FSG_dialednumber18_numbertyp, numbertype [18]);
	putvalue(env_FSG_dialednumber19_numbertyp, numbertype [19]);

}

display_callstack_missedcalls ()
{
int callstackline, i;
char missedcalldate[CALLSTACK][9];
char missedcalltime[CALLSTACK][9];
char numbertype[CALLSTACK][15];

    //Pos
	putvalue(env_FSG_missedcall0_Pos, gmissedcalls_pos [0]);
	putvalue(env_FSG_missedcall1_Pos, gmissedcalls_pos [1]);
	putvalue(env_FSG_missedcall2_Pos, gmissedcalls_pos [2]);
	putvalue(env_FSG_missedcall3_Pos, gmissedcalls_pos [3]);
	putvalue(env_FSG_missedcall4_Pos, gmissedcalls_pos [4]);
	putvalue(env_FSG_missedcall5_Pos, gmissedcalls_pos [5]);
	putvalue(env_FSG_missedcall6_Pos, gmissedcalls_pos [6]);
	putvalue(env_FSG_missedcall7_Pos, gmissedcalls_pos [7]);
	putvalue(env_FSG_missedcall8_Pos, gmissedcalls_pos [8]);
	putvalue(env_FSG_missedcall9_Pos, gmissedcalls_pos [9]);
	putvalue(env_FSG_missedcall10_Pos, gmissedcalls_pos [10]);
	putvalue(env_FSG_missedcall11_Pos, gmissedcalls_pos [11]);
	putvalue(env_FSG_missedcall12_Pos, gmissedcalls_pos [12]);
	putvalue(env_FSG_missedcall13_Pos, gmissedcalls_pos [13]);
	putvalue(env_FSG_missedcall14_Pos, gmissedcalls_pos [14]);
	putvalue(env_FSG_missedcall15_Pos, gmissedcalls_pos [15]);
	putvalue(env_FSG_missedcall16_Pos, gmissedcalls_pos [16]);
	putvalue(env_FSG_missedcall17_Pos, gmissedcalls_pos [17]);
	putvalue(env_FSG_missedcall18_Pos, gmissedcalls_pos [18]);
	putvalue(env_FSG_missedcall19_Pos, gmissedcalls_pos [19]);

	//PbName
	putvalue(env_FSG_missedcall0_PbName, gmissedcalls_pbname [0]);
	putvalue(env_FSG_missedcall1_PbName, gmissedcalls_pbname [1]);
	putvalue(env_FSG_missedcall2_PbName, gmissedcalls_pbname [2]);
	putvalue(env_FSG_missedcall3_PbName, gmissedcalls_pbname [3]);
	putvalue(env_FSG_missedcall4_PbName, gmissedcalls_pbname [4]);
	putvalue(env_FSG_missedcall5_PbName, gmissedcalls_pbname [5]);
	putvalue(env_FSG_missedcall6_PbName, gmissedcalls_pbname [6]);
	putvalue(env_FSG_missedcall7_PbName, gmissedcalls_pbname [7]);
	putvalue(env_FSG_missedcall8_PbName, gmissedcalls_pbname [8]);
	putvalue(env_FSG_missedcall9_PbName, gmissedcalls_pbname [9]);
	putvalue(env_FSG_missedcall10_PbName, gmissedcalls_pbname [10]);
	putvalue(env_FSG_missedcall11_PbName, gmissedcalls_pbname [11]);
	putvalue(env_FSG_missedcall12_PbName, gmissedcalls_pbname [12]);
	putvalue(env_FSG_missedcall13_PbName, gmissedcalls_pbname [13]);
	putvalue(env_FSG_missedcall14_PbName, gmissedcalls_pbname [14]);
	putvalue(env_FSG_missedcall15_PbName, gmissedcalls_pbname [15]);
	putvalue(env_FSG_missedcall16_PbName, gmissedcalls_pbname [16]);
	putvalue(env_FSG_missedcall17_PbName, gmissedcalls_pbname [17]);
	putvalue(env_FSG_missedcall18_PbName, gmissedcalls_pbname [18]);
	putvalue(env_FSG_missedcall19_PbName, gmissedcalls_pbname [19]);

	//TelNumber
	putvalue(env_FSG_missedcall0_TelNumber, gmissedcalls_telnumber [0]);
	putvalue(env_FSG_missedcall1_TelNumber, gmissedcalls_telnumber [1]);
	putvalue(env_FSG_missedcall2_TelNumber, gmissedcalls_telnumber [2]);
	putvalue(env_FSG_missedcall3_TelNumber, gmissedcalls_telnumber [3]);
	putvalue(env_FSG_missedcall4_TelNumber, gmissedcalls_telnumber [4]);
	putvalue(env_FSG_missedcall5_TelNumber, gmissedcalls_telnumber [5]);
	putvalue(env_FSG_missedcall6_TelNumber, gmissedcalls_telnumber [6]);
	putvalue(env_FSG_missedcall7_TelNumber, gmissedcalls_telnumber [7]);
	putvalue(env_FSG_missedcall8_TelNumber, gmissedcalls_telnumber [8]);
	putvalue(env_FSG_missedcall9_TelNumber, gmissedcalls_telnumber [9]);
	putvalue(env_FSG_missedcall10_TelNumber, gmissedcalls_telnumber [10]);
	putvalue(env_FSG_missedcall11_TelNumber, gmissedcalls_telnumber [11]);
	putvalue(env_FSG_missedcall12_TelNumber, gmissedcalls_telnumber [12]);
	putvalue(env_FSG_missedcall13_TelNumber, gmissedcalls_telnumber [13]);
	putvalue(env_FSG_missedcall14_TelNumber, gmissedcalls_telnumber [14]);
	putvalue(env_FSG_missedcall15_TelNumber, gmissedcalls_telnumber [15]);
	putvalue(env_FSG_missedcall16_TelNumber, gmissedcalls_telnumber [16]);
	putvalue(env_FSG_missedcall17_TelNumber, gmissedcalls_telnumber [17]);
	putvalue(env_FSG_missedcall18_TelNumber, gmissedcalls_telnumber [18]);
	putvalue(env_FSG_missedcall19_TelNumber, gmissedcalls_telnumber [19]);
	
	

	//Date
	for(callstackline=0;callstackline<20;callstackline++)
    {
		missedcalldate[callstackline][0]=gmissedcalls_date[callstackline][0];
		missedcalldate[callstackline][1]=gmissedcalls_date[callstackline][1];
		missedcalldate[callstackline][2]='.';
		missedcalldate[callstackline][3]=gmissedcalls_date[callstackline][2];
		missedcalldate[callstackline][4]=gmissedcalls_date[callstackline][3];
		missedcalldate[callstackline][5]='.';
		missedcalldate[callstackline][6]=gmissedcalls_date[callstackline][4];
		missedcalldate[callstackline][7]=gmissedcalls_date[callstackline][5];
	}

	putvalue(env_FSG_missedcall0_date, missedcalldate [0]);
	putvalue(env_FSG_missedcall1_date, missedcalldate [1]);
	putvalue(env_FSG_missedcall2_date, missedcalldate [2]);
	putvalue(env_FSG_missedcall3_date, missedcalldate [3]);
	putvalue(env_FSG_missedcall4_date, missedcalldate [4]);
	putvalue(env_FSG_missedcall5_date, missedcalldate [5]);
	putvalue(env_FSG_missedcall6_date, missedcalldate [6]);
	putvalue(env_FSG_missedcall7_date, missedcalldate [7]);
	putvalue(env_FSG_missedcall8_date, missedcalldate [8]);
	putvalue(env_FSG_missedcall9_date, missedcalldate [9]);
	putvalue(env_FSG_missedcall10_date, missedcalldate [10]);
	putvalue(env_FSG_missedcall11_date, missedcalldate [11]);
	putvalue(env_FSG_missedcall12_date, missedcalldate [12]);
	putvalue(env_FSG_missedcall13_date, missedcalldate [13]);
	putvalue(env_FSG_missedcall14_date, missedcalldate [14]);
	putvalue(env_FSG_missedcall15_date, missedcalldate [15]);
	putvalue(env_FSG_missedcall16_date, missedcalldate [16]);
	putvalue(env_FSG_missedcall17_date, missedcalldate [17]);
	putvalue(env_FSG_missedcall18_date, missedcalldate [18]);
	putvalue(env_FSG_missedcall19_date, missedcalldate [19]);

	//time
	for(callstackline=0;callstackline<20;callstackline++){
		missedcalltime[callstackline][0]=gmissedcalls_time[callstackline][0];
		missedcalltime[callstackline][1]=gmissedcalls_time[callstackline][1];
		missedcalltime[callstackline][2]=':';
		missedcalltime[callstackline][3]=gmissedcalls_time[callstackline][2];
		missedcalltime[callstackline][4]=gmissedcalls_time[callstackline][3];
		missedcalltime[callstackline][5]=':';
		missedcalltime[callstackline][6]=gmissedcalls_time[callstackline][4];
		missedcalltime[callstackline][7]=gmissedcalls_time[callstackline][5];
	}
	putvalue(env_FSG_missedcall0_time, missedcalltime [0]);
	putvalue(env_FSG_missedcall1_time, missedcalltime [1]);
	putvalue(env_FSG_missedcall2_time, missedcalltime [2]);
	putvalue(env_FSG_missedcall3_time, missedcalltime [3]);
	putvalue(env_FSG_missedcall4_time, missedcalltime [4]);
	putvalue(env_FSG_missedcall5_time, missedcalltime [5]);
	putvalue(env_FSG_missedcall6_time, missedcalltime [6]);
	putvalue(env_FSG_missedcall7_time, missedcalltime [7]);
	putvalue(env_FSG_missedcall8_time, missedcalltime [8]);
	putvalue(env_FSG_missedcall9_time, missedcalltime [9]);
	putvalue(env_FSG_missedcall10_time, missedcalltime [10]);
	putvalue(env_FSG_missedcall11_time, missedcalltime [11]);
	putvalue(env_FSG_missedcall12_time, missedcalltime [12]);
	putvalue(env_FSG_missedcall13_time, missedcalltime [13]);
	putvalue(env_FSG_missedcall14_time, missedcalltime [14]);
	putvalue(env_FSG_missedcall15_time, missedcalltime [15]);
	putvalue(env_FSG_missedcall16_time, missedcalltime [16]);
	putvalue(env_FSG_missedcall17_time, missedcalltime [17]);
	putvalue(env_FSG_missedcall18_time, missedcalltime [18]);
	putvalue(env_FSG_missedcall19_time, missedcalltime [19]);

	//numbertype
	for(i=0;i<20;i++){
		if(gmissedcalls_numbertype[i]<0x0F)
			strncpy(numbertype[i], gnumbertype[gmissedcalls_numbertype[i]],15);
	}
	putvalue(env_FSG_missedcall0_numbertype, numbertype [0]);
	putvalue(env_FSG_missedcall1_numbertype, numbertype [1]);
	putvalue(env_FSG_missedcall2_numbertype, numbertype [2]);
	putvalue(env_FSG_missedcall3_numbertype, numbertype [3]);
	putvalue(env_FSG_missedcall4_numbertype, numbertype [4]);
	putvalue(env_FSG_missedcall5_numbertype, numbertype [5]);
	putvalue(env_FSG_missedcall6_numbertype, numbertype [6]);
	putvalue(env_FSG_missedcall7_numbertype, numbertype [7]);
	putvalue(env_FSG_missedcall8_numbertype, numbertype [8]);
	putvalue(env_FSG_missedcall9_numbertype, numbertype [9]);
	putvalue(env_FSG_missedcall10_numbertyp, numbertype [10]);
	putvalue(env_FSG_missedcall11_numbertyp, numbertype [11]);
	putvalue(env_FSG_missedcall12_numbertyp, numbertype [12]);
	putvalue(env_FSG_missedcall13_numbertyp, numbertype [13]);
	putvalue(env_FSG_missedcall14_numbertyp, numbertype [14]);
	putvalue(env_FSG_missedcall15_numbertyp, numbertype [15]);
	putvalue(env_FSG_missedcall16_numbertyp, numbertype [16]);
	putvalue(env_FSG_missedcall17_numbertyp, numbertype [17]);
	putvalue(env_FSG_missedcall18_numbertyp, numbertype [18]);
	putvalue(env_FSG_missedcall19_numbertyp, numbertype [19]);

}

display_callstack_receivedcalls ()
{
int callstackline, i;
char receivedcalldate[CALLSTACK][9];
char receivedcalltime[CALLSTACK][9];
char numbertype[CALLSTACK][10];


	//PbName
	putvalue(env_FSG_receivedcall0_PbName, greceivedcalls_pbname [0]);
	putvalue(env_FSG_receivedcall1_PbName, greceivedcalls_pbname [1]);
	putvalue(env_FSG_receivedcall2_PbName, greceivedcalls_pbname [2]);
	putvalue(env_FSG_receivedcall3_PbName, greceivedcalls_pbname [3]);
	putvalue(env_FSG_receivedcall4_PbName, greceivedcalls_pbname [4]);
	putvalue(env_FSG_receivedcall5_PbName, greceivedcalls_pbname [5]);
	putvalue(env_FSG_receivedcall6_PbName, greceivedcalls_pbname [6]);
	putvalue(env_FSG_receivedcall7_PbName, greceivedcalls_pbname [7]);
	putvalue(env_FSG_receivedcall8_PbName, greceivedcalls_pbname [8]);
	putvalue(env_FSG_receivedcall9_PbName, greceivedcalls_pbname [9]);
	putvalue(env_FSG_receivedcall10_PbName, greceivedcalls_pbname [10]);
	putvalue(env_FSG_receivedcall11_PbName, greceivedcalls_pbname [11]);
	putvalue(env_FSG_receivedcall12_PbName, greceivedcalls_pbname [12]);
	putvalue(env_FSG_receivedcall13_PbName, greceivedcalls_pbname [13]);
	putvalue(env_FSG_receivedcall14_PbName, greceivedcalls_pbname [14]);
	putvalue(env_FSG_receivedcall15_PbName, greceivedcalls_pbname [15]);
	putvalue(env_FSG_receivedcall16_PbName, greceivedcalls_pbname [16]);
	putvalue(env_FSG_receivedcall17_PbName, greceivedcalls_pbname [17]);
	putvalue(env_FSG_receivedcall18_PbName, greceivedcalls_pbname [18]);
	putvalue(env_FSG_receivedcall19_PbName, greceivedcalls_pbname [19]);

	//TelNumber
	putvalue(env_FSG_receivedcall0_TelNumber, greceivedcalls_telnumber [0]);
	putvalue(env_FSG_receivedcall1_TelNumber, greceivedcalls_telnumber [1]);
	putvalue(env_FSG_receivedcall2_TelNumber, greceivedcalls_telnumber [2]);
	putvalue(env_FSG_receivedcall3_TelNumber, greceivedcalls_telnumber [3]);
	putvalue(env_FSG_receivedcall4_TelNumber, greceivedcalls_telnumber [4]);
	putvalue(env_FSG_receivedcall5_TelNumber, greceivedcalls_telnumber [5]);
	putvalue(env_FSG_receivedcall6_TelNumber, greceivedcalls_telnumber [6]);
	putvalue(env_FSG_receivedcall7_TelNumber, greceivedcalls_telnumber [7]);
	putvalue(env_FSG_receivedcall8_TelNumber, greceivedcalls_telnumber [8]);
	putvalue(env_FSG_receivedcall9_TelNumber, greceivedcalls_telnumber [9]);
	putvalue(env_FSG_receivedcall10_TelNumber, greceivedcalls_telnumber [10]);
	putvalue(env_FSG_receivedcall11_TelNumber, greceivedcalls_telnumber [11]);
	putvalue(env_FSG_receivedcall12_TelNumber, greceivedcalls_telnumber [12]);
	putvalue(env_FSG_receivedcall13_TelNumber, greceivedcalls_telnumber [13]);
	putvalue(env_FSG_receivedcall14_TelNumber, greceivedcalls_telnumber [14]);
	putvalue(env_FSG_receivedcall15_TelNumber, greceivedcalls_telnumber [15]);
	putvalue(env_FSG_receivedcall16_TelNumber, greceivedcalls_telnumber [16]);
	putvalue(env_FSG_receivedcall17_TelNumber, greceivedcalls_telnumber [17]);
	putvalue(env_FSG_receivedcall18_TelNumber, greceivedcalls_telnumber [18]);
	putvalue(env_FSG_receivedcall19_TelNumber, greceivedcalls_telnumber [19]);
	
	

	//Date
	for(callstackline=0;callstackline<CALLSTACK;callstackline++){
		receivedcalldate[callstackline][0]=greceivedcalls_date[callstackline][0];
		receivedcalldate[callstackline][1]=greceivedcalls_date[callstackline][1];
		receivedcalldate[callstackline][2]='.';
		receivedcalldate[callstackline][3]=greceivedcalls_date[callstackline][2];
		receivedcalldate[callstackline][4]=greceivedcalls_date[callstackline][3];
		receivedcalldate[callstackline][5]='.';
		receivedcalldate[callstackline][6]=greceivedcalls_date[callstackline][4];
		receivedcalldate[callstackline][7]=greceivedcalls_date[callstackline][5];
	}

	putvalue(env_FSG_receivedcall0_date, receivedcalldate [0]);
	putvalue(env_FSG_receivedcall1_date, receivedcalldate [1]);
	putvalue(env_FSG_receivedcall2_date, receivedcalldate [2]);
	putvalue(env_FSG_receivedcall3_date, receivedcalldate [3]);
	putvalue(env_FSG_receivedcall4_date, receivedcalldate [4]);
	putvalue(env_FSG_receivedcall5_date, receivedcalldate [5]);
	putvalue(env_FSG_receivedcall6_date, receivedcalldate [6]);
	putvalue(env_FSG_receivedcall7_date, receivedcalldate [7]);
	putvalue(env_FSG_receivedcall8_date, receivedcalldate [8]);
	putvalue(env_FSG_receivedcall9_date, receivedcalldate [9]);
	putvalue(env_FSG_receivedcall10_date, receivedcalldate [10]);
	putvalue(env_FSG_receivedcall11_date, receivedcalldate [11]);
	putvalue(env_FSG_receivedcall12_date, receivedcalldate [12]);
	putvalue(env_FSG_receivedcall13_date, receivedcalldate [13]);
	putvalue(env_FSG_receivedcall14_date, receivedcalldate [14]);
	putvalue(env_FSG_receivedcall15_date, receivedcalldate [15]);
	putvalue(env_FSG_receivedcall16_date, receivedcalldate [16]);
	putvalue(env_FSG_receivedcall17_date, receivedcalldate [17]);
	putvalue(env_FSG_receivedcall18_date, receivedcalldate [18]);
	putvalue(env_FSG_receivedcall19_date, receivedcalldate [19]);

	//time
	for(callstackline=0;callstackline<CALLSTACK;callstackline++){
		receivedcalltime[callstackline][0]=greceivedcalls_time[callstackline][0];
		receivedcalltime[callstackline][1]=greceivedcalls_time[callstackline][1];
		receivedcalltime[callstackline][2]=':';
		receivedcalltime[callstackline][3]=greceivedcalls_time[callstackline][2];
		receivedcalltime[callstackline][4]=greceivedcalls_time[callstackline][3];
		receivedcalltime[callstackline][5]=':';
		receivedcalltime[callstackline][6]=greceivedcalls_time[callstackline][4];
		receivedcalltime[callstackline][7]=greceivedcalls_time[callstackline][5];
	}
	putvalue(env_FSG_receivedcall0_time, receivedcalltime [0]);
	putvalue(env_FSG_receivedcall1_time, receivedcalltime [1]);
	putvalue(env_FSG_receivedcall2_time, receivedcalltime [2]);
	putvalue(env_FSG_receivedcall3_time, receivedcalltime [3]);
	putvalue(env_FSG_receivedcall4_time, receivedcalltime [4]);
	putvalue(env_FSG_receivedcall5_time, receivedcalltime [5]);
	putvalue(env_FSG_receivedcall6_time, receivedcalltime [6]);
	putvalue(env_FSG_receivedcall7_time, receivedcalltime [7]);
	putvalue(env_FSG_receivedcall8_time, receivedcalltime [8]);
	putvalue(env_FSG_receivedcall9_time, receivedcalltime [9]);
	putvalue(env_FSG_receivedcall10_time, receivedcalltime [10]);
	putvalue(env_FSG_receivedcall11_time, receivedcalltime [11]);
	putvalue(env_FSG_receivedcall12_time, receivedcalltime [12]);
	putvalue(env_FSG_receivedcall13_time, receivedcalltime [13]);
	putvalue(env_FSG_receivedcall14_time, receivedcalltime [14]);
	putvalue(env_FSG_receivedcall15_time, receivedcalltime [15]);
	putvalue(env_FSG_receivedcall16_time, receivedcalltime [16]);
	putvalue(env_FSG_receivedcall17_time, receivedcalltime [17]);
	putvalue(env_FSG_receivedcall18_time, receivedcalltime [18]);
	putvalue(env_FSG_receivedcall19_time, receivedcalltime [19]);

	//numbertype
	for(i=0;i<CALLSTACK;i++){
		if(greceivedcalls_numbertype[i]<5)
			strncpy(numbertype[i], gnumbertype[greceivedcalls_numbertype[i]],10);
	}
	putvalue(env_FSG_receivedcall0_numbertype, numbertype [0]);
	putvalue(env_FSG_receivedcall1_numbertype, numbertype [1]);
	putvalue(env_FSG_receivedcall2_numbertype, numbertype [2]);
	putvalue(env_FSG_receivedcall3_numbertype, numbertype [3]);
	putvalue(env_FSG_receivedcall4_numbertype, numbertype [4]);
	putvalue(env_FSG_receivedcall5_numbertype, numbertype [5]);
	putvalue(env_FSG_receivedcall6_numbertype, numbertype [6]);
	putvalue(env_FSG_receivedcall7_numbertype, numbertype [7]);
	putvalue(env_FSG_receivedcall8_numbertype, numbertype [8]);
	putvalue(env_FSG_receivedcall9_numbertype, numbertype [9]);
	putvalue(env_FSG_receivedcall10_numbertyp, numbertype [10]);
	putvalue(env_FSG_receivedcall11_numbertyp, numbertype [11]);
	putvalue(env_FSG_receivedcall12_numbertyp, numbertype [12]);
	putvalue(env_FSG_receivedcall13_numbertyp, numbertype [13]);
	putvalue(env_FSG_receivedcall14_numbertyp, numbertype [14]);
	putvalue(env_FSG_receivedcall15_numbertyp, numbertype [15]);
	putvalue(env_FSG_receivedcall16_numbertyp, numbertype [16]);
	putvalue(env_FSG_receivedcall17_numbertyp, numbertype [17]);
	putvalue(env_FSG_receivedcall18_numbertyp, numbertype [18]);
	putvalue(env_FSG_receivedcall19_numbertyp, numbertype [19]);

}

MissedCallIndication_Indication (dword Indication_array [], byte indication, int datalength)
{

int missedcalls, missednumbers;

//init lokal variables
	missedcalls=0;
	missednumbers=0;
//********************
	
	
	switch(indication){
		case DataSetGet_IND:
			//check BAP-array
			if(datalength!=7)														//datalength error
				MissedCallIndication_Request(Error_REQ, Terror_unknownapllicationerror);//send error-message to RNS
			
             //IssueList #27
            else if (getValue(env_Tel_MissedCallInd_Error_On))
            MissedCallIndication_Request(Error_REQ, getValue(env_Tel_MissedCallInd_Error_Code));

            else{
				missedcalls=Indication_array[3]+Indication_array[4]*0x100;
				missednumbers=Indication_array[5]+Indication_array[6]*0x100;
				if(missedcalls!=0 || missednumbers!=0)								//invalid value for set/ setget
					MissedCallIndication_Request(Error_REQ, Terror_unknownapllicationerror);//send error-message to RNS
				else{
					gMissedCalls=0;
					gMissedNumbers=0;
					putvalue(env_FSG_MissedCalls, gMissedCalls);
					putvalue(env_FSG_MissedNumbers, gMissedNumbers);
					MissedCallIndication_Request(Data_REQ, 0);						//send data to RNS
					
				}
			}
		break;
		case DataGet_IND:
			//check BAP-array
			if(datalength!=3)														//datalength error
				MissedCallIndication_Request(Error_REQ, Terror_unknownapllicationerror);//send error-message to RNS
			else
				MissedCallIndication_Request(Data_REQ, 0);							//send data to RNS
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone MissedCallIndication_Indication: invalid indication %d", indication);
		break;
		}		
}

MissedCallIndication_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************
	
	switch(request){
		case Data_REQ:
            //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x2D_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;				//LSG-ID
			requestarray[1]=FctID_MissedCallIndication;		//Fct.-ID
			requestarray[2]=request;	
			//changes from Jöran Karl (28.03.2012)
			requestarray[3]=gMissedCalls & 0xff;        //Lowbyte of MissedCall
			requestarray[4]=(gMissedCalls >> 8) & 0xff; //Highbyte of MissedCall
			requestarray[5]=gMissedNumbers & 0xff;      //Lowbyte of MissedCall
			requestarray[6]=(gMissedNumbers >> 8) & 0xff;//Highbyte of MissedCall

			Offset=7;		
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;				//LSG-ID
			requestarray[1]=FctID_MissedCallIndication;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone MissedCallIndication_Request: invalid request %d", request);
		break;
	}
}

MissedCalls_Indication (dword Indication_array [], byte indication, int datalength)
{

int i; 
word valid_startelement, startelement, elements, valid_elements, requested_startelement, delete_ID, datapointer;
byte mode, recordaddress, shift, direction, transmitpos, indexsize, temp, SetGet_possible;

//init lokal variables
	startelement=0;
	elements=0;
	valid_startelement=0xff;
	valid_elements=0;
	requested_startelement=0;
	delete_ID=0;
	datapointer=0;
	mode=0;
	recordaddress=0;
	shift=0;
	direction=0;
	transmitpos=0;
	indexsize=0;
	SetGet_possible=0;
    temp=0;
//********************
	
    gmissedcalls_ASG_ID=(Indication_array[3] & 0xF0)/0x10;
    gmissedcalls_TAID=Indication_array[3] & 0x0F;

	mode=Indication_array[4];
	recordaddress=mode & 0x0F;
	shift=(mode & 0x10)/0x10;
	direction=(mode & 0x20)/0x20;
	transmitpos=(mode & 0x40)/0x40;
	indexsize=(mode & 0x80)/0x80;
//	write("FSG-Telephone MissedCalls_Indication: direction:%d, indexsize: %d", direction, indexsize);
	if(indexsize){
		startelement=Indication_array[5]+Indication_array[6]*256;
		elements=Indication_array[7]+Indication_array[8]*256;
		datapointer=9;
	}
	else{
		startelement=Indication_array[5];
		elements=Indication_array[6];
		datapointer=7;
	}

	requested_startelement=startelement;

	//temp=checkcallstackarray(Indication_array, datalength);
    //write("FSG-Telephone MissedCalls_Indication - checkcallstackarray: %d",temp);
	
	if(temp==0xff)																		//check array-datalength/format
	{
		MissedCalls_Request(Error_REQ, 0, 0, 0, 0, Terror_unknownapllicationerror);
	}
	else
	{
		switch(indication)
		{
			case DataSetGet_IND:
			/*	switch(recordaddress)
				{
					case 1:	//PbName and NumberType only (is only used to delete an entry)
						//verify  startelement
						if(gmissedcalls_pbname[startelement][0]!=0 && Indication_array[datapointer]==0)	//only if valid entriy at found position and PbName-length=0 (necessary for delete)
						{
							SetGet_possible=1;
							delete_ID=startelement;
							i=CALLSTACK;											//loop finished
							write("delete dialednumber");
						}
						//**************************
						if(ActiveUserValidation()!=1)								//no active User available
							MissedCalls_Request(Error_REQ, 0, 0, 0, 0, Terror_unknownapllicationerror);
						else if(elements!=1)										//invalid value for elements, SetGet is allowed for only one element
							MissedCalls_Request(Error_REQ, 0, 0, 0, 0, Terror_datainvalid);
						else if(SetGet_possible!=1)									//invalid startelement or invalid parameter
							MissedCalls_Request(Error_REQ, 0, 0, 0, 0, Terror_datainvalid);	
						else
						{
							callstack_missedcalls(DELETE_ID, delete_ID,1);
							gmissedcall_DeleteStatus=TRUE;
							recordaddress=1;
							if(delete_ID<256)
								indexsize=0;
							else
								indexsize=1;
							
							shift=1;
							direction=1;												//means, that elements were deleted and the following entries were shifted upstairs
							mode=recordaddress+shift*0x10+direction*0x20+indexsize*0x80;
							MissedCalls_Request(Data_REQ, delete_ID, delete_ID, 1, mode, 0);
							settimer(MissedCallsDeleteEntryTimer, 250);
						}
					break;
					default:
						MissedCalls_Request(Error_REQ, 0, 0, 0, 0, Terror_datainvalid);
					break;
				}
            */
			break;
			case DataGet_IND:

				//	write("missedcalls User valid: %d", ActiveUserValidation());		//debug
				//if(ActiveUserValidation()!=1)	//function changed, always delievers true										//no active User available
				//{
				//	valid_startelement=startelement;
				//	valid_elements=0;
				//}

				//check startelement of request for special cases
                if(startelement==0 && direction==FORWARD)                          //begin at first element in list
                {
                    valid_startelement=startelement;

                    if(elements>CALLSTACK)              //to much elements requested
                    {
                        for(i=valid_startelement;i<CALLSTACK;i++)
                        {
                            if(gmissedcalls_pbname[i][0]!=0)            //element is valid
                                valid_elements++;
                            else                                        //element is not valid
                                i=CALLSTACK;                                //break loop
                        }
                    }
                    else        //elements =< CALLSTACK
                    {
                        for(i=valid_startelement;i<(elements+valid_startelement);i++)
                        {
                            if(gmissedcalls_pbname[i][0]!=0)            //element is valid
                                valid_elements++;
                            else                                        //element is not valid
                                i=CALLSTACK;                                //break loop
                        }
                    }
                }
                else if(startelement==0 && direction==BACKWARD && shift==TRUE)     //begin at last element in list
				{
                    //searching for valid startelement
                    for(i=(CALLSTACK-1);i>=0;i--)
					{
						if(gmissedcalls_pbname[i][0]!=0)		//found valid startelement
						{
							valid_startelement =i;								
							i =0;		                        //break loop										
						}
					}
                        
                    //searching for valid elements
					if(valid_startelement==0xff)					//no valid element found 
					{
						valid_startelement  =startelement;
						valid_elements      =0;
					}                                       
						
					else if(elements>(valid_startelement+1))		//not enougth array elements available, because no wrap around
					{
						for(i=valid_startelement;i>=0;i--)
						{
							if(gmissedcalls_pbname[i][0]!=0)    	//if there is an valid element
								valid_elements++;					
							else									//no valid element, 
								i=0;                                //loop finished
						}
					}
                    else											//enough array elements available
					{
						for(i=valid_startelement;i>=((valid_startelement+1)-elements);i--)
						{
							if(gmissedcalls_pbname[i][0]!=0)	    //if there is an valid element
								valid_elements++;			
							else									//no valid element
								i=0;                                //loop finished
						}              
					}
                }

				//************requested startelement !=0******************
				else
                {
					//searching for valid startelement
					for(i=0;i<CALLSTACK;i++)
					{
						if(gmissedcalls_pos[i]==startelement)					    //requested start element found
						{   
                            if(i==0)        //first element
                            {
                                if(direction==BACKWARD) 
                                    valid_startelement =0xff;                       //invalid element
                                else if(direction==FORWARD)
                                    valid_startelement = 0 + shift;                         //valid element is first element in Array
                            }                                       
                            else    //i!=0
                            {
                                if(shift==TRUE)											//shift is set, this means starting with the next/previous element (depending on the direction-setting)
						            valid_startelement =i+1-2*direction;            //includes shift & direction
                                else //shift==FALSE
                                    valid_startelement =i;                              //found element is valid_startelement
                            }
							i=CALLSTACK;        //break loop
						}
					}

					if(valid_startelement==0xff)										//Startelement-ID doesn't exist in array
					{
						valid_startelement  =startelement;
						valid_elements      =0;
					}
					else																//found valid entry for startelement in array
					{
						//verify number of valid elements
						if(direction==BACKWARD)											//BACKWARD
						{
							if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
								valid_elements=1;
							else if(elements>(valid_startelement+1))					//not enough array elements available, because array ends at array-position 0
							{
								for(i=valid_startelement;i>=0;i--)
								{
									if(gmissedcalls_pbname[i][0]!=0)                	//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element
										i=0;                                            //loop finished
								}
							}
							else														//enough array-elements available
							{
								for(i=valid_startelement;i>=((valid_startelement+1)-elements);i--)
								{
									if(gmissedcalls_pbname[i][0]!=0)                	//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element
										i=0;                                            //loop finished
								}
							}
						}
                        											
						else		//FORWARD
						{
							if((valid_startelement+elements)>=CALLSTACK)            //to much elements requested
							{
								for(i=valid_startelement;i<CALLSTACK;i++)
								{
									if(gmissedcalls_pbname[i][0]!=0)							//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element
										i=CALLSTACK;                                    //loop finished
								}
							}
							else            //enough elemtents available
							{
								for(i=valid_startelement;i<(valid_startelement+elements);i++)
								{
									if(gmissedcalls_pbname[i][0]!=0)							//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element
										i=CALLSTACK;
								}
							}
						}
					}
				}

				mode=recordaddress+shift*0x10+direction*0x20+transmitpos*0x40+indexsize*0x80;
				//********************
			//	write("FSG-Telephone MissedCalls_Indication: valid-start: %d, valid_elements: %d, indexsize: %d",valid_startelement, valid_elements, (mode & 0x01));
				
                if(gmissedcalls_AutoOnOff)    //Automatic response active
                    MissedCalls_Request(Data_REQ, requested_startelement, valid_startelement, valid_elements, mode, 0);
				
			break;
			default:
				MissedCalls_Request(Error_REQ, 0, 0, 0, 0, Terror_unknownapllicationerror);
				write("FSG-Telephone MissedCalls_Indication: invalid indication %d", indication);
			break;
		}
	}
}

MissedCalls_Request (byte request, word requested_startelement, word startelement, word elements, byte mode, byte errorcode)
{
int i;
word callstackline, leeloo, Offset, length, datapointer;
byte shift, indexsize, transmitpos, direction, recordaddress;	
dword requestarray [BAP_buffer_size];
char sday[3], smonth[3], syear[3], shour[3], smin[3], ssec[3];
byte bday, bmonth, byear, bhour, bmin, bsec;

//init lokal variables
	Offset=0;
	length=0;
	callstackline=0;
	leeloo=0;
	datapointer=0;
    shift=0;
	indexsize=0;
	transmitpos=0;
	direction=0;
	recordaddress=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
	
	for(i=0;i<3;i++)
	{
		sday[i]=0;
		smonth[i]=0;
		syear[i]=0;
		shour[i]=0;
		smin[i]=0;
		ssec[i]=0;
	}

	bday=0;
	bmonth=0;
	byear=0;
	bhour=0;
	bmin=0;
	bsec=0;
//********************

	shift=(mode & 0x10)/0x10;
	direction=(mode & 0x20)/0x20;
	transmitpos=(mode & 0x40)/0x40;
    indexsize=(mode & 0x80)/0x80;
	recordaddress=mode & 0x0f;
	//write("FSG-Telephone: MissedCalls_Request: direction:%d, indexsize: %d, recordaddress: %d", direction, indexsize, recordaddress);	

	switch (request)
	{
		case Changed_REQ:
			//BAP-header
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_MissedCalls;	//Fct.-ID
			requestarray[2]=request;	
			
			//extended array header
			requestarray[3]=mode;	//Mode+RecordAdress
			if(indexsize)       //16-bit
			{
				requestarray[4]=requested_startelement & 0x00ff;
				requestarray[5]=(requested_startelement & 0xff00)/0x100;
				requestarray[6]=elements & 0x00ff;
				requestarray[7]=(elements & 0xff00)/0x100;
				Offset=8;
			}
			else                //8bit
			{
				requestarray[4]=requested_startelement;
				requestarray[5]=elements;
				Offset=6;
			}

            //check, if startelement in array   
            if(requested_startelement !=0)      //startelement is not first element
            {
                for(i=0;i<CALLSTACK;i++)
                {
                    if(gmissedcalls_pos[i] ==requested_startelement)
                    {
                        callstackline =i;    
                        i=CALLSTACK;        //stop loop
                    }
                    else
                        callstackline =0xff;    //invalid
                }
            }
            else        //startelement is first element
                callstackline =0;

            //copy data
            while(leeloo <elements)
            {
                if(callstackline ==0xff) //Invalid list entry
                {
                    //write("FSG MissedCalls_Request: invalid callstackline");  //debug
                    break;  //leeloo =elements;       //stop loop
                }
                else //list entry valid
                {   
                    /***Array Data***/
                    if (transmitpos) // Pos  ->Array position transmitted
                    {
                        requestarray[Offset] =gmissedcalls_pos[callstackline];
                        Offset++;
                    }                                                                       
                }
                leeloo++;
                callstackline =nextvalidcallstackline(callstackline, gmissedcalls_pbname, direction, gmissedcalls_TotalNumListElements);               
            }//end while
            
            //if(callstackline!=0xff)     //only if callstack is valid, send request
			    set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);			
		break;

		case Data_REQ:
             //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x2E_TimeOut)!=TRUE)
            {
            transmitpos=1;      //arbitrary lists -> always send transmitpos
            mode=shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;//update mode
            mode=recordaddress + (mode*0x10);

			if(gmissedcall_DeleteStatus==TRUE)			//array-element was deleted
			{
				gmissedcall_DeleteStatus=FALSE;

				//BAP-header
				requestarray[0]=LSGID_Telephone;	//LSG-ID
				requestarray[1]=FctID_MissedCalls;	//Fct.-ID
				requestarray[2]=request;

                //ASG_ID & TAID
                requestarray[3]=(gmissedcalls_ASG_ID*0x10)+gmissedcalls_TAID;//upper and lower nibble

                requestarray[4]=gmissedcalls_TotalNumListElements;

				//extended array header
				requestarray[5]=mode;				//Mode

				if(indexsize)
				{
					requestarray[6]=requested_startelement & 0x00ff;
					requestarray[7]=(requested_startelement & 0xff00)/0x100;
					requestarray[8]=elements & 0x00ff;
					requestarray[9]=(elements & 0xff00)/0x100;
					Offset=10;
				}
				else
				{
					requestarray[6]=requested_startelement;
					requestarray[7]=elements;
					Offset=8;
				}

				//PbName
				requestarray[Offset]=0;
				Offset++;
				//NumberType
				requestarray[Offset]=0;
				Offset++;				

				set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

			}
			else	//no element was deleted, normal Status-array Request
			{
				//BAP-header
				requestarray[0]=LSGID_Telephone;	//LSG-ID telephone
				requestarray[1]=FctID_MissedCalls;	//Fct.-ID
				requestarray[2]=request;

				//ASG_ID & TAID
                requestarray[3]=(gmissedcalls_ASG_ID*0x10)+gmissedcalls_TAID;//upper and lower nibble

                requestarray[4]=gmissedcalls_TotalNumListElements;

				//extended array header
				requestarray[5]=mode;				//Mode
				if(indexsize)
				{
					requestarray[6]=requested_startelement & 0x00ff;
					requestarray[7]=(requested_startelement & 0xff00)/0x100;
					requestarray[8]=elements & 0x00ff;
					requestarray[9]=(elements & 0xff00)/0x100;
					Offset=10;
				}
				else
				{
					requestarray[6]=requested_startelement;
					requestarray[7]=elements;
					Offset=8;
				}

				callstackline=startelement;

				switch(recordaddress)
				{
					case 0:	//complete record
						while(leeloo<elements)
						{
							if(callstackline==0xff)
							{
								write("FSG-Telephone: MissedCalls_Request - invalid callstack-line");
								leeloo=elements;    //break loop
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									if(indexsize)
									{
										requestarray[Offset]=gmissedcalls_pos[callstackline] & 0x00ff;
										requestarray[Offset+1]=(gmissedcalls_pos[callstackline] & 0xff00)/0x100;
										Offset=Offset+2;
									}
									else
									{
										requestarray[Offset]=gmissedcalls_pos[callstackline];
										Offset++;
									}
								}								

								//PbName
								if(strncmp(gmissedcalls_pbname[callstackline], gunknown, CALL_INFO_NAME_LENGTH)==0) //PbName is "unknown"
								{
									length=1;
									requestarray[Offset]=length;
									Offset++;
									requestarray[Offset]=0x00;
									Offset++;
								}
								else    //PbName is known
								{
									length=strlen(gmissedcalls_pbname[callstackline]);
									requestarray[Offset]=length;
									Offset++;
									for(i=0;i<length;i++)	//copy PbName in request buffer
									{
										requestarray[Offset]=gmissedcalls_pbname[callstackline][i];
										Offset++;
									}
								}

								//NumberType
								requestarray[Offset]=gmissedcalls_numbertype[callstackline];	
								Offset++;

								//TelNumber
								length=strlen(gmissedcalls_telnumber[callstackline]);
								requestarray[Offset]=length;
								Offset++;
								for(i=0;i<length;i++)							//copy TelNumber in request buffer
								{
									requestarray[Offset]=gmissedcalls_telnumber[callstackline][i];
									Offset++;
								}
								
								//Date
								sday[0]=gmissedcalls_date[callstackline][0];
								sday[1]=gmissedcalls_date[callstackline][1];
								sday[2]=0;
								smonth[0]=gmissedcalls_date[callstackline][2];
								smonth[1]=gmissedcalls_date[callstackline][3];
								smonth[2]=0;
								syear[0]=gmissedcalls_date[callstackline][4];
								syear[1]=gmissedcalls_date[callstackline][5];
								syear[2]=0;
								bday=atol(sday);
								bmonth=atol(smonth);
								byear=atol(syear);

								//Time
								shour[0]=gmissedcalls_time[callstackline][0];
								shour[1]=gmissedcalls_time[callstackline][1];
								shour[2]=0;
								smin[0]=gmissedcalls_time[callstackline][2];
								smin[1]=gmissedcalls_time[callstackline][3];
								smin[2]=0;
								ssec[0]=gmissedcalls_time[callstackline][4];
								ssec[1]=gmissedcalls_time[callstackline][5];
								ssec[2]=0;
								bhour=atol(shour);
								bmin=atol(smin);
								bsec=atol(ssec);
		
								if(!gmissedcall_DateTime)       //no date/time available
								    bday=0xff;
								
							    requestarray[Offset]=bday;
								Offset++;
								requestarray[Offset]=bmonth;
								Offset++;
								requestarray[Offset]=byear;
								Offset++;
								requestarray[Offset]=bhour;
								Offset++;
								requestarray[Offset]=bmin;
								Offset++;
								requestarray[Offset]=bsec;
								Offset++;
							}
							leeloo++;
							callstackline=nextvalidcallstackline(callstackline, gmissedcalls_pbname, direction, gmissedcalls_TotalNumListElements);
						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                        
					break;
					case 1:	//PbName and NumberType only
						while(leeloo<elements)
						{
							if(callstackline==0xff)
							{
								write("FSG-Telephone dialednumbers_Request - invalid callstack-line");
								leeloo=elements;
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									if(indexsize)
									{
										requestarray[Offset]=gmissedcalls_pos[callstackline] & 0x00ff;
										requestarray[Offset+1]=(gmissedcalls_pos[callstackline] & 0xff00)/0x100;
										Offset=Offset+2;
									}
									else
									{
										requestarray[Offset]=gmissedcalls_pos[callstackline];
										Offset++;
									}
								}
							
								//PbName
								if(strncmp(gmissedcalls_pbname[callstackline], gunknown, CALL_INFO_NAME_LENGTH)==0)
								{
									length=1;
									requestarray[Offset]=length;
									Offset++;
									requestarray[Offset]=0x00;
									Offset++;
								}
								else
								{
									length=strlen(gmissedcalls_pbname[callstackline]);
									requestarray[Offset]=length;
									Offset++;
									for(i=0;i<length;i++)	//copy PbName in request buffer
									{
										requestarray[Offset]=gmissedcalls_pbname[callstackline][i];
										Offset++;
									}
								}

								//NumberType
								requestarray[Offset]=gmissedcalls_numbertype[callstackline];	
								Offset++;
							}
							leeloo++;
							callstackline=nextvalidcallstackline(callstackline, gmissedcalls_pbname, direction, gmissedcalls_TotalNumListElements);
						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
					break;
					case 2://TelNumber, Date and Time only
						while(leeloo<elements)
						{
							if(callstackline==0xff)
							{
								write("FSG-Telephone dialednumbers_Request - invalid callstack-line");
								leeloo=elements;
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									if(indexsize)
									{
										requestarray[Offset]=gmissedcalls_pos[callstackline] & 0x00ff;
										requestarray[Offset+1]=(gmissedcalls_pos[callstackline] & 0xff00)/0x100;
										Offset=Offset+2;
									}
									else
									{
										requestarray[Offset]=gmissedcalls_pos[callstackline];
										Offset++;
									}
								}
								
								//TelNumber
								length=strlen(gmissedcalls_telnumber[callstackline]);
								requestarray[Offset]=length;
								Offset++;
								for(i=0;i<length;i++)						//copy TelNumber in request buffer
								{
									requestarray[Offset]=gmissedcalls_telnumber[callstackline][i];
									Offset++;
								}

								//Date
								sday[0]=gmissedcalls_date[callstackline][0];
								sday[1]=gmissedcalls_date[callstackline][1];
								sday[2]=0;
								smonth[0]=gmissedcalls_date[callstackline][2];
								smonth[1]=gmissedcalls_date[callstackline][3];
								smonth[2]=0;
								syear[0]=gmissedcalls_date[callstackline][4];
								syear[1]=gmissedcalls_date[callstackline][5];
								syear[2]=0;
								bday=atol(sday);
								bmonth=atol(smonth);
								byear=atol(syear);

								//Time
								shour[0]=gmissedcalls_time[callstackline][0];
								shour[1]=gmissedcalls_time[callstackline][1];
								shour[2]=0;
								smin[0]=gmissedcalls_time[callstackline][2];
								smin[1]=gmissedcalls_time[callstackline][3];
								smin[2]=0;
								ssec[0]=gmissedcalls_time[callstackline][4];
								ssec[1]=gmissedcalls_time[callstackline][5];
								ssec[2]=0;
								bhour=atol(shour);
								bmin=atol(smin);
								bsec=atol(ssec);
		
								if(!gmissedcall_DateTime)       //no date/time
								    bday=0xff;
								
							    requestarray[Offset]=bday;
								Offset++;
								requestarray[Offset]=bmonth;
								Offset++;
								requestarray[Offset]=byear;
								Offset++;
								requestarray[Offset]=bhour;
								Offset++;
								requestarray[Offset]=bmin;
								Offset++;
								requestarray[Offset]=bsec;
								Offset++;
							}
							leeloo++;
							callstackline=nextvalidcallstackline(callstackline, gmissedcalls_pbname, direction, gmissedcalls_TotalNumListElements);
						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
					break;
					case 0x0f:	//Pos only
						while(leeloo<elements)
						{
							if(callstackline==0xff)
							{
								write("FSG-Telephone dialednumbers_Request - invalid callstack-line");
								leeloo=elements;
							}
							else
							{
								//transmit position
								if(indexsize)
								{
									requestarray[Offset]=gmissedcalls_pos[callstackline] & 0x00ff;
									requestarray[Offset+1]=(gmissedcalls_pos[callstackline] & 0xff00)/0x100;
									Offset=Offset+2;
								}
								else
								{
									requestarray[Offset]=gmissedcalls_pos[callstackline];
									Offset++;
								}
							}
							leeloo++;
							callstackline=nextvalidcallstackline(callstackline, gmissedcalls_pbname, direction, gmissedcalls_TotalNumListElements);
						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
					break;
					default:
						write("FSG-Telephone MissedCalls_Request: invalid recordaddress %d", recordaddress);
					break;
				}
			}
            }//end if for IssueList #62
		break;
		case Error_REQ:
			//BAP-header
			requestarray[0]=LSGID_Telephone;	//LSG-ID telephone
			requestarray[1]=FctID_MissedCalls;	//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:
			write("FSG-Telephone MissedCalls_Request: invalid request %d", request);
		break;
	}

}

byte nextvalidcallstackline (byte currentcallstackline, char significant_string [][], byte direction, byte totalnumlistelements)	//
{
byte nextcallstackline;	


//init lokal variables
	nextcallstackline=0;	
//********************

	if((currentcallstackline==(totalnumlistelements-1) && direction==0) || (currentcallstackline==0 && direction==1))	//last-/first-element of callstack-array reached
		nextcallstackline=0xFF;
	else{
		nextcallstackline=currentcallstackline+1-2*direction; 									//increment or decrement array-line (depend on direction);
		
        if(significant_string[nextcallstackline][0]==0)													//invalid array element
				nextcallstackline=0xFF;
        //write("nextline: %d", nextcallstackline);//debug
	}

	return(nextcallstackline);

}

word nextvalidphonebookline (word currentphonebookline, char significant_string [][], byte direction, byte totalnumlistelements)
{
byte nextphonebookline;	


//init lokal variables
	nextphonebookline=0;	
//********************
//write("totalnumlistelements = %d",totalnumlistelements);

	if((currentphonebookline==(totalnumlistelements-1) && direction==0) || (currentphonebookline==0 && direction==1))	//last-/fist-element of phonebook-array reached
		//nextphonebookline=0xFFFF;
        nextphonebookline=0xFF;
	else{
		nextphonebookline=currentphonebookline+1-2*direction; 										//increment or decrement array-line (depend on direction);

		//IssueList #125 - PBname = empty considered as valid element (needs to displayed)
        //if(significant_string[nextphonebookline][0]==0)												//invalid array element
				//nextphonebookline=0xFFFF;
	}

	return(nextphonebookline);
    
}

PbSpeller_Indication (dword Indication_array [], byte indication, int datalength)
{
int i, j,length, first_matching_entry;
char char0, next_char, previous_char, search_char;
byte tmpResult, next_char_c, previous_char_c, found_matching_char, curr_found_char;

//changes for IssueList #152 - MR 53938
//PHONEBOOK_ENTRIES --> gPhonebook_TotalNumListElements

	length=0;
    char0 = 0;
    next_char = 0;
    previous_char = 0;
    search_char = 0; 
    curr_found_char = 0;

	
	for(i = 0; i < CALL_INFO_NAME_LENGTH; i++)	//delete array for searchstring
		gSearchString[i] = 0;
	
	gSearchMode = Indication_array[3];
	length = Indication_array[4]; //stringlength of searchstring

	gMatchingEntries = 0;
	gFoundPos = 0;

	switch(indication)
	{
		case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_FSG_Tel_PbSpeller_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_PbSpeller_ErrorCode) > 0x3F)) && (gTelFctList_0x35_TimeOut_flg == 0x00))
			{
            PbSpeller_Request(Processing_REQ, 0);									//send Processing
		        
                //IssueList #68
                if (gTelFctList_0x35_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x35_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x35_ProcessingTimer,TELMAXPROCESSINGTIME);

                PbSpeller_Request(Processing_REQ, 0);
                }
            }
        break;
		case StartResult_IND:
             //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x35_TimeOut)!=TRUE)
            {
             gTelFctList_0x35_TimeOut_flg = 0x00;
                //IssueList #57
                if (getValue(env_FSG_Tel_PbSpeller_Error_On)==0x00)
                putValue(env_FSG_Tel_PbSpeller_ErrorCode,0);
                
                //IssueList #47
                if (getValue(env_FSG_Tel_PbSpeller_Error_On))
                    PbSpeller_Request(Error_REQ, getValue(env_FSG_Tel_PbSpeller_ErrorCode)); // send error-message

    			//check BAP-array
    			else if(datalength!=length+5)	//datalength error											
    				PbSpeller_Request(Error_REQ, Terror_unknownapllicationerror);		//send error-message
    			else
    			{
    				//IssueList #26
                    //if (getValue(env_FSG_PbSpeller_Result)!=SUCCESSFUL)
                        //{
                        //gPbSpeller_Result = getValue(env_FSG_PbSpeller_Result);
    					//PbSpeller_Request(Result_REQ, 0);
                        //}
               
                    //elseif (length == 0) // search string empty?
                    if (length == 0) // search string empty?
    				{	
                        gPbSpeller_Result = NOT_SUCCESSFUL;
    					PbSpeller_Request(Result_REQ, 0);
    				}
    				else
    				{
                    
    					for(i = 0; i < length; i++)											//read searchstring from indication array
    						gSearchString[i] = Indication_array[i+5];

    				    switch(gSearchMode)
                        {
                            case PbSpeller_MatchSpeller:

                                gPbSpeller_Result = 0; 

                                // search for matching entry
                                length = strlen(gSearchString);
                                first_matching_entry = -1;
                                gMatchingEntries = 0;
                                if(length != 0)
                                {
                                    i = 0;
                                    while(i < gPhonebook_TotalNumListElements)
                                    {                                      
                                        if(compare_strings(gSearchString, gPhonebook_PbName[i], length) == length)
                                        {
                                            //write("# ---> gSearchString: %s, gPhonebook_PbName[%d]: %s, length = %d", gSearchString, i, gPhonebook_PbName[i], length);
                                            gMatchingEntries++;
                                            if(first_matching_entry == -1)
                                                first_matching_entry = i; // first entry
                                        }
                                        i++;
                                    }                         
                                           
                                    gPbSpeller_Result = SUCCESSFUL;

                                    if(gMatchingEntries > 0) // matching entry found?
                                    {
                                        gFoundPos = gPhonebook_Pos[first_matching_entry];        
                                        //write("(FSG) PbSpeller_Request: found pos: %d, gMatchingEntries: %d", gFoundPos, gMatchingEntries);
                                    } 
                                    else
                                    {
                                        gFoundPos = 0;
                                        //write("(FSG) PbSpeller_Request: no matching entry found");
                                    }                                                                                           
                                } 
                                else
                                {
                                    gPbSpeller_Result = NOT_SUCCESSFUL; // no search string
                                    //write("(FSG) PbSpeller_Request: no matching entry found");
                                }
                                PbSpeller_Request(Result_REQ, 0);
                            break;
                            case PbSpeller_NextCharacter:
                                gPbSpeller_Result = 0;
                                length = strlen(gSearchString);
                                first_matching_entry = -1;
                                gMatchingEntries = 0;
                                gFoundPos = 0;
                                if(length != 0)
                                {                              
                                    tmpResult = SUCCESSFUL;

                                    // find next character
                                    char0 = gSearchString[0];
                                    //write("# --> char0 = %c", char0);
                                    if((char0 >= 0x41 && char0 < 0x5a) || (char0 >= 0x61 && char0 < 0x7a)) // A - Y || a - y
                                        next_char = char0 + 1;
                                    else if(char0 == 0x5a || char0 == 0x7a) // Z || z
                                        tmpResult = 0x05; //last character reached
                                    else // no letter
                                        tmpResult = NOT_SUCCESSFUL;
                                
                                    //write("# --> next_char = %c", next_char);                                    


                                    if(tmpResult == SUCCESSFUL)
                                    {
                                        // find first phonebook entry beginning with 'next_character'
                                        i = 0;

                                        next_char_c = (next_char >= 0x41 && next_char <= 0x5a) ? 1 : 0; // 'next_char' is capital letter ? 

                                        while(i < gPhonebook_TotalNumListElements)
                                        {
                                            search_char = gPhonebook_PbName[i][0]; 
                                        
                                            if
                                            (
                                                (
                                                    (search_char > 0x41 && search_char <= 0x5a) // 'search_char' is capital letter
                                                    && 
                                                    (
                                                        ((next_char_c == 1) && (search_char >= next_char))
                                                        ||
                                                        ((next_char_c == 0) && ((search_char + 0x20) >= next_char))
                                                    )
                                                )
                                                || 
                                                (
                                                    (search_char > 0x61 && search_char <= 0x7a) // 'search_char' is small letter
                                                    && 
                                                    (
                                                        ((next_char_c == 1) && ((search_char - 0x20) >= next_char)) 
                                                        || 
                                                        ((next_char_c == 0) && (search_char >= next_char))
                                                    )
                                                )
                                            )
                                            {
                                                // found matching entry
                                                gFoundPos = gPhonebook_Pos[i];
                                                gMatchingEntries = 1;
                                                //write("# --> found entry; pos: 0x%x", gPhonebook_Pos[i]);
                                                break;
                                            }
                                            i++;  
                                        }
                                    }

                                    gPbSpeller_Result = tmpResult;
                                } 
                                else
                                {
                                    gPbSpeller_Result = NOT_SUCCESSFUL; // no search string
                                }
                                PbSpeller_Request(Result_REQ, 0);
                            break;
                            case PbSpeller_PreviousCharacter:
                                //write("PbSpeller_PreviousCharacter");
                                gPbSpeller_Result = 0;
                                length = strlen(gSearchString);
                                first_matching_entry = -1;
                                gMatchingEntries = 0;
                                gFoundPos = 0;
                                if(length != 0)
                                {                              
                                    tmpResult = SUCCESSFUL;

                                    // find previous character
                                    char0 = gSearchString[0];
                                    //write("char0 = %c", char0);
                                    if((char0 > 0x41 && char0 <= 0x5a) || (char0 > 0x61 && char0 <= 0x7a)) // B - Z || b - z
                                        previous_char = char0 - 1;
                                    else if(char0 == 0x41 || char0 == 0x61) // A || a
                                        tmpResult = 0x04; // not successful - first character reached
                                    else // no letter
                                        tmpResult = NOT_SUCCESSFUL;
                                
                                    //write("previous_char = %c", previous_char);                                    


                                    if(tmpResult == SUCCESSFUL)
                                    {                              
                                        previous_char_c = (previous_char >= 0x41 && previous_char <= 0x5a) ? 1 : 0; // 'previous_char' is capital letter ? 

                                        i = 0;
                                        curr_found_char = 0;
                                        while(i < gPhonebook_TotalNumListElements)
                                        {
                                            search_char = gPhonebook_PbName[i][0]; 
                                        
                                            if
                                            (
                                                (
                                                    (
                                                        (search_char >= 0x41 && search_char <= 0x5a) // 'search_char' is capital letter
                                                        && 
                                                        (
                                                            ((previous_char_c == 1) && (search_char <= previous_char))
                                                            ||
                                                            ((previous_char_c == 0) && ((search_char + 0x20) <= previous_char))
                                                        )
                                                    )
                                                    || 
                                                    (
                                                        (search_char >= 0x61 && search_char <= 0x7a) // 'search_char' is small letter
                                                        && 
                                                        (
                                                            ((previous_char_c == 1) && ((search_char - 0x20) <= previous_char)) 
                                                            || 
                                                            ((previous_char_c == 0) && (search_char <= previous_char))
                                                        )
                                                    )
                                                )
                                                &&
                                                (
                                                    (curr_found_char == 0)
                                                    ||
                                                    (
                                                        (
                                                            (search_char >= 0x41 && search_char <= 0x5a) // 'search_char' is capital letter
                                                            && 
                                                            (search_char > curr_found_char)
                                                        )
                                                        || 
                                                        (
                                                            (search_char >= 0x61 && search_char <= 0x7a) // 'search_char' is small letter
                                                            && 
                                                            ((search_char - 0x20) > curr_found_char)
                                                        )
                                                    )
                                                )
                                            )
                                            {
                                                curr_found_char = (search_char >= 0x41 && search_char <= 0x5a) ? search_char : (search_char - 0x20);
                                            
                                                gFoundPos = gPhonebook_Pos[i];
                                                gMatchingEntries = 1;
                                                //write("# --> found entry; pos: 0x%x", gPhonebook_Pos[i]);                                            
                                            }

                                            if(search_char == char0)
                                                    break;
                                            i++;  
                                        }

                                    }

                                    gPbSpeller_Result = tmpResult;
                                } 
                                else
                                {
                                    gPbSpeller_Result = NOT_SUCCESSFUL; // no search string
                                }
                                PbSpeller_Request(Result_REQ, 0);
                            break;
                            default:
                            break;
                        }
    				}
    			}
            } //IssueList #74
            else
            gTelFctList_0x35_TimeOut_flg = 0x01;

		break;
		default:
			write("FSG-Telephone PbSpeller_Indication: invalid indication: %d", indication);
		break;
	}
//IssueList #26
//putValue(env_FSG_PbSpeller_Mode, gSearchMode);
//putValue(env_FSG_PbSpeller_SearchString, gSearchString);
//putValue(env_FSG_PbSpeller_Matching, gMatchingEntries);
//putValue(env_FSG_PbSpeller_Pos, gFoundPos);
 

}

PbSpeller_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size], length;

//*********
    //write("# (FSG) PbSpeller_Request"); // debug
//*********

//init lokal variables
	Offset=0;
	length=0;
	
	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;

	switch (request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_PbSpeller;	//Fct.-ID
			requestarray[2]=request;			
			requestarray[3]=0;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
		break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x35_Processing_flg == 0x00)
            {
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_PbSpeller;	//Fct.-ID
			requestarray[2]=request;			
            requestarray[3] = gPbSpeller_Result;
            requestarray[4] = gMatchingEntries & 0xff;
            //changes from Jöran Karl (28.03.2012)
	        requestarray[5] = (gMatchingEntries >> 8) & 0xff;
            requestarray[6] = gFoundPos & 0xff;
			//changes from Jöran Karl (28.03.2012)
			requestarray[7] = (gFoundPos >> 8) & 0xff;
			Offset=8;
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }

		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_PbSpeller;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x35_ProcessingTimer);
		break;
		default:
			write("FSG-Telephone PbSpeller_Request: invalid request: %d", request);
		break;
	}

}

PbStartDownload_Indication(dword Indication_array [], byte indication, int datalength)
{
	switch(indication){
		case Processing_CNF:
			PbStartDownload_Request(Processing_REQ, 0);										//send Processing
		break;
		case StartResult_IND:
			if(gPbStartDownload_status!=0)
				PbStartDownload_Request(Error_REQ, Terror_unknownapllicationerror);			//send error-message to RNS
			else if(datalength!=3)															//datalength error
				PbStartDownload_Request(Error_REQ, Terror_unknownapllicationerror);			//send error-message to RNS
			else if(gDownLoadState==CURRENTLY_BEING_LOADED)										//datalength error
				PbStartDownload_Request(Error_REQ, Terror_phonebookdownloadinprogress);		//send error-message to RNS
			else if(ActiveUserValidation()!=1)												//no active User
				PbStartDownload_Request(Error_REQ, Terror_nouseractive);					//send error-message to RNS
			else{
				gPbStartDownload_status=1;													//method PbStartDownload active
				settimer(PbStartDownload_timer, 1000);
			}
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone PbStartDownload_Indication: unknown indication %d", indication);
		break;
	}
}

PbStartDownload_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Phonebook;		//LSG-ID
			requestarray[1]=FctID_PbStartDownload;	//Fct.-ID
			requestarray[2]=request;
			Offset=3;
			set_status_requestbuffer (requestarray, Offset, Bap_Void);
		break;
		case Result_REQ:
			requestarray[0]=LSGID_Phonebook;		//LSG-ID
			requestarray[1]=FctID_PbStartDownload;	//Fct.-ID
			requestarray[2]=request;
			Offset=3;
			set_status_requestbuffer (requestarray, Offset, Bap_Void);
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Phonebook;		//LSG-ID
			requestarray[1]=FctID_PbStartDownload;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone PbStartDownload_Request: unknown request %d",request );
		break;
	}
}

PbState_Indication (dword Indication_array [], byte indication, int datalength)
{

int missedcalls, missednumbers;

//init lokal variables
	missedcalls=0;
	missednumbers=0;
//********************
	
	
	switch(indication){
		case DataGet_IND:
			//check BAP-array
			if(datalength!=3)											//datalength error
				PbState_Request(Error_REQ, Terror_unknownapllicationerror);//send error-message to RNS
			else
				PbState_Request(Data_REQ, 0);							//send data to RNS
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "Phonebook PbState_Indication: invalid indication %d", indication);
		break;
	}		
}

PbState_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************
	
	switch(request){
		case Data_REQ:
             //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x33_TimeOut)!=TRUE)
            {
    			requestarray[0]=LSGID_Telephone;				//LSG-ID phonebook
    			requestarray[1]=FctID_PbState;					//Fct.-ID
    			requestarray[2]=request;	
	
    			requestarray[3]=gDownLoadState;					
    			requestarray[4]=gPbEntriesUHV & 0x00ff;			//Lowbyte of PbEntriesUHV
    			requestarray[5]=(gPbEntriesUHV & 0xff00)/0x100;	//Highbyte of PBEntriesUHV
			
    			Offset=6;		
    			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;				//LSG-ID phonebook
			requestarray[1]=FctID_PbState;					//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone PbState_Request: invalid request %d", request);
		break;
	}

	

}

phonebook_functions (char functionID, int datalength)	
{

	switch (functionID){
		case FctID_MissedCalls:
			//MissedCalls_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_ReceivedCalls:
			//receivedcalls_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_DialedNumbers:
			//dialednumbers_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_CallStackDeleteAll:
			CallStackDeleteAll_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_Phonebook:
			Phonebook_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		case FctID_PbSpeller:
			PbSpeller_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		break;
		case FctID_PbStartDownload:
			PbStartDownload_Indication(gBAP_Indication, gBAP_Indication [2], datalength);
		break;
		default:
			write("FSG-Telephone phonebook_functions: invalid funcion-ID %d", functionID);
		break;
	}	

}

Phonebook_Indication (dword Indication_array [], byte indication, int datalength)
{

int i; 
word valid_startelement, startelement, elements, valid_elements, requested_startelement, delete_ID, datapointer;
byte mode, recordaddress, shift, direction, transmitpos, indexsize, temp;

//IssueList #76 - MR49870 : Phonebook
int j =0;
byte telephoneListDelFlg;
word validStartElem_plusElem;

//changes for IssueList #152 - MR 53938
//PHONEBOOK_ENTRIES --> gPhonebook_TotalNumListElements

//IssueList #193
byte pb_InValidStartElemFlg;

//init lokal variables
	startelement=0;
	elements=0;
	valid_startelement=0xff;
	valid_elements=0;
	requested_startelement=0;
	delete_ID=0;
	datapointer=0;
	mode=0;
	recordaddress=0;
	shift=0;
	direction=0;
	transmitpos=0;
	indexsize=0;
    temp=0;
//********************
//IssueList #76 - MR49870 : Phonebook
    validStartElem_plusElem = 0;
	
    gPhonebook_ASG_ID=(Indication_array[3] & 0xF0)/0x10;
    gPhonebook_TAID=Indication_array[3] & 0x0F;

	mode=Indication_array[4];
	recordaddress=mode & 0x0F;
	shift=(mode & 0x10)/0x10;
	direction=(mode & 0x20)/0x20;
	transmitpos=(mode & 0x40)/0x40;
	indexsize=(mode & 0x80)/0x80;


	if(indexsize)
    {
		startelement=Indication_array[5]+Indication_array[6]*256;
		elements=Indication_array[7]+Indication_array[8]*256;
		datapointer=9;
	}
	else
    {
		startelement=Indication_array[5];
        //IssueList #148
        //if (getValue(env_FSG_Phonebook_TotalNumLE)<4)
         // elements = getValue(env_FSG_Phonebook_TotalNumLE);
        //else

		elements=Indication_array[6];
		datapointer=7;
	}

	requested_startelement=startelement;

	//temp=checkcallstackarray(Indication_array, datalength);
    //write("FSG-Telephone Phonebook_Indication - checkcallstackarray: %d",temp);
	
	if(temp==0xff)																		//check array-datalength/format
	{
		//MR 63667 11.07.2014 -TNLE with SA-button
        //Phonebook_Request(Error_REQ, 0, 0, 0, 0, Terror_unknownapllicationerror);
        Phonebook_Request(Error_REQ, 0, 0, 0, 0, 0, Terror_unknownapllicationerror);
	}
	else
	{
		switch(indication)
		{
			case DataGet_IND:
            //MR 63336	02.07.2014
    	    if(getvalue(env_FSG_Phonebook_Timeout) == TRUE)
            {
            /* NOP */
            }
	    //VAGH-10511
    	    else if(getvalue(env_FSG_Phonebook_Error_on) == TRUE)
            {
                Phonebook_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue(env_FSG_Phonebook_ErrorCode));
            }
	    else
	    {
	    
				//check startelement of request for special cases
                if(startelement==0 && direction==FORWARD)                          //begin at first element in list
                {
                    //xxx
                    //valid_startelement=startelement;
                    valid_startelement =0;

                    //IssueList #152 - MR53938
                    if(elements>=gPhonebook_TotalNumListElements)        //to much elements requested
                    {
                        for(i=valid_startelement;i<gPhonebook_TotalNumListElements;i++)
                        {    
                            //IssueList #125 - PBname = empty considered as valid element (needs to displayed)
                            //if(gPhonebook_PbName[i][0]!=0)            //element is valid
                                valid_elements++;
                            //else                                        //element is not valid
                                //i=gPB_CSVtotalElem;                                //break loop
                        }
                    }
                    else        //elements =< gPhonebook_TotalNumListElements
                    {
                        for(i=valid_startelement;i<(elements+valid_startelement);i++)
                        {
                            //IssueList #125 - PBname = empty considered as valid element (needs to displayed)
                            //if(gPhonebook_PbName[i][0]!=0)            //element is valid
                                valid_elements++;
                            //else                                        //element is not valid
                              //  i=gPhonebook_TotalNumListElements;                                //break loop
                        }
                    }
                }
                else if(startelement==0 && direction==BACKWARD && shift==TRUE)     //begin at last element in list
				{
                    //searching for valid startelement
                    for(i=(gPB_CSVtotalElem-1);i>=0;i--)
					{
						//if(gPhonebook_PbName[i][0]!=0)		//found valid startelement
						//{
							valid_startelement =i;								
							i =0;		                        //break loop										
						//}
					}
                        
                    //searching for valid elements
					if(valid_startelement==0xff)					//no valid element found 
					{
						valid_startelement  =startelement;
						valid_elements      =0;
					}                                       
						
					else if(elements>(valid_startelement+1))		//not enougth array elements available, because no wrap around
					{
						for(i=valid_startelement;i>=0;i--)
						{
							//if(gPhonebook_PbName[i][0]!=0)    	//if there is an valid element
                                valid_elements++;
			
							//else									//no valid element, 
								//i=0;                                //loop finished
						}
					}
                    else											//enough array elements available
					{
						for(i=valid_startelement;i>=((valid_startelement+1)-elements);i--)
						{
							//if(gPhonebook_PbName[i][0]!=0)	    //if there is an valid element
                                valid_elements++;
	
							//else									//no valid element
								//i=0;                                //loop finished
						}              
					}
                }

				//************requested startelement !=0******************
				else
                {
					//IssueList #193 - start
					pb_InValidStartElemFlg = 0;
	                for(i=0;i<gPB_CSVtotalElem;i++)
					{
                        if (startelement==gPhonebook_Pos_insDel[i][0])
                        {
                            //check if Start is deleted then reply with 0 elements
                            if( gPhonebook_Pos_insDel[i][1]==0x01)
                            {
                            valid_startelement  =startelement;
    						valid_elements      =0;
                            pb_InValidStartElemFlg = 1;
                            }
                        }
                    }
					//IssueList #193 - end

                    //IssueList #193 - if condition
					if (pb_InValidStartElemFlg == 0x00)
					{
                        //searching for valid startelement
    					for(i=0;i<gPB_CSVtotalElem;i++)
    					{
    						if(gPhonebook_Pos[i]==startelement)					    //requested start element found
    						{   
                                if(i==0)        //first element
                                {
                                    if(direction==BACKWARD) 
                                        valid_startelement =0xff;                       //invalid element
                                    else if(direction==FORWARD)
                                        valid_startelement = 0 + shift;                         //valid element is first element in Array
                                }                                       
                                else    //i!=0
                                {
                                    if(shift==TRUE)											//shift is set, this means starting with the next/previous element (depending on the direction-setting)
    						            valid_startelement =i+1-2*direction;            //includes shift & direction
                                    else //shift==FALSE
                                        valid_startelement =i;                              //found element is valid_startelement
    			                 }

    							i=gPB_CSVtotalElem;        //break loop
    						}
    					}

    					if(valid_startelement==0xff)										//Startelement-ID doesn't exist in array
    					{
    						valid_startelement  =startelement;
    						valid_elements      =0;
    					}
    					else																//found valid entry for startelement in array
    					{
    						//verify number of valid elements
    						if(direction==BACKWARD)											//BACKWARD
    						{
    							if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
    							{	
                                        //IssueList #76 - MR49870 : Phonebook
                                       telephoneListDelFlg = 0x00;
                                       telephoneListDelFlg = telephoneList_deleteCheck(gPhonebook_Pos[0],gPhonebook_Pos_insDel,gPB_CSVtotalElem );

                                       if (telephoneListDelFlg == 0x00)
                                        valid_elements=1;
                                 }
    							else if(elements>(valid_startelement+1))					//not enough array elements available, because array ends at array-position 0
    							{
    								for(i=valid_startelement;i>=0;i--)
    								{
    									//IssueList #125 - PBname = empty considered as valid element (needs to displayed)
                                        //if(gPhonebook_PbName[i][0]!=0)                	//if there is an valid element
    										valid_elements++;								//increment elements
    									//else												//no valid element
    										//i=0;                                            //loop finished
    								}
    							}
    							else														//enough array-elements available
    							{
    								for(i=valid_startelement;i>=((valid_startelement+1)-elements);i--)
    								{
    									//IssueList #125 - PBname = empty considered as valid element (needs to displayed)
                                        //if(gPhonebook_PbName[i][0]!=0)                	//if there is an valid element
    										valid_elements++;								//increment elements
    									//else												//no valid element
    									//	i=0;                                            //loop finished
    								}
    							}
    						}
                        											
    						else		//FORWARD
    						{   
    							//IssueList #76 - MR49870 : gPhonebook
                                if((valid_startelement+elements)>=gPhonebook_TotalNumListElements)            //to much elements requested
                                {
                                    for(i=valid_startelement;i<gPB_CSVtotalElem;i++)
    								{
    								    //IssueList #125 - PBname = empty considered as valid element (needs to displayed)
                                        //if(gPhonebook_PbName[i][0]!=0)							//if there is an valid element
										
                                            //IssueList #76 - MR49870 : ReceptionList
                                            telephoneListDelFlg = 0x00;
                                            telephoneListDelFlg = telephoneList_deleteCheck(gPhonebook_Pos[i], gPhonebook_Pos_insDel, gPB_CSVtotalElem );
                                        
                                            if (telephoneListDelFlg == 0x00 && valid_elements < elements)
                                            valid_elements++;								//increment elements
    									//else												//no valid element
    									//	i=gPhonebook_TotalNumListElements;                                    //loop finished
    								}
    							}
    							else            //enough elemtents available
    							{
    								    //IssueList #76 - MR49870 : Phonebook
                                        validStartElem_plusElem =valid_startelement+elements;
    								    //for(i=valid_startelement;i<(valid_startelement+elements);i++)
                                        for(i=valid_startelement;i<validStartElem_plusElem;i++)
    								{
    									//IssueList #125 - PBname = empty considered as valid element (needs to displayed)
                                        //if(gPhonebook_PbName[i][0]!=0)							//if there is an valid element
										
                                             //IssueList #76 - MR49870 : Phonebook
                                            telephoneListDelFlg = 0x00;
                                            telephoneListDelFlg = telephoneList_deleteCheck(gPhonebook_Pos[i], gPhonebook_Pos_insDel, gPB_CSVtotalElem );
                                        
                                            if (telephoneListDelFlg == 0x00)
                                            {
                                                if (valid_elements < elements)      //guard check if valid elements < elements
                                                   valid_elements++;								//increment elements
    									    }
                                         //else												//no valid element
    									//	i=gPhonebook_TotalNumListElements;
                                             else
                                                 {
                                                    if (valid_elements < elements)
                                                    validStartElem_plusElem++;      //adjust the loop boundary based on number of deleted elements
                                                 }
    								}
    							}
    						}
    					}
                    }//pb_InValidStartElemFlg
				} //else Startelement!=0

				mode=recordaddress+shift*0x10+direction*0x20+transmitpos*0x40+indexsize*0x80;
				//********************
			//	write("FSG-Telephone Phonebook_Indication: valid-start: %d, valid_elements: %d, indexsize: %d",valid_startelement, valid_elements, (mode & 0x01));
		//VAGH-10511		
                if((gPhonebook_AutoOnOff) && !getvalue(env_FSG_Phonebook_StatusArrayOff))   //Automatic response active
                    //MR 63667 11.07.2014 -TNLE with SA-button
                    //Phonebook_Request(Data_REQ, requested_startelement, valid_startelement, valid_elements, mode, 0);
                    Phonebook_Request(Data_REQ, gPhonebook_TotalNumListElements, requested_startelement, valid_startelement, valid_elements, mode, 0);
			}//env_FSG_Phonebook_Timeout	
			break;
			default:
                //MR 63667 11.07.2014 -TNLE with SA-button
				//Phonebook_Request(Error_REQ, 0, 0, 0, 0, Terror_unknownapllicationerror);
                Phonebook_Request(Error_REQ, 0, 0, 0, 0, 0, Terror_unknownapllicationerror);
				write("FSG-Telephone Phonebook_Indication: invalid indication %d", indication);
			break;
		}
	}
}

Phonebook_Request (byte request, word tnle, word requested_startelement, word startelement, word elements, byte mode, byte errorcode)
{
//changes from Jöran Karl (28.03.2012)
int i,j;
word phonebookline, leeloo, Offset, length, datapointer;
byte shift, indexsize, transmitpos, direction, recordaddress;	
dword requestarray [BAP_buffer_size];

 //IssueList #76 - MR49870 : Phonebook
byte telephoneListDelFlg;

//changes for IssueList #152 - MR 53938
//PHONEBOOK_ENTRIES --> gPhonebook_TotalNumListElements--> gPB_CSVtotalElem

//init lokal variables
	Offset=0;
	length=0;
	phonebookline=0;
	leeloo=0;
	datapointer=0;
    shift=0;
	indexsize=0;
	transmitpos=0;
	direction=0;
	recordaddress=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
	
//********************

	shift=(mode & 0x10)/0x10;
	direction=(mode & 0x20)/0x20;
	transmitpos=(mode & 0x40)/0x40;
    indexsize=(mode & 0x80)/0x80;
	recordaddress=mode & 0x0f;
	//write("FSG-Telephone: Phonebook_Request: direction:%d, indexsize: %d, recordaddress: %d", direction, indexsize, recordaddress);	

	switch (request)
	{
		case Changed_REQ:
			//BAP-header
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_Phonebook;	//Fct.-ID
			requestarray[2]=request;	
			
			//extended array header
			requestarray[3]=mode;	//Mode+RecordAdress
			if(indexsize)       //16-bit
			{
				requestarray[4]=requested_startelement & 0x00ff;
				requestarray[5]=(requested_startelement & 0xff00)/0x100;
				requestarray[6]=elements & 0x00ff;
				requestarray[7]=(elements & 0xff00)/0x100;
				Offset=8;
			}
			else                //8bit
			{
				requestarray[4]=requested_startelement;
				requestarray[5]=elements;
				Offset=6;
			}

            //check, if startelement in array   
            if(requested_startelement !=0)      //startelement is not first element
            {
                for(i=0;i<gPB_CSVtotalElem;i++)
                {
                    if(gPhonebook_Pos[i] ==requested_startelement)
                    {
                        phonebookline =i;    
                        i=gPB_CSVtotalElem;        //stop loop
                    }
                    else
                        phonebookline =0xff;    //invalid
                }
            }
            else        //startelement is first element
                phonebookline =0;

            //copy data
            while(leeloo <elements)
            {
                if(phonebookline ==0xff) //Invalid list entry
                {
                    //write("FSG Phonebook_Request: invalid phonebookline");  //debug
                    break;  //leeloo =elements;       //stop loop
                }
                else //list entry valid
                {   
                    /***Array Data***/
                    if (transmitpos) // Pos  ->Array position transmitted
                    {
                        requestarray[Offset] =gPhonebook_Pos[phonebookline];
                        Offset++;
                    }                                                                       
                }
                leeloo++;
                phonebookline =nextvalidphonebookline(phonebookline, gPhonebook_PbName, direction, gPB_CSVtotalElem);               
            }//end while
            
            //if(phonebookline!=0xff)     //only if phonebook is valid, send request
			    set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);			
		break;

		case Data_REQ:

            //changes from Jöran Karl (28.03.2012)
            //MR 63336	02.07.2014
	        //if(getvalue(env_FSG_Phonebook_Timeout) != TRUE)
            if(/*getvalue(env_FSG_Phonebook_Timeout) != */ TRUE)
            {
	        //VAGH-10511
                ASGID = getvalue(env_FSG_Phonebook_ASG_ID);;
                TAID = gPhonebook_TAID;
                if(getvalue(env_FSG_Phonebook_ASGID_error) != FALSE)
                {
                    ASGID += 0x2;
                }
                if(getvalue(env_FSG_Phonebook_TAID_error) != FALSE)
                {
                    TAID += 0x02;
                }

                transmitpos=1;      //arbitrary lists -> always send transmitpos
                mode=shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;//update mode
                mode=recordaddress + (mode*0x10);

			if(gPhonebook_DeleteStatus==TRUE)			//array-element was deleted
			{
				gPhonebook_DeleteStatus=FALSE;

				//BAP-header
				requestarray[0]=LSGID_Telephone;	//LSG-ID
				requestarray[1]=FctID_Phonebook;	//Fct.-ID
				requestarray[2]=request;

                //ASG_ID & TAID
                requestarray[3]=(ASGID*0x10)+TAID;//upper and lower nibble

                //Total number of list elements
                requestarray[4]=gPhonebook_TotalNumListElements & 0x00ff;
                requestarray[5]=(gPhonebook_TotalNumListElements & 0xff00)/0x100;

				//extended array header
				requestarray[6]=mode;				//Mode

				if(indexsize)
				{
					requestarray[7]=requested_startelement & 0x00ff;
					requestarray[8]=(requested_startelement & 0xff00)/0x100;
					requestarray[9]=elements & 0x00ff;
					requestarray[10]=(elements & 0xff00)/0x100;
					Offset=11;
				}
				else
				{
					requestarray[7]=requested_startelement;
					requestarray[8]=elements;
					Offset=9;
				}

				//PbName
				requestarray[Offset]=0;
				Offset++;
				//NumberType
				requestarray[Offset]=0;
				Offset++;				

				set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

			}
			else	//no element was deleted, normal Status-array Request
			{
				//BAP-header
				requestarray[0]=LSGID_Telephone;	//LSG-ID telephone
				requestarray[1]=FctID_Phonebook;	//Fct.-ID
				requestarray[2]=request;

				//ASG_ID & TAID
                requestarray[3]=(ASGID*0x10)+TAID;//upper and lower nibble

                //Total number of list elements
                requestarray[4]=gPhonebook_TotalNumListElements & 0x00ff;
                requestarray[5]=(gPhonebook_TotalNumListElements & 0xff00)/0x100;

				//extended array header
				requestarray[6]=mode;				//Mode
				if(indexsize)
				{
					requestarray[7]=requested_startelement & 0x00ff;
					requestarray[8]=(requested_startelement & 0xff00)/0x100;
					requestarray[9]=elements & 0x00ff;
					requestarray[10]=(elements & 0xff00)/0x100;
					Offset=11;
				}
				else
				{
					requestarray[7]=requested_startelement;
					requestarray[8]=elements;
					Offset=9;
				}

				phonebookline=startelement;

				switch(recordaddress)
				{
					case 0:	//complete record

                        while(leeloo<elements)
						{
							if(phonebookline==0xff)
							{
								//write("FSG-Telephone: Phonebook_Request - invalid phonebook-line");
								leeloo=elements;    //break loop
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									
                                 //IssueList #76 - MR49870 : Phonebook
                                  //Updating the status array excluding the deleted elements
                                  telephoneListDelFlg = 0x00;
                                  telephoneListDelFlg = telephoneList_deleteCheck(gPhonebook_Pos[phonebookline],gPhonebook_Pos_insDel,gPB_CSVtotalElem);
                                            
                                  if (telephoneListDelFlg == 0x00)
                                  {
                                        if(indexsize)
    									{
    										requestarray[Offset]=gPhonebook_Pos[phonebookline] & 0x00ff;
    										requestarray[Offset+1]=(gPhonebook_Pos[phonebookline] & 0xff00)/0x100;
    										Offset=Offset+2;
    									}
    									else
    									{
    										requestarray[Offset]=gPhonebook_Pos[phonebookline];
    										Offset++;
    									}
                                   } //if telephoneListDelFlg
								}								
                                
                                //IssueList #76 - MR49870 : Phonebook
								if (telephoneListDelFlg == 0x00)
                                {
                                    //PbName
    								if(strncmp(gPhonebook_PbName[phonebookline], gunknown, PHONEBOOK_PBNAME_LENGTH)==0) //PbName is "unknown"
    								{
    									length=1;
    									requestarray[Offset]=length;
    									Offset++;
    									requestarray[Offset]=0x00;
    									Offset++;
    								}
    								else    //PbName is known
    								{
    									length=strlen(gPhonebook_PbName[phonebookline]);
    									requestarray[Offset]=length;
    									Offset++;
    									for(i=0;i<length;i++)	//copy PbName in request buffer
    									{
    										requestarray[Offset]=gPhonebook_PbName[phonebookline][i];
    										Offset++;
    									}
                                        //IssueList #20
                                        for(i = 0; i < DIAL_NUMBER_NAME_LENGTH; i++)	//delete all call info strings
    			                        gDialNumber_name2[i]=0;
                                        strncpy(gDialNumber_name2, gPhonebook_PbName[phonebookline],strlen(gPhonebook_PbName[phonebookline])+1);
                                   
                                    }

    								//Storage
    								requestarray[Offset]=gPhonebook_Storage[phonebookline];	
    								Offset++;

                                    //AnyVoiceTag = upper nibble + TelNumberQuantity = lower nibble
                                    requestarray[Offset]= (gPhonebook_AnyVoiceTag[phonebookline] & 0x02)*0x10 + (gPhonebook_TelNumberQuantity[phonebookline] & 0x0F);
                                    Offset++;
								
            						//changes from Jöran Karl (28.03.2012)
    								//********TelNumber1-10 with VoiceTag an NumberType, depending on TelNumberQuantity****

                                          //IssueList #20
                                        gPhonebookRequestActive = 0x01;
                                        for(i = 0; i < gPhonebook_TelNumberQuantity[phonebookline]; i++)	//delete all call info strings
    			                        gDialNumber_PhoneBook_Category[i]=0;

                                        for(j=0;j<gPhonebook_TelNumberQuantity[phonebookline];j++) {
            								//*********TelNumber n********
            								length=strlen(gPhonebook_TelNumbers[j][phonebookline]);
            								requestarray[Offset]=length;
            								Offset++;

                                            for(i=0;i<length;i++)
            								{
            									requestarray[Offset]=gPhonebook_TelNumbers[j][phonebookline][i];
                                                Offset++;
            								}
                                       
                                            //VoiceTag = upper nibble + Reserve = lower nibble of TelNumber n
            								requestarray[Offset]=gPhonebook_VoiceTags[j][phonebookline]*0x10;	
            								Offset++;
                                            //NumberType n
                                            requestarray[Offset]=gPhonebook_NumberTypes[j][phonebookline];
                                            Offset++;
                                            //IssueList #20
                                            gDialNumber_PhoneBook_Category[j]=gPhonebook_NumberTypes[j][phonebookline];
                                     
                                        
            								//***************************                                    
            							}
                                        gPhonebook_TelNum_index = phonebookline;
            							//*********TelNumbers1-10 finished*******************************************

                                    //AddressIndication
                                    requestarray[Offset]=gPhonebook_AddressIndication[phonebookline];
                                    Offset++;
                                }// telephoneListDelFlg
							}
                             //IssueList #76 - MR49870 : Phonebook
							if (telephoneListDelFlg == 0x00)
							leeloo++;

							phonebookline=nextvalidphonebookline(phonebookline, gPhonebook_PbName, direction, gPB_CSVtotalElem);
						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

					break;

					case 1:	//PbName,Storage,AnyVoiceTag,TelNumberQuantity,AddressIndication
						while(leeloo<elements)
						{
                            if(phonebookline==0xff)
							{
								write("FSG-Telephone: Phonebook_Request - invalid phonebook-line");
								leeloo=elements;    //break loop
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									//IssueList #76 - MR49870 : Phonebook
                                  //Updating the status array excluding the deleted elements
                                  telephoneListDelFlg = 0x00;
                                  telephoneListDelFlg = telephoneList_deleteCheck(gPhonebook_Pos[phonebookline],gPhonebook_Pos_insDel,gPB_CSVtotalElem);
                                            
                                  if (telephoneListDelFlg == 0x00)
                                  {
                                        if(indexsize)
    									{
    										requestarray[Offset]=gPhonebook_Pos[phonebookline] & 0x00ff;
    										requestarray[Offset+1]=(gPhonebook_Pos[phonebookline] & 0xff00)/0x100;
    										Offset=Offset+2;
    									}
    									else
    									{
    										requestarray[Offset]=gPhonebook_Pos[phonebookline];
    										Offset++;
    									}
                                    }
								}								

								if (telephoneListDelFlg == 0x00)
                                {
                                    //PbName
    								//if(strncmp(gPhonebook_PbName[phonebookline], gunknown, PHONEBOOK_PBNAME_LENGTH)==0) //PbName is "unknown"
                                    if(strncmp(gPhonebook_PbName[phonebookline], gempty_string, PHONEBOOK_PBNAME_LENGTH)==0) //PbName is "unknown"
    								{
									
                                        length=1;
    									requestarray[Offset]=length;
    									Offset++;
    									requestarray[Offset]=0x00;
    									Offset++;
    								}
    								else    //PbName is known
    								{
    									length=strlen(gPhonebook_PbName[phonebookline]);
    									requestarray[Offset]=length;
    									Offset++;
    									for(i=0;i<length;i++)	//copy PbName in request buffer
    									{
    										requestarray[Offset]=gPhonebook_PbName[phonebookline][i];
                                            Offset++;
    									}
                                   
    								}

    								//Storage
    								requestarray[Offset]=gPhonebook_Storage[phonebookline];	
    								Offset++;

                                    //AnyVoiceTag = upper nibble + TelNumberQuantity = lower nibble
                                    requestarray[Offset]= (gPhonebook_AnyVoiceTag[phonebookline] & 0x02)*0x10 + (gPhonebook_TelNumberQuantity[phonebookline] & 0x0F);
                                    Offset++;

                                    //AddressIndication
                                    requestarray[Offset]=gPhonebook_AddressIndication[phonebookline];
                                    Offset++;
                                }   //telephoneListDelFlg
							}
							
                            if (telephoneListDelFlg == 0x00)
                            leeloo++;
							
                            phonebookline=nextvalidphonebookline(phonebookline, gPhonebook_PbName, direction, gPB_CSVtotalElem);
						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

					break;
					case 2://TelNumber(n),VoiceTag(n),Reserve(n),NumberType(n)

                        while(leeloo<elements)
						{
							if(phonebookline==0xff)
							{
								write("FSG-Telephone: Phonebook_Request - invalid phonebook-line");
								leeloo=elements;    //break loop
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									if(indexsize)
									{
										requestarray[Offset]=gPhonebook_Pos[phonebookline] & 0x00ff;
										requestarray[Offset+1]=(gPhonebook_Pos[phonebookline] & 0xff00)/0x100;
										Offset=Offset+2;
									}
									else
									{
										requestarray[Offset]=gPhonebook_Pos[phonebookline];
										Offset++;
									}
								}								

        							//changes from Jöran Karl (28.03.2012)
								//********TelNumber1-10 with VoiceTag an NumberType, depending on TelNumberQuantity****
        							for(j=0;j<gPhonebook_TelNumberQuantity[phonebookline];j++)
        							{
        								//*********TelNumber1********
        								length=strlen(gPhonebook_TelNumbers[j][phonebookline]);
        								requestarray[Offset]=length;
        								Offset++;

                                        for(i=0;i<length;i++)
        								{
        									requestarray[Offset]=gPhonebook_TelNumbers[j][phonebookline][i];
                                           	Offset++;
        								}
                                         
        								//VoiceTag = upper nibble + Reserve = lower nibble of TelNumber1
        								requestarray[Offset]=gPhonebook_VoiceTags[j][phonebookline]*0x10;	
        								Offset++;
                                        //NumberType
                                        requestarray[Offset]=gPhonebook_NumberTypes[j][phonebookline];
                                       Offset++;
        								//***************************
                                    }
    							}
    							leeloo++;
    							phonebookline=nextvalidphonebookline(phonebookline, gPhonebook_PbName, direction, gPB_CSVtotalElem);
    						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

					break;
                    case 3://PbName,AnyVoiceTag,TelNumberQuantity,VoiceTag(n),Reserve(n),Numbertype(n)

                        while(leeloo<elements)
						{
							if(phonebookline==0xff)
							{
								write("FSG-Telephone: Phonebook_Request - invalid phonebook-line");
								leeloo=elements;    //break loop
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									if(indexsize)
									{
										requestarray[Offset]=gPhonebook_Pos[phonebookline] & 0x00ff;
										requestarray[Offset+1]=(gPhonebook_Pos[phonebookline] & 0xff00)/0x100;
										Offset=Offset+2;
									}
									else
									{
										requestarray[Offset]=gPhonebook_Pos[phonebookline];
										Offset++;
									}
								}								

								//PbName
								if(strncmp(gPhonebook_PbName[phonebookline], gunknown, PHONEBOOK_PBNAME_LENGTH)==0) //PbName is "unknown"
								{
									length=1;
									requestarray[Offset]=length;
									Offset++;
									requestarray[Offset]=0x00;
									Offset++;
								}
								else    //PbName is known
								{
									length=strlen(gPhonebook_PbName[phonebookline]);
									requestarray[Offset]=length;
									Offset++;
									for(i=0;i<length;i++)	//copy PbName in request buffer
									{
										requestarray[Offset]=gPhonebook_PbName[phonebookline][i];
										Offset++;
									}
                                   
								}

                                //AnyVoiceTag = upper nibble + TelNumberQuantity = lower nibble
                                requestarray[Offset]= (gPhonebook_AnyVoiceTag[phonebookline] & 0x02)*0x10 + (gPhonebook_TelNumberQuantity[phonebookline] & 0x0F);
                                Offset++;
								
        						//changes from Jöran Karl (28.03.2012)
								//********1-10 with VoiceTag an NumberType, depending on TelNumberQuantity****
        							for(j=0;j<gPhonebook_TelNumberQuantity[phonebookline];j++)
        							{
        								//*********1********
        								//VoiceTag = upper nibble + Reserve = lower nibble of TelNumber1
        								requestarray[Offset]=gPhonebook_VoiceTags[j][phonebookline]*0x10;	
        								Offset++;
                                        //NumberType
                                        requestarray[Offset]=gPhonebook_NumberTypes[j][phonebookline];
                                        Offset++;
        								//***************************
        							}
        							//*********1-10 finished*******************************************
    							}
    							leeloo++;
    							phonebookline=nextvalidphonebookline(phonebookline, gPhonebook_PbName, direction, gPB_CSVtotalElem);
    						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

					break;
                    case 4://TelNumberQuantity,TelNumber(n),VoiceTag(n),Reserve(n),Numbertype(n)

                        while(leeloo<elements)
						{
							if(phonebookline==0xff)
							{
								write("FSG-Telephone: Phonebook_Request - invalid phonebook-line");
								leeloo=elements;    //break loop
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									if(indexsize)
									{
										requestarray[Offset]=gPhonebook_Pos[phonebookline] & 0x00ff;
										requestarray[Offset+1]=(gPhonebook_Pos[phonebookline] & 0xff00)/0x100;
										Offset=Offset+2;
									}
									else
									{
										requestarray[Offset]=gPhonebook_Pos[phonebookline];
										Offset++;
									}
								}								

                                //TelNumberQuantity = lower nibble
                                requestarray[Offset]=gPhonebook_TelNumberQuantity[phonebookline] & 0x0F;
                                Offset++;
								
        							//changes from Jöran Karl (28.03.2012)
								//********TelNumber1-10 with VoiceTag an NumberType, depending on TelNumberQuantity****
        							for(j=0;j<gPhonebook_TelNumberQuantity[phonebookline];j++)
        							{
        								//*********TelNumber1********
        								length=strlen(gPhonebook_TelNumbers[j][phonebookline]);
        								requestarray[Offset]=length;
        								Offset++;
        							
                                        for(i=0;i<length;i++)
        								{
        									requestarray[Offset]=gPhonebook_TelNumbers[j][phonebookline][i];

        									Offset++;
        								}
        								//VoiceTag = upper nibble + Reserve = lower nibble of TelNumber1
        								requestarray[Offset]=gPhonebook_VoiceTags[j][phonebookline]*0x10;	
        								Offset++;
                                        //NumberType
                                        requestarray[Offset]=gPhonebook_NumberTypes[j][phonebookline];
                                        Offset++;
        								//***************************
        							}
        							//*********TelNumbers1-10 finished*******************************************
    							}
    							leeloo++;
    							phonebookline=nextvalidphonebookline(phonebookline, gPhonebook_PbName, direction, gPB_CSVtotalElem);
    						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

					break;
					case 0x0f:	//Pos only
						while(leeloo<elements)
						{
							if(phonebookline==0xff)
							{
								write("FSG-Telephone_Request - invalid phonebook-line");
								leeloo=elements;
							}
							else
							{
								//transmit position
								//IssueList #76 - MR49870 : Phonebook
                                  //Updating the status array excluding the deleted elements
                                  telephoneListDelFlg = 0x00;
                                  telephoneListDelFlg = telephoneList_deleteCheck(gPhonebook_Pos[phonebookline],gPhonebook_Pos_insDel,gPB_CSVtotalElem);
                                            
                                  if (telephoneListDelFlg == 0x00)
                                  {
                                        if(indexsize)
        								{
        									requestarray[Offset]=gPhonebook_Pos[phonebookline] & 0x00ff;
        									requestarray[Offset+1]=(gPhonebook_Pos[phonebookline] & 0xff00)/0x100;
        									Offset=Offset+2;
        								}
        								else
        								{
        									requestarray[Offset]=gPhonebook_Pos[phonebookline];
        									Offset++;
        								}
							       } //telephoneListDelFlg
                            }
							 //IssueList #76 - MR49870 : Phonebook
							if (telephoneListDelFlg == 0x00)
                            leeloo++;
							
                            phonebookline=nextvalidphonebookline(phonebookline, gPhonebook_PbName, direction, gPB_CSVtotalElem);
						}

    						
                            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    					break;
    					default:
    						write("FSG-Telephone Phonebook_Request: invalid recordaddress %d", recordaddress);
    					break;
    				}
    		//changes from Jöran Karl (28.03.2012)
			}
            }
            else
            {
                write("FSG-Telephone Phonebook_Request: Simulate timeout of Status-Array!");
            }
		break;
		case Error_REQ:
			//BAP-header
			requestarray[0]=LSGID_Telephone;	//LSG-ID telephone
			requestarray[1]=FctID_Phonebook;	//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:
			write("FSG-Telephone Phonebook_Request: invalid request %d", request);
		break;
	}

}

receivedcalls_Indication (dword Indication_array [], byte indication, int datalength)
{

int i; 
word valid_startelement, startelement, elements, valid_elements, requested_startelement, delete_ID, datapointer;
byte mode, recordaddress, shift, direction, transmitpos, indexsize, temp, SetGet_possible;

//init lokal variables
	startelement=0;
	elements=0;
	valid_startelement=0xff;
	valid_elements=0xff;
	requested_startelement=0;
	delete_ID=0;
	datapointer=0;
	mode=0;
	recordaddress=0;
	shift=0;
	direction=0;
	transmitpos=0;
	indexsize=0;
	SetGet_possible=0;
//********************
	
	mode=Indication_array[3];
	recordaddress=mode & 0x0f;
	shift=(mode & 0x10)/0x10;
	direction=(mode & 0x20)/0x20;
	transmitpos=(mode & 0x40)/0x40;
	indexsize=(mode & 0x80)/0x80;
	//write("FSG-Telephone receivedcalls_Indication: direction:%d, indexsize: %d", direction, indexsize);
	
	if(indexsize){
		startelement=Indication_array[4]+Indication_array[5]*256;
		elements=Indication_array[6]+Indication_array[7]*256;
		datapointer=8;
	}
	else{
		startelement=Indication_array[4];
		elements=Indication_array[5];
		datapointer=6;
	}
	
	requested_startelement=startelement;

	temp=checkcallstackarray(Indication_array, datalength);
	//write("FSG-Telephone receivedcalls_Indication - checkcallstackarray: %d",temp);
	
	if(temp==0xff)																		//check array-datalength/format
	{
		receivedcalls_Request(Error_REQ, 0, 0, 0, 0, Terror_unknownapllicationerror);
	}
	else
	{
		switch(indication)
		{
			case DataSetGet_IND:
				switch(recordaddress)
				{
					case 1:	//PbName and NumberType only (is only used to delete an entry)
						//verify  startelement
						if(greceivedcalls_pbname[startelement][0]!=0 && Indication_array[datapointer]==0)	//only if valid entriy at found position and PbName-length=0 (necessary for delete)
						{
							SetGet_possible=1;
							delete_ID=startelement;
							i=CALLSTACK;											//loop finished
						
						}
						//**************************
						if(ActiveUserValidation()!=1)								//no active User available
							receivedcalls_Request(Error_REQ, 0, 0, 0, 0, Terror_unknownapllicationerror);
						else if(elements!=1)										//invalid value for elements, SetGet is allowed for only one element
							receivedcalls_Request(Error_REQ, 0, 0, 0, 0, Terror_datainvalid);
						else if(SetGet_possible!=1)									//invalid startelement or invalid parameter
							receivedcalls_Request(Error_REQ, 0, 0, 0, 0, Terror_datainvalid);	
						else
						{
							callstack_receivedcalls(DELETE_ID, delete_ID);
							greceivedcall_DeleteStatus=TRUE;
							recordaddress=1;
							if(delete_ID<256)
								indexsize=0;
							else
								indexsize=1;

							shift=1;
							direction=1;												//means, that elements were deleted and the following entries were shifted upstairs
							mode=recordaddress+shift*0x10+direction*0x20+indexsize*0x80;
							receivedcalls_Request(Data_REQ, delete_ID, delete_ID, 1, mode, 0);
							settimer(ReceivedCallsDeleteEntryTimer, 250);
						}
					break;
					default:
						receivedcalls_Request(Error_REQ, 0, 0, 0, 0, Terror_datainvalid);
					break;
				}
			break;
			case DataGet_IND:
				
				//check startelement of request for special case
				if(startelement==0 && direction==BACKWARD && shift==TRUE)				//ASG ask for the last elements of array
					startelement=CALLSTACK-1;											//start at the end of array
				//**********************************************
			
			//	write("receivedcalls User valid: %d", ActiveUserValidation());			//debug
				if(ActiveUserValidation()!=1)											//no active User available
				{
					valid_startelement=startelement;
					valid_elements=0;
				}
				else if(startelement>(CALLSTACK-1) && direction==FORWARD)				//'position of startelement'>'maximum array-position' and direction=FORWARD 
				{
					valid_startelement=startelement;
					valid_elements=0;
				}
				else if(startelement>(CALLSTACK-1) && direction==BACKWARD)				//'position of startelement'>'maximum array-position' and direction=BACKWARD 
				{
					//search valid_startelement, starting at the end of array
					for(i=(CALLSTACK-1);i>=0;i--)
					{
						if(greceivedcalls_pbname[i][0]!=0)								//if there is an valid element
						{
							valid_startelement=i;
							i=-1;														//loop finished
						}
					}
					
					if(valid_startelement==0xff)										//dialednumbers-array is empty
					{
						valid_startelement=startelement;
						valid_elements=0;
					}
					else																//at least one valid element in dialednumber-array
					{
						//verify number of valid elements
						if(elements>valid_startelement+1)
							valid_elements=valid_startelement+1;
						else
							valid_elements=elements;
					}
				}
				else if(startelement<CALLSTACK && direction==BACKWARD)					//'position of startelement'<'maximum array-position' and direction=BACKWARD )
				{
					//search valid_startelement
					for(i=startelement-shift;i>=0;i--)										//if shift-bit is set, searching started one element before the requested start-position
					{
						if(greceivedcalls_pbname[i][0]!=0)								//if there is an valid element
						{
							valid_startelement=i;
							i=-1;														//loop finished
						}
					}
					
					if(valid_startelement==0xff)										//empty array dialednumbers
					{
						valid_startelement=startelement;
						valid_elements=0;
					}
					else																//at least one valid element in dialednumber-array
					{
						//verify number of valid elements
						if(elements>(valid_startelement+1))
							valid_elements=valid_startelement+1;
						else
							valid_elements=elements;
					}
				}
				else if(startelement<CALLSTACK && direction==FORWARD)					//'position of startelement'<'maximum array-position' and direction=FORWARD 
				{
					if(TRUE==shift)														//if shift-bit is set
						valid_startelement=startelement+1;								//starting one element after the requested startposition
					else
						valid_startelement=startelement;
					
					valid_elements=0;
					//verify number of valid elements
					for(i=valid_startelement;i<valid_startelement+elements;i++)
					{
						if(greceivedcalls_pbname[i][0]!=0)								//if there is an valid element
							valid_elements++;

						if(i==(CALLSTACK-1))											//loop finished
							i=valid_startelement+elements;	
					}
				}
				
				//***calculate mode***
				if(requested_startelement<256 && indexsize==1)							//if indexsize-bit is set and not necessary
					indexsize=0;														//reset indexsize-bit
				
				if((valid_startelement!=requested_startelement  && valid_elements>0) || 0x0f==recordaddress)
					transmitpos=1;
				else
					transmitpos=0;

				mode=recordaddress+shift*0x10+direction*0x20+transmitpos*0x40+indexsize*0x80;
				//********************
			//	write("FSG-Telephone receivedcalls_Indication: valid-start: %d, valid_elements: %d, indexsize: %d",valid_startelement, valid_elements, (mode & 0x01));
				receivedcalls_Request(Data_REQ, requested_startelement, valid_startelement, valid_elements, mode, 0);
				
			break;
			default:
				receivedcalls_Request(Error_REQ, 0, 0, 0, 0, Terror_unknownapllicationerror);
				write("FSG-Telephone receivedcalls_Indication: invalid indication %d", indication);
			break;
		}
	}
}

receivedcalls_Request (byte request, word requested_startelement, word startelement, word elements, byte mode, byte errorcode)
{
int i;
word callstackline, leeloo, Offset, length, datapointer;
byte indexsize, transmitpos, direction, recordaddress;	
dword requestarray [BAP_buffer_size];
char sday[3], smonth[3], syear[3], shour[3], smin[3], ssec[3];
byte bday, bmonth, byear, bhour, bmin, bsec;


//init lokal variables
	Offset=0;
	length=0;
	callstackline=0;
	leeloo=0;
	datapointer=0;
	indexsize=0;
	transmitpos=0;
	direction=0;
	recordaddress=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;

	for(i=0;i<3;i++)
	{
		sday[i]=0;
		smonth[i]=0;
		syear[i]=0;
		shour[i]=0;
		smin[i]=0;
		ssec[i]=0;
	}

	bday=0;
	bmonth=0;
	byear=0;
	bhour=0;
	bmin=0;
	bsec=0;
//********************

	
	indexsize=(mode & 0x80)/0x80;
	direction=(mode & 0x20)/0x20;
	transmitpos=(mode & 0x40)/0x40;
	recordaddress=mode & 0x0f;
	//write("FSG-Telephone: receivedcalls_Request: direction:%d, indexsize: %d, recordaddress: %d", direction, indexsize, recordaddress);
	

	switch (request)
	{
		case Changed_REQ:
			//BAP-header
			requestarray[0]=LSGID_Phonebook;	//LSG-ID
			requestarray[1]=FctID_ReceivedCalls;	//Fct.-ID
			requestarray[2]=request;	
			
			//extendet array header
			requestarray[3]=mode;	//Mode
			if(indexsize)
			{
				requestarray[4]=startelement & 0x00ff;
				requestarray[5]=(startelement & 0xff00)/256;
				requestarray[6]=elements & 0x00ff;
				requestarray[7]=(elements & 0xff00)/256;
				Offset=8;
			}
			else
			{
				requestarray[4]=startelement;
				requestarray[5]=elements;
				Offset=6;
			}
		
			
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);			
		break;
		case Data_REQ:
			if(greceivedcall_DeleteStatus==TRUE)											//array-element was deleted
			{
				greceivedcall_DeleteStatus=FALSE;

				//BAP-header
				requestarray[0]=LSGID_Phonebook;	//LSG-ID
				requestarray[1]=FctID_ReceivedCalls;	//Fct.-ID
				requestarray[2]=request;

				//extendet array header
				requestarray[3]=mode;				//Mode
				if(indexsize)
				{
					requestarray[4]=requested_startelement & 0x00ff;
					requestarray[5]=(requested_startelement & 0xff00)/0x100;
					requestarray[6]=elements & 0x00ff;
					requestarray[7]=(elements & 0xff00)/0x100;
					Offset=8;
				}
				else
				{
					requestarray[4]=requested_startelement;
					requestarray[5]=elements;
					Offset=6;
				}

				//PbName
				requestarray[Offset]=0;
				Offset++;
				//NumberType
				requestarray[Offset]=0;
				Offset++;				

				set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

			}
			else																		//no element was deleted, normal Status-array Request
			{
				//BAP-header
				requestarray[0]=LSGID_Phonebook;	//LSG-ID telephone
				requestarray[1]=FctID_ReceivedCalls;	//Fct.-ID
				requestarray[2]=request;

				//extendet array header
				requestarray[3]=mode;	//Mode
				if(indexsize)
				{
					requestarray[4]=requested_startelement & 0x00ff;
					requestarray[5]=(requested_startelement & 0xff00)/256;
					requestarray[6]=elements & 0x00ff;
					requestarray[7]=(elements & 0xff00)/256;
					Offset=8;
				}
				else
				{
					requestarray[4]=requested_startelement;
					requestarray[5]=elements;
					Offset=6;
				}

				callstackline=startelement;

				switch(recordaddress)
				{
					case 0:	//complete record
						while(leeloo<elements)
						{
							if(callstackline==0xff)
							{
								write("FSG-Telephone: receivedcalls_Request - invalid callstack-line");
								leeloo=elements;
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									if(indexsize)
									{
										requestarray[Offset]=callstackline & 0x00ff;
										requestarray[Offset+1]=(callstackline & 0xff00)/0x100;
										Offset=Offset+2;
									}
									else
									{
										requestarray[Offset]=callstackline;
										Offset++;
									}
								}
							
								//PbName
								if(strncmp(greceivedcalls_pbname[callstackline], gunknown, 40)==0)
								{
									length=1;
									requestarray[Offset]=length;
									Offset++;
									requestarray[Offset]=0x00;
									Offset++;
								}
								else
								{
									length=strlen(greceivedcalls_pbname[callstackline]);
									requestarray[Offset]=length;
									Offset++;
									for(i=0;i<length;i++)	//copy PbName in request buffer
									{
										requestarray[Offset]=greceivedcalls_pbname[callstackline][i];
										Offset++;
									}
								}

								//NumberType
								requestarray[Offset]=greceivedcalls_numbertype[callstackline];	
								Offset++;

								//TelNumber
								length=strlen(greceivedcalls_telnumber[callstackline]);
								requestarray[Offset]=length;
								Offset++;
								for(i=0;i<length;i++)					//copy PbName in request buffer
								{
									requestarray[Offset]=greceivedcalls_telnumber[callstackline][i];
									Offset++;
								}
							
								//Date
								sday[0]=greceivedcalls_date[callstackline][0];
								sday[1]=greceivedcalls_date[callstackline][1];
								sday[2]=0;
								smonth[0]=greceivedcalls_date[callstackline][2];
								smonth[1]=greceivedcalls_date[callstackline][3];
								smonth[2]=0;
								syear[0]=greceivedcalls_date[callstackline][4];
								syear[1]=greceivedcalls_date[callstackline][5];
								syear[2]=0;
								bday=atol(sday);
								bmonth=atol(smonth);
								byear=atol(syear);
								if(greceivedcall_DateTime)
								{
									requestarray[Offset]=bday;
									Offset++;
									requestarray[Offset]=bmonth;
									Offset++;
									requestarray[Offset]=byear;
									Offset++;
								}
								else
								{
									requestarray[Offset]=0xff;
									Offset++;
									requestarray[Offset]=0xff;
									Offset++;
									requestarray[Offset]=0xff;
									Offset++;
								}

								//Time
								shour[0]=greceivedcalls_time[callstackline][0];
								shour[1]=greceivedcalls_time[callstackline][1];
								shour[2]=0;
								smin[0]=greceivedcalls_time[callstackline][2];
								smin[1]=greceivedcalls_time[callstackline][3];
								smin[2]=0;
								ssec[0]=greceivedcalls_time[callstackline][4];
								ssec[1]=greceivedcalls_time[callstackline][5];
								ssec[2]=0;
								bhour=atol(shour);
								bmin=atol(smin);
								bsec=atol(ssec);
								if(greceivedcall_DateTime)
								{
									requestarray[Offset]=bhour;
									Offset++;
									requestarray[Offset]=bmin;
									Offset++;
									requestarray[Offset]=bsec;
									Offset++;
								}
								else
								{
									requestarray[Offset]=0xff;
									Offset++;
									requestarray[Offset]=0xff;
									Offset++;
									requestarray[Offset]=0xff;
									Offset++;
								}
							}
							leeloo++;
							callstackline=nextvalidcallstackline(callstackline, greceivedcalls_pbname, direction, greceivedcalls_TotalNumListElements);
						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
					break;
					case 1:	//PbName and NumberType only
						while(leeloo<elements)
						{
							if(callstackline==0xff)
							{
								write("FSG-Telephone dialednumbers_Request - invalid callstack-line");
								leeloo=elements;
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									if(indexsize)
									{
										requestarray[Offset]=callstackline & 0x00ff;
										requestarray[Offset+1]=(callstackline & 0xff00)/0x100;
										Offset=Offset+2;
									}
									else
									{
										requestarray[Offset]=callstackline;
										Offset++;
									}
								}								

								//PbName
								if(strncmp(greceivedcalls_pbname[callstackline], gunknown, 40)==0)
								{
									length=1;
									requestarray[Offset]=length;
									Offset++;
									requestarray[Offset]=0x00;
									Offset++;
								}
								else
								{
									length=strlen(greceivedcalls_pbname[callstackline]);
									requestarray[Offset]=length;
									Offset++;
									for(i=0;i<length;i++)	//copy PbName in request buffer
									{
										requestarray[Offset]=greceivedcalls_pbname[callstackline][i];
										Offset++;
									}
								}

								//NumberType
								requestarray[Offset]=greceivedcalls_numbertype[callstackline];	
								Offset++;
							}
							leeloo++;
							callstackline=nextvalidcallstackline(callstackline, greceivedcalls_pbname, direction, greceivedcalls_TotalNumListElements);
						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
					break;
					case 2://TelNumber, Date and Time only
						while(leeloo<elements)
						{
							if(callstackline==0xff)
							{
								write("FSG-Telephone dialednumbers_Request - invalid callstack-line");
								leeloo=elements;
							}
							else
							{
								//transmit position
								if(transmitpos==1)
								{
									if(indexsize)
									{
										requestarray[Offset]=callstackline & 0x00ff;
										requestarray[Offset+1]=(callstackline & 0xff00)/0x100;
										Offset=Offset+2;
									}
									else
									{
										requestarray[Offset]=callstackline;
										Offset++;
									}
								}
							
								//TelNumber
								length=strlen(greceivedcalls_telnumber[callstackline]);
								requestarray[Offset]=length;
								Offset++;
								for(i=0;i<length;i++)						//copy PbName in request buffer
								{
									requestarray[Offset]=greceivedcalls_telnumber[callstackline][i];
									Offset++;
								}

								//Date
								sday[0]=greceivedcalls_date[callstackline][0];
								sday[1]=greceivedcalls_date[callstackline][1];
								sday[2]=0;
								smonth[0]=greceivedcalls_date[callstackline][2];
								smonth[1]=greceivedcalls_date[callstackline][3];
								smonth[2]=0;
								syear[0]=greceivedcalls_date[callstackline][4];
								syear[1]=greceivedcalls_date[callstackline][5];
								syear[2]=0;
								bday=atol(sday);
								bmonth=atol(smonth);
								byear=atol(syear);
								if(greceivedcall_DateTime)
								{
									requestarray[Offset]=bday;
									Offset++;
									requestarray[Offset]=bmonth;
									Offset++;
									requestarray[Offset]=byear;
									Offset++;
								}
								else
								{
									requestarray[Offset]=0xff;
									Offset++;
									requestarray[Offset]=0xff;
									Offset++;
									requestarray[Offset]=0xff;
									Offset++;
								}

								//Time
								shour[0]=greceivedcalls_time[callstackline][0];
								shour[1]=greceivedcalls_time[callstackline][1];
								shour[2]=0;
								smin[0]=greceivedcalls_time[callstackline][2];
								smin[1]=greceivedcalls_time[callstackline][3];
								smin[2]=0;
								ssec[0]=greceivedcalls_time[callstackline][4];
								ssec[1]=greceivedcalls_time[callstackline][5];
								ssec[2]=0;
								bhour=atol(shour);
								bmin=atol(smin);
								bsec=atol(ssec);
								if(greceivedcall_DateTime)
								{
									requestarray[Offset]=bhour;
									Offset++;
									requestarray[Offset]=bmin;
									Offset++;
									requestarray[Offset]=bsec;
									Offset++;
								}
								else
								{
									requestarray[Offset]=0xff;
									Offset++;
									requestarray[Offset]=0xff;
									Offset++;
									requestarray[Offset]=0xff;
									Offset++;
								}
							}
							leeloo++;
							callstackline=nextvalidcallstackline(callstackline, greceivedcalls_pbname, direction, greceivedcalls_TotalNumListElements);
						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
					break;
					case 0x0f:	//Pos only
						while(leeloo<elements)
						{
							if(callstackline==0xff)
							{
								write("FSG-Telephone dialednumbers_Request - invalid callstack-line");
								leeloo=elements;
							}
							else
							{
								//transmit position
								if(indexsize)
								{
									requestarray[Offset]=callstackline & 0x00ff;
									requestarray[Offset+1]=(callstackline & 0xff00)/0x100;
									Offset=Offset+2;
								}
								else
								{
									requestarray[Offset]=callstackline;
									Offset++;
								}
							}
							leeloo++;
							callstackline=nextvalidcallstackline(callstackline, greceivedcalls_pbname, direction, greceivedcalls_TotalNumListElements);
						}

						set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
					break;
					default:
						write("FSG-Telephone receivedcalls_Request: invalid recordaddress %d", recordaddress);
					break;
				}
			}
		break;
		case Error_REQ:
			//BAP-header
			requestarray[0]=LSGID_Phonebook;	//LSG-ID telephone
			requestarray[1]=FctID_ReceivedCalls;	//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:
			write("FSG-Telephone receivedcalls_Request: invalid request %d", request);
		break;
	}

}

on envVar env_FSG_dialednumber_add		//add new entry by using the panel
{
int i;
char empty_string [2], dialednumber [CALL_INFO_NUMBER_LENGTH];

//init lokal variables
	for(i=0;i<2;i++)
		empty_string[i]=0;

	for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
		dialednumber[i]=0;
//********************
	
	if(getvalue(this)){
		getvalue(env_FSG_dialednumber_add_number, dialednumber);
	
		if(strlen(dialednumber)!=0){
			strncpy(gdialednumber_new, dialednumber, CALL_INFO_NUMBER_LENGTH);
			getvalue(env_FSG_dialednumber_add_name, gdialednumbername_new);
			if(strlen(gdialednumbername_new)==0)
				strncpy(gdialednumbername_new, dialednumber, CALL_INFO_NUMBER_LENGTH);
			gdialednumbersnumbertype_new=getvalue(env_FSG_dialednumber_add_type);

			callstack_dialednumbers(NEWCALL, 0);

			putvalue(env_FSG_dialednumber_add_number, empty_string);
			putvalue(env_FSG_dialednumber_add_name, empty_string);
		}
	}
}

on envVar env_FSG_dialednumber_add_type
{
	putvalue(env_FSG_s_dialednumber_add_type, gnumbertype[getvalue(this)]);	

}

on envVar env_FSG_dialednumber_callstack	//number was dialed and has to be addad to the call stack
{

int i;
char empty_string [2], dialednumber [CALL_INFO_NUMBER_LENGTH];

//init lokal variables
	for(i=0;i<2;i++)
		empty_string[i]=0;

	for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
		dialednumber[i]=0;
//********************

	getvalue(this, dialednumber);
	
	if(strlen(dialednumber)!=0){
		strncpy(gdialednumber_new, dialednumber, CALL_INFO_NUMBER_LENGTH);
		getvalue(env_FSG_dialednumber_name, gdialednumbername_new);
		gdialednumbersnumbertype_new=getvalue(env_FSG_dialednumber_numbertype);

		callstack_dialednumbers(NEWCALL, 0);

		putvalue(this, empty_string);
		putvalue(env_FSG_dialednumber_name, empty_string);
		putvalue(env_FSG_dialednumber_numbertype, 0);
	}
}

on envVar env_FSG_PbState_DownloadAbort
{
	if(gFSG_Telephone_PowerOnOff==Power_on && gDownLoadState==CURRENTLY_BEING_LOADED && getvalue(this)){
		canceltimer(PbDownload_timer);
		gDownLoadState=DOWNLOAD_ABORTED;
		if(gDownLoadState_old==COMPLETELY_LOADED || gDownLoadState_old==INCOMPLETELY_LOADED)
			gPbEntriesUHV=gPbEntriesUHV_old;
		else
			gPbEntriesUHV=0;

		putvalue(env_FSG_PbState_DownloadState, gDownLoadState);
		putvalue(env_FSG_PbState_EntriesUHV, gPbEntriesUHV);
		PbState_Request(Data_REQ, 0);
		settimer(PbDownloadAborted_timer, 1000);
	}
}

on envVar env_FSG_missedcall_add
{
int i;
char empty_string [2], missedcallnumber [CALL_INFO_NUMBER_LENGTH];

//init lokal variables
	for(i=0;i<2;i++)
		empty_string[i]=0;

	for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
		missedcallnumber[i]=0;
//********************

	if(getvalue(this)){
		getvalue(env_FSG_missedcall_add_number, missedcallnumber);
	
		if(strlen(missedcallnumber)!=0){
			strncpy(gmissedcallnumber_new, missedcallnumber, CALL_INFO_NUMBER_LENGTH);
			getvalue(env_FSG_missedcall_add_name, gmissedcallname_new);
			if(strlen(gmissedcallname_new)==0)
				strncpy(gmissedcallname_new, missedcallnumber, CALL_INFO_NUMBER_LENGTH);
			gmissedcallnumbertype_new=getvalue(env_FSG_missedcall_add_type);
		}
		else{
			strncpy(gmissedcallnumber_new, empty_string, CALL_INFO_NUMBER_LENGTH);
			strncpy(gmissedcallname_new, gunknown, CALL_INFO_NAME_LENGTH);
			gmissedcallnumbertype_new=0;
		}

		callstack_missedcalls(NEWCALL, 0,1);

		putvalue(env_FSG_missedcall_add_number, empty_string);
		putvalue(env_FSG_missedcall_add_name, empty_string);
	}
}

on envVar env_FSG_missedcall_add_type
{
	putvalue(env_FSG_s_missedcall_add_type, gnumbertype[getvalue(this)]);	

}

on envVar env_FSG_MissedCallIndication
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this)){
		gMissedCalls=getvalue(env_FSG_MissedCalls);
		gMissedNumbers=getvalue(env_FSG_MissedNumbers);

		MissedCallIndication_Request(Data_REQ, 0);						//send data to RNS
	}

}

on envVar env_FSG_receivedcall_add
{
int i;
char empty_string [2], receivedcallnumber [CALL_INFO_NUMBER_LENGTH];

//init lokal variables
	for(i=0;i<2;i++)
		empty_string[i]=0;

	for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
		receivedcallnumber[i]=0;
//********************

	if(getvalue(this)){
		getvalue(env_FSG_receivedcall_add_number, receivedcallnumber);
	
		if(strlen(receivedcallnumber)!=0){
			strncpy(greceivedcallnumber_new, receivedcallnumber, CALL_INFO_NUMBER_LENGTH);
			getvalue(env_FSG_receivedcall_add_name, greceivedcallname_new);
			if(strlen(greceivedcallname_new)==0)
				strncpy(greceivedcallname_new, receivedcallnumber, CALL_INFO_NUMBER_LENGTH);
			greceivedcallnumbertype_new=getvalue(env_FSG_receivedcall_add_type);
		}
		else{
			strncpy(greceivedcallnumber_new, empty_string, CALL_INFO_NUMBER_LENGTH);
			strncpy(greceivedcallname_new, gunknown, CALL_INFO_NAME_LENGTH);
			greceivedcallnumbertype_new=0;
		}

		callstack_receivedcalls(NEWCALL, 0);

		putvalue(env_FSG_receivedcall_add_number, empty_string);
		putvalue(env_FSG_receivedcall_add_name, empty_string);
	}
}

on envVar env_FSG_receivedcall_add_type
{
	putvalue(env_FSG_s_receivedcall_add_type, gnumbertype[getvalue(this)]);	

}

on envVar env_FSG_receivedcall_callstack
{
int i;
char empty_string [2], receivedcallnumber [CALL_INFO_NUMBER_LENGTH];

//init lokal variables
	for(i=0;i<2;i++)
		empty_string[i]=0;

	for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
		receivedcallnumber[i]=0;
//********************

	if(getvalue(this))
	{
		getvalue(env_FSG_receivedcall_name, greceivedcallname_new);
		getvalue(env_FSG_receivedcall_number, greceivedcallnumber_new);
		greceivedcallnumbertype_new=getvalue(env_FSG_receivedcall_numbertype);

		callstack_receivedcalls(NEWCALL, 0);

		putvalue(this, 0);
		putvalue(env_FSG_receivedcall_name, empty_string);
		putvalue(env_FSG_receivedcall_number, empty_string);
		putvalue(env_FSG_receivedcall_numbertype, 0);
	}
}

on envVar env_FSG_time
{
int i;

	for(i=0;i<3;i++){
		gshour[i]=0;
		gsmin[i]=0;
		gssec[i]=0;
	}

	gbhour=0;
	gbmin=0;
	gbsec=0;
	getvalue(env_FSG_time, gtime);

	gshour[0]=gtime[0];
	gshour[1]=gtime[1];
	gshour[2]=0;
	gsmin[0]=gtime[2];
	gsmin[1]=gtime[3];
	gsmin[2]=0;
	gssec[0]=gtime[4];
	gssec[1]=gtime[5];
	gssec[2]=0;
	gbhour=atol(gshour);
	gbmin=atol(gsmin);
	gbsec=atol(gssec);

}

//MR63666
on envVar env_PIC_bapMOST_setImage_Cat
{
	if (getValue(this)==0x01) //activeCall - activate PIctureType dropdown
    EnableControl("BAP_MOST_Synchronization","ActiveCall_PictureType",1);
  else
    EnableControl("BAP_MOST_Synchronization","ActiveCall_PictureType",0);
}

on envVar env_FSG_Telephone_FctList_set
{
	if(gFSG_Telephone_PowerOnOff==Power_off){
		gFunctionListModified=getvalue(this);
		putvalue(env_FSG_Telephone_s_FctList_set, gstring_FunctionListModified[gFunctionListModified]);
	}
}

on envVar env_FSG_Telephone_MSS_update
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
    //changes from Jöran Karl (28.03.2012)
    //IssueList #17
	//Byte0
        //gMobilServiceSupport0  =getvalue(env_FSG_Telephone_MSS_0x01)*0x40;
        //gMobilServiceSupport0 +=getvalue(env_FSG_Telephone_MSS_0x02)*0x20;
        //gMobilServiceSupport0 +=getvalue(env_FSG_Telephone_MSS_0x03)*0x10;
        //gMobilServiceSupport0 +=getvalue(env_FSG_Telephone_MSS_0x04)*0x08;
        //Byte1
        //gMobilServiceSupport1  =getvalue(env_FSG_Telephone_MSS_0x0E)*0x02;
        //gMobilServiceSupport1 +=getvalue(env_FSG_Telephone_MSS_0x0F)*0x01;
        //Byte2
        //gMobilServiceSupport2  =getvalue(env_FSG_Telephone_MSS_0x10)*0x80;
        gMobilServiceSupport2 =getvalue(env_FSG_Telephone_MSS_0x11)*0x40;
        gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x12)*0x20;
        gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x13)*0x10;
        gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x14)*0x08;
        gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x15)*0x04;
        gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x16)*0x02;
        gMobilServiceSupport2 +=getvalue(env_FSG_Telephone_MSS_0x17)*0x01;
        //Byte3
        gMobilServiceSupport3  =getvalue(env_FSG_Telephone_MSS_0x18)*0x80;
        gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x19)*0x40;
        gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1A)*0x20;
        gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1B)*0x10;
        gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1C)*0x08;
        gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1D)*0x04;
        gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1E)*0x02;
        gMobilServiceSupport3 +=getvalue(env_FSG_Telephone_MSS_0x1F)*0x01;
        //Byte4
        gMobilServiceSupport4  =getvalue(env_FSG_Telephone_MSS_0x20)*0x80;
        gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x21)*0x40;
        gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x22)*0x20;
        gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x23)*0x10;
        gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x24)*0x08;
        gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x25)*0x04;
        gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x26)*0x02;
        gMobilServiceSupport4 +=getvalue(env_FSG_Telephone_MSS_0x27)*0x01;
        //Byte5
        gMobilServiceSupport5  =getvalue(env_FSG_Telephone_MSS_0x28)*0x80;
        gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x29)*0x40;
        gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2A)*0x20;
        gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2B)*0x10;
        gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2C)*0x08;
        gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2D)*0x04;
        gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2E)*0x02;
        gMobilServiceSupport5 +=getvalue(env_FSG_Telephone_MSS_0x2F)*0x01;
        //Byte6
        gMobilServiceSupport6  =getvalue(env_FSG_Telephone_MSS_0x30)*0x80;
        gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x31)*0x40;
        gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x32)*0x20;
        gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x33)*0x10;
        gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x34)*0x08;
        gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x35)*0x04;
        gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x36)*0x02;
        gMobilServiceSupport6 +=getvalue(env_FSG_Telephone_MSS_0x37)*0x01;
        //Byte7
        gMobilServiceSupport7  =getvalue(env_FSG_Telephone_MSS_0x38)*0x80;
        gMobilServiceSupport7 +=getvalue(env_FSG_Telephone_MSS_0x39)*0x40;
        gMobilServiceSupport7 +=getvalue(env_FSG_Telephone_MSS_0x3A)*0x20;
           //IssueList #17
	//gMobilServiceSupport7 +=getvalue(env_FSG_Telephone_MSS_0x3B)*0x10;
        gMobilServiceSupport7 +=getvalue(env_FSG_Telephone_MSS_0x3C)*0x08;
        //gMobilServiceSupport7 +=getvalue(env_FSG_Telephone_MSS_0x3D)*0x04;
        //gMobilServiceSupport7 +=getvalue(env_FSG_Telephone_MSS_0x3E)*0x02;
        gMobilServiceSupport7 +=getvalue(env_FSG_Telephone_MSS_0x3F)*0x01;

		MobilServiceSupport_Request(Data_REQ, 0);
	}
}

MobilServiceSupport_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication)	{
		case DataGet_IND:
			if(datalength!=3)															//datalength error
				MobilServiceSupport_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				MobilServiceSupport_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone MobilServiceSupport_Indication: unknown indication %d", indication);
		break;
	}
}

MobilServiceSupport_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request)
	{
		case Data_REQ:
             //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x10_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_MobilServiceSupport;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gMobilServiceSupport0;
			requestarray[4]=gMobilServiceSupport1;
			requestarray[5]=gMobilServiceSupport2;
			requestarray[6]=gMobilServiceSupport3;
			requestarray[7]=gMobilServiceSupport4;
			requestarray[8]=gMobilServiceSupport5;
			requestarray[9]=gMobilServiceSupport6;
			requestarray[10]=gMobilServiceSupport7;
			
			Offset=11;
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_MobilServiceSupport;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone MobilServiceSupport_Request: unknown request %d", request);
		break;
	}
}

on envVar env_FSG_PbState_DownloadState
{
	if(gFSG_Telephone_PowerOnOff==Power_on){
		gDownLoadState=getvalue(env_FSG_PbState_DownloadState);
		//IssueList #143 - commented: envar doesn't exist in any panel
        //putvalue(env_FSG_s_PbState_DownloadState, gstring_DownLoadState[gDownLoadState]);
	}
}

byte ActiveUserValidation ()
{
/*
char na [3] = "na";
char tna [4] = "tna";

	if(gSIMSerial[0]!=0 && strncmp(gSIMSerial, "tna", 40)!=0 && strncmp(gSIMSerial, "na", 40)!=0){							//IMSI is not empty or "tna" or "na"
	//	write("one");											//debug
		return(1);
	}
	else if(strncmp(gSIMSerial, "na", 40)==0 && strncmp(gSerialNumber, "tna", 40)!=0 && gSerialNumber[0]!=0){
	//	write("two");											//debug
		return(1);
	}
	else
		return(0);
*/
return(1);
}

on envVar env_FSG_PbState_update
{
byte mode;

mode=0;

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
		gPbEntriesUHV=getvalue(env_FSG_PbState_EntriesUHV);
		
		PbState_Request(Data_REQ, 0);
	}
}

CallHold_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, callID, callholdpossible;

//init lokal variables
	callID=0xff;
	//callholdpossible=1;
//********************

//IssueList #26
 if ((getValue(env_FSG_CallHold_Result)==0x00)&& (getValue(env_FSG_Tel_CallHold_Error_On)==0x00))
	callholdpossible=1;
else
   callholdpossible=0;


	for(i=0;i<7;i++){
		if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
			callholdpossible=Terror_heldcallpresent;
	}

	if(callholdpossible==1){
		callholdpossible=Terror_noactivecall;
		for(i=0;i<7;i++){
			if(gCallState[i]==active)
				callholdpossible=1;
		}
	}

	switch (indication){
		case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_FSG_Tel_CallHold_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_CallHold_ErrorCode) > 0x3F)) &&  (gTelFctList_0x1F_TimeOut_flg==0x00))
			{
            CallHold_Request(Processing_REQ, 0);												//send Processing
		
               //IssueList #68
                if (gTelFctList_0x1F_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x1F_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x1F_ProcessingTimer,TELMAXPROCESSINGTIME);

                CallHold_Request(Processing_REQ, 0);
                }
            }
        break;
		case StartResult_IND:
            //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x1F_TimeOut)!=TRUE)
            {
		    gTelFctList_0x1F_TimeOut_flg=0x00;
                //IssueList #57
                if (getValue(env_FSG_Tel_CallHold_Error_On)==0x00)
                putValue(env_FSG_Tel_CallHold_ErrorCode,0);
                
                //IssueList #47
                if (getValue(env_FSG_Tel_CallHold_Error_On))
                    CallHold_Request(Error_REQ, getValue(env_FSG_Tel_CallHold_ErrorCode)); // send error-message
                else if(gCallHold_status!=0)
    				CallHold_Request(Error_REQ, Terror_unknownapllicationerror);
    			else if(datalength!=3)																//datalength error
    				CallHold_Request(Error_REQ, Terror_unknownapllicationerror);					//send error-message to RNS
    			else if(gCallActivity==NOCALL)														//CallHold is impossible, no call
    				CallHold_Request(Error_REQ, Terror_nocall);										//send error-message to RNS
    			else if(callholdpossible!=1)														//CallHold is impossible
    				//IssueList #26	
                    //CallHold_Request(Error_REQ, callholdpossible);									//send error-message to RNS
                    {
                    gCallHold_Result=getValue(env_FSG_CallHold_Result);
                    CallHold_Request(Result_REQ, callholdpossible);
                    }
    			else
    			{	
    				gCallHold_status=1;																//method "CallHold" active
    				settimer(CallHoldTimer, CallHoldTimerTime);	
    			}
            }
            else
            gTelFctList_0x1F_TimeOut_flg = 0x01;
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone CallHold_Indication: unknown indication %d", indication);
		break;
		}
}

CallHold_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_CallHold;			//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x1F_Processing_flg == 0x00)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_CallHold;		//Fct.-ID
			requestarray[2]=request;
            requestarray[3]=gCallHold_Result;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_CallHold;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x1F_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone CallHold_Request: unknown request %d", request);
		break;
	}
}

on envVar env_FSG_CallHold
{
byte i, callID, callholdpossible;


//init lokal variables
	callID=0xff;
	callholdpossible=1;
//********************

	for(i=0;i<7;i++){
		if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
			callholdpossible=0;
	}

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && callholdpossible==1){
		for(i=0;i<7;i++){																//searching for active calls
			if(gCallState[i]==active){
				callID=i;
			// changes from Jan Swoboda (01.03.2012)
				set_CallState_noReq(callID,onhold);											//set call state
			}
		}
        if (gCallStateRequestPending)
            CallState_Request(Data_REQ,0);

	}
}

on envVar env_FSG_CallResume
{
byte i, callID, callresumepossible;


//init lokal variables
	callID=0xff;
	callresumepossible=1;
//********************

	for(i=0;i<7;i++){
		if(gCallState[i]==active || gCallState[i]==disconnecting || gCallState[i]==dialing || gCallState[i]==ringing_waiting)
			callresumepossible=0;
	}

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && callresumepossible==1){
		for(i=0;i<7;i++){																//searching for active calls
			if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD){
				callID=i;
				// changes from Jan Swoboda (01.03.2012)
				set_CallState_noReq(callID,active);												//set call state
			}
		}
        // changes from Jan Swoboda (01.03.2012)
	if (gCallStateRequestPending)
            CallState_Request(Data_REQ,0);
	}
}

ResumeCall_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;			//LSG-ID
			requestarray[1]=FctID_ResumeCall;			//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x20_Processing_flg == 0x00)
            {
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_ResumeCall;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=gResumeCall_Result;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            }

		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_ResumeCall;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
            
            //IssueList #68
            cancelTimer(TelFctList_0x20_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone ResumeCall_Request: unknown request %d", request);
		break;
	}
}

ResumeCall_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, callID, callresumepossible;

//init lokal variables
	callID=0xff;
	//callresumepossible=1;
//********************
//IssueList #26
 if (getValue(env_FSG_CallResume_Result)==0x00)	
	callresumepossible=1;
else
   callresumepossible=0;


	for(i=0;i<7;i++){
		if(gCallState[i]==active || gCallState[i]==disconnecting || gCallState[i]==dialing)
			callresumepossible=Terror_activecallpresentdialing;
	}

	if(callresumepossible==1){
		callresumepossible=Terror_nocallonhold;
		for(i=0;i<7;i++){
			if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
				callresumepossible=1;
		}
	}

	switch (indication){
		case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_FSG_Tel_ResumeCall_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_ResumeCall_ErrorCode) > 0x3F)) &&  (gTelFctList_0x20_TimeOut_flg ==0x00))
			{
            ResumeCall_Request(Processing_REQ, 0);											//send Processing
		        
                ///IssueList #68
                if (gTelFctList_0x20_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x20_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x20_ProcessingTimer,TELMAXPROCESSINGTIME);

                ResumeCall_Request(Processing_REQ, 0);
                }
            }
        break;
		case StartResult_IND:
			//IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x20_TimeOut)!=TRUE)
            {
            gTelFctList_0x20_TimeOut_flg = 0x00;
                //IssueList #57
                if (getValue(env_FSG_Tel_ResumeCall_Error_On)==0x00)
                putValue(env_FSG_Tel_ResumeCall_ErrorCode,0);

                //IssueList #47
                if (getValue(env_FSG_Tel_ResumeCall_Error_On))
                    ResumeCall_Request(Error_REQ, getValue(env_FSG_Tel_ResumeCall_ErrorCode)); // send error-message

                else if(gCallHold_status!=0)
    				ResumeCall_Request(Error_REQ, Terror_datainvalid);
    			else if(datalength!=3)															//datalength error
    				ResumeCall_Request(Error_REQ, Terror_datainvalid);							//send error-message to RNS
    			else if(gCallActivity==NOCALL)													//ResumeCall is impossible, no call
    				ResumeCall_Request(Error_REQ, Terror_nocall);								//send error-message to RNS
    			else if(callresumepossible!=1)													//ResumeCall is impossible
    				//IssueList #26
                    //ResumeCall_Request(Error_REQ, callresumepossible);							//send error-message to RNS
                    {
                    gResumeCall_Result=getValue(env_FSG_CallResume_Result);							                       
                    ResumeCall_Request(Result_REQ, callresumepossible);
                    }

    			else{	
    				gResumeCall_status=1;														//method "ResumeCall" active
    				settimer(ResumeCallTimer, ResumeCallTimerTime);
    			    }
             }
             else
             gTelFctList_0x20_TimeOut_flg = 0x01;   

		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone ResumeCall_Indication: unknown indication %d", indication);
		break;
		}
}

on timer CallHoldTimer
{
byte i, callID;

//init lokal variables
	callID=0xff;
//********************


	for(i=0;i<7;i++){																//searching for active calls
		if(gCallState[i]==active){
			callID=i;
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,onhold);												//set call state
		}
	}
    if (gCallStateRequestPending)
        CallState_Request(Data_REQ,0);

	if(callID<7){																	//hold call is possible
        //IssueList #26	
	    gCallHold_Result = SUCCESSFUL;

    	CallHold_Request(Result_REQ, 0);
		gCallHold_status=0;															//method "CallHold" finished
	}
	else {																			//no active call available
		CallHold_Request(Error_REQ, Terror_noactivecall);
		gCallHold_status=0;															//method "CallHold" finished
	}

}

on timer ResumeCallTimer
{
byte i, callID;

//init lokal variables
	callID=0xff;
//********************

	for(i=0;i<7;i++){															//searching for active calls
		if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD){
			callID=i;
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,active);											//set call state
		}
	}
    // changes from Jan Swoboda (01.03.2012)
    if (gCallStateRequestPending)
        CallState_Request(Data_REQ,0);
	if(callID<7){
        //IssueList #26	  																//resume is possible
        gResumeCall_Result = SUCCESSFUL;

		ResumeCall_Request(Result_REQ, 0);
		gResumeCall_status=0;													//method "ResumeCall" finished
	}
	else {																		//no hold call exist
		ResumeCall_Request(Error_REQ, Terror_nocallonhold);
		gResumeCall_status=0;													//method "ResumeCall" finished
	}
}

on timer acceptcallTimer
{
byte i, callID;

//init lokal variables
	callID=0xff;
//********************

	for(i = 0; i < 7; i++){
		if(gCallState[i] == ringing_waiting)
			callID = i;
	}
	if(callID<7){																	//accept call is feasible
		//write to callstack ReceivedCalls
		putvalue(env_FSG_receivedcall_name, greceivedcall_name);				//write name of received call in callstack
		putvalue(env_FSG_receivedcall_number, greceivedcall_number);			//write number of received call in callstack
		putvalue(env_FSG_receivedcall_numbertype, greceivedcall_numbertype);	//write numbertype of dialed number in callstack
		//putvalue(env_FSG_receivedcall_callstack, 1);							//start callstack
		//*********************************
        //MR 63665 - if condition
      
		if (gHookTasteFlag_AcceptCall == 0)
        set_CallState(callID, active);      //method "acceptcal" finished
		
              
        gAcceptCall_Result=SUCCESSFUL;
        
        
        AcceptCall_Request(Result_REQ, 0);
		gacceptcall_status=0;
        

        if(gRingTone_incoming_callid < 7 && gRingTone_unmute == 1)
            putvalue(env_FSG_RingToneMuteOnOff, 0); // unmute
            //IssueList #51
            //MR 63665 - if condition
            if (gHookTasteFlag_AcceptCall == 0)
            putValue(env_FSG_RingToneMuteOnOff_OK,1);

        gRingTone_unmute = 0;
        gRingTone_incoming_callid = 0xff;


        														
	}
	else {																			//no incoming call related to call-ID
		AcceptCall_Request(Error_REQ, Terror_noincomingwaitingcall);
		gacceptcall_status=0;														//method "acceptcal" finished
	}
}

on envVar env_FSG_MPSwap
{
byte i, callID, mpswappossible;


//init lokal variables
	callID=0xff;
	mpswappossible=0;
//********************
	
	//search for active calls 
	for(i=0;i<7;i++){
		if(gCallState[i]==active)
			mpswappossible=1;
	}
	
	//search for held calls
	if(mpswappossible==1){										// if there are active calls
		mpswappossible=0;
		for(i=0;i<7;i++){
			if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
				mpswappossible=1;
		}
	}

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && mpswappossible==1){
		for(i=0;i<7;i++){																//searching for active calls
			if(gCallState[i]==active){
				callID=i;
			// changes from Jan Swoboda (01.03.2012)
				set_CallState_noReq(callID,onhold);											//set call state
			}
			else if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD){
				callID=i;
				// changes from Jan Swoboda (01.03.2012)
				set_CallState_noReq(callID,active);											//set call state
			}
		}
        // changes from Jan Swoboda (01.03.2012)
	if (gCallStateRequestPending)
            CallState_Request(Data_REQ,0);
	}
}

MPSwap_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, callID, mpswappossible;

//init lokal variables
	callID=0xff;
	mpswappossible=Terror_noactivecall;
//********************



	//search for active calls 
	for(i=0;i<7;i++){
		if(gCallState[i]==active)
			mpswappossible=Terror_nocallonhold;
	}
	
	//search for held calls
	if(mpswappossible==Terror_nocallonhold){												// if there are active calls
		for(i=0;i<7;i++){
			if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
				{
                mpswappossible=TRUE;
                callID = i;
                }
		}
	}

//IssueList #26
if (getValue(env_FSG_MPSwap_Result)==0x00)	
	mpswappossible=TRUE;
else
    mpswappossible=FALSE;

	switch (indication){
		case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_FSG_Tel_MPSWAP_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_MPSWAP_ErrorCode) > 0x3F)) &&  (gTelFctList_0x24_TimeOut_flg == 0x00))
			{
            MPSwap_Request(Processing_REQ, 0);												//send Processing
		        
                //IssueList #68
                if (gTelFctList_0x24_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x24_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x24_ProcessingTimer,TELMAXPROCESSINGTIME);

                MPSwap_Request(Processing_REQ, 0);
                }
            }
        break;
		case StartResult_IND:
         //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x24_TimeOut)!=TRUE)
            {
            gTelFctList_0x24_TimeOut_flg = 0x00;
    			
                //IssueList #57
                if (getValue(env_FSG_Tel_MPSWAP_Error_On)==0x00)
                putValue(env_FSG_Tel_MPSWAP_ErrorCode,0);
              
                //IssueList #47
                if (getValue(env_FSG_Tel_MPSWAP_Error_On))
                    MPSwap_Request(Error_REQ, getValue(env_FSG_Tel_MPSWAP_ErrorCode)); // send error-message
            
                else if(gMPSwap_status!=0)															//method is still active
    				MPSwap_Request(Error_REQ, Terror_unknownapllicationerror);
    			else if(datalength!=3)															//datalength error
    				MPSwap_Request(Error_REQ, Terror_unknownapllicationerror);					//send error-message to RNS
    			else if(gCallActivity==NOCALL)													//MPSwap is impossible, no call
    				MPSwap_Request(Error_REQ, Terror_nocall);									//send error-message to RNS
    			else if(mpswappossible!=TRUE)													//MPSwap is impossible
    			//IssueList #26	
                    {
                    gMPSwap_Result=getValue(env_FSG_MPSwap_Result);							                         //send error-message to RNS
                    MPSwap_Request(Result_REQ, mpswappossible);
    	            }
                    //MPSwap_Request(Error_REQ, mpswappossible);									//send error-message to RNS
    			else{
                    //MR59817
                    gActiveCall_active = 0;
                    gActiveCall_CallMethodActive = 0;
                    gActiveCall_MPswapActive = 0;
                    if (getValue(env_PIC_bapMOST_active_flag) == 0x01)
                    {
                     gBapMostCallID= callID;
                     gActiveCall_active = 1;
                     gActiveCall_MPswapActive = 1;
                     gActiveCall_CallMethodActive = 1;
                     setActiveCall_Picture();
                    } //MOST_active_flag
                
                	
    				gMPSwap_status=1;

                    if 	(gActiveCall_BAPdelayFlag == 0x00)														//method "MPSwap" active
    				settimer(MPSwapTimer, MPSwapTimerTime);
                    else
                    settimer(MPSwapTimer, getValue(env_AudioTel_bapMost_delayTimer)*1000);

    			}
            }
            else
            gTelFctList_0x24_TimeOut_flg = 0x01;
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone MPSwap_Indication: unknown indication %d", indication);
		break;
		}
}

MPSwap_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_MPSwap;			//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68

			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_MPSwap;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=gMPSwap_Result;
			Offset=4;

            //MR 60227 - BAP_MOST delay timer
            //if (gTelFctList_0x24_Processing_flg == 0x00 && getValue(env_PIC_bapMOST_active_flag) == 0x00)
            if (gTelFctList_0x24_Processing_flg == 0x00) 
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);

            //MR59817
            if (gActiveCall_CallMethodActive ==0x01)
            gActiveCall_CallMethodActive=0x00;

		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_MPSwap;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x24_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone MPSwap_Request: unknown request %d", request);
		break;
	}
}

on timer MPSwapTimer
{
byte i, callID;

//init lokal variables
	callID=0xff;
//********************

	for(i=0;i<7;i++){																//searching for active calls
		if(gCallState[i]==active){
			callID=i;
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,onhold);											//set call state
		}
		else if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD){
			callID=i;
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,active);											//set call state
		}
	}
    // changes from Jan Swoboda (01.03.2012)
    if (gCallStateRequestPending)
    {
        CallState_Request(Data_REQ,0);
    }

	//IssueList #26
    gMPSwap_Result = SUCCESSFUL;	
	
	MPSwap_Request(Result_REQ, 0);
	gMPSwap_status=0;															//method "acceptcal" finished

}

on envVar env_FSG_CCJoin
{
byte i, callID, ccjoinpossible;


//init lokal variables
	callID=0xff;
	ccjoinpossible=0;
//********************
	
	//search for active calls 
	for(i=0;i<7;i++){
		if(gCallState[i]==active)
			ccjoinpossible=1;
	}
	
	//search for held calls
	if(ccjoinpossible==1){														// if there are active calls
		ccjoinpossible=0;
		for(i=0;i<7;i++){
			if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
				ccjoinpossible=1;
		}
	}

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && ccjoinpossible==1){
		for(i=0;i<7;i++){														//searching for active calls
			if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD){
				callID=i;
                gCallType[callID]=CONFERENCE_VOICE_CALL;									//set call type
				// changes from Jan Swoboda (01.03.2012)
				set_CallState_noReq(callID,active);										//set call state
			}
			else if(gCallState[i]==active){
				callID=i;
				gCallType[callID]=CONFERENCE_VOICE_CALL;									//set call type
                // changes from Jan Swoboda (01.03.2012)
		set_CallState_noReq(callID,active);               //update CallOptions
			}
		}
        // changes from Jan Swoboda (01.03.2012)
	if (gCallStateRequestPending)
            CallState_Request(Data_REQ,0);
	}
}

CCJoin_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, callID, ccjoinpossible;

//init lokal variables
	callID=0xff;
	ccjoinpossible=Terror_noactivecall;
//********************

	//search for active calls 
	for(i=0;i<7;i++){
		if(gCallState[i]==active)
			ccjoinpossible=Terror_nocallonhold;
	}
	
	//search for held calls
	if(ccjoinpossible==Terror_nocallonhold){												// if there are active calls
		for(i=0;i<7;i++){
			if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
				ccjoinpossible=1;
		}
	}

//IssueList #26
 if ((getValue(env_FSG_CCJoin_Result)==0x00)&& (getValue(env_FSG_Tel_CCJoin_Error_On)==0x00))
	ccjoinpossible=1;
else
    ccjoinpossible=0;

	switch (indication){
		case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_FSG_Tel_CCJoin_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_CCJoin_ErrorCode) > 0x3F)) &&   (gTelFctList_0x28_TimeOut_flg == 0x00))
			{
            CCJoin_Request(Processing_REQ, 0);												//send Processing
		        
                //IssueList #68
                if (gTelFctList_0x28_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x28_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x28_ProcessingTimer,TELMAXPROCESSINGTIME);

                CCJoin_Request(Processing_REQ, 0);
                }
            }
        break;
		case StartResult_IND:
         //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x28_TimeOut)!=TRUE)
            {
            gTelFctList_0x28_TimeOut_flg = 0x00;
    			//IssueList #57
                if (getValue(env_FSG_Tel_CCJoin_Error_On)==0x00)
                putValue(env_FSG_Tel_CCJoin_ErrorCode,0);
                
                //IssueList #47
                if (getValue(env_FSG_Tel_CCJoin_Error_On))
                    CCJoin_Request(Error_REQ, getValue(env_FSG_Tel_CCJoin_ErrorCode)); // send error-message

                else if(gCCJoin_status!=0)															//method is still active
    				CCJoin_Request(Error_REQ, Terror_datainvalid);
    			else if(datalength!=3)															//datalength error
    				CCJoin_Request(Error_REQ, Terror_datainvalid);								//send error-message to RNS
    			else if(gCallActivity==NOCALL)													//MPSwap is impossible, no call
    				CCJoin_Request(Error_REQ, Terror_nocall);									//send error-message to RNS
    			else if(ccjoinpossible!=1)														
    			 //IssueList #26													
                    {
                    gCCJoin_Result=getValue(env_FSG_CCJoin_Result);							                         //send error-message to RNS
                    CCJoin_Request(Result_REQ, ccjoinpossible);
                    }	
                    //CCJoin_Request(Error_REQ, ccjoinpossible);									//send error-message to RNS
    			else{	
    				gCCJoin_status=1;															//method "MPSwap" active
    				settimer(CCJoinTimer, CCJoinTimerTime);
    			}
            }
            else
            gTelFctList_0x28_TimeOut_flg = 0x01;
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone CCJoin_Indication: unknown indication %d", indication);
		break;
		}
}

CCJoin_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_CCJoin;			//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x28_Processing_flg == 0x00)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_CCJoin;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=gCCJoin_Result;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_CCJoin;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);

           //IssueList #68
            cancelTimer(TelFctList_0x28_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone CCJoin_Request: unknown request %d", request);
		break;
	}
}

on timer CCJoinTimer
{
byte i, callID;


//init lokal variables
	callID=0xff;
//********************
	
	
	for(i=0;i<7;i++){														//searching for active calls
		if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD){
			callID=i;
            gCallType[callID]=CONFERENCE_VOICE_CALL;						//set call type
			// changes from Jan Swoboda (01.03.2012)
            set_CallState_noReq(callID,active);								//set call state
		}
		else if(gCallState[i]==active){
			callID=i;
			gCallType[callID]=CONFERENCE_VOICE_CALL;									//set call type
            // changes from Jan Swoboda (01.03.2012)

        set_CallState_noReq(callID,active);       //update CallOptions
		}
	}
    // changes from Jan Swoboda (01.03.2012)
    if (gCallStateRequestPending)
        CallState_Request(Data_REQ,0);
    //IssueList #26
    gCCJoin_Result = SUCCESSFUL;

	CCJoin_Request(Result_REQ, 0);
	gCCJoin_status=0;															//method "CCJoin" finished
}

on envVar env_FSG_CCSplit0
{
byte i, callID, ccsplitpossible, conference_active, conference_onhold, conference_partner;


//init lokal variables
	callID=0xff;
	ccsplitpossible=0;
	conference_active=0;
	conference_onhold=0;
	conference_partner=0;
//********************
	
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && gCallType[0]==CONFERENCE_VOICE_CALL && (gCallState[0]==active || gCallState[0]==onhold)){
		//search for conference
		for(i=0;i<7;i++)
		{
			if(gCallType[i]==CONFERENCE_VOICE_CALL)											//if there is an conference
			{
				ccsplitpossible=1;
				conference_partner++;
				if(gCallState[i]==active)											//active conference
					conference_active=1;
				else if(gCallState[i]==onhold && conference_active==0)				//held conference
					conference_onhold=1;
				else
				{																//invalid call state for conference call
					write("FSG-Telephone env_FSG_CCSplit0: invalid call state for conferencecall, split not possible");
					ccsplitpossible=0;
					i=7;	
				}
			}
		}

		//check call states and call types 
		if(ccsplitpossible==1)														//if there is an active conference with valid call state
		{
			if(conference_onhold)													//held conference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==active)										//another active call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
			else																	//active coonference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==onhold)										//a held call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
		}
	

		if(ccsplitpossible==1)
		{
			conference_partner--;
			if(conference_onhold==TRUE)														//held conference
			{
				gCallState[0]=active;
				gCallType[0]=SINGLE_VOICE_CALL;
			}																		
			else																		//active conference		
			{
				gCallType[0]=SINGLE_VOICE_CALL;
				for(i=0;i<7;i++)														//searching for active calls
				{
					if(gCallState[i]==active && gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallState[i]=onhold;											//set call state

				}
			}

			if(conference_partner==1)													//after splitting only single call, no conference
			{
				for(i=0;i<7;i++)														//searching for conference calls
				{
					if(gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallType[i]=SINGLE_VOICE_CALL;
				}
			}
			
			display_CallState();
			CallState_Request(Data_REQ,0);												//send call state
		}
	}
}

on envVar env_FSG_CCSplit1
{
byte i,  ccsplitpossible, conference_active, conference_onhold, conference_partner;


//init lokal variables
	ccsplitpossible=0;
	conference_active=0;
	conference_onhold=0;
	conference_partner=0;
//********************
	
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && gCallType[1]==CONFERENCE_VOICE_CALL && (gCallState[1]==active || gCallState[1]==onhold)){
		//search for conference
		for(i=0;i<7;i++)
		{
			if(gCallType[i]==CONFERENCE_VOICE_CALL)											//if there is an conference
			{
				ccsplitpossible=1;
				conference_partner++;
				if(gCallState[i]==active)											//active conference
					conference_active=1;
				else if(gCallState[i]==onhold && conference_active==0)				//held conference
					conference_onhold=1;
				else
				{																//invalid call state for conference call
					write("FSG-Telephone env_FSG_CCSplit1: invalid call state for conferencecall, split not possible");
					ccsplitpossible=0;
					i=7;	
				}
			}
		}

		//check call states and call types 
		if(ccsplitpossible==1)														//if there is an active conference with valid call state
		{
			if(conference_onhold)													//held conference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==active)										//another active call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
			else																	//active coonference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==onhold)										//a held call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
		}
	

		if(ccsplitpossible==1)
		{
			conference_partner--;
			if(conference_onhold==TRUE)													//held conference
			{
				gCallState[1]=active;
				gCallType[1]=SINGLE_VOICE_CALL;
			}																		
			else																		//active conference		
			{
				gCallType[1]=SINGLE_VOICE_CALL;
				for(i=0;i<7;i++)														//searching for active calls
				{
					if(gCallState[i]==active && gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallState[i]=onhold;											//set call state

				}
			}

			if(conference_partner==1)													//after splitting only single call, no conference
			{
				for(i=0;i<7;i++)														//searching for conference calls
				{
					if(gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallType[i]=SINGLE_VOICE_CALL;
				}
			}
			
			display_CallState();
			CallState_Request(Data_REQ,0);												//send call state
		}
	}
}

on envVar env_FSG_CCSplit2
{
byte i, ccsplitpossible, conference_active, conference_onhold, conference_partner;


//init lokal variables
	ccsplitpossible=0;
	conference_active=0;
	conference_onhold=0;
	conference_partner=0;
//********************
	
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && gCallType[2]==CONFERENCE_VOICE_CALL && (gCallState[2]==active || gCallState[2]==onhold)){
		//search for conference
		for(i=0;i<7;i++)
		{
			if(gCallType[i]==CONFERENCE_VOICE_CALL)											//if there is an conference
			{
				ccsplitpossible=1;
				conference_partner++;
				if(gCallState[i]==active)											//active conference
					conference_active=1;
				else if(gCallState[i]==onhold && conference_active==0)				//held conference
					conference_onhold=1;
				else
				{																//invalid call state for conference call
					write("FSG-Telephone env_FSG_CCSplit2: invalid call state for conferencecall, split not possible");
					ccsplitpossible=0;
					i=7;	
				}
			}
		}

		//check call states and call types 
		if(ccsplitpossible==1)														//if there is an active conference with valid call state
		{
			if(conference_onhold)													//held conference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==active)										//another active call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
			else																	//active coonference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==onhold)										//a held call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
		}
	

		if(ccsplitpossible==1)
		{
			conference_partner--;
			if(conference_onhold==TRUE)														//held conference
			{
				gCallState[2]=active;
				gCallType[2]=SINGLE_VOICE_CALL;
			}																		
			else																		//active conference		
			{
				gCallType[2]=SINGLE_VOICE_CALL;
				for(i=0;i<7;i++)														//searching for active calls
				{
					if(gCallState[i]==active && gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallState[i]=onhold;											//set call state

				}
			}

			if(conference_partner==1)													//after splitting only single call, no conference
			{
				for(i=0;i<7;i++)														//searching for conference calls
				{
					if(gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallType[i]=SINGLE_VOICE_CALL;
				}
			}
			
			display_CallState();
			CallState_Request(Data_REQ,0);												//send call state
		}
	}
}

on envVar env_FSG_CCSplit3
{
byte i, ccsplitpossible, conference_active, conference_onhold, conference_partner;


//init lokal variables
	ccsplitpossible=0;
	conference_active=0;
	conference_onhold=0;
	conference_partner=0;
//********************
	
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && gCallType[3]==CONFERENCE_VOICE_CALL && (gCallState[3]==active || gCallState[3]==onhold)){
		//search for conference
		for(i=0;i<7;i++)
		{
			if(gCallType[i]==CONFERENCE_VOICE_CALL)											//if there is an conference
			{
				ccsplitpossible=1;
				conference_partner++;
				if(gCallState[i]==active)											//active conference
					conference_active=1;
				else if(gCallState[i]==onhold && conference_active==0)				//held conference
					conference_onhold=1;
				else
				{																//invalid call state for conference call
					write("FSG-Telephone env_FSG_CCSplit3: invalid call state for conferencecall, split not possible");
					ccsplitpossible=0;
					i=7;	
				}
			}
		}

		//check call states and call types 
		if(ccsplitpossible==1)														//if there is an active conference with valid call state
		{
			if(conference_onhold)													//held conference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==active)										//another active call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
			else																	//active coonference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==onhold)										//a held call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
		}
	

		if(ccsplitpossible==1)
		{
			conference_partner--;
			if(conference_onhold==TRUE)														//held conference
			{
				gCallState[3]=active;
				gCallType[3]=SINGLE_VOICE_CALL;
			}																		
			else																		//active conference		
			{
				gCallType[3]=SINGLE_VOICE_CALL;
				for(i=0;i<7;i++)														//searching for active calls
				{
					if(gCallState[i]==active && gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallState[i]=onhold;											//set call state

				}
			}

			if(conference_partner==1)													//after splitting only single call, no conference
			{
				for(i=0;i<7;i++)														//searching for conference calls
				{
					if(gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallType[i]=SINGLE_VOICE_CALL;
				}
			}
			
			display_CallState();
			CallState_Request(Data_REQ,0);												//send call state
		}
	}
}

on envVar env_FSG_CCSplit4
{
byte i, ccsplitpossible, conference_active, conference_onhold, conference_partner;


//init lokal variables
	ccsplitpossible=0;
	conference_active=0;
	conference_onhold=0;
	conference_partner=0;
//********************
	
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && gCallType[4]==CONFERENCE_VOICE_CALL && (gCallState[4]==active || gCallState[4]==onhold)){
		//search for conference
		for(i=0;i<7;i++)
		{
			if(gCallType[i]==CONFERENCE_VOICE_CALL)											//if there is an conference
			{
				ccsplitpossible=1;
				conference_partner++;
				if(gCallState[i]==active)											//active conference
					conference_active=1;
				else if(gCallState[i]==onhold && conference_active==0)				//held conference
					conference_onhold=1;
				else
				{																//invalid call state for conference call
					write("FSG-Telephone env_FSG_CCSplit4: invalid call state for conferencecall, split not possible");
					ccsplitpossible=0;
					i=7;	
				}
			}
		}

		//check call states and call types 
		if(ccsplitpossible==1)														//if there is an active conference with valid call state
		{
			if(conference_onhold)													//held conference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==active)										//another active call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
			else																	//active coonference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==onhold)										//a held call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
		}
	

		if(ccsplitpossible==1)
		{
			conference_partner--;
			if(conference_onhold==TRUE)														//held conference
			{
				gCallState[4]=active;
				gCallType[4]=SINGLE_VOICE_CALL;
			}																		
			else																		//active conference		
			{
				gCallType[4]=SINGLE_VOICE_CALL;
				for(i=0;i<7;i++)														//searching for active calls
				{
					if(gCallState[i]==active && gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallState[i]=onhold;											//set call state

				}
			}

			if(conference_partner==1)													//after splitting only single call, no conference
			{
				for(i=0;i<7;i++)														//searching for conference calls
				{
					if(gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallType[i]=SINGLE_VOICE_CALL;
				}
			}
			
			display_CallState();
			CallState_Request(Data_REQ,0);												//send call state
		}
	}
}

on envVar env_FSG_CCSplit5
{
byte i, ccsplitpossible, conference_active, conference_onhold, conference_partner;


//init lokal variables
	ccsplitpossible=0;
	conference_active=0;
	conference_onhold=0;
	conference_partner=0;
//********************
	
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && gCallType[5]==CONFERENCE_VOICE_CALL && (gCallState[5]==active || gCallState[5]==onhold)){
		//search for conference
		for(i=0;i<7;i++)
		{
			if(gCallType[i]==CONFERENCE_VOICE_CALL)											//if there is an conference
			{
				ccsplitpossible=1;
				conference_partner++;
				if(gCallState[i]==active)											//active conference
					conference_active=1;
				else if(gCallState[i]==onhold && conference_active==0)				//held conference
					conference_onhold=1;
				else
				{																//invalid call state for conference call
					write("FSG-Telephone env_FSG_CCSplit0: invalid call state for conferencecall, split not possible");
					ccsplitpossible=0;
					i=7;	
				}
			}
		}

		//check call states and call types 
		if(ccsplitpossible==1)														//if there is an active conference with valid call state
		{
			if(conference_onhold)													//held conference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==active)										//another active call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
			else																	//active coonference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==onhold)										//a held call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
		}
	

		if(ccsplitpossible==1)
		{
			conference_partner--;
			if(conference_onhold==TRUE)														//held conference
			{
				gCallState[5]=active;
				gCallType[5]=SINGLE_VOICE_CALL;
			}																		
			else																		//active conference		
			{
				gCallType[5]=SINGLE_VOICE_CALL;
				for(i=0;i<7;i++)														//searching for active calls
				{
					if(gCallState[i]==active && gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallState[i]=onhold;											//set call state

				}
			}

			if(conference_partner==1)													//after splitting only single call, no conference
			{
				for(i=0;i<7;i++)														//searching for conference calls
				{
					if(gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallType[i]=SINGLE_VOICE_CALL;
				}
			}
			
			display_CallState();
			CallState_Request(Data_REQ,0);												//send call state
		}
	}
}

on envVar env_FSG_CCSplit6
{
byte i, ccsplitpossible, conference_active, conference_onhold, conference_partner;


//init lokal variables
	ccsplitpossible=0;
	conference_active=0;
	conference_onhold=0;
	conference_partner=0;
//********************
	
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && gCallType[6]==CONFERENCE_VOICE_CALL && (gCallState[6]==active || gCallState[6]==onhold)){
		//search for conference
		for(i=0;i<7;i++)
		{
			if(gCallType[i]==CONFERENCE_VOICE_CALL)											//if there is an conference
			{
				ccsplitpossible=1;
				conference_partner++;
				if(gCallState[i]==active)											//active conference
					conference_active=1;
				else if(gCallState[i]==onhold && conference_active==0)				//held conference
					conference_onhold=1;
				else
				{																//invalid call state for conference call
					write("FSG-Telephone env_FSG_CCSplit6: invalid call state for conferencecall, split not possible");
					ccsplitpossible=0;
					i=7;	
				}
			}
		}

		//check call states and call types 
		if(ccsplitpossible==1)														//if there is an active conference with valid call state
		{
			if(conference_onhold)													//held conference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==active)										//another active call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
			else																	//active coonference
			{
				for(i=0;i<7;i++)
				{
					if(gCallState[i]==onhold)										//a held call exists
						ccsplitpossible=0;											//CCSplit not possible
				}
			}
		}
	

		if(ccsplitpossible==1)
		{
			conference_partner--;
			if(conference_onhold==TRUE)														//held conference
			{
				gCallState[6]=active;
				gCallType[6]=SINGLE_VOICE_CALL;
			}																		
			else																		//active conference		
			{
				gCallType[6]=SINGLE_VOICE_CALL;
				for(i=0;i<7;i++)														//searching for active calls
				{
					if(gCallState[i]==active && gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallState[i]=onhold;											//set call state

				}
			}

			if(conference_partner==1)													//after splitting only single call, no conference
			{
				for(i=0;i<7;i++)														//searching for conference calls
				{
					if(gCallType[i]==CONFERENCE_VOICE_CALL)
						gCallType[i]=SINGLE_VOICE_CALL;
				}
			}
			
			display_CallState();
			CallState_Request(Data_REQ,0);												//send call state
		}
	}
}

CCSplit_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, callID, ccsplitpossible, conference_active, conference_onhold;

//init lokal variables
	callID=0xff;
	ccsplitpossible=Terror_noactivecall;
	conference_active=0;
	conference_onhold=0;
//********************

	

	switch (indication){
		case Processing_CNF:
			CCSplit_Request(Processing_REQ, 0);												//send Processing
		break;
		case StartResult_IND:
			if(gCCSplit_status!=0)															//method is still active
				CCSplit_Request(Error_REQ, Terror_datainvalid);
			else if(datalength!=4)															//datalength error
				CCSplit_Request(Error_REQ, Terror_datainvalid);								//send error-message to RNS
			else if(gCallActivity==NOCALL)													//CCSplit is impossible, no call
				CCSplit_Request(Error_REQ, Terror_nocall);									//send error-message to RNS
			else{
				gCCSplitCallID=Indication_array[3];
				if(gCallType[gCCSplitCallID]==CONFERENCE_VOICE_CALL && (gCallState[gCCSplitCallID]==active || gCallState[gCCSplitCallID]==onhold)){
					//search for conference
					for(i=0;i<7;i++){
						if(gCallType[i]==CONFERENCE_VOICE_CALL){										//if there is an conference
							ccsplitpossible=1;
							if(gCallState[i]==active)										//active conference
								conference_active=1;
							else if(gCallState[i]==onhold && conference_active==0)			//held conference
								conference_onhold=1;
							else{															//invalid call state for conference call
								write("FSG-Telephone env_FSG_CCSplit: invalid call state for conferencecall, split not possible");
								ccsplitpossible=Terror_unknownapllicationerror;
								i=7;	
							}
						}
					}

					//check call states and call types 
					if(ccsplitpossible==1){													//if there is an active conference with valid call state
						if(conference_onhold){												//held conference
							for(i=0;i<7;i++){
								if(gCallState[i]==active || gCallState[i]==dialing)			//another active call exists
									ccsplitpossible=Terror_activecallpresentdialing;		//CCSplit not possible
							}
						}
						else{																//active coonference
							for(i=0;i<7;i++){
								if(gCallState[i]==onhold)									//a held call exists
									ccsplitpossible=Terror_heldcallpresent;					//CCSplit not possible
							}
						}
					}				

			
					if(ccsplitpossible!=1)													//CCSplit is impossible
						CCSplit_Request(Error_REQ, ccsplitpossible);						//send error-message to RNS
					else{	
						gCCSplit_status=1;													//method "MPSwap" active
						settimer(CCSplitTimer, CCSplitTimerTime);
					}
				}				
				else
					CCSplit_Request(Error_REQ, Terror_nocallrelatedtoCallID);				//send error-message to RNS
			}
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone CCJoin_Indication: unknown indication %d", indication);
		break;
		}
}

CCSplit_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_CCSplit;			//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_CCSplit;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=gCCSplit_Result;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_CCSplit;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone CCSplit_Request: unknown request %d", request);
		break;
	}
}

on timer CCSplitTimer
{
byte i, conference_active, conference_onhold, conference_partner;


//init lokal variables
	conference_active=0;
	conference_onhold=0;
	conference_partner=0;
//********************
	
	for(i=0;i<7;i++)
	{
		if(gCallType[i]==CONFERENCE_VOICE_CALL)											//if there is an conference
		{
			if(gCallState[i]==active)											//active conference
				conference_active=1;
			else 
				conference_onhold=1;
			i=7;	
		}
	}

	//****CallState*******
	if(conference_onhold)														//held conference
	{
		gCallState[gCCSplitCallID]=active;
		gCallType[gCCSplitCallID]=SINGLE_VOICE_CALL;
		
	}																			//active conference
	else
		gCallType[gCCSplitCallID]=SINGLE_VOICE_CALL;
	
	for(i=0;i<7;i++)															//searching for conference calls
	{
		if(gCallType[i]==CONFERENCE_VOICE_CALL)
		{
			conference_partner++;												//increment number of conference partner
			if(gCallState[i]==active)
				gCallState[i]=onhold;											//set call state
		}
	}
	//********************

	//****CallType********
	if(conference_partner==1)													//searching for active calls
	{
		for(i=0;i<7;i++)
		{
			if(gCallType[i]==CONFERENCE_VOICE_CALL)
				gCallType[i]=SINGLE_VOICE_CALL;									//set call state
		}
	}
	//********************

	display_CallState();
	CallState_Request(Data_REQ,0);												//send call state
	CCSplit_Request(Result_REQ, 0);
	gCCSplit_status=0;															//method "CCSplit" finished
}

on timer disconnectingtimer2		//hangup all active or hold or actie and hold or all calls
{
byte i, callID, freeline, disconnected, callinfostart, callinfoelements, callinfochange [7];
char empty_string [3];


//init lokal variables
	i=0;
	callID=0xff;
	freeline=1;
	disconnected=0;
	callinfostart=0xff;
	callinfoelements=0;
	for(i=0;i<7;i++)
		callinfochange[i]=0;
	for(i=0;i<3;i++)
		empty_string[i]=0;
//********************

	for(callID=0;callID<7;callID++)
	{
		if(gCallState[callID]==disconnecting)
		{
			disconnected=1;
			callinfochange[callID]=1;
			if (gCallType[callID]==emergencycall && (gemergencycall==2 || gemergencycall==3))//disconnected emergency call
			{
				switch(gemergencycall)
				{
					case 2:
						gRegisterState=notregisterdandsearching;						//set register state
                        gNetworkType=UNKNOWN_NT;
                        gPacketDataNetworkType=NO_DATA_SERVICE;
					break;
					case 3:
						gRegisterState=notregisteredandnotsearching;					//set register state
                        gNetworkType=UNKNOWN_NT;
                        gPacketDataNetworkType=NO_DATA_SERVICE;
					break;
					default:
						write("error disconnectingtimer: invalid gemergencycall-value: %d",gemergencycall);
					break;
				}
			
				putvalue(env_FSG_RegisterState, gRegisterState);
                putvalue(env_FSG_NetworkType,gNetworkType);
                putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
				RegisterState_Request(Data_REQ, 0);										//send register state
				putvalue(env_FSG_NetworkProviderState, 0);									//delete network provider
				NetworkProvider_Request(Data_REQ, 0);									//send empty provider name
			}

			gemergencycall=0;

			//**********CallStates*****************
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,idle);
			//*************************************

			//call info
			for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
				gCallInfo_PbName[callID][i]=0;
			for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
				gCallInfo_TelNumber[callID][i]=0;
            
            //IssueList #206 -s
             for(i = 0; i < CALL_INFO_NAME_LENGTH; i++)
				gCallInfo_PbName_hex[callID][i] = 0;
             //IssueList #206 -e

            //changes from Jöran Karl (28.03.2012)
	        putvalue_CallInfo(callID);
		}
	}
    // changes from Jan Swoboda (01.03.2012)
    if (gCallStateRequestPending)
        CallState_Request(Data_REQ,0);

	if(disconnected==0)
	{																						//error, no disconected callID was found
		write("error disonnecting-timer, no disconnected call-id");
	}
	else
	{
		//CallInfo
		CallInfo_Request(Data_REQ,0);//callinfodelete_Request(Data_REQ, 0, 7, 1, 0);

		//Disconnect Reason
		for(i=0;i<7;i++)
		{
			if(gCallState[i]!=idle)
				freeline=0;
		}

		//changes from Jöran Karl (28.03.2012)
		if((freeline == 1) || (ghangupcall_status == 1))
		{
            //DisconnectReason & Result
            if (gActiveCall_BAPdelayFlag == 0x00)
            settimer(DisconnectReason_Timer, disconnectreasontime);
            else
            settimer(DisconnectReason_Timer, 10);

            

		}
	}
}

RestoreFactorySettings_Indication(dword Indication_array [], byte indication, int datalength)
{

	switch (indication){
		case Processing_CNF:
			RestoreFactorySettings_Request(Processing_REQ, 0);									//send Processing
		break;
		case StartResult_IND:
			if(gRestoreFactorySettings_status!=0)
				RestoreFactorySettings_Request(Error_REQ, Terror_unknownapllicationerror);		//send error-message to RNS
			else if(datalength!=4)																//datalength error
				RestoreFactorySettings_Request(Error_REQ, Terror_unknownapllicationerror);		//send error-message to RNS
			else if(Indication_array[3]!=1)														//accept call impossible
				RestoreFactorySettings_Request(Error_REQ, Terror_unknownapllicationerror);		//send error-message to RNS
			else{	
				gRestoreFactorySettings_status=1;												//method active
				settimer(RestoreFactorySettingsTimer, RestoreFactorySettingsTimerTime);
			}
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone RestoreFactorySettings_Indication: unknown indication %d", indication);
		break;
		}
}

RestoreFactorySettings_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;					//LSG-ID
			requestarray[1]=FctID_RestoreFactorySettings;		//Fct.-ID
			requestarray[2]=request;
			Offset=3;
			set_status_requestbuffer (requestarray, Offset, Bap_Void);
		break;
		case Result_REQ:
			requestarray[0]=LSGID_Telephone;				//LSG-ID
			requestarray[1]=FctID_RestoreFactorySettings;	//Fct.-ID
			requestarray[2]=request;
			Offset=3;
			set_status_requestbuffer (requestarray, Offset, Bap_Void);
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;				//LSG-ID
			requestarray[1]=FctID_RestoreFactorySettings;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone RestoreFactorySettings_Request: unknown request %d", request);
		break;
	}
}

on timer RestoreFactorySettingsTimer
{
	if(getvalue(env_FSG_Restore_PhoneOne))					//method finished successfull
		RestoreFactorySettings_Request(Result_REQ, 0);
	else													//method finshed not successfull
		RestoreFactorySettings_Request(Error_REQ, Terror_unknownapllicationerror);
			
	gRestoreFactorySettings_status=0;										//method finished
}

PhoneOnOff_Indication(dword Indication_array [], byte indication, int datalength)
{

	switch (indication){
		case Processing_CNF:
			PhoneOnOff_Request(Processing_REQ, 0);									//send Processing
		break;
		case StartResult_IND:
			if(gPhoneOnOff_status!=0)
				PhoneOnOff_Request(Error_REQ, Terror_unknownapllicationerror);		//send error-message to RNS
			else if(datalength!=4)																//datalength error
				PhoneOnOff_Request(Error_REQ, Terror_unknownapllicationerror);		//send error-message to RNS
			else if(Indication_array[3]>1)														//accept call impossible
				PhoneOnOff_Request(Error_REQ, Terror_unknownapllicationerror);		//send error-message to RNS
			else	
			{
				gPhoneOnOff_mode=Indication_array[3];
				gPhoneOnOff_status=1;												//method "acceptcal" active
				settimer(PhoneOnOffTimer, PhoneOnOffTimerTime);
			}
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone PhoneOnOff_Indication: unknown indication %d", indication);
		break;
		}
}

PhoneOnOff_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;					//LSG-ID
			requestarray[1]=FctID_PhoneOnOff;					//Fct.-ID
			requestarray[2]=request;
			Offset=3;
			set_status_requestbuffer (requestarray, Offset, Bap_Void);
		break;
		case Result_REQ:
			requestarray[0]=LSGID_Telephone;				//LSG-ID
			requestarray[1]=FctID_PhoneOnOff;				//Fct.-ID
			requestarray[2]=request;
			Offset=3;
			set_status_requestbuffer (requestarray, Offset, Bap_Void);
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;				//LSG-ID
			requestarray[1]=FctID_PhoneOnOff;				//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone PhoneOnOff_Request: unknown request %d", request);
		break;
	}
}

on timer PhoneOnOffTimer
{
int i;

	if(getvalue(env_FSG_Restore_PhoneOne))											//method finished successful
	{
		if(SHUTDOWN==gPhoneOnOff_mode)												//switch GSM-module off
		{	
			//OpState
			gTel_State=PhoneModuleOff;
			putvalue(env_FSG_Tel_State, gTel_State);
			FSG_OperationState_Request(Data_REQ, 0);

			if(gCallActivity!=0)													//singel or multipaty call active
				Kill_Bill_Vol1();													//kill all calls

			//RegisterState
			gRegisterState=notregisteredandnotsearching;
            gNetworkType=UNKNOWN_NT;
            gPacketDataNetworkType=NO_DATA_SERVICE;
			putvalue(env_FSG_RegisterState, gRegisterState);
            putvalue(env_FSG_NetworkType,gNetworkType);
            putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
			RegisterState_Request(Data_REQ, 0);
			
			//NetworkProvider
			for(i=0;i<40;i++)
				gNetworkProviderName[i]=0;
            putvalue(env_FSG_NetworkProviderName,gNetworkProviderName);            
			gNetworkProviderState=0;
			putvalue(env_FSG_NetworkProviderState,gNetworkProviderState);
            for(i=0;i<40;i++)
				gServiceProviderName[i]=0;
            putvalue(env_FSG_ServiceProviderName,gServiceProviderName);            
			gServiceProviderState=0;
			putvalue(env_FSG_ServiceProviderState,gServiceProviderState);
			NetworkProvider_Request(Data_REQ, 0);
			
            //changes from Jöran Karl (28.03.2012)
	    if(getvalue(env_FSG_DisconnectReason_Active) != FALSE)
            {
    			//DisconnectReason
    			gDisconnectReason=regulardisconnecting;
    			putvalue(env_FSG_DisconnectReason, gDisconnectReason);
            }
		}

		else if(STARTUP==gPhoneOnOff_mode)
		{
			//OpState
			gTel_State=PhoneModuleOn;
			putvalue(env_FSG_Tel_State, gTel_State);
			FSG_OperationState_Request(Data_REQ, 0);

			//RegisterState
			gRegisterState=notregisterdandsearching;
            gNetworkType=UNKNOWN_NT;
            gPacketDataNetworkType=NO_DATA_SERVICE;
			putvalue(env_FSG_RegisterState, gRegisterState);
            putvalue(env_FSG_NetworkType,gNetworkType);
            putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);
			RegisterState_Request(Data_REQ, 0);
		}

		PhoneOnOff_Request(Result_REQ, 0);
	}
	else													//method finshed not successful
		PhoneOnOff_Request(Error_REQ, Terror_unknownapllicationerror);

	gPhoneOnOff_status=0;										//method "acceptcal" finished
}

on envVar env_FSG_MP_RACAWC
{
byte i, callID, mpracawcpossible;


//init lokal variables
	callID=0xff;
	mpracawcpossible=0;
//********************
	
	//search for active calls 
	for(i=0;i<7;i++)
	{
		if(gCallState[i]==active)
			mpracawcpossible=1;
	}
	
	//search for waiting calls
	if(mpracawcpossible==1)										// if there are active calls
	{
		mpracawcpossible=0;
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==ringing_waiting)
				mpracawcpossible=1;
		}
	}

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && mpracawcpossible==1)
	{
		for(i=0;i<7;i++)																//searching for active calls
		{
			if(gCallState[i]==active)
			{
				callID=i;
				// changes from Jan Swoboda (01.03.2012)
				set_CallState_noReq(callID,disconnecting);										//set call state
			}
		}
        if (gCallStateRequestPending)
            CallState_Request(Data_REQ,0);

        settimer(MPRACAWCTimer, MPRACAWCTimerTime);
	}
}

on timer MPRACAWCTimer
{
byte i, callID, hangups, hangupid;
char empty_string [3];

//init lokal variables
	callID=0xff;
	hangups=0;
	hangupid=0;
	for(i=0;i<3;i++)
		empty_string[i]=0;
//********************
	
	
	for(callID=0;callID<7;callID++){										//searching for active calls
		if(gCallState[callID]==disconnecting){
			hangups++;
			hangupid=callID;
            // changes from Jan Swoboda (01.03.2012)
	    set_CallState_noReq(callID,idle);
		//**********call info******************
			for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
				gCallInfo_PbName[callID][i]=0;
			for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
				gCallInfo_TelNumber[callID][i]=0;
            
            //IssueList #206 -s
            for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
				gCallInfo_PbName_hex[callID][i] = 0;
            //IssueList #206 -e

            //changes from Jöran Karl (28.03.2012)
	    putvalue_CallInfo(callID);
		//*************************************
		}
		else if(gCallState[callID]==ringing_waiting){
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,active);										//set call state
		}
	}
    // changes from Jan Swoboda (01.03.2012)
    if (gCallStateRequestPending)
        CallState_Request(Data_REQ,0);
	
    // changes from Jan Swoboda (01.03.2012)
    // JanSwo 20120110
    //MR 63665 - if condition

    if (gHookTasteFlag_MPRACAWC == 0)
    CallInfo_Request(Data_REQ,0);

    if (gHookTasteFlag_MPRACAWC ==1)
    gHookTasteFlag_MPRACAWC =0;
    

	if(gMPRACAWC_status)
    {   //IssueList #26
        gMPRACAWC_Result = SUCCESSFUL;
		
        MPRACAWC_Request(Result_REQ, 0);
		gMPRACAWC_status=0;
	}

}

MPRACAWC_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request)
	{
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;								//LSG-ID
			requestarray[1]=FctID_MPReleaseActiveCallAcceptWaitingCall;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68

			requestarray[0]=LSGID_Telephone;								//LSG-ID
			requestarray[1]=FctID_MPReleaseActiveCallAcceptWaitingCall;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=gMPRACAWC_Result;
			Offset=4;
            
            //MR 60227 - BAP_MOST delay timer
            //if (gTelFctList_0x23_Processing_flg == 0x00 && getValue(env_PIC_bapMOST_active_flag) == 0x00)
            if (gTelFctList_0x23_Processing_flg == 0x00)
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);

            /*else if (getValue(env_PIC_bapMOST_active_flag) == 0x01)
            {
                if (getValue(env_AudioTel_bapMost_delayTimer) > 0)
                {
                    for (i=0;i<4;i++)
                    gTel_Requestarray[i]=0;
                    
                    for (i=0;i<4;i++)
                    gTel_Requestarray[i]=requestarray[i];
                gTel_Offset = Offset;
                setTimer(_tMostF_delayTime,getValue(env_AudioTel_bapMost_delayTimer));
                }

                else
                set_status_requestbuffer (requestarray, Offset, Bap_UInt8);

            }*/

		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;								//LSG-ID
			requestarray[1]=FctID_MPReleaseActiveCallAcceptWaitingCall;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x23_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone MPRACAWC_Request: unknown request %d", request);
		break;
	}
}

MPRACAWC_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, callID, mpracawcpossible;
//MR63665
byte mpracawcCallActivity=0;


//init lokal variables
	callID=0xff;
	mpracawcpossible=Terror_noactivecall;

    //MR63665
    mpracawcCallActivity =0;

//********************

	//search for active calls 
	for(i=0;i<7;i++)
	{
		if(gCallState[i]==active)
			mpracawcpossible=Terror_noincomingwaitingcall;
	}
	
	//search for waiting calls
	if(mpracawcpossible==Terror_noincomingwaitingcall)									// if there are active calls
	{
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==ringing_waiting)
				mpracawcpossible=1;
		}
	}

//IssueList #26
 if (getValue(env_FSG_MPRACAWC_Result)==0x00)	
	mpracawcpossible=1;
else
   mpracawcpossible=0;

    switch (indication)
	{
		case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_FSG_Tel_MPRACAWC_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_MPRACAWC_ErrorCode) > 0x3F)) &&  (gTelFctList_0x23_TimeOut_flg == 0x00))
            {
            MPRACAWC_Request(Processing_REQ, 0);											//send Processing
		       
                //IssueList #68
                if (gTelFctList_0x23_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x23_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x23_ProcessingTimer,TELMAXPROCESSINGTIME);

                MPRACAWC_Request(Processing_REQ, 0);
                }
            }
        break;
		case StartResult_IND:
			 //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x23_TimeOut)!=TRUE)
            {
             gTelFctList_0x23_TimeOut_flg = 0x00;

                //MR 63665  16.07.2014  -s
                mpracawcCallActivity = gCallActivity;

                if (getValue(env_FSG_CallState_CallID_0_set)!=0x00 || getValue(env_FSG_CallState_CallID_1_set)!=0x00 ||
                getValue(env_FSG_CallState_CallID_2_set)!=0x00 || getValue(env_FSG_CallState_CallID_3_set)!=0x00 ||
                getValue(env_FSG_CallState_CallID_4_set)!=0x00 || getValue(env_FSG_CallState_CallID_5_set)!=0x00 ||
                getValue(env_FSG_CallState_CallID_6_set)!=0x00)
                gHookTasteFlag_MPRACAWC = 1;
                

                if (gHookTasteFlag_MPRACAWC == 1 && gCallActivity ==NOCALL)
                gCallActivity = SINGLECALL;
                 //MR 63665  16.07.2014  -e

                //IssueList #57
                if (getValue(env_FSG_Tel_MPRACAWC_Error_On)==0x00)
                putValue(env_FSG_Tel_MPRACAWC_ErrorCode,0);

                //IssueList #47
                if (getValue(env_FSG_Tel_MPRACAWC_Error_On))
                    MPRACAWC_Request(Error_REQ, getValue(env_FSG_Tel_MPRACAWC_ErrorCode)); // send error-message
            
                else if(gMPRACAWC_status!=0)															//method is still active
    				MPRACAWC_Request(Error_REQ, Terror_unknownapllicationerror);
    			else if(datalength!=3)															//datalength error
    				MPRACAWC_Request(Error_REQ, Terror_unknownapllicationerror);				//send error-message to RNS
    			else if(gCallActivity==NOCALL)													//MPRACAWC is impossible, no call
    				MPRACAWC_Request(Error_REQ, Terror_nocall);									//send error-message to RNS
    			else if(mpracawcpossible!=1)													//MPRACAWC is impossible
    				//IssueList #26
                    {
                    gMPRACAWC_Result=getValue(env_FSG_MPRACAWC_Result);							                         //send error-message to RNS
                    MPRACAWC_Request(Result_REQ, mpracawcpossible);
                    }
                    // MPRACAWC_Request(Error_REQ, mpracawcpossible);								//send error-message to RNS
    			else
    			{	
    				gMPRACAWC_status=1;															//method "MPRACAWC" active
    				for(i=0;i<7;i++)															//searching for active calls
    				{
    					if(gCallState[i]==active)
    					{
    						callID=i;
    						// changes from Jan Swoboda (01.03.2012)
    						set_CallState_noReq(callID,disconnecting);										//set call state
    					}
    				}
                    // changes from Jan Swoboda (01.03.2012)
            		if (gCallStateRequestPending)
                    CallState_Request(Data_REQ,0);
		
    				settimer(MPRACAWCTimer, MPRACAWCTimerTime);
    			}
            //MR 63665
                gCallActivity = mpracawcCallActivity;

            } //IssueList #74
            else
            gTelFctList_0x23_TimeOut_flg = 0x01;
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone MPRACAWC_Indication: unknown indication %d", indication);
		break;
		}
}

on envVar env_FSG_Keypad_Inforuf_short
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this)){
		gKeypadStatus=0x01;
		if(gKeypadTimer_status){
			canceltimer(KeypadTimer);
			settimer(KeypadTimer, KeypadTimerTime);
		}
		else{
			settimer(KeypadTimer, KeypadTimerTime);
			gKeypadTimer_status=1;
		}
		Keypad_Request(Data_REQ, 0);
	}

}

Keypad_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Data_REQ:
             //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x2A_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_Keypad;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gKeypadStatus;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_Keypad;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone Keypad_Request: unknown request %d", request);
		break;
	}
}

Keypad_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			if(datalength!=3)												//datalength error
				Keypad_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				Keypad_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone Keypad: unknown indication %d", indication);
		break;
	}
}

on timer KeypadTimer
{
	gKeypadStatus=0;
	Keypad_Request(Data_REQ, 0);

}

on envVar env_FSG_Keypad_Inforuf_long
{
int i;

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this)){
		gKeypadStatus=0x02;
		if(gKeypadTimer_status){
			canceltimer(KeypadTimer);
			settimer(KeypadTimer, KeypadTimerTime);
		}
		else{
			settimer(KeypadTimer, KeypadTimerTime);
			gKeypadTimer_status=1;
		}
		Keypad_Request(Data_REQ, 0);

//		if(gDialNumber_status==0)
//		{
//			for(i=0;i<40;i++)												//delete dial-number array
//				gDialNumber[i]=0;
//			for(i=0;i<50;i++)												//delete dial-number-name array
//				gDialNumber_name[i]=0;
//		
//			gcallID=callstates_status(dialing);								//aks for free Call-ID
//		//	write("FSG-Telephone dialnumber CallID: %d", gcallID);				//debug
//		
//			if(gRegisterState==1 && gcallID!=0xff)
//			{
//				strncpy(gDialNumber, info, 40);
//				strncpy(gDialNumber_name, info_pbname, 50);
//				gdialnumber_numbertype=infocall;
//						
//				putvalue(env_FSG_dialednumber_name, gDialNumber_name);				//write name of dialed number in callstack
//				putvalue(env_FSG_dialednumber_numbertype, gdialnumber_numbertype);	//write numbertype of dialed number in callstack
//				putvalue(env_FSG_dialednumber_callstack, gDialNumber);				//write dialed number in callstack
//				settimer(checknetworktimer, gtime_checknetworktimer);
//			}
//		}
	}
}

on envVar env_FSG_Keypad_Pannenruf_short
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this)){
		gKeypadStatus=0x04;
		if(gKeypadTimer_status){
			canceltimer(KeypadTimer);
			settimer(KeypadTimer, KeypadTimerTime);
		}
		else{
			settimer(KeypadTimer, KeypadTimerTime);
			gKeypadTimer_status=1;
		}
		Keypad_Request(Data_REQ, 0);
	}

}

on envVar env_FSG_Keypad_Pannenruf_long
{
int i;

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this)){
		gKeypadStatus=0x08;
		if(gKeypadTimer_status){
			canceltimer(KeypadTimer);
			settimer(KeypadTimer, KeypadTimerTime);
		}
		else{
			settimer(KeypadTimer, KeypadTimerTime);
			gKeypadTimer_status=1;
		}
		Keypad_Request(Data_REQ, 0);

//		if(gDialNumber_status==0)
//		{
//			for(i=0;i<40;i++)												//delete dial-number array
//				gDialNumber[i]=0;
//			for(i=0;i<50;i++)												//delete dial-number-name array
//				gDialNumber_name[i]=0;
//		
//			gcallID=callstates_status(dialing);							//aks for free Call-ID
//		//	write("FSG-Telephone dialnumber CallID: %d", gcallID);				//debug
//		
//			if(gRegisterState==1 && gcallID!=0xff)
//			{
//				strncpy(gDialNumber, service, 40);
//				strncpy(gDialNumber_name, service_pbname, 50);
//				gdialnumber_numbertype=servicecall;
//			
//				putvalue(env_FSG_dialednumber_name, gDialNumber_name);				//write name of dialed number in callstack
//				putvalue(env_FSG_dialednumber_numbertype, gdialnumber_numbertype);	//write numbertype of dialed number in callstack
//				putvalue(env_FSG_dialednumber_callstack, gDialNumber);				//write dialed number in callstack
//				settimer(checknetworktimer, gtime_checknetworktimer);
//			}
//		}
	}

}

CallStackDeleteAll_Indication(dword Indication_array [], byte indication, int datalength)
{

	switch(indication){
		case Processing_CNF:
			CallStackDeleteAll_Request(Processing_REQ, 0);											//send Processing
		break;
		case StartResult_IND:
			if(gCallStackDeleteAll_status!=0)
				CallStackDeleteAll_Request(Error_REQ, Terror_unknownapllicationerror);				//send error-message to RNS
			else if(datalength!=4)
				CallStackDeleteAll_Request(Error_REQ, Terror_unknownapllicationerror);				//send error-message to RNS
			else if(Indication_array[3]>7 || Indication_array[3]==0)
				CallStackDeleteAll_Request(Error_REQ, Terror_unknownapllicationerror);				//send error-message to RNS
			else{
				gCallStackDeleteAllStorage=Indication_array[3];
				gCallStackDeleteAll_status=1;														//method vCalendarSend active
				settimer(CallStackDeleteAllTimer, CallStackDeleteAllTimerTime);
			}
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone CallStackDeleteAll_Indication: unknown indication %d", indication);
		break;
	}
}

CallStackDeleteAll_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Phonebook;			//LSG-ID
			requestarray[1]=FctID_CallStackDeleteAll;	//Fct.-ID
			requestarray[2]=request;
			Offset=3;
			set_status_requestbuffer (requestarray, Offset, Bap_Void);
		break;
		case Result_REQ:
			requestarray[0]=LSGID_Phonebook;			//LSG-ID
			requestarray[1]=FctID_CallStackDeleteAll;	//Fct.-ID
			requestarray[2]=request;
			Offset=3;
			set_status_requestbuffer (requestarray, Offset, Bap_Void);
		break;
		case Error_REQ:	
			requestarray[0]=LSGID_Phonebook;			//LSG-ID
			requestarray[1]=FctID_CallStackDeleteAll;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone CallStackDeleteAll_Request: unknown request %d",request );
		break;
	}
}

on timer CallStackDeleteAllTimer
{/*
int i, j;

char empty_string[3];
	
//init lokal variables
	for(i=0;i<3;i++)
		empty_string[i]=0;
//********************


	


	if(gCallStackDeleteAllStorage==1 || gCallStackDeleteAllStorage==3 || gCallStackDeleteAllStorage==5 || gCallStackDeleteAllStorage==7){
	//delete missed calls
		for(j=0;j<CALLSTACK;j++){
			for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
				gmissedcalls_pbname[j][i]=0;									//delete PbName
			for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
				gmissedcalls_telnumber[j][i]=0;									//delete TelNumber
			for(i=0;i<7;i++){
				gmissedcalls_date[j][i]=0;										//delete Date
				gmissedcalls_time[j][i]=0;										//delete Time
			}
			
			gmissedcalls_numbertype[j]=0xff;									//delete NumberType
		}
		
		display_callstack_missedcalls();
		MissedCalls_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);
	}

	if(gCallStackDeleteAllStorage==2 || gCallStackDeleteAllStorage==3 || gCallStackDeleteAllStorage==6 || gCallStackDeleteAllStorage==7){
	//delete received calls
		for(j=0;j<CALLSTACK;j++){
			for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
				greceivedcalls_pbname[j][i]=0;									//delete PbName
			for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
				greceivedcalls_telnumber[j][i]=0;								//delete TelNumber
			for(i=0;i<7;i++){
				greceivedcalls_date[j][i]=0;									//delete Date
				greceivedcalls_time[j][i]=0;									//delete Time
			}
			
			display_callstack_receivedcalls();
			greceivedcalls_numbertype[j]=0xff;									//delete NumberType
		}
		
		receivedcalls_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);
	}

	if(gCallStackDeleteAllStorage==4 || gCallStackDeleteAllStorage==5 || gCallStackDeleteAllStorage==6 || gCallStackDeleteAllStorage==7){
	//delete dialednumbers
		for(j=0;j<CALLSTACK;j++){
			for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
				gdialednumbers_pbname[j][i]=0;									//delete PbName
			for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
				gdialednumbers_telnumber[j][i]=0;								//delete TelNumber
			for(i=0;i<7;i++){
				gdialednumbers_date[j][i]=0;									//delete Date
				gdialednumbers_time[j][i]=0;								//delete Time
			}
			
			gdialednumbers_numbertype[j]=0xff;	//delete NumberType
		}
		
		display_callstack_dialednumbers();
		dialednumbers_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);
	}
	
	CallStackDeleteAll_Request(Result_REQ, 0);
	gCallStackDeleteAll_status=0;
	gCallStackDeleteAllStorage=0;*/
}

SMSState_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************
	
	switch(request){
		case Data_REQ:
             //IssueList #62
    			if (getValue(env_FSG_Tel_FctList_0x37_TimeOut)!=TRUE)
                {
    			requestarray[0]=LSGID_Telephone;	//LSG-ID
    			requestarray[1]=FctID_SMSState;		//Fct.-ID
    			requestarray[2]=request;	
	
    			requestarray[3]=gSIMReady;						
    			requestarray[4]=gStorageState;					
    			requestarray[5]=gNumberOfNewSMS & 0x00ff;		//Lowbyte of NumberOfNewSMS
    			requestarray[6]=(gNumberOfNewSMS & 0xff00)/0x100;//Highbyte of NumberOfNewSMS

    			Offset=7;		
    			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_SMSState;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone SMSState_Request: invalid request %d", request);
		break;
	}
}

SMSState_Indication (dword Indication_array [], byte indication, int datalength)
{

int NumberOfNewSMS;

//init lokal variables
	NumberOfNewSMS=0;
//********************
	
	
	switch(indication){
		case DataSetGet_IND:
			//check BAP-array
			//***attention, changes in new version of Fct-cat.***
			if(datalength!=7)														//datalength error
				SMSState_Request(Error_REQ, Terror_unknownapllicationerror);		//send error-message to RNS
			//else if(ActiveUserValidation()!=1 || gSIMReady==FALSE)			//no active User available or SIM data not available
			//	SMSState_Request(Error_REQ, Terror_unknownapllicationerror);		//send error-message to RNS
			else{
			//***attention, changes in new version of Fct-cat.***
				NumberOfNewSMS=Indication_array[5]+Indication_array[6]*0x100;
				if(NumberOfNewSMS!=0)										//invalid value for setget
					SMSState_Request(Error_REQ, Terror_datainvalid);				//send error-message to RNS
				else{
					gNumberOfNewSMS=0;
					putvalue(env_FSG_NumberOfNewSMS, gNumberOfNewSMS);
					SMSState_Request(Data_REQ, 0);									//send data to RNS	
				}
			//***************************************************
			}
		break;
		case DataGet_IND:
			//check BAP-array
			if(datalength!=3)														//datalength error
				SMSState_Request(Error_REQ, Terror_unknownapllicationerror);		//send error-message to RNS
			else
				SMSState_Request(Data_REQ, 0);										//send data to RNS
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone SMSState_Indication: invalid indication %d", indication);
		break;
		}		
}

on envVar env_FSG_SMSState_OK
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
		gSIMReady=getvalue(env_FSG_SIMReady);
		gStorageState=getvalue(env_FSG_StorageState);
		gNumberOfNewSMS=getvalue(env_FSG_NumberOfNewSMS);
		
		SMSState_Request(Data_REQ, 0);
	}
}

display_CallState ()
{
int i;
char empty_string [3];

//init lokal variables
	for(i=0;i<3;i++)
		empty_string[i]=0;
//********************

	putvalue(env_FSG_CallState_CallID_0, gstring_callstate[gCallState[0]]);
	if(gCallState[0]!=idle)
		putvalue(env_FSG_CallType_CallID_0, gstring_calltype[gCallType[0]]);
	else
		putvalue(env_FSG_CallType_CallID_0, empty_string);
	
	putvalue(env_FSG_CallState_CallID_1, gstring_callstate[gCallState[1]]);
	if(gCallState[1]!=idle)
		putvalue(env_FSG_CallType_CallID_1, gstring_calltype[gCallType[1]]);
	else
		putvalue(env_FSG_CallType_CallID_1, empty_string);
	
	putvalue(env_FSG_CallState_CallID_2, gstring_callstate[gCallState[2]]);
	if(gCallState[2]!=idle)
		putvalue(env_FSG_CallType_CallID_2, gstring_calltype[gCallType[2]]);
	else
		putvalue(env_FSG_CallType_CallID_2, empty_string);
	
	putvalue(env_FSG_CallState_CallID_3, gstring_callstate[gCallState[3]]);
	if(gCallState[3]!=idle)
		putvalue(env_FSG_CallType_CallID_3, gstring_calltype[gCallType[3]]);
	else
		putvalue(env_FSG_CallType_CallID_3, empty_string);
	
	putvalue(env_FSG_CallState_CallID_4, gstring_callstate[gCallState[4]]);
	if(gCallState[4]!=idle)
		putvalue(env_FSG_CallType_CallID_4, gstring_calltype[gCallType[4]]);
	else
		putvalue(env_FSG_CallType_CallID_4, empty_string);
	
	putvalue(env_FSG_CallState_CallID_5, gstring_callstate[gCallState[5]]);
	if(gCallState[5]!=idle)
		putvalue(env_FSG_CallType_CallID_5, gstring_calltype[gCallType[5]]);
	else
		putvalue(env_FSG_CallType_CallID_5, empty_string);
	
	putvalue(env_FSG_CallState_CallID_6, gstring_callstate[gCallState[6]]);
	if(gCallState[6]!=idle)
		putvalue(env_FSG_CallType_CallID_6, gstring_calltype[gCallType[6]]);
	else
		putvalue(env_FSG_CallType_CallID_6, empty_string);
}

on envVar env_FSG_ChargeLevelH1_Init
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
	   //IssueList #164 - remove if condition
      // if(getvalue(env_FSG_ChargeLevelH1)>=101 && getvalue(env_FSG_ChargeLevelH1)<=253)              //Value between 100 and 254
       //     gChargeLevelHandset1=100;                               //Set level to 100%
        //else
            gChargeLevelHandset1=getvalue(env_FSG_ChargeLevelH1);                    //Set level by value

        putvalue(env_FSG_ChargeLevelH1,gChargeLevelHandset1);
    }
}

on envVar env_FSG_RegisterState_OK
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
        //IssueList #25
        gRegisterState  =  getvalue(env_FSG_RegisterState);
        gNetworkType    =  getValue(env_FSG_NetworkType);
        gPacketDataNetworkType = getValue(env_FSG_PacketDataNetworkType);
        RegisterState_Request(Data_REQ, 0);
        //IssueList #25
        /*if(gRegisterState==registered || gRegisterState==registeredandroaming || gRegisterState==registeredandroamingalternative)
        //{
            gNetworkType=getvalue(env_FSG_NetworkType);
            switch(gNetworkType)
            {
                case UNKNOWN_NT:
                    gPacketDataNetworkType=NO_DATA_SERVICE;
                    break;
                case GSM:
                    if(getvalue(env_FSG_PacketDataNetworkType)==GSM_GPRS || getvalue(env_FSG_PacketDataNetworkType)==GSM_EDGE || getvalue(env_FSG_PacketDataNetworkType)==NO_DATA_SERVICE)
                        gPacketDataNetworkType=getvalue(env_FSG_PacketDataNetworkType); 
                   else                                        //PacketDataNetworkType is HSDPA/HSUPA
                        gPacketDataNetworkType=NO_DATA_SERVICE; //Not available for GSM
                break;
                case UMTS:
                    if(getvalue(env_FSG_PacketDataNetworkType)==HSDPA || getvalue(env_FSG_PacketDataNetworkType)==HSUPA ||getvalue(env_FSG_PacketDataNetworkType)==NO_DATA_SERVICE)
                        gPacketDataNetworkType=getvalue(env_FSG_PacketDataNetworkType); 
                    else                                        //PacketDataNetworkType is GSM-GPRS/GSM-EDGE
                        gPacketDataNetworkType=NO_DATA_SERVICE; //Not available for UMTS
                break;
                case CDMA:
                    if(getvalue(env_FSG_PacketDataNetworkType)==HSDPA || getvalue(env_FSG_PacketDataNetworkType)==HSUPA ||getvalue(env_FSG_PacketDataNetworkType)==NO_DATA_SERVICE)
                        gPacketDataNetworkType=getvalue(env_FSG_PacketDataNetworkType); 
                    else                                        //PacketDataNetworkType is GSM-GPRS/GSM-EDGE
                        gPacketDataNetworkType=NO_DATA_SERVICE; //Not available for CDMA
              
                break;
            }
        //}
        //else        //not registered, registration denied or function not supported by ME
        //{
            //gNetworkType=UNKNOWN_NT;
            
            //gPacketDataNetworkType=NO_DATA_SERVICE;
            
        //}
        putvalue(env_FSG_NetworkType,gNetworkType);
        putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);*/
        //

        //if(gRegisterState==0)
	    //	EnableControl("FSG-Telephone", "FSG-Telephone_networkprovider", 0);
	    //else	
        //	EnableControl("FSG-Telephone", "FSG-Telephone_networkprovider", 1);
	
    //IssueList #26 - CANoe crash
    gFirstPress = 0x00;  

    }

}

on envVar env_FSG_MP_RAllCAWC
{
byte i, callID, mprallcawcpossible;

//init lokal variables
	callID=0xff;
	mprallcawcpossible=0;
//********************
	
	//search for available calls 
	for(i=0;i<7;i++)
	{
		if(gCallState[i]!=idle && gCallState[i]!=ringing_waiting)
			mprallcawcpossible=1;
	}
	
	//search for waiting calls
	if(mprallcawcpossible==1)										// if there are active calls
	{
		mprallcawcpossible=0;
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==ringing_waiting)
				mprallcawcpossible=1;
		}
	}

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && mprallcawcpossible==1)
	{
		for(i=0;i<7;i++)																//searching for active calls
		{
			if(gCallState[i]!=idle && gCallState[i]!=ringing_waiting)
			{
				callID=i;
				// changes from Jan Swoboda (01.03.2012)
				set_CallState_noReq(callID,disconnecting);										//set call state
			}
		}
        // changes from Jan Swoboda (01.03.2012)
	if (gCallStateRequestPending)
            CallState_Request(Data_REQ,0);
		
        settimer(MPRAllCAWCTimer, MPRAllCAWCTimerTime);
	}
}

on timer MPRAllCAWCTimer
{
byte i, callID, hangups, hangupid;
char empty_string [3];

//init lokal variables
	callID=0xff;
	hangups=0;
	hangupid=0;
	for(i=0;i<3;i++)
		empty_string[i]=0;
//********************
	
	
	for(callID=0;callID<7;callID++){										//searching for active calls
		if(gCallState[callID]==disconnecting){
			hangups++;
			hangupid=callID;
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,idle);
		//**********call info******************
			for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
				gCallInfo_PbName[callID][i]=0;
			for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
				gCallInfo_TelNumber[callID][i]=0;
             
             //IssueList #206 -s
            for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
				gCallInfo_PbName_hex[callID][i] = 0;
            //IssueList #206 -e            

            //changes from Jöran Karl (28.03.2012)
	    putvalue_CallInfo(callID);
		//*************************************
		}
		else if(gCallState[callID]==ringing_waiting){
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,active);										//set call state
		}
	}
    // changes from Jan Swoboda (01.03.2012)
    if (gCallStateRequestPending)
        CallState_Request(Data_REQ,0);
	
    // changes from Jan Swoboda (01.03.2012)
    // JanSwo 20120110
    CallInfo_Request(Data_REQ,0);

	if(gMPRAllCAWC_status){
		MPRAllCAWC_Request(Result_REQ, 0);
		gMPRAllCAWC_status=0;
	}

}

MPRAllCAWC_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, callID, mprallcawcpossible;

//init lokal variables
	callID=0xff;
	mprallcawcpossible=Terror_nocall;
//********************

	//search for active calls 
	for(i=0;i<7;i++)
	{
		if(gCallState[i]!=idle && gCallState[i]!=ringing_waiting)
			mprallcawcpossible=Terror_noincomingwaitingcall;
	}
	
	//search for waiting calls
	if(mprallcawcpossible==Terror_noincomingwaitingcall)									// if there are active calls
	{
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==ringing_waiting)
				mprallcawcpossible=1;
		}
	}

//IssueList #26
 if (getValue(env_FSG_MPRACAWC_Result)==0x00)	
	mprallcawcpossible=1;
else
   mprallcawcpossible=0;

	switch (indication)
	{
		case Processing_CNF:
			//IssueList #57  and #74
           if (((getValue(env_FSG_Tel_MPRAllCAWC_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_MPRAllCAWC_ErrorCode) > 0x3F)) &&  (gTelFctList_0x26_TimeOut_flg == 0x00))
			{
            MPRAllCAWC_Request(Processing_REQ, 0);											//send Processing
		        
                //IssueList #68
                if (gTelFctList_0x26_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x26_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x26_ProcessingTimer,TELMAXPROCESSINGTIME);

                MPRAllCAWC_Request(Processing_REQ, 0);
                }
            }
        break;
		case StartResult_IND:
            //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x26_TimeOut)!=TRUE)
            {
            gTelFctList_0x26_TimeOut_flg = 0x00;
    			//IssueList #57
                if (getValue(env_FSG_Tel_MPRAllCAWC_Error_On)==0x00)
                putValue(env_FSG_Tel_MPRAllCAWC_ErrorCode,0);
                
                //IssueList #47
                if (getValue(env_FSG_Tel_MPRAllCAWC_Error_On))
                    MPRAllCAWC_Request(Error_REQ, getValue(env_FSG_Tel_MPRAllCAWC_ErrorCode)); // send error-message

                else if(gMPRAllCAWC_status!=0)														//method is still active
    				MPRAllCAWC_Request(Error_REQ, Terror_unknownapllicationerror);
    			else if(datalength!=3)															//datalength error
    				MPRAllCAWC_Request(Error_REQ, Terror_unknownapllicationerror);				//send error-message to RNS
    			else if(gCallActivity==NOCALL)													//MPRACAWC is impossible, no call
    				MPRAllCAWC_Request(Error_REQ, Terror_nocall);								//send error-message to RNS
    			else if(mprallcawcpossible!=1)													//MPRACAWC is impossible
    				//IssueList #26
                    {
                    gMPRAllCAWC_Result=getValue(env_FSG_MPRAllCAWC_Result);							                         //send error-message to RNS
                    MPRAllCAWC_Request(Result_REQ, mprallcawcpossible);
                    }
                    //MPRAllCAWC_Request(Error_REQ, mprallcawcpossible);							//send error-message to RNS
    			else
    			{	
    				gMPRAllCAWC_status=1;														//method "MPRACAWC" active
    				for(i=0;i<7;i++)															//searching for active calls
    				{
    					if(gCallState[i]!=idle && gCallState[i]!=ringing_waiting)
    					{
    						callID=i;
    						// changes from Jan Swoboda (01.03.2012)
    						set_CallState_noReq(callID,disconnecting);										//set call state
    					}
    				}
                    // changes from Jan Swoboda (01.03.2012)
    		            if (gCallStateRequestPending)
                        CallState_Request(Data_REQ,0);
		
    				settimer(MPRAllCAWCTimer, MPRAllCAWCTimerTime);
    			}
            }
            else
            gTelFctList_0x26_TimeOut_flg = 0x01;
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone MPRAllCAWC_Indication: unknown indication %d", indication);
		break;
		}
}

MPRAllCAWC_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request)
	{
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;								//LSG-ID
			requestarray[1]=FctID_MPReleaseAllCallsAcceptWaitingCall;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x26_Processing_flg == 0x00)
            {
			requestarray[0]=LSGID_Telephone;								//LSG-ID
			requestarray[1]=FctID_MPReleaseAllCallsAcceptWaitingCall;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=gMPRAllCAWC_Result;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;								//LSG-ID
			requestarray[1]=FctID_MPReleaseAllCallsAcceptWaitingCall;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x26_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone MPRAllCAWC_Request: unknown request %d", request);
		break;
	}
}

on envVar env_FSG_MP_CHAWC
{
byte i, callID, mpchawcpossible;

//init lokal variables
	callID=0xff;
	mpchawcpossible=Terror_noactivecall;
//********************
	
	//search for held calls 
	for(i=0;i<7;i++)
	{
		if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
			mpchawcpossible=Terror_heldcallpresent;
	}
	
	//search for active calls
	if(mpchawcpossible!=Terror_heldcallpresent)										//no held call(s) present
	{
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==active)
				mpchawcpossible=Terror_noincomingwaitingcall;
		}
	}

	//search for waiting calls
	if(mpchawcpossible==Terror_noincomingwaitingcall)								//active call(s) is(are) present
	{
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==ringing_waiting)
				mpchawcpossible=1;
		}
	}

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && mpchawcpossible==1)
	{
		for(i=0;i<7;i++)															//searching for active calls
		{
			if(gCallState[i]==active)
			{
				callID=i;
				// changes from Jan Swoboda (01.03.2012)
				set_CallState_noReq(callID,onhold);												//set call state
			}
		}

		for(i=0;i<7;i++)																//searching for active calls
		{
			if(gCallState[i]==ringing_waiting)
			{
				callID=i;
				// changes from Jan Swoboda (01.03.2012)
				set_CallState_noReq(callID,active);												//set call state
			}
		}
        // changes from Jan Swoboda (01.03.2012)
	if (gCallStateRequestPending)
            CallState_Request(Data_REQ,0);
	}
}

MPCHAWC_Indication(dword Indication_array [], byte indication, int datalength)
{

byte i, callID, mpchawcpossible;

//MR63665
byte mpchawcCallActivity = 0;


//init lokal variables
	callID=0xff;
	mpchawcpossible=Terror_noactivecall;

    mpchawcCallActivity =0;
    gHookTasteFlag_MPCHAWC = 0;
//********************

	//search for held calls 
	for(i=0;i<7;i++)
	{
		if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
			mpchawcpossible=Terror_heldcallpresent;
	}
	
	//search for active calls
	if(mpchawcpossible!=Terror_heldcallpresent)										//no held call(s) present
	{
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==active)
				mpchawcpossible=Terror_noincomingwaitingcall;
		}
	}

	//search for waiting calls
	if(mpchawcpossible==Terror_noincomingwaitingcall)								//active call(s) is(are) present
	{
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==ringing_waiting)
				mpchawcpossible=1;
		}
	}

//IssueList #26
if (getValue(env_FSG_MPCHAWC_Result)==0x00)	
	mpchawcpossible=1;
else
   mpchawcpossible=0;

	switch (indication)
	{
		case Processing_CNF:
			//IssueList #57  and #74
           if (((getValue(env_FSG_Tel_MPCHAWC_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_MPCHAWC_ErrorCode) > 0x3F)) &&   (gTelFctList_0x25_TimeOut_flg == 0x00))
			{
            MPCHAWC_Request(Processing_REQ, 0);											//send Processing
		        
                //IssueList #68
                if (gTelFctList_0x25_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x25_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x25_ProcessingTimer,TELMAXPROCESSINGTIME);

                MPCHAWC_Request(Processing_REQ, 0);
                }
            }
        break;
		case StartResult_IND:
            //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x25_TimeOut)!=TRUE)
            {
            gTelFctList_0x25_TimeOut_flg = 0x00;

                //MR 63665  16.07.2014  
                mpchawcCallActivity = gCallActivity;

                //MR 63665   07.05.2014
                if (getValue(env_FSG_CallState_CallID_0_set)!=0x00 || getValue(env_FSG_CallState_CallID_1_set)!=0x00 ||
                getValue(env_FSG_CallState_CallID_2_set)!=0x00 || getValue(env_FSG_CallState_CallID_3_set)!=0x00 ||
                getValue(env_FSG_CallState_CallID_4_set)!=0x00 || getValue(env_FSG_CallState_CallID_5_set)!=0x00 ||
                getValue(env_FSG_CallState_CallID_6_set)!=0x00)
                gHookTasteFlag_MPCHAWC = 1;
                
                if (gHookTasteFlag_MPCHAWC == 1 && gCallActivity ==NOCALL)
                gCallActivity = SINGLECALL;

    			//IssueList #57
                if (getValue(env_FSG_Tel_MPCHAWC_Error_On)==0x00)
                putValue(env_FSG_Tel_MPCHAWC_ErrorCode,0);
                
                //IssueList #47
                if (getValue(env_FSG_Tel_MPCHAWC_Error_On))
                    MPCHAWC_Request(Error_REQ, getValue(env_FSG_Tel_MPCHAWC_ErrorCode)); // send error-message

                else if(gMPCHAWC_status!=0)														//method is still active
    				MPCHAWC_Request(Error_REQ, Terror_unknownapllicationerror);
    			else if(datalength!=3)														//datalength error
    				MPCHAWC_Request(Error_REQ, Terror_unknownapllicationerror);				//send error-message to RNS
    			else if(gCallActivity==NOCALL)												//MPRACAWC is impossible, no call
    				MPCHAWC_Request(Error_REQ, Terror_nocall);								//send error-message to RNS
    			else if(mpchawcpossible!=1)	
                     //IssueList #26													//MPRACAWC is impossible
                    {
                    gMPCHAWC_Result=getValue(env_FSG_MPCHAWC_Result);							                         //send error-message to RNS
                    MPCHAWC_Request(Result_REQ, mpchawcpossible);
                    }
    				//MPCHAWC_Request(Error_REQ, mpchawcpossible);							//send error-message to RNS
    			else
    			{	
    				gMPCHAWC_status=1;														//method "MPRACAWC" active
    				settimer(MPCHAWCTimer, MPCHAWCTimerTime);
    			}
                
                //MR 63665  16.07.2014  
                gCallActivity = mpchawcCallActivity;

            }
            else
            gTelFctList_0x25_TimeOut_flg = 0x01;
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone MPRACAWC_Indication: unknown indication %d", indication);
		break;
		}
}

on timer MPCHAWCTimer
{
byte i, callID;
char empty_string [3];

//init lokal variables
	callID=0xff;
	for(i=0;i<3;i++)
		empty_string[i]=0;
//********************
	
	
	for(i=0;i<7;i++)															//searching for active calls
	{
		if(gCallState[i]==active)
		{
			callID=i;
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,onhold);												//set call state
		}
	}

	for(i=0;i<7;i++)																//searching for active calls
	{
		if(gCallState[i]==ringing_waiting)
		{
			callID=i;
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,active);												//set call state
		}
	}
    // changes from Jan Swoboda (01.03.2012)
    if (gCallStateRequestPending)
        CallState_Request(Data_REQ,0);
    //IssueList #26
    gMPCHAWC_Result = SUCCESSFUL;
	
    MPCHAWC_Request(Result_REQ, 0);
	gMPCHAWC_status=0;
}

MPCHAWC_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request)
	{
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;						//LSG-ID
			requestarray[1]=FctID_MPCallHoldAcceptWaitingCall;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68

			requestarray[0]=LSGID_Telephone;						//LSG-ID
			requestarray[1]=FctID_MPCallHoldAcceptWaitingCall;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=gMPCHAWC_Result;
			Offset=4;

            //MR 60227 - BAP_MOST delay timer
            //if (gTelFctList_0x25_Processing_flg == 0x00 && getValue(env_PIC_bapMOST_active_flag) == 0x00)
			if (gTelFctList_0x25_Processing_flg == 0x00)
            set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            
            /*else if (getValue(env_PIC_bapMOST_active_flag) == 0x01)
            {
                if (getValue(env_AudioTel_bapMost_delayTimer) > 0)
                {
                    for (i=0;i<4;i++)
                    gTel_Requestarray[i]=0;
                    
                    for (i=0;i<4;i++)
                    gTel_Requestarray[i]=requestarray[i];
                gTel_Offset = Offset;
                setTimer(_tMostF_delayTime,getValue(env_AudioTel_bapMost_delayTimer));
                }

                else
                set_status_requestbuffer (requestarray, Offset, Bap_UInt8);

            }*/

		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;						//LSG-ID
			requestarray[1]=FctID_MPCallHoldAcceptWaitingCall;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x25_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone MPCHAWC_Request: unknown request %d", request);
		break;
	}
}

on envVar env_FSG_RemoteSide_HangUp
{
int i;

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && getvalue(env_FSG_dialednumber_free_busy)==free)
	{
		//search for dialing calls 
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==dialing)								//found corresponding dialing call 
			{
				EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);	
				//changes from Jöran Karl (28.03.2012)
				//gDisconnectReason=linebusy;								//set Disconnect Reason
				//putvalue(env_FSG_DisconnectReason, gDisconnectReason);	//update panel
				//DisconnectReason_Request(Data_REQ, 0);						//send Disconnect Reason
				
				//changes from Jöran Karl (28.03.2012)
					// changes from Jan Swoboda (01.03.2012)
					//set_CallState_noReq(gcallID, disconnecting);				//disconnect call
				set_CallState(gcallID, disconnecting);				//disconnect call
				settimer(disconnectingtimer, disconnecttime);
				
				i=7;												//loop finished
			}
			//IssueList #64
            //else if(gCallState[i]==active)            //found corresponding active call
		    else if(gCallState[i]==active || gCallState[i]==onhold)
        	{
				EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);	
				
				//changes from Jöran Karl (28.03.2012)
					// changes from Jan Swoboda (01.03.2012)
					//set_CallState_noReq(gcallID, disconnecting);				//disconnect call
 				set_CallState(gcallID, disconnecting);	
				settimer(disconnectingtimer, disconnecttime);
				
				i=7;												//loop finished
			}

		}
        // changes from Jan Swoboda (01.03.2012)
	if (gCallStateRequestPending)
            CallState_Request(Data_REQ,0);
	
    //IssueList #99
    gFirstPress = 0x00;
    }
}

on envVar env_FSG_RemoteSide_HangUpWait
{
int i;
char empty_string [2];

//init lokal variables
	for(i=0;i<2;i++)
		empty_string[i]=0;
//********************

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && getvalue(env_FSG_dialednumber_free_busy)==free)
	{
		//search for dialing calls 
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==ringing_waiting)						//found corresponding call
			{
				//fill missed call stack with missed incoming call
			/*	if(strlen(gCallInfo_PbName[i])==0)
				{
					strncpy(gmissedcallnumber_new, empty_string, 40);
					strncpy(gmissedcallname_new, gunknown, 50);
					gmissedcallnumbertype_new=0;
				}
				else
				{
			*/		strncpy(gmissedcallnumber_new, gCallInfo_TelNumber[i], CALL_INFO_NUMBER_LENGTH);
					strncpy(gmissedcallname_new, gCallInfo_PbName[i], CALL_INFO_NAME_LENGTH);
					gmissedcallnumbertype_new=gincomingcall_numbertype;
			//	}
				callstack_missedcalls(NEWCALL, 0,1);								
				//*************************************************


				set_CallState(gcallID, disconnecting);				//disconnect call
				settimer(disconnectingtimer, disconnecttime);
				
				i=7;												//loop finished
			}
		}
       //changes from Jöran Karl (28.03.2012)
        if (gCallStateRequestPending)
            CallState_Request(Data_REQ,0);
	}
}

on envVar env_FSG_dialednumber_DateTime
{
	if(gFSG_Telephone_PowerOnOff==Power_on)
	{
		gdialednumbers_DateTime=getvalue(this);
	}
}

on envVar env_FSG_missedcall_DateTime
{
	if(gFSG_Telephone_PowerOnOff==Power_on)
	{
		gmissedcall_DateTime=getvalue(this);
	}
}

on envVar env_FSG_receivedcall_DateTime
{
	if(gFSG_Telephone_PowerOnOff==Power_on)
	{
		greceivedcall_DateTime=getvalue(this);
	}
}

on envVar env_FSG_Telephone_FctList_mode
{
	switch(getvalue(this))
		{
		case 0:	//none
			putvalue(env_FSG_Telephone_FctList_0x01, 0);
			putvalue(env_FSG_Telephone_FctList_0x02, 0);
			putvalue(env_FSG_Telephone_FctList_0x03, 0);
			putvalue(env_FSG_Telephone_FctList_0x04, 0);
			putvalue(env_FSG_Telephone_FctList_0x0E, 0);
			putvalue(env_FSG_Telephone_FctList_0x0F, 0);
			putvalue(env_FSG_Telephone_FctList_0x10, 0);
			putvalue(env_FSG_Telephone_FctList_0x11, 0);
			putvalue(env_FSG_Telephone_FctList_0x12, 0);
			putvalue(env_FSG_Telephone_FctList_0x13, 0);
			putvalue(env_FSG_Telephone_FctList_0x14, 0);
			putvalue(env_FSG_Telephone_FctList_0x15, 0);
			putvalue(env_FSG_Telephone_FctList_0x16, 0);
			putvalue(env_FSG_Telephone_FctList_0x17, 0);
			putvalue(env_FSG_Telephone_FctList_0x18, 0);
			putvalue(env_FSG_Telephone_FctList_0x19, 0);
			putvalue(env_FSG_Telephone_FctList_0x1A, 0);
			putvalue(env_FSG_Telephone_FctList_0x1B, 0);
			putvalue(env_FSG_Telephone_FctList_0x1C, 0);
			putvalue(env_FSG_Telephone_FctList_0x1D, 0);
			putvalue(env_FSG_Telephone_FctList_0x1E, 0);
			putvalue(env_FSG_Telephone_FctList_0x1F, 0);
			putvalue(env_FSG_Telephone_FctList_0x20, 0);
			putvalue(env_FSG_Telephone_FctList_0x21, 0);
			putvalue(env_FSG_Telephone_FctList_0x22, 0);
			putvalue(env_FSG_Telephone_FctList_0x23, 0);
			putvalue(env_FSG_Telephone_FctList_0x24, 0);
			putvalue(env_FSG_Telephone_FctList_0x25, 0);
			putvalue(env_FSG_Telephone_FctList_0x26, 0);
			putvalue(env_FSG_Telephone_FctList_0x27, 0);
			putvalue(env_FSG_Telephone_FctList_0x28, 0);
			putvalue(env_FSG_Telephone_FctList_0x29, 0);
			putvalue(env_FSG_Telephone_FctList_0x2A, 0);
			putvalue(env_FSG_Telephone_FctList_0x2B, 0);
			putvalue(env_FSG_Telephone_FctList_0x2C, 0);
			putvalue(env_FSG_Telephone_FctList_0x2D, 0);
			putvalue(env_FSG_Telephone_FctList_0x2E, 0);
			putvalue(env_FSG_Telephone_FctList_0x2F, 0);
			putvalue(env_FSG_Telephone_FctList_0x30, 0);
		break;
		case 1:	//all
			putvalue(env_FSG_Telephone_FctList_0x01, 1);
			putvalue(env_FSG_Telephone_FctList_0x02, 1);
			putvalue(env_FSG_Telephone_FctList_0x03, 1);
			putvalue(env_FSG_Telephone_FctList_0x04, 1);
			putvalue(env_FSG_Telephone_FctList_0x0E, 1);
			putvalue(env_FSG_Telephone_FctList_0x0F, 1);
			putvalue(env_FSG_Telephone_FctList_0x10, 1);
			putvalue(env_FSG_Telephone_FctList_0x11, 1);
			putvalue(env_FSG_Telephone_FctList_0x12, 1);
			putvalue(env_FSG_Telephone_FctList_0x13, 1);
			putvalue(env_FSG_Telephone_FctList_0x14, 1);
			putvalue(env_FSG_Telephone_FctList_0x15, 1);
			putvalue(env_FSG_Telephone_FctList_0x16, 1);
			putvalue(env_FSG_Telephone_FctList_0x17, 1);
			putvalue(env_FSG_Telephone_FctList_0x18, 1);
			putvalue(env_FSG_Telephone_FctList_0x19, 1);
			putvalue(env_FSG_Telephone_FctList_0x1A, 1);
			putvalue(env_FSG_Telephone_FctList_0x1B, 1);
			putvalue(env_FSG_Telephone_FctList_0x1C, 1);
			putvalue(env_FSG_Telephone_FctList_0x1D, 1);
			putvalue(env_FSG_Telephone_FctList_0x1E, 1);
			putvalue(env_FSG_Telephone_FctList_0x1F, 1);
			putvalue(env_FSG_Telephone_FctList_0x20, 1);
			putvalue(env_FSG_Telephone_FctList_0x21, 1);
			putvalue(env_FSG_Telephone_FctList_0x22, 1);
			putvalue(env_FSG_Telephone_FctList_0x23, 1);
			putvalue(env_FSG_Telephone_FctList_0x24, 1);
			putvalue(env_FSG_Telephone_FctList_0x25, 1);
			putvalue(env_FSG_Telephone_FctList_0x26, 1);
			putvalue(env_FSG_Telephone_FctList_0x27, 1);
			putvalue(env_FSG_Telephone_FctList_0x28, 1);
			putvalue(env_FSG_Telephone_FctList_0x29, 1);
			putvalue(env_FSG_Telephone_FctList_0x2A, 1);
			putvalue(env_FSG_Telephone_FctList_0x2B, 1);
			putvalue(env_FSG_Telephone_FctList_0x2C, 1);
			putvalue(env_FSG_Telephone_FctList_0x2D, 1);
			putvalue(env_FSG_Telephone_FctList_0x2E, 1);
			putvalue(env_FSG_Telephone_FctList_0x2F, 1);
			putvalue(env_FSG_Telephone_FctList_0x30, 1);
		break;
		case 2:	//UHV-Premium
			putvalue(env_FSG_Telephone_FctList_0x01, 1);
			putvalue(env_FSG_Telephone_FctList_0x02, 1);
			putvalue(env_FSG_Telephone_FctList_0x03, 1);
			putvalue(env_FSG_Telephone_FctList_0x04, 1);
			putvalue(env_FSG_Telephone_FctList_0x0E, 1);
			putvalue(env_FSG_Telephone_FctList_0x0F, 1);
			putvalue(env_FSG_Telephone_FctList_0x10, 1);
			putvalue(env_FSG_Telephone_FctList_0x11, 1);
			putvalue(env_FSG_Telephone_FctList_0x12, 1);
			putvalue(env_FSG_Telephone_FctList_0x13, 1);
			putvalue(env_FSG_Telephone_FctList_0x14, 1);
			putvalue(env_FSG_Telephone_FctList_0x15, 1);
			putvalue(env_FSG_Telephone_FctList_0x16, 1);
			putvalue(env_FSG_Telephone_FctList_0x17, 1);
			putvalue(env_FSG_Telephone_FctList_0x18, 1);
			putvalue(env_FSG_Telephone_FctList_0x19, 1);
			putvalue(env_FSG_Telephone_FctList_0x1A, 1);
			putvalue(env_FSG_Telephone_FctList_0x1B, 1);
			putvalue(env_FSG_Telephone_FctList_0x1C, 1);
			putvalue(env_FSG_Telephone_FctList_0x1D, 1);
			putvalue(env_FSG_Telephone_FctList_0x1E, 1);
			putvalue(env_FSG_Telephone_FctList_0x1F, 1);
			putvalue(env_FSG_Telephone_FctList_0x20, 1);
			putvalue(env_FSG_Telephone_FctList_0x21, 1);
			putvalue(env_FSG_Telephone_FctList_0x22, 1);
			putvalue(env_FSG_Telephone_FctList_0x23, 1);
			putvalue(env_FSG_Telephone_FctList_0x24, 1);
			putvalue(env_FSG_Telephone_FctList_0x25, 0);
			putvalue(env_FSG_Telephone_FctList_0x26, 0);
			putvalue(env_FSG_Telephone_FctList_0x27, 1);
			putvalue(env_FSG_Telephone_FctList_0x28, 1);
			putvalue(env_FSG_Telephone_FctList_0x29, 0);
			putvalue(env_FSG_Telephone_FctList_0x2A, 0);
			putvalue(env_FSG_Telephone_FctList_0x2B, 1);
			putvalue(env_FSG_Telephone_FctList_0x2C, 1);
			putvalue(env_FSG_Telephone_FctList_0x2D, 1);
			putvalue(env_FSG_Telephone_FctList_0x2E, 1);
			putvalue(env_FSG_Telephone_FctList_0x2F, 1);
			putvalue(env_FSG_Telephone_FctList_0x30, 1);
		break;
		case 3:	//UHV-High
			putvalue(env_FSG_Telephone_FctList_0x01, 1);
			putvalue(env_FSG_Telephone_FctList_0x02, 1);
			putvalue(env_FSG_Telephone_FctList_0x03, 1);
			putvalue(env_FSG_Telephone_FctList_0x04, 1);
			putvalue(env_FSG_Telephone_FctList_0x0E, 1);
			putvalue(env_FSG_Telephone_FctList_0x0F, 1);
			putvalue(env_FSG_Telephone_FctList_0x10, 1);
			putvalue(env_FSG_Telephone_FctList_0x11, 0);
			putvalue(env_FSG_Telephone_FctList_0x12, 1);
			putvalue(env_FSG_Telephone_FctList_0x13, 1);
			putvalue(env_FSG_Telephone_FctList_0x14, 1);
			putvalue(env_FSG_Telephone_FctList_0x15, 1);
			putvalue(env_FSG_Telephone_FctList_0x16, 1);
			putvalue(env_FSG_Telephone_FctList_0x17, 1);
			putvalue(env_FSG_Telephone_FctList_0x18, 1);
			putvalue(env_FSG_Telephone_FctList_0x19, 1);
			putvalue(env_FSG_Telephone_FctList_0x1A, 1);
			putvalue(env_FSG_Telephone_FctList_0x1B, 1);
			putvalue(env_FSG_Telephone_FctList_0x1C, 1);
			putvalue(env_FSG_Telephone_FctList_0x1D, 1);
			putvalue(env_FSG_Telephone_FctList_0x1E, 1);
			putvalue(env_FSG_Telephone_FctList_0x1F, 0);
			putvalue(env_FSG_Telephone_FctList_0x20, 0);
			putvalue(env_FSG_Telephone_FctList_0x21, 0);
			putvalue(env_FSG_Telephone_FctList_0x22, 0);
			putvalue(env_FSG_Telephone_FctList_0x23, 0);
			putvalue(env_FSG_Telephone_FctList_0x24, 0);
			putvalue(env_FSG_Telephone_FctList_0x25, 0);
			putvalue(env_FSG_Telephone_FctList_0x26, 1);
			putvalue(env_FSG_Telephone_FctList_0x27, 0);
			putvalue(env_FSG_Telephone_FctList_0x28, 0);
			putvalue(env_FSG_Telephone_FctList_0x29, 1);
			putvalue(env_FSG_Telephone_FctList_0x2A, 0);
			putvalue(env_FSG_Telephone_FctList_0x2B, 0);
			putvalue(env_FSG_Telephone_FctList_0x2C, 0);
			putvalue(env_FSG_Telephone_FctList_0x2D, 0);
			putvalue(env_FSG_Telephone_FctList_0x2E, 0);
			putvalue(env_FSG_Telephone_FctList_0x2F, 0);
			putvalue(env_FSG_Telephone_FctList_0x30, 1);
		break;
	}
}

on envVar env_FSG_Telephone_MSS_mode
{
	if(gFSG_Telephone_PowerOnOff==Power_on)
	{
		switch(getvalue(this))
		{
			case 0:	//none
            //IssueList #17
				//putvalue(env_FSG_Telephone_MSS_0x01, 0);
				//putvalue(env_FSG_Telephone_MSS_0x02, 0);
				//putvalue(env_FSG_Telephone_MSS_0x03, 0);
				//putvalue(env_FSG_Telephone_MSS_0x04, 0);
				//putvalue(env_FSG_Telephone_MSS_0x0E, 0);
				//putvalue(env_FSG_Telephone_MSS_0x0F, 0);
				//putvalue(env_FSG_Telephone_MSS_0x10, 0);
				putvalue(env_FSG_Telephone_MSS_0x11, 0);
				putvalue(env_FSG_Telephone_MSS_0x12, 0);
				putvalue(env_FSG_Telephone_MSS_0x13, 0);
				putvalue(env_FSG_Telephone_MSS_0x14, 0);
				putvalue(env_FSG_Telephone_MSS_0x15, 0);
				putvalue(env_FSG_Telephone_MSS_0x16, 0);
				putvalue(env_FSG_Telephone_MSS_0x17, 0);
				putvalue(env_FSG_Telephone_MSS_0x18, 0);
				putvalue(env_FSG_Telephone_MSS_0x19, 0);
				putvalue(env_FSG_Telephone_MSS_0x1A, 0);
				putvalue(env_FSG_Telephone_MSS_0x1B, 0);
				putvalue(env_FSG_Telephone_MSS_0x1C, 0);
				putvalue(env_FSG_Telephone_MSS_0x1D, 0);
				putvalue(env_FSG_Telephone_MSS_0x1E, 0);
				putvalue(env_FSG_Telephone_MSS_0x1F, 0);
				putvalue(env_FSG_Telephone_MSS_0x20, 0);
				putvalue(env_FSG_Telephone_MSS_0x21, 0);
				putvalue(env_FSG_Telephone_MSS_0x22, 0);
				putvalue(env_FSG_Telephone_MSS_0x23, 0);
				putvalue(env_FSG_Telephone_MSS_0x24, 0);
				putvalue(env_FSG_Telephone_MSS_0x25, 0);
				putvalue(env_FSG_Telephone_MSS_0x26, 0);
				putvalue(env_FSG_Telephone_MSS_0x27, 0);
				putvalue(env_FSG_Telephone_MSS_0x28, 0);
				putvalue(env_FSG_Telephone_MSS_0x29, 0);
				putvalue(env_FSG_Telephone_MSS_0x2A, 0);
				putvalue(env_FSG_Telephone_MSS_0x2B, 0);
				putvalue(env_FSG_Telephone_MSS_0x2C, 0);
				putvalue(env_FSG_Telephone_MSS_0x2D, 0);
				putvalue(env_FSG_Telephone_MSS_0x2E, 0);
				putvalue(env_FSG_Telephone_MSS_0x2F, 0);
				putvalue(env_FSG_Telephone_MSS_0x30, 0);
                putvalue(env_FSG_Telephone_MSS_0x31, 0);
                putvalue(env_FSG_Telephone_MSS_0x32, 0);
                putvalue(env_FSG_Telephone_MSS_0x33, 0);
                putvalue(env_FSG_Telephone_MSS_0x34, 0);
                putvalue(env_FSG_Telephone_MSS_0x35, 0);
                putvalue(env_FSG_Telephone_MSS_0x36, 0);
                putvalue(env_FSG_Telephone_MSS_0x37, 0);
                putvalue(env_FSG_Telephone_MSS_0x38, 0);
                putvalue(env_FSG_Telephone_MSS_0x39, 0);
                putvalue(env_FSG_Telephone_MSS_0x3A, 0);
                //IssueList #17
                //putvalue(env_FSG_Telephone_MSS_0x3B, 0);
                //putvalue(env_FSG_Telephone_MSS_0x3C, 0);
                //putvalue(env_FSG_Telephone_MSS_0x3D, 0);
                //putvalue(env_FSG_Telephone_MSS_0x3E, 0);
                //putvalue(env_FSG_Telephone_MSS_0x3F, 0);
			break;
			case 1:	//all
				/*putvalue(env_FSG_Telephone_MSS_0x01, 1);
				putvalue(env_FSG_Telephone_MSS_0x02, 1);
				putvalue(env_FSG_Telephone_MSS_0x03, 1);
				putvalue(env_FSG_Telephone_MSS_0x04, 1);
				putvalue(env_FSG_Telephone_MSS_0x0E, 1);
				putvalue(env_FSG_Telephone_MSS_0x0F, 1);
				putvalue(env_FSG_Telephone_MSS_0x10, 1);*/
				putvalue(env_FSG_Telephone_MSS_0x11, 1);
				putvalue(env_FSG_Telephone_MSS_0x12, 1);
				putvalue(env_FSG_Telephone_MSS_0x13, 1);
				putvalue(env_FSG_Telephone_MSS_0x14, 1);
				putvalue(env_FSG_Telephone_MSS_0x15, 1);
				putvalue(env_FSG_Telephone_MSS_0x16, 1);
				putvalue(env_FSG_Telephone_MSS_0x17, 1);
				putvalue(env_FSG_Telephone_MSS_0x18, 1);
				putvalue(env_FSG_Telephone_MSS_0x19, 1);
				putvalue(env_FSG_Telephone_MSS_0x1A, 1);
				putvalue(env_FSG_Telephone_MSS_0x1B, 1);
				putvalue(env_FSG_Telephone_MSS_0x1C, 1);
				putvalue(env_FSG_Telephone_MSS_0x1D, 1);
				putvalue(env_FSG_Telephone_MSS_0x1E, 1);
				putvalue(env_FSG_Telephone_MSS_0x1F, 1);
				putvalue(env_FSG_Telephone_MSS_0x20, 1);
				putvalue(env_FSG_Telephone_MSS_0x21, 1);
				putvalue(env_FSG_Telephone_MSS_0x22, 1);
				putvalue(env_FSG_Telephone_MSS_0x23, 1);
				putvalue(env_FSG_Telephone_MSS_0x24, 1);
				putvalue(env_FSG_Telephone_MSS_0x25, 1);
				putvalue(env_FSG_Telephone_MSS_0x26, 1);
				putvalue(env_FSG_Telephone_MSS_0x27, 1);
				putvalue(env_FSG_Telephone_MSS_0x28, 1);
				putvalue(env_FSG_Telephone_MSS_0x29, 1);
				putvalue(env_FSG_Telephone_MSS_0x2A, 1);
				putvalue(env_FSG_Telephone_MSS_0x2B, 1);
				putvalue(env_FSG_Telephone_MSS_0x2C, 1);
				putvalue(env_FSG_Telephone_MSS_0x2D, 1);
				putvalue(env_FSG_Telephone_MSS_0x2E, 1);
				putvalue(env_FSG_Telephone_MSS_0x2F, 1);
				putvalue(env_FSG_Telephone_MSS_0x30, 1);
                putvalue(env_FSG_Telephone_MSS_0x31, 1);
                putvalue(env_FSG_Telephone_MSS_0x32, 1);
                putvalue(env_FSG_Telephone_MSS_0x33, 1);
                putvalue(env_FSG_Telephone_MSS_0x34, 1);
                putvalue(env_FSG_Telephone_MSS_0x35, 1);
                putvalue(env_FSG_Telephone_MSS_0x36, 1);
                putvalue(env_FSG_Telephone_MSS_0x37, 1);
                putvalue(env_FSG_Telephone_MSS_0x38, 1);
                putvalue(env_FSG_Telephone_MSS_0x39, 1);
                putvalue(env_FSG_Telephone_MSS_0x3A, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3B, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3C, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3D, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3E, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3F, 1);
			break;
			case 2:	//UHV-Premium
				/*putvalue(env_FSG_Telephone_MSS_0x01, 1);
				putvalue(env_FSG_Telephone_MSS_0x02, 1);
				putvalue(env_FSG_Telephone_MSS_0x03, 1);
				putvalue(env_FSG_Telephone_MSS_0x04, 1);
				putvalue(env_FSG_Telephone_MSS_0x0E, 1);
				putvalue(env_FSG_Telephone_MSS_0x0F, 1);
				putvalue(env_FSG_Telephone_MSS_0x10, 1);*/
				putvalue(env_FSG_Telephone_MSS_0x11, 1);
				putvalue(env_FSG_Telephone_MSS_0x12, 1);
				putvalue(env_FSG_Telephone_MSS_0x13, 1);
				putvalue(env_FSG_Telephone_MSS_0x14, 1);
				putvalue(env_FSG_Telephone_MSS_0x15, 1);
				putvalue(env_FSG_Telephone_MSS_0x16, 1);
				putvalue(env_FSG_Telephone_MSS_0x17, 1);
				putvalue(env_FSG_Telephone_MSS_0x18, 1);
				putvalue(env_FSG_Telephone_MSS_0x19, 1);
				putvalue(env_FSG_Telephone_MSS_0x1A, 1);
				putvalue(env_FSG_Telephone_MSS_0x1B, 1);
				putvalue(env_FSG_Telephone_MSS_0x1C, 1);
				putvalue(env_FSG_Telephone_MSS_0x1D, 1);
				putvalue(env_FSG_Telephone_MSS_0x1E, 1);
				putvalue(env_FSG_Telephone_MSS_0x1F, 1);
				putvalue(env_FSG_Telephone_MSS_0x20, 1);
				putvalue(env_FSG_Telephone_MSS_0x21, 1);
				putvalue(env_FSG_Telephone_MSS_0x22, 1);
				putvalue(env_FSG_Telephone_MSS_0x23, 1);
				putvalue(env_FSG_Telephone_MSS_0x24, 1);
				putvalue(env_FSG_Telephone_MSS_0x25, 0);
				putvalue(env_FSG_Telephone_MSS_0x26, 0);
				putvalue(env_FSG_Telephone_MSS_0x27, 1);
				putvalue(env_FSG_Telephone_MSS_0x28, 1);
				putvalue(env_FSG_Telephone_MSS_0x29, 0);
				putvalue(env_FSG_Telephone_MSS_0x2A, 0);
				putvalue(env_FSG_Telephone_MSS_0x2B, 1);
				putvalue(env_FSG_Telephone_MSS_0x2C, 1);
				putvalue(env_FSG_Telephone_MSS_0x2D, 1);
				putvalue(env_FSG_Telephone_MSS_0x2E, 1);
				putvalue(env_FSG_Telephone_MSS_0x2F, 1);
				putvalue(env_FSG_Telephone_MSS_0x30, 1);
                putvalue(env_FSG_Telephone_MSS_0x31, 1);
                putvalue(env_FSG_Telephone_MSS_0x32, 1);
                putvalue(env_FSG_Telephone_MSS_0x33, 1);
                putvalue(env_FSG_Telephone_MSS_0x34, 1);
                putvalue(env_FSG_Telephone_MSS_0x35, 1);
                putvalue(env_FSG_Telephone_MSS_0x36, 1);
                putvalue(env_FSG_Telephone_MSS_0x37, 1);
                putvalue(env_FSG_Telephone_MSS_0x38, 1);
                putvalue(env_FSG_Telephone_MSS_0x39, 1);
                putvalue(env_FSG_Telephone_MSS_0x3A, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3B, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3C, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3D, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3E, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3F, 1);
			break;
			case 3:	//UHV-High
				/*putvalue(env_FSG_Telephone_MSS_0x01, 1);
				putvalue(env_FSG_Telephone_MSS_0x02, 1);
				putvalue(env_FSG_Telephone_MSS_0x03, 1);
				putvalue(env_FSG_Telephone_MSS_0x04, 1);
				putvalue(env_FSG_Telephone_MSS_0x0E, 1);
				putvalue(env_FSG_Telephone_MSS_0x0F, 1);
				putvalue(env_FSG_Telephone_MSS_0x10, 1);*/
				putvalue(env_FSG_Telephone_MSS_0x11, 0);
				putvalue(env_FSG_Telephone_MSS_0x12, 1);
				putvalue(env_FSG_Telephone_MSS_0x13, 1);
				putvalue(env_FSG_Telephone_MSS_0x14, 1);
				putvalue(env_FSG_Telephone_MSS_0x15, 1);
				putvalue(env_FSG_Telephone_MSS_0x16, 1);
				putvalue(env_FSG_Telephone_MSS_0x17, 1);
				putvalue(env_FSG_Telephone_MSS_0x18, 1);
				putvalue(env_FSG_Telephone_MSS_0x19, 1);
				putvalue(env_FSG_Telephone_MSS_0x1A, 1);
				putvalue(env_FSG_Telephone_MSS_0x1B, 1);
				putvalue(env_FSG_Telephone_MSS_0x1C, 1);
				putvalue(env_FSG_Telephone_MSS_0x1D, 1);
				putvalue(env_FSG_Telephone_MSS_0x1E, 1);
				putvalue(env_FSG_Telephone_MSS_0x1F, 0);
				putvalue(env_FSG_Telephone_MSS_0x20, 0);
				putvalue(env_FSG_Telephone_MSS_0x21, 0);
				putvalue(env_FSG_Telephone_MSS_0x22, 0);
				putvalue(env_FSG_Telephone_MSS_0x23, 0);
				putvalue(env_FSG_Telephone_MSS_0x24, 0);
				putvalue(env_FSG_Telephone_MSS_0x25, 0);
				putvalue(env_FSG_Telephone_MSS_0x26, 1);
				putvalue(env_FSG_Telephone_MSS_0x27, 0);
				putvalue(env_FSG_Telephone_MSS_0x28, 0);
				putvalue(env_FSG_Telephone_MSS_0x29, 1);
				putvalue(env_FSG_Telephone_MSS_0x2A, 0);
				putvalue(env_FSG_Telephone_MSS_0x2B, 0);
				putvalue(env_FSG_Telephone_MSS_0x2C, 0);
				putvalue(env_FSG_Telephone_MSS_0x2D, 0);
				putvalue(env_FSG_Telephone_MSS_0x2E, 0);
				putvalue(env_FSG_Telephone_MSS_0x2F, 0);
                putvalue(env_FSG_Telephone_MSS_0x30, 1);
				putvalue(env_FSG_Telephone_MSS_0x31, 1);
                putvalue(env_FSG_Telephone_MSS_0x32, 1);
                putvalue(env_FSG_Telephone_MSS_0x33, 1);
                putvalue(env_FSG_Telephone_MSS_0x34, 1);
                putvalue(env_FSG_Telephone_MSS_0x35, 1);
                putvalue(env_FSG_Telephone_MSS_0x36, 1);
                putvalue(env_FSG_Telephone_MSS_0x37, 1);
                putvalue(env_FSG_Telephone_MSS_0x38, 1);
                putvalue(env_FSG_Telephone_MSS_0x39, 1);
                putvalue(env_FSG_Telephone_MSS_0x3A, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3B, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3C, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3D, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3E, 1);
                //putvalue(env_FSG_Telephone_MSS_0x3F, 1);
			break;
		}
	}
}

on envVar env_FSG_Telephone_FctList_update
{
dword Cache_Request_Header[6];					//Cache header for DLL
byte Cache_Request_Data[BAP_buffer_size];		//Cache data for DLL
byte i, temp;

	if(Power_on==gFSG_Telephone_PowerOnOff && getvalue(this))
	{	
		//set new FctList
		BAP150_Shutdown(NODE_INDEX,LSGID_Telephone);

		//header
		Cache_Request_Header[0] = LSGID_Telephone;				//LSG-ID
		Cache_Request_Header[1] = FctID_FunctionList;			//Fct-ID
		Cache_Request_Header[2] = 0;							//ignored
		Cache_Request_Header[3] = Bap_ByteSequence;				//data-type
		Cache_Request_Header[4] = 8;							//length
		Cache_Request_Header[5] = 0;              				//ignored
	
	    initFunctionList();	
		
		Cache_Request_Data[0]=gFunctionList0;
		Cache_Request_Data[1]=gFunctionList1;
		Cache_Request_Data[2]=gFunctionList2;
		Cache_Request_Data[3]=gFunctionList3;
		Cache_Request_Data[4]=gFunctionList4;
		Cache_Request_Data[5]=gFunctionList5;
		Cache_Request_Data[6]=gFunctionList6;
		Cache_Request_Data[7]=gFunctionList7;

		temp=0;
		temp=BAP150_InitSendBuf(NODE_INDEX,Cache_Request_Header, Cache_Request_Data);
		if(temp!=0)
			write("FSG-Telephone: BAP_Init FunctionList errorcode: %d", temp);
	
		temp=BAP150_Start(NODE_INDEX,LSGID_Telephone);
		if(temp==0)
			write("FSG-Telephone BAP_Start successful");
		else
			write("FSG-Telephone error BAP_Start: %d", temp);	
		//****************
	}
}

delete_phonebook ()
{
    //changes from Jöran Karl (28.03.2012)
    word j,i,k;

    gPhonebook_TotalNumListElements  =0;

	for(j=0;j<PHONEBOOK_ENTRIES;j++) //reset Phonebook
	{
		gPhonebook_Pos[j]               =0;
		for(i=0;i<PHONEBOOK_PBNAME_LENGTH;i++)
			gPhonebook_PbName[j][i]     =0;
        gPhonebook_Storage[j]           =0;
        gPhonebook_AnyVoiceTag[j]       =0;
        gPhonebook_TelNumberQuantity[j] =0;
       //changes from Jöran Karl (28.03.2012)
        for(k=0;k<PHONEBOOK_N_MAX;k++) 
        {
            for(i=0;i<PHONEBOOK_TELNUMBER_LENGTH;i++)
            {
                gPhonebook_TelNumbers[k][j][i] =0;
            }
            gPhonebook_VoiceTags[k][j]     =0;
            gPhonebook_NumberTypes[k][j]   =0;            
        }
        gPhonebook_AddressIndication[j]=0;
	}
}

on timer MissedCallsDeleteEntryTimer
{
	MissedCalls_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);
}

on timer ReceivedCallsDeleteEntryTimer
{
	receivedcalls_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);
}

on timer DialedNumbersDeleteEntryTimer
{
	//dialednumbers_Request(Changed_REQ, 0, 0, CALLSTACK, 0, 0);
}

on envVar env_FSG_Phonebook_Pb_Changed
{
byte mode;

mode=0;

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
		mode=0x80;
        //MR 63667 11.07.2014 -TNLE with SA-button
		//Phonebook_Request(Changed_REQ, 0, 0, 0xffff, mode, 0);					//send changed-array for phonebookarray
        Phonebook_Request(Changed_REQ, 0, 0, 0, 0xffff, mode, 0);					//send changed-array for phonebookarray
	}
}

on envVar env_FSG_Debug_on_off//bap150 - debug
{
    if(getvalue(this)) gdebug=1;
        else gdebug=0;
}

on message CAN1.BAP_Telefon_ASG_01	//BAP-message
{

int i, temp;
byte RX_Data[8];			//received CAN-DATA
dword RX_Header[3];			//received CAN-Header

	if(gFSG_Telephone_PowerOnOff==Power_on)
    {
		RX_Header[0]=this.CAN; 
		RX_Header[1]=this.ID; 
		RX_Header[2]=this.DLC; // received length
	
																	//debug
		for (i=0; i<this.DLC; i++) 
        {							//CAN-data
		    RX_Data[i]=this.byte(i);
													//debug
		}
	    //IssueList #159 - start
        //temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
        switch (RX_Data[1])
        {
        //getAll
        case 1: //error
                if (getValue(env_FSG_GetAll_ErrEn)==0x01)
                Request_error(FctID_GetAll,getValue(env_FSG_GetAll_ErrCode)); 
                
                else if (getValue(env_FSG_GetAll_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 2: //error
                if (getValue(env_BAPCFG_FSG_Tel_ErrEn)==0x01)
                Request_error(FctID_BAP_Config,getValue(env_BAPCFG_FSG_ErrCode)); 

                else if (getValue(env_BAPCFG_FSG_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 3: //error
                if (getValue(env_FSG_FctList_ErrEn)==0x01)
                Request_error(FctID_FunctionList,getValue(env_FSG_FctList_ErrCode)); 
                
                else if (getValue(env_FSG_FctList_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);
                break;
             
        
        default: temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	//send recieved CAN-data with CAN-header to BAP-DLL
                break;
        }
        //IssueList #159 - end

        if(temp!=0)
			write("BAP_CAN_SetRxData: %d", temp);
	}
}

on message BAP_Telefon_ASG_02	//BAP-message
{

int i, temp;
byte RX_Data[8];			//received CAN-DATA
dword RX_Header[3];			//received CAN-Header

	if(gFSG_Telephone_PowerOnOff==Power_on){
		RX_Header[0]=this.CAN; 
		RX_Header[1]=this.ID; 
		RX_Header[2]=this.DLC; // received length
	
																		//debug
		for (i=0; i<this.DLC; i++) {							//CAN-data
		    RX_Data[i]=this.byte(i);
													//debug
		}
	
		temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	//send recieved CAN-data with CAN-header to BAP-DLL
		if(temp!=0)
			write("BAP_CAN_SetRxData: %d", temp);
	}
}

on envVar env_FSG_NetworkProvider_OK
{
byte i,length;

//init lokal variables
	length=0;
//********************

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        canceltimer(registerstatetimer);
		gNetworkProviderState=getvalue(env_FSG_NetworkProviderState);
	
		if (gLockState==nolock)															//SIM available and not locked
		{
			//MR61568 - commented 
            /*if (gNetworkProviderState==0)												//no NetworkProvider
			{
				
                if(gCallActivity!=0)													//singel or multipaty call active
					Kill_Bill_Vol1();													//kill all calls
			}*/
				
				gServiceProviderState=getvalue(env_FSG_ServiceProviderState);

				//check if Provider/Service Names are changed.

                if (strncmp(gServiceProviderName,gCurrent_ServiceProviderName,40)!=0 || strncmp(gNetworkProviderName,gCurrent_NetworkProviderName,40)!=0)
				{
				//setting RegisterState
                gRegisterState=notregisterdandsearching;
                gNetworkType=UNKNOWN_NT;
                gPacketDataNetworkType=NO_DATA_SERVICE;
				putvalue(env_FSG_RegisterState, gRegisterState);
                putvalue(env_FSG_NetworkType,gNetworkType);
                putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);

				RegisterState_Request(Data_REQ, 0);										//send register state
                getvalue(env_FSG_ServiceProviderName,gServiceProviderName); 
                getvalue(env_FSG_NetworkProviderName,gNetworkProviderName);
				settimer(registerstatetimer, gtime_registerstatetimer);	
				
				}
				else
				NetworkProvider_Request(Data_REQ, 0);									//send empty provider name		
		}
		else if (gemergencycall==2 || gemergencycall==3)								//SIM not available or locked but emergency call active
		{
			if(gNetworkProviderState==0 && gCallActivity!=0)							//no network provider (provider lost) and singel or multipaty call active
				Kill_Bill_Vol1();														//kill all calls

			getvalue(env_FSG_NetworkProviderName,gNetworkProviderName);
			gRegisterState=notregisterdandsearching;
            gNetworkType=UNKNOWN_NT;
            gPacketDataNetworkType=NO_DATA_SERVICE;
			putvalue(env_FSG_RegisterState, gRegisterState);
            putvalue(env_FSG_NetworkType,gNetworkType);
            putvalue(env_FSG_PacketDataNetworkType,gPacketDataNetworkType);

			settimer(registerstatetimer, gtime_registerstatetimer);
			RegisterState_Request(Data_REQ, 0);											//send register state
		}
		else                                                                            //LockState !=Nolock
        {
		    if(gNetworkProviderState)
                settimer(nonetworktimer,10);
            
            strncpy(gServiceProviderName,gNetworkProviderName,40);                      //delete old name
            gServiceProviderState=0;        
            putvalue(env_FSG_ServiceProviderState,gServiceProviderState);
        }
	}

}

on envVar env_FSG_DisconnectReason_OK
{
    //changes from Jöran Karl (28.03.2012)
    if((gFSG_Telephone_PowerOnOff == Power_on) && getvalue(this) && (getvalue(env_FSG_DisconnectReason_Active) != FALSE))
    {
        gDisconnectReason=getvalue(env_FSG_DisconnectReason);
        DisconnectReason_Request(Data_REQ, 0);
    }
}

on envVar env_FSG_Keypad_eCall_long
{
int i;

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this)){
		gKeypadStatus=0x20;
		if(gKeypadTimer_status){
			canceltimer(KeypadTimer);
			settimer(KeypadTimer, KeypadTimerTime);
		}
		else{
			settimer(KeypadTimer, KeypadTimerTime);
			gKeypadTimer_status=1;
		}
		Keypad_Request(Data_REQ, 0);

//		if(gDialNumber_status==0)
//		{
//			for(i=0;i<40;i++)												//delete dial-number array
//				gDialNumber[i]=0;
//			for(i=0;i<50;i++)												//delete dial-number-name array
//				gDialNumber_name[i]=0;
//		
//			gcallID=callstates_status(dialing);								//aks for free Call-ID
//		//	write("FSG-Telephone dialnumber CallID: %d", gcallID);				//debug
//		
//			if(gRegisterState==1 && gcallID!=0xff)
//			{
//				strncpy(gDialNumber, info, 40);
//				strncpy(gDialNumber_name, info_pbname, 50);
//				gdialnumber_numbertype=infocall;
//						
//				putvalue(env_FSG_dialednumber_name, gDialNumber_name);				//write name of dialed number in callstack
//				putvalue(env_FSG_dialednumber_numbertype, gdialnumber_numbertype);	//write numbertype of dialed number in callstack
//				putvalue(env_FSG_dialednumber_callstack, gDialNumber);				//write dialed number in callstack
//				settimer(checknetworktimer, gtime_checknetworktimer);
//			}
//		}
	}
}

on envVar env_FSG_Keypad_eCall_short
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this)){
		gKeypadStatus=0x10;
		if(gKeypadTimer_status){
			canceltimer(KeypadTimer);
			settimer(KeypadTimer, KeypadTimerTime);
		}
		else{
			settimer(KeypadTimer, KeypadTimerTime);
			gKeypadTimer_status=1;
		}
		Keypad_Request(Data_REQ, 0);
	}

}

on envVar env_FSG_ChargeLevelM1
{
    if(gFSG_Telephone_PowerOnOff==Power_on)
    {
        if(getvalue(this)>=101 && getvalue(this)<=253)              //Value between 100 and 254
            gChargeLevelMobile1=100;                                //Set level to 100%
        else
            gChargeLevelMobile1=getvalue(this);                     //Set level by value
        if(gChargeLevelMobile1<=LOW_CHARGE_LEVEL)                   //Level under LOW_CHARGE_LEVEL
            gWarningLevel=gWarningLevel|0x01;                       //activate warning mobile1
        else
            gWarningLevel=gWarningLevel&0xFE;                       //deactivate warning mobile1
        settimer(MobileBatteryLevelTimer,1);                        //timer to send request
    }  
}

MobileBatteryLevel_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Data_REQ:
             //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x2B_TimeOut)!=TRUE)
            {
    			requestarray[0]=LSGID_Telephone;	//LSG-ID
    			requestarray[1]=FctID_MobileBatteryLevel;	//Fct.-ID
    			requestarray[2]=request;	
    			requestarray[3]=gChargeLevelMobile1;
    			requestarray[4]=gChargeLevelMobile2;
                requestarray[5]=gChargeLevelHandset1;
                requestarray[6]=gChargeLevelHandset2;
                requestarray[7]=gWarningLevel;
    			Offset=8;
    			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_MobileBatteryLevel;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone MobileBatteryLevel_Request: unknown request %d", request);
		break;
	}
}

MobileBatteryLevel_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			if(datalength!=3)															//datalength error
				MobileBatteryLevel_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				MobileBatteryLevel_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone MobileBatteryLevel_Indication: unknown indication %d", indication);
		break;
	}
}

on envVar env_FSG_ChargeLevelM2
{
    if(gFSG_Telephone_PowerOnOff==Power_on)
    {
        if(getvalue(this)>=101 && getvalue(this)<=253)              //Value between 100 and 254
            gChargeLevelMobile2=100;                                //Set level to 100%
        else
            gChargeLevelMobile2=getvalue(this);                     //Set level by value
        if(gChargeLevelMobile2<=LOW_CHARGE_LEVEL)                   //Level under LOW_CHARGE_LEVEL
            gWarningLevel=gWarningLevel|0x02;                       //activate warning mobile2
        else
            gWarningLevel=gWarningLevel&0xFD;                       //deactivate warning mobile2
        settimer(MobileBatteryLevelTimer,1);                        //timer to send request
    }  
}

on envVar env_FSG_ChargeLevelH1
{
    if(gFSG_Telephone_PowerOnOff==Power_on)
    {
        if(getvalue(this)>=101 && getvalue(this)<=253)              //Value between 100 and 254
            gChargeLevelHandset1=100;                               //Set level to 100%
        else
            gChargeLevelHandset1=getvalue(this);                    //Set level by value
        if(gChargeLevelHandset1<=LOW_CHARGE_LEVEL)                  //Level under LOW_CHARGE_LEVEL
            gWarningLevel=gWarningLevel|0x04;                       //activate warning handset1
        else
            gWarningLevel=gWarningLevel&0xFB;                       //deactivate warning handset1
        settimer(MobileBatteryLevelTimer,1);                        //timer to send request
    }  
}

on envVar env_FSG_ChargeLevelH2
{
    if(gFSG_Telephone_PowerOnOff==Power_on)
    {
        if(getvalue(this)>=101 && getvalue(this)<=253)              //Value between 100 and 254
            gChargeLevelHandset2=100;                               //Set level to 100%
        else
            gChargeLevelHandset2=getvalue(this);                    //Set level by value
        if(gChargeLevelHandset2<=LOW_CHARGE_LEVEL)                  //Level under LOW_CHARGE_LEVEL
            gWarningLevel=gWarningLevel|0x08;                       //activate warning handset2
        else
            gWarningLevel=gWarningLevel&0xF7;                       //deactivate warning handset2
        settimer(MobileBatteryLevelTimer,1);                        //timer to send request
    }  
}

on timer DataConnectionIndicationTimer
{
    //init local variables
    dword i;
    //

    for(i=0;i<=TESTRATE;i++)
    {
        gDataVolumeUplink++;
        gDataVolumeDownlink++;
    }
    putvalue(env_FSG_DataVolumeUplink,gDataVolumeUplink);
    putvalue(env_FSG_DataVolumeDownlink,gDataVolumeDownlink);
    
    DataConnectionIndication_Request(Data_REQ, 0);
    if(gConnectionIndication)
        settimer(DataConnectionIndicationTimer,2);
}

//IssueList #51
//on envVar env_FSG_ConnectionIndication
on envVar env_FSG_DataConnInd_OK
{
    //if(gFSG_Telephone_PowerOnOff==Power_on)
    if((gFSG_Telephone_PowerOnOff==Power_on) && getValue(this))
    {
        //if(getvalue(this))                    //DataConnection active
        if(getvalue(env_FSG_ConnectionIndication)) 
        {
            gConnectionIndication=TRUE;             //DataConnection active
            settimer(DataConnectionIndicationTimer,2);
        }
        else                                        //No data connecion or reserved value
        {
            gConnectionIndication=FALSE;            //No data connection
            canceltimer(DataConnectionIndicationTimer);

            gDataVolumeUplink=0;                    //Reset
            putvalue(env_FSG_DataVolumeUplink,gDataVolumeUplink);
            gDataVolumeDownlink=0;
            putvalue(env_FSG_DataVolumeDownlink,gDataVolumeDownlink);

            DataConnectionIndication_Request(Data_REQ, 0);
        }
    }
}

on envVar env_FSG_ConIndication_Reset
{
    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
        gDataVolumeUplink=0;
        putvalue(env_FSG_DataVolumeUplink,gDataVolumeUplink);
        gDataVolumeDownlink=0;
        putvalue(env_FSG_DataVolumeDownlink,gDataVolumeDownlink);

        DataConnectionIndication_Request(Data_REQ, 0);
    }
}

DataConnectionIndication_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Data_REQ:
             //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x2C_TimeOut)!=TRUE)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_DataConnectionIndication;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=gConnectionIndication;
            //write("debug: up: %d // %x... down: %d // %x", gDataVolumeUplink, gDataVolumeUplink, gDataVolumeDownlink, gDataVolumeDownlink);
			//changes from Jöran Karl (28.03.2012)
			requestarray[4]=(gDataVolumeUplink         ) & 0xFF;  //mask lowest byte
            requestarray[5]=(gDataVolumeUplink    >>  8) & 0xFF;  //mask second byte
            requestarray[6]=(gDataVolumeUplink    >> 16) & 0xFF;  //mask third byte
            requestarray[7]=(gDataVolumeUplink    >> 24) & 0xFF;  //mask highest byte

            requestarray[8]= (gDataVolumeDownlink      ) & 0xFF; //mask lowest byte
            requestarray[9]= (gDataVolumeDownlink >>  8) & 0xFF; //mask second byte
            requestarray[10]=(gDataVolumeDownlink >> 16) & 0xFF; //mask third byte
            requestarray[11]=(gDataVolumeDownlink >> 24) & 0xFF; //mask highest byte
			Offset=12;
			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_DataConnectionIndication;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone DataConnectionIndication_Request: unknown request %d", request);
		break;
	}
}

DataConnectionIndication_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication){
		case DataGet_IND:
			if(datalength!=3)															//datalength error
				DataConnectionIndication_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				DataConnectionIndication_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone DataConnectionIndication_Indication: unknown indication %d", indication);
		break;
	}
}

on envVar env_FSG_HangupCall
{
byte i;
byte HangupPossible;


//init lokal variables
    i=0;
    HangupPossible=0;
//********************
  //IssueList #26 - CANoe crash
   gFirstPress = 0x00;  

   //IssueList #122
   allCallsHangUpFlg = 0x00;

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this)) 
    {

        //IssueList #49
        EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);
		gHangupCall_CallID=getvalue(env_FSG_HangupCall_CallID);
        
        if(gHangupCall_CallID<7)        //Single call hangup
        {
            HangupPossible=check_hangup(gHangupCall_CallID);

            if(HangupPossible==1)          //only when call or emergency call is ring_waiting/dialing/active/hold
			{    
                
                //MR60227
                gActiveCall_HangUpPressed = 1;
                //set_CallState(gHangupCall_CallID, disconnecting);
                //settimer(disconnectingtimer, disconnecttime);
                //IssueList #79 - MR50008
                     set_CallState_noReq (gHangupCall_CallID, disconnecting);       //set call state without request
                    //if (gHangupCall_CallID>0)
                    //{
                        for(i=0;i<7;i++)							                //searching for active calls
                        {
                         if(gCallState[i]==onhold)                                  //searching for calls on hold
                         //set_CallState(i,onhold);	                                //set call state
                          set_CallState_noReq (i, onhold);                          //set call state without request                       
                        }
                    //}
                    CallState_Request(Data_REQ,0);                                  //send call state
                    settimer(disconnectingtimer, disconnecttime);
            }
		    else
                writelineEx(gError_Trace, 0, "FSG-Telephone HangupCall-Error: 0x%x", HangupPossible);
        
		}
        else
        {
             //IssuList #122
             allCallsHangUpFlg = 0x01;
            switch(gHangupCall_CallID)
            { 
                case ALL_ACTIVE_CALLS:
                    for(i=0;i<7;i++)
                    {
					    if(gCallState[i]==active)
                            // changes from Jan Swoboda (01.03.2012)
			            set_CallState_noReq(i,disconnecting);
                        
                    }
                break;
                case ALL_HELD_CALLS:
                    for(i=0;i<7;i++)
                    {
					    if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
                            // changes from Jan Swoboda (01.03.2012)
			    set_CallState_noReq(i,disconnecting);
                    }
                break;
                case ALL_ACTIVE_AND_HELD_CALLS:
                    for(i=0;i<7;i++)
                    {
					    if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD || gCallState[i]==active)
                            // changes from Jan Swoboda (01.03.2012)
			    set_CallState_noReq(i,disconnecting);
                    }
                break;
                case ALL_CALLS:
                    for(i=0;i<7;i++)
                    {
					    if(gCallState[i]!=idle)
                            // changes from Jan Swoboda (01.03.2012)
			    set_CallState_noReq(i,disconnecting);
                    }
                break;
            }
            // changes from Jan Swoboda (01.03.2012)
	    if (gCallStateRequestPending)
                CallState_Request(Data_REQ,0);
            settimer(disconnectingtimer2, disconnecttime);
        }
                    //IssueList #83 & IssueList #88 (deleted #65)
                    //IssueList #65
                    /*for(i=0;i<7;i++)
                    {
					    if(gCallState[i]==onhold)
			            set_CallState_noReq(i,active);
                    }*/
	}
}

on timer MobileBatteryLevelTimer
{
    MobileBatteryLevel_Request(Data_REQ, 0);
}

on envVar env_FSG_ChargeLevelH2_Init
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
	    //IssueList #164 - remove if condition
       //if(getvalue(env_FSG_ChargeLevelH2)>=101 && getvalue(env_FSG_ChargeLevelH2)<=253)              //Value between 100 and 254
            //gChargeLevelHandset2=100;                               //Set level to 100%
        //else
            gChargeLevelHandset2=getvalue(env_FSG_ChargeLevelH2);                    //Set level by value

        putvalue(env_FSG_ChargeLevelH2,gChargeLevelHandset2);

        if(gChargeLevelHandset2<=LOW_CHARGE_LEVEL)                  //Level under LOW_CHARGE_LEVEL
            gWarningLevel=gWarningLevel|0x04;                       //activate warning handset2
        else
            gWarningLevel=gWarningLevel&0xFB;                       //deactivate warning handset2
    }
}

on envVar env_FSG_ChargeLevelM1_Init
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
	    //IssueList #164 - remove if condition
       //if(getvalue(env_FSG_ChargeLevelM1)>=101 && getvalue(env_FSG_ChargeLevelM1)<=253)              //Value between 100 and 254
            //gChargeLevelMobile1=100;                               //Set level to 100%
        //else
            gChargeLevelMobile1=getvalue(env_FSG_ChargeLevelM1);                    //Set level by value

        putvalue(env_FSG_ChargeLevelM1,gChargeLevelMobile1);
    }
}

on envVar env_FSG_ChargeLevelM2_Init
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
	    //IssueList #164 - remove if condition
       //if(getvalue(env_FSG_ChargeLevelM2)>=101 && getvalue(env_FSG_ChargeLevelM2)<=253)              //Value between 100 and 254
            //gChargeLevelMobile2=100;                               //Set level to 100%
        //else
            gChargeLevelMobile2=getvalue(env_FSG_ChargeLevelM2);                    //Set level by value

        putvalue(env_FSG_ChargeLevelM2,gChargeLevelMobile2);
    }
}

on envVar env_FSG_DialNumber
{
int nulength, nalength, is_emergency_call;
byte valid=0;
char i, empty_string [3];

//init lokal variables
	nulength=0;     //stringlength of number 
    nalength=0;     //stringlenght of name
	for(i=0;i<3;i++)
		empty_string[i]=0;
//********************
//IssueList# 26
//Dial button flag
if (getValue(this))
{
gDialbuttonOn = 0x01;


//IssueList #20
gPhonebookRequestActive = 0x00;
}

	//IssueList #26 - CANoe crashes
    //if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && (gFirstPress ==0))
    {
    gFirstPress = 0x01;

        //IssueList #47
        if (getValue(env_FSG_Tel_DialNumber_Error_On))
            { DialNumber_Request(Error_REQ, getValue(env_FSG_Tel_DialNumber_ErrorCode)); // send error-message
            gFirstPress = 0x00;
            }
        else if(gDialNumber_status!=0)											//method is still active
		{
			//write("FSG-Telephone: Method DialNumber still in process!");      //debug
		}
		else
		{
            gCallStartedFromASG = 0; 

			gDialNumber_status = 1;											//method "dialnumber" is active

			for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)												//delete dial-number array
				gDialNumber[i] = 0;
			for(i=0;i<DIAL_NUMBER_NAME_LENGTH;i++)												//delete dial-number-name array
				gDialNumber_name[i] = 0;

            getvalue(env_FSG_DialNumber_TelNumber, gDialNumber);	
		    getvalue(env_FSG_DialNumber_Name, gDialNumber_name);


            //IssueList #26
            putvalue(env_FSG_AutoRedialExtInfo_TelNo, gDialNumber);
            putvalue(env_FSG_AutoRedialExtInfo_Name, gDialNumber_name);
            putvalue(env_FSG_DialNumber_Name_M, gDialNumber_name);
            putvalue(env_FSG_DialNumber_TelNumber_M, gDialNumber);

            //IssueList #101
            strncpy(gDialNumber_name2,gDialNumber_name,strlen(gDialNumber_name)+1);
		    nulength=strlen(gDialNumber);
            nalength=strlen(gDialNumber_name);

			//gcallID=callstates_status(dialing);							//aks for free Call-ID
				//write("FSG-Telephone dialnumber CallID: %d", gcallID);				//debug
			//********verify number and PbName**********
			//******Number*********
			if (nulength==0)														//no number
			{
				//write("Error string length");										//debug
				gDialNumber_status=0;												//method "dialnumber" is finished
			}
			else//	valid
				valid=tel_number_valid (gDialNumber, nulength);						//check each part of the new number of correctness
			//*****end number*******
			if(valid==TRUE)														//valid number
			{
				//********Name*********
				if(nalength>0)			
				{
					//write("FSG-Telephone dialnumber, numbername: %s", gDialNumber_name);//debug							
					gnumbersearchphonebook=2;
					settimer(numbersearchphonebooktimer, 5);
				}
				else if(strncmp(gDialNumber, info, CALL_INFO_NUMBER_LENGTH)==0)      //InfoCall
				{
					strncpy(gDialNumber_name, info_pbname, CALL_INFO_NAME_LENGTH);
					gdialnumber_numbertype=infocall;
					gnumbersearchphonebook=2;
					settimer(numbersearchphonebooktimer, 5);
				}
				else if(strncmp(gDialNumber, service, CALL_INFO_NUMBER_LENGTH)==0)   //ServiceCall
				{
					strncpy(gDialNumber_name, service_pbname, CALL_INFO_NAME_LENGTH);
					gdialnumber_numbertype=servicecall;
					gnumbersearchphonebook=2;
					settimer(numbersearchphonebooktimer, 5);
				}
				else        //no name available
				{
					//putvalue(env_FSG_phonebook_number, gDialNumber);
					gnumbersearchphonebook=1;
                    			gDialNumActive = 0x01;
					settimer(numbersearchphonebooktimer, 100);
				}
				//******end name*******
			}
            else
            {
                //write("number invalid");          //debug
                gDialNumber_status=0;
            }
			//**********end number-/name-verification*******
				
			//********check registerstate and callstate***********

            is_emergency_call = detect_emergency_number();

			if(PhoneModuleOn != gTel_State && MobileOn != gTel_State)				//GMS-module or mobile not active
			{
				//write("no DialNumber possible - Mobile off");     //debug
			    gDialNumber_status = 0;															//method is finished
			}
			
            //IssueList #42
            //else if(gRegisterState != 1)
            else if((gRegisterState != 1)&&(gRegisterState != 4)&&(gRegisterState != 5)	)																//not registered
			{
			    if(is_emergency_call != 1)	//not registered and no emergency call
				{
					//write("no network, emergency call only");									//debug
					gDialNumber_status=0;														//method "dialnumber" is finished
				}
				else						//emergency call but not registered
				{
					if (gLockState != nolock)	//emergency call but not registered and no SIM
						gemergencycall = 3;
					else					//emergency call but not registered and SIM OK
						gemergencycall = 2;	

					//while(provider==0)		//searching for provider
					//	provider=random(4);
					           
                    putvalue(env_FSG_NetworkProviderState, 1);
					//putvalue(env_FSG_networkprovider, provider);					//new provider
				}
			}
			else															//registered and one call-ID-state is "idle" and no other call-ID-state is "active/dialing/disconnecting"
			{
                gemergencycall = (is_emergency_call == 1) ? 1 : 0;


			    if(!valid)													//number invalid
				{
					//write("invalid number");								//debug
					gDialNumber_status=0;									//method "dialnumber" is finished
				}
				else
				{
					if(gConfirmCall == 1) // call needs to be confirmed manually ?
                    {
                        //write("call needs confirmation");                    

                        gCallOutgoingDiverted_eCallConfirmationPending[7] = 1;
                        CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = true
                        //IssueList #160 MR49588
                        //setTimer (checkEcallConfirmPending,5); //addition of assumed 5 second time out for confirmPending flag check
                        //IssueList #167
                        setTimer (checkEcallConfirmPending,10); //changed to 10s

                        //IssueList #136 -commented
                        //gDialNumber_Result = 0x0a; // not successful - confirm emergency call
                        //DialNumber_Request(Result_REQ, 0);
                    }
                    else
                    {
                        //write("call does not need confirmation");

                        gcallID = callstates_status(dialing); //aks for free Call-ID
                        
                        //MR60227
                        if (getValue(env_PIC_bapMOST_active_flag)==0x01)
                        {
                         gBapMostCallID= gcallID;
                         gActiveCall_active = 1;
                         gActiveCall_CallMethodActive=1;
                         gActiveCall_Dialled =1;
                         setActiveCall_Picture();

                        if (gActiveCall_BAPdelayFlag==0)
                        settimer(checknetworktimer, gtime_checknetworktimer);					//start timer for searching in phonebook
                        else
                        settimer(checknetworktimer, getValue(env_AudioTel_bapMost_delayTimer)*1000);
                        }
                         //MR 63212
			else if (getValue(env_PIC_bapMOST_active_flag)==0x00)
                        settimer(checknetworktimer, gtime_checknetworktimer);

                   
                        if(gcallID == 0xff)
    						gDialNumber_status = 0;
                        
                        if (getValue(env_PIC_bapMOST_active_flag)==0x00)
    					settimer(checknetworktimer, gtime_checknetworktimer);

                    }
    		    }
			}
		}
	}
}

CallInfo_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];
//IssueList #46
//byte requestarray_pbName[BAP_buffer_size];

// changes from Jan Swoboda (01.03.2012)
int callid;
int test;

//init lokal variables
	Offset=0;
	
	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch (request){
		case Data_REQ:
         //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x17_TimeOut)!=TRUE)
            {
    			requestarray[0]=LSGID_Telephone;	//LSG-ID
    			requestarray[1]=FctID_CallInfo;	//Fct.-ID
    			requestarray[2]=request;	
            
                Offset=3;
                //IssueList #41
                getvalue(env_FSG_DialNumber_Name, gCallInfoDialNumber_name);
    //*************************************************
               // changes from Jan Swoboda (01.03.2012)
    	    for (callid = 0; callid < 7; ++callid)
                {
        			//IssueList #84 & 85
                    //IssueList #41
                    //if ((gIncomingCallPress==0x01)||(((strncmp(gCallInfoDialNumber_name, gempty_string, 3) == 0))&&(gDialNumActive==0x01)))
                      if (gIncomingCallPress==0x01 && strncmp(gCallInfo_TelNumber[callid],gempty_string, 3) == 0 )
                        {
                        //requestarray[Offset]=0x00;
                        requestarray[Offset]=0x01;
                        Offset++;
                        requestarray[Offset]=0x00;
                        Offset++;
                        gIncomingCallPress = 0x00;
                        
                        }
                        //IssueList #101
                        else if (gDialNumActive==0x01 && strncmp(gCallInfoDialNumber_name,gempty_string, 3) == 0 )
                        {
                        requestarray[Offset]=0x01;
                        Offset++;
                        requestarray[Offset]=0x00;
                        Offset++;
                        gDialNumActive = 0x00;
                        }
                        else if (strncmp(gCallInfo_PbName[callid],gCallInfo_TelNumber[callid], strlen(gCallInfo_PbName[callid])) == 0 && (strncmp(gCallInfo_TelNumber[callid],gempty_string, 3)) != 0 )
                        {
                        gIncomingCallPress = 0x00;
                        requestarray[Offset]=0x01;
                        Offset++;
                        requestarray[Offset]=0x00;
                        Offset++;
                        }
                    else
                    {
                        requestarray[Offset]=strlen(gCallInfo_PbName[callid]);
                        Offset++;
            			for(i=0;i<strlen(gCallInfo_PbName[callid]);i++)
                        {
            				requestarray[Offset]=gCallInfo_PbName[callid][i];
                            
                            //IssueList #46
                            //requestarray_pbName[i] = requestarray[Offset];
                            //if (requestarray_pbName[i]>= 0x80)
                            //requestarray[Offset] =0x5F;   //replacing invalid character with '_'

                            Offset++;
            			}
                    }

        			requestarray[Offset]=strlen(gCallInfo_TelNumber[callid]);
                    Offset++;
        			for(i=0;i<strlen(gCallInfo_TelNumber[callid]);i++)
                    {
        				requestarray[Offset]=gCallInfo_TelNumber[callid][i];
        				Offset++;
        			}

                     //IssueList #20
                     if ((gPhonebookRequestActive == 0x01)&& (callid ==gcallID))
                    {
                    gCallInfo_Category[callid] = gDialNumber_Category;
                    putvalue_CallInfo_category(callid);
                     }

                    requestarray[Offset]=gCallInfo_Category[callid];
                    Offset++;
                    
                }
    //*************************************************
	
    			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);	//send CallState
              
            }
		break;
		case Error_REQ:
			//BAP-header
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_CallState;	//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);	//send CallState
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone callstate_request: unknown request %d", request);
		break;
	}

}

CallInfo_Indication(dword Indication_array [], byte indication, int datalength)
{
byte temp;

//init lokal variables
	temp=0;
//********************

	switch(indication){
		case DataGet_IND:
			//check BAP-array
			if(datalength!=4)	//datalength error
				CallInfo_Request(Error_REQ, Terror_datainvalid);	//send error-message to RNS
			else
				CallInfo_Request(Data_REQ,0);	//send call Info
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone CallInfo indication: unknown indication %d", indication);
		break;

	}
}

on envVar env_FSG_CallDurationSync_OK
{
    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
        gTimeStampCall[0]=getvalue(env_FSG_CallDurationSync_0);
        gTimeStampCall[1]=getvalue(env_FSG_CallDurationSync_1);
        gTimeStampCall[2]=getvalue(env_FSG_CallDurationSync_2);
        gTimeStampCall[3]=getvalue(env_FSG_CallDurationSync_3);
        gTimeStampCall[4]=getvalue(env_FSG_CallDurationSync_4);
        gTimeStampCall[5]=getvalue(env_FSG_CallDurationSync_5);
        gTimeStampCall[6]=getvalue(env_FSG_CallDurationSync_6);

        CallDurationSync_Request(Data_REQ,0);
    }
        

}

CallDurationSync_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************


	switch(request)
    {
		case Data_REQ:
            //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x18_TimeOut)!=TRUE)
            {
    			requestarray[0]=LSGID_Telephone;	//LSG-ID
    			requestarray[1]=FctID_CallDurationSync;	//Fct.-ID
    			requestarray[2]=request;
            	
    			//changes from Jöran Karl (28.03.2012)
    			Offset = 3;
                for (i = 0; i < 7; i++)
                {
                    requestarray[Offset++] = (gTimeStampCall[i]     ) & 0xFF;
                    requestarray[Offset++] = (gTimeStampCall[i] >> 8) & 0xFF;
                }

    			set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_CallDurationSync;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone CallDurationSync_Request: unknown request %d", request);
    }
}

CallDurationSync_Indication (dword Indication_array [], byte indication, int datalength)
{
	switch (indication)
    {
		case DataGet_IND:
			if(datalength!=4)													//datalength error
				CallDurationSync_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				CallDurationSync_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone CallDurationSync_Indication: unknown indication %d", indication);
		break;
	}
}

on envVar env_FSG_PbState_OK
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
		gDownLoadState=getvalue(env_FSG_PbState_DownloadState);
        gPbEntriesUHV=getvalue(env_FSG_PbState_EntriesUHV);
		
		PbState_Request(Data_REQ, 0);
	}
}

MissedCalls_init_static()
{

byte j, i, missedcallline;
	
    //clear
    missedcallline   =0;
    gmissedcalls_TotalNumListElements  =0;

	for(j=0;j<CALLSTACK;j++) //reset callstack MissedCalls
	{
		gmissedcalls_pos[j] =0;
		for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
			gmissedcalls_pbname[j][i] =0;
        for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
			gmissedcalls_telnumber[j][i] =0;
        gmissedcalls_numbertype[j] =0;
        for(i=0;i<7;i++)
			gmissedcalls_date[j][i] =0;
        for(i=0;i<7;i++)
			gmissedcalls_time[j][i] =0;

        
	}
	  	
    //entry 0
	gmissedcalls_pos[missedcallline] =3;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz0",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210500",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 1
	gmissedcalls_pos[missedcallline] =6;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz1",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210501",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 2
	gmissedcalls_pos[missedcallline] =9;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz2",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210502",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;
    
    //entry 3
	gmissedcalls_pos[missedcallline] =12;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz3",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210503",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;
    
    //entry 4
	gmissedcalls_pos[missedcallline] =15;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz4",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210504",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 5
	gmissedcalls_pos[missedcallline] =18;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz5",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210505",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 6
	gmissedcalls_pos[missedcallline] =21;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz6",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210506",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 7
	gmissedcalls_pos[missedcallline] =24;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz7",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210507",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 8
	gmissedcalls_pos[missedcallline] =27;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz8",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210508",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 9
	gmissedcalls_pos[missedcallline] =30;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz9",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210509",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 10
	gmissedcalls_pos[missedcallline] =33;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz10",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210510",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 11
	gmissedcalls_pos[missedcallline] =36;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz11",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210511",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 12
	gmissedcalls_pos[missedcallline] =39;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz12",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210512",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 13
	gmissedcalls_pos[missedcallline] =42;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz13",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210513",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 14
	gmissedcalls_pos[missedcallline] =45;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz14",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210514",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 15
	gmissedcalls_pos[missedcallline] =48;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz15",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210515",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 16
	gmissedcalls_pos[missedcallline] =51;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz16",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210516",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 17
	gmissedcalls_pos[missedcallline] =54;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz17",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210517",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 18
	gmissedcalls_pos[missedcallline] =57;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz18",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210518",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 19
	gmissedcalls_pos[missedcallline] =60;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz19",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210519",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 20
	gmissedcalls_pos[missedcallline] =63;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz20",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210520",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 21
	gmissedcalls_pos[missedcallline] =66;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz21",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210521",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 22
	gmissedcalls_pos[missedcallline] =69;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz22",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210522",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 23
	gmissedcalls_pos[missedcallline] =72;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz23",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210523",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 24
	gmissedcalls_pos[missedcallline] =75;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz24",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210524",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 25
	gmissedcalls_pos[missedcallline] =78;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz25",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210525",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 26
	gmissedcalls_pos[missedcallline] =81;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz26",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210526",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 27
	gmissedcalls_pos[missedcallline] =84;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz27",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210527",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 28
	gmissedcalls_pos[missedcallline] =87;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz28",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210528",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 29
	gmissedcalls_pos[missedcallline] =90;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz29",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210529",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 30
	gmissedcalls_pos[missedcallline] =93;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz30",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210530",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 31
	gmissedcalls_pos[missedcallline] =96;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz31",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210531",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 32
	gmissedcalls_pos[missedcallline] =99;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz32",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210532",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 33
	gmissedcalls_pos[missedcallline] =102;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz33",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210533",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 34
	gmissedcalls_pos[missedcallline] =105;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz34",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210534",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 35
	gmissedcalls_pos[missedcallline] =108;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz35",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210535",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 36
	gmissedcalls_pos[missedcallline] =111;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz36",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210536",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 37
	gmissedcalls_pos[missedcallline] =114;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz37",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210537",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 38
	gmissedcalls_pos[missedcallline] =117;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz38",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210538",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;

    //entry 39
	gmissedcalls_pos[missedcallline] =120;
    strncpy(gmissedcalls_pbname [missedcallline], "Moritz39",CALL_INFO_NAME_LENGTH);
    strncpy(gmissedcalls_telnumber [missedcallline], "012345",CALL_INFO_NUMBER_LENGTH);
    gmissedcalls_numbertype [missedcallline]= MOBILE;
    strncpy(gmissedcalls_date [missedcallline], "210539",7);
    strncpy(gmissedcalls_time [missedcallline], "234559",7);
    
    missedcallline++;
    
    gmissedcalls_TotalNumListElements=missedcallline;
    putvalue(env_FSG_MissedCalls_TotalNumLE, gmissedcalls_TotalNumListElements);
    
    display_callstack_missedcalls();

    //MissedCalls_Request(Changed_REQ, 0, 0, 0xFFFF, 0, 0);

    //write Array in "write-window"
    /*
    writeClear(gMissedCalls_writeWindow);
    writelineEx(gMissedCalls_writeWindow, 0, "");
    writelineEx(gMissedCalls_writeWindow, 0,"*******Default MissedCalls_Array*******");
    writelineEx(gMissedCalls_writeWindow, 0, "");
    
    for (i=0;i<gmissedcalls_TotalNumListElements;i++)
    {
        writelineEx(gMissedCalls_writeWindow, 0,"*******Element %d*******",i);
        
        writelineEx(gMissedCalls_writeWindow, 0,"Pos[%d]: 0x%x", i, gmissedcalls_pos [i]);
                     
        writelineEx(gMissedCalls_writeWindow, 0,"PbName[%d]: %s",i, gmissedcalls_pbname[i]);

        writelineEx(gMissedCalls_writeWindow, 0,"TelNumber[%d]: %s",i, gmissedcalls_telnumber[i]);

        writelineEx(gMissedCalls_writeWindow, 0,"NumberType[%d]: 0x%x", i, gmissedcalls_numbertype [i]);
        
        writelineEx(gMissedCalls_writeWindow, 0,"Date[%d]: %s",i, gmissedcalls_date[i]);

        writelineEx(gMissedCalls_writeWindow, 0,"Time[%d]: %s",i, gmissedcalls_time[i]);

        writelineEx(gMissedCalls_writeWindow, 0, "");
    }

    writelineEx(gMissedCalls_writeWindow, 0,"Anzahl der Listenelemente: %d", gmissedcalls_TotalNumListElements);
    */
    
}

on envVar env_FSG_MissedCalls_DataSource
{
    if (getvalue(this) ==TEL_DEFAULT_LIST)
    {
        MissedCalls_init_static();
        putvalue(env_FSG_MissedCalls_DS_file, gempty_string);
        putvalue(env_FSG_MissedCalls_DS_result, gempty_string);
    }
}

on envVar env_FSG_MissedCalls_reload //load external MissedCalls from *.csv
{
    if(getvalue(this) && getvalue(env_FSG_MissedCalls_DataSource) ==TEL_EXTERNAL_LIST)
	    MissedCalls_init_CSV();

    else if(getvalue(env_FSG_MissedCalls_DataSource) != TEL_EXTERNAL_LIST)
        putvalue(env_FSG_MissedCalls_DS_result,"not successful, select 'external *.csv'");
}

MissedCalls_init_csv ()
{
    int i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
    dword CSVfileHandle =0, ConfigFileHandle =0;
    char buffer_string[TEL_BUFFERSIZE], Path_CSV[TEL_BUFFERSIZE], Path_Config[TEL_BUFFERSIZE];
    byte missedcallsline =0, buffer_byte[TEL_BUFFERSIZE];
    char missedcalls_pos_string [CALLSTACK][TEL_TEXTLENGTH];           //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
    char missedcalls_numbertype_string [CALLSTACK][TEL_TEXTLENGTH];           //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv 

    if(getvalue(env_FSG_MissedCalls_DataSource) == TEL_EXTERNAL_LIST) //output data in write window "FSGFavoriteDestList"  
    {
        writeClear(gMissedCalls_writeWindow);
        writelineEx(gMissedCalls_writeWindow, 0,"*******External MissedCalls*******");
        writelineEx(gMissedCalls_writeWindow, 0, "");
        writelineEx(gMissedCalls_writeWindow, 0, "**********************Start load new MissedCalls**********************");   
    
		    //clear
        gmissedcalls_TotalNumListElements  =0;

	    for(j=0;j<CALLSTACK;j++) 
	    {
		    gmissedcalls_pos[j] =0;
		    for(i=0;i<CALL_INFO_NAME_LENGTH;i++)
			    gmissedcalls_pbname[j][i] =0;
            for(i=0;i<CALL_INFO_NUMBER_LENGTH;i++)
			    gmissedcalls_telnumber[j][i] =0;
            gmissedcalls_numbertype[j] =0;
            for(i=0;i<7;i++)
			    gmissedcalls_date[j][i] =0;
            for(i=0;i<7;i++)
			    gmissedcalls_time[j][i] =0;           
        }

        for(i=0;i<TEL_FILENAME_SIZE; i++) //clear "filename"
            gMissedCalls_CSV_filename[i] =0;       
        
        for(j=0;j<CALLSTACK; j++) //clear "buffer"
        {
            buffer_string[j]    =0;
            buffer_byte[j]      =0;

            for(i=0;i<TEL_TEXTLENGTH;i++) //clear help value
		    {
                missedcalls_pos_string[j][i]       =0;
                missedcalls_numbertype_string[j][i]   =0;
            }
        }        

        i =0; j =0; missedcallsline =0; current_CSV_line =0; //reset values 
                      
        getvalue(env_FSG_MissedCalls_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        
        //write("complete path *.csv: %s", Path_CSV); //debug
        
        i =0;

        while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after Favorite "\"
            {              
                gMissedCalls_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after Favorite "\"            
                count2++;
                               
            i++;
        }

        writelineEx(gMissedCalls_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 

        writelineEx(gMissedCalls_writeWindow, 0,"filename of *.csv: '%s'", gMissedCalls_CSV_filename);  //output filename 

        putvalue(env_FSG_MissedCalls_DS_file, gMissedCalls_CSV_filename); //output current loaded *.csv-file on panel

        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gMissedCalls_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

        if (CSVfileHandle!=0) //*.csv file access successful
        {
            writelineEx(gMissedCalls_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gMissedCalls_CSV_filename);    //output result  
            
            putvalue(env_FSG_MissedCalls_DS_result, "successful");   //output result on panel                      
            
            Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
                           
            for (i=0; i<Num_of_csv_byte; i++) //copy data into "MissedCalls"
            {      
                if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
                {
                    if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in MissedCalls) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                    {
                        if(current_CSV_line>0 && missedcallsline<CALLSTACK) //ignore first line in *.csv file
                        {   
                            writelineEx(gMissedCalls_writeWindow, 0, "");
                            writelineEx(gMissedCalls_writeWindow, 0,"*******Element %d*******",missedcallsline);

                            //transform 'string' to 'long' for "POS", "NumberType"
                            gmissedcalls_pos[missedcallsline]     =atol(missedcalls_pos_string[missedcallsline]);
                            gmissedcalls_numbertype[missedcallsline]     =atol(missedcalls_numbertype_string[missedcallsline]);                   
                            
                            writelineEx(gMissedCalls_writeWindow, 0,"Pos[%d]: 0x%x",missedcallsline, gmissedcalls_pos[missedcallsline]);

                            writelineEx(gMissedCalls_writeWindow, 0,"PbName[%d]: %s",missedcallsline, gmissedcalls_pbname[missedcallsline]);
                            
                            writelineEx(gMissedCalls_writeWindow, 0,"TelNumber[%d]: %s",missedcallsline, gmissedcalls_telnumber[missedcallsline]);
                            
                            writelineEx(gMissedCalls_writeWindow, 0,"Numbertype[%d]: 0x%x",missedcallsline, gmissedcalls_numbertype[missedcallsline]);

                            writelineEx(gMissedCalls_writeWindow, 0,"Date[%d]: %s",missedcallsline, gmissedcalls_date[missedcallsline]);
                            
                            writelineEx(gMissedCalls_writeWindow, 0,"Time[%d]: %s",missedcallsline, gmissedcalls_time[missedcallsline]);                            
                            
                                                
                            missedcallsline++; // -> next line in *.csv (next record element)
                        }

                        current_CSV_line++; //next line in *.csv file
                        element =0; //start at 'POS' (first record element of "array data")
                        j=0; //reset value
                    }
                      
                    else if(current_CSV_line>0 && missedcallsline<CALLSTACK) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                    {
                        switch (element)
                        {
                            case 0: //POS
                                    missedcalls_pos_string[missedcallsline][j] =buffer_byte[i];
                                    j++;
                            break;

                            case 1: //PbName
                                    gmissedcalls_pbname[missedcallsline][j] =buffer_byte[i];                                   
                                    j++;
                            break;

                            case 2: //TelNumber
                                    gmissedcalls_telnumber[missedcallsline][j] =buffer_byte[i];
                                    j++;                                
                            break;
                            case 3: //Numbertype
                                    missedcalls_numbertype_string[missedcallsline][j] =buffer_byte[i];
                                    j++;
                            break;
                            case 4: //Date
                                    gmissedcalls_date[missedcallsline][j] =buffer_byte[i];
                                    j++;
                            break;
                            case 5: //Time
                                    gmissedcalls_time[missedcallsline][j] =buffer_byte[i];
                                    j++;
                            break;                        
                            default:
                             break;
                        }
                    }                               
                }
                               
                else  // ";" is detected ->next record element of "array data"
                {                                          
                    element++;
                    j=0; //reset value  
                }                                              
        
            }         
            
            gmissedcalls_TotalNumListElements =missedcallsline; //get "total number of list elements"
            
            putvalue(env_FSG_MissedCalls_TotalNumLE, gmissedcalls_TotalNumListElements);

            writelineEx(gMissedCalls_writeWindow, 0, "");

            writelineEx(gMissedCalls_writeWindow, 0,"Anzahl der Listenelemente: %d", gmissedcalls_TotalNumListElements); //output total number of list elements

            writelineEx(gMissedCalls_writeWindow, 0, "");

            if(fileClose (CSVfileHandle) !=0) //close *.csv file
                writelineEx(gMissedCalls_writeWindow, 0,"Datei '%s' geschlossen", gMissedCalls_CSV_filename); //output result
             
            else
                writelineEx(gMissedCalls_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gMissedCalls_CSV_filename);//output result
            
            display_callstack_missedcalls();

            MissedCalls_Request(Changed_REQ, 0, 0, 0xFFFF, 0, 0);

        }

        else //*.csv file access not successful
        {
            writelineEx(gMissedCalls_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gMissedCalls_CSV_filename); //output result
            
            putvalue(env_FSG_MissedCalls_DS_result,"not successful"); //output result
        }
    }
}

on envVar env_FSG_MissedCalls_StatusArray
{
    word requested_startelement, startelement, elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        if(getvalue(env_FSG_MissedCalls_AH_start) >255 && getvalue(env_FSG_MissedCalls_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_FSG_MissedCalls_AH_IS,1);

        //get data from Panel
        gmissedcalls_ASG_ID                 =getvalue(env_FSG_MissedCalls_ASG_ID);
        gmissedcalls_TAID                  =getvalue(env_FSG_MissedCalls_TAID);
        gmissedcalls_TotalNumListElements  =getvalue(env_FSG_MissedCalls_TotalNumLE);

        recordaddress   =getvalue(env_FSG_MissedCalls_AH_RA);
        shift           =getvalue(env_FSG_MissedCalls_AH_shift);
        direction       =getvalue(env_FSG_MissedCalls_AH_dir);
        transmitpos     =getvalue(env_FSG_MissedCalls_AH_POS);
        indexsize       =getvalue(env_FSG_MissedCalls_AH_IS);
        startelement    =getvalue(env_FSG_MissedCalls_AH_start);
        elements        =getvalue(env_FSG_MissedCalls_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(startelement==0) //Startelement-ID =0 -> start at first array-entry
		{
            if(direction==FORWARD)  //FORWARD-start
			{
                valid_startelement =startelement;				       									

                if(elements>CALLSTACK) //1. more elements requested, than in array
				{
                    for(i=valid_startelement;i<CALLSTACK;i++)
					{
						if(gmissedcalls_pbname[i][0]!=0)	//if element is valid 
							valid_elements++;				//increment elements
						else								//no valid element
							i =CALLSTACK;                   //break loop 
					}
			    }
                else    //2. number of requested elements <= elements in array
				{
                    for(i=valid_startelement;i<(elements+valid_startelement);i++)
					{
						if(gmissedcalls_pbname[i][0]!=0)	//if element is valid 
							valid_elements++;				//increment elements
						else								//no valid element
							i =CALLSTACK;                   //break loop 
					}

				}
            }                                                               //FORWARD ends
            
            else if(direction==BACKWARD && shift==TRUE)						//BACKWARD-start, only if the shift bit is set
			{   
			    //searching for valid startelement
				for(i=(CALLSTACK-1);i>=0;i--)
				{
				    if(gmissedcalls_pbname[i][0]!=0)		//found valid startelement
					{
					    valid_startelement =i;								
						i =0;					//break loop							
					}
				}
                        
                //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in array
				{
				    valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				    for(i=valid_startelement;i>=0;i--)
					{
					    if(gmissedcalls_pbname[i][0]!=0)	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						    i=0;
				    }
				}
                else			//enougth array elements available
				{
				    for(i=valid_startelement;i>=((valid_startelement+1)-elements);i--)
					{
					    if(gmissedcalls_pbname[i][0]!=0)	//if element is valid 
							valid_elements++;				//increment elements
						else								//no valid element
							i=0;
					}                   
				}															
	        }                                                               //BACKWARD-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else																//searching for Startelement-ID				
		{
		    //searching for valid startelement
			for(i=0;i<CALLSTACK;i++)
			{
				if(gmissedcalls_pos[i] ==startelement)					    //found a valid element
				{                                       
                    if(i==0)
                    {
                        if(direction==BACKWARD)
                            valid_startelement =0xff;                       //invalid element
                        else if(direction==FORWARD)
                            valid_startelement =0;                         //valid element is first element in Array
                    }                                       
                    else    //i!=0
                    {
                        if(shift==TRUE)											//shift is set, this means starting with the next/previous element (depending on the direction-setting)
                            valid_startelement =i+1-2*direction;            //includes shift & direction
                        else //shift==FALSE
                        valid_startelement =i;                              //found element is valid_startelement
                    }
					i=CALLSTACK;        //break loop
				}
			}

			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			    //verify number of valid elements
				if(direction==BACKWARD)											//BACKWARD-start
				{
				    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
					    valid_elements=1;
							
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				    {
					    for(i=valid_startelement;i>=0;i--)
						{
						    if(gmissedcalls_pbname[i][0]!=0)	//if element is valid 
							    valid_elements++;				//increment elements
						    else								//no valid element
							    i=0;
						}
				    }
					else														//enougth array-elements available
					{
					    for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
						    //if(0!=gFavoriteDestList_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
							//else												//no valid element, loop finished
							//	i=0;
						}
					}
				}				//BACKWARD-end
				else			//FORWARD-start
				{
				    if((valid_startelement+elements)>=CALLSTACK)            //to much elements are requested
					{
					    for(i=valid_startelement;i<CALLSTACK;i++)
						{
						    if(gmissedcalls_pbname[i][0]!=0)	//if element is valid 
							    valid_elements++;				//increment elements
						    else								//no valid element
							    i=CALLSTACK;
						}
					}
					else        //enough elements available
					{
					    for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
						    if(gmissedcalls_pbname[i][0]!=0)				    //if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=CALLSTACK;
						}
					}
				}
			}
		}
        putvalue(env_FSG_MissedCalls_AH_elements, valid_elements);

        mode = recordaddress + (mode*0x10);

        //send StatusArray
        MissedCalls_Request(Data_REQ, requested_startelement, valid_startelement, valid_elements, mode, 0);
    }
}

on envVar env_FSG_MissedCalls_ChangedArray
{
    word requested_startelement, startelement, elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress,i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;

    if(gFSG_Telephone_PowerOnOff==_ON && getvalue(this))
	{
        if(getvalue(env_FSG_MissedCalls_AH_start) >255 && getvalue(env_FSG_MissedCalls_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_FSG_MissedCalls_AH_IS,1);

        //get data from Panel
        recordaddress   =getvalue(env_FSG_MissedCalls_AH_RA);
        shift           =getvalue(env_FSG_MissedCalls_AH_shift);
        direction       =getvalue(env_FSG_MissedCalls_AH_dir);
        transmitpos     =getvalue(env_FSG_MissedCalls_AH_POS);
        indexsize       =getvalue(env_FSG_MissedCalls_AH_IS);
        startelement    =getvalue(env_FSG_MissedCalls_AH_start);
        elements        =getvalue(env_FSG_MissedCalls_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +(indexsize*0x08);
        mode = mode*0x10 + recordaddress;

        MissedCalls_Request(Changed_REQ, startelement, startelement, elements, mode, 0);
        /*
            //**********Insert new elements*******************
            if(shift==1 && direction==0 && transmitpos==0 && elements!=0 && startelement<CALLSTACK)
            {
                if((startelement+elements)>CALLSTACK)               //to much elements to insert
                {
                    elements=CALLSTACK-startelement;                //reduce elements to valid value
                    putvalue(env_FSG_MissedCalls_AH_elements,elements);
                }
            
            //get new entries from panel
            getvalue(env_FSG_missedcall_add_name, gmissedcallname_new);
            gmissedcallnumbertype_new=getvalue(env_FSG_missedcall_add_type);
            getvalue(env_FSG_missedcall_add_number, gmissedcallnumber_new);

            callstack_missedcalls(INSERT_ID,startelement,elements);

        }

        //**********Delete elements************************
        if(shift==1 && direction==1 && transmitpos==0 && elements!=0 && startelement<gmissedcalls_TotalNumListElements)
        {
            if(startelement<(elements-1))                       //to much elements to delete
            {
                elements=startelement+1;                        //reduce elements to valid value
                putvalue(env_FSG_MissedCalls_AH_elements,elements);
            }
                                                                //normal operation: delete several elements
            callstack_missedcalls(DELETE_ID,startelement,elements);
        }

        //**********Change elements************************
        if(shift==0 && direction==0 && transmitpos==0 && elements!=0 && startelement<CALLSTACK)
        {
            if((startelement+elements)>CALLSTACK)               //to much elements to insert
            {
                elements=CALLSTACK-startelement;                //reduce elements to valid value
                putvalue(env_FSG_MissedCalls_AH_elements,elements);
            }
            
            //get new entries from panel
            getvalue(env_FSG_missedcall_add_name, gmissedcallname_new);
            gmissedcallnumbertype_new=getvalue(env_FSG_missedcall_add_type);
            getvalue(env_FSG_missedcall_add_number, gmissedcallnumber_new);

            callstack_missedcalls(CHANGE_ID,startelement,elements);
        }

        putvalue(env_FSG_MissedCalls_TotalNumLE,gmissedcalls_TotalNumListElements);
        display_callstack_missedcalls();
*/

    }
}

on envVar env_FSG_MissedCalls_AutoOnOff
{
    if(getvalue(this))
    {
        gmissedcalls_AutoOnOff=_ON;
        EnableControl("FSG-Telephone_MissedCalls(array)", "MissedCalls_StatusArray",0); //disable SatusArray button
    }
    else
    {
        gmissedcalls_AutoOnOff=OFF;
        EnableControl("FSG-Telephone_MissedCalls(array)", "MissedCalls_StatusArray",1); //enable SatusArray button
    }
    putvalue(env_FSG_MissedCalls_AutoOnOff_s,gmissedcalls_AutoOnOff_s[gmissedcalls_AutoOnOff]);
}

on envVar env_FSG_MPSWCOH
{
    byte i, callID, incoming_callholdpossible;


//init lokal variables
	callID=0xff;
	incoming_callholdpossible=0;
//********************

	for(i=0;i<7;i++){
		if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
			incoming_callholdpossible=Terror_heldcallpresent;
	}

    if(incoming_callholdpossible!=Terror_heldcallpresent)
    {
        incoming_callholdpossible=Terror_noincomingwaitingcall;
        for(i=0;i<7;i++){
		    if(gCallState[i]==ringing_waiting)
			    incoming_callholdpossible=1;
        }
    }

	if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && incoming_callholdpossible==1){
		for(i=0;i<7;i++){																//searching for ringing/waiting calls
			if(gCallState[i]==ringing_waiting){
				callID=i;
				// changes from Jan Swoboda (01.03.2012)
				set_CallState_noReq(callID,INCOMING_ON_HOLD);											//set call state
			}
		}
        // changes from Jan Swoboda (01.03.2012)
	if (gCallStateRequestPending)
            CallState_Request(Data_REQ,0);
	}
}

on timer MPSWCOHTimer
{
byte i, callID;

//init lokal variables
	callID=0xff;
//********************


	for(i=0;i<7;i++){																//searching for active calls
		if(gCallState[i]==ringing_waiting){
			callID=i;
			// changes from Jan Swoboda (01.03.2012)
			set_CallState_noReq(callID,INCOMING_ON_HOLD);												//set call state
		}
	}
    // changes from Jan Swoboda (01.03.2012)
    if (gCallStateRequestPending)
        CallState_Request(Data_REQ,0);
	if(callID<7)
    {																	//incoming_hold call is possible
		//IssueList #26
        gMPSWCOH_Result = SUCCESSFUL;

		MPSWCOH_Request(Result_REQ, 0);
		gMPSWCOH_status=0;															//method "MPSWCOH" finished
	}
	else {																			//no incoming call available
		MPSWCOH_Request(Error_REQ, Terror_noincomingwaitingcall);
		gMPSWCOH_status=0;															//method "MPSWCOH" finished
	}
}

MPSWCOH_Request (byte request, byte errorcode)
{
int i, length, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	length=0;
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************

	
	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_MPSetWaitingCallOnHold;			//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      //Dummy
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x27_Processing_flg == 0x00)
            {
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_MPSetWaitingCallOnHold;		//Fct.-ID
			requestarray[2]=request;
            requestarray[3]=gMPSWCOH_Result;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_UInt8);
            }
		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_MPSetWaitingCallOnHold;		//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x27_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone MPSWCOH_Request: unknown request %d", request);
		break;
	}
}

MPSWCOH_Indication (dword Indication_array [], byte indication, int datalength)
{
    byte i, callID, incoming_callholdpossible;


//init lokal variables
	callID=0xff;
	incoming_callholdpossible=0;
//********************

	for(i=0;i<7;i++){
		if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
			incoming_callholdpossible=Terror_heldcallpresent;
	}

    if(incoming_callholdpossible!=Terror_heldcallpresent)
    {
        incoming_callholdpossible=Terror_noincomingwaitingcall;
        for(i=0;i<7;i++){
		    if(gCallState[i]==ringing_waiting)
			    incoming_callholdpossible=1;
	    }
    }

//IssueList #26
if (getValue(env_FSG_MPSWCOH_Result)==0x00)	
	incoming_callholdpossible=1;
else
   incoming_callholdpossible=0;


	switch (indication){
		case Processing_CNF:
			//IssueList #57  and #74
           if (((getValue(env_FSG_Tel_MPSWCOH_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_MPSWCOH_ErrorCode) > 0x3F)) && (gTelFctList_0x27_TimeOut_flg == 0x00))
			{
            MPSWCOH_Request(Processing_REQ, 0);												//send Processing
		        
                //IssueList #68
                if (gTelFctList_0x27_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x27_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x27_ProcessingTimer,TELMAXPROCESSINGTIME);

                MPSWCOH_Request(Processing_REQ, 0);
                }
            }
        break;
		case StartResult_IND:
            //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x27_TimeOut)!=TRUE)
            {
            gTelFctList_0x27_TimeOut_flg = 0x00;
    			//IssueList #57
                if (getValue(env_FSG_Tel_MPSWCOH_Error_On)==0x00)
                putValue(env_FSG_Tel_MPSWCOH_ErrorCode,0);
                
                //IssueList #47
                if (getValue(env_FSG_Tel_MPSWCOH_Error_On))
                    MPSWCOH_Request(Error_REQ, getValue(env_FSG_Tel_MPSWCOH_ErrorCode)); // send error-message
            
                else if(gMPSWCOH_status!=0)
    				MPSWCOH_Request(Error_REQ, Terror_unknownapllicationerror);
    			else if(datalength!=3)																//datalength error
    				MPSWCOH_Request(Error_REQ, Terror_unknownapllicationerror);					//send error-message to RNS
    			else if(gCallActivity==NOCALL)														//incoming_CallHold is impossible, no call
    				MPSWCOH_Request(Error_REQ, Terror_nocall);										//send error-message to RNS
    			else if(incoming_callholdpossible!=1)														//incommin_CallHold is impossible
    	    		//IssueList #26
                    {
                    gMPSWCOH_Result=getValue(env_FSG_MPSWCOH_Result);							                         //send error-message to RNS
                    MPSWCOH_Request(Result_REQ, incoming_callholdpossible);
    	            }		
                    //MPSWCOH_Request(Error_REQ, incoming_callholdpossible);									//send error-message to RNS
    			else
    			{	
    				gMPSWCOH_status=1;																//method "MPSWCOH" active
    				settimer(MPSWCOHTimer, MPSWCOHTimerTime);	
    			}
            }
            else
            gTelFctList_0x27_TimeOut_flg = 0x01;
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone MPSWCOH_Indication: unknown indication %d", indication);
		break;
		}
}

Phonebook_init_static()
{

word phonebookline;

phonebookline   =0;	
    
    //clear
    delete_phonebook();
            
    //entry 0
	gPhonebook_Pos[phonebookline] =3;
    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_PbName [phonebookline], "Use_CSVs_For_Detail!",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    //changes from Jöran Karl (28.03.2012)
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 1
	gPhonebook_Pos[phonebookline] =6;
    strncpy(gPhonebook_PbName [phonebookline], "Book1",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 2
	gPhonebook_Pos[phonebookline] =9;
    strncpy(gPhonebook_PbName [phonebookline], "book2",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    //changes from Jöran Karl (28.03.2012)
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;
    
    //entry 3
	gPhonebook_Pos[phonebookline] =12;
    strncpy(gPhonebook_PbName [phonebookline], "Book3",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;

    phonebookline++;
    
    //entry 4
	gPhonebook_Pos[phonebookline] =15;
    strncpy(gPhonebook_PbName [phonebookline], "Book4",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 5
	gPhonebook_Pos[phonebookline] =18;
    strncpy(gPhonebook_PbName [phonebookline], "Book5",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    //changes from Jöran Karl (28.03.2012)
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 6
	gPhonebook_Pos[phonebookline] =21;
    strncpy(gPhonebook_PbName [phonebookline], "Book6",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 7
	gPhonebook_Pos[phonebookline] =24;
    strncpy(gPhonebook_PbName [phonebookline], "Book7",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 8
	gPhonebook_Pos[phonebookline] =27;
    strncpy(gPhonebook_PbName [phonebookline], "Book8",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 9
	gPhonebook_Pos[phonebookline] =30;
    strncpy(gPhonebook_PbName [phonebookline], "Book9",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    //changes from Jöran Karl (28.03.2012)
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 10
	gPhonebook_Pos[phonebookline] =33;
    strncpy(gPhonebook_PbName [phonebookline], "Book10",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

	//changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 11
	gPhonebook_Pos[phonebookline] =36;
    strncpy(gPhonebook_PbName [phonebookline], "Book11",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 12
	gPhonebook_Pos[phonebookline] =39;
    strncpy(gPhonebook_PbName [phonebookline], "Book12",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 13
	gPhonebook_Pos[phonebookline] =42;
    strncpy(gPhonebook_PbName [phonebookline], "Book13",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    //changes from Jöran Karl (28.03.2012)
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 14
	gPhonebook_Pos[phonebookline] =45;
    strncpy(gPhonebook_PbName [phonebookline], "Book14",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 15
	gPhonebook_Pos[phonebookline] =48;
    strncpy(gPhonebook_PbName [phonebookline], "Book15",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 16
	gPhonebook_Pos[phonebookline] =51;
    strncpy(gPhonebook_PbName [phonebookline], "Book16",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 17
	gPhonebook_Pos[phonebookline] =54;
    strncpy(gPhonebook_PbName [phonebookline], "Book17",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 18
	gPhonebook_Pos[phonebookline] =57;
    strncpy(gPhonebook_PbName [phonebookline], "Book18",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    //changes from Jöran Karl (28.03.2012)
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 19
	gPhonebook_Pos[phonebookline] =60;
    strncpy(gPhonebook_PbName [phonebookline], "Book19",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 20
	gPhonebook_Pos[phonebookline] =63;
    strncpy(gPhonebook_PbName [phonebookline], "Book20",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 21
	gPhonebook_Pos[phonebookline] =66;
    strncpy(gPhonebook_PbName [phonebookline], "Book21",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 22
	gPhonebook_Pos[phonebookline] =69;
    strncpy(gPhonebook_PbName [phonebookline], "Book22",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 23
	gPhonebook_Pos[phonebookline] =72;
    strncpy(gPhonebook_PbName [phonebookline], "Book23",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;

    phonebookline++;

    //entry 24
	gPhonebook_Pos[phonebookline] =75;
    strncpy(gPhonebook_PbName [phonebookline], "Book24",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 25
	gPhonebook_Pos[phonebookline] =78;
    strncpy(gPhonebook_PbName [phonebookline], "Book25",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 26
	gPhonebook_Pos[phonebookline] =81;
    strncpy(gPhonebook_PbName [phonebookline], "Book26",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 27
	gPhonebook_Pos[phonebookline] =84;
    strncpy(gPhonebook_PbName [phonebookline], "Book27",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

   //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 28
	gPhonebook_Pos[phonebookline] =87;
    strncpy(gPhonebook_PbName [phonebookline], "Book28",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

   //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 29
	gPhonebook_Pos[phonebookline] =90;
    strncpy(gPhonebook_PbName [phonebookline], "Book29",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 30
	gPhonebook_Pos[phonebookline] =93;
    strncpy(gPhonebook_PbName [phonebookline], "Book30",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 31
	gPhonebook_Pos[phonebookline] =96;
    strncpy(gPhonebook_PbName [phonebookline], "Book31",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 32
	gPhonebook_Pos[phonebookline] =99;
    strncpy(gPhonebook_PbName [phonebookline], "Book32",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 33
	gPhonebook_Pos[phonebookline] =102;
    strncpy(gPhonebook_PbName [phonebookline], "Book33",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 34
	gPhonebook_Pos[phonebookline] =105;
    strncpy(gPhonebook_PbName [phonebookline], "Book34",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 35
	gPhonebook_Pos[phonebookline] =108;
    strncpy(gPhonebook_PbName [phonebookline], "Book35",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 36
	gPhonebook_Pos[phonebookline] =111;
    strncpy(gPhonebook_PbName [phonebookline], "Book36",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 37
	gPhonebook_Pos[phonebookline] =114;
    strncpy(gPhonebook_PbName [phonebookline], "Book37",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 38
	gPhonebook_Pos[phonebookline] =117;
    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_PbName [phonebookline], "Book38",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;

    //entry 39
	gPhonebook_Pos[phonebookline] =120;
    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_PbName [phonebookline], "Book39",PHONEBOOK_PBNAME_LENGTH);
    gPhonebook_Storage[phonebookline]           =0;
    gPhonebook_AnyVoiceTag[phonebookline]       =1;
    gPhonebook_TelNumberQuantity[phonebookline] =1;

    //changes from Jöran Karl (28.03.2012)
    strncpy(gPhonebook_TelNumbers[0] [phonebookline], "012345",PHONEBOOK_TELNUMBER_LENGTH);
    gPhonebook_VoiceTags[0][phonebookline]= TRUE;
    gPhonebook_NumberTypes[0] [phonebookline]= MOBILE;

    gPhonebook_AddressIndication[phonebookline]=0;
    
    phonebookline++;
    
    gPhonebook_TotalNumListElements=phonebookline;
    putvalue(env_FSG_Phonebook_TotalNumLE, gPhonebook_TotalNumListElements);
    
    display_phonebook();

    //Phonebook_Request(Changed_REQ, 0, 0, 0xFFFF, 0, 0);



    
}

display_phonebook ()
{
int i;
char numbertype1[20][15];

    //Pos
	putvalue(env_FSG_Phonebook0_Pos, gPhonebook_Pos [0]);
	putvalue(env_FSG_Phonebook1_Pos, gPhonebook_Pos [1]);
	putvalue(env_FSG_Phonebook2_Pos, gPhonebook_Pos [2]);
	putvalue(env_FSG_Phonebook3_Pos, gPhonebook_Pos [3]);
	putvalue(env_FSG_Phonebook4_Pos, gPhonebook_Pos [4]);
	putvalue(env_FSG_Phonebook5_Pos, gPhonebook_Pos [5]);
	putvalue(env_FSG_Phonebook6_Pos, gPhonebook_Pos [6]);
	putvalue(env_FSG_Phonebook7_Pos, gPhonebook_Pos [7]);
	putvalue(env_FSG_Phonebook8_Pos, gPhonebook_Pos [8]);
	putvalue(env_FSG_Phonebook9_Pos, gPhonebook_Pos [9]);
	putvalue(env_FSG_Phonebook10_Pos, gPhonebook_Pos [10]);
	putvalue(env_FSG_Phonebook11_Pos, gPhonebook_Pos [11]);
	putvalue(env_FSG_Phonebook12_Pos, gPhonebook_Pos [12]);
	putvalue(env_FSG_Phonebook13_Pos, gPhonebook_Pos [13]);
	putvalue(env_FSG_Phonebook14_Pos, gPhonebook_Pos [14]);
	putvalue(env_FSG_Phonebook15_Pos, gPhonebook_Pos [15]);
	putvalue(env_FSG_Phonebook16_Pos, gPhonebook_Pos [16]);
	putvalue(env_FSG_Phonebook17_Pos, gPhonebook_Pos [17]);
	putvalue(env_FSG_Phonebook18_Pos, gPhonebook_Pos [18]);
	putvalue(env_FSG_Phonebook19_Pos, gPhonebook_Pos [19]);

	//PbName
	putvalue(env_FSG_Phonebook0_PbName, gPhonebook_PbName [0]);
	putvalue(env_FSG_Phonebook1_PbName, gPhonebook_PbName [1]);
	putvalue(env_FSG_Phonebook2_PbName, gPhonebook_PbName [2]);
	putvalue(env_FSG_Phonebook3_PbName, gPhonebook_PbName [3]);
	putvalue(env_FSG_Phonebook4_PbName, gPhonebook_PbName [4]);
	putvalue(env_FSG_Phonebook5_PbName, gPhonebook_PbName [5]);
	putvalue(env_FSG_Phonebook6_PbName, gPhonebook_PbName [6]);
	putvalue(env_FSG_Phonebook7_PbName, gPhonebook_PbName [7]);
	putvalue(env_FSG_Phonebook8_PbName, gPhonebook_PbName [8]);
	putvalue(env_FSG_Phonebook9_PbName, gPhonebook_PbName [9]);
	putvalue(env_FSG_Phonebook10_PbName, gPhonebook_PbName [10]);
	putvalue(env_FSG_Phonebook11_PbName, gPhonebook_PbName [11]);
	putvalue(env_FSG_Phonebook12_PbName, gPhonebook_PbName [12]);
	putvalue(env_FSG_Phonebook13_PbName, gPhonebook_PbName [13]);
	putvalue(env_FSG_Phonebook14_PbName, gPhonebook_PbName [14]);
	putvalue(env_FSG_Phonebook15_PbName, gPhonebook_PbName [15]);
	putvalue(env_FSG_Phonebook16_PbName, gPhonebook_PbName [16]);
	putvalue(env_FSG_Phonebook17_PbName, gPhonebook_PbName [17]);
	putvalue(env_FSG_Phonebook18_PbName, gPhonebook_PbName [18]);
	putvalue(env_FSG_Phonebook19_PbName, gPhonebook_PbName [19]);

    //Storage
    putvalue(env_FSG_Phonebook0_Storage, gPhonebook_Storage [0]);
	putvalue(env_FSG_Phonebook1_Storage, gPhonebook_Storage [1]);
	putvalue(env_FSG_Phonebook2_Storage, gPhonebook_Storage [2]);
	putvalue(env_FSG_Phonebook3_Storage, gPhonebook_Storage [3]);
	putvalue(env_FSG_Phonebook4_Storage, gPhonebook_Storage [4]);
	putvalue(env_FSG_Phonebook5_Storage, gPhonebook_Storage [5]);
	putvalue(env_FSG_Phonebook6_Storage, gPhonebook_Storage [6]);
	putvalue(env_FSG_Phonebook7_Storage, gPhonebook_Storage [7]);
	putvalue(env_FSG_Phonebook8_Storage, gPhonebook_Storage [8]);
	putvalue(env_FSG_Phonebook9_Storage, gPhonebook_Storage [9]);
	putvalue(env_FSG_Phonebook10_Storage, gPhonebook_Storage [10]);
	putvalue(env_FSG_Phonebook11_Storage, gPhonebook_Storage [11]);
	putvalue(env_FSG_Phonebook12_Storage, gPhonebook_Storage [12]);
	putvalue(env_FSG_Phonebook13_Storage, gPhonebook_Storage [13]);
	putvalue(env_FSG_Phonebook14_Storage, gPhonebook_Storage [14]);
	putvalue(env_FSG_Phonebook15_Storage, gPhonebook_Storage [15]);
	putvalue(env_FSG_Phonebook16_Storage, gPhonebook_Storage [16]);
	putvalue(env_FSG_Phonebook17_Storage, gPhonebook_Storage [17]);
	putvalue(env_FSG_Phonebook18_Storage, gPhonebook_Storage [18]);
	putvalue(env_FSG_Phonebook19_Storage, gPhonebook_Storage [19]);

    //AnyVoiceTag
    putvalue(env_FSG_Phonebook0_AnyVoiceTag, gPhonebook_AnyVoiceTag [0]);
	putvalue(env_FSG_Phonebook1_AnyVoiceTag, gPhonebook_AnyVoiceTag [1]);
	putvalue(env_FSG_Phonebook2_AnyVoiceTag, gPhonebook_AnyVoiceTag [2]);
	putvalue(env_FSG_Phonebook3_AnyVoiceTag, gPhonebook_AnyVoiceTag [3]);
	putvalue(env_FSG_Phonebook4_AnyVoiceTag, gPhonebook_AnyVoiceTag [4]);
	putvalue(env_FSG_Phonebook5_AnyVoiceTag, gPhonebook_AnyVoiceTag [5]);
	putvalue(env_FSG_Phonebook6_AnyVoiceTag, gPhonebook_AnyVoiceTag [6]);
	putvalue(env_FSG_Phonebook7_AnyVoiceTag, gPhonebook_AnyVoiceTag [7]);
	putvalue(env_FSG_Phonebook8_AnyVoiceTag, gPhonebook_AnyVoiceTag [8]);
	putvalue(env_FSG_Phonebook9_AnyVoiceTag, gPhonebook_AnyVoiceTag [9]);
	putvalue(env_FSG_Phonebook10_AnyVoiceTag, gPhonebook_AnyVoiceTag [10]);
	putvalue(env_FSG_Phonebook11_AnyVoiceTag, gPhonebook_AnyVoiceTag [11]);
	putvalue(env_FSG_Phonebook12_AnyVoiceTag, gPhonebook_AnyVoiceTag [12]);
	putvalue(env_FSG_Phonebook13_AnyVoiceTag, gPhonebook_AnyVoiceTag [13]);
	putvalue(env_FSG_Phonebook14_AnyVoiceTag, gPhonebook_AnyVoiceTag [14]);
	putvalue(env_FSG_Phonebook15_AnyVoiceTag, gPhonebook_AnyVoiceTag [15]);
	putvalue(env_FSG_Phonebook16_AnyVoiceTag, gPhonebook_AnyVoiceTag [16]);
	putvalue(env_FSG_Phonebook17_AnyVoiceTag, gPhonebook_AnyVoiceTag [17]);
	putvalue(env_FSG_Phonebook18_AnyVoiceTag, gPhonebook_AnyVoiceTag [18]);
	putvalue(env_FSG_Phonebook19_AnyVoiceTag, gPhonebook_AnyVoiceTag [19]);

    //TelNumberQuantity
    putvalue(env_FSG_Phonebook0_TelNumberQuantity, gPhonebook_TelNumberQuantity [0]);
	putvalue(env_FSG_Phonebook1_TelNumberQuantity, gPhonebook_TelNumberQuantity [1]);
	putvalue(env_FSG_Phonebook2_TelNumberQuantity, gPhonebook_TelNumberQuantity [2]);
	putvalue(env_FSG_Phonebook3_TelNumberQuantity, gPhonebook_TelNumberQuantity [3]);
	putvalue(env_FSG_Phonebook4_TelNumberQuantity, gPhonebook_TelNumberQuantity [4]);
	putvalue(env_FSG_Phonebook5_TelNumberQuantity, gPhonebook_TelNumberQuantity [5]);
	putvalue(env_FSG_Phonebook6_TelNumberQuantity, gPhonebook_TelNumberQuantity [6]);
	putvalue(env_FSG_Phonebook7_TelNumberQuantity, gPhonebook_TelNumberQuantity [7]);
	putvalue(env_FSG_Phonebook8_TelNumberQuantity, gPhonebook_TelNumberQuantity [8]);
	putvalue(env_FSG_Phonebook9_TelNumberQuantity, gPhonebook_TelNumberQuantity [9]);
	putvalue(env_FSG_Phonebook10_TelNumberQuantity, gPhonebook_TelNumberQuantity [10]);
	putvalue(env_FSG_Phonebook11_TelNumberQuantity, gPhonebook_TelNumberQuantity [11]);
	putvalue(env_FSG_Phonebook12_TelNumberQuantity, gPhonebook_TelNumberQuantity [12]);
	putvalue(env_FSG_Phonebook13_TelNumberQuantity, gPhonebook_TelNumberQuantity [13]);
	putvalue(env_FSG_Phonebook14_TelNumberQuantity, gPhonebook_TelNumberQuantity [14]);
	putvalue(env_FSG_Phonebook15_TelNumberQuantity, gPhonebook_TelNumberQuantity [15]);
	putvalue(env_FSG_Phonebook16_TelNumberQuantity, gPhonebook_TelNumberQuantity [16]);
	putvalue(env_FSG_Phonebook17_TelNumberQuantity, gPhonebook_TelNumberQuantity [17]);
	putvalue(env_FSG_Phonebook18_TelNumberQuantity, gPhonebook_TelNumberQuantity [18]);
	putvalue(env_FSG_Phonebook19_TelNumberQuantity, gPhonebook_TelNumberQuantity [19]);

	//TelNumber1
	//changes from Jöran Karl (28.03.2012)
	putvalue(env_FSG_Phonebook0_TelNumber1, gPhonebook_TelNumbers[0] [0]);
	putvalue(env_FSG_Phonebook1_TelNumber1, gPhonebook_TelNumbers[0] [1]);
	putvalue(env_FSG_Phonebook2_TelNumber1, gPhonebook_TelNumbers[0] [2]);
	putvalue(env_FSG_Phonebook3_TelNumber1, gPhonebook_TelNumbers[0] [3]);
	putvalue(env_FSG_Phonebook4_TelNumber1, gPhonebook_TelNumbers[0] [4]);
	putvalue(env_FSG_Phonebook5_TelNumber1, gPhonebook_TelNumbers[0] [5]);
	putvalue(env_FSG_Phonebook6_TelNumber1, gPhonebook_TelNumbers[0] [6]);
	putvalue(env_FSG_Phonebook7_TelNumber1, gPhonebook_TelNumbers[0] [7]);
	putvalue(env_FSG_Phonebook8_TelNumber1, gPhonebook_TelNumbers[0] [8]);
	putvalue(env_FSG_Phonebook9_TelNumber1, gPhonebook_TelNumbers[0] [9]);
	putvalue(env_FSG_Phonebook10_TelNumber1, gPhonebook_TelNumbers[0] [10]);
	putvalue(env_FSG_Phonebook11_TelNumber1, gPhonebook_TelNumbers[0] [11]);
	putvalue(env_FSG_Phonebook12_TelNumber1, gPhonebook_TelNumbers[0] [12]);
	putvalue(env_FSG_Phonebook13_TelNumber1, gPhonebook_TelNumbers[0] [13]);
	putvalue(env_FSG_Phonebook14_TelNumber1, gPhonebook_TelNumbers[0] [14]);
	putvalue(env_FSG_Phonebook15_TelNumber1, gPhonebook_TelNumbers[0] [15]);
	putvalue(env_FSG_Phonebook16_TelNumber1, gPhonebook_TelNumbers[0] [16]);
	putvalue(env_FSG_Phonebook17_TelNumber1, gPhonebook_TelNumbers[0] [17]);
	putvalue(env_FSG_Phonebook18_TelNumber1, gPhonebook_TelNumbers[0] [18]);
	putvalue(env_FSG_Phonebook19_TelNumber1, gPhonebook_TelNumbers[0] [19]);

    //VoiceTag1
    //changes from Jöran Karl (28.03.2012)
    putvalue(env_FSG_Phonebook0_VoiceTag1, gPhonebook_VoiceTags[0] [0]);
	putvalue(env_FSG_Phonebook1_VoiceTag1, gPhonebook_VoiceTags[0] [1]);
	putvalue(env_FSG_Phonebook2_VoiceTag1, gPhonebook_VoiceTags[0] [2]);
	putvalue(env_FSG_Phonebook3_VoiceTag1, gPhonebook_VoiceTags[0] [3]);
	putvalue(env_FSG_Phonebook4_VoiceTag1, gPhonebook_VoiceTags[0] [4]);
	putvalue(env_FSG_Phonebook5_VoiceTag1, gPhonebook_VoiceTags[0] [5]);
	putvalue(env_FSG_Phonebook6_VoiceTag1, gPhonebook_VoiceTags[0] [6]);
	putvalue(env_FSG_Phonebook7_VoiceTag1, gPhonebook_VoiceTags[0] [7]);
	putvalue(env_FSG_Phonebook8_VoiceTag1, gPhonebook_VoiceTags[0] [8]);
	putvalue(env_FSG_Phonebook9_VoiceTag1, gPhonebook_VoiceTags[0] [9]);
	putvalue(env_FSG_Phonebook10_VoiceTag1, gPhonebook_VoiceTags[0] [10]);
	putvalue(env_FSG_Phonebook11_VoiceTag1, gPhonebook_VoiceTags[0] [11]);
	putvalue(env_FSG_Phonebook12_VoiceTag1, gPhonebook_VoiceTags[0] [12]);
	putvalue(env_FSG_Phonebook13_VoiceTag1, gPhonebook_VoiceTags[0] [13]);
	putvalue(env_FSG_Phonebook14_VoiceTag1, gPhonebook_VoiceTags[0] [14]);
	putvalue(env_FSG_Phonebook15_VoiceTag1, gPhonebook_VoiceTags[0] [15]);
	putvalue(env_FSG_Phonebook16_VoiceTag1, gPhonebook_VoiceTags[0] [16]);
	putvalue(env_FSG_Phonebook17_VoiceTag1, gPhonebook_VoiceTags[0] [17]);
	putvalue(env_FSG_Phonebook18_VoiceTag1, gPhonebook_VoiceTags[0] [18]);
	putvalue(env_FSG_Phonebook19_VoiceTag1, gPhonebook_VoiceTags[0] [19]);

	//NumberType1
	for(i=0;i<20;i++){
		//changes from Jöran Karl (28.03.2012)
		if(gPhonebook_NumberTypes[0][i]<0x0F)
			strncpy(numbertype1[i], gnumbertype[gmissedcalls_numbertype[i]],15);
        else
            strncpy(numbertype1[i],gnumbertype[0],15);   //unknown
	}
	putvalue(env_FSG_Phonebook0_NumberType1, numbertype1 [0]);
	putvalue(env_FSG_Phonebook1_NumberType1, numbertype1 [1]);
	putvalue(env_FSG_Phonebook2_NumberType1, numbertype1 [2]);
	putvalue(env_FSG_Phonebook3_NumberType1, numbertype1 [3]);
	putvalue(env_FSG_Phonebook4_NumberType1, numbertype1 [4]);
	putvalue(env_FSG_Phonebook5_NumberType1, numbertype1 [5]);
	putvalue(env_FSG_Phonebook6_NumberType1, numbertype1 [6]);
	putvalue(env_FSG_Phonebook7_NumberType1, numbertype1 [7]);
	putvalue(env_FSG_Phonebook8_NumberType1, numbertype1 [8]);
	putvalue(env_FSG_Phonebook9_NumberType1, numbertype1 [9]);
	putvalue(env_FSG_Phonebook10_NumberType1, numbertype1 [10]);
	putvalue(env_FSG_Phonebook11_NumberType1, numbertype1 [11]);
	putvalue(env_FSG_Phonebook12_NumberType1, numbertype1 [12]);
	putvalue(env_FSG_Phonebook13_NumberType1, numbertype1 [13]);
	putvalue(env_FSG_Phonebook14_NumberType1, numbertype1 [14]);
	putvalue(env_FSG_Phonebook15_NumberType1, numbertype1 [15]);
	putvalue(env_FSG_Phonebook16_NumberType1, numbertype1 [16]);
	putvalue(env_FSG_Phonebook17_NumberType1, numbertype1 [17]);
	putvalue(env_FSG_Phonebook18_NumberType1, numbertype1 [18]);
	putvalue(env_FSG_Phonebook19_NumberType1, numbertype1 [19]);

    //AddressInd
    putvalue(env_FSG_Phonebook0_AddressInd, gPhonebook_AddressIndication [0]);
	putvalue(env_FSG_Phonebook1_AddressInd, gPhonebook_AddressIndication [1]);
	putvalue(env_FSG_Phonebook2_AddressInd, gPhonebook_AddressIndication [2]);
	putvalue(env_FSG_Phonebook3_AddressInd, gPhonebook_AddressIndication [3]);
	putvalue(env_FSG_Phonebook4_AddressInd, gPhonebook_AddressIndication [4]);
	putvalue(env_FSG_Phonebook5_AddressInd, gPhonebook_AddressIndication [5]);
	putvalue(env_FSG_Phonebook6_AddressInd, gPhonebook_AddressIndication [6]);
	putvalue(env_FSG_Phonebook7_AddressInd, gPhonebook_AddressIndication [7]);
	putvalue(env_FSG_Phonebook8_AddressInd, gPhonebook_AddressIndication [8]);
	putvalue(env_FSG_Phonebook9_AddressInd, gPhonebook_AddressIndication [9]);
	putvalue(env_FSG_Phonebook10_AddressInd, gPhonebook_AddressIndication [10]);
	putvalue(env_FSG_Phonebook11_AddressInd, gPhonebook_AddressIndication [11]);
	putvalue(env_FSG_Phonebook12_AddressInd, gPhonebook_AddressIndication [12]);
	putvalue(env_FSG_Phonebook13_AddressInd, gPhonebook_AddressIndication [13]);
	putvalue(env_FSG_Phonebook14_AddressInd, gPhonebook_AddressIndication [14]);
	putvalue(env_FSG_Phonebook15_AddressInd, gPhonebook_AddressIndication [15]);
	putvalue(env_FSG_Phonebook16_AddressInd, gPhonebook_AddressIndication [16]);
	putvalue(env_FSG_Phonebook17_AddressInd, gPhonebook_AddressIndication [17]);
	putvalue(env_FSG_Phonebook18_AddressInd, gPhonebook_AddressIndication [18]);
	putvalue(env_FSG_Phonebook19_AddressInd, gPhonebook_AddressIndication [19]);

}

on envVar env_FSG_Phonebook_AutoOnOff
{
    if(getvalue(this))
    {
        gPhonebook_AutoOnOff=_ON;
        EnableControl("FSG-Telephone_Phonebook(array)", "Phonebook_StatusArray",0); //disable SatusArray button
    }
    else
    {
        gPhonebook_AutoOnOff=OFF;
        EnableControl("FSG-Telephone_Phonebook(array)", "Phonebook_StatusArray",1); //enable SatusArray button
    }
    putvalue(env_FSG_Phonebook_AutoOnOff_s,gPhonebook_AutoOnOff_s[gPhonebook_AutoOnOff]);
}

on envVar env_FSG_Phonebook_reload //load external Phonebook from *.csv
{
word i;

    if(getvalue(this) && getvalue(env_FSG_Phonebook_DataSource) ==TEL_EXTERNAL_LIST)
    {
	   //IssueList #76 - MR49870 : Phonebook
       if (getValue(env_FSG_PB_insert_UPD_button)==0x00)
         {
             for(i =0; i<PHONEBOOK_ENTRIES; i++)
             {
              gPhonebook_Pos_insDel[i] [0] =0x00;   //POS value
              gPhonebook_Pos_insDel[i] [1] =0x00;   //tagging of deleted elements
             }
        }

        //MissedCalls_init_CSV();
        //IssueList #24
	    Phonebook_init_CSV();
   
    
     //IssueList #76 - MR49870 : Phonebook
        if (getValue(env_FSG_PB_insert_UPD_button)==0x00)
        {
          //MR 63332 #3   02.07.2014
          //gPhonebook_TotalNumListElements = getValue(env_FSG_Phonebook_TotalNumLE);
          
           gPB_CSVtotalElem = gPhonebook_TotalNumListElements;

          //Clear insert/delete panel
           putValue(env_FSG_PB_delete_start, 0);
           putValue(env_FSG_PB_insert_start, 0);
           putValue(env_FSG_PB_insert_start, 0);
           putValue(env_FSG_PB_insert_successor, 0);
           putValue(env_FSG_Phonebook_delete_ErrHandler, 1);
           putValue(env_FSG_PB_delete_Message, empty_string);

           putValue(env_FSG_Phonebook_insert_Err, 1);
           putValue(env_FSG_PB_Insert_Message, empty_string);
        }
            
        //Clearing send buffer       
        for(i =0; i<PHONEBOOK_ENTRIES; i++)
        {
           gPhonebook_Send[i][0] =0;   //POS value
        }
            
        display_phonebook();


    }
    else if(getvalue(env_FSG_Phonebook_DataSource) != TEL_EXTERNAL_LIST)
        putvalue(env_FSG_Phonebook_DS_result,"not successful, select 'external *.csv'");
}

on envVar env_FSG_Phonebook_DataSource
{
    if (getvalue(this) ==TEL_DEFAULT_LIST)
    {
        Phonebook_init_static();
        putvalue(env_FSG_Phonebook_DS_file, gempty_string);
        putvalue(env_FSG_Phonebook_DS_result, gempty_string);
    }
}

on envVar env_FSG_Phonebook_StatusArray
{
    //MR 63667 11.07.2014 -TNLE with SA-button
    //word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    word tnle, requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    //changes for IssueList #152 - MR 53938
    //PHONEBOOK_ENTRIES --> gPhonebook_TotalNumListElements
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        if(getvalue(env_FSG_Phonebook_AH_start) >255 && getvalue(env_FSG_Phonebook_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_FSG_Phonebook_AH_IS,1);

        //get data from Panel
        gPhonebook_ASG_ID                 =getvalue(env_FSG_Phonebook_ASG_ID);
        gPhonebook_TAID                  =getvalue(env_FSG_Phonebook_TAID);
        
        //MR 63332 #3   02.07.2014
        //gPhonebook_TotalNumListElements  =getvalue(env_FSG_Phonebook_TotalNumLE);

        tnle = getvalue(env_FSG_Phonebook_TotalNumLE);

        recordaddress   =getvalue(env_FSG_Phonebook_AH_RA);
        shift           =getvalue(env_FSG_Phonebook_AH_shift);
        direction       =getvalue(env_FSG_Phonebook_AH_dir);
        transmitpos     =getvalue(env_FSG_Phonebook_AH_POS);
        indexsize       =getvalue(env_FSG_Phonebook_AH_IS);
        startelement    =getvalue(env_FSG_Phonebook_AH_start);
        elements        =getvalue(env_FSG_Phonebook_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(startelement==0) //Startelement-ID =0 -> start at first array-entry
		{
            if(direction==FORWARD)  //FORWARD-start
			{
                valid_startelement =startelement;				       									

                if(elements>gPhonebook_TotalNumListElements) //1. more elements requested, than in array
				{
                    for(i=valid_startelement;i<gPhonebook_TotalNumListElements;i++)
					{
						if(gPhonebook_PbName[i][0]!=0)	//if element is valid 
							valid_elements++;				//increment elements
						else								//no valid element
							i =gPhonebook_TotalNumListElements;                   //break loop 
					}
			    }
                else    //2. number of requested elements <= elements in array
				{
                    for(i=valid_startelement;i<(elements+valid_startelement);i++)
					{
						if(gPhonebook_PbName[i][0]!=0)	//if element is valid 
							valid_elements++;				//increment elements
						else								//no valid element
							i =gPhonebook_TotalNumListElements;                   //break loop 
					}

				}
            }                                                               //FORWARD ends
            
            else if(direction==BACKWARD && shift==TRUE)						//BACKWARD-start, only if the shift bit is set
			{   
			    //searching for valid startelement
				for(i=(gPhonebook_TotalNumListElements-1);i>=0;i--)
				{
				    if(gPhonebook_PbName[i][0]!=0)		//found valid startelement
					{
					    valid_startelement =i;								
						i =0;					//break loop							
					}
				}
                        
                //searching for valid elements
				if(0xffff==valid_startelement)								//Startelement-ID doesn't exist in array
				{
				    valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				    for(i=valid_startelement;i>=0;i--)
					{
					    if(gPhonebook_PbName[i][0]!=0)	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						    i=0;
				    }
				}
                else			//enougth array elements available
				{
				    for(i=valid_startelement;i>=((valid_startelement+1)-elements);i--)
					{
					    if(gPhonebook_PbName[i][0]!=0)	//if element is valid 
							valid_elements++;				//increment elements
						else								//no valid element
							i=0;
					}                   
				}															
	        }                                                               //BACKWARD-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else																//searching for Startelement-ID				
		{
		    //searching for valid startelement
			for(i=0;i<gPhonebook_TotalNumListElements;i++)
			{
				if(gPhonebook_Pos[i] ==startelement)					    //found a valid element
				{                                       
                    if(i==0)
                    {
                        if(direction==BACKWARD)
                            valid_startelement =0xffff;                       //invalid element
                        else if(direction==FORWARD)
                            valid_startelement =0;                         //valid element is first element in Array
                    }                                       
                    else    //i!=0
                    {
                        if(shift==TRUE)											//shift is set, this means starting with the next/previous element (depending on the direction-setting)
                            valid_startelement =i+1-2*direction;            //includes shift & direction
                        else //shift==FALSE
                        valid_startelement =i;                              //found element is valid_startelement
                    }
					i=gPhonebook_TotalNumListElements;        //break loop
				}
			}

			if(0xffff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			    //verify number of valid elements
				if(direction==BACKWARD)											//BACKWARD-start
				{
				    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
					    valid_elements=1;
							
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				    {
					    for(i=valid_startelement;i>=0;i--)
						{
						    if(gPhonebook_PbName[i][0]!=0)	//if element is valid 
							    valid_elements++;				//increment elements
						    else								//no valid element
							    i=0;
						}
				    }
					else														//enougth array-elements available
					{
					    for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
						    //if(0!=gFavoriteDestList_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
							//else												//no valid element, loop finished
							//	i=0;
						}
					}
				}				//BACKWARD-end
				else			//FORWARD-start
				{
				    if((valid_startelement+elements)>=gPhonebook_TotalNumListElements)            //to much elements are requested
					{
					    for(i=valid_startelement;i<gPhonebook_TotalNumListElements;i++)
						{
						    if(gPhonebook_PbName[i][0]!=0)	//if element is valid 
							    valid_elements++;				//increment elements
						    else								//no valid element
							    i=gPhonebook_TotalNumListElements;
						}
					}
					else        //enough elements available
					{
					    for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
						    if(gPhonebook_PbName[i][0]!=0)				    //if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=gPhonebook_TotalNumListElements;
						}
					}
				}
			}
		}
        putvalue(env_FSG_Phonebook_AH_elements, valid_elements);

        mode = recordaddress + (mode*0x10);

        //send StatusArray
        //MR 63667 11.07.2014 -TNLE with SA-button
        //Phonebook_Request(Data_REQ, requested_startelement, valid_startelement, valid_elements, mode, 0);
	//VAGH-10511
	if(!getvalue(env_FSG_Phonebook_StatusArrayOff))
		Phonebook_Request(Data_REQ, tnle, requested_startelement, valid_startelement, valid_elements, mode, 0);
    }
}

on envVar env_FSG_Phonebook_ChangedArray
{
    word requested_startelement, startelement, elements,i;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;

    if(gFSG_Telephone_PowerOnOff==_ON && getvalue(this))
	{
        if(getvalue(env_FSG_Phonebook_AH_start) >255 && getvalue(env_FSG_Phonebook_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_FSG_Phonebook_AH_IS,1);

        //get data from Panel
        recordaddress   =getvalue(env_FSG_Phonebook_AH_RA);
        shift           =getvalue(env_FSG_Phonebook_AH_shift);
        direction       =getvalue(env_FSG_Phonebook_AH_dir);
        transmitpos     =getvalue(env_FSG_Phonebook_AH_POS);
        indexsize       =getvalue(env_FSG_Phonebook_AH_IS);
        startelement    =getvalue(env_FSG_Phonebook_AH_start);
        elements        =getvalue(env_FSG_Phonebook_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +(indexsize*0x08);
        mode = mode*0x10 + recordaddress;

        //MR 63667 11.07.2014 -TNLE with SA-button
        //Phonebook_Request(Changed_REQ, startelement, startelement, elements, mode, 0);
        Phonebook_Request(Changed_REQ, 0, startelement, startelement, elements, mode, 0);
        /*
            //**********Insert new elements*******************
            if(shift==1 && direction==0 && transmitpos==0 && elements!=0 && startelement<CALLSTACK)
            {
                if((startelement+elements)>CALLSTACK)               //to much elements to insert
                {
                    elements=CALLSTACK-startelement;                //reduce elements to valid value
                    putvalue(env_FSG_MissedCalls_AH_elements,elements);
                }
            
            //get new entries from panel
            getvalue(env_FSG_missedcall_add_name, gmissedcallname_new);
            gmissedcallnumbertype_new=getvalue(env_FSG_missedcall_add_type);
            getvalue(env_FSG_missedcall_add_number, gmissedcallnumber_new);

            callstack_missedcalls(INSERT_ID,startelement,elements);

        }

        //**********Delete elements************************
        if(shift==1 && direction==1 && transmitpos==0 && elements!=0 && startelement<gmissedcalls_TotalNumListElements)
        {
            if(startelement<(elements-1))                       //to much elements to delete
            {
                elements=startelement+1;                        //reduce elements to valid value
                putvalue(env_FSG_MissedCalls_AH_elements,elements);
            }
                                                                //normal operation: delete several elements
            callstack_missedcalls(DELETE_ID,startelement,elements);
        }

        //**********Change elements************************
        if(shift==0 && direction==0 && transmitpos==0 && elements!=0 && startelement<CALLSTACK)
        {
            if((startelement+elements)>CALLSTACK)               //to much elements to insert
            {
                elements=CALLSTACK-startelement;                //reduce elements to valid value
                putvalue(env_FSG_MissedCalls_AH_elements,elements);
            }
            
            //get new entries from panel
            getvalue(env_FSG_missedcall_add_name, gmissedcallname_new);
            gmissedcallnumbertype_new=getvalue(env_FSG_missedcall_add_type);
            getvalue(env_FSG_missedcall_add_number, gmissedcallnumber_new);

            callstack_missedcalls(CHANGE_ID,startelement,elements);
        }

        putvalue(env_FSG_MissedCalls_TotalNumLE,gmissedcalls_TotalNumListElements);
        display_callstack_missedcalls();
*/

    }
}

on envVar env_FSG_CallState_update
{
    int i, Offset;
    dword requestarray [BAP_buffer_size];

    //init lokal variables
	Offset=0;
	
	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
        requestarray[0]=LSGID_Telephone;	//LSG-ID
		requestarray[1]=FctID_CallState;	//Fct.-ID
		requestarray[2]=Data_REQ;	

		requestarray[3]=(@env_FSG_CallType_CallID_0_set +(@env_FSG_CallState_CallID_0_set *0x10));	//call state 0 (upper nibble) and call type 0 (lower nibble)
        requestarray[4]=@env_FSG_CallState_Opt_AcCall_0_s 
                        +(@env_FSG_CallState_Opt_HoldAc_0_s *0x02) 
                        +(@env_FSG_CallState_Opt_CallAc_0_s *0x04)
                        +(@env_FSG_CallState_Opt_CallHo_0_s *0x08)
                        +(@env_FSG_CallState_Opt_ResCal_0_s *0x10)
                        +(@env_FSG_CallState_Opt_MPSwap_0_s *0x20)
                        +(@env_FSG_CallState_Opt_CCJoin_0_s *0x40)
                        +(@env_FSG_CallState_Opt_CCSpli_0_s *0x80);
        requestarray[5]=(@env_FSG_CallType_CallID_1_set +(@env_FSG_CallState_CallID_1_set *0x10));	
        requestarray[6]=@env_FSG_CallState_Opt_AcCall_1_s 
                        +(@env_FSG_CallState_Opt_HoldAc_1_s *0x02) 
                        +(@env_FSG_CallState_Opt_CallAc_1_s *0x04)
                        +(@env_FSG_CallState_Opt_CallHo_1_s *0x08)
                        +(@env_FSG_CallState_Opt_ResCal_1_s *0x10)
                        +(@env_FSG_CallState_Opt_MPSwap_1_s *0x20)
                        +(@env_FSG_CallState_Opt_CCJoin_1_s *0x40)
                        +(@env_FSG_CallState_Opt_CCSpli_1_s *0x80);
        requestarray[7]=(@env_FSG_CallType_CallID_2_set +(@env_FSG_CallState_CallID_2_set *0x10));	
        requestarray[8]=@env_FSG_CallState_Opt_AcCall_2_s 
                        +(@env_FSG_CallState_Opt_HoldAc_2_s *0x02) 
                        +(@env_FSG_CallState_Opt_CallAc_2_s *0x04)
                        +(@env_FSG_CallState_Opt_CallHo_2_s *0x08)
                        +(@env_FSG_CallState_Opt_ResCal_2_s *0x10)
                        +(@env_FSG_CallState_Opt_MPSwap_2_s *0x20)
                        +(@env_FSG_CallState_Opt_CCJoin_2_s *0x40)
                        +(@env_FSG_CallState_Opt_CCSpli_2_s *0x80);
        requestarray[9]=(@env_FSG_CallType_CallID_3_set +(@env_FSG_CallState_CallID_3_set *0x10));	
        requestarray[10]=@env_FSG_CallState_Opt_AcCall_3_s 
                        +(@env_FSG_CallState_Opt_HoldAc_3_s *0x02) 
                        +(@env_FSG_CallState_Opt_CallAc_3_s *0x04)
                        +(@env_FSG_CallState_Opt_CallHo_3_s *0x08)
                        +(@env_FSG_CallState_Opt_ResCal_3_s *0x10)
                        +(@env_FSG_CallState_Opt_MPSwap_3_s *0x20)
                        +(@env_FSG_CallState_Opt_CCJoin_3_s *0x40)
                        +(@env_FSG_CallState_Opt_CCSpli_3_s *0x80);
        requestarray[11]=(@env_FSG_CallType_CallID_4_set +(@env_FSG_CallState_CallID_4_set *0x10));	
        requestarray[12]=@env_FSG_CallState_Opt_AcCall_4_s 
                        +(@env_FSG_CallState_Opt_HoldAc_4_s *0x02) 
                        +(@env_FSG_CallState_Opt_CallAc_4_s *0x04)
                        +(@env_FSG_CallState_Opt_CallHo_4_s *0x08)
                        +(@env_FSG_CallState_Opt_ResCal_4_s *0x10)
                        +(@env_FSG_CallState_Opt_MPSwap_4_s *0x20)
                        +(@env_FSG_CallState_Opt_CCJoin_4_s *0x40)
                        +(@env_FSG_CallState_Opt_CCSpli_4_s *0x80);
        requestarray[13]=(@env_FSG_CallType_CallID_5_set +(@env_FSG_CallState_CallID_5_set *0x10));	
        requestarray[14]=@env_FSG_CallState_Opt_AcCall_5_s 
                        +(@env_FSG_CallState_Opt_HoldAc_5_s *0x02) 
                        +(@env_FSG_CallState_Opt_CallAc_5_s *0x04)
                        +(@env_FSG_CallState_Opt_CallHo_5_s *0x08)
                        +(@env_FSG_CallState_Opt_ResCal_5_s *0x10)
                        +(@env_FSG_CallState_Opt_MPSwap_5_s *0x20)
                        +(@env_FSG_CallState_Opt_CCJoin_5_s *0x40)
                        +(@env_FSG_CallState_Opt_CCSpli_5_s *0x80);
        requestarray[15]=(@env_FSG_CallType_CallID_6_set +(@env_FSG_CallState_CallID_6_set *0x10));	
        requestarray[16]=@env_FSG_CallState_Opt_AcCall_6_s 
                        +(@env_FSG_CallState_Opt_HoldAc_6_s *0x02) 
                        +(@env_FSG_CallState_Opt_CallAc_6_s *0x04)
                        +(@env_FSG_CallState_Opt_CallHo_6_s *0x08)
                        +(@env_FSG_CallState_Opt_ResCal_6_s *0x10)
                        +(@env_FSG_CallState_Opt_MPSwap_6_s *0x20)
                        +(@env_FSG_CallState_Opt_CCJoin_6_s *0x40)
                        +(@env_FSG_CallState_Opt_CCSpli_6_s *0x80);
		requestarray[17]=@env_FSG_CallState_CallInDive_0_s
                        +(@env_FSG_CallState_CallInDive_1_s *0x02)
                        +(@env_FSG_CallState_CallInDive_2_s *0x04)
                        +(@env_FSG_CallState_CallInDive_3_s *0x08)
                        +(@env_FSG_CallState_CallInDive_4_s *0x10)
                        +(@env_FSG_CallState_CallInDive_5_s *0x20)
                        +(@env_FSG_CallState_CallInDive_6_s *0x40);						  
        requestarray[18]=@env_FSG_CallState_CallOuDive_0_s
                        +(@env_FSG_CallState_CallOuDive_1_s *0x02)
                        +(@env_FSG_CallState_CallOuDive_2_s *0x04)
                        +(@env_FSG_CallState_CallOuDive_3_s *0x08)
                        +(@env_FSG_CallState_CallOuDive_4_s *0x10)
                        +(@env_FSG_CallState_CallOuDive_5_s *0x20)
                        +(@env_FSG_CallState_CallOuDive_6_s *0x40)
                        +(@env_FSG_CallState_CallOuDive_7_s *0x80);
                        					    
	    set_status_requestbuffer (requestarray, 19, Bap_ByteSequence);	//send CallState

                //MR63666
                if ((getValue(env_FSG_CallState_CallID_0_set)>0x00 && getValue(env_FSG_CallState_CallID_0_set)< 0x04) 
                || (getValue(env_FSG_CallState_CallID_1_set)>0x00 && getValue(env_FSG_CallState_CallID_1_set)< 0x04)
                || (getValue(env_FSG_CallState_CallID_2_set)>0x00 && getValue(env_FSG_CallState_CallID_2_set)< 0x04)
                || (getValue(env_FSG_CallState_CallID_3_set)>0x00 && getValue(env_FSG_CallState_CallID_3_set)< 0x04)
                || (getValue(env_FSG_CallState_CallID_4_set)>0x00 && getValue(env_FSG_CallState_CallID_4_set)< 0x04)
                || (getValue(env_FSG_CallState_CallID_5_set)>0x00 && getValue(env_FSG_CallState_CallID_5_set)< 0x04)
                || (getValue(env_FSG_CallState_CallID_6_set)>0x00 && getValue(env_FSG_CallState_CallID_6_set)< 0x04))
                {
                    if (getValue(env_PIC_bapMOST_active_flag)==0x00) //nonCoupled
                    {
                         if (getValue(env_PIC_bapMOST_setImage_Cat) == 0x01)   //ActiveCall
                         {
                            if (getValue(env_FSG_MOST_ActiveCallPicType_NC)> 0x00 && getValue(env_FSG_MOST_ActiveCallPicType_NC)< 0x06) //not NoPicture/DefaultPicture
                            {
                            putValue(env_PIC_bapMOST_setImage_button,1);
                            setTimer (_tReleaseSetImage_button,100);
                            }
                         } 
                    } 
                }
    }
}

on envVar env_FSG_open_send_data_panel
{
    if(getvalue(this))
        OpenPanel("FSG-Telephone_send_data");
}

on envVar env_FSG_CallInfo_update
{
    int i, Offset;
    dword requestarray [BAP_buffer_size];
    char string [120];

    //init lokal variables
    Offset=0;
    for(i=0;i<120;i++)
        string[i] =0;
	
	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {
        requestarray[0]=LSGID_Telephone;	//LSG-ID
		requestarray[1]=FctID_CallInfo;	    //Fct.-ID
		requestarray[2]=Data_REQ;	

		//PbName0
        getvalue(env_FSG_CallInfo_PbName_0_s, string);
        requestarray[3]=strlen(string);
        Offset =4;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;

        //TelNumber0
        getvalue(env_FSG_CallInfo_TelNumber_0_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;
    
        //Category0
        requestarray[Offset] =@env_FSG_CallInfo_Category_0_s;
        Offset++;

        //PbName1
        getvalue(env_FSG_CallInfo_PbName_1_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;

        //TelNumber1
        getvalue(env_FSG_CallInfo_TelNumber_1_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;
    
        //Category1
        requestarray[Offset] =@env_FSG_CallInfo_Category_1_s;
        Offset++;

        //PbName2
        getvalue(env_FSG_CallInfo_PbName_2_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;

        //TelNumber2
        getvalue(env_FSG_CallInfo_TelNumber_2_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;
    
        //Category2
        requestarray[Offset] =@env_FSG_CallInfo_Category_2_s;
        Offset++;

        //PbName3
        getvalue(env_FSG_CallInfo_PbName_3_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;

        //TelNumber3
        getvalue(env_FSG_CallInfo_TelNumber_3_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;
    
        //Category3
        requestarray[Offset] =@env_FSG_CallInfo_Category_3_s;
        Offset++;

        //PbName4
        getvalue(env_FSG_CallInfo_PbName_4_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;

        //TelNumber4
        getvalue(env_FSG_CallInfo_TelNumber_4_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;
    
        //Category4
        requestarray[Offset] =@env_FSG_CallInfo_Category_4_s;
        Offset++;

        //PbName5
        getvalue(env_FSG_CallInfo_PbName_5_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;

        //TelNumber5
        getvalue(env_FSG_CallInfo_TelNumber_5_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;
    
        //Category5
        requestarray[Offset] =@env_FSG_CallInfo_Category_5_s;
        Offset++;

        //PbName6
        getvalue(env_FSG_CallInfo_PbName_6_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;

        //TelNumber6
        getvalue(env_FSG_CallInfo_TelNumber_6_s, string);
        requestarray[Offset]=strlen(string);
        Offset++;
       
        for(i=0;i<strlen(string);i++)
        {
            requestarray[Offset]=string[i];
            Offset++;    
        }
        for(i=0;i<120;i++)
            string[i] =0;
    
        //Category6
        requestarray[Offset] =@env_FSG_CallInfo_Category_6_s;
        Offset++;

        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);	//send CallInfo
    }
}

//IssueList #51
//on envVar env_FSG_RingToneMuteOnOff

on envVar env_FSG_RingToneMuteOnOff_OK
{
    //if(gFSG_Telephone_PowerOnOff == Power_on && gRingToneMuteOnOff != getvalue(this))
   if(gFSG_Telephone_PowerOnOff == Power_on &&getValue(this))
    { 
       
        if (gRingToneMuteOnOff != getvalue(env_FSG_RingToneMuteOnOff))
        {
        gRingToneMuteOnOff = getvalue(env_FSG_RingToneMuteOnOff); //(getvalue(env_FSG_RingToneMuteOnOff) & 0x01);

        }
        RingToneMuteOnOff_Request(Data_REQ, 0);
    }
 
}

RingToneMuteOnOff_Indication (dword Indication_array [], byte indication, int datalength)
{

    //write("FSG: RingToneMuteOnOff_Indication");

	switch (indication){
		case DataSetGet_IND:
			//check array
			if(datalength!=4)														//datalength error
				RingToneMuteOnOff_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message
		 
         //IssueList #27
            else if (getValue(env_Tel_RingToneMute_Error_On))
            RingToneMuteOnOff_Request(Error_REQ, getValue(env_Tel_RingToneMute_Error_Code));	

            else
            {
                putvalue(env_FSG_RingToneMuteOnOff, (Indication_array[3] & 0x01));
                //IssueList #51
                putValue(env_FSG_RingToneMuteOnOff_OK,1);
                if(gRingToneMuteOnOff == (Indication_array[3] & 0x01)) // gRingToneMute not changed: value vill not be send by 'on envVar env_FSG_RingToneMuteOnOff'
                    RingToneMuteOnOff_Request(Data_REQ, 0);
                   
                if(gRingTone_incoming_callid < 7)
                {
                    //write("mute ringtone while incoming call: will be reactivated after hangup or accept");
                    gRingTone_unmute = 1; // indicate, that the ringtone has to be unmuted in case of hangup or accept
                    //write("gRingTone_unmute: %d");
                }
			}
		break;
        case DataGet_IND:
			if(datalength != 3)															//datalength error
				RingToneMuteOnOff_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				RingToneMuteOnOff_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone RingToneMuteOnOff_Indication: unknown indication %d", indication);
		break;
	}
}

RingToneMuteOnOff_Request (byte request, byte errorcode)
{
    int i, offset;
    dword requestarray[BAP_buffer_size];

    //write("FSG: RingToneMuteOnOff_Request");

    //init lokal variables
	offset = 0;

	for(i = 0; i < BAP_buffer_size; i++)
		requestarray[i] = 0;
	
	switch(request){
		case Data_REQ:
		     //IssueList #62
    	    if (getValue(env_FSG_Tel_FctList_0x38_TimeOut)!=TRUE)
            {
            requestarray[0] = LSGID_Telephone;	//LSG-ID
			requestarray[1] = FctID_RingToneMuteOnOff;		//Fct.-ID
			requestarray[2] = request; 
			requestarray[3] = gRingToneMuteOnOff;
			offset = 4;		
			set_status_requestbuffer(requestarray, offset, Bap_UInt8);
            }
            
		break;
		case Error_REQ:
			requestarray[0] = LSGID_Telephone;	//LSG-ID
			requestarray[1] = FctID_RingToneMuteOnOff;		//Fct.-ID
			requestarray[2] = request;	
			requestarray[3] = errorcode;
			offset = 4;
			set_status_requestbuffer(requestarray, offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone RingToneMuteOnOff_Request: invalid request %d", request);
		break;
	}
//IssueList #51   
putValue(env_FSG_RingToneMuteOnOff_OK,0); 
}

CombinedNumbers_Indication(dword Indication_array [])
{
    byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements, Offset;
    int i=0;
    
//changes for IssueList #152 - MR 53938
//TEL_COMBINEDNUMBERS_ENTRIES --> gCombinedNumbers_TotalNumListElements--> gCN_CSVtotalElem

    //IssueList #76 - MR49870 : Phonebook
    int j =0;
    byte telephoneListDelFlg;
    word validStartElem_plusElem;

     //IssueList #193
    byte cn_InValidStartElemFlg;

    // Init local variables. 
    mode                    =0;
    direction               =0;
    shift                   =0;
    transmitpos             =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    indexsize               =0;
    valid_startelement      =0xff;
    valid_elements          =0;
    Offset                  =0;

        switch (Indication_array[2]) // indication
	    {
            putvalue(env_Telephone_DataGet_IND, 1); // MR60227: Item #9
		    case DataGet_IND:
              //MR60227
                putValue(env_FSG_CN_Flg,1);
		
		//MR 63336	02.07.2014
                if(getvalue(env_FSG_CN_Timeout) == TRUE)
                {
                /* NOP */
                }
		//VAGH-10511
		else if(getvalue(env_FSG_CN_Error_on) == TRUE)
		{
		    CombinedNumbers_Request(Error_REQ, 0, 0, 0, 0, 0, 0, getvalue(env_FSG_CN_ErrorCode));   
		}
		else
		{
                //getData
                gCombinedNumbers_ASGID                =(gBAP_Indication[3] &0xF0) /0x10;
                gCombinedNumbers_TAID                 =gBAP_Indication[3] &0x0F;
                
                 //IssueList #20
                gPhonebookRequestActive = 0x00;
                //decode BAP-ArrayHeader
                mode                =(gBAP_Indication[4] &0xF0) /0x10;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                recordaddress       =gBAP_Indication[4] &0x0F;
                if(indexsize)
                {
                    startelement        =gBAP_Indication[5];
                    startelement        +=gBAP_Indication[6] *0x100;
                    elements            =gBAP_Indication[7];
                    elements            +=gBAP_Indication[8]*0x100;
                }
                else
                {    
                    startelement        =gBAP_Indication[5];
                    elements            =gBAP_Indication[6];
                }

                requested_startelement =startelement;
                
                transmitpos     =TRUE; 
                mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***Startelement=0***/
                if(0==startelement) //Startelement-ID =0 -> start at first array-entry
				{
                    if(FORWARD==direction)  //forward-start
					{
                        valid_startelement =0;				       									

                        if(gCombinedNumbers_TotalNumListElements <=elements) //1. more elements requested, than in array
						{
                            if (shift ==FALSE)  
                            {
                                for(i=0;i<gCombinedNumbers_TotalNumListElements;i++)
							    {
								    if(0 !=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
                                        valid_elements++;	            //increment elements
					
								    else												//no valid element, loop finished
									    i =gCombinedNumbers_TotalNumListElements;
							    }
                            }
                            else if (shift ==TRUE)
                            {   
                                valid_startelement  =1;
                                startelement        =valid_startelement;

                                for(i=1;i<gCN_CSVtotalElem;i++)
							    {
								    if(0 !=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
                                        valid_elements++;                               //increment elements
								    else												//no valid element, loop finished
									    i =gCN_CSVtotalElem;
							    }
                            }
						}
                        else    //2. number of requested elements < elements in array
						{
                            if (shift ==FALSE)
                            {
							    for(i=0;i<elements;i++)
							    {
								    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
                                        valid_elements++;
								    else												//no valid element, loop finished
									    i =gCN_CSVtotalElem;
							    }
                            }
                            else if (shift ==TRUE)
                            {
                                valid_startelement  =1;
                                startelement        =valid_startelement;

                                for(i=1;i<=elements;i++)
							    {
								    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
                                        valid_elements++;	
								    else												//no valid element, loop finished
									    i =gCN_CSVtotalElem;
							    }   
                            }
						}
                    }                                                               //forward ends

                    else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
					{   
						//searching for valid startelement
						for(i=(gCN_CSVtotalElem-1);i>=0;i--)
						{
							if(0!=gCombinedNumbers_ListEntryValidInformation[i])		//found valid startelement
							{
								valid_startelement =i;								
								i =0;												
							}
						}
                        
                        //searching for valid elements
						if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
						{
							valid_startelement  =startelement;
							valid_elements      =0;
						}
						else if(0==valid_startelement)								
							valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
						else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
						{
							for(i=valid_startelement;i>=0;i--)
							{
								if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
                                    valid_elements++;
								else												//no valid element, loop finished
									i=0;
							}
						}
                        else														//enougth array-elements available
						{
							for(i=valid_startelement;i>(valid_startelement-elements);i--)
							{
								if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
                                    valid_elements++;
								else												//no valid element, loop finished
									i=0;
							}
                                      
						}															
				    }                                                               //backward-end
                }                                                                   //startelement ==0 -end

                /***Startelement!=0***/
                else																//searching for Startelement-ID				
				{
                    //IssueList #193 - start
					cn_InValidStartElemFlg = 0;
	                for(i=0;i<gCN_CSVtotalElem;i++)
					{
                        if (startelement==gCombinedNum_Pos_insDel[i][0])
                        {
                            //check if Start is deleted then reply with 0 elements
                            if( gCombinedNum_Pos_insDel[i][1]==0x01)
                            {
                            valid_startelement  =startelement;
    						valid_elements      =0;
                            cn_InValidStartElemFlg = 1;
                            }
                        }
                    }
					//IssueList #193 - end

                    //IssueList #193 - if condition
					if (cn_InValidStartElemFlg == 0x00)
					{
                        //searching for valid startelement
    					for(i=0;i<gCN_CSVtotalElem;i++)
    					{
    						if(gCombinedNumbers_Pos[i] ==startelement)					    //found a valid element
    						{                                          
                                if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
    							{
    								if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
    									valid_startelement =i+1-2*direction;
                                							
                                    else if(i==0 && BACKWARD==direction) 
                                        valid_startelement =gCombinedNumbers_sum;     //valid element is last element in Array                                                
                            
                                    else if(i==0 && FORWARD==direction) 
                                        valid_startelement =0;                          //valid element is first element in Array
                                }
					
                                else
                                    valid_startelement =i;                              //found element is valid_startelement

    							i=gCN_CSVtotalElem;
    						}
    					}
                    
    					if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
    					{
    						valid_startelement  =startelement;
    						valid_elements      =0;
    					}
    					else																//found valid entry for startelement in array
    					{
    						//verify number of valid elements
    						if(BACKWARD==direction)											//backward-start
    						{
    							if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
    							{	 //IssueList #76 - MR49870 : CN
                                       telephoneListDelFlg = 0x00;
                                       telephoneListDelFlg = telephoneList_deleteCheck(gCombinedNumbers_Pos[0],gCombinedNum_Pos_insDel,gCN_CSVtotalElem );

                                       if (telephoneListDelFlg == 0x00)
                                       valid_elements=1;
                    
    							}
    							else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
    							{
    								for(i=valid_startelement;i>=0;i--)
    								{
    									if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
                                        valid_elements++;
    									else												//no valid element, loop finished
    										i=0;
    								}
    							}
    							else														//enougth array-elements available
    							{
    								for(i=valid_startelement;i>(valid_startelement-elements);i--)
    								{
    									if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
                                        valid_elements++;
    									else												//no valid element, loop finished
    										i=0;
    								}
    							}
    						}																//backward-end
    						else															//forward-start
    						{
    							if((valid_startelement+elements)>=gCombinedNumbers_TotalNumListElements)
    							{
    								for(i=valid_startelement;i<gCN_CSVtotalElem;i++)
    								{
    									//if(0!=gCombinedNumbers_Pos[i])						//if there is an valid element
    									if(gCombinedNumbers_ListEntryValidInformation[i])
                                        	{
                                            //IssueList #76 - MR49870 : CN
                                            telephoneListDelFlg = 0x00;
                                            telephoneListDelFlg = telephoneList_deleteCheck(gCombinedNumbers_Pos[i], gCombinedNum_Pos_insDel, gCN_CSVtotalElem );
                                        
                                            if (telephoneListDelFlg == 0x00 && valid_elements < elements)
                                            valid_elements++;
                                            }									//increment elements
    									else												//no valid element, loop finished
    										i=gCN_CSVtotalElem;
    								}
    							}
    							else
    							{
    								//IssueList #76 - MR49870 : CN
                                     validStartElem_plusElem =valid_startelement+elements;
                                    //for(i=valid_startelement;i<(valid_startelement+elements);i++)
                                    for(i=valid_startelement;i<validStartElem_plusElem;i++)
    								{
    									//if(0!=gCombinedNumbers_Pos[i])						    //if there is an valid element
    									if(gCombinedNumbers_ListEntryValidInformation[i])
                                        {
                                             //IssueList #76 - MR49870 : CN
                                            telephoneListDelFlg = 0x00;
                                            telephoneListDelFlg = telephoneList_deleteCheck(gCombinedNumbers_Pos[i], gCombinedNum_Pos_insDel, gCN_CSVtotalElem );
                                        
                                            if (telephoneListDelFlg == 0x00)
                                            {
                                                if (valid_elements < elements) 
                                                valid_elements++;
                                             }
                                             else
                                             {
                                                if (valid_elements < elements)
                                                 validStartElem_plusElem++;      //adjust the loop boundary based on number of deleted elements
                                              }	
                                    
                                        }									//increment elements
    									else												//no valid element, loop finished
    										i=gCN_CSVtotalElem;
    								}
    							}
    						}
    					}
					}//cn_InValidStartElemFlg
    			}

                    mode =0;     
                    mode =CombinedNumbers_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);

                    //send StatusArray
                    //MR 63667 11.07.2014 -TNLE with SA-button
                    //CombinedNumbers_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);  
		    //VAGH-10511
		    if(!getvalue(env_FSG_CN_StatusArrayOff))
		        CombinedNumbers_Request(Data_REQ, gCombinedNumbers_TotalNumListElements, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                 

                    //Panel
    		        putvalue(env_FSG_CN_ASGID,gCombinedNumbers_ASGID);
                    putvalue(env_FSG_CN_TAID,gCombinedNumbers_TAID);
                 
                 } //(getvalue(env_FSG_CN_Timeout)
                 break;
            
                case DataSetGet_IND:
                    putvalue(env_Telephone_DataGet_IND, 1); // MR60227: Item #9
                    //getData
                    gCombinedNumbers_ASGID                =(gBAP_Indication[3] &0xF0) /0x10;
                    gCombinedNumbers_TAID                 =gBAP_Indication[3] &0x0F;
                
                    //decode BAP-ArrayHeader
                    mode                =(gBAP_Indication[4] &0xF0) /0x10;
                
                    // decode "mode-byte"
                    shift       =mode &0x01;
                    direction   =(mode &0x02)/0x02;
                    transmitpos =(mode &0x04)/0x04;
                    indexsize   =(mode &0x08)/0x08; 

                    recordaddress       =gBAP_Indication[4] &0x0F;
                    if(indexsize)
                    {
                        startelement        =gBAP_Indication[5];
                        startelement        +=gBAP_Indication[6] *0x100;
                        elements            =gBAP_Indication[7];
                        elements            +=gBAP_Indication[8]*0x100;

                        Offset =9;
                    }
                    else
                    {    
                        startelement        =gBAP_Indication[5];
                        elements            =gBAP_Indication[6];

                        Offset =7;
                    }

                    requested_startelement =startelement;
                
                    //transmitpos     =FALSE; //Position must always be sent in the case of *.StatusArray.  
                    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                    /***Startelement=0***/
                    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
    				{
                        if(FORWARD==direction)  //forward-start
    					{
                            valid_startelement =0;				       									

                            if(gCN_CSVtotalElem <=elements) //1. more elements requested, than in array
    						{
                                if (shift ==FALSE)  
                                {
                                    for(i=0;i<gCN_CSVtotalElem;i++)
    							    {
    								    if(0 !=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
    									    valid_elements++;								//increment elements
    								    else												//no valid element, loop finished
    									    i =gCN_CSVtotalElem;
    							    }
                                }
                                else if (shift ==TRUE)
                                {   
                                    valid_startelement  =1;
                                    startelement        =valid_startelement;

                                    for(i=1;i<gCN_CSVtotalElem;i++)
    							    {
    								    if(0 !=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
    									    valid_elements++;								//increment elements
    								    else												//no valid element, loop finished
    									    i =gCN_CSVtotalElem;
    							    }
                                }
    						}
                            else    //2. number of requested elements < elements in array
    						{
                                if (shift ==FALSE)
                                {
    							    for(i=0;i<elements;i++)
    							    {
    								    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
    									    valid_elements++;								//increment elements
    								    else												//no valid element, loop finished
    									    i =gCN_CSVtotalElem;
    							    }
                                }
                                else if (shift ==TRUE)
                                {
                                    valid_startelement  =1;
                                    startelement        =valid_startelement;

                                    for(i=1;i<=elements;i++)
    							    {
    								    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
    									    valid_elements++;								//increment elements
    								    else												//no valid element, loop finished
    									    i =gCN_CSVtotalElem;
    							    }   
                                }
    						}
                        }                                                               //forward ends

                        else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
    					{   
    						//searching for valid startelement
    						for(i=(gCN_CSVtotalElem-1);i>=0;i--)
    						{
    							if(0!=gCombinedNumbers_ListEntryValidInformation[i])		//found valid startelement
    							{
    								valid_startelement =i;								
    								i =0;												
    							}
    						}
                        
                            //searching for valid elements
    						if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
    						{
    							valid_startelement  =startelement;
    							valid_elements      =0;
    						}
    						else if(0==valid_startelement)								
    							valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
    						else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
    						{
    							for(i=valid_startelement;i>=0;i--)
    							{
    								if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
    									valid_elements++;								//increment elements
    								else												//no valid element, loop finished
    									i=0;
    							}
    						}
                            else														//enougth array-elements available
    						{
    							for(i=valid_startelement;i>(valid_startelement-elements);i--)
    							{
    								if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
    									valid_elements++;								//increment elements
    								else												//no valid element, loop finished
    									i=0;
    							}
                                      
    						}															
    				    }                                                               //backward-end
                    }                                                                   //startelement ==0 -end

                    /***Startelement!=0***/
                    else																//searching for Startelement-ID				
    				{
    					//IssueList #193 - start
						cn_InValidStartElemFlg = 0;
						for(i=0;i<gCN_CSVtotalElem;i++)
						{
							if (startelement==gCombinedNum_Pos_insDel[i][0])
							{
								//check if Start is deleted then reply with 0 elements
								if( gCombinedNum_Pos_insDel[i][1]==0x01)
								{
								valid_startelement  =startelement;
								valid_elements      =0;
								cn_InValidStartElemFlg = 1;
								}
							}
						}
						//IssueList #193 - end

                    //IssueList #193 - if condition
					if (cn_InValidStartElemFlg == 0x00)
					{
						//searching for valid startelement
    					for(i=0;i<gCN_CSVtotalElem;i++)
    					{
    						if(gCombinedNumbers_Pos[i] ==startelement)					    //found a valid element
    						{                                          
                                if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
    							{
    								if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
    									valid_startelement =i+1-2*direction;
                                							
                                    else if(i==0 && BACKWARD==direction) 
                                        valid_startelement =gCombinedNumbers_sum;     //valid element is last element in Array                                                
                            
                                    else if(i==0 && FORWARD==direction) 
                                        valid_startelement =0;                          //valid element is first element in Array
                                }
					
                                else
                                    valid_startelement =i;                              //found element is valid_startelement

    							i=gCN_CSVtotalElem;
    						}
    					}

    					if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
    					{
    						valid_startelement  =startelement;
    						valid_elements      =0;
    					}
    					else																//found valid entry for startelement in array
    					{
    						//verify number of valid elements
    						if(BACKWARD==direction)											//backward-start
    						{
    							if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
    								valid_elements=1;
							
    							else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
    							{
    								for(i=valid_startelement;i>=0;i--)
    								{
    									if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
    										valid_elements++;								//increment elements
    									else												//no valid element, loop finished
    										i=0;
    								}
    							}
    							else														//enougth array-elements available
    							{
    								for(i=valid_startelement;i>(valid_startelement-elements);i--)
    								{
    									if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
    										valid_elements++;								//increment elements
    									else												//no valid element, loop finished
    										i=0;
    								}
    							}
    						}																//backward-end
    						else															//forward-start
    						{
    							if((valid_startelement+elements)>=gCN_CSVtotalElem)
    							{
    								for(i=valid_startelement;i<gCN_CSVtotalElem;i++)
    								{
    									if(0!=gCombinedNumbers_Pos[i])						//if there is an valid element
    										valid_elements++;								//increment elements
    									else												//no valid element, loop finished
    										i=gCN_CSVtotalElem;
    								}
    							}
    							else
    							{
    								for(i=valid_startelement;i<(valid_startelement+elements);i++)
    								{
    									if(0!=gCombinedNumbers_Pos[i])						    //if there is an valid element
    										valid_elements++;								//increment elements
    									else												//no valid element, loop finished
    										i=gCN_CSVtotalElem;
    								}
    							}
    						}
    					}
                    }//cn_InValidStartElemFlg
				}//else Startelement!=0
                
                if(getvalue(env_FSG_CN_SetGetArray_behaviour) && valid_elements>0)
                    CombinedNumbers_TakeOverData(Indication_array, Offset, valid_startelement, valid_elements, recordaddress, direction, transmitpos, indexsize);
                
                mode =0;   
                mode =CombinedNumbers_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);

                //send StatusArray
                //MR 63667 11.07.2014 -TNLE with SA-button
                //CombinedNumbers_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0); 
		//VAGH-10511
		if(!getvalue(env_FSG_CN_StatusArrayOff))
		    CombinedNumbers_Request(Data_REQ, gCombinedNumbers_TotalNumListElements, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                    

                //Panel
		        putvalue(env_FSG_CN_ASGID,gCombinedNumbers_ASGID);
                putvalue(env_FSG_CN_TAID,gCombinedNumbers_TAID);
                
                //check FSG Cache
                CombinedNumbers_CheckCache();

            break;

            case Error_IND:
				writelineEx(gError_Trace, 0, "FSG_Telepfhone CombinedNumbers_Indication: received error, errorcode:0x%x", Indication_array[3]);
			break;

		    default:
			    writelineEx(gError_Trace, 0, "FSG_Telepfhone CombinedNumbers_Indication: invalid indication %d", Indication_array[2]);
		     break;
	}
}

CombinedNumbers_Request (byte request, word tnle, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{
    int  i;
    byte shift, direction, transmitpos, indexsize, current_element;
    dword requestarray [BAP_buffer_size], Offset;
    word CombinedNumbersLine;

     //IssueList #76 - MR49870 : Phonebook
    byte telephoneListDelFlg;

	// Init local variables. 
    for(i=0;i<BAP_buffer_size;i++)
	    requestarray [i]=0;
    
    shift               =0;
    direction           =0;
	transmitpos         =0;
	indexsize           =0;
    CombinedNumbersLine =0;
    current_element     =0;
    Offset              =0;

    // decode "mode-byte"
    shift       =mode &0x01;
    direction   =(mode &0x02)/0x02;
	transmitpos =(mode &0x04)/0x04;
	indexsize   =(mode &0x08)/0x08;

   //IssueList #100 (uncommented the code - for arbitrary IDs)
   // changes from Jan Swoboda (01.03.2012)

    if (startelement != 0xFF)
    {
        if (gCombinedNumbers_Pos[startelement] != requested_startelement)
       {
            // JanSwo 20111111: ForcePos
            transmitpos = 1;
            mode |= 0x04;
            // write("CombinedNumbers_Request: ForcePos");
        }
    }
	// Handle request.
    requestarray[0] =LSGID_Telephone;				//LSG-ID
	requestarray[1] =FctID_CombinedNumbers;		//Fct.-ID
	requestarray[2] =request;                   //request type
	Offset =3;

    switch(request)
	{
		case Changed_REQ: 

            /***ArrayHeader***/
			requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
			Offset++;
            if(indexsize)
            {
                requestarray[Offset] =requested_startelement &0xff;
                Offset++;
                requestarray[Offset] =(requested_startelement &0xff00) /0x100;
                Offset++;
                
                requestarray[Offset] =elements &0xff;
                Offset++;
                requestarray[Offset] =(elements &0xff00) /0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] =requested_startelement;
                Offset++;  
                requestarray[Offset] =elements;
                Offset++;
            }
            
            CombinedNumbersLine =startelement;
          
            if(@env_FSG_CN_CA_switch) //if "ArrayHeader + Data"
            {
                //copy data
                switch(recordaddress)
			    {
                    case 0: //complete record
                            while(current_element <elements)
                            {
                                if(CombinedNumbersLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                                            Offset++;
                                        }
                                    }
                                                                                          
                                    //PbName
                                    requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
                    			    {
			                            requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];	
			                            Offset++;
			                        }
                                    
                                    //NumberType+CallMode
                                    requestarray[Offset] = (gCombinedNumbers_NumberType[CombinedNumbersLine]*0x10) + gCombinedNumbers_CallMode[CombinedNumbersLine];//upper nible + lower nibble
                                    Offset++;
                                
                                    //CallMode
                                    //requestarray[Offset] =gCombinedNumbers_CallMode[CombinedNumbersLine];
                                    //Offset++;

                                    //TelNumber
                                    requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
                    			    {
			                            requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];	
			                            Offset++;
			                        }

                                    //Day
                                    requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
                                    Offset++;

                                    //Month
                                    requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
                                    Offset++;

                                    //Year
                                    requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
                                    Offset++;

                                    //Hour
                                    requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
                                    Offset++;

                                    //Minute
                                    requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
                                    Offset++;

                                    //Second
                                    requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
                                    Offset++;

                                }
                                current_element++;
                                CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
                            
                            }//end while
 
                     break;

                    case 1: //PbName, CallMode
                            while(current_element <elements)
                            {
                                if(CombinedNumbersLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                                            Offset++;
                                        }
                                    }
                                                                                              
                                    //PbName
                                    requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
                    			    {
			                            requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];	
			                            Offset++;
			                        }
                                
                                    //CallMode
                                    requestarray[Offset] =gCombinedNumbers_CallMode[CombinedNumbersLine];
                                    Offset++;
                                }
                                current_element++;
                                CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
                            
                            }//end while
                        
                     break;

                    case 2: //TelNumber, Day, Month, Year, Hour, Minute, Second
                            while(current_element <elements)
                            {
                                if(CombinedNumbersLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                                            Offset++;
                                        }
                                    }

                                    //TelNumber
                                    requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
                    			    {
			                            requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];	
			                            Offset++;
			                        }

                                    //Day
                                    requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
                                    Offset++;

                                    //Month
                                    requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
                                    Offset++;

                                    //Year
                                    requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
                                    Offset++;

                                    //Hour
                                    requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
                                    Offset++;

                                    //Minute
                                    requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
                                    Offset++;

                                    //Second
                                    requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
                                    Offset++;

                                }
                                current_element++;
                                CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
                            
                            }//end while
                        
                     break;

                    case 15: //Pos
                            while(current_element <elements)
                            {
                                if(CombinedNumbersLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                                            Offset++;
                                        }
                                    }
                                }
                                current_element++;
                                CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
                            
                            }//end while
                        
                     break;

                    default:
					    write("FSG-Telephone CombinedNumbers_Request: invalid recordaddress %d", recordaddress);
				     break;
                } //end switch "recordaddress"
            } //end if "ArrayHeader + Data"       		
		
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

        break; //end Changed_REQ
        
        
        case Data_REQ:
            //changes from Jöran Karl (28.03.2012)
            //MR 63336	02.07.2014
            //if(getvalue(env_FSG_CN_Timeout) != TRUE)
            if(/*getvalue(env_FSG_CN_Timeout) != */ TRUE)
            {
	        //VAGH-10511
	        ASGID = getvalue(env_FSG_CN_ASGID);
	        TAID = gCombinedNumbers_TAID;
                if(getvalue(env_FSG_CN_ASGID_error) == TRUE)
                {
                    ASGID += 2;
                }
                if(getvalue(env_FSG_CN_TAID_error) == TRUE)
                {
                    TAID += 0x02;
                }

                requestarray[Offset] =((ASGID *0x10) &0xF0) +(TAID &0x0F);	
                Offset++;

                //MR 63667 11.07.2014 -TNLE with SA-button
                //requestarray[Offset] =gCombinedNumbers_TotalNumListElements;
                requestarray[Offset] =tnle;	

                Offset++;


            /***ArrayHeader***/
			requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
			Offset++;
            if(indexsize)
            {
                requestarray[Offset] =requested_startelement &0xff;
                Offset++;
                requestarray[Offset] =(requested_startelement &0xff00) /0x100;
                Offset++;
                
                requestarray[Offset] =elements &0xff;
                Offset++;
                requestarray[Offset] =(elements &0xff00) /0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] =requested_startelement;
                Offset++;  
                requestarray[Offset] =elements;
                Offset++;
            }
              
            CombinedNumbersLine =startelement;
            
            //copy data
            switch(recordaddress)
			{
                case 0: //complete record
                        while(current_element <elements)
                        {
                            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                   //IssueList #76 - MR49870 : CN
                                  //Updating the status array excluding the deleted elements
                                  telephoneListDelFlg = 0x00;
                                  telephoneListDelFlg = telephoneList_deleteCheck(gCombinedNumbers_Pos[CombinedNumbersLine],gCombinedNum_Pos_insDel,gCN_CSVtotalElem);
                                            
                                  if (telephoneListDelFlg == 0x00)
                                  {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                                            Offset++;
                                        }//indexsize 
                                    }//telephoneListDelFlg
                                }//transmitpos
                                                                                              
                                //IssueList #76 - MR49870 : CN
								if (telephoneListDelFlg == 0x00)
                                {
                                    //PbName
                                    requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
                        			{
    			                        requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];	
    			                        Offset++;
    			                    }
									
									//NumberType+CallMode
                                    requestarray[Offset] =(gCombinedNumbers_NumberType[CombinedNumbersLine]*0x10) + gCombinedNumbers_CallMode[CombinedNumbersLine]; //upper nibble + lower nibble
                                    Offset++;
									
                                    //CallMode
                                    //requestarray[Offset] =gCombinedNumbers_CallMode[CombinedNumbersLine];
                                    //Offset++;

                                    //TelNumber
                                    requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
                        			{
    			                        requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];	
    			                        Offset++;
    			                    }

                                    //Day
                                    requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
                                    Offset++;

                                    //Month
                                    requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
                                    Offset++;

                                    //Year
                                    requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
                                    Offset++;

                                    //Hour
                                    requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
                                    Offset++;

                                    //Minute
                                    requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
                                    Offset++;

                                    //Second
                                    requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
                                    Offset++;
                                } //telephoneListDelFlg

                            }
                             //IssueList #76 - MR49870 : CN
							if (telephoneListDelFlg == 0x00)
                            current_element++;

                            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 1: //PbName, CallMode
                        while(current_element <elements)
                        {
                            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    //IssueList #76 - MR49870 : CN
                                  //Updating the status array excluding the deleted elements
                                  telephoneListDelFlg = 0x00;
                                  telephoneListDelFlg = telephoneList_deleteCheck(gCombinedNumbers_Pos[CombinedNumbersLine],gCombinedNum_Pos_insDel,gCN_CSVtotalElem);
                                            
                                  if (telephoneListDelFlg == 0x00)
                                  {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                                            Offset++;
                                        }
                                    }//telephoneListDelFlg
                                }//transmitpos
                                                                                              
                                if (telephoneListDelFlg == 0x00)
                                {
                                    //PbName
                                    requestarray[Offset] =strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gCombinedNumbers_PbName[CombinedNumbersLine]);i++)
                        			{
    			                        requestarray[Offset] =gCombinedNumbers_PbName[CombinedNumbersLine][i];	
    			                        Offset++;
    			                    }
                                
                                    //CallMode
                                    requestarray[Offset] =gCombinedNumbers_CallMode[CombinedNumbersLine];
                                    Offset++;
                                }//telephoneListDelFlg
                            }
                            if (telephoneListDelFlg == 0x00)
                            current_element++;

                            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 2: //TelNumber, Day, Month, Year, Hour, Minute, Second
                        while(current_element <elements)
                        {
                            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //TelNumber
                                requestarray[Offset] =strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gCombinedNumbers_TelNumber[CombinedNumbersLine]);i++)
                    			{
			                        requestarray[Offset] =gCombinedNumbers_TelNumber[CombinedNumbersLine][i];	
			                        Offset++;
			                    }

                                //Day
                                requestarray[Offset] =gCombinedNumbers_day[CombinedNumbersLine];
                                Offset++;

                                //Month
                                requestarray[Offset] =gCombinedNumbers_month[CombinedNumbersLine];
                                Offset++;

                                //Year
                                requestarray[Offset] =gCombinedNumbers_year[CombinedNumbersLine];
                                Offset++;

                                //Hour
                                requestarray[Offset] =gCombinedNumbers_hour[CombinedNumbersLine];
                                Offset++;

                                //Minute
                                requestarray[Offset] =gCombinedNumbers_minute[CombinedNumbersLine];
                                Offset++;

                                //Second
                                requestarray[Offset] =gCombinedNumbers_second[CombinedNumbersLine];
                                Offset++;

                            }
                            current_element++;
                            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 15: //Pos
                        while(current_element <elements)
                        {
                            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone CombinedNumbers_Request: invalid CombinedNumbersLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                     //IssueList #76 - MR49870 : CN
                                  //Updating the status array excluding the deleted elements
                                  telephoneListDelFlg = 0x00;
                                  telephoneListDelFlg = telephoneList_deleteCheck(gCombinedNumbers_Pos[CombinedNumbersLine],gCombinedNum_Pos_insDel,gCN_CSVtotalElem);
                                            
                                  if (telephoneListDelFlg == 0x00)
                                  {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gCombinedNumbers_Pos[CombinedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gCombinedNumbers_Pos[CombinedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gCombinedNumbers_Pos[CombinedNumbersLine];
                                            Offset++;
                                        }
                                    } //telephoneListDelFlg
                                }//transmitpos
                            }
                            if (telephoneListDelFlg == 0x00)
                            current_element++;

                            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                    default:
    					write("FSG-Telephone CombinedNumbers_Request: invalid recordaddress %d", recordaddress);
    				 break;
                } //end switch "recordaddress"
            //changes from Jöran Karl (28.03.2012)
	    }
            else
            {
                write("FSG-Telephone CombinedNumbers_Request: Simulate timeout of Status-Array!");
            }
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] =errorcode;
			
			set_status_requestbuffer (requestarray, 4, Bap_Error);
         break; //end Error_REQ
    
    } //end switch "request"   
}

byte CombinedNumbers_nextvalidLine (byte current_CombinedNumbersLine, byte direction)
{
    word next_CombinedNumbersLine;
    int i;

//changes for IssueList #152 - MR 53938
//TEL_COMBINEDNUMBERS_ENTRIES --> gCombinedNumbers_TotalNumListElements
         
    //init lokal variables
    next_CombinedNumbersLine    =0;
    i                           =0;

    //search next "list entry"
    if(((gCombinedNumbers_sum-1)==current_CombinedNumbersLine && FORWARD ==direction) || (0 ==current_CombinedNumbersLine && BACKWARD ==direction))	//last-/fist-element of array reached
	    next_CombinedNumbersLine =0xFF;
	else
	{
			next_CombinedNumbersLine =current_CombinedNumbersLine +1-2*direction;       //increment or decrement array-line (depends on direction);
            
            //IssueList #93
            if (next_CombinedNumbersLine < gCN_CSVtotalElem)
            {
            if(0 ==gCombinedNumbers_ListEntryValidInformation[next_CombinedNumbersLine])	// check if next element is "valid"
			    next_CombinedNumbersLine =0xff; 
                
             }					
	}

    return(next_CombinedNumbersLine);
}

CombinedNumbers_init_static()
{
    byte j, i, CombinedNumbersLine;

    //clear
    CombinedNumbersLine   =0;
    gCombinedNumbers_sum  =0;

	for(j=0;j<TEL_COMBINEDNUMBERS_ENTRIES;j++) 
	{
		gCombinedNumbers_Pos[j]                       =0;
        
        for(i=0;i<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;i++)
			gCombinedNumbers_PbName[j][i] =0;

        gCombinedNumbers_NumberType[j]                =0;		
		gCombinedNumbers_CallMode[j]                  =0;
        
        for(i=0;i<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;i++)
			gCombinedNumbers_TelNumber[j][i] =0;

        gCombinedNumbers_day[j]     =0;
        gCombinedNumbers_month[j]   =0;
        gCombinedNumbers_year[j]    =0;
        gCombinedNumbers_hour[j]    =0;
        gCombinedNumbers_minute[j]  =0;
        gCombinedNumbers_second[j]  =0;

        gCombinedNumbers_ListEntryValidInformation[j] =0;
	}
	  	
    //entry 0
	gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x00;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_0",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);

    gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_GENERAL;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_MISSEDCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_0",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =1;  
    gCombinedNumbers_month [CombinedNumbersLine]    =2; 
    gCombinedNumbers_year [CombinedNumbersLine]     =50; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =21; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =4; 
    gCombinedNumbers_second [CombinedNumbersLine]   =9;                         
    
    CombinedNumbersLine++;

    //entry 1
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x01;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_1",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_MOBILE;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_RECEIVEDCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_1",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =0xFF;  
    gCombinedNumbers_month [CombinedNumbersLine]    =0xFF; 
    gCombinedNumbers_year [CombinedNumbersLine]     =0xFF; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =0xFF; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =0xFF; 
    gCombinedNumbers_second [CombinedNumbersLine]   =0xFF;                         
    
    CombinedNumbersLine++;

    //entry 2
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x02;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_2",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_OFFICE;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_DIALEDNUMBER;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_2",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =5;  
    gCombinedNumbers_month [CombinedNumbersLine]    =4; 
    gCombinedNumbers_year [CombinedNumbersLine]     =2; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =9; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =34; 
    gCombinedNumbers_second [CombinedNumbersLine]   =54;                         
    
    CombinedNumbersLine++;

    //entry 3
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x03;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_3",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_HOME;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_UNKNOWNCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_3",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =30;  
    gCombinedNumbers_month [CombinedNumbersLine]    =5; 
    gCombinedNumbers_year [CombinedNumbersLine]     =84; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =5; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =0; 
    gCombinedNumbers_second [CombinedNumbersLine]   =0;                         
    
    CombinedNumbersLine++;

    //entry 4
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x04;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_4",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_FAX;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_MISSEDCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_4",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =31;  
    gCombinedNumbers_month [CombinedNumbersLine]    =7; 
    gCombinedNumbers_year [CombinedNumbersLine]     =83; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =10; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =15; 
    gCombinedNumbers_second [CombinedNumbersLine]   =1;                         
    
    CombinedNumbersLine++;

    //entry 5
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x05;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_5",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_PAGER;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_UNKNOWNCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_5",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =9;  
    gCombinedNumbers_month [CombinedNumbersLine]    =11; 
    gCombinedNumbers_year [CombinedNumbersLine]     =4; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =8; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =7; 
    gCombinedNumbers_second [CombinedNumbersLine]   =33;                         
    
    CombinedNumbersLine++;

    //entry 6
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x06;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_6",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_CAR;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_RECEIVEDCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_6",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =6;  
    gCombinedNumbers_month [CombinedNumbersLine]    =5; 
    gCombinedNumbers_year [CombinedNumbersLine]     =30; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =18; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =14; 
    gCombinedNumbers_second [CombinedNumbersLine]   =45;                         
    
    CombinedNumbersLine++;

    //entry 7
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x07;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_7",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_SIM;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_DIALEDNUMBER;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_7",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =21;  
    gCombinedNumbers_month [CombinedNumbersLine]    =1; 
    gCombinedNumbers_year [CombinedNumbersLine]     =31; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =23; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =29; 
    gCombinedNumbers_second [CombinedNumbersLine]   =30;                         
    
    CombinedNumbersLine++;

    //entry 8
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x08;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_8",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_MAINOFFICE;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_RECEIVEDCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_8",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =16;  
    gCombinedNumbers_month [CombinedNumbersLine]    =2; 
    gCombinedNumbers_year [CombinedNumbersLine]     =8; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =15; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =59; 
    gCombinedNumbers_second [CombinedNumbersLine]   =59;                         
    
    CombinedNumbersLine++;

    //entry 9
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x09;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_9",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_MAINHOME;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_MISSEDCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_9",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =31;  
    gCombinedNumbers_month [CombinedNumbersLine]    =12; 
    gCombinedNumbers_year [CombinedNumbersLine]     =99; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =23; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =59; 
    gCombinedNumbers_second [CombinedNumbersLine]   =59;                         
    
    CombinedNumbersLine++;

    //entry 10
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x0A;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_10",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_CELLOFFICE;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_RECEIVEDCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_10",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =1;  
    gCombinedNumbers_month [CombinedNumbersLine]    =1; 
    gCombinedNumbers_year [CombinedNumbersLine]     =0xFF; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =0; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =0; 
    gCombinedNumbers_second [CombinedNumbersLine]   =0;                         
    
    CombinedNumbersLine++;

    //entry 11
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x0B;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_11",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_CELLHOME;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_UNKNOWNCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_11",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =11;  
    gCombinedNumbers_month [CombinedNumbersLine]    =11; 
    gCombinedNumbers_year [CombinedNumbersLine]     =11; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =11; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =11; 
    gCombinedNumbers_second [CombinedNumbersLine]   =11;                         
    
    CombinedNumbersLine++;

    //entry 12
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x0C;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_12",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_FAXOFFICE;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_MISSEDCALL;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_12",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =1;  
    gCombinedNumbers_month [CombinedNumbersLine]    =1; 
    gCombinedNumbers_year [CombinedNumbersLine]     =0; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =0; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =0; 
    gCombinedNumbers_second [CombinedNumbersLine]   =0;                         
    
    CombinedNumbersLine++;

    //entry 13
    gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]     =TRUE;
    gCombinedNumbers_Pos [CombinedNumbersLine]                          =0x0D;
    strncpy(gCombinedNumbers_PbName [CombinedNumbersLine], "PbName_13",TEL_COMBINEDNUMBERS_PBNAME_LENGTH);
	
	gCombinedNumbers_NumberType [CombinedNumbersLine]                   =TEL_COMBINEDNUMBERS_FAXHOME;
    gCombinedNumbers_CallMode [CombinedNumbersLine]                     =TEL_COMBINEDNUMBERS_DIALEDNUMBER;
    
    strncpy(gCombinedNumbers_TelNumber [CombinedNumbersLine], "TelNumber_13",TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH);
    
    gCombinedNumbers_day [CombinedNumbersLine]      =31;  
    gCombinedNumbers_month [CombinedNumbersLine]    =2; 
    gCombinedNumbers_year [CombinedNumbersLine]     =20; 
    gCombinedNumbers_hour [CombinedNumbersLine]     =8; 
    gCombinedNumbers_minute [CombinedNumbersLine]   =9; 
    gCombinedNumbers_second [CombinedNumbersLine]   =10;                         
    
    CombinedNumbersLine++; 
    
    gCombinedNumbers_sum                    =CombinedNumbersLine;
    gCombinedNumbers_TotalNumListElements   =gCombinedNumbers_sum;

/*
    //write Array in "write-window"
    writeClear(gCombinedNumbers_writeWindow);
    writelineEx(gCombinedNumbers_writeWindow, 0, "");
    writelineEx(gCombinedNumbers_writeWindow, 0,"*******Default CombinedNumbers_Array*******");
    writelineEx(gCombinedNumbers_writeWindow, 0, "");
    
    for (i=0;i<gCombinedNumbers_sum;i++)
    {
        writelineEx(gCombinedNumbers_writeWindow, 0,"*******Element %d*******",i);
        
        writelineEx(gCombinedNumbers_writeWindow, 0,"Pos[%d]: 0x%x", i, gCombinedNumbers_Pos [i]);
                     
        writelineEx(gCombinedNumbers_writeWindow, 0,"PbName[%d]: '%s'", i, gCombinedNumbers_PbName[i]);
		
		writelineEx(gCombinedNumbers_writeWindow, 0,"NumberType[%d]: 0x%x",i, gCombinedNumbers_NumberType[i]);
        if(gCombinedNumbers_NumberType[i] <0x0F)
             writeEx(gCombinedNumbers_writeWindow, 0," -> '%s'", gCombinedNumbers_NumberType_s[gCombinedNumbers_NumberType[i]]);
        else
             writeEx(gCombinedNumbers_writeWindow, 0," -> '%s'", gstring_reserved);
			 
        writelineEx(gCombinedNumbers_writeWindow, 0,"CallMode[%d]: 0x%x",i, gCombinedNumbers_CallMode[i]);
        if(gCombinedNumbers_CallMode[i] <0x04)
             writeEx(gCombinedNumbers_writeWindow, 0," -> '%s'", gCombinedNumbers_CallMode_s[gCombinedNumbers_CallMode[i]]);
        else
             writeEx(gCombinedNumbers_writeWindow, 0," -> '%s'", gstring_reserved);			 		
        
        writelineEx(gCombinedNumbers_writeWindow, 0,"TelNumber[%d]: '%s'", i, gCombinedNumbers_TelNumber[i]);

        writelineEx(gCombinedNumbers_writeWindow, 0,"Day[%d]: %d",i, gCombinedNumbers_day[i]);

        writelineEx(gCombinedNumbers_writeWindow, 0,"Month[%d]: %d",i, gCombinedNumbers_month[i]);

        writelineEx(gCombinedNumbers_writeWindow, 0,"Year[%d]: %d",i, gCombinedNumbers_year[i]);

        writelineEx(gCombinedNumbers_writeWindow, 0,"Hour[%d]: %d",i, gCombinedNumbers_hour[i]);

        writelineEx(gCombinedNumbers_writeWindow, 0,"Minute[%d]: %d",i, gCombinedNumbers_minute[i]);

        writelineEx(gCombinedNumbers_writeWindow, 0,"Second[%d]: %d",i, gCombinedNumbers_second[i]);

        writelineEx(gCombinedNumbers_writeWindow, 0, "");
    }

    writelineEx(gCombinedNumbers_writeWindow, 0,"Anzahl der Listenelemente: %d", gCombinedNumbers_sum);
*/    
    putvalue(env_FSG_CN_TotalNumLE, gCombinedNumbers_TotalNumListElements);
}

CombinedNumbers_init_CSV () //Byte & file selection
{
    dword CSVfileHandle =0, ConfigFileHandle =0, i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
    char buffer_string[TEL_BUFFERSIZE], Path_CSV[TEL_BUFFERSIZE], Path_Config[TEL_BUFFERSIZE];
    byte CombinedNumbersLine =0, buffer_byte[TEL_BUFFERSIZE];
    char CombinedNumbers_Pos_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
    char CombinedNumbers_NumberType_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH]; //help value ->"NumberType" is stored in the ASCII(UTF-8) code in the *.csv 
	char CombinedNumbers_CallMode_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];   //help value ->"CallMode" is stored in the ASCII(UTF-8) code in the *.csv 
    char CombinedNumbers_Day_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];        //help value ->"Day" is stored in the ASCII(UTF-8) code in the *.csv 
    char CombinedNumbers_Month_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];      //help value ->"Month" is stored in the ASCII(UTF-8) code in the *.csv 
    char CombinedNumbers_Year_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];       //help value ->"Year" is stored in the ASCII(UTF-8) code in the *.csv 
    char CombinedNumbers_Hour_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];       //help value ->"Hour" is stored in the ASCII(UTF-8) code in the *.csv 
    char CombinedNumbers_Minute_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];     //help value ->"Minute" is stored in the ASCII(UTF-8) code in the *.csv 
    char CombinedNumbers_Second_string [TEL_COMBINEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];     //help value ->"Second" is stored in the ASCII(UTF-8) code in the *.csv 

    if(getvalue(env_FSG_CN_DataSource) == TEL_EXTERNAL_LIST) //output data in write window "FSGCombinedNumbers"  
    {
        writeClear(gCombinedNumbers_writeWindow);
        writelineEx(gCombinedNumbers_writeWindow, 0,"*******External CombinedNumbers*******");
        writelineEx(gCombinedNumbers_writeWindow, 0, "");
        writelineEx(gCombinedNumbers_writeWindow, 0, "**********************Start load new CombinedNumbers**********************");   
    
        //clear  
	    for(j=0;j<TEL_COMBINEDNUMBERS_ENTRIES;j++) 
	    {
		gCombinedNumbers_Pos[j]                       =0;
        
        for(i=0;i<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;i++)
			gCombinedNumbers_PbName[j][i] =0;

		gCombinedNumbers_NumberType[j]                =0;		
		gCombinedNumbers_CallMode[j]                  =0;
        
        for(i=0;i<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;i++)
			gCombinedNumbers_TelNumber[j][i] =0;

        gCombinedNumbers_day[j]     =0;
        gCombinedNumbers_month[j]   =0;
        gCombinedNumbers_year[j]    =0;
        gCombinedNumbers_hour[j]    =0;
        gCombinedNumbers_minute[j]  =0;
        gCombinedNumbers_second[j]  =0;

        gCombinedNumbers_ListEntryValidInformation[j] =0;
	    }

        for(i=0;i<TEL_FILENAME_SIZE; i++) //clear "filename"
            gCombinedNumbers_CSV_filename[i] =0;       
        
        for(j=0;j<TEL_COMBINEDNUMBERS_ENTRIES; j++) //clear "buffer"
        {
            buffer_string[j]    =0;
            buffer_byte[j]      =0;

            for(i=0;i<TEL_TEXTLENGTH;i++) //clear help value
		    {
                CombinedNumbers_Pos_string[j][i]        =0;
				CombinedNumbers_NumberType_string[j][i] =0;
                CombinedNumbers_CallMode_string[j][i]   =0;
                CombinedNumbers_Day_string[j][i]        =0;
                CombinedNumbers_Month_string[j][i]      =0;
                CombinedNumbers_Year_string[j][i]       =0;
                CombinedNumbers_Hour_string[j][i]       =0;
                CombinedNumbers_Minute_string[j][i]     =0;
                CombinedNumbers_Second_string[j][i]     =0;
            }
        }        

        i =0; j =0; CombinedNumbersLine =0; current_CSV_line =0; //reset values 
                      
        getvalue(env_FSG_CN_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        
        //write("complete path *.csv: %s", Path_CSV); //debug
        
        i =0;

        while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after last "\"
            {              
                gCombinedNumbers_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
                count2++;
                               
            i++;
        }

        writelineEx(gCombinedNumbers_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 

        writelineEx(gCombinedNumbers_writeWindow, 0,"filename of *.csv: '%s'", gCombinedNumbers_CSV_filename);  //output filename 

        putvalue(env_FSG_CN_DataSource_file, gCombinedNumbers_CSV_filename); //output current loaded *.csv-file on panel

        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gCombinedNumbers_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

        if (CSVfileHandle!=0) //*.csv file access successful
        {
            writelineEx(gCombinedNumbers_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gCombinedNumbers_CSV_filename);    //output result  
            
            putvalue(env_FSG_CN_DataSource_result, "successful");   //output result on panel                      
            
            Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
                          
            for (i=0; i<Num_of_csv_byte; i++) //copy data into "CombinedNumbers"
            {      
                if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
                {
                    if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in CombinedNumbers) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                    {
                        if(current_CSV_line>0 && CombinedNumbersLine<TEL_COMBINEDNUMBERS_ENTRIES) //ignore first line in *.csv file
                        {   
                            writelineEx(gCombinedNumbers_writeWindow, 0, "");
                            writelineEx(gCombinedNumbers_writeWindow, 0,"*******Element %d*******",CombinedNumbersLine);

                            //transform 'string' to 'long' for "POS", "NumberType", "CallMode", "Day", "Month", "Year", "Hour", "Minute" and "Second"
                            gCombinedNumbers_Pos[CombinedNumbersLine]           =atol(CombinedNumbers_Pos_string[CombinedNumbersLine]);
                            gCombinedNumbers_NumberType[CombinedNumbersLine]    =atol(CombinedNumbers_NumberType_string[CombinedNumbersLine]);                      
							gCombinedNumbers_CallMode[CombinedNumbersLine]      =atol(CombinedNumbers_CallMode_string[CombinedNumbersLine]);                        
                            gCombinedNumbers_day[CombinedNumbersLine]           =atol(CombinedNumbers_Day_string[CombinedNumbersLine]);
                            gCombinedNumbers_month[CombinedNumbersLine]         =atol(CombinedNumbers_Month_string[CombinedNumbersLine]);
                            gCombinedNumbers_year[CombinedNumbersLine]          =atol(CombinedNumbers_Year_string[CombinedNumbersLine]);
                            gCombinedNumbers_hour[CombinedNumbersLine]          =atol(CombinedNumbers_Hour_string[CombinedNumbersLine]);
                            gCombinedNumbers_minute[CombinedNumbersLine]        =atol(CombinedNumbers_Minute_string[CombinedNumbersLine]);
                            gCombinedNumbers_second[CombinedNumbersLine]        =atol(CombinedNumbers_Second_string[CombinedNumbersLine]);

                           writelineEx(gCombinedNumbers_writeWindow, 0,"Pos[%d]: 0x%x",CombinedNumbersLine, gCombinedNumbers_Pos[CombinedNumbersLine]);
                            
                            writelineEx(gCombinedNumbers_writeWindow, 0,"PbName[%d]: %s",CombinedNumbersLine, gCombinedNumbers_PbName[CombinedNumbersLine]);
							                            
							writelineEx(gCombinedNumbers_writeWindow, 0,"NumberType[%d]: 0x%x",CombinedNumbersLine, gCombinedNumbers_NumberType[CombinedNumbersLine]);
                            if(gCombinedNumbers_NumberType[CombinedNumbersLine] <0x0F)
                                writeEx(gCombinedNumbers_writeWindow, 0," -> '%s'", gCombinedNumbers_NumberType_s[gCombinedNumbers_NumberType[CombinedNumbersLine]]);
                            else
                                writeEx(gCombinedNumbers_writeWindow, 0," -> '%s'", gstring_reserved);							
                            	
                            writelineEx(gCombinedNumbers_writeWindow, 0,"CallMode[%d]: 0x%x",CombinedNumbersLine, gCombinedNumbers_CallMode[CombinedNumbersLine]);
                            if(gCombinedNumbers_CallMode[CombinedNumbersLine] <0x04)
                                writeEx(gCombinedNumbers_writeWindow, 0," -> '%s'", gCombinedNumbers_CallMode_s[gCombinedNumbers_CallMode[CombinedNumbersLine]]);
                            else
                                writeEx(gCombinedNumbers_writeWindow, 0," -> '%s'", gstring_reserved);

                            writelineEx(gCombinedNumbers_writeWindow, 0,"TelNumber[%d]: %s",CombinedNumbersLine, gCombinedNumbers_TelNumber[CombinedNumbersLine]);
                            
                            writelineEx(gCombinedNumbers_writeWindow, 0,"Day[%d]: 0%d",CombinedNumbersLine, gCombinedNumbers_day[CombinedNumbersLine]);
                            
                            writelineEx(gCombinedNumbers_writeWindow, 0,"Month[%d]: 0%d",CombinedNumbersLine, gCombinedNumbers_month[CombinedNumbersLine]);

                            writelineEx(gCombinedNumbers_writeWindow, 0,"Year[%d]: 0%d",CombinedNumbersLine, gCombinedNumbers_year[CombinedNumbersLine]);

                            writelineEx(gCombinedNumbers_writeWindow, 0,"Hour[%d]: 0%d",CombinedNumbersLine, gCombinedNumbers_hour[CombinedNumbersLine]);

                            writelineEx(gCombinedNumbers_writeWindow, 0,"Minute[%d]: 0%d",CombinedNumbersLine, gCombinedNumbers_minute[CombinedNumbersLine]);

                            writelineEx(gCombinedNumbers_writeWindow, 0,"Second[%d]: 0%d",CombinedNumbersLine, gCombinedNumbers_second[CombinedNumbersLine]);

                            gCombinedNumbers_ListEntryValidInformation[CombinedNumbersLine]  =TRUE;
                                                
                            CombinedNumbersLine++; // -> next line in *.csv (next record element)
                        }

                        current_CSV_line++; //next line in *.csv file
                        element =0; //start at 'POS' (first record element of "array data")
                        j=0; //reset value
                    }
                      
                    else if(current_CSV_line>0 && CombinedNumbersLine<TEL_COMBINEDNUMBERS_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                    {
                        switch (element)
                        {
                            case 0: //POS
                                    CombinedNumbers_Pos_string[CombinedNumbersLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //PbName
                                    gCombinedNumbers_PbName[CombinedNumbersLine][j] =buffer_byte[i];
                                    j++; 
                             break;
                            
							case 2: //NumberType
                                    CombinedNumbers_NumberType_string[CombinedNumbersLine][j] =buffer_byte[i];                                                                       
                                    j++;
							break;
									
                            case 3: //CallMode
                                    CombinedNumbers_CallMode_string[CombinedNumbersLine][j] =buffer_byte[i];                                     
                                    j++;
                             break;
                            
                            case 4: //TelNumber
                                    gCombinedNumbers_TelNumber[CombinedNumbersLine][j] =buffer_byte[i];
                                    j++; 
                             break;

                            case 5: //Day
                                    CombinedNumbers_Day_string[CombinedNumbersLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 6: //Month
                                    CombinedNumbers_Month_string[CombinedNumbersLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 7: //Year
                                    CombinedNumbers_Year_string[CombinedNumbersLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;
                            
                            case 8: //Hour
                                    CombinedNumbers_Hour_string[CombinedNumbersLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 9: //Minute
                                    CombinedNumbers_Minute_string[CombinedNumbersLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 10: //Second
                                    CombinedNumbers_Second_string[CombinedNumbersLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            default:
                             break;
                        }
                    }                               
                }
                               
                else  // ";" is detected ->next record element of "array data"
                {                                          
                    element++;
                    j=0; //reset value  
                }                                              
        
            }         
            
            //IssueList #76 - MR49870 : CN
	        // - if condition           
            if (getValue(env_FSG_CN_insert_UPD_button) == 0x00)
            gCombinedNumbers_TotalNumListElements =gCombinedNumbers_sum =CombinedNumbersLine; //get "total number of list elements"
            
            putvalue(env_FSG_CN_TotalNumLE, gCombinedNumbers_TotalNumListElements);

            writelineEx(gCombinedNumbers_writeWindow, 0, "");

            writelineEx(gCombinedNumbers_writeWindow, 0,"Anzahl der Listenelemente: %d", gCombinedNumbers_sum); //output total number of list elements

            writelineEx(gCombinedNumbers_writeWindow, 0, "");

            if(fileClose (CSVfileHandle) !=0) //close *.csv file
                writelineEx(gCombinedNumbers_writeWindow, 0,"Datei '%s' geschlossen", gCombinedNumbers_CSV_filename); //output result
             
            else
                writelineEx(gCombinedNumbers_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gCombinedNumbers_CSV_filename);//output result
        
        }
    
   else //*.csv file access not successful
        {
            writelineEx(gCombinedNumbers_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gCombinedNumbers_CSV_filename); //output result
            
            putvalue(env_FSG_CN_DataSource_result,"not successful"); //output result
        }
    }
        //IssueList #76 - MR49870 : CN
         for(i =0; i<gCombinedNumbers_TotalNumListElements; i++)
		gCombinedNum_Pos_insDel[i] [0] =gCombinedNumbers_Pos[i];

        if (getValue(env_FSG_CN_insert_UPD_button) == 0x00)
        gCN_totalDELctr = 0;

}

on envVar env_FSG_CN_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
//changes for IssueList #152 - MR 53938
//TEL_COMBINEDNUMBERS_ENTRIES --> gCombinedNumbers_TotalNumListElements


    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        if(getvalue(env_FSG_CN_AH_start) >255 && getvalue(env_FSG_CN_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_FSG_CN_AH_IS,1);

        //get data from Panel
        recordaddress   =getvalue(env_FSG_CN_AH_RA);
        shift           =getvalue(env_FSG_CN_AH_shift);
        direction       =getvalue(env_FSG_CN_AH_dir);
        transmitpos     =getvalue(env_FSG_CN_AH_POS);
        indexsize       =getvalue(env_FSG_CN_AH_IS);
        startelement    =getvalue(env_FSG_CN_AH_start);
        elements        =getvalue(env_FSG_CN_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        if (getvalue(env_FSG_CN_CA_switch))   //Array+Data
        {
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
            if(FORWARD==direction)  //forward-start
			{
                valid_startelement =0;				       									

                if(gCombinedNumbers_TotalNumListElements <=elements) //1. more elements requested, than in array
				{
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<gCombinedNumbers_TotalNumListElements;i++)
						{
						    if(0 !=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =gCombinedNumbers_TotalNumListElements;
					    }
                    }
                    else if (shift ==TRUE)
                    {   
                     //IssueList #93
			          //valid_startelement  =1;
                      //startelement        =valid_startelement;
			            valid_startelement  =startelement;
				        valid_elements      =0;

                        for(i=1;i<gCombinedNumbers_TotalNumListElements;i++)
						{
						    if(0 !=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =gCombinedNumbers_TotalNumListElements;
					    }
                    }
			    }
                else    //2. number of requested elements < elements in array
				{
                    if (shift ==FALSE)
                    {
					    for(i=0;i<elements;i++)
						{
						    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						       i =gCombinedNumbers_TotalNumListElements;
					    }
                    }
                    else if (shift ==TRUE)
                    {
                     //IssueList #93
			         //valid_startelement  =1;
                     //startelement        =valid_startelement;
			          valid_startelement  =startelement;
				       valid_elements      =0;

                        for(i=1;i<=elements;i++)
						{
						    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =gCombinedNumbers_TotalNumListElements;
					    }   
                    }

				}
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			    //searching for valid startelement
				for(i=(gCombinedNumbers_TotalNumListElements-1);i>=0;i--)
				{
				    if(0!=gCombinedNumbers_ListEntryValidInformation[i])		//found valid startelement
					{
					    valid_startelement =i;								
						i =0;												
					}
				}
                        
                //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
				{
				    valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
				    valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				    for(i=valid_startelement;i>=0;i--)
					{
					    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						    i=0;
				    }
				}
                else														//enougth array-elements available
				{
				    for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
					    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
							i=0;
					}                   
				}															
	        }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else																//searching for Startelement-ID				
		{
		    //searching for valid startelement
			for(i=0;i<gCombinedNumbers_TotalNumListElements;i++)
			{
				if(gCombinedNumbers_Pos[i] ==startelement)					    //found a valid element
				{                                       
                    if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
					    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
						    valid_startelement =i+1-2*direction;
                                							
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gCombinedNumbers_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
					
                    else
                        valid_startelement =i;                              //found element is valid_startelement

					i =gCombinedNumbers_TotalNumListElements;
				}
                else
                    valid_startelement =0xff;
			}

			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			    //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
				    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
					    valid_elements=1;
							
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				    {
					    for(i=valid_startelement;i>=0;i--)
						{
						    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
                            else												//no valid element, loop finished
							    i=0;
						}
				    }
					else														//enougth array-elements available
					{
					    for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
						    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
								i=0;
						}
					}
				}																//backward-end
				else															//forward-start
				{
				    if((valid_startelement+elements)>=gCombinedNumbers_TotalNumListElements)
					{
					    for(i=valid_startelement;i<gCombinedNumbers_TotalNumListElements;i++)
						{
						    if(0!=gCombinedNumbers_Pos[i])							//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=gCombinedNumbers_TotalNumListElements;
						}
					}
					else
					{
					    for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
						    if(0!=gCombinedNumbers_Pos[i])						    //if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=gCombinedNumbers_TotalNumListElements;
						}
					}
				}
			}
		}
        //IssueList #94 - FullRangeUpdate button
          /*changes from Jan Swoboda (01.03.2012)
	        JanSwo 20111201: FRU
            if ((requested_startelement == 0) && ((elements == 0xFF) || (elements == 0xFFFF)))
            {
                CombinedNumbers_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, elements, 0);

            }
            else
            {*/
            //putvalue(env_FSG_CN_AH_elements, valid_elements);
            //send ChangedArray
             //MR 63667 11.07.2014 -TNLE with SA-button
             //CombinedNumbers_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
             CombinedNumbers_Request(Changed_REQ, 0, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
            //gInsertFunctionActive = 0x00;
            //}
    } //if env_FSG_CN_CA_switch
    
    //IssueList #93  Array Only
    else
    //MR 63667 11.07.2014 -TNLE with SA-button
    //CombinedNumbers_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    CombinedNumbers_Request(Changed_REQ, 0, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);

   } //if gFSG_Telephone_PowerOnOff
}

on envVar env_FSG_CN_StatusArray
{
    //MR 63667 11.07.2014 -TNLE with SA-button
    //word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    word tnle, requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;

//changes for IssueList #152 - MR 53938
//gCombinedNumbers_TotalNumListElements --> gCombinedNumbers_TotalNumListElements


    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        if(getvalue(env_FSG_CN_AH_start) >255 && getvalue(env_FSG_CN_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_FSG_CN_AH_IS,1);

        //get data from Panel
        gCombinedNumbers_ASGID                =getvalue(env_FSG_CN_ASGID);
        gCombinedNumbers_TAID                 =getvalue(env_FSG_CN_TAID);

        //MR 63332 #3   02.07.2014
        //gCombinedNumbers_TotalNumListElements  =getvalue(env_FSG_CN_TotalNumLE);

        //MR 63667 11.07.2014 -TNLE with SA-button
        tnle = getvalue(env_FSG_CN_TotalNumLE);

        recordaddress   =getvalue(env_FSG_CN_AH_RA);
        shift           =getvalue(env_FSG_CN_AH_shift);
        direction       =getvalue(env_FSG_CN_AH_dir);
        transmitpos     =getvalue(env_FSG_CN_AH_POS);
        indexsize       =getvalue(env_FSG_CN_AH_IS);
        startelement    =getvalue(env_FSG_CN_AH_start);
        elements        =getvalue(env_FSG_CN_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
            if(FORWARD==direction)  //forward-start
			{
                valid_startelement =0;				       									

                if(gCombinedNumbers_TotalNumListElements <=elements) //1. more elements requested, than in array
				{
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<gCombinedNumbers_TotalNumListElements;i++)
						{
						    if(0 !=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =gCombinedNumbers_TotalNumListElements;
					    }
                    }
                    else if (shift ==TRUE)
                    {   
                        valid_startelement  =1;
                        startelement        =valid_startelement;

                        for(i=1;i<gCombinedNumbers_TotalNumListElements;i++)
						{
						    if(0 !=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =gCombinedNumbers_TotalNumListElements;
					    }
                    }
			    }
                else    //2. number of requested elements < elements in array
				{
                    if (shift ==FALSE)
                    {
					    for(i=0;i<elements;i++)
						{
						    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						       i =gCombinedNumbers_TotalNumListElements;
					    }
                    }
                    else if (shift ==TRUE)
                    {
                        valid_startelement  =1;
                        startelement        =valid_startelement;

                        for(i=1;i<=elements;i++)
						{
						    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =gCombinedNumbers_TotalNumListElements;
					    }   
                    }

				}
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			    //searching for valid startelement
				for(i=(gCombinedNumbers_TotalNumListElements-1);i>=0;i--)
				{
				    if(0!=gCombinedNumbers_ListEntryValidInformation[i])		//found valid startelement
					{
					    valid_startelement =i;								
						i =0;												
					}
				}
                        
                //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
				{
				    valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
				    valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				    for(i=valid_startelement;i>=0;i--)
					{
					    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						    i=0;
				    }
				}
                else														//enougth array-elements available
				{
				    for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
					    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
							i=0;
					}                   
				}															
	        }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else																//searching for Startelement-ID				
		{
		    //searching for valid startelement
			for(i=0;i<gCombinedNumbers_TotalNumListElements;i++)
			{
				if(gCombinedNumbers_Pos[i] ==startelement)					    //found a valid element
				{                                       
                    if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
					    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
						    valid_startelement =i+1-2*direction;
                                							
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gCombinedNumbers_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
					
                    else
                        valid_startelement =i;                              //found element is valid_startelement

					i =gCombinedNumbers_TotalNumListElements;
				}
                else
                    valid_startelement =0xff;
			}

			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			    //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
				    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
					    valid_elements=1;
							
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				    {
					    for(i=valid_startelement;i>=0;i--)
						{
						    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
                            else												//no valid element, loop finished
							    i=0;
						}
				    }
					else														//enougth array-elements available
					{
					    for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
						    if(0!=gCombinedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
								i=0;
						}
					}
				}																//backward-end
				else															//forward-start
				{
				    if((valid_startelement+elements)>=gCombinedNumbers_TotalNumListElements)
					{
					    for(i=valid_startelement;i<gCombinedNumbers_TotalNumListElements;i++)
						{
						    if(0!=gCombinedNumbers_Pos[i])							//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=gCombinedNumbers_TotalNumListElements;
						}
					}
					else
					{
					    for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
						    if(0!=gCombinedNumbers_Pos[i])						    //if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=gCombinedNumbers_TotalNumListElements;
						}
					}
				}
			}
		}
        putvalue(env_FSG_CN_AH_elements, valid_elements);

        //send StatusArray
        //MR 63667 11.07.2014 -TNLE with SA-button
        //CombinedNumbers_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
	//VAGH-10511
	if(!getvalue(env_FSG_CN_StatusArrayOff))
	    CombinedNumbers_Request(Data_REQ, tnle, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);

    }
}

on envVar env_FSG_CN_DataSource
{
    if (getvalue(this) ==TEL_DEFAULT_LIST)
    {
        CombinedNumbers_init_static();
        putvalue(env_FSG_CN_DataSource_file, empty_string);
        putvalue(env_FSG_CN_DataSource_result, empty_string);
    }
}

on envVar env_FSG_CN_reload //load external ReceptionList from *.csv
{
int i;

    if(getvalue(this) && getvalue(env_FSG_CN_DataSource) ==TEL_EXTERNAL_LIST)
      {
        
         //IssueList #76 - MR49870 : Phonebook
       if (getValue(env_FSG_PB_insert_UPD_button)==0x00)
         {
             for(i =0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
             {
              gCombinedNum_Pos_insDel[i] [0] =0x00;   //POS value
              gCombinedNum_Pos_insDel[i] [1] =0x00;   //tagging of deleted elements
              }
        }

        CombinedNumbers_init_CSV();

       
        //IssueList #76 - MR49870 : Phonebook
        if (getValue(env_FSG_CN_insert_UPD_button)==0x00)
        {
          //MR 63332 #3   02.07.2014
          //gCombinedNumbers_TotalNumListElements = getValue(env_FSG_CN_TotalNumLE);
          gCN_CSVtotalElem = gCombinedNumbers_TotalNumListElements;
          //Clear insert/delete panel
           putValue(env_FSG_CN_delete_start, 0);
           putValue(env_FSG_CN_insert_start, 0);
           putValue(env_FSG_CN_insert_start, 0);
           putValue(env_FSG_CN_insert_successor, 0);
           putValue(env_FSG_Phonebook_delete_ErrHandler, 1);
           putValue(env_FSG_CN_delete_Message, empty_string);

           putValue(env_FSG_Phonebook_insert_Err, 1);
           putValue(env_FSG_CN_Insert_Message, empty_string);
        }
            //Clearing send buffer       
            for(i =0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
            gCombinedNum_Send[i][0] =0;   //POS value

       }
    else if(getvalue(env_FSG_CN_DataSource) != TEL_EXTERNAL_LIST)
        putvalue(env_FSG_CN_DataSource_result,"not successful, select 'external *.csv'");
}

byte CombinedNumbers_buildModeByte (word requested_startelement, word startelement, word elements, byte shift, byte direction, byte transmitpos, byte indexsize)
{    
    int  i;
    word CombinedNumbersLine;
    byte mode;
    
    //init variables
    indexsize           =0;
    i                   =0;
    CombinedNumbersLine =0;    
    mode                =0;
    
    if(requested_startelement >0xFE)
        indexsize =TRUE;

    else
    {  
        CombinedNumbersLine =startelement;
                
        while(i <elements)
        {   
            if(CombinedNumbersLine ==0xff) //Invalid "list entry"
                i =elements;

            else //"list entry" valid
            {   
                if(gCombinedNumbers_Pos[CombinedNumbersLine] >0xFE)
                    indexsize =TRUE;
            }
            i++;
            CombinedNumbersLine =CombinedNumbers_nextvalidLine(CombinedNumbersLine, direction);
                            
        }//end while
    }//end else
    
    //build mode byte
    mode    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

    return (mode);
}

byte FavoriteList_buildModeByte (word requested_startelement, word startelement, word elements, byte shift, byte direction, byte transmitpos, byte indexsize)
{    
    int  i;
    word FavoriteListLine;
    byte mode;
    
    //init variables
    indexsize           =0;
    i                   =0;
    FavoriteListLine =0;    
    mode                =0;
    
    if(requested_startelement >0xFE)
        indexsize =TRUE;

    else
    {  
        FavoriteListLine =startelement;
                
        while(i <elements)
        {   
            if(FavoriteListLine ==0xff) //Invalid "list entry"
                i =elements;

            else //"list entry" valid
            {   
                if(gFavoriteList_Pos[FavoriteListLine] >0xFE)
                    indexsize =TRUE;
            }
            i++;
            FavoriteListLine =CombinedNumbers_nextvalidLine(FavoriteListLine, direction);
                            
        }//end while
    }//end else
    
    //build mode byte
    mode    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

    return (mode);
}

CombinedNumbers_TakeOverData (dword Indication_array [], word Offset, word startelement, word elements, byte recordaddress, byte direction, byte transmitpos, byte indexsize)
{
    int i =0, j =0, length =0;
    word current_CombinedNumbersLine =0;

//changes for IssueList #152 - MR 53938
//TEL_COMBINEDNUMBERS_ENTRIES --> gCombinedNumbers_TotalNumListElements

    for(i=0;i<gCombinedNumbers_TotalNumListElements;i++)
    {
        if(gCombinedNumbers_Pos[i] ==startelement)
        {
            current_CombinedNumbersLine =i;
                        
            i =gCombinedNumbers_TotalNumListElements;
        }
    }

    /***copy elements***/
    for (i=0; i<elements; i++)
    {
        switch (recordaddress)
        {
            case 0: //recordaddress =0 -> complete record
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
                            Offset++;
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
            
                        Offset++;
                    }

                    //PbName
                    for(j=0; j<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;j++) //clear
                        gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =0; 
                                   
                    length =Indication_array[Offset];
                    Offset++;

                    if(length ==0) //list element cleared by ASG ('empty string')
                        gCombinedNumbers_ListEntryValidInformation[current_CombinedNumbersLine] =0;
                        
                                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =Indication_array[Offset];
                        Offset++;
                    }
                    
                    //NumberType+CallMode
                    //gCombinedNumbers_NumberType[current_CombinedNumbersLine] =Indication_array[Offset];
                    gCombinedNumbers_NumberType[current_CombinedNumbersLine]  =(Indication_array[Offset] & 0xF0)/0x10;
                    gCombinedNumbers_CallMode[current_CombinedNumbersLine]    =Indication_array[Offset] & 0x0F;
                    Offset++;

                    //CallMode
                    //gCombinedNumbers_CallMode[current_CombinedNumbersLine] =Indication_array[Offset];
                    //Offset++;

                    //TelNumber
                    for(j=0; j<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;j++) //clear
			            gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =0; 
                                    
                                         
                    length =Indication_array[Offset];
                    Offset++;
                                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =Indication_array[Offset];
                        Offset++;
                    }

                    //Day
                    gCombinedNumbers_day[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;


                    //Month
                    gCombinedNumbers_month[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
                      

                    //Year
                    gCombinedNumbers_year[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Hour
                    gCombinedNumbers_hour[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
                    

                    //Minute
                    gCombinedNumbers_minute[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Second
                    gCombinedNumbers_second[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    
            break;

            case 1: //recordaddress =1 -> PbName, CallMode
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
                            Offset++;
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
            
                        Offset++;
                    }

                    //PbName
                    for(j=0; j<TEL_COMBINEDNUMBERS_PBNAME_LENGTH;j++) //clear
			            gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =0; 
                                    
                                         
                    length =Indication_array[Offset];
                    Offset++;
                                    
                    
                    if(length ==0) //list element cleared by ASG ('empty string')
                        gCombinedNumbers_ListEntryValidInformation[current_CombinedNumbersLine]=0;
                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gCombinedNumbers_PbName[current_CombinedNumbersLine][j] =Indication_array[Offset];
                        Offset++;
                    }
                    
                    //CallMode
                    gCombinedNumbers_CallMode[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    
            break;//recordaddress =2 ends

            case 2: //recordaddress =2 -> TelNumber, Day, Month, Year, Hour, Minute, Second
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
                            Offset++;
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
            
                        Offset++;
                    }

                    //TelNumber
                    for(j=0; j<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH;j++) //clear
			            gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =0; 
                                    
                                         
                    length =Indication_array[Offset];
                    Offset++;
                                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gCombinedNumbers_TelNumber[current_CombinedNumbersLine][j] =Indication_array[Offset];
                        Offset++;
                    }

                    //Day
                    gCombinedNumbers_day[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;


                    //Month
                    gCombinedNumbers_month[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
                      

                    //Year
                    gCombinedNumbers_year[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Hour
                    gCombinedNumbers_hour[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
                    

                    //Minute
                    gCombinedNumbers_minute[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Second
                    gCombinedNumbers_second[current_CombinedNumbersLine] =Indication_array[Offset];
                    Offset++;
            break;

            case 15: //recordaddress =0xf -> Pos
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array [Offset];
                            Offset++;
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gCombinedNumbers_Pos[current_CombinedNumbersLine] =Indication_array[Offset];
            
                        Offset++;
                    }

            break; //recordaddress =0xf ends

        }// end switch recordaddress

        current_CombinedNumbersLine =CombinedNumbers_nextvalidLine (current_CombinedNumbersLine, direction);
    } //end 'for' -> copy elements
}

CombinedNumbers_CheckCache ()
{
    int i =0, j =0, k =0;


    for (i=0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
    {
        if(gCombinedNumbers_ListEntryValidInformation[i] !=1)
        {       
            for (j=i; j<TEL_COMBINEDNUMBERS_ENTRIES; j++)
            {
                if(gCombinedNumbers_ListEntryValidInformation[j])
                {                   
                    //Pos
                    gCombinedNumbers_Pos[i] =0; //clear new position
                    gCombinedNumbers_Pos[i] =i; // -> new Pos for consecutive ID
                    
                    //PbName
                    for(k=0; k<TEL_COMBINEDNUMBERS_PBNAME_LENGTH; k++) //clear new position
                        gCombinedNumbers_PbName[i][k]=0; 
                    
                    for(k=0; k<strlen(gCombinedNumbers_PbName[j]); k++)
                        gCombinedNumbers_PbName[i][k]=gCombinedNumbers_PbName[j][k];

                    for(k=0; k<TEL_COMBINEDNUMBERS_PBNAME_LENGTH; k++) //clear old position
                        gCombinedNumbers_PbName[j][k]=0; 
					
					//NumberType
                    gCombinedNumbers_NumberType[i] =0; //clear new position
                    gCombinedNumbers_NumberType[i] =gCombinedNumbers_NumberType[j];
                    gCombinedNumbers_NumberType[j] =0; //clear old position
					
                    //CallMode
                    gCombinedNumbers_CallMode[i] =0; //clear new position
                    gCombinedNumbers_CallMode[i] =gCombinedNumbers_CallMode[j];
                    gCombinedNumbers_CallMode[j] =0; //clear old position
                    
                    //TelNumber
                    for(k=0; k<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH; k++) //clear new position
                        gCombinedNumbers_TelNumber[i][k]=0; 
                    
                    for(k=0; k<strlen(gCombinedNumbers_TelNumber[j]); k++)
                        gCombinedNumbers_TelNumber[i][k]=gCombinedNumbers_TelNumber[j][k];

                    for(k=0; k<TEL_COMBINEDNUMBERS_TELNUMBER_LENGTH; k++) //clear old position
                        gCombinedNumbers_TelNumber[j][k]=0; 
                    
                    //Day
                    gCombinedNumbers_day[i] =0; //clear new position
                    gCombinedNumbers_day[i] =gCombinedNumbers_day[j];
                    gCombinedNumbers_day[j] =0; //clear old position

                    //Month
                    gCombinedNumbers_month[i] =0; //clear new position
                    gCombinedNumbers_month[i] =gCombinedNumbers_month[j];
                    gCombinedNumbers_month[j] =0; //clear old position

                    //Year
                    gCombinedNumbers_year[i] =0; //clear new position
                    gCombinedNumbers_year[i] =gCombinedNumbers_year[j];
                    gCombinedNumbers_year[j] =0; //clear old position

                    //Hour
                    gCombinedNumbers_hour[i] =0; //clear new position
                    gCombinedNumbers_hour[i] =gCombinedNumbers_hour[j];
                    gCombinedNumbers_hour[j] =0; //clear old position

                    //Minute
                    gCombinedNumbers_minute[i] =0; //clear new position
                    gCombinedNumbers_minute[i] =gCombinedNumbers_minute[j];
                    gCombinedNumbers_minute[j] =0; //clear old position

                    //Second
                    gCombinedNumbers_second[i] =0; //clear new position
                    gCombinedNumbers_second[i] =gCombinedNumbers_second[j];
                    gCombinedNumbers_second[j] =0; //clear old position

                    gCombinedNumbers_ListEntryValidInformation[i] =0; //clear new position
                    gCombinedNumbers_ListEntryValidInformation[i] =gCombinedNumbers_ListEntryValidInformation[j];
                    gCombinedNumbers_ListEntryValidInformation[j] =0; //clear old position


                    j=TEL_COMBINEDNUMBERS_ENTRIES;
                }
            }
        }    
    }
    
    gCombinedNumbers_sum =0;

    for (i=0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
    {
        if(gCombinedNumbers_ListEntryValidInformation[i])
            gCombinedNumbers_sum++;
        else
            i=TEL_COMBINEDNUMBERS_ENTRIES;
    }
    
    gCombinedNumbers_TotalNumListElements =gCombinedNumbers_sum;
    putvalue(env_FSG_CN_TotalNumLE,gCombinedNumbers_TotalNumListElements);   
}

ReceivedCalls_init_static()
{
    word j, i, ReceivedCallsLine;

    //clear
    ReceivedCallsLine =0;
    gReceivedCalls_sum  =0;

	for(j=0;j<TEL_RECEIVEDCALLS_ENTRIES;j++) 
	{
		gReceivedCalls_Pos[j]                       =0;
        
        for(i=0;i<TEL_RECEIVEDCALLS_PBNAME_LENGTH;i++)
			gReceivedCalls_PbName[j][i] =0;

        gReceivedCalls_NumberType[j]                =0;
        
        for(i=0;i<TEL_RECEIVEDCALLS_TELNUMBER_LENGTH;i++)
			gReceivedCalls_TelNumber[j][i] =0;

        gReceivedCalls_day[j]     =0;
        gReceivedCalls_month[j]   =0;
        gReceivedCalls_year[j]    =0;
        gReceivedCalls_hour[j]    =0;
        gReceivedCalls_minute[j]  =0;
        gReceivedCalls_second[j]  =0;

        gReceivedCalls_ListEntryValidInformation[j] =0;
	}
	  	
    //entry 0
	gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x00;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_0",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_UNKNOWN;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_0",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =1;  
    gReceivedCalls_month [ReceivedCallsLine]    =2; 
    gReceivedCalls_year [ReceivedCallsLine]     =50; 
    gReceivedCalls_hour [ReceivedCallsLine]     =21; 
    gReceivedCalls_minute [ReceivedCallsLine]   =4; 
    gReceivedCalls_second [ReceivedCallsLine]   =9;                         
    
    ReceivedCallsLine++;

    //entry 1
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x01;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_1",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_GENERAL;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_1",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =0xFF;  
    gReceivedCalls_month [ReceivedCallsLine]    =0xFF; 
    gReceivedCalls_year [ReceivedCallsLine]     =0xFF; 
    gReceivedCalls_hour [ReceivedCallsLine]     =0xFF; 
    gReceivedCalls_minute [ReceivedCallsLine]   =0xFF; 
    gReceivedCalls_second [ReceivedCallsLine]   =0xFF;                         
    
    ReceivedCallsLine++;

    //entry 2
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x02;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_2",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_MOBILE;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_2",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =5;  
    gReceivedCalls_month [ReceivedCallsLine]    =4; 
    gReceivedCalls_year [ReceivedCallsLine]     =2; 
    gReceivedCalls_hour [ReceivedCallsLine]     =9; 
    gReceivedCalls_minute [ReceivedCallsLine]   =34; 
    gReceivedCalls_second [ReceivedCallsLine]   =54;                         
    
    ReceivedCallsLine++;

    //entry 3
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x03;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_3",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_OFFICE;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_3",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =30;  
    gReceivedCalls_month [ReceivedCallsLine]    =5; 
    gReceivedCalls_year [ReceivedCallsLine]     =84; 
    gReceivedCalls_hour [ReceivedCallsLine]     =5; 
    gReceivedCalls_minute [ReceivedCallsLine]   =0; 
    gReceivedCalls_second [ReceivedCallsLine]   =0;                         
    
    ReceivedCallsLine++;

    //entry 4
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x04;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_4",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_HOME;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_4",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =31;  
    gReceivedCalls_month [ReceivedCallsLine]    =7; 
    gReceivedCalls_year [ReceivedCallsLine]     =83; 
    gReceivedCalls_hour [ReceivedCallsLine]     =10; 
    gReceivedCalls_minute [ReceivedCallsLine]   =15; 
    gReceivedCalls_second [ReceivedCallsLine]   =1;                         
    
    ReceivedCallsLine++;

    //entry 5
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x05;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_5",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_FAX;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_5",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =9;  
    gReceivedCalls_month [ReceivedCallsLine]    =11; 
    gReceivedCalls_year [ReceivedCallsLine]     =4; 
    gReceivedCalls_hour [ReceivedCallsLine]     =8; 
    gReceivedCalls_minute [ReceivedCallsLine]   =7; 
    gReceivedCalls_second [ReceivedCallsLine]   =33;                         
    
    ReceivedCallsLine++;

    //entry 6
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x06;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_6",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_PAGER;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_6",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =6;  
    gReceivedCalls_month [ReceivedCallsLine]    =5; 
    gReceivedCalls_year [ReceivedCallsLine]     =30; 
    gReceivedCalls_hour [ReceivedCallsLine]     =18; 
    gReceivedCalls_minute [ReceivedCallsLine]   =14; 
    gReceivedCalls_second [ReceivedCallsLine]   =45;                         
    
    ReceivedCallsLine++;

    //entry 7
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x07;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_7",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_CAR;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_7",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =21;  
    gReceivedCalls_month [ReceivedCallsLine]    =1; 
    gReceivedCalls_year [ReceivedCallsLine]     =31; 
    gReceivedCalls_hour [ReceivedCallsLine]     =23; 
    gReceivedCalls_minute [ReceivedCallsLine]   =29; 
    gReceivedCalls_second [ReceivedCallsLine]   =30;                         
    
    ReceivedCallsLine++;

    //entry 8
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x08;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_8",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_SIM;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_8",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =16;  
    gReceivedCalls_month [ReceivedCallsLine]    =2; 
    gReceivedCalls_year [ReceivedCallsLine]     =8; 
    gReceivedCalls_hour [ReceivedCallsLine]     =15; 
    gReceivedCalls_minute [ReceivedCallsLine]   =59; 
    gReceivedCalls_second [ReceivedCallsLine]   =59;                         
    
    ReceivedCallsLine++;

    //entry 9
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x09;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_9",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_MAINOFFICE;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_9",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =31;  
    gReceivedCalls_month [ReceivedCallsLine]    =12; 
    gReceivedCalls_year [ReceivedCallsLine]     =99; 
    gReceivedCalls_hour [ReceivedCallsLine]     =23; 
    gReceivedCalls_minute [ReceivedCallsLine]   =59; 
    gReceivedCalls_second [ReceivedCallsLine]   =59;                         
    
    ReceivedCallsLine++;

    //entry 10
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x0A;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_10",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_MAINHOME;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_10",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =1;  
    gReceivedCalls_month [ReceivedCallsLine]    =1; 
    gReceivedCalls_year [ReceivedCallsLine]     =0xFF; 
    gReceivedCalls_hour [ReceivedCallsLine]     =0; 
    gReceivedCalls_minute [ReceivedCallsLine]   =0; 
    gReceivedCalls_second [ReceivedCallsLine]   =0;                         
    
    ReceivedCallsLine++;

    //entry 11
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x0B;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_11",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_MAINHOME;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_11",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =11;  
    gReceivedCalls_month [ReceivedCallsLine]    =11; 
    gReceivedCalls_year [ReceivedCallsLine]     =11; 
    gReceivedCalls_hour [ReceivedCallsLine]     =11; 
    gReceivedCalls_minute [ReceivedCallsLine]   =11; 
    gReceivedCalls_second [ReceivedCallsLine]   =11;                         
    
    ReceivedCallsLine++;

    //entry 12
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x0C;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_12",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_CELLOFFICE;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_12",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =1;  
    gReceivedCalls_month [ReceivedCallsLine]    =1; 
    gReceivedCalls_year [ReceivedCallsLine]     =0; 
    gReceivedCalls_hour [ReceivedCallsLine]     =0; 
    gReceivedCalls_minute [ReceivedCallsLine]   =0; 
    gReceivedCalls_second [ReceivedCallsLine]   =0;                         
    
    ReceivedCallsLine++;

    //entry 13
    gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]     =TRUE;
    gReceivedCalls_Pos [ReceivedCallsLine]                          =0x0D;
    strncpy(gReceivedCalls_PbName [ReceivedCallsLine], "PbName_13",TEL_RECEIVEDCALLS_PBNAME_LENGTH);

    gReceivedCalls_NumberType [ReceivedCallsLine]                     =TEL_RECEIVEDCALLS_FAXHOME;
    
    strncpy(gReceivedCalls_TelNumber [ReceivedCallsLine], "TelNumber_13",TEL_RECEIVEDCALLS_TELNUMBER_LENGTH);
    
    gReceivedCalls_day [ReceivedCallsLine]      =31;  
    gReceivedCalls_month [ReceivedCallsLine]    =2; 
    gReceivedCalls_year [ReceivedCallsLine]     =20; 
    gReceivedCalls_hour [ReceivedCallsLine]     =8; 
    gReceivedCalls_minute [ReceivedCallsLine]   =9; 
    gReceivedCalls_second [ReceivedCallsLine]   =10;                         
    
    ReceivedCallsLine++; 
    
    gReceivedCalls_sum                    =ReceivedCallsLine;
    gReceivedCalls_TotalNumListElements   =gReceivedCalls_sum;

/*
    //write Array in "write-window"
    writeClear(gReceivedCalls_writeWindow);
    writelineEx(gReceivedCalls_writeWindow, 0, "");
    writelineEx(gReceivedCalls_writeWindow, 0,"*******Default ReceivedCalls_Array*******");
    writelineEx(gReceivedCalls_writeWindow, 0, "");
    
    for (i=0;i<gReceivedCalls_sum;i++)
    {
        writelineEx(gReceivedCalls_writeWindow, 0,"*******Element %d*******",i);
        
        writelineEx(gReceivedCalls_writeWindow, 0,"Pos[%d]: 0x%x", i, gReceivedCalls_Pos [i]);
                     
        writelineEx(gReceivedCalls_writeWindow, 0,"PbName[%d]: '%s'", i, gReceivedCalls_PbName[i]);

        writelineEx(gReceivedCalls_writeWindow, 0,"NumberType[%d]: 0x%x",i, gReceivedCalls_NumberType[i]);
        if(gReceivedCalls_NumberType[i] <0x0F)
             writeEx(gReceivedCalls_writeWindow, 0," -> '%s'", gReceivedCalls_NumberType_s[gReceivedCalls_NumberType[i]]);
        else
             writeEx(gReceivedCalls_writeWindow, 0," -> '%s'", gstring_reserved);
        
        writelineEx(gReceivedCalls_writeWindow, 0,"TelNumber[%d]: '%s'", i, gReceivedCalls_TelNumber[i]);

        writelineEx(gReceivedCalls_writeWindow, 0,"Day[%d]: %d",i, gReceivedCalls_day[i]);

        writelineEx(gReceivedCalls_writeWindow, 0,"Month[%d]: %d",i, gReceivedCalls_month[i]);

        writelineEx(gReceivedCalls_writeWindow, 0,"Year[%d]: %d",i, gReceivedCalls_year[i]);

        writelineEx(gReceivedCalls_writeWindow, 0,"Hour[%d]: %d",i, gReceivedCalls_hour[i]);

        writelineEx(gReceivedCalls_writeWindow, 0,"Minute[%d]: %d",i, gReceivedCalls_minute[i]);

        writelineEx(gReceivedCalls_writeWindow, 0,"Second[%d]: %d",i, gReceivedCalls_second[i]);

        writelineEx(gReceivedCalls_writeWindow, 0, "");
    }

    writelineEx(gReceivedCalls_writeWindow, 0,"Anzahl der Listenelemente: %d", gReceivedCalls_sum);
*/    
    putvalue(env_FSG_RC_TotalNumLE, gReceivedCalls_TotalNumListElements);
}

on envVar env_FSG_RC_reload //load external ReceptionList from *.csv
{
    if(getvalue(this) && getvalue(env_FSG_RC_DataSource) ==TEL_EXTERNAL_LIST)
	    ReceivedCalls_init_CSV();

    else if(getvalue(env_FSG_RC_DataSource) != TEL_EXTERNAL_LIST)
        putvalue(env_FSG_RC_DataSource_result,"not successful, select 'external *.csv'");
}

on envVar env_FSG_RC_DataSource
{
    if (getvalue(this) ==TEL_DEFAULT_LIST)
    {
        ReceivedCalls_init_static();
        putvalue(env_FSG_RC_DataSource_file, empty_string);
        putvalue(env_FSG_RC_DataSource_result, empty_string);
    }
}

on envVar env_FSG_RC_StatusArray
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        if(getvalue(env_FSG_RC_AH_start) >255 && getvalue(env_FSG_RC_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_FSG_RC_AH_IS,1);

        //get data from Panel
        gReceivedCalls_ASGID                =getvalue(env_FSG_RC_ASGID);
        gReceivedCalls_TAID                 =getvalue(env_FSG_RC_TAID);

        gReceivedCalls_TotalNumListElements  =getvalue(env_FSG_RC_TotalNumLE);

        recordaddress   =getvalue(env_FSG_RC_AH_RA);
        shift           =getvalue(env_FSG_RC_AH_shift);
        direction       =getvalue(env_FSG_RC_AH_dir);
        transmitpos     =getvalue(env_FSG_RC_AH_POS);
        indexsize       =getvalue(env_FSG_RC_AH_IS);
        startelement    =getvalue(env_FSG_RC_AH_start);
        elements        =getvalue(env_FSG_RC_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
            if(FORWARD==direction)  //forward-start
			{
                valid_startelement =0;				       									

                if(TEL_RECEIVEDCALLS_ENTRIES <=elements) //1. more elements requested, than in array
				{
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
						{
						    if(0 !=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_RECEIVEDCALLS_ENTRIES;
					    }
                    }
                    else if (shift ==TRUE)
                    {   
                        valid_startelement  =1;
                        startelement        =valid_startelement;

                        for(i=1;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
						{
						    if(0 !=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_RECEIVEDCALLS_ENTRIES;
					    }
                    }
			    }
                else    //2. number of requested elements < elements in array
				{
                    if (shift ==FALSE)
                    {
					    for(i=0;i<elements;i++)
						{
						    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						       i =TEL_RECEIVEDCALLS_ENTRIES;
					    }
                    }
                    else if (shift ==TRUE)
                    {
                        valid_startelement  =1;
                        startelement        =valid_startelement;

                        for(i=1;i<=elements;i++)
						{
						    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_RECEIVEDCALLS_ENTRIES;
					    }   
                    }

				}
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			    //searching for valid startelement
				for(i=(TEL_RECEIVEDCALLS_ENTRIES-1);i>=0;i--)
				{
				    if(0!=gReceivedCalls_ListEntryValidInformation[i])		//found valid startelement
					{
					    valid_startelement =i;								
						i =0;												
					}
				}
                        
                //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
				{
				    valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
				    valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				    for(i=valid_startelement;i>=0;i--)
					{
					    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						    i=0;
				    }
				}
                else														//enougth array-elements available
				{
				    for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
					    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
							i=0;
					}                   
				}															
	        }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else																//searching for Startelement-ID				
		{
		    //searching for valid startelement
			for(i=0;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
			{
				if(gReceivedCalls_Pos[i] ==startelement)					    //found a valid element
				{                                       
                    if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
					    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
						    valid_startelement =i+1-2*direction;
                                							
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gReceivedCalls_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
					
                    else
                        valid_startelement =i;                              //found element is valid_startelement

					i =TEL_RECEIVEDCALLS_ENTRIES;
				}
                else
                    valid_startelement =0xff;
			}

			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			    //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
				    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
					    valid_elements=1;
							
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				    {
					    for(i=valid_startelement;i>=0;i--)
						{
						    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
                            else												//no valid element, loop finished
							    i=0;
						}
				    }
					else														//enougth array-elements available
					{
					    for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
						    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
								i=0;
						}
					}
				}																//backward-end
				else															//forward-start
				{
				    if((valid_startelement+elements)>=TEL_RECEIVEDCALLS_ENTRIES)
					{
					    for(i=valid_startelement;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
						{
						    if(0!=gReceivedCalls_Pos[i])							//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=TEL_RECEIVEDCALLS_ENTRIES;
						}
					}
					else
					{
					    for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
						    if(0!=gReceivedCalls_Pos[i])						    //if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=TEL_RECEIVEDCALLS_ENTRIES;
						}
					}
				}
			}
		}
        putvalue(env_FSG_RC_AH_elements, valid_elements);

        //send StatusArray
        ReceivedCalls_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

on envVar env_FSG_RC_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        if(getvalue(env_FSG_RC_AH_start) >255 && getvalue(env_FSG_RC_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_FSG_RC_AH_IS,1);

        //get data from Panel
        recordaddress   =getvalue(env_FSG_RC_AH_RA);
        shift           =getvalue(env_FSG_RC_AH_shift);
        direction       =getvalue(env_FSG_RC_AH_dir);
        transmitpos     =getvalue(env_FSG_RC_AH_POS);
        indexsize       =getvalue(env_FSG_RC_AH_IS);
        startelement    =getvalue(env_FSG_RC_AH_start);
        elements        =getvalue(env_FSG_RC_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
            if(FORWARD==direction)  //forward-start
			{
                valid_startelement =0;				       									

                if(TEL_RECEIVEDCALLS_ENTRIES <=elements) //1. more elements requested, than in array
				{
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
						{
						    if(0 !=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_RECEIVEDCALLS_ENTRIES;
					    }
                    }
                    else if (shift ==TRUE)
                    {   
                        valid_startelement  =1;
                        startelement        =valid_startelement;

                        for(i=1;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
						{
						    if(0 !=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_RECEIVEDCALLS_ENTRIES;
					    }
                    }
			    }
                else    //2. number of requested elements < elements in array
				{
                    if (shift ==FALSE)
                    {
					    for(i=0;i<elements;i++)
						{
						    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						       i =TEL_RECEIVEDCALLS_ENTRIES;
					    }
                    }
                    else if (shift ==TRUE)
                    {
                        valid_startelement  =1;
                        startelement        =valid_startelement;

                        for(i=1;i<=elements;i++)
						{
						    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_RECEIVEDCALLS_ENTRIES;
					    }   
                    }

				}
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			    //searching for valid startelement
				for(i=(TEL_RECEIVEDCALLS_ENTRIES-1);i>=0;i--)
				{
				    if(0!=gReceivedCalls_ListEntryValidInformation[i])		//found valid startelement
					{
					    valid_startelement =i;								
						i =0;												
					}
				}
                        
                //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
				{
				    valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
				    valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				    for(i=valid_startelement;i>=0;i--)
					{
					    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						    i=0;
				    }
				}
                else														//enougth array-elements available
				{
				    for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
					    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
							i=0;
					}                   
				}															
	        }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else																//searching for Startelement-ID				
		{
		    //searching for valid startelement
			for(i=0;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
			{
				if(gReceivedCalls_Pos[i] ==startelement)					    //found a valid element
				{                                       
                    if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
					    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
						    valid_startelement =i+1-2*direction;
                                							
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gReceivedCalls_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
					
                    else
                        valid_startelement =i;                              //found element is valid_startelement

					i =TEL_RECEIVEDCALLS_ENTRIES;
				}
                else
                    valid_startelement =0xff;
			}

			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			    //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
				    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
					    valid_elements=1;
							
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				    {
					    for(i=valid_startelement;i>=0;i--)
						{
						    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
                            else												//no valid element, loop finished
							    i=0;
						}
				    }
					else														//enougth array-elements available
					{
					    for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
						    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
								i=0;
						}
					}
				}																//backward-end
				else															//forward-start
				{
				    if((valid_startelement+elements)>=TEL_RECEIVEDCALLS_ENTRIES)
					{
					    for(i=valid_startelement;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
						{
						    if(0!=gReceivedCalls_Pos[i])							//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=TEL_RECEIVEDCALLS_ENTRIES;
						}
					}
					else
					{
					    for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
						    if(0!=gReceivedCalls_Pos[i])						    //if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=TEL_RECEIVEDCALLS_ENTRIES;
						}
					}
				}
			}
		}
        putvalue(env_FSG_RC_AH_elements, valid_elements);

        //send ChangedArray
        ReceivedCalls_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

ReceivedCalls_init_CSV () //Byte & file selection
{
    dword CSVfileHandle =0, ConfigFileHandle =0, i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
    char buffer_string[TEL_BUFFERSIZE], Path_CSV[TEL_BUFFERSIZE], Path_Config[TEL_BUFFERSIZE];
    byte buffer_byte[TEL_BUFFERSIZE];
    word ReceivedCallsLine =0;
    char ReceivedCalls_Pos_string [TEL_RECEIVEDCALLS_ENTRIES][TEL_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
    char ReceivedCalls_NumberType_string [TEL_RECEIVEDCALLS_ENTRIES][TEL_TEXTLENGTH];   //help value ->"NumberType" is stored in the ASCII(UTF-8) code in the *.csv 
    char ReceivedCalls_Day_string [TEL_RECEIVEDCALLS_ENTRIES][TEL_TEXTLENGTH];        //help value ->"Day" is stored in the ASCII(UTF-8) code in the *.csv 
    char ReceivedCalls_Month_string [TEL_RECEIVEDCALLS_ENTRIES][TEL_TEXTLENGTH];      //help value ->"Month" is stored in the ASCII(UTF-8) code in the *.csv 
    char ReceivedCalls_Year_string [TEL_RECEIVEDCALLS_ENTRIES][TEL_TEXTLENGTH];       //help value ->"Year" is stored in the ASCII(UTF-8) code in the *.csv 
    char ReceivedCalls_Hour_string [TEL_RECEIVEDCALLS_ENTRIES][TEL_TEXTLENGTH];       //help value ->"Hour" is stored in the ASCII(UTF-8) code in the *.csv 
    char ReceivedCalls_Minute_string [TEL_RECEIVEDCALLS_ENTRIES][TEL_TEXTLENGTH];     //help value ->"Minute" is stored in the ASCII(UTF-8) code in the *.csv 
    char ReceivedCalls_Second_string [TEL_RECEIVEDCALLS_ENTRIES][TEL_TEXTLENGTH];     //help value ->"Second" is stored in the ASCII(UTF-8) code in the *.csv 

    if(getvalue(env_FSG_RC_DataSource) == TEL_EXTERNAL_LIST) //output data in write window "FSgReceivedCalls"  
    {
        writeClear(gReceivedCalls_writeWindow);
        writelineEx(gReceivedCalls_writeWindow, 0,"*******External ReceivedCalls*******");
        writelineEx(gReceivedCalls_writeWindow, 0, "");
        writelineEx(gReceivedCalls_writeWindow, 0, "**********************Start load new ReceivedCalls**********************");   
    
        //clear  
	    for(j=0;j<TEL_RECEIVEDCALLS_ENTRIES;j++) 
	    {
		gReceivedCalls_Pos[j]                       =0;
        
        for(i=0;i<TEL_RECEIVEDCALLS_PBNAME_LENGTH;i++)
			gReceivedCalls_PbName[j][i] =0;

        gReceivedCalls_NumberType[j]                  =0;
        
        for(i=0;i<TEL_RECEIVEDCALLS_TELNUMBER_LENGTH;i++)
			gReceivedCalls_TelNumber[j][i] =0;

        gReceivedCalls_day[j]     =0;
        gReceivedCalls_month[j]   =0;
        gReceivedCalls_year[j]    =0;
        gReceivedCalls_hour[j]    =0;
        gReceivedCalls_minute[j]  =0;
        gReceivedCalls_second[j]  =0;

        gReceivedCalls_ListEntryValidInformation[j] =0;
	    }

        for(i=0;i<TEL_FILENAME_SIZE; i++) //clear "filename"
            gReceivedCalls_CSV_filename[i] =0;       
        
        for(j=0;j<TEL_RECEIVEDCALLS_ENTRIES; j++) //clear "buffer"
        {
            buffer_string[j]    =0;
            buffer_byte[j]      =0;

            for(i=0;i<TEL_TEXTLENGTH;i++) //clear help value
		    {
                ReceivedCalls_Pos_string[j][i]        =0;
                ReceivedCalls_NumberType_string[j][i]   =0;
                ReceivedCalls_Day_string[j][i]        =0;
                ReceivedCalls_Month_string[j][i]      =0;
                ReceivedCalls_Year_string[j][i]       =0;
                ReceivedCalls_Hour_string[j][i]       =0;
                ReceivedCalls_Minute_string[j][i]     =0;
                ReceivedCalls_Second_string[j][i]     =0;
            }
        }        

        i =0; j =0; ReceivedCallsLine =0; current_CSV_line =0; //reset values 
                      
        getvalue(env_FSG_RC_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        
        //write("complete path *.csv: %s", Path_CSV); //debug
        
        i =0;

        while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after last "\"
            {              
                gReceivedCalls_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
                count2++;
                               
            i++;
        }

        writelineEx(gReceivedCalls_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 

        writelineEx(gReceivedCalls_writeWindow, 0,"filename of *.csv: '%s'", gReceivedCalls_CSV_filename);  //output filename 

        putvalue(env_FSG_RC_DataSource_file, gReceivedCalls_CSV_filename); //output current loaded *.csv-file on panel

        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gReceivedCalls_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

        if (CSVfileHandle!=0) //*.csv file access successful
        {
            writelineEx(gReceivedCalls_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gReceivedCalls_CSV_filename);    //output result  
            
            putvalue(env_FSG_RC_DataSource_result, "successful");   //output result on panel                      
            
            Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
                          
            for (i=0; i<Num_of_csv_byte; i++) //copy data into "ReceivedCalls"
            {      
                if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
                {
                    if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in ReceivedCalls) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                    {
                        if(current_CSV_line>0 && ReceivedCallsLine<TEL_RECEIVEDCALLS_ENTRIES) //ignore first line in *.csv file
                        {   
                            writelineEx(gReceivedCalls_writeWindow, 0, "");
                            writelineEx(gReceivedCalls_writeWindow, 0,"*******Element %d*******",ReceivedCallsLine);

                            //transform 'string' to 'long' for "POS", "NumberType", "Day", "Month", "Year", "Hour", "Minute" and "Second"
                            gReceivedCalls_Pos[ReceivedCallsLine]           =atol(ReceivedCalls_Pos_string[ReceivedCallsLine]);
                            gReceivedCalls_NumberType[ReceivedCallsLine]      =atol(ReceivedCalls_NumberType_string[ReceivedCallsLine]);                        
                            gReceivedCalls_day[ReceivedCallsLine]           =atol(ReceivedCalls_Day_string[ReceivedCallsLine]);
                            gReceivedCalls_month[ReceivedCallsLine]         =atol(ReceivedCalls_Month_string[ReceivedCallsLine]);
                            gReceivedCalls_year[ReceivedCallsLine]          =atol(ReceivedCalls_Year_string[ReceivedCallsLine]);
                            gReceivedCalls_hour[ReceivedCallsLine]          =atol(ReceivedCalls_Hour_string[ReceivedCallsLine]);
                            gReceivedCalls_minute[ReceivedCallsLine]        =atol(ReceivedCalls_Minute_string[ReceivedCallsLine]);
                            gReceivedCalls_second[ReceivedCallsLine]        =atol(ReceivedCalls_Second_string[ReceivedCallsLine]);

                            writelineEx(gReceivedCalls_writeWindow, 0,"Pos[%d]: 0x%x",ReceivedCallsLine, gReceivedCalls_Pos[ReceivedCallsLine]);
                            
                            writelineEx(gReceivedCalls_writeWindow, 0,"PbName[%d]: %s",ReceivedCallsLine, gReceivedCalls_PbName[ReceivedCallsLine]);

                            writelineEx(gReceivedCalls_writeWindow, 0,"NumberType[%d]: 0x%x",ReceivedCallsLine, gReceivedCalls_NumberType[ReceivedCallsLine]);
                            if(gReceivedCalls_NumberType[ReceivedCallsLine] <0x04)
                                writeEx(gReceivedCalls_writeWindow, 0," -> '%s'", gReceivedCalls_NumberType_s[gReceivedCalls_NumberType[ReceivedCallsLine]]);
                            else
                                writeEx(gReceivedCalls_writeWindow, 0," -> '%s'", gstring_reserved);

                            writelineEx(gReceivedCalls_writeWindow, 0,"TelNumber[%d]: %s",ReceivedCallsLine, gReceivedCalls_TelNumber[ReceivedCallsLine]);
                            
                            writelineEx(gReceivedCalls_writeWindow, 0,"Day[%d]: 0%d",ReceivedCallsLine, gReceivedCalls_day[ReceivedCallsLine]);
                            
                            writelineEx(gReceivedCalls_writeWindow, 0,"Month[%d]: 0%d",ReceivedCallsLine, gReceivedCalls_month[ReceivedCallsLine]);

                            writelineEx(gReceivedCalls_writeWindow, 0,"Year[%d]: 0%d",ReceivedCallsLine, gReceivedCalls_year[ReceivedCallsLine]);

                            writelineEx(gReceivedCalls_writeWindow, 0,"Hour[%d]: 0%d",ReceivedCallsLine, gReceivedCalls_hour[ReceivedCallsLine]);

                            writelineEx(gReceivedCalls_writeWindow, 0,"Minute[%d]: 0%d",ReceivedCallsLine, gReceivedCalls_minute[ReceivedCallsLine]);

                            writelineEx(gReceivedCalls_writeWindow, 0,"Second[%d]: 0%d",ReceivedCallsLine, gReceivedCalls_second[ReceivedCallsLine]);

                            gReceivedCalls_ListEntryValidInformation[ReceivedCallsLine]  =TRUE;
                                                
                            ReceivedCallsLine++; // -> next line in *.csv (next record element)
                        }

                        current_CSV_line++; //next line in *.csv file
                        element =0; //start at 'POS' (first record element of "array data")
                        j=0; //reset value
                    }
                      
                    else if(current_CSV_line>0 && ReceivedCallsLine<TEL_RECEIVEDCALLS_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                    {
                        switch (element)
                        {
                            case 0: //POS
                                    ReceivedCalls_Pos_string[ReceivedCallsLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //PbName
                                    gReceivedCalls_PbName[ReceivedCallsLine][j] =buffer_byte[i];
                                    j++; 
                             break;
                            
                            case 2: //NumberType
                                    ReceivedCalls_NumberType_string[ReceivedCallsLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;
                            
                            case 3: //TelNumber
                                    gReceivedCalls_TelNumber[ReceivedCallsLine][j] =buffer_byte[i];
                                    j++; 
                             break;

                            case 4: //Day
                                    ReceivedCalls_Day_string[ReceivedCallsLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 5: //Month
                                    ReceivedCalls_Month_string[ReceivedCallsLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 6: //Year
                                    ReceivedCalls_Year_string[ReceivedCallsLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;
                            
                            case 7: //Hour
                                    ReceivedCalls_Hour_string[ReceivedCallsLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 8: //Minute
                                    ReceivedCalls_Minute_string[ReceivedCallsLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 9: //Second
                                    ReceivedCalls_Second_string[ReceivedCallsLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            default:
                             break;
                        }
                    }                               
                }
                               
                else  // ";" is detected ->next record element of "array data"
                {                                          
                    element++;
                    j=0; //reset value  
                }                                              
        
            }         
            
            gReceivedCalls_TotalNumListElements =gReceivedCalls_sum =ReceivedCallsLine; //get "total number of list elements"
            
            putvalue(env_FSG_RC_TotalNumLE, gReceivedCalls_TotalNumListElements);

            writelineEx(gReceivedCalls_writeWindow, 0, "");

            writelineEx(gReceivedCalls_writeWindow, 0,"Anzahl der Listenelemente: %d", gReceivedCalls_sum); //output total number of list elements

            writelineEx(gReceivedCalls_writeWindow, 0, "");

            if(fileClose (CSVfileHandle) !=0) //close *.csv file
                writelineEx(gReceivedCalls_writeWindow, 0,"Datei '%s' geschlossen", gReceivedCalls_CSV_filename); //output result
             
            else
                writelineEx(gReceivedCalls_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gReceivedCalls_CSV_filename);//output result
        }

        else //*.csv file access not successful
        {
            writelineEx(gReceivedCalls_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gReceivedCalls_CSV_filename); //output result
            
            putvalue(env_FSG_RC_DataSource_result,"not successful"); //output result
        }
    }
}

ReceivedCalls_Indication (dword Indication_array [])
{
    byte mode, shift, direction, recordaddress, indexsize, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements, valid_elements, Offset;
    int i=0;
    
    // Init local variables. 
    mode                    =0;
    direction               =0;
    shift                   =0;
    transmitpos             =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    indexsize               =0;
    valid_startelement      =0xff;
    valid_elements          =0;
    Offset                  =0;

        switch (Indication_array[2]) // indication
	    {
		    case DataGet_IND: 
                //getData
                gReceivedCalls_ASGID                =(gBAP_Indication[3] &0xF0) /0x10;
                gReceivedCalls_TAID                 =gBAP_Indication[3] &0x0F;
                
                //decode BAP-ArrayHeader
                mode                =(gBAP_Indication[4] &0xF0) /0x10;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                recordaddress       =gBAP_Indication[4] &0x0F;
                if(indexsize)
                {
                    startelement        =gBAP_Indication[5];
                    startelement        +=gBAP_Indication[6] *0x100;
                    elements            =gBAP_Indication[7];
                    elements            +=gBAP_Indication[8]*0x100;
                }
                else
                {    
                    startelement        =gBAP_Indication[5];
                    elements            =gBAP_Indication[6];
                }

                requested_startelement =startelement;
                
                //transmitpos     =TRUE; 
                mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***Startelement=0***/
                if(0==startelement) //Startelement-ID =0 -> start at first array-entry
				{
                    if(FORWARD==direction)  //forward-start
					{ 
                        valid_startelement =0;				       									

                        if(TEL_RECEIVEDCALLS_ENTRIES <=elements) //1. more elements requested, than in array
						{
                            if (shift ==FALSE)  
                            {
                                for(i=0;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
							    {
								    if(0 !=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_RECEIVEDCALLS_ENTRIES;
							    }
                            }
                            else if (shift ==TRUE)
                            {   
                                valid_startelement  =1;
                                startelement        =valid_startelement;

                                for(i=1;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
							    {
								    if(0 !=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_RECEIVEDCALLS_ENTRIES;
							    }
                            }
						}
                        else    //2. number of requested elements < elements in array
						{
                            if (shift ==FALSE)
                            {
							    for(i=0;i<elements;i++)
							    {
								    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_RECEIVEDCALLS_ENTRIES;
							    }
                            }
                            else if (shift ==TRUE)
                            {
                                valid_startelement  =1;
                                startelement        =valid_startelement;

                                for(i=1;i<=elements;i++)
							    {
								    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_RECEIVEDCALLS_ENTRIES;
							    }   
                            }
						}
                    }                                                               //forward ends

                    else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
					{   
						//searching for valid startelement
						for(i=(TEL_RECEIVEDCALLS_ENTRIES-1);i>=0;i--)
						{
							if(0!=gReceivedCalls_ListEntryValidInformation[i])		//found valid startelement
							{
								valid_startelement =i;								
								i =0;												
							}
						}
                        
                        //searching for valid elements
						if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
						{
							valid_startelement  =startelement;
							valid_elements      =0;
						}
						else if(0==valid_startelement)								
							valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
						else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
						{
							for(i=valid_startelement;i>=0;i--)
							{
								if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									valid_elements++;								//increment elements
								else												//no valid element, loop finished
									i=0;
							}
						}
                        else														//enougth array-elements available
						{
							for(i=valid_startelement;i>(valid_startelement-elements);i--)
							{
								if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									valid_elements++;								//increment elements
								else												//no valid element, loop finished
									i=0;
							}
                                      
						}															
				    }                                                               //backward-end
                }                                                                   //startelement ==0 -end

                /***Startelement!=0***/
                else																//searching for Startelement-ID				
				{
					//searching for valid startelement
					for(i=0;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
					{
						if(gReceivedCalls_Pos[i] ==startelement)					    //found a valid element
						{                                          
                            if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
							{
								if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
									valid_startelement =i+1-2*direction;
                                							
                                else if(i==0 && BACKWARD==direction) 
                                    valid_startelement =gReceivedCalls_sum;     //valid element is last element in Array                                                
                            
                                else if(i==0 && FORWARD==direction) 
                                    valid_startelement =0;                          //valid element is first element in Array
                            }
					
                            else
                                valid_startelement =i;                              //found element is valid_startelement

							i=TEL_RECEIVEDCALLS_ENTRIES;
						}
					}

					if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
					{
						valid_startelement  =startelement;
						valid_elements      =0;
					}
					else																//found valid entry for startelement in array
					{
						//verify number of valid elements
						if(BACKWARD==direction)											//backward-start
						{
							if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
								valid_elements=1;
							
							else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
							{
								for(i=valid_startelement;i>=0;i--)
								{
									if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=0;
								}
							}
							else														//enougth array-elements available
							{
								for(i=valid_startelement;i>(valid_startelement-elements);i--)
								{
									if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=0;
								}
							}
						}																//backward-end
						else															//forward-start
						{
							if((valid_startelement+elements)>=TEL_RECEIVEDCALLS_ENTRIES)
							{
								for(i=valid_startelement;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
								{
									//if(0!=gReceivedCalls_Pos[i])						//if there is an valid element
									if(gReceivedCalls_ListEntryValidInformation[i])
                                    	valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=TEL_RECEIVEDCALLS_ENTRIES;
								}
							}
							else
							{
								for(i=valid_startelement;i<(valid_startelement+elements);i++)
								{
									//if(0!=gReceivedCalls_Pos[i])						    //if there is an valid element
									if(gReceivedCalls_ListEntryValidInformation[i])
                                    	valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=TEL_RECEIVEDCALLS_ENTRIES;
								}
							}
						}
					}
				}

                mode =0;     
                mode =ReceivedCalls_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);

                //send StatusArray
                ReceivedCalls_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                   
                
                //Panel
		        putvalue(env_FSG_RC_ASGID,gReceivedCalls_ASGID);
                putvalue(env_FSG_RC_TAID,gReceivedCalls_TAID);

             break;
            
            case DataSetGet_IND:
                //getData
                gReceivedCalls_ASGID                =(gBAP_Indication[3] &0xF0) /0x10;
                gReceivedCalls_TAID                 =gBAP_Indication[3] &0x0F;
                
                //decode BAP-ArrayHeader
                mode                =(gBAP_Indication[4] &0xF0) /0x10;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                recordaddress       =gBAP_Indication[4] &0x0F;
                if(indexsize)
                {
                    startelement        =gBAP_Indication[5];
                    startelement        +=gBAP_Indication[6] *0x100;
                    elements            =gBAP_Indication[7];
                    elements            +=gBAP_Indication[8]*0x100;

                    Offset =9;
                }
                else
                {    
                    startelement        =gBAP_Indication[5];
                    elements            =gBAP_Indication[6];

                    Offset =7;
                }

                requested_startelement =startelement;
                
                //transmitpos     =FALSE; //Position must always be sent in the case of *.StatusArray.  
                mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***Startelement=0***/
                if(0==startelement) //Startelement-ID =0 -> start at first array-entry
				{
                    if(FORWARD==direction)  //forward-start
					{
                        valid_startelement =0;				       									

                        if(TEL_RECEIVEDCALLS_ENTRIES <=elements) //1. more elements requested, than in array
						{
                            if (shift ==FALSE)  
                            {
                                for(i=0;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
							    {
								    if(0 !=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_RECEIVEDCALLS_ENTRIES;
							    }
                            }
                            else if (shift ==TRUE)
                            {   
                                valid_startelement  =1;
                                startelement        =valid_startelement;

                                for(i=1;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
							    {
								    if(0 !=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_RECEIVEDCALLS_ENTRIES;
							    }
                            }
						}
                        else    //2. number of requested elements < elements in array
						{
                            if (shift ==FALSE)
                            {
							    for(i=0;i<elements;i++)
							    {
								    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_RECEIVEDCALLS_ENTRIES;
							    }
                            }
                            else if (shift ==TRUE)
                            {
                                valid_startelement  =1;
                                startelement        =valid_startelement;

                                for(i=1;i<=elements;i++)
							    {
								    if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_RECEIVEDCALLS_ENTRIES;
							    }   
                            }
						}
                    }                                                               //forward ends

                    else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
					{   
						//searching for valid startelement
						for(i=(TEL_RECEIVEDCALLS_ENTRIES-1);i>=0;i--)
						{
							if(0!=gReceivedCalls_ListEntryValidInformation[i])		//found valid startelement
							{
								valid_startelement =i;								
								i =0;												
							}
						}
                        
                        //searching for valid elements
						if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
						{
							valid_startelement  =startelement;
							valid_elements      =0;
						}
						else if(0==valid_startelement)								
							valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
						else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
						{
							for(i=valid_startelement;i>=0;i--)
							{
								if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									valid_elements++;								//increment elements
								else												//no valid element, loop finished
									i=0;
							}
						}
                        else														//enougth array-elements available
						{
							for(i=valid_startelement;i>(valid_startelement-elements);i--)
							{
								if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
									valid_elements++;								//increment elements
								else												//no valid element, loop finished
									i=0;
							}
                                      
						}															
				    }                                                               //backward-end
                }                                                                   //startelement ==0 -end

                /***Startelement!=0***/
                else																//searching for Startelement-ID				
				{
					//searching for valid startelement
					for(i=0;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
					{
						if(gReceivedCalls_Pos[i] ==startelement)					    //found a valid element
						{                                          
                            if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
							{
								if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
									valid_startelement =i+1-2*direction;
                                							
                                else if(i==0 && BACKWARD==direction) 
                                    valid_startelement =gReceivedCalls_sum;     //valid element is last element in Array                                                
                            
                                else if(i==0 && FORWARD==direction) 
                                    valid_startelement =0;                          //valid element is first element in Array
                            }
					
                            else
                                valid_startelement =i;                              //found element is valid_startelement

							i=TEL_RECEIVEDCALLS_ENTRIES;
						}
					}

					if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
					{
						valid_startelement  =startelement;
						valid_elements      =0;
					}
					else																//found valid entry for startelement in array
					{
						//verify number of valid elements
						if(BACKWARD==direction)											//backward-start
						{
							if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
								valid_elements=1;
							
							else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
							{
								for(i=valid_startelement;i>=0;i--)
								{
									if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=0;
								}
							}
							else														//enougth array-elements available
							{
								for(i=valid_startelement;i>(valid_startelement-elements);i--)
								{
									if(0!=gReceivedCalls_ListEntryValidInformation[i])	//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=0;
								}
							}
						}																//backward-end
						else															//forward-start
						{
							if((valid_startelement+elements)>=TEL_RECEIVEDCALLS_ENTRIES)
							{
								for(i=valid_startelement;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
								{
									if(0!=gReceivedCalls_Pos[i])						//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=TEL_RECEIVEDCALLS_ENTRIES;
								}
							}
							else
							{
								for(i=valid_startelement;i<(valid_startelement+elements);i++)
								{
									if(0!=gReceivedCalls_Pos[i])						    //if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=TEL_RECEIVEDCALLS_ENTRIES;
								}
							}
						}
					}
				}
                
                if(getvalue(env_FSG_RC_SetGetArray_behaviour) && valid_elements>0)
                    ReceivedCalls_TakeOverData(Indication_array, Offset, valid_startelement, valid_elements, recordaddress, direction, transmitpos, indexsize);
                
                mode =0;   
                mode =ReceivedCalls_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);

                //send StatusArray
                ReceivedCalls_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                   
                
                //Panel
		        putvalue(env_FSG_RC_ASGID,gReceivedCalls_ASGID);
                putvalue(env_FSG_RC_TAID,gReceivedCalls_TAID);
                
                //check FSG Cache
                ReceivedCalls_CheckCache();

            break;

            case Error_IND:
				writelineEx(gError_Trace, 0, "FSG_Telepfhone ReceivedCalls_Indication: received error, errorcode:0x%x", Indication_array[3]);
			break;

		    default:
			    writelineEx(gError_Trace, 0, "FSG_Telepfhone ReceivedCalls_Indication: invalid indication %d", Indication_array[2]);
		     break;
	}
}

ReceivedCalls_Request (byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{
    int  i;
    byte shift, direction, transmitpos, indexsize;
    dword requestarray [BAP_buffer_size];
    word ReceivedCallsLine, current_element, Offset;

	// Init local variables. 
    for(i=0;i<BAP_buffer_size;i++)
	    requestarray [i]=0;
    
    shift               =0;
    direction           =0;
	transmitpos         =0;
	indexsize           =0;
    ReceivedCallsLine =0;
    current_element     =0;
    Offset              =0;

    // decode "mode-byte"
    shift       =mode &0x01;
    direction   =(mode &0x02)/0x02;
	transmitpos =(mode &0x04)/0x04;
	indexsize   =(mode &0x08)/0x08;

	// Handle request.
    requestarray[0] =LSGID_Telephone;				//LSG-ID
	requestarray[1] =FctID_ReceivedCalls;		//Fct.-ID
	requestarray[2] =request;                   //request type
	Offset =3;

    switch(request)
	{
		case Changed_REQ:      

            /***ArrayHeader***/
			requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
			Offset++;
            if(indexsize)
            {
                requestarray[Offset] =requested_startelement &0xff;
                Offset++;
                requestarray[Offset] =(requested_startelement &0xff00) /0x100;
                Offset++;
                
                requestarray[Offset] =elements &0xff;
                Offset++;
                requestarray[Offset] =(elements &0xff00) /0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] =requested_startelement;
                Offset++;  
                requestarray[Offset] =elements;
                Offset++;
            }
            
            ReceivedCallsLine =startelement;
           
            if(@env_FSG_RC_CA_switch) //if "ArrayHeader + Data"
            {
                //copy data
                switch(recordaddress)
			    {
                    case 0: //complete record
                            while(current_element <elements)
                            {
                                if(ReceivedCallsLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone ReceivedCalls_Request: invalid ReceivedCallsLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gReceivedCalls_Pos[ReceivedCallsLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gReceivedCalls_Pos[ReceivedCallsLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gReceivedCalls_Pos[ReceivedCallsLine];
                                            Offset++;
                                        }
                                    }
                                                                                              
                                    //PbName
                                    requestarray[Offset] =strlen(gReceivedCalls_PbName[ReceivedCallsLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gReceivedCalls_PbName[ReceivedCallsLine]);i++)
                    			    {
			                            requestarray[Offset] =gReceivedCalls_PbName[ReceivedCallsLine][i];	
			                            Offset++;
			                        }
                                
                                    //NumberType
                                    requestarray[Offset] =gReceivedCalls_NumberType[ReceivedCallsLine];
                                    Offset++;

                                    //TelNumber
                                    requestarray[Offset] =strlen(gReceivedCalls_TelNumber[ReceivedCallsLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gReceivedCalls_TelNumber[ReceivedCallsLine]);i++)
                    			    {
			                            requestarray[Offset] =gReceivedCalls_TelNumber[ReceivedCallsLine][i];	
			                            Offset++;
			                        }

                                    //Day
                                    requestarray[Offset] =gReceivedCalls_day[ReceivedCallsLine];
                                    Offset++;

                                    //Month
                                    requestarray[Offset] =gReceivedCalls_month[ReceivedCallsLine];
                                    Offset++;

                                    //Year
                                    requestarray[Offset] =gReceivedCalls_year[ReceivedCallsLine];
                                    Offset++;

                                    //Hour
                                    requestarray[Offset] =gReceivedCalls_hour[ReceivedCallsLine];
                                    Offset++;

                                    //Minute
                                    requestarray[Offset] =gReceivedCalls_minute[ReceivedCallsLine];
                                    Offset++;

                                    //Second
                                    requestarray[Offset] =gReceivedCalls_second[ReceivedCallsLine];
                                    Offset++;

                                }
                                current_element++;
                                ReceivedCallsLine =ReceivedCalls_nextvalidLine(ReceivedCallsLine, direction);
                            
                            }//end while
 
                     break;

                    case 1: //PbName, NumberType
                            while(current_element <elements)
                            {
                                if(ReceivedCallsLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone ReceivedCalls_Request: invalid ReceivedCallsLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gReceivedCalls_Pos[ReceivedCallsLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gReceivedCalls_Pos[ReceivedCallsLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gReceivedCalls_Pos[ReceivedCallsLine];
                                            Offset++;
                                        }
                                    }
                                                                                              
                                    //PbName
                                    requestarray[Offset] =strlen(gReceivedCalls_PbName[ReceivedCallsLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gReceivedCalls_PbName[ReceivedCallsLine]);i++)
                    			    {
			                            requestarray[Offset] =gReceivedCalls_PbName[ReceivedCallsLine][i];	
			                            Offset++;
			                        }
                                
                                    //NumberType
                                    requestarray[Offset] =gReceivedCalls_NumberType[ReceivedCallsLine];
                                    Offset++;
                                }
                                current_element++;
                                ReceivedCallsLine =ReceivedCalls_nextvalidLine(ReceivedCallsLine, direction);
                            
                            }//end while
                        
                     break;

                    case 2: //TelNumber, Day, Month, Year, Hour, Minute, Second
                            while(current_element <elements)
                            {
                                if(ReceivedCallsLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone ReceivedCalls_Request: invalid ReceivedCallsLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gReceivedCalls_Pos[ReceivedCallsLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gReceivedCalls_Pos[ReceivedCallsLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gReceivedCalls_Pos[ReceivedCallsLine];
                                            Offset++;
                                        }
                                    }

                                    //TelNumber
                                    requestarray[Offset] =strlen(gReceivedCalls_TelNumber[ReceivedCallsLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gReceivedCalls_TelNumber[ReceivedCallsLine]);i++)
                    			    {
			                            requestarray[Offset] =gReceivedCalls_TelNumber[ReceivedCallsLine][i];	
			                            Offset++;
			                        }

                                    //Day
                                    requestarray[Offset] =gReceivedCalls_day[ReceivedCallsLine];
                                    Offset++;

                                    //Month
                                    requestarray[Offset] =gReceivedCalls_month[ReceivedCallsLine];
                                    Offset++;

                                    //Year
                                    requestarray[Offset] =gReceivedCalls_year[ReceivedCallsLine];
                                    Offset++;

                                    //Hour
                                    requestarray[Offset] =gReceivedCalls_hour[ReceivedCallsLine];
                                    Offset++;

                                    //Minute
                                    requestarray[Offset] =gReceivedCalls_minute[ReceivedCallsLine];
                                    Offset++;

                                    //Second
                                    requestarray[Offset] =gReceivedCalls_second[ReceivedCallsLine];
                                    Offset++;

                                }
                                current_element++;
                                ReceivedCallsLine =ReceivedCalls_nextvalidLine(ReceivedCallsLine, direction);
                            
                            }//end while
                        
                     break;

                    case 15: //Pos
                            while(current_element <elements)
                            {
                                if(ReceivedCallsLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone ReceivedCalls_Request: invalid ReceivedCallsLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gReceivedCalls_Pos[ReceivedCallsLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gReceivedCalls_Pos[ReceivedCallsLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gReceivedCalls_Pos[ReceivedCallsLine];
                                            Offset++;
                                        }
                                    }
                                }
                                current_element++;
                                ReceivedCallsLine =ReceivedCalls_nextvalidLine(ReceivedCallsLine, direction);
                            
                            }//end while
                        
                     break;

                    default:
					    write("FSG-Telephone ReceivedCalls_Request: invalid recordaddress %d", recordaddress);
				     break;
                } //end switch "recordaddress"
            } //end if "ArrayHeader + Data"       		
		
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

        break; //end Changed_REQ
        
        
        case Data_REQ:
            //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x2F_TimeOut)!=TRUE)
            {
            requestarray[Offset] =((gReceivedCalls_ASGID *0x10) &0xF0) +(gReceivedCalls_TAID &0x0F);	
            Offset++;
            requestarray[Offset] =gReceivedCalls_TotalNumListElements;	
            Offset++;

            /***ArrayHeader***/
			requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
			Offset++;
            if(indexsize)
            {
                requestarray[Offset] =requested_startelement &0xff;
                Offset++;
                requestarray[Offset] =(requested_startelement &0xff00) /0x100;
                Offset++;
                
                requestarray[Offset] =elements &0xff;
                Offset++;
                requestarray[Offset] =(elements &0xff00) /0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] =requested_startelement;
                Offset++;  
                requestarray[Offset] =elements;
                Offset++;
            }
              
            ReceivedCallsLine =startelement;
            
            //copy data
            switch(recordaddress)
			{
                case 0: //complete record 
                        while(current_element <elements)
                        {
                            if(ReceivedCallsLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone ReceivedCalls_Request: invalid ReceivedCallsLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gReceivedCalls_Pos[ReceivedCallsLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gReceivedCalls_Pos[ReceivedCallsLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gReceivedCalls_Pos[ReceivedCallsLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //PbName
                                requestarray[Offset] =strlen(gReceivedCalls_PbName[ReceivedCallsLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gReceivedCalls_PbName[ReceivedCallsLine]);i++)
                    			{
			                        requestarray[Offset] =gReceivedCalls_PbName[ReceivedCallsLine][i];	
			                        Offset++;
			                    }
                                
                                //NumberType
                                requestarray[Offset] =gReceivedCalls_NumberType[ReceivedCallsLine];
                                Offset++;

                                //TelNumber
                                requestarray[Offset] =strlen(gReceivedCalls_TelNumber[ReceivedCallsLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gReceivedCalls_TelNumber[ReceivedCallsLine]);i++)
                    			{
			                        requestarray[Offset] =gReceivedCalls_TelNumber[ReceivedCallsLine][i];	
			                        Offset++;
			                    }

                                //Day
                                requestarray[Offset] =gReceivedCalls_day[ReceivedCallsLine];
                                Offset++;

                                //Month
                                requestarray[Offset] =gReceivedCalls_month[ReceivedCallsLine];
                                Offset++;

                                //Year
                                requestarray[Offset] =gReceivedCalls_year[ReceivedCallsLine];
                                Offset++;

                                //Hour
                                requestarray[Offset] =gReceivedCalls_hour[ReceivedCallsLine];
                                Offset++;

                                //Minute
                                requestarray[Offset] =gReceivedCalls_minute[ReceivedCallsLine];
                                Offset++;

                                //Second
                                requestarray[Offset] =gReceivedCalls_second[ReceivedCallsLine];
                                Offset++;

                            }
                            current_element++;
                            ReceivedCallsLine =ReceivedCalls_nextvalidLine(ReceivedCallsLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 1: //PbName, NumberType
                        while(current_element <elements)
                        {
                            if(ReceivedCallsLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone ReceivedCalls_Request: invalid ReceivedCallsLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gReceivedCalls_Pos[ReceivedCallsLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gReceivedCalls_Pos[ReceivedCallsLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gReceivedCalls_Pos[ReceivedCallsLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //PbName
                                requestarray[Offset] =strlen(gReceivedCalls_PbName[ReceivedCallsLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gReceivedCalls_PbName[ReceivedCallsLine]);i++)
                    			{
			                        requestarray[Offset] =gReceivedCalls_PbName[ReceivedCallsLine][i];	
			                        Offset++;
			                    }
                                
                                //NumberType
                                requestarray[Offset] =gReceivedCalls_NumberType[ReceivedCallsLine];
                                Offset++;
                            }
                            current_element++;
                            ReceivedCallsLine =ReceivedCalls_nextvalidLine(ReceivedCallsLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 2: //TelNumber, Day, Month, Year, Hour, Minute, Second
                        while(current_element <elements)
                        {
                            if(ReceivedCallsLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone ReceivedCalls_Request: invalid ReceivedCallsLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gReceivedCalls_Pos[ReceivedCallsLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gReceivedCalls_Pos[ReceivedCallsLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gReceivedCalls_Pos[ReceivedCallsLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //TelNumber
                                requestarray[Offset] =strlen(gReceivedCalls_TelNumber[ReceivedCallsLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gReceivedCalls_TelNumber[ReceivedCallsLine]);i++)
                    			{
			                        requestarray[Offset] =gReceivedCalls_TelNumber[ReceivedCallsLine][i];	
			                        Offset++;
			                    }

                                //Day
                                requestarray[Offset] =gReceivedCalls_day[ReceivedCallsLine];
                                Offset++;

                                //Month
                                requestarray[Offset] =gReceivedCalls_month[ReceivedCallsLine];
                                Offset++;

                                //Year
                                requestarray[Offset] =gReceivedCalls_year[ReceivedCallsLine];
                                Offset++;

                                //Hour
                                requestarray[Offset] =gReceivedCalls_hour[ReceivedCallsLine];
                                Offset++;

                                //Minute
                                requestarray[Offset] =gReceivedCalls_minute[ReceivedCallsLine];
                                Offset++;

                                //Second
                                requestarray[Offset] =gReceivedCalls_second[ReceivedCallsLine];
                                Offset++;

                            }
                            current_element++;
                            ReceivedCallsLine =ReceivedCalls_nextvalidLine(ReceivedCallsLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 15: //Pos
                        while(current_element <elements)
                        {
                            if(ReceivedCallsLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone ReceivedCalls_Request: invalid ReceivedCallsLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gReceivedCalls_Pos[ReceivedCallsLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gReceivedCalls_Pos[ReceivedCallsLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gReceivedCalls_Pos[ReceivedCallsLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            ReceivedCallsLine =ReceivedCalls_nextvalidLine(ReceivedCallsLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                default:
					write("FSG-Telephone ReceivedCalls_Request: invalid recordaddress %d", recordaddress);
				 break;
            } //end switch "recordaddress"
            } // end of if for issueList #62
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] =errorcode;
			
			set_status_requestbuffer (requestarray, 4, Bap_Error);
         break; //end Error_REQ
    
    } //end switch "request"   
}

ReceivedCalls_CheckCache ()
{
    int i =0, j =0, k =0;

    for (i=0; i<TEL_RECEIVEDCALLS_ENTRIES; i++)
    {
        if(gReceivedCalls_ListEntryValidInformation[i] !=1)
        {       
            for (j=i; j<TEL_RECEIVEDCALLS_ENTRIES; j++)
            {
                if(gReceivedCalls_ListEntryValidInformation[j])
                {                   
                    //Pos
                    gReceivedCalls_Pos[i] =0; //clear new position
                    gReceivedCalls_Pos[i] =i; // -> new Pos for consecutive ID
                    
                    //PbName
                    for(k=0; k<TEL_RECEIVEDCALLS_PBNAME_LENGTH; k++) //clear new position
                        gReceivedCalls_PbName[i][k]=0; 
                    
                    for(k=0; k<strlen(gReceivedCalls_PbName[j]); k++)
                        gReceivedCalls_PbName[i][k]=gReceivedCalls_PbName[j][k];

                    for(k=0; k<TEL_RECEIVEDCALLS_PBNAME_LENGTH; k++) //clear old position
                        gReceivedCalls_PbName[j][k]=0; 

                    //NumberType
                    gReceivedCalls_NumberType[i] =0; //clear new position
                    gReceivedCalls_NumberType[i] =gReceivedCalls_NumberType[j];
                    gReceivedCalls_NumberType[j] =0; //clear old position
                    
                    //TelNumber
                    for(k=0; k<TEL_RECEIVEDCALLS_TELNUMBER_LENGTH; k++) //clear new position
                        gReceivedCalls_TelNumber[i][k]=0; 
                    
                    for(k=0; k<strlen(gReceivedCalls_TelNumber[j]); k++)
                        gReceivedCalls_TelNumber[i][k]=gReceivedCalls_TelNumber[j][k];

                    for(k=0; k<TEL_RECEIVEDCALLS_TELNUMBER_LENGTH; k++) //clear old position
                        gReceivedCalls_TelNumber[j][k]=0; 
                    
                    //Day
                    gReceivedCalls_day[i] =0; //clear new position
                    gReceivedCalls_day[i] =gReceivedCalls_day[j];
                    gReceivedCalls_day[j] =0; //clear old position

                    //Month
                    gReceivedCalls_month[i] =0; //clear new position
                    gReceivedCalls_month[i] =gReceivedCalls_month[j];
                    gReceivedCalls_month[j] =0; //clear old position

                    //Year
                    gReceivedCalls_year[i] =0; //clear new position
                    gReceivedCalls_year[i] =gReceivedCalls_year[j];
                    gReceivedCalls_year[j] =0; //clear old position

                    //Hour
                    gReceivedCalls_hour[i] =0; //clear new position
                    gReceivedCalls_hour[i] =gReceivedCalls_hour[j];
                    gReceivedCalls_hour[j] =0; //clear old position

                    //Minute
                    gReceivedCalls_minute[i] =0; //clear new position
                    gReceivedCalls_minute[i] =gReceivedCalls_minute[j];
                    gReceivedCalls_minute[j] =0; //clear old position

                    //Second
                    gReceivedCalls_second[i] =0; //clear new position
                    gReceivedCalls_second[i] =gReceivedCalls_second[j];
                    gReceivedCalls_second[j] =0; //clear old position

                    gReceivedCalls_ListEntryValidInformation[i] =0; //clear new position
                    gReceivedCalls_ListEntryValidInformation[i] =gReceivedCalls_ListEntryValidInformation[j];
                    gReceivedCalls_ListEntryValidInformation[j] =0; //clear old position


                    j=TEL_RECEIVEDCALLS_ENTRIES;
                }
            }
        }    
    }
    
    gReceivedCalls_sum =0;

    for (i=0; i<TEL_RECEIVEDCALLS_ENTRIES; i++)
    {
        if(gReceivedCalls_ListEntryValidInformation[i])
            gReceivedCalls_sum++;
        else
            i=TEL_RECEIVEDCALLS_ENTRIES;
    }
    
    gReceivedCalls_TotalNumListElements =gReceivedCalls_sum;
    putvalue(env_FSG_RC_TotalNumLE,gReceivedCalls_TotalNumListElements);   
}

byte ReceivedCalls_buildModeByte (word requested_startelement, word startelement, word elements, byte shift, byte direction, byte transmitpos, byte indexsize)
{    
    int  i;
    word ReceivedCallsLine;
    byte mode;
    
    //init variables
    indexsize           =0;
    i                   =0;
    ReceivedCallsLine =0;    
    mode                =0;
    
    if(requested_startelement >0xFE)
        indexsize =TRUE;

    else
    {  
        ReceivedCallsLine =startelement;
                
        while(i <elements)
        {   
            if(ReceivedCallsLine ==0xff) //Invalid "list entry"
                i =elements;

            else //"list entry" valid
            {   
                if(gReceivedCalls_Pos[ReceivedCallsLine] >0xFE)
                    indexsize =TRUE;
            }
            i++;
            ReceivedCallsLine =ReceivedCalls_nextvalidLine(ReceivedCallsLine, direction);
                            
        }//end while
    }//end else
    
    //build mode byte
    mode    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

    return (mode);
}

ReceivedCalls_TakeOverData (dword Indication_array [], word Offset, word startelement, word elements, byte recordaddress, byte direction, byte transmitpos, byte indexsize)
{
    int i =0, j =0, length =0;
    word current_ReceivedCallsLine =0;

    //write("IndicationArray[%d], startelement =0x%x, elemente =%d, recordaddress =0x%x, direction =%d, transimtPos =%d, IS =%d", Offset, startelement, elements, recordaddress, shift, direction, transmitpos, indexsize);

    for(i=0;i<TEL_RECEIVEDCALLS_ENTRIES;i++)
    {
        if(gReceivedCalls_Pos[i] ==startelement)
        {
            current_ReceivedCallsLine =i;
                        
            i =TEL_RECEIVEDCALLS_ENTRIES;
        }
    }

    /***copy elements***/
    for (i=0; i<elements; i++)
    {
        switch (recordaddress)
        {
            case 0: //recordaddress =0 -> complete record
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gReceivedCalls_Pos[current_ReceivedCallsLine] =Indication_array [Offset];
                            Offset++;
                            gReceivedCalls_Pos[current_ReceivedCallsLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gReceivedCalls_Pos[current_ReceivedCallsLine] =Indication_array[Offset];
            
                        Offset++;
                    }

                    //PbName
                    for(j=0; j<TEL_RECEIVEDCALLS_PBNAME_LENGTH;j++) //clear
                        gReceivedCalls_PbName[current_ReceivedCallsLine][j] =0; 
                                   
                    length =Indication_array[Offset];
                    Offset++;

                    if(length ==0) //list element cleared by ASG ('empty string')
                        gReceivedCalls_ListEntryValidInformation[current_ReceivedCallsLine] =0;
                        
                                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gReceivedCalls_PbName[current_ReceivedCallsLine][j] =Indication_array[Offset];
                        Offset++;
                    }
                    
                    //NumberType
                    gReceivedCalls_NumberType[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;

                    //TelNumber
                    for(j=0; j<TEL_RECEIVEDCALLS_TELNUMBER_LENGTH;j++) //clear
			            gReceivedCalls_TelNumber[current_ReceivedCallsLine][j] =0; 
                                    
                                         
                    length =Indication_array[Offset];
                    Offset++;
                                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gReceivedCalls_TelNumber[current_ReceivedCallsLine][j] =Indication_array[Offset];
                        Offset++;
                    }

                    //Day
                    gReceivedCalls_day[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;


                    //Month
                    gReceivedCalls_month[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
                      

                    //Year
                    gReceivedCalls_year[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Hour
                    gReceivedCalls_hour[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
                    

                    //Minute
                    gReceivedCalls_minute[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Second
                    gReceivedCalls_second[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
                                    
            break;

            case 1: //recordaddress =1 -> PbName, NumberType
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gReceivedCalls_Pos[current_ReceivedCallsLine] =Indication_array [Offset];
                            Offset++;
                            gReceivedCalls_Pos[current_ReceivedCallsLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gReceivedCalls_Pos[current_ReceivedCallsLine] =Indication_array[Offset];
            
                        Offset++;
                    }

                    //PbName
                    for(j=0; j<TEL_RECEIVEDCALLS_PBNAME_LENGTH;j++) //clear
			            gReceivedCalls_PbName[current_ReceivedCallsLine][j] =0; 
                                    
                                         
                    length =Indication_array[Offset];
                    Offset++;
                                    
                    
                    if(length ==0) //list element cleared by ASG ('empty string')
                        gReceivedCalls_ListEntryValidInformation[current_ReceivedCallsLine]=0;
                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gReceivedCalls_PbName[current_ReceivedCallsLine][j] =Indication_array[Offset];
                        Offset++;
                    }
                    
                    //NumberType
                    gReceivedCalls_NumberType[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
                                    
            break;//recordaddress =2 ends

            case 2: //recordaddress =2 -> TelNumber, Day, Month, Year, Hour, Minute, Second
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gReceivedCalls_Pos[current_ReceivedCallsLine] =Indication_array [Offset];
                            Offset++;
                            gReceivedCalls_Pos[current_ReceivedCallsLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gReceivedCalls_Pos[current_ReceivedCallsLine] =Indication_array[Offset];
            
                        Offset++;
                    }

                    //TelNumber
                    for(j=0; j<TEL_RECEIVEDCALLS_TELNUMBER_LENGTH;j++) //clear
			            gReceivedCalls_TelNumber[current_ReceivedCallsLine][j] =0; 
                                    
                                         
                    length =Indication_array[Offset];
                    Offset++;
                                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gReceivedCalls_TelNumber[current_ReceivedCallsLine][j] =Indication_array[Offset];
                        Offset++;
                    }

                    //Day
                    gReceivedCalls_day[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;


                    //Month
                    gReceivedCalls_month[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
                      

                    //Year
                    gReceivedCalls_year[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Hour
                    gReceivedCalls_hour[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
                    

                    //Minute
                    gReceivedCalls_minute[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Second
                    gReceivedCalls_second[current_ReceivedCallsLine] =Indication_array[Offset];
                    Offset++;
            break;

            case 15: //recordaddress =0xf -> Pos
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gReceivedCalls_Pos[current_ReceivedCallsLine] =Indication_array [Offset];
                            Offset++;
                            gReceivedCalls_Pos[current_ReceivedCallsLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gReceivedCalls_Pos[current_ReceivedCallsLine] =Indication_array[Offset];
            
                        Offset++;
                    }

            break; //recordaddress =0xf ends

        }// end switch recordaddress

        current_ReceivedCallsLine =ReceivedCalls_nextvalidLine (current_ReceivedCallsLine, direction);
    } //end 'for' -> copy elements
}

byte ReceivedCalls_nextvalidLine (word current_ReceivedCallsLine, byte direction)
{
    word next_ReceivedCallsLine;
    int i;
         
    //init lokal variables
    next_ReceivedCallsLine    =0;
    i                           =0;

    //search next "list entry"
    if(((gReceivedCalls_sum-1)==current_ReceivedCallsLine && FORWARD ==direction) || (0 ==current_ReceivedCallsLine && BACKWARD ==direction))	//last-/fist-element of array reached
	    next_ReceivedCallsLine =0xFF;
	else
	{
			next_ReceivedCallsLine =current_ReceivedCallsLine +1-2*direction;       //increment or decrement array-line (depends on direction);
                 
            if(0 ==gReceivedCalls_ListEntryValidInformation[next_ReceivedCallsLine])	// check if next element is "valid"
			    next_ReceivedCallsLine =0xff; 					
	}

    return(next_ReceivedCallsLine);
}

on envVar env_FSG_DN_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        if(getvalue(env_FSG_DN_AH_start) >255 && getvalue(env_FSG_DN_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_FSG_DN_AH_IS,1);

        //get data from Panel
        recordaddress   =getvalue(env_FSG_DN_AH_RA);
        shift           =getvalue(env_FSG_DN_AH_shift);
        direction       =getvalue(env_FSG_DN_AH_dir);
        transmitpos     =getvalue(env_FSG_DN_AH_POS);
        indexsize       =getvalue(env_FSG_DN_AH_IS);
        startelement    =getvalue(env_FSG_DN_AH_start);
        elements        =getvalue(env_FSG_DN_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
            if(FORWARD==direction)  //forward-start
			{
                valid_startelement =0;				       									

                if(TEL_DIALEDNUMBERS_ENTRIES <=elements) //1. more elements requested, than in array
				{
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
						{
						    if(0 !=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_DIALEDNUMBERS_ENTRIES;
					    }
                    }
                    else if (shift ==TRUE)
                    {   
                        valid_startelement  =1;
                        startelement        =valid_startelement;

                        for(i=1;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
						{
						    if(0 !=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_DIALEDNUMBERS_ENTRIES;
					    }
                    }
			    }
                else    //2. number of requested elements < elements in array
				{
                    if (shift ==FALSE)
                    {
					    for(i=0;i<elements;i++)
						{
						    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						       i =TEL_DIALEDNUMBERS_ENTRIES;
					    }
                    }
                    else if (shift ==TRUE)
                    {
                        valid_startelement  =1;
                        startelement        =valid_startelement;

                        for(i=1;i<=elements;i++)
						{
						    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_DIALEDNUMBERS_ENTRIES;
					    }   
                    }

				}
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			    //searching for valid startelement
				for(i=(TEL_DIALEDNUMBERS_ENTRIES-1);i>=0;i--)
				{
				    if(0!=gDialedNumbers_ListEntryValidInformation[i])		//found valid startelement
					{
					    valid_startelement =i;								
						i =0;												
					}
				}
                        
                //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
				{
				    valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
				    valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				    for(i=valid_startelement;i>=0;i--)
					{
					    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						    i=0;
				    }
				}
                else														//enougth array-elements available
				{
				    for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
					    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
							i=0;
					}                   
				}															
	        }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else																//searching for Startelement-ID				
		{
		    //searching for valid startelement
			for(i=0;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
			{
				if(gDialedNumbers_Pos[i] ==startelement)					    //found a valid element
				{                                       
                    if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
					    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
						    valid_startelement =i+1-2*direction;
                                							
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gDialedNumbers_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
					
                    else
                        valid_startelement =i;                              //found element is valid_startelement

					i =TEL_DIALEDNUMBERS_ENTRIES;
				}
                else
                    valid_startelement =0xff;
			}

			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			    //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
				    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
					    valid_elements=1;
							
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				    {
					    for(i=valid_startelement;i>=0;i--)
						{
						    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
                            else												//no valid element, loop finished
							    i=0;
						}
				    }
					else														//enougth array-elements available
					{
					    for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
						    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
								i=0;
						}
					}
				}																//backward-end
				else															//forward-start
				{
				    if((valid_startelement+elements)>=TEL_DIALEDNUMBERS_ENTRIES)
					{
					    for(i=valid_startelement;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
						{
						    if(0!=gDialedNumbers_Pos[i])							//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=TEL_DIALEDNUMBERS_ENTRIES;
						}
					}
					else
					{
					    for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
						    if(0!=gDialedNumbers_Pos[i])						    //if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=TEL_DIALEDNUMBERS_ENTRIES;
						}
					}
				}
			}
		}
        putvalue(env_FSG_DN_AH_elements, valid_elements);

        //send ChangedArray
        DialedNumbers_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

on envVar env_FSG_DN_DataSource
{
    if (getvalue(this) ==TEL_DEFAULT_LIST)
    {
        DialedNumbers_init_static();
        putvalue(env_FSG_DN_DataSource_file, empty_string);
        putvalue(env_FSG_DN_DataSource_result, empty_string);
    }
}

on envVar env_FSG_DN_StatusArray
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        if(getvalue(env_FSG_DN_AH_start) >255 && getvalue(env_FSG_DN_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_FSG_DN_AH_IS,1);

        //get data from Panel
        gDialedNumbers_ASGID                =getvalue(env_FSG_DN_ASGID);
        gDialedNumbers_TAID                 =getvalue(env_FSG_DN_TAID);

        gDialedNumbers_TotalNumListElements  =getvalue(env_FSG_DN_TotalNumLE);

        recordaddress   =getvalue(env_FSG_DN_AH_RA);
        shift           =getvalue(env_FSG_DN_AH_shift);
        direction       =getvalue(env_FSG_DN_AH_dir);
        transmitpos     =getvalue(env_FSG_DN_AH_POS);
        indexsize       =getvalue(env_FSG_DN_AH_IS);
        startelement    =getvalue(env_FSG_DN_AH_start);
        elements        =getvalue(env_FSG_DN_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
            if(FORWARD==direction)  //forward-start
			{
                valid_startelement =0;				       									

                if(TEL_DIALEDNUMBERS_ENTRIES <=elements) //1. more elements requested, than in array
				{
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
						{
						    if(0 !=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_DIALEDNUMBERS_ENTRIES;
					    }
                    }
                    else if (shift ==TRUE)
                    {   
                        valid_startelement  =1;
                        startelement        =valid_startelement;

                        for(i=1;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
						{
						    if(0 !=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_DIALEDNUMBERS_ENTRIES;
					    }
                    }
			    }
                else    //2. number of requested elements < elements in array
				{
                    if (shift ==FALSE)
                    {
					    for(i=0;i<elements;i++)
						{
						    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						       i =TEL_DIALEDNUMBERS_ENTRIES;
					    }
                    }
                    else if (shift ==TRUE)
                    {
                        valid_startelement  =1;
                        startelement        =valid_startelement;

                        for(i=1;i<=elements;i++)
						{
						    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i =TEL_DIALEDNUMBERS_ENTRIES;
					    }   
                    }

				}
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			    //searching for valid startelement
				for(i=(TEL_DIALEDNUMBERS_ENTRIES-1);i>=0;i--)
				{
				    if(0!=gDialedNumbers_ListEntryValidInformation[i])		//found valid startelement
					{
					    valid_startelement =i;								
						i =0;												
					}
				}
                        
                //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
				{
				    valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
				    valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				    for(i=valid_startelement;i>=0;i--)
					{
					    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						    i=0;
				    }
				}
                else														//enougth array-elements available
				{
				    for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
					    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
						else												//no valid element, loop finished
							i=0;
					}                   
				}															
	        }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else																//searching for Startelement-ID				
		{
		    //searching for valid startelement
			for(i=0;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
			{
				if(gDialedNumbers_Pos[i] ==startelement)					    //found a valid element
				{                                       
                    if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
					    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
						    valid_startelement =i+1-2*direction;
                                							
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gDialedNumbers_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
					
                    else
                        valid_startelement =i;                              //found element is valid_startelement

					i =TEL_DIALEDNUMBERS_ENTRIES;
				}
                else
                    valid_startelement =0xff;
			}

			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			    //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
				    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
					    valid_elements=1;
							
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				    {
					    for(i=valid_startelement;i>=0;i--)
						{
						    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
                            else												//no valid element, loop finished
							    i=0;
						}
				    }
					else														//enougth array-elements available
					{
					    for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
						    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
								i=0;
						}
					}
				}																//backward-end
				else															//forward-start
				{
				    if((valid_startelement+elements)>=TEL_DIALEDNUMBERS_ENTRIES)
					{
					    for(i=valid_startelement;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
						{
						    if(0!=gDialedNumbers_Pos[i])							//if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=TEL_DIALEDNUMBERS_ENTRIES;
						}
					}
					else
					{
					    for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
						    if(0!=gDialedNumbers_Pos[i])						    //if there is an valid element
							    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							    i=TEL_DIALEDNUMBERS_ENTRIES;
						}
					}
				}
			}
		}
        putvalue(env_FSG_DN_AH_elements, valid_elements);

        //send StatusArray
        DialedNumbers_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

on envVar env_FSG_DN_reload //load external ReceptionList from *.csv
{
    if(getvalue(this) && getvalue(env_FSG_DN_DataSource) ==TEL_EXTERNAL_LIST)
	    DialedNumbers_init_CSV();

    else if(getvalue(env_FSG_DN_DataSource) != TEL_EXTERNAL_LIST)
        putvalue(env_FSG_DN_DataSource_result,"not successful, select 'external *.csv'");
}

DialedNumbers_CheckCache ()
{
    int i =0, j =0, k =0;

    for (i=0; i<TEL_DIALEDNUMBERS_ENTRIES; i++)
    {
        if(gDialedNumbers_ListEntryValidInformation[i] !=1)
        {       
            for (j=i; j<TEL_DIALEDNUMBERS_ENTRIES; j++)
            {
                if(gDialedNumbers_ListEntryValidInformation[j])
                {                   
                    //Pos
                    gDialedNumbers_Pos[i] =0; //clear new position
                    gDialedNumbers_Pos[i] =i; // -> new Pos for consecutive ID
                    
                    //PbName
                    for(k=0; k<TEL_DIALEDNUMBERS_PBNAME_LENGTH; k++) //clear new position
                        gDialedNumbers_PbName[i][k]=0; 
                    
                    for(k=0; k<strlen(gDialedNumbers_PbName[j]); k++)
                        gDialedNumbers_PbName[i][k]=gDialedNumbers_PbName[j][k];

                    for(k=0; k<TEL_DIALEDNUMBERS_PBNAME_LENGTH; k++) //clear old position
                        gDialedNumbers_PbName[j][k]=0; 

                    //NumberType
                    gDialedNumbers_NumberType[i] =0; //clear new position
                    gDialedNumbers_NumberType[i] =gDialedNumbers_NumberType[j];
                    gDialedNumbers_NumberType[j] =0; //clear old position
                    
                    //TelNumber
                    for(k=0; k<TEL_DIALEDNUMBERS_TELNUMBER_LENGTH; k++) //clear new position
                        gDialedNumbers_TelNumber[i][k]=0; 
                    
                    for(k=0; k<strlen(gDialedNumbers_TelNumber[j]); k++)
                        gDialedNumbers_TelNumber[i][k]=gDialedNumbers_TelNumber[j][k];

                    for(k=0; k<TEL_DIALEDNUMBERS_TELNUMBER_LENGTH; k++) //clear old position
                        gDialedNumbers_TelNumber[j][k]=0; 
                    
                    //Day
                    gDialedNumbers_day[i] =0; //clear new position
                    gDialedNumbers_day[i] =gDialedNumbers_day[j];
                    gDialedNumbers_day[j] =0; //clear old position

                    //Month
                    gDialedNumbers_month[i] =0; //clear new position
                    gDialedNumbers_month[i] =gDialedNumbers_month[j];
                    gDialedNumbers_month[j] =0; //clear old position

                    //Year
                    gDialedNumbers_year[i] =0; //clear new position
                    gDialedNumbers_year[i] =gDialedNumbers_year[j];
                    gDialedNumbers_year[j] =0; //clear old position

                    //Hour
                    gDialedNumbers_hour[i] =0; //clear new position
                    gDialedNumbers_hour[i] =gDialedNumbers_hour[j];
                    gDialedNumbers_hour[j] =0; //clear old position

                    //Minute
                    gDialedNumbers_minute[i] =0; //clear new position
                    gDialedNumbers_minute[i] =gDialedNumbers_minute[j];
                    gDialedNumbers_minute[j] =0; //clear old position

                    //Second
                    gDialedNumbers_second[i] =0; //clear new position
                    gDialedNumbers_second[i] =gDialedNumbers_second[j];
                    gDialedNumbers_second[j] =0; //clear old position

                    gDialedNumbers_ListEntryValidInformation[i] =0; //clear new position
                    gDialedNumbers_ListEntryValidInformation[i] =gDialedNumbers_ListEntryValidInformation[j];
                    gDialedNumbers_ListEntryValidInformation[j] =0; //clear old position


                    j=TEL_DIALEDNUMBERS_ENTRIES;
                }
            }
        }    
    }
    
    gDialedNumbers_sum =0;

    for (i=0; i<TEL_DIALEDNUMBERS_ENTRIES; i++)
    {
        if(gDialedNumbers_ListEntryValidInformation[i])
            gDialedNumbers_sum++;
        else
            i=TEL_DIALEDNUMBERS_ENTRIES;
    }
    
    gDialedNumbers_TotalNumListElements =gDialedNumbers_sum;
    putvalue(env_FSG_DN_TotalNumLE,gDialedNumbers_TotalNumListElements);   
}

DialedNumbers_Indication (dword Indication_array [])
{
    byte mode, shift, direction, recordaddress, indexsize, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements, valid_elements, Offset;
    int i=0;
    
    // Init local variables. 
    mode                    =0;
    direction               =0;
    shift                   =0;
    transmitpos             =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    indexsize               =0;
    valid_startelement      =0xff;
    valid_elements          =0;
    Offset                  =0;

        switch (Indication_array[2]) // indication
	    {
		    case DataGet_IND: 
                //getData
                gDialedNumbers_ASGID                =(gBAP_Indication[3] &0xF0) /0x10;
                gDialedNumbers_TAID                 =gBAP_Indication[3] &0x0F;
                
                //decode BAP-ArrayHeader
                mode                =(gBAP_Indication[4] &0xF0) /0x10;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                recordaddress       =gBAP_Indication[4] &0x0F;
                if(indexsize)
                {
                    startelement        =gBAP_Indication[5];
                    startelement        +=gBAP_Indication[6] *0x100;
                    elements            =gBAP_Indication[7];
                    elements            +=gBAP_Indication[8]*0x100;
                }
                else
                {    
                    startelement        =gBAP_Indication[5];
                    elements            =gBAP_Indication[6];
                }

                requested_startelement =startelement;
                
                //transmitpos     =TRUE; 
                mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***Startelement=0***/
                if(0==startelement) //Startelement-ID =0 -> start at first array-entry
				{
                    if(FORWARD==direction)  //forward-start
					{ 
                        valid_startelement =0;				       									

                        if(TEL_DIALEDNUMBERS_ENTRIES <=elements) //1. more elements requested, than in array
						{
                            if (shift ==FALSE)  
                            {
                                for(i=0;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
							    {
								    if(0 !=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_DIALEDNUMBERS_ENTRIES;
							    }
                            }
                            else if (shift ==TRUE)
                            {   
                                valid_startelement  =1;
                                startelement        =valid_startelement;

                                for(i=1;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
							    {
								    if(0 !=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_DIALEDNUMBERS_ENTRIES;
							    }
                            }
						}
                        else    //2. number of requested elements < elements in array
						{
                            if (shift ==FALSE)
                            {
							    for(i=0;i<elements;i++)
							    {
								    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_DIALEDNUMBERS_ENTRIES;
							    }
                            }
                            else if (shift ==TRUE)
                            {
                                valid_startelement  =1;
                                startelement        =valid_startelement;

                                for(i=1;i<=elements;i++)
							    {
								    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_DIALEDNUMBERS_ENTRIES;
							    }   
                            }
						}
                    }                                                               //forward ends

                    else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
					{   
						//searching for valid startelement
						for(i=(TEL_DIALEDNUMBERS_ENTRIES-1);i>=0;i--)
						{
							if(0!=gDialedNumbers_ListEntryValidInformation[i])		//found valid startelement
							{
								valid_startelement =i;								
								i =0;												
							}
						}
                        
                        //searching for valid elements
						if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
						{
							valid_startelement  =startelement;
							valid_elements      =0;
						}
						else if(0==valid_startelement)								
							valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
						else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
						{
							for(i=valid_startelement;i>=0;i--)
							{
								if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									valid_elements++;								//increment elements
								else												//no valid element, loop finished
									i=0;
							}
						}
                        else														//enougth array-elements available
						{
							for(i=valid_startelement;i>(valid_startelement-elements);i--)
							{
								if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									valid_elements++;								//increment elements
								else												//no valid element, loop finished
									i=0;
							}
                                      
						}															
				    }                                                               //backward-end
                }                                                                   //startelement ==0 -end

                /***Startelement!=0***/
                else																//searching for Startelement-ID				
				{
					//searching for valid startelement
					for(i=0;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
					{
						if(gDialedNumbers_Pos[i] ==startelement)					    //found a valid element
						{                                          
                            if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
							{
								if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
									valid_startelement =i+1-2*direction;
                                							
                                else if(i==0 && BACKWARD==direction) 
                                    valid_startelement =gDialedNumbers_sum;     //valid element is last element in Array                                                
                            
                                else if(i==0 && FORWARD==direction) 
                                    valid_startelement =0;                          //valid element is first element in Array
                            }
					
                            else
                                valid_startelement =i;                              //found element is valid_startelement

							i=TEL_DIALEDNUMBERS_ENTRIES;
						}
					}

					if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
					{
						valid_startelement  =startelement;
						valid_elements      =0;
					}
					else																//found valid entry for startelement in array
					{
						//verify number of valid elements
						if(BACKWARD==direction)											//backward-start
						{
							if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
								valid_elements=1;
							
							else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
							{
								for(i=valid_startelement;i>=0;i--)
								{
									if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=0;
								}
							}
							else														//enougth array-elements available
							{
								for(i=valid_startelement;i>(valid_startelement-elements);i--)
								{
									if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=0;
								}
							}
						}																//backward-end
						else															//forward-start
						{
							if((valid_startelement+elements)>=TEL_DIALEDNUMBERS_ENTRIES)
							{
								for(i=valid_startelement;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
								{
									//if(0!=gDialedNumbers_Pos[i])						//if there is an valid element
									if(gDialedNumbers_ListEntryValidInformation[i])
                                    	valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=TEL_DIALEDNUMBERS_ENTRIES;
								}
							}
							else
							{
								for(i=valid_startelement;i<(valid_startelement+elements);i++)
								{
									//if(0!=gDialedNumbers_Pos[i])						    //if there is an valid element
									if(gDialedNumbers_ListEntryValidInformation[i])
                                    	valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=TEL_DIALEDNUMBERS_ENTRIES;
								}
							}
						}
					}
				}

                mode =0;     
                mode =DialedNumbers_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);

                //send StatusArray
                DialedNumbers_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                   
                
                //Panel
		        putvalue(env_FSG_DN_ASGID,gDialedNumbers_ASGID);
                putvalue(env_FSG_DN_TAID,gDialedNumbers_TAID);

             break;
            
            case DataSetGet_IND:
                //getData
                gDialedNumbers_ASGID                =(gBAP_Indication[3] &0xF0) /0x10;
                gDialedNumbers_TAID                 =gBAP_Indication[3] &0x0F;
                
                //decode BAP-ArrayHeader
                mode                =(gBAP_Indication[4] &0xF0) /0x10;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                recordaddress       =gBAP_Indication[4] &0x0F;
                if(indexsize)
                {
                    startelement        =gBAP_Indication[5];
                    startelement        +=gBAP_Indication[6] *0x100;
                    elements            =gBAP_Indication[7];
                    elements            +=gBAP_Indication[8]*0x100;

                    Offset =9;
                }
                else
                {    
                    startelement        =gBAP_Indication[5];
                    elements            =gBAP_Indication[6];

                    Offset =7;
                }

                requested_startelement =startelement;
                
                //transmitpos     =FALSE; //Position must always be sent in the case of *.StatusArray.  
                mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***Startelement=0***/
                if(0==startelement) //Startelement-ID =0 -> start at first array-entry
				{
                    if(FORWARD==direction)  //forward-start
					{
                        valid_startelement =0;				       									

                        if(TEL_DIALEDNUMBERS_ENTRIES <=elements) //1. more elements requested, than in array
						{
                            if (shift ==FALSE)  
                            {
                                for(i=0;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
							    {
								    if(0 !=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_DIALEDNUMBERS_ENTRIES;
							    }
                            }
                            else if (shift ==TRUE)
                            {   
                                valid_startelement  =1;
                                startelement        =valid_startelement;

                                for(i=1;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
							    {
								    if(0 !=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_DIALEDNUMBERS_ENTRIES;
							    }
                            }
						}
                        else    //2. number of requested elements < elements in array
						{
                            if (shift ==FALSE)
                            {
							    for(i=0;i<elements;i++)
							    {
								    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_DIALEDNUMBERS_ENTRIES;
							    }
                            }
                            else if (shift ==TRUE)
                            {
                                valid_startelement  =1;
                                startelement        =valid_startelement;

                                for(i=1;i<=elements;i++)
							    {
								    if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									    valid_elements++;								//increment elements
								    else												//no valid element, loop finished
									    i =TEL_DIALEDNUMBERS_ENTRIES;
							    }   
                            }
						}
                    }                                                               //forward ends

                    else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
					{   
						//searching for valid startelement
						for(i=(TEL_DIALEDNUMBERS_ENTRIES-1);i>=0;i--)
						{
							if(0!=gDialedNumbers_ListEntryValidInformation[i])		//found valid startelement
							{
								valid_startelement =i;								
								i =0;												
							}
						}
                        
                        //searching for valid elements
						if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
						{
							valid_startelement  =startelement;
							valid_elements      =0;
						}
						else if(0==valid_startelement)								
							valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
						
						else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
						{
							for(i=valid_startelement;i>=0;i--)
							{
								if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									valid_elements++;								//increment elements
								else												//no valid element, loop finished
									i=0;
							}
						}
                        else														//enougth array-elements available
						{
							for(i=valid_startelement;i>(valid_startelement-elements);i--)
							{
								if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
									valid_elements++;								//increment elements
								else												//no valid element, loop finished
									i=0;
							}
                                      
						}															
				    }                                                               //backward-end
                }                                                                   //startelement ==0 -end

                /***Startelement!=0***/
                else																//searching for Startelement-ID				
				{
					//searching for valid startelement
					for(i=0;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
					{
						if(gDialedNumbers_Pos[i] ==startelement)					    //found a valid element
						{                                          
                            if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
							{
								if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
									valid_startelement =i+1-2*direction;
                                							
                                else if(i==0 && BACKWARD==direction) 
                                    valid_startelement =gDialedNumbers_sum;     //valid element is last element in Array                                                
                            
                                else if(i==0 && FORWARD==direction) 
                                    valid_startelement =0;                          //valid element is first element in Array
                            }
					
                            else
                                valid_startelement =i;                              //found element is valid_startelement

							i=TEL_DIALEDNUMBERS_ENTRIES;
						}
					}

					if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
					{
						valid_startelement  =startelement;
						valid_elements      =0;
					}
					else																//found valid entry for startelement in array
					{
						//verify number of valid elements
						if(BACKWARD==direction)											//backward-start
						{
							if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
								valid_elements=1;
							
							else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
							{
								for(i=valid_startelement;i>=0;i--)
								{
									if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=0;
								}
							}
							else														//enougth array-elements available
							{
								for(i=valid_startelement;i>(valid_startelement-elements);i--)
								{
									if(0!=gDialedNumbers_ListEntryValidInformation[i])	//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=0;
								}
							}
						}																//backward-end
						else															//forward-start
						{
							if((valid_startelement+elements)>=TEL_DIALEDNUMBERS_ENTRIES)
							{
								for(i=valid_startelement;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
								{
									if(0!=gDialedNumbers_Pos[i])						//if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=TEL_DIALEDNUMBERS_ENTRIES;
								}
							}
							else
							{
								for(i=valid_startelement;i<(valid_startelement+elements);i++)
								{
									if(0!=gDialedNumbers_Pos[i])						    //if there is an valid element
										valid_elements++;								//increment elements
									else												//no valid element, loop finished
										i=TEL_DIALEDNUMBERS_ENTRIES;
								}
							}
						}
					}
				}
                
                if(getvalue(env_FSG_DN_SetGetArray_behaviour) && valid_elements>0)
                    DialedNumbers_TakeOverData(Indication_array, Offset, valid_startelement, valid_elements, recordaddress, direction, transmitpos, indexsize);
                
                mode =0;   
                mode =DialedNumbers_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);

                //send StatusArray
                DialedNumbers_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                   
                
                //Panel
		        putvalue(env_FSG_DN_ASGID,gDialedNumbers_ASGID);
                putvalue(env_FSG_DN_TAID,gDialedNumbers_TAID);
                
                //check FSG Cache
                DialedNumbers_CheckCache();

            break;

            case Error_IND:
				writelineEx(gError_Trace, 0, "FSG_Telepfhone DialedNumbers_Indication: received error, errorcode:0x%x", Indication_array[3]);
			break;

		    default:
			    writelineEx(gError_Trace, 0, "FSG_Telepfhone DialedNumbers_Indication: invalid indication %d", Indication_array[2]);
		     break;
	}
}

DialedNumbers_Request (byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{
    int  i;
    byte shift, direction, transmitpos, indexsize;
    dword requestarray [BAP_buffer_size];
    word DialedNumbersLine, current_element, Offset;

	// Init local variables. 
    for(i=0;i<BAP_buffer_size;i++)
	    requestarray [i]=0;
    
    shift               =0;
    direction           =0;
	transmitpos         =0;
	indexsize           =0;
    DialedNumbersLine   =0;
    current_element     =0;
    Offset              =0;

    // decode "mode-byte"
    shift       =mode &0x01;
    direction   =(mode &0x02)/0x02;
	transmitpos =(mode &0x04)/0x04;
	indexsize   =(mode &0x08)/0x08;

	// Handle request.
    requestarray[0] =LSGID_Telephone;				//LSG-ID
	requestarray[1] =FctID_DialedNumbers;		//Fct.-ID
	requestarray[2] =request;                   //request type
	Offset =3;

    switch(request)
	{
		case Changed_REQ:      

            /***ArrayHeader***/
			requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
			Offset++;
            if(indexsize)
            {
                requestarray[Offset] =requested_startelement &0xff;
                Offset++;
                requestarray[Offset] =(requested_startelement &0xff00) /0x100;
                Offset++;
                
                requestarray[Offset] =elements &0xff;
                Offset++;
                requestarray[Offset] =(elements &0xff00) /0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] =requested_startelement;
                Offset++;  
                requestarray[Offset] =elements;
                Offset++;
            }
            
            DialedNumbersLine =startelement;
           
            if(@env_FSG_DN_CA_switch) //if "ArrayHeader + Data"
            {
                //copy data
                switch(recordaddress)
			    {
                    case 0: //complete record
                            while(current_element <elements)
                            {
                                if(DialedNumbersLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone DialedNumbers_Request: invalid DialedNumbersLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gDialedNumbers_Pos[DialedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gDialedNumbers_Pos[DialedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gDialedNumbers_Pos[DialedNumbersLine];
                                            Offset++;
                                        }
                                    }
                                                                                              
                                    //PbName
                                    requestarray[Offset] =strlen(gDialedNumbers_PbName[DialedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gDialedNumbers_PbName[DialedNumbersLine]);i++)
                    			    {
			                            requestarray[Offset] =gDialedNumbers_PbName[DialedNumbersLine][i];	
			                            Offset++;
			                        }
                                
                                    //NumberType
                                    requestarray[Offset] =gDialedNumbers_NumberType[DialedNumbersLine];
                                    Offset++;

                                    //TelNumber
                                    requestarray[Offset] =strlen(gDialedNumbers_TelNumber[DialedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gDialedNumbers_TelNumber[DialedNumbersLine]);i++)
                    			    {
			                            requestarray[Offset] =gDialedNumbers_TelNumber[DialedNumbersLine][i];	
			                            Offset++;
			                        }

                                    //Day
                                    requestarray[Offset] =gDialedNumbers_day[DialedNumbersLine];
                                    Offset++;

                                    //Month
                                    requestarray[Offset] =gDialedNumbers_month[DialedNumbersLine];
                                    Offset++;

                                    //Year
                                    requestarray[Offset] =gDialedNumbers_year[DialedNumbersLine];
                                    Offset++;

                                    //Hour
                                    requestarray[Offset] =gDialedNumbers_hour[DialedNumbersLine];
                                    Offset++;

                                    //Minute
                                    requestarray[Offset] =gDialedNumbers_minute[DialedNumbersLine];
                                    Offset++;

                                    //Second
                                    requestarray[Offset] =gDialedNumbers_second[DialedNumbersLine];
                                    Offset++;

                                }
                                current_element++;
                                DialedNumbersLine =DialedNumbers_nextvalidLine(DialedNumbersLine, direction);
                            
                            }//end while
 
                     break;

                    case 1: //PbName, NumberType
                            while(current_element <elements)
                            {
                                if(DialedNumbersLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone DialedNumbers_Request: invalid DialedNumbersLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gDialedNumbers_Pos[DialedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gDialedNumbers_Pos[DialedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gDialedNumbers_Pos[DialedNumbersLine];
                                            Offset++;
                                        }
                                    }
                                                                                              
                                    //PbName
                                    requestarray[Offset] =strlen(gDialedNumbers_PbName[DialedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gDialedNumbers_PbName[DialedNumbersLine]);i++)
                    			    {
			                            requestarray[Offset] =gDialedNumbers_PbName[DialedNumbersLine][i];	
			                            Offset++;
			                        }
                                
                                    //NumberType
                                    requestarray[Offset] =gDialedNumbers_NumberType[DialedNumbersLine];
                                    Offset++;
                                }
                                current_element++;
                                DialedNumbersLine =DialedNumbers_nextvalidLine(DialedNumbersLine, direction);
                            
                            }//end while
                        
                     break;

                    case 2: //TelNumber, Day, Month, Year, Hour, Minute, Second
                            while(current_element <elements)
                            {
                                if(DialedNumbersLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone DialedNumbers_Request: invalid DialedNumbersLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gDialedNumbers_Pos[DialedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gDialedNumbers_Pos[DialedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gDialedNumbers_Pos[DialedNumbersLine];
                                            Offset++;
                                        }
                                    }

                                    //TelNumber
                                    requestarray[Offset] =strlen(gDialedNumbers_TelNumber[DialedNumbersLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gDialedNumbers_TelNumber[DialedNumbersLine]);i++)
                    			    {
			                            requestarray[Offset] =gDialedNumbers_TelNumber[DialedNumbersLine][i];	
			                            Offset++;
			                        }

                                    //Day
                                    requestarray[Offset] =gDialedNumbers_day[DialedNumbersLine];
                                    Offset++;

                                    //Month
                                    requestarray[Offset] =gDialedNumbers_month[DialedNumbersLine];
                                    Offset++;

                                    //Year
                                    requestarray[Offset] =gDialedNumbers_year[DialedNumbersLine];
                                    Offset++;

                                    //Hour
                                    requestarray[Offset] =gDialedNumbers_hour[DialedNumbersLine];
                                    Offset++;

                                    //Minute
                                    requestarray[Offset] =gDialedNumbers_minute[DialedNumbersLine];
                                    Offset++;

                                    //Second
                                    requestarray[Offset] =gDialedNumbers_second[DialedNumbersLine];
                                    Offset++;

                                }
                                current_element++;
                                DialedNumbersLine =DialedNumbers_nextvalidLine(DialedNumbersLine, direction);
                            
                            }//end while
                        
                     break;

                    case 15: //Pos
                            while(current_element <elements)
                            {
                                if(DialedNumbersLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone DialedNumbers_Request: invalid DialedNumbersLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gDialedNumbers_Pos[DialedNumbersLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gDialedNumbers_Pos[DialedNumbersLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gDialedNumbers_Pos[DialedNumbersLine];
                                            Offset++;
                                        }
                                    }
                                }
                                current_element++;
                                DialedNumbersLine =DialedNumbers_nextvalidLine(DialedNumbersLine, direction);
                            
                            }//end while
                        
                     break;

                    default:
					    write("FSG-Telephone DialedNumbers_Request: invalid recordaddress %d", recordaddress);
				     break;
                } //end switch "recordaddress"
            } //end if "ArrayHeader + Data"       		
		
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);

        break; //end Changed_REQ
        
        
        case Data_REQ:
            //IssueList #62
			if (getValue(env_FSG_Tel_FctList_0x30_TimeOut)!=TRUE)
            {
            requestarray[Offset] =((gDialedNumbers_ASGID *0x10) &0xF0) +(gDialedNumbers_TAID &0x0F);	
            Offset++;
            requestarray[Offset] =gDialedNumbers_TotalNumListElements;	
            Offset++;

            /***ArrayHeader***/
			requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
			Offset++;
            if(indexsize)
            {
                requestarray[Offset] =requested_startelement &0xff;
                Offset++;
                requestarray[Offset] =(requested_startelement &0xff00) /0x100;
                Offset++;
                
                requestarray[Offset] =elements &0xff;
                Offset++;
                requestarray[Offset] =(elements &0xff00) /0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] =requested_startelement;
                Offset++;  
                requestarray[Offset] =elements;
                Offset++;
            }
              
            DialedNumbersLine =startelement;
            
            //copy data
            switch(recordaddress)
			{
                case 0: //complete record 
                        while(current_element <elements)
                        {
                            if(DialedNumbersLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone DialedNumbers_Request: invalid DialedNumbersLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gDialedNumbers_Pos[DialedNumbersLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gDialedNumbers_Pos[DialedNumbersLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gDialedNumbers_Pos[DialedNumbersLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //PbName
                                requestarray[Offset] =strlen(gDialedNumbers_PbName[DialedNumbersLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gDialedNumbers_PbName[DialedNumbersLine]);i++)
                    			{
			                        requestarray[Offset] =gDialedNumbers_PbName[DialedNumbersLine][i];	
			                        Offset++;
			                    }
                                
                                //NumberType
                                requestarray[Offset] =gDialedNumbers_NumberType[DialedNumbersLine];
                                Offset++;

                                //TelNumber
                                requestarray[Offset] =strlen(gDialedNumbers_TelNumber[DialedNumbersLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gDialedNumbers_TelNumber[DialedNumbersLine]);i++)
                    			{
			                        requestarray[Offset] =gDialedNumbers_TelNumber[DialedNumbersLine][i];	
			                        Offset++;
			                    }

                                //Day
                                requestarray[Offset] =gDialedNumbers_day[DialedNumbersLine];
                                Offset++;

                                //Month
                                requestarray[Offset] =gDialedNumbers_month[DialedNumbersLine];
                                Offset++;

                                //Year
                                requestarray[Offset] =gDialedNumbers_year[DialedNumbersLine];
                                Offset++;

                                //Hour
                                requestarray[Offset] =gDialedNumbers_hour[DialedNumbersLine];
                                Offset++;

                                //Minute
                                requestarray[Offset] =gDialedNumbers_minute[DialedNumbersLine];
                                Offset++;

                                //Second
                                requestarray[Offset] =gDialedNumbers_second[DialedNumbersLine];
                                Offset++;

                            }
                            current_element++;
                            DialedNumbersLine =DialedNumbers_nextvalidLine(DialedNumbersLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 1: //PbName, NumberType
                        while(current_element <elements)
                        {
                            if(DialedNumbersLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone DialedNumbers_Request: invalid DialedNumbersLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gDialedNumbers_Pos[DialedNumbersLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gDialedNumbers_Pos[DialedNumbersLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gDialedNumbers_Pos[DialedNumbersLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //PbName
                                requestarray[Offset] =strlen(gDialedNumbers_PbName[DialedNumbersLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gDialedNumbers_PbName[DialedNumbersLine]);i++)
                    			{
			                        requestarray[Offset] =gDialedNumbers_PbName[DialedNumbersLine][i];	
			                        Offset++;
			                    }
                                
                                //NumberType
                                requestarray[Offset] =gDialedNumbers_NumberType[DialedNumbersLine];
                                Offset++;
                            }
                            current_element++;
                            DialedNumbersLine =DialedNumbers_nextvalidLine(DialedNumbersLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 2: //TelNumber, Day, Month, Year, Hour, Minute, Second
                        while(current_element <elements)
                        {
                            if(DialedNumbersLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone DialedNumbers_Request: invalid DialedNumbersLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gDialedNumbers_Pos[DialedNumbersLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gDialedNumbers_Pos[DialedNumbersLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gDialedNumbers_Pos[DialedNumbersLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //TelNumber
                                requestarray[Offset] =strlen(gDialedNumbers_TelNumber[DialedNumbersLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gDialedNumbers_TelNumber[DialedNumbersLine]);i++)
                    			{
			                        requestarray[Offset] =gDialedNumbers_TelNumber[DialedNumbersLine][i];	
			                        Offset++;
			                    }

                                //Day
                                requestarray[Offset] =gDialedNumbers_day[DialedNumbersLine];
                                Offset++;

                                //Month
                                requestarray[Offset] =gDialedNumbers_month[DialedNumbersLine];
                                Offset++;

                                //Year
                                requestarray[Offset] =gDialedNumbers_year[DialedNumbersLine];
                                Offset++;

                                //Hour
                                requestarray[Offset] =gDialedNumbers_hour[DialedNumbersLine];
                                Offset++;

                                //Minute
                                requestarray[Offset] =gDialedNumbers_minute[DialedNumbersLine];
                                Offset++;

                                //Second
                                requestarray[Offset] =gDialedNumbers_second[DialedNumbersLine];
                                Offset++;

                            }
                            current_element++;
                            DialedNumbersLine =DialedNumbers_nextvalidLine(DialedNumbersLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 15: //Pos
                        while(current_element <elements)
                        {
                            if(DialedNumbersLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone DialedNumbers_Request: invalid DialedNumbersLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gDialedNumbers_Pos[DialedNumbersLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gDialedNumbers_Pos[DialedNumbersLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gDialedNumbers_Pos[DialedNumbersLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            DialedNumbersLine =DialedNumbers_nextvalidLine(DialedNumbersLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                default:
					write("FSG-Telephone DialedNumbers_Request: invalid recordaddress %d", recordaddress);
				 break;
            } //end switch "recordaddress"
            } //end if for IssueList #62
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] =errorcode;
			
			set_status_requestbuffer (requestarray, 4, Bap_Error);
         break; //end Error_REQ
    
    } //end switch "request"   
}

DialedNumbers_TakeOverData (dword Indication_array [], word Offset, word startelement, word elements, byte recordaddress, byte direction, byte transmitpos, byte indexsize)
{
    int i =0, j =0, length =0;
    word current_DialedNumbersLine =0;

    //write("IndicationArray[%d], startelement =0x%x, elemente =%d, recordaddress =0x%x, direction =%d, transimtPos =%d, IS =%d", Offset, startelement, elements, recordaddress, shift, direction, transmitpos, indexsize);

    for(i=0;i<TEL_DIALEDNUMBERS_ENTRIES;i++)
    {
        if(gDialedNumbers_Pos[i] ==startelement)
        {
            current_DialedNumbersLine =i;
                        
            i =TEL_DIALEDNUMBERS_ENTRIES;
        }
    }

    /***copy elements***/
    for (i=0; i<elements; i++)
    {
        switch (recordaddress)
        {
            case 0: //recordaddress =0 -> complete record
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gDialedNumbers_Pos[current_DialedNumbersLine] =Indication_array [Offset];
                            Offset++;
                            gDialedNumbers_Pos[current_DialedNumbersLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gDialedNumbers_Pos[current_DialedNumbersLine] =Indication_array[Offset];
            
                        Offset++;
                    }

                    //PbName
                    for(j=0; j<TEL_DIALEDNUMBERS_PBNAME_LENGTH;j++) //clear
                        gDialedNumbers_PbName[current_DialedNumbersLine][j] =0; 
                                   
                    length =Indication_array[Offset];
                    Offset++;

                    if(length ==0) //list element cleared by ASG ('empty string')
                        gDialedNumbers_ListEntryValidInformation[current_DialedNumbersLine] =0;
                        
                                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gDialedNumbers_PbName[current_DialedNumbersLine][j] =Indication_array[Offset];
                        Offset++;
                    }
                    
                    //NumberType
                    gDialedNumbers_NumberType[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;

                    //TelNumber
                    for(j=0; j<TEL_DIALEDNUMBERS_TELNUMBER_LENGTH;j++) //clear
			            gDialedNumbers_TelNumber[current_DialedNumbersLine][j] =0; 
                                    
                                         
                    length =Indication_array[Offset];
                    Offset++;
                                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gDialedNumbers_TelNumber[current_DialedNumbersLine][j] =Indication_array[Offset];
                        Offset++;
                    }

                    //Day
                    gDialedNumbers_day[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;


                    //Month
                    gDialedNumbers_month[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
                      

                    //Year
                    gDialedNumbers_year[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Hour
                    gDialedNumbers_hour[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
                    

                    //Minute
                    gDialedNumbers_minute[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Second
                    gDialedNumbers_second[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    
            break;

            case 1: //recordaddress =1 -> PbName, NumberType
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gDialedNumbers_Pos[current_DialedNumbersLine] =Indication_array [Offset];
                            Offset++;
                            gDialedNumbers_Pos[current_DialedNumbersLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gDialedNumbers_Pos[current_DialedNumbersLine] =Indication_array[Offset];
            
                        Offset++;
                    }

                    //PbName
                    for(j=0; j<TEL_DIALEDNUMBERS_PBNAME_LENGTH;j++) //clear
			            gDialedNumbers_PbName[current_DialedNumbersLine][j] =0; 
                                    
                                         
                    length =Indication_array[Offset];
                    Offset++;
                                    
                    
                    if(length ==0) //list element cleared by ASG ('empty string')
                        gDialedNumbers_ListEntryValidInformation[current_DialedNumbersLine]=0;
                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gDialedNumbers_PbName[current_DialedNumbersLine][j] =Indication_array[Offset];
                        Offset++;
                    }
                    
                    //NumberType
                    gDialedNumbers_NumberType[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    
            break;//recordaddress =2 ends

            case 2: //recordaddress =2 -> TelNumber, Day, Month, Year, Hour, Minute, Second
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gDialedNumbers_Pos[current_DialedNumbersLine] =Indication_array [Offset];
                            Offset++;
                            gDialedNumbers_Pos[current_DialedNumbersLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gDialedNumbers_Pos[current_DialedNumbersLine] =Indication_array[Offset];
            
                        Offset++;
                    }

                    //TelNumber
                    for(j=0; j<TEL_DIALEDNUMBERS_TELNUMBER_LENGTH;j++) //clear
			            gDialedNumbers_TelNumber[current_DialedNumbersLine][j] =0; 
                                    
                                         
                    length =Indication_array[Offset];
                    Offset++;
                                    
                    for(j=0; j<length;j++) //copy data
                    {   
                        gDialedNumbers_TelNumber[current_DialedNumbersLine][j] =Indication_array[Offset];
                        Offset++;
                    }

                    //Day
                    gDialedNumbers_day[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;


                    //Month
                    gDialedNumbers_month[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
                      

                    //Year
                    gDialedNumbers_year[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Hour
                    gDialedNumbers_hour[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
                    

                    //Minute
                    gDialedNumbers_minute[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
                                    

                    //Second
                    gDialedNumbers_second[current_DialedNumbersLine] =Indication_array[Offset];
                    Offset++;
            break;

            case 15: //recordaddress =0xf -> Pos
                    //Pos
                    if(transmitpos)
                    {
                        if(indexsize)
                        {
                            gDialedNumbers_Pos[current_DialedNumbersLine] =Indication_array [Offset];
                            Offset++;
                            gDialedNumbers_Pos[current_DialedNumbersLine] +=Indication_array[Offset] *0x100;
                        }
                        else
                            gDialedNumbers_Pos[current_DialedNumbersLine] =Indication_array[Offset];
            
                        Offset++;
                    }

            break; //recordaddress =0xf ends

        }// end switch recordaddress

        current_DialedNumbersLine =DialedNumbers_nextvalidLine (current_DialedNumbersLine, direction);
    } //end 'for' -> copy elements
}

byte DialedNumbers_buildModeByte (word requested_startelement, word startelement, word elements, byte shift, byte direction, byte transmitpos, byte indexsize)
{    
    int  i;
    word DialedNumbersLine;
    byte mode;
    
    //init variables
    indexsize           =0;
    i                   =0;
    DialedNumbersLine =0;    
    mode                =0;
    
    if(requested_startelement >0xFE)
        indexsize =TRUE;

    else
    {  
        DialedNumbersLine =startelement;
                
        while(i <elements)
        {   
            if(DialedNumbersLine ==0xff) //Invalid "list entry"
                i =elements;

            else //"list entry" valid
            {   
                if(gDialedNumbers_Pos[DialedNumbersLine] >0xFE)
                    indexsize =TRUE;
            }
            i++;
            DialedNumbersLine =DialedNumbers_nextvalidLine(DialedNumbersLine, direction);
                            
        }//end while
    }//end else
    
    //build mode byte
    mode    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

    return (mode);
}

DialedNumbers_init_CSV () //Byte & file selection
{
    dword CSVfileHandle =0, ConfigFileHandle =0, i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
    char buffer_string[TEL_BUFFERSIZE], Path_CSV[TEL_BUFFERSIZE], Path_Config[TEL_BUFFERSIZE];
    byte buffer_byte[TEL_BUFFERSIZE];
    word DialedNumbersLine =0;
    char DialedNumbers_Pos_string [TEL_DIALEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
    char DialedNumbers_NumberType_string [TEL_DIALEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];   //help value ->"NumberType" is stored in the ASCII(UTF-8) code in the *.csv 
    char DialedNumbers_Day_string [TEL_DIALEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];        //help value ->"Day" is stored in the ASCII(UTF-8) code in the *.csv 
    char DialedNumbers_Month_string [TEL_DIALEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];      //help value ->"Month" is stored in the ASCII(UTF-8) code in the *.csv 
    char DialedNumbers_Year_string [TEL_DIALEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];       //help value ->"Year" is stored in the ASCII(UTF-8) code in the *.csv 
    char DialedNumbers_Hour_string [TEL_DIALEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];       //help value ->"Hour" is stored in the ASCII(UTF-8) code in the *.csv 
    char DialedNumbers_Minute_string [TEL_DIALEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];     //help value ->"Minute" is stored in the ASCII(UTF-8) code in the *.csv 
    char DialedNumbers_Second_string [TEL_DIALEDNUMBERS_ENTRIES][TEL_TEXTLENGTH];     //help value ->"Second" is stored in the ASCII(UTF-8) code in the *.csv 

    if(getvalue(env_FSG_DN_DataSource) == TEL_EXTERNAL_LIST) //output data in write window "FSgDialedNumbers"  
    {
        writeClear(gDialedNumbers_writeWindow);
        writelineEx(gDialedNumbers_writeWindow, 0,"*******External DialedNumbers*******");
        writelineEx(gDialedNumbers_writeWindow, 0, "");
        writelineEx(gDialedNumbers_writeWindow, 0, "**********************Start load new DialedNumbers**********************");   
    
        //clear  
	    for(j=0;j<TEL_DIALEDNUMBERS_ENTRIES;j++) 
	    {
		gDialedNumbers_Pos[j]                       =0;
        
        for(i=0;i<TEL_DIALEDNUMBERS_PBNAME_LENGTH;i++)
			gDialedNumbers_PbName[j][i] =0;

        gDialedNumbers_NumberType[j]                  =0;
        
        for(i=0;i<TEL_DIALEDNUMBERS_TELNUMBER_LENGTH;i++)
			gDialedNumbers_TelNumber[j][i] =0;

        gDialedNumbers_day[j]     =0;
        gDialedNumbers_month[j]   =0;
        gDialedNumbers_year[j]    =0;
        gDialedNumbers_hour[j]    =0;
        gDialedNumbers_minute[j]  =0;
        gDialedNumbers_second[j]  =0;

        gDialedNumbers_ListEntryValidInformation[j] =0;
	    }

        for(i=0;i<TEL_FILENAME_SIZE; i++) //clear "filename"
            gDialedNumbers_CSV_filename[i] =0;       
        
        for(j=0;j<TEL_DIALEDNUMBERS_ENTRIES; j++) //clear "buffer"
        {
            buffer_string[j]    =0;
            buffer_byte[j]      =0;

            for(i=0;i<TEL_TEXTLENGTH;i++) //clear help value
		    {
                DialedNumbers_Pos_string[j][i]        =0;
                DialedNumbers_NumberType_string[j][i]   =0;
                DialedNumbers_Day_string[j][i]        =0;
                DialedNumbers_Month_string[j][i]      =0;
                DialedNumbers_Year_string[j][i]       =0;
                DialedNumbers_Hour_string[j][i]       =0;
                DialedNumbers_Minute_string[j][i]     =0;
                DialedNumbers_Second_string[j][i]     =0;
            }
        }        

        i =0; j =0; DialedNumbersLine =0; current_CSV_line =0; //reset values 
                      
        getvalue(env_FSG_DN_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        
        //write("complete path *.csv: %s", Path_CSV); //debug
        
        i =0;

        while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after last "\"
            {              
                gDialedNumbers_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
                count2++;
                               
            i++;
        }

        writelineEx(gDialedNumbers_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 

        writelineEx(gDialedNumbers_writeWindow, 0,"filename of *.csv: '%s'", gDialedNumbers_CSV_filename);  //output filename 

        putvalue(env_FSG_DN_DataSource_file, gDialedNumbers_CSV_filename); //output current loaded *.csv-file on panel

        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gDialedNumbers_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

        if (CSVfileHandle!=0) //*.csv file access successful
        {
            writelineEx(gDialedNumbers_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gDialedNumbers_CSV_filename);    //output result  
            
            putvalue(env_FSG_DN_DataSource_result, "successful");   //output result on panel                      
            
            Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
                          
            for (i=0; i<Num_of_csv_byte; i++) //copy data into "DialedNumbers"
            {      
                if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
                {
                    if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in DialedNumbers) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                    {
                        if(current_CSV_line>0 && DialedNumbersLine<TEL_DIALEDNUMBERS_ENTRIES) //ignore first line in *.csv file
                        {   
                            writelineEx(gDialedNumbers_writeWindow, 0, "");
                            writelineEx(gDialedNumbers_writeWindow, 0,"*******Element %d*******",DialedNumbersLine);

                            //transform 'string' to 'long' for "POS", "NumberType", "Day", "Month", "Year", "Hour", "Minute" and "Second"
                            gDialedNumbers_Pos[DialedNumbersLine]           =atol(DialedNumbers_Pos_string[DialedNumbersLine]);
                            gDialedNumbers_NumberType[DialedNumbersLine]      =atol(DialedNumbers_NumberType_string[DialedNumbersLine]);                        
                            gDialedNumbers_day[DialedNumbersLine]           =atol(DialedNumbers_Day_string[DialedNumbersLine]);
                            gDialedNumbers_month[DialedNumbersLine]         =atol(DialedNumbers_Month_string[DialedNumbersLine]);
                            gDialedNumbers_year[DialedNumbersLine]          =atol(DialedNumbers_Year_string[DialedNumbersLine]);
                            gDialedNumbers_hour[DialedNumbersLine]          =atol(DialedNumbers_Hour_string[DialedNumbersLine]);
                            gDialedNumbers_minute[DialedNumbersLine]        =atol(DialedNumbers_Minute_string[DialedNumbersLine]);
                            gDialedNumbers_second[DialedNumbersLine]        =atol(DialedNumbers_Second_string[DialedNumbersLine]);

                            writelineEx(gDialedNumbers_writeWindow, 0,"Pos[%d]: 0x%x",DialedNumbersLine, gDialedNumbers_Pos[DialedNumbersLine]);
                            
                            writelineEx(gDialedNumbers_writeWindow, 0,"PbName[%d]: %s",DialedNumbersLine, gDialedNumbers_PbName[DialedNumbersLine]);

                            writelineEx(gDialedNumbers_writeWindow, 0,"NumberType[%d]: 0x%x",DialedNumbersLine, gDialedNumbers_NumberType[DialedNumbersLine]);
                            if(gDialedNumbers_NumberType[DialedNumbersLine] <0x04)
                                writeEx(gDialedNumbers_writeWindow, 0," -> '%s'", gDialedNumbers_NumberType_s[gDialedNumbers_NumberType[DialedNumbersLine]]);
                            else
                                writeEx(gDialedNumbers_writeWindow, 0," -> '%s'", gstring_reserved);

                            writelineEx(gDialedNumbers_writeWindow, 0,"TelNumber[%d]: %s",DialedNumbersLine, gDialedNumbers_TelNumber[DialedNumbersLine]);
                            
                            writelineEx(gDialedNumbers_writeWindow, 0,"Day[%d]: 0%d",DialedNumbersLine, gDialedNumbers_day[DialedNumbersLine]);
                            
                            writelineEx(gDialedNumbers_writeWindow, 0,"Month[%d]: 0%d",DialedNumbersLine, gDialedNumbers_month[DialedNumbersLine]);

                            writelineEx(gDialedNumbers_writeWindow, 0,"Year[%d]: 0%d",DialedNumbersLine, gDialedNumbers_year[DialedNumbersLine]);

                            writelineEx(gDialedNumbers_writeWindow, 0,"Hour[%d]: 0%d",DialedNumbersLine, gDialedNumbers_hour[DialedNumbersLine]);

                            writelineEx(gDialedNumbers_writeWindow, 0,"Minute[%d]: 0%d",DialedNumbersLine, gDialedNumbers_minute[DialedNumbersLine]);

                            writelineEx(gDialedNumbers_writeWindow, 0,"Second[%d]: 0%d",DialedNumbersLine, gDialedNumbers_second[DialedNumbersLine]);

                            gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]  =TRUE;
                                                
                            DialedNumbersLine++; // -> next line in *.csv (next record element)
                        }

                        current_CSV_line++; //next line in *.csv file
                        element =0; //start at 'POS' (first record element of "array data")
                        j=0; //reset value
                    }
                      
                    else if(current_CSV_line>0 && DialedNumbersLine<TEL_DIALEDNUMBERS_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                    {
                        switch (element)
                        {
                            case 0: //POS
                                    DialedNumbers_Pos_string[DialedNumbersLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //PbName
                                    gDialedNumbers_PbName[DialedNumbersLine][j] =buffer_byte[i];
                                    j++; 
                             break;
                            
                            case 2: //NumberType
                                    DialedNumbers_NumberType_string[DialedNumbersLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;
                            
                            case 3: //TelNumber
                                    gDialedNumbers_TelNumber[DialedNumbersLine][j] =buffer_byte[i];
                                    j++; 
                             break;

                            case 4: //Day
                                    DialedNumbers_Day_string[DialedNumbersLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 5: //Month
                                    DialedNumbers_Month_string[DialedNumbersLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 6: //Year
                                    DialedNumbers_Year_string[DialedNumbersLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;
                            
                            case 7: //Hour
                                    DialedNumbers_Hour_string[DialedNumbersLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 8: //Minute
                                    DialedNumbers_Minute_string[DialedNumbersLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 9: //Second
                                    DialedNumbers_Second_string[DialedNumbersLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            default:
                             break;
                        }
                    }                               
                }
                               
                else  // ";" is detected ->next record element of "array data"
                {                                          
                    element++;
                    j=0; //reset value  
                }                                              
        
            }         
            
            gDialedNumbers_TotalNumListElements =gDialedNumbers_sum =DialedNumbersLine; //get "total number of list elements"
            
            putvalue(env_FSG_DN_TotalNumLE, gDialedNumbers_TotalNumListElements);

            writelineEx(gDialedNumbers_writeWindow, 0, "");

            writelineEx(gDialedNumbers_writeWindow, 0,"Anzahl der Listenelemente: %d", gDialedNumbers_sum); //output total number of list elements

            writelineEx(gDialedNumbers_writeWindow, 0, "");

            if(fileClose (CSVfileHandle) !=0) //close *.csv file
                writelineEx(gDialedNumbers_writeWindow, 0,"Datei '%s' geschlossen", gDialedNumbers_CSV_filename); //output result
             
            else
                writelineEx(gDialedNumbers_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gDialedNumbers_CSV_filename);//output result
        }

        else //*.csv file access not successful
        {
            writelineEx(gDialedNumbers_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gDialedNumbers_CSV_filename); //output result
            
            putvalue(env_FSG_DN_DataSource_result,"not successful"); //output result
        }
    }
}

DialedNumbers_init_static()
{
    word j, i, DialedNumbersLine;

    //clear
    DialedNumbersLine =0;
    gDialedNumbers_sum  =0;

	for(j=0;j<TEL_DIALEDNUMBERS_ENTRIES;j++) 
	{
		gDialedNumbers_Pos[j]                       =0;
        
        for(i=0;i<TEL_DIALEDNUMBERS_PBNAME_LENGTH;i++)
			gDialedNumbers_PbName[j][i] =0;

        gDialedNumbers_NumberType[j]                =0;
        
        for(i=0;i<TEL_DIALEDNUMBERS_TELNUMBER_LENGTH;i++)
			gDialedNumbers_TelNumber[j][i] =0;

        gDialedNumbers_day[j]     =0;
        gDialedNumbers_month[j]   =0;
        gDialedNumbers_year[j]    =0;
        gDialedNumbers_hour[j]    =0;
        gDialedNumbers_minute[j]  =0;
        gDialedNumbers_second[j]  =0;

        gDialedNumbers_ListEntryValidInformation[j] =0;
	}
	  	
    //entry 0
	gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x00;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_0",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_UNKNOWN;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_0",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =1;  
    gDialedNumbers_month [DialedNumbersLine]    =2; 
    gDialedNumbers_year [DialedNumbersLine]     =50; 
    gDialedNumbers_hour [DialedNumbersLine]     =21; 
    gDialedNumbers_minute [DialedNumbersLine]   =4; 
    gDialedNumbers_second [DialedNumbersLine]   =9;                         
    
    DialedNumbersLine++;

    //entry 1
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x01;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_1",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_GENERAL;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_1",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =0xFF;  
    gDialedNumbers_month [DialedNumbersLine]    =0xFF; 
    gDialedNumbers_year [DialedNumbersLine]     =0xFF; 
    gDialedNumbers_hour [DialedNumbersLine]     =0xFF; 
    gDialedNumbers_minute [DialedNumbersLine]   =0xFF; 
    gDialedNumbers_second [DialedNumbersLine]   =0xFF;                         
    
    DialedNumbersLine++;

    //entry 2
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x02;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_2",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_MOBILE;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_2",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =5;  
    gDialedNumbers_month [DialedNumbersLine]    =4; 
    gDialedNumbers_year [DialedNumbersLine]     =2; 
    gDialedNumbers_hour [DialedNumbersLine]     =9; 
    gDialedNumbers_minute [DialedNumbersLine]   =34; 
    gDialedNumbers_second [DialedNumbersLine]   =54;                         
    
    DialedNumbersLine++;

    //entry 3
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x03;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_3",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_OFFICE;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_3",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =30;  
    gDialedNumbers_month [DialedNumbersLine]    =5; 
    gDialedNumbers_year [DialedNumbersLine]     =84; 
    gDialedNumbers_hour [DialedNumbersLine]     =5; 
    gDialedNumbers_minute [DialedNumbersLine]   =0; 
    gDialedNumbers_second [DialedNumbersLine]   =0;                         
    
    DialedNumbersLine++;

    //entry 4
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x04;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_4",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_HOME;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_4",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =31;  
    gDialedNumbers_month [DialedNumbersLine]    =7; 
    gDialedNumbers_year [DialedNumbersLine]     =83; 
    gDialedNumbers_hour [DialedNumbersLine]     =10; 
    gDialedNumbers_minute [DialedNumbersLine]   =15; 
    gDialedNumbers_second [DialedNumbersLine]   =1;                         
    
    DialedNumbersLine++;

    //entry 5
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x05;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_5",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_FAX;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_5",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =9;  
    gDialedNumbers_month [DialedNumbersLine]    =11; 
    gDialedNumbers_year [DialedNumbersLine]     =4; 
    gDialedNumbers_hour [DialedNumbersLine]     =8; 
    gDialedNumbers_minute [DialedNumbersLine]   =7; 
    gDialedNumbers_second [DialedNumbersLine]   =33;                         
    
    DialedNumbersLine++;

    //entry 6
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x06;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_6",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_PAGER;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_6",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =6;  
    gDialedNumbers_month [DialedNumbersLine]    =5; 
    gDialedNumbers_year [DialedNumbersLine]     =30; 
    gDialedNumbers_hour [DialedNumbersLine]     =18; 
    gDialedNumbers_minute [DialedNumbersLine]   =14; 
    gDialedNumbers_second [DialedNumbersLine]   =45;                         
    
    DialedNumbersLine++;

    //entry 7
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x07;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_7",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_CAR;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_7",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =21;  
    gDialedNumbers_month [DialedNumbersLine]    =1; 
    gDialedNumbers_year [DialedNumbersLine]     =31; 
    gDialedNumbers_hour [DialedNumbersLine]     =23; 
    gDialedNumbers_minute [DialedNumbersLine]   =29; 
    gDialedNumbers_second [DialedNumbersLine]   =30;                         
    
    DialedNumbersLine++;

    //entry 8
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x08;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_8",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_SIM;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_8",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =16;  
    gDialedNumbers_month [DialedNumbersLine]    =2; 
    gDialedNumbers_year [DialedNumbersLine]     =8; 
    gDialedNumbers_hour [DialedNumbersLine]     =15; 
    gDialedNumbers_minute [DialedNumbersLine]   =59; 
    gDialedNumbers_second [DialedNumbersLine]   =59;                         
    
    DialedNumbersLine++;

    //entry 9
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x09;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_9",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_MAINOFFICE;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_9",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =31;  
    gDialedNumbers_month [DialedNumbersLine]    =12; 
    gDialedNumbers_year [DialedNumbersLine]     =99; 
    gDialedNumbers_hour [DialedNumbersLine]     =23; 
    gDialedNumbers_minute [DialedNumbersLine]   =59; 
    gDialedNumbers_second [DialedNumbersLine]   =59;                         
    
    DialedNumbersLine++;

    //entry 10
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x0A;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_10",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_MAINHOME;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_10",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =1;  
    gDialedNumbers_month [DialedNumbersLine]    =1; 
    gDialedNumbers_year [DialedNumbersLine]     =0xFF; 
    gDialedNumbers_hour [DialedNumbersLine]     =0; 
    gDialedNumbers_minute [DialedNumbersLine]   =0; 
    gDialedNumbers_second [DialedNumbersLine]   =0;                         
    
    DialedNumbersLine++;

    //entry 11
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x0B;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_11",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_MAINHOME;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_11",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =11;  
    gDialedNumbers_month [DialedNumbersLine]    =11; 
    gDialedNumbers_year [DialedNumbersLine]     =11; 
    gDialedNumbers_hour [DialedNumbersLine]     =11; 
    gDialedNumbers_minute [DialedNumbersLine]   =11; 
    gDialedNumbers_second [DialedNumbersLine]   =11;                         
    
    DialedNumbersLine++;

    //entry 12
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x0C;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_12",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_CELLOFFICE;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_12",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =1;  
    gDialedNumbers_month [DialedNumbersLine]    =1; 
    gDialedNumbers_year [DialedNumbersLine]     =0; 
    gDialedNumbers_hour [DialedNumbersLine]     =0; 
    gDialedNumbers_minute [DialedNumbersLine]   =0; 
    gDialedNumbers_second [DialedNumbersLine]   =0;                         
    
    DialedNumbersLine++;

    //entry 13
    gDialedNumbers_ListEntryValidInformation[DialedNumbersLine]     =TRUE;
    gDialedNumbers_Pos [DialedNumbersLine]                          =0x0D;
    strncpy(gDialedNumbers_PbName [DialedNumbersLine], "PbName_13",TEL_DIALEDNUMBERS_PBNAME_LENGTH);

    gDialedNumbers_NumberType [DialedNumbersLine]                     =TEL_DIALEDNUMBERS_FAXHOME;
    
    strncpy(gDialedNumbers_TelNumber [DialedNumbersLine], "TelNumber_13",TEL_DIALEDNUMBERS_TELNUMBER_LENGTH);
    
    gDialedNumbers_day [DialedNumbersLine]      =31;  
    gDialedNumbers_month [DialedNumbersLine]    =2; 
    gDialedNumbers_year [DialedNumbersLine]     =20; 
    gDialedNumbers_hour [DialedNumbersLine]     =8; 
    gDialedNumbers_minute [DialedNumbersLine]   =9; 
    gDialedNumbers_second [DialedNumbersLine]   =10;                         
    
    DialedNumbersLine++; 
    
    gDialedNumbers_sum                    =DialedNumbersLine;
    gDialedNumbers_TotalNumListElements   =gDialedNumbers_sum;

/*
    //write Array in "write-window"
    writeClear(gDialedNumbers_writeWindow);
    writelineEx(gDialedNumbers_writeWindow, 0, "");
    writelineEx(gDialedNumbers_writeWindow, 0,"*******Default DialedNumbers_Array*******");
    writelineEx(gDialedNumbers_writeWindow, 0, "");
    
    for (i=0;i<gDialedNumbers_sum;i++)
    {
        writelineEx(gDialedNumbers_writeWindow, 0,"*******Element %d*******",i);
        
        writelineEx(gDialedNumbers_writeWindow, 0,"Pos[%d]: 0x%x", i, gDialedNumbers_Pos [i]);
                     
        writelineEx(gDialedNumbers_writeWindow, 0,"PbName[%d]: '%s'", i, gDialedNumbers_PbName[i]);

        writelineEx(gDialedNumbers_writeWindow, 0,"NumberType[%d]: 0x%x",i, gDialedNumbers_NumberType[i]);
        if(gDialedNumbers_NumberType[i] <0x0F)
             writeEx(gDialedNumbers_writeWindow, 0," -> '%s'", gDialedNumbers_NumberType_s[gDialedNumbers_NumberType[i]]);
        else
             writeEx(gDialedNumbers_writeWindow, 0," -> '%s'", gstring_reserved);
        
        writelineEx(gDialedNumbers_writeWindow, 0,"TelNumber[%d]: '%s'", i, gDialedNumbers_TelNumber[i]);

        writelineEx(gDialedNumbers_writeWindow, 0,"Day[%d]: %d",i, gDialedNumbers_day[i]);

        writelineEx(gDialedNumbers_writeWindow, 0,"Month[%d]: %d",i, gDialedNumbers_month[i]);

        writelineEx(gDialedNumbers_writeWindow, 0,"Year[%d]: %d",i, gDialedNumbers_year[i]);

        writelineEx(gDialedNumbers_writeWindow, 0,"Hour[%d]: %d",i, gDialedNumbers_hour[i]);

        writelineEx(gDialedNumbers_writeWindow, 0,"Minute[%d]: %d",i, gDialedNumbers_minute[i]);

        writelineEx(gDialedNumbers_writeWindow, 0,"Second[%d]: %d",i, gDialedNumbers_second[i]);

        writelineEx(gDialedNumbers_writeWindow, 0, "");
    }

    writelineEx(gDialedNumbers_writeWindow, 0,"Anzahl der Listenelemente: %d", gDialedNumbers_sum);
*/    
    putvalue(env_FSG_DN_TotalNumLE, gDialedNumbers_TotalNumListElements);
}

byte DialedNumbers_nextvalidLine (word current_DialedNumbersLine, byte direction)
{
    word next_DialedNumbersLine;
    int i;
         
    //init lokal variables
    next_DialedNumbersLine    =0;
    i                           =0;

    //search next "list entry"
    if(((gDialedNumbers_sum-1)==current_DialedNumbersLine && FORWARD ==direction) || (0 ==current_DialedNumbersLine && BACKWARD ==direction))	//last-/fist-element of array reached
	    next_DialedNumbersLine =0xFF;
	else
	{
			next_DialedNumbersLine =current_DialedNumbersLine +1-2*direction;       //increment or decrement array-line (depends on direction);
                 
            if(0 ==gDialedNumbers_ListEntryValidInformation[next_DialedNumbersLine])	// check if next element is "valid"
			    next_DialedNumbersLine =0xff; 					
	}

    return(next_DialedNumbersLine);
}

DialService_Indication(dword Indication_array [], byte indication, int datalength)
{
    int i, provider, nulength, nalength, is_emergency_call;
    provider = 0;
    nulength = 0;
    nalength = 0;


    //write("# (FSG) DialService_Indication");
    //write("# (FSG) DialService_Indication gDialService_status: %d, gDialService_Enabled: %d", gDialService_status, gDialService_Enabled);
    //DialService_Request(Processing_REQ, 0);	
	
	switch(indication)
	{
        case Processing_CNF:
            //write("# --> send Processing_REQ ((FSG) DialService_Indication)");
			//IssueList #57  and #74
           if (((getValue(env_FSG_Tel_DialServ_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_DialServ_ErrorCode) > 0x3F)) && (gTelFctList_0x1B_TimeOut_flg == 0x00))
            {
            DialService_Request(Processing_REQ, 0);	
                
                //IssueList #68
                if (gTelFctList_0x1B_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x1B_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x1B_ProcessingTimer,TELMAXPROCESSINGTIME);

                DialService_Request(Processing_REQ, 0);
                }
             }
        break;
        case StartResult_IND:
            //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x1B_TimeOut)!=TRUE)
            {
            gTelFctList_0x1B_TimeOut_flg = 0x00;
                if(datalength != 4) // BAP-array datalength error
    			{
    				DialService_Request(Error_REQ, Terror_datainvalid); // send error-message
    				break;
    			}

                //IssueList #57
                if (getValue(env_FSG_Tel_DialServ_Error_On)==0x00)
                putValue(env_FSG_Tel_DialServ_ErrorCode,0);
                
                //IssueList #47
                if (getValue(env_FSG_Tel_DialServ_Error_On))
                {
                    DialService_Request(Error_REQ, getValue(env_FSG_Tel_DialServ_ErrorCode)); // send error-message
                    break;
                }

                //IssueList #26
                if (getValue(env_FSG_DialService_Result)!=0x00)
                {
                 gDialService_Result = getValue(env_FSG_DialService_Result);								
        		 DialService_Request(Result_REQ, 0);	
        		 gDialNumber_status = 0;
                 gDialService_status = 0;
                 break;
                 }

                if(gDialService_status != 0 || gDialNumber_status != 0) // DialService or DialNumber is still active 
    			{
    				if(gDialNumber_status != 0)
                        write("dial number still active");
                    if(gDialService_status != 0)
                        write("dial service still active");
                
                    gDialService_Result = 0x01;//not successful;   
                    DialService_Request(Result_REQ, 0);
    			}            

                gCallStartedFromASG = 1; 
    			gDialService_status = 1;	//method "DialService" is now active
                gDialNumber_status = 1; // prevent use of DialNumber

    			for(i = 0; i < CALL_INFO_NUMBER_LENGTH; i++)
    				gDialNumber[i] = 0;
    			for(i = 0; i < DIAL_NUMBER_NAME_LENGTH; i++)
    				gDialNumber_name[i] = 0;

                // set number, name, number length, name length
                gDialService_type = Indication_array[3];
                //IssueList #26
                putValue(env_FSG_DialService_Type,gDialService_type);

                nulength = strlen(gDialService_ServiceNumbers[gDialService_type]);
                nalength = strlen(gDialService_ServiceNames[gDialService_type]);                  
                for (i=0; i<nulength; i++)		
    				gDialNumber[i] = gDialService_ServiceNumbers[gDialService_type][i];
                for(i = 0; i < nalength; i++) 
            	    gDialNumber_name[i] = gDialService_ServiceNames[gDialService_type][i]; 
  

                // GMS-module or mobile not active ?
                if(PhoneModuleOn != gTel_State && MobileOn != gTel_State) 
    			{
                    gDialService_Result = 0x05; // not successful, no network
    				DialService_Request(Result_REQ, 0);
    				gDialNumber_status = 0;
                    gDialService_status = 0;
                    break;
    			}

                is_emergency_call = detect_emergency_number();

        		//IssueList #42
                //if(gRegisterState != 1) // not registered
                if((gRegisterState != 1)&&(gRegisterState != 4)&&(gRegisterState != 5))
        		{
                    if(is_emergency_call != 1) // not registered and no emergency call
                    {
                        gDialService_Result = NOT_SUCCESSFUL;								
        				DialService_Request(Result_REQ, 0);	
        				gDialNumber_status = 0;
                        gDialService_status = 0;
                        break;
                    }
                    else
                    {
                        if (gLockState != nolock) //emergency call but not registered and no SIM
        					gemergencycall=3;
        				else //emergency call but not registered and SIM OK
        					gemergencycall=2;	

                        // search for provider
        				while(provider == 0)
        					provider = random(4);
    
                        putvalue(env_FSG_NetworkProviderState, 1);
        				//putvalue(env_FSG_networkprovider, provider); //new provider
                    }
                }
                else
                {
                    gemergencycall = (is_emergency_call == 1) ? 1 : 0;

                    if(gConfirmCall == 1) // call needs to be confirmed manually ?
                    {
                        //write("call needs confirmation");                    

                        gCallOutgoingDiverted_eCallConfirmationPending[7] = 1;
                        CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = true


                        gDialService_Result = 0x0a; // not successful - confirm emergency call
                        DialService_Request(Result_REQ, 0);
                    }
                    else
                    {
                        //write("call does not need confirmation");

                        gcallID = callstates_status(dialing); //aks for free Call-ID
            
                        if(gcallID == 0xff)
                        {
                            DialService_Request(Error_REQ, Terror_activecallpresentdialing);	//send error
    						gDialNumber_status = 0;
                            gDialService_status = 0;
                            break;
                        }
            
                        settimer(checknetworktimer, gtime_checknetworktimer);
                    }   
                }
            }
            else
            gTelFctList_0x1B_TimeOut_flg = 0x01;
            break;
        default:
		    writelineEx(gError_Trace, 0, "FSG-Telephone DialService Indication: unknown indication %d", indication);
		break;
	}
}

/*
DialService_Indication(dword Indication_array [], byte indication, int datalength)
{
    int i, provider, service_type, nulength, nalength;
    provider = 0;
    service_type = 0;
    nulength = 0;
    nalength = 0;


    //write("# (FSG) DialService_Indication");
    //write("# (FSG) DialService_Indication gDialService_status: %d, gDialService_Enabled: %d", gDialService_status, gDialService_Enabled);
    //DialService_Request(Processing_REQ, 0);	
	
	switch(indication)
	{
        case Processing_CNF:
            //write("# --> send Processing_REQ ((FSG) DialService_Indication)");
            DialService_Request(Processing_REQ, 0);	
        break;
        case StartResult_IND:
            if(gDialService_enabled != 1) 
            {
                //write("# --> gDialService_enabled not enabled");   
                gDialService_Result = SUCCESSFUL;   
                DialService_Request(Result_REQ, 0);		
                gDialService_status = 0;	
            }
            else
            {
                if(gDialService_status != 0 || gDialNumber_status != 0) // DialService or DialNumber is still active 
                {
                    if(gDialNumber_status != 0)
                        write("dial number still active");
                    if(gDialService_status != 0)
                        write("dial service still active");
                    
                    //DialService_Request(Error_REQ, 0x80); //AppErr_Unknown
                    gDialService_Result = 0x03;//abort not successful;   
                    DialService_Request(Result_REQ, 0);
                }  
                else 
                {
                    gDialService_status = 1;
                    gDialNumber_status = 1; // prevent use of DialNumber

                    for(i = 0; i < CALL_INFO_NUMBER_LENGTH; i++) // delete dial-number array
                		gDialNumber[i] = 0;
                	for(i = 0 ; i < CALL_INFO_NAME_LENGTH; i++) // delete dial-number-name array
                		gDialNumber_name[i] = 0;
                    
                    // set number, name, number length, name length
                    service_type = Indication_array[3];
                    nulength = strlen(gDialService_ServiceNumbers[service_type]);
                    nalength = strlen(gDialService_ServiceNames[service_type]);                  
                    for (i=0; i<nulength; i++)		
						gDialNumber[i] = gDialService_ServiceNumbers[service_type][i];
                    for(i = 0; i < nalength; i++) 
                	    gDialNumber_name[i] = gDialService_ServiceNames[service_type][i]; 
                    

                    //write("# number = %s, name = %s, number length = %d, name length = %d", gDialNumber, gDialNumber_name, nulength, nalength);

                    gcallID = callstates_status(dialing);	// ask for free callID                    
                
					if(PhoneModuleOn!=gTel_State && MobileOn!=gTel_State)				//GMS-module or mobile not active
					{
                        gDialService_Result = NS_NO_NETWORK;
						DialService_Request(Result_REQ, 0);
						gDialNumber_status=0;
                        gDialService_status = 0;															//method is finished
					}
					else if(gRegisterState!=1)																//not registered
					{
						if(service_type != 0x03)	//not registered and no emergency call
						{
							write("no network, no emergency call");	
                            gDialNumber_Result = NOT_SUCCESSFUL;								
							DialService_Request(Result_REQ, 0);	
							gDialNumber_status = 0;
                            gDialService_status = 0;														//method "dialnumber" is finished
						}
						else						//emergency call but not registered
						{
                            write("emergency call but not registered");
							if (gLockState != nolock)	//emergency call but not registered and no SIM
								gemergencycall=3;
							else					//emergency call but not registered and SIM OK
								gemergencycall=2;	

							while(provider == 0)		//searching for provider
								provider = random(4);
				            
                            putvalue(env_FSG_NetworkProviderState,1);
							//putvalue(env_FSG_networkprovider, provider);					//new provider
						}
					}
					else if(gcallID == 0xff)													//registered, but no free call-ID or some call-ID-state is "active/dialing/disconnecting"
					{
                        write("no free callID or some id is active/dialing/disconnecting");
						DialService_Request(Error_REQ, Terror_activecallpresentdialing);	//send error
						gDialNumber_status = 0;
                        gDialService_status = 0;												//method "dialnumber" is finished
					}
					else															//registered and one call-ID-state is "idle" an no other call-ID-state is "active/dialing/disconnecting"
					{
						if(service_type == 0x03)	//emergency call ?
                        {
							gemergencycall = 1;
                            //setCallState(gcallID, 0x80); 
                            gCallOutgoingDiverted_eCallConfirmationPending[7] = 1;
                            set_CallState(gcallID, 0x00);

                            write("setCallState(gcallID, 0x00)");

                            gDialService_Result = 0x0a; //not successful - confirm emergency call
                            DialService_Request(Result_REQ, 0);

                        }
						else													//no emergency call
                        {
							gemergencycall = 0;
                            settimer(checknetworktimer, gtime_checknetworktimer);
                        }
                        						
					}                               
                }
            }
        break;
        default:
		    writelineEx(gError_Trace, 0, "FSG-Telephone DialService Indication: unknown indication %d", indication);
		break;
	}
}
*/

DialService_Request (byte request, byte errorcode)
{
    int offset, i;
    dword requestarray[BAP_buffer_size];
	offset=0;
	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i] = 0;

//**********
    //write("# (FSG) DialService_Request");
//**********

	switch(request){
		case Processing_REQ:
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_DialService;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      
			offset=4;
			set_status_requestbuffer (requestarray, offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x1B_Processing_flg == 0x00)
            {
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_DialService;	    //Fct.-ID
			requestarray[2]=request;
            requestarray[3]=gDialService_Result;	
			offset=4;
//**********
            //write("# --> (FSG) DialService_Request: result = 0x%x", gDialService_Result);
//**********
			set_status_requestbuffer (requestarray, offset, Bap_UInt8);

            }
		break;
		case Error_REQ:
            requestarray[0]=LSGID_Telephone;	    //LSG-ID
			requestarray[1]=FctID_DialService;	    //Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			offset=4;
			set_status_requestbuffer (requestarray, offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x1B_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone DialService_Request: unknown request %d", request);
		break;
	}
}

on envVar env_FSG_DialService_Enabled
{
    if(gFSG_Telephone_PowerOnOff==Power_on && gDialService_status == 0)
    {
		gDialService_enabled = getvalue(this);	    
        //write("# on envVar env_FSG_DialService_Enabled gDialService_enabled = %d", gDialService_enabled);
    } 
}

int compare_strings (char str1[], char str2[], int length)
{
    // note: lenth has to be shorter than max. of strlen of str1 and str2

    int i;
    char ch1, ch2;

    for(i = 0; i < length; i++) 
    {
        ch1 = str1[i];
        ch2 = str2[i];
        if(ch1 != ch2)
        {
            if  // case insensitive
            (
                !
                (   
                    (
                        ((ch1 >= 0x41) && (ch1 <= 0x5A)) // ch1 capital letter
                        &&
                        ((ch1 + 0x20) == ch2)
                    )
                    ||
                    (
                        ((ch1 >= 0x61) && (ch1 <= 0x7A)) // ch1 small letter
                        &&
                        ((ch1 - 0x20) == ch2)
                    )
                )
            )    
                break;
        }
    }

    return i; // return the number of identical characters at the beginning of the strings
}

ConfirmEmergencyCall_Request(byte request, byte errorcode)
{
    int offset, i;
    dword requestarray[BAP_buffer_size];
	offset=0;
	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i] = 0;

//**********
    //write("# (FSG) ConfirmEmergencyCall_Request");
//**********

	switch(request){
		case Processing_REQ:
            
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_ConfirmEmergencyCall;		//Fct.-ID
			requestarray[2]=request;
			requestarray[3]=0;                      
			offset=4;
			set_status_requestbuffer (requestarray, offset, Bap_UInt8);
		break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x1C_Processing_flg == 0x00)
            {
			requestarray[0]=LSGID_Telephone;		//LSG-ID
			requestarray[1]=FctID_ConfirmEmergencyCall;	    //Fct.-ID
			requestarray[2]=request;
            requestarray[3]=gConfirmErmergencyCall_result;	
			offset=4;
			

            set_status_requestbuffer(requestarray, offset, Bap_UInt8);
            }

		break;
		case Error_REQ:
			requestarray[0]=LSGID_Telephone;	    //LSG-ID
			requestarray[1]=FctID_ConfirmEmergencyCall;	    //Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			offset=4;
			set_status_requestbuffer (requestarray, offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x1C_ProcessingTimer);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone ConfirmEmergencyCall_Request: unknown request %d", request);
		break;
	}
}

ConfirmEmergencyCall_Indication (dword Indication_array[], byte indication, int datalength)
{
    byte control;

    control = 0;
    //IssueList #180
    gConfirmEcall_3minProc_flg =0;

//*********
   // write("# (ASG) ConfirmEmergencyCall_Indication");
//*********
	
	switch (indication)
	{
        case Processing_CNF:
			//IssueList #57  and #74
           if (((getValue(env_FSG_Tel_ECall_ErrorCode) ==0x00)||(getValue(env_FSG_Tel_ECall_ErrorCode) > 0x3F)) &&  (gTelFctList_0x1C_TimeOut_flg == 0x00))
            {
            ConfirmEmergencyCall_Request(Processing_REQ, 0);
               
               //IssueList #68
                if (gTelFctList_0x1C_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x1C_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x1C_ProcessingTimer,TELMAXPROCESSINGTIME);

                ConfirmEmergencyCall_Request(Processing_REQ, 0);
                }
            }
        break;
        case StartResult_IND:
            //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x1C_TimeOut)!=TRUE)
            {
            gTelFctList_0x1C_TimeOut_flg = 0x00;
                //IssueList #57
                if (getValue(env_FSG_Tel_ECall_Error_On)==0x00)
                putValue(env_FSG_Tel_ECall_ErrorCode,0);

                //IssueList #47
                if (getValue(env_FSG_Tel_ECall_Error_On))
                    {
                    ConfirmEmergencyCall_Request(Error_REQ, getValue(env_FSG_Tel_ECall_ErrorCode)); // send error-message


                    //IssueList #160 MR49588
                        //IssueList #167 - commented the code & addition of 3 second timer
                    //gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
                    //CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
                    //gDialNumber_status = 0;
                    //gDialService_status = 0;
                    //gFirstPress = 0x00;
                     setTimer(checkEcallConfirmPending,3);
                    }

                else if(gDialNumber_status != 1)
    				ConfirmEmergencyCall_Request(Error_REQ, Terror_unknownapllicationerror);			
    			else if(datalength!=4) // datalength error
    				ConfirmEmergencyCall_Request(Error_REQ, Terror_unknownapllicationerror);	
    			else
                {
                
                   if(gDialNumber_status == 1)
                    {
                        control = Indication_array[3];
                    
                        //IssueList #26
                        putValue(env_FSG_ConfirmECall_Control,control);
                    
                        switch(control)
                        {                    
                            case ECALL_CONTROL_CONFIRM:
                                // ConfirmEmergencyCall_Request(Processing_REQ, 0);
                                gcallID = callstates_status(dialing); //aks for free Call-ID

                    
                                if(gcallID == 0xff)
                                {
                                    if(gDialService_status == 1)
                                    {
                                        DialService_Request(Error_REQ, Terror_activecallpresentdialing);	//send error
                                        gDialNumber_status = 0;
                                        gDialService_status = 0;
                                    }
                                    else if(gDialNumber_status == 1)
                                    {
                                        DialNumber_Request(Error_REQ, Terror_activecallpresentdialing);	//send error
                                        gDialNumber_status = 0;
                                    }
                                    gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
                                    set_CallState(gcallID, idle);
                                    CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
                                    gDialNumber_status = 0;	
                                    gDialService_status = 0;

                                    gConfirmErmergencyCall_result = NOT_SUCCESSFUL;
                                    ConfirmEmergencyCall_Request(Result_REQ, 0);
                                }
                                else
                                {
                                     //IssueList #26
                                     if (getValue(env_FSG_ConfirmECall_Result)==SUCCESSFUL)
                                     {
                                   
                                    gCallStartedFromASG = 1;
                      
                                    gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
                                    settimer(checknetworktimer, gtime_checknetworktimer);

                                    putValue(env_FSG_ConfirmECall_Control,ECALL_CONTROL_CONFIRM);
                                    
                                    }
                                    //IssueList #160 MR49588 - addition of else condition
                                    else
                                    {

                                    gConfirmErmergencyCall_result = getValue(env_FSG_ConfirmECall_Result);
                                    ConfirmEmergencyCall_Request(Result_REQ, 0);
                                    
                                    //IssueList #167 - commented the code & addition of 3 second timer
                                    //gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
                                    //CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
                                    //gDialNumber_status = 0;
                                    //gDialService_status = 0;
                                      //IssueList #180 - if condition
                                      if (getValue(env_FSG_Tel_FctList_0x1C_3min_TO)==0x00)
                                      setTimer(checkEcallConfirmPending,3);
                                      else
                                      gConfirmEcall_3minProc_flg = 0x01;
                                   }
                                }

                            //IssueList #26 - CANoe crash
                            gFirstPress = 0x00;
                              
                            break;
                            case ECALL_CONTROL_CANCEL:
                                //write("cancel");
                                //IssueList #26
                                if (getValue(env_FSG_ConfirmECall_Result)==SUCCESSFUL)
                                     {
                                gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
                                //set_CallState(gcallID, idle);
                                CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
                                gDialNumber_status = 0;	
                                gDialService_status = 0;

                                gConfirmErmergencyCall_result = getValue(env_FSG_ConfirmECall_Result);;
                                ConfirmEmergencyCall_Request(Result_REQ, 0);

                                //IssueList #49
                                 EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);
                                }
                                 
                                 //IssueList #160 MR49588 - addition of else condition
                                else
                                 {
                                //gConfirmErmergencyCall_result = SUCCESSFUL;
                                 gConfirmErmergencyCall_result = getValue(env_FSG_ConfirmECall_Result);;
                                 ConfirmEmergencyCall_Request(Result_REQ, 0);

                                //IssueList #167 - commented the code & addition of 3 second timer
                                //gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
                                //CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
                                //gDialNumber_status = 0;
                                //gDialService_status = 0;
                                //IssueList #180 - if condition
                                 if (getValue(env_FSG_Tel_FctList_0x1C_3min_TO)==0x00)
                                 setTimer(checkEcallConfirmPending,3);
                                 else
                                 gConfirmEcall_3minProc_flg = 0x01;
                                }
                              
                                //IssueList #26 - CANoe crash
                                gFirstPress = 0x00;  
                                
                            break;
                        }
                    }
                }
             }//IssueList #74
             else
             gTelFctList_0x1C_TimeOut_flg = 0x01;
                         
        break;
        default:
		    writelineEx(gError_Trace, 0, "FSG-Telephone ConfirmEmergencyCall Indication: unknown indication %d", indication);
		break;
	}
}

on envVar env_FSG_ConfirmCall_Confirm
{
    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && (gCallOutgoingDiverted_eCallConfirmationPending[7] == 1))
    {
        gcallID = callstates_status(dialing); //aks for free Call-ID

                   
        if(gcallID == 0xff)
        {
            DialNumber_Request(Error_REQ, Terror_activecallpresentdialing);	//send error
            if(gDialService_status == 1)
            {
                gDialNumber_status = 0;
                gDialService_status = 0;
            }
            else if(gDialNumber_status == 1)
            {
                gDialNumber_status = 0;
            }

            gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
            //set_CallState(gcallID, idle);
            CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
            gDialNumber_status = 0;	
            gDialService_status = 0;
        }
        else
        {
            gCallStartedFromASG = 0;

            gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
            settimer(checknetworktimer, gtime_checknetworktimer);
        }
    }
}

on envVar env_FSG_ConfirmCall_Cancel
{
    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this) && (gCallOutgoingDiverted_eCallConfirmationPending[7] == 1) && (gemergencycall == 0x01))
    {
        gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;

        //set_CallState(gcallID, idle);
        CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false

        gDialNumber_status = 0;	
        gDialService_status = 0;

        //MR61018
        gFirstPress = 0;
    } 
}

byte detect_emergency_number() // detect emergency call, and set. if confirmation is required
{
    if(gDialNumber_status == 1 && gDialService_status == 0)
    {
        if(strncmp(gDialNumber, police, CALL_INFO_NUMBER_LENGTH)==0 || strncmp(gDialNumber, ambulance, CALL_INFO_NUMBER_LENGTH)==0 || strncmp(gDialNumber, emergency_NAR, CALL_INFO_NUMBER_LENGTH)==0 || strncmp(gDialNumber, cerveza, CALL_INFO_NUMBER_LENGTH)==0)
        {   gConfirmCall = 0x01;
            return 0x01; // emergency call detected
        }
    }
    else if(gDialService_status == 1)
    {
        if(gDialService_type == 0x03)
        {
            gConfirmCall = 0x01;
            return 0x01; // emergency call detected
            //IssueList #26
            putValue(env_FSG_DialService_Type,gDialService_type);
        }
    }
    
    gConfirmCall = 0x00; // no confirmition required
    return 0x00; // no emergency call
}

AutomaticRedial_Request(byte request, byte errorcode)
{
    int i, offset;
    dword requestarray[BAP_buffer_size];

	offset = 0;
	for(i = 0; i < BAP_buffer_size; i++)
		requestarray[i] = 0;

    //write("FSG: AutomaticRedial_Request");	

	switch(request){
		case Data_REQ:
            //IssueList #62
    	    if (getValue(env_FSG_Tel_FctList_0x39_TimeOut)!=TRUE)
            {
            //write("-> Data_REQ");
			requestarray[0] = LSGID_Telephone;	//LSG-ID
			requestarray[1] = FctID_AutomaticRedial;		//Fct.-ID
			requestarray[2] = request; 
			requestarray[3] = gAutomaticRedialState;
			offset = 4;		
			set_status_requestbuffer(requestarray, offset, Bap_UInt8);
            }
		break;
		case Error_REQ:
            //write("-> Error_REQ");
			requestarray[0] = LSGID_Telephone;	//LSG-ID
			requestarray[1] = FctID_AutomaticRedial;		//Fct.-ID
			requestarray[2] = request;	
			requestarray[3] = errorcode;
			offset = 4;
			set_status_requestbuffer(requestarray, offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone AutomaticRedial_Request: invalid request %d", request);
		break;
	}
//IssueList #51
putvalue(env_FSG_AutoRedial_OK, 0);
}

AutomaticRedial_Indication (dword indication_array[], byte indication, int datalength)
{

    //write("FSG: RingToneMuteOnOff_Indication");

	switch (indication){
		case DataSetGet_IND:
			//check array
			if(datalength!=4)														//datalength error
				AutomaticRedial_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message
		 
         //IssueList #27
            else if (getValue(env_Tel_AutoRedial_Error_On))
            AutomaticRedial_Request(Error_REQ, getValue(env_Tel_AutoRedial_Error_Code));	
            
            else
            {
                gAutomaticRedialState = (indication_array[3] & 0x01);                
                putvalue(env_FSG_AutomaticRedial_Active, gAutomaticRedialState);
                //IssueList #51
                putvalue(env_FSG_AutoRedial_OK, 1);
                //AutomaticRedial_Request(Data_REQ, 0);
			}
		break;
        case DataGet_IND:
			if(datalength != 3)															//datalength error
				AutomaticRedial_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				AutomaticRedial_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone AutomaticRedial_Indication: unknown indication %d", indication);
		break;
	}
}

GetNextListPos_Indication(dword indication_array[], byte indication, int datalength)
{
    int i;
    dword curr_entry, next_entry;
    curr_entry = 0xffffffff;
    next_entry = 0xffffffff; 
	switch(indication)
	{
		case Processing_CNF:
			//IssueList #57  and #74
           if (((getValue(env_FSG_Tel_GetNextListPos_EC) ==0x00)||(getValue(env_FSG_Tel_GetNextListPos_EC) > 0x3F)) &&  (gTelFctList_0x36_TimeOut_flg == 0x00))
             {
             GetNextListPos_Request(Processing_REQ, 0); //send Processing
		        
                //IssueList #68
                if (gTelFctList_0x36_Processing_flg==0x01)
                {
                  if (isTimerActive(TelFctList_0x36_ProcessingTimer) == 0x00)
                  setTimer(TelFctList_0x36_ProcessingTimer,TELMAXPROCESSINGTIME);

                GetNextListPos_Request(Processing_REQ, 0);
                }
             }
        break;
		case StartResult_IND:
            //IssueList #74
			if (getValue(env_FSG_Tel_FctList_0x36_TimeOut)!=TRUE)
            {
            gTelFctList_0x36_TimeOut_flg =0x00;
             	//IssueList #57
                if (getValue(env_FSG_Tel_GetNextListPos_E_O)==0x00)
                putValue(env_FSG_Tel_GetNextListPos_EC,0);
                
                //IssueList #47
                if (getValue(env_FSG_Tel_GetNextListPos_E_O))
                {
                    GetNextListPos_Request(Error_REQ, getValue(env_FSG_Tel_GetNextListPos_EC)); // send error-message
                    break;
                }
            
                //IssueList #26
                 if (getValue(env_FSG_GetNextListPos_Result)!=SUCCESSFUL)
                 {
                  gGetNextListPos_Result = getValue(env_FSG_GetNextListPos_Result);
                  GetNextListPos_Request(Result_REQ, 0);
                  break;
                  }

    			if(datalength != 8)	//datalength error										
                {
    				GetNextListPos_Request(Error_REQ, Terror_unknownapllicationerror); //send error-message
                    break;
                }


                gGetNextListPos_currentPos = indication_array[3] + (indication_array[4] << 8);
                gGetNextListPos_Offset = indication_array[5] + (indication_array[6] << 8);
                gGetNextListPos_ListType = indication_array[7];

                if(gGetNextListPos_ListType == 0) // phonebook
                {
                    // find current entry
                    curr_entry = 0xffffffff;
                    for(i = 0; i < gPhonebook_TotalNumListElements; i++)
                    {
                        if(gPhonebook_Pos[i] == gGetNextListPos_currentPos)
                        {
                            curr_entry = i;  
                            break;
                        }
                    }

                    if(curr_entry == 0xffffffff)
                    {
                        // current entry not in list
                        gGetNextListPos_nextPos = 0xff;
                        gGetNextListPos_absoluteListPos = 0xffff;
                        gGetNextListPos_Result = NOT_SUCCESSFUL; 
                        gGetNextListPos_req = Result_REQ;
                        //changes from Jöran Karl (28.03.2012)
    			    // changes from Jan Swoboda (01.03.2012)
    			    //settimer(GetNextListPos_timer, 200);
    		    settimer(GetNextListPos_timer, gGetNextListPos_Time);
                        //GetNextListPos_Request(Result_REQ, 0);
                        break;
                    }

                    // get next entry
                    if((curr_entry + gGetNextListPos_Offset) >= gPhonebook_TotalNumListElements || (curr_entry + gGetNextListPos_Offset) < 0) // entry to search for is not in list
                    {
                        // no entry with this offset in list
                        gGetNextListPos_nextPos = 0xffff;
                        gGetNextListPos_absoluteListPos = 0xffff;
                        gGetNextListPos_Result = NOT_SUCCESSFUL; 
                        gGetNextListPos_req = Result_REQ;
                        //changes from Jöran Karl (28.03.2012)
    			    // changes from Jan Swoboda (01.03.2012)
    			    //settimer(GetNextListPos_timer, 200);
    		    settimer(GetNextListPos_timer, gGetNextListPos_Time);
                        //GetNextListPos_Request(Result_REQ, 0);
                        break;
                    }
                    next_entry = curr_entry + gGetNextListPos_Offset;

                    gGetNextListPos_nextPos = gPhonebook_Pos[next_entry];
                    gGetNextListPos_absoluteListPos = next_entry + 1; 
                    gGetNextListPos_Result = SUCCESSFUL;

                    gGetNextListPos_req = Result_REQ;
                        //changes from Jöran Karl (28.03.2012)
    			    // changes from Jan Swoboda (01.03.2012)
    			    //settimer(GetNextListPos_timer, 200);
    		    settimer(GetNextListPos_timer, gGetNextListPos_Time);
                    //GetNextListPos_Request(Result_REQ, 0);
                    break;
                }
                else
                {
                    // no known list type
                    gGetNextListPos_nextPos = 0xffff;
                    gGetNextListPos_absoluteListPos = 0xffff;
                    gGetNextListPos_Result = NOT_SUCCESSFUL;
                    gGetNextListPos_req = Result_REQ;
                        //changes from Jöran Karl (28.03.2012)
    			    // changes from Jan Swoboda (01.03.2012)
    			    //settimer(GetNextListPos_timer, 200);
    		    settimer(GetNextListPos_timer, gGetNextListPos_Time);
                    //GetNextListPos_Request(Result_REQ, 0);
                    break; 
                }
             }//IssueList #74
             else
             gTelFctList_0x36_TimeOut_flg =0x01;
		    break;
        case Abort_IND:
            gGetNextListPos_nextPos = 0xffff;
            gGetNextListPos_absoluteListPos = 0xffff;
            gGetNextListPos_Result = ABORT_SUCCESSFUL;
            gGetNextListPos_abort_active = 1;
            if(istimeractive(GetNextListPos_timer))
                cancelTimer(GetNextListPos_timer);
            gGetNextListPos_req = Result_REQ;
            GetNextListPos_Request(Result_REQ, 0);
		break;
		default:
			write("FSG-Telephone GetNextListPos_Indication: invalid indication: %d", indication);
		break;
	}

 //IssueList #26
    putValue(env_FSG_GetNextListPos_ListType,gGetNextListPos_ListType);
    putValue(env_FSG_GetNextListPos_current,gGetNextListPos_currentPos);
    putValue(env_FSG_GetNextListPos_Offset,gGetNextListPos_Offset);
    putValue(env_FSG_GetNextListPos_nextPos,gGetNextListPos_nextPos);
    putValue(env_FSG_GetNextListPos_AbsLpos,gGetNextListPos_absoluteListPos);
}

GetNextListPos_Request(byte request, byte errorcode)
{
    int i, offset;
    dword requestarray [BAP_buffer_size], length;

	offset = 0;
	length = 0;
	
	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;

	switch (request){
		case Processing_REQ:
			requestarray[0] = LSGID_Telephone;		//LSG-ID
			requestarray[1] = FctID_GetNextListPos;	//Fct.-ID
			requestarray[2] = request;
            		//IssueList #145 - Aghil: dummy + offset adjustment
			requestarray[3] = 0;                    //Dummy
			offset=4;
			set_status_requestbuffer(requestarray, offset, Bap_ByteSequence);
		    break;
		case Result_REQ:
            //IssueList #68
            if (gTelFctList_0x36_Processing_flg == 0x00)
            {
			requestarray[0] = LSGID_Telephone;		//LSG-ID
			requestarray[1] = FctID_GetNextListPos;	//Fct.-ID
			requestarray[2] = request;			
            requestarray[3] = gGetNextListPos_Result;
            requestarray[4] = gGetNextListPos_currentPos & 0xff;
            requestarray[5] = (gGetNextListPos_currentPos & 0xff00)/0x100;
            requestarray[6] = gGetNextListPos_nextPos & 0xff;
			requestarray[7] = (gGetNextListPos_nextPos & 0xff00)/0x100;
            requestarray[8] = gGetNextListPos_absoluteListPos & 0xff;
            requestarray[9] = (gGetNextListPos_absoluteListPos & 0xff00)/0x100;
			offset = 10;
            gGetNextListPos_abort_active = 0;
			set_status_requestbuffer (requestarray, offset, Bap_ByteSequence);
            }
		    break;
		case Error_REQ:
			requestarray[0] = LSGID_Telephone;		//LSG-ID
			requestarray[1] = FctID_GetNextListPos;	//Fct.-ID
			requestarray[2] = request;	
			requestarray[3] = errorcode;
			offset = 4;
			set_status_requestbuffer(requestarray, offset, Bap_Error);

            //IssueList #68
            cancelTimer(TelFctList_0x36_ProcessingTimer);
		    break;
		default:
			write("FSG-Telephone GetNextListPos_Request: invalid request: %d", request);
		    break;
	}
}

on envVar env_FSG_Schalter_OnOff
{
    if( getvalue( this ) )  //FSG Power on
    {
        putValue( ON_OFF_FSG40_0, 0 );
        putvalue( env_FSG_Power_on_off, 1 );
        gFSG_Schalter_OnOff = 1;
        putvalue( env_FSG_Schalter_OnOff_string, gFSG_Schalter_OnOff_string[gFSG_Schalter_OnOff]);
    }
    else                //FSG Power off
    {
        putvalue( env_FSG_Power_on_off, 0 );
        gFSG_Schalter_OnOff = 0;
        putvalue( env_FSG_Schalter_OnOff_string, gFSG_Schalter_OnOff_string[gFSG_Schalter_OnOff]);

        //IssueList #22  (Retain all Telephone Panels)
        /*ClosePanel("FSG-Telephone_MobileServiceSupport");
        ClosePanel("FSG-Telephone_Properties_2");
        ClosePanel("FSG-Telephone_Properties_1");
        ClosePanel("FSG-Telephone_Methods");
        ClosePanel("FSG-Telephone_Remote_Side");
        ClosePanel("FSG-Telephone_MissedCalls");
        ClosePanel("FSG-Telephone_MissedCalls(array)");
        ClosePanel("FSG-Telephone_Phonebook");
        ClosePanel("FSG-Telephone_Phonebook(array)");*/
    }
}

on envVar env_FSG_Panel_Methods
{
    if(getvalue(this))
    {
        //if(gFSG_Telephone_PowerOnOff) //FSG Power on
        //{
            //OpenPanel("FSG-Telephone_Properties_2");
            OpenPanel("FSG-Telephone_Methods");
        //}
    }
}

//MR 60374
on envVar env_FSG_Panel_LoadUtf8OutputPanels
{
    if(getvalue(this))
    {
        OpenPanel("BAP Transmitter");        
		OpenPanel("CombinedNumbers");  
		OpenPanel("PhoneBook&TelephoneNumber");  
		OpenPanel("PhoneBookName");  
		OpenPanel("PhonebookArray");  
    }
}

on envVar env_FSG_Panel_RemoteSide
{
    if(getvalue(this))
    {
        //if(gFSG_Telephone_PowerOnOff) //FSG Power on
        //{
            OpenPanel("FSG-Telephone_Remote_Side");
        //}
    }
}

on envVar env_FSG_Panel_Phonebook
{
    if(getvalue(this))
    {
        //if(gFSG_Telephone_PowerOnOff) //FSG Power on
        //{
            OpenPanel("FSG-Telephone_Phonebook");
       // }
    }    
}

on envVar env_FSG_Panel_Phonebook_Array
{
    if(getvalue(this))
    {
        //if(gFSG_Telephone_PowerOnOff) //FSG Power on
        //{
            OpenPanel("FSG-Telephone_Phonebook(array)");
        //}
    }
}

on envVar env_FSG_Panel_CombNum_Array
{
    if(getvalue(this))
    {
        //if(gFSG_Telephone_PowerOnOff) //FSG Power on
        //{
            OpenPanel("FSG_Telephone_0x31 - CombinedNumers_(array)");
        //}
    }    
}

on envVar env_FSG_Panel_RecCalls_Array
{
    if(getvalue(this))
    {
        if(gFSG_Telephone_PowerOnOff) //FSG Power on
        {
            OpenPanel("FSG_Telephone_0x2F - ReceivedCalls_(array)");
        }
    } 
}

on envVar env_FSG_Panel_DialedNumbers
{
        if(getvalue(this))
    {
        if(gFSG_Telephone_PowerOnOff) //FSG Power on
        {
            OpenPanel("FSG_Telephone_0x30 - DialedNumbers_(array)");
        }
    } 
}

on envVar env_FSG_Panel_MissedCalls
{
    if(getvalue(this))
    {
        if(gFSG_Telephone_PowerOnOff) //FSG Power on
        {
            OpenPanel("FSG-Telephone_MissedCalls");
        }
    } 
}

on envVar env_FSG_Panel_SendData
{
    if(getvalue(this))
    {
        if(gFSG_Telephone_PowerOnOff) //FSG Power on
        {
            OpenPanel("FSG-Telephone_send_data");
        }
    }     
}

on envVar env_FSG_Panel_MissedCalls_Array
{
    if(getvalue(this))
    {
        if(gFSG_Telephone_PowerOnOff) //FSG Power on
        {
            OpenPanel("FSG-Telephone_MissedCalls(array)");
        }
    } 
}

on envVar env_FSG_Panel_ServiceSupport
{
    if(getvalue(this))
    {
        //if(gFSG_Telephone_PowerOnOff) //FSG Power on
        //{
            OpenPanel("FSG-Telephone_MobileServiceSupport");
        //}
    }  
}

on envVar env_FSG_Panel_Properties2
{
    if(getvalue(this))
    {
        //if(gFSG_Telephone_PowerOnOff) //FSG Power on
       // {
            OpenPanel("FSG-Telephone_Properties_2");
        //}
    } 
}

on envVar env_FSG_Panel_Properties1
{
        if(getvalue(this))
    {
        //if(gFSG_Telephone_PowerOnOff) //FSG Power on
        //{
            OpenPanel("FSG-Telephone_Properties_1");
        //}
    } 
}

on envVar env_FSG_AutoRedial_OK
{
    //if(gFSG_Telephone_PowerOnOff == Power_on)
    if(gFSG_Telephone_PowerOnOff == Power_on && getvalue(this))
    {
        //if(gAutomaticRedialState != getvalue(this))
        if(gAutomaticRedialState != getvalue(env_FSG_AutomaticRedial_Active))
        {   
            
             // gAutomaticRedialState = getvalue(this);
              gAutomaticRedialState = getvalue(env_FSG_AutomaticRedial_Active);
           
        }
        //else
        //{
           // putvalue(env_FSG_AutomaticRedial_ActiveS, gAutomaticRedialState_s[gAutomaticRedialState]);
        //}
      
            //IssueList #27
            if (getValue(env_Tel_AutoRedial_Error_On))
            AutomaticRedial_Request(Error_REQ, getValue(env_Tel_AutoRedial_Error_Code));

            else
            AutomaticRedial_Request(Data_REQ, 0);
            putvalue(env_FSG_AutomaticRedial_ActiveS, gAutomaticRedialState_s[gAutomaticRedialState]);
    }
}

on timer GetNextListPos_timer
{
    if(gGetNextListPos_abort_active == 0)
        GetNextListPos_Request(gGetNextListPos_req, 0);
}

on timer dialnumber_result_timer
{
    //IssueList #104
    //changes from Jan Swoboda 21.06.2012

    //changes from Jan Swoboda 21.06.2012
    //if(gLastAcknowlegdeData[0] != LSGID_Telephone && gLastAcknowlegdeData[1] != FctID_CallState && gLastAcknowlegdeData[2] != 0xb)
    if (gAcknowledgePending[FctID_CallState] == 0)
        DialNumber_Request(Result_REQ, 0);
    else
        settimer(dialnumber_result_timer, 20);
}

//IssueList #22
on envVar env_BAPCFG_FSG_Tel_PrtclMjr
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 7, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Major BAP Version.",NODE_INDEX, ret);
        }
    }
}

//IssueList #22
on envVar env_BAPCFG_FSG_Tel_LsgClssMnr
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 6, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor Class Version.",NODE_INDEX, ret);
        }
    }
}

//IssueList #22
on envVar env_BAPCFG_FSG_Tel_LsgClssMjr
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 5, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor Class Version.",NODE_INDEX, ret);
        }
    }
}

//IssueList #22
on envVar env_BAPCFG_FSG_Tel_DFMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 9, temp);
        if (ret != 0)
        {
            // changes from Jan Swoboda (01.03.2012)
	    writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Major DF Version.",NODE_INDEX, ret);
        }
    }
}

//IssueList #22
on envVar env_BAPCFG_FSG_Tel_DFMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 10, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}

//IssueList #22
initBapConfig()
{
        long config[3];
    config[0] = LSGID;
    config[1] = 0;
    config[2] = getValue(env_BAPCFG_FSG_Tel_PrtclMjr);
    ChangeConfig(0x0012,config);
    config[2] = getValue(env_BAPCFG_FSG_Tel_PrtclMnr);
    ChangeConfig(0x0013,config);
    config[2] = getValue(env_BAPCFG_FSG_Tel_LsgClssMjr);
    ChangeConfig(0x0010,config);
    config[2] = getValue(env_BAPCFG_FSG_Tel_LsgClssMnr);
    ChangeConfig(0x0011,config);
    config[2] = getValue(env_BAPCFG_FSG_Tel_DFMajor);
    ChangeConfig(0x0014,config);
    config[2] = getValue(env_BAPCFG_FSG_Tel_DFMinor);
    ChangeConfig(0x0015,config);
    
}

//IssueList #22
ChangeConfig(long paramIndex,long config[])
{

        byte temp ;
        temp = BAP150_ChangeConfig(NODE_INDEX, paramIndex, config);
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP150_ChangeConfig for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP150_ChangeConfig error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        
}

initFunctionList(void)
{	
		//Byte0
        //IssueList #17
        //gFunctionList0= 0 //getvalue(env_FSG_Telephone_FctList_0x01)*0x40;
		gFunctionList0 =  getvalue(env_FSG_Telephone_FctList_0x01)*0x40;
        gFunctionList0 += getvalue(env_FSG_Telephone_FctList_0x02)*0x20;
		gFunctionList0 += getvalue(env_FSG_Telephone_FctList_0x03)*0x10;
		gFunctionList0 += getvalue(env_FSG_Telephone_FctList_0x04)*0x08;
		//Byte1
        gFunctionList1= 0x00;//reset
	    gFunctionList1 += getvalue(env_FSG_Telephone_FctList_0x0E)*0x02;
		gFunctionList1 += getvalue(env_FSG_Telephone_FctList_0x0F)*0x01;
		//Byte2
        gFunctionList2 = getvalue(env_FSG_Telephone_FctList_0x10)*0x80;
		gFunctionList2 += getvalue(env_FSG_Telephone_FctList_0x11)*0x40;
		gFunctionList2 += getvalue(env_FSG_Telephone_FctList_0x12)*0x20;
		gFunctionList2 += getvalue(env_FSG_Telephone_FctList_0x13)*0x10;
		gFunctionList2 += getvalue(env_FSG_Telephone_FctList_0x14)*0x08;
		gFunctionList2 += getvalue(env_FSG_Telephone_FctList_0x15)*0x04;
        gFunctionList2 += getvalue(env_FSG_Telephone_FctList_0x16)*0x02;
		gFunctionList2 += getvalue(env_FSG_Telephone_FctList_0x17)*0x01;
		//Byte3
        gFunctionList3 = getvalue(env_FSG_Telephone_FctList_0x18)*0x80;
		gFunctionList3 += getvalue(env_FSG_Telephone_FctList_0x19)*0x40;
		gFunctionList3 += getvalue(env_FSG_Telephone_FctList_0x1A)*0x20;
		gFunctionList3 += getvalue(env_FSG_Telephone_FctList_0x1B)*0x10;
        gFunctionList3 += getvalue(env_FSG_Telephone_FctList_0x1C)*0x08;
        gFunctionList3 += getvalue(env_FSG_Telephone_FctList_0x1D)*0x04;
        gFunctionList3 += getvalue(env_FSG_Telephone_FctList_0x1E)*0x02;
		gFunctionList3 += getvalue(env_FSG_Telephone_FctList_0x1F)*0x01;
//		//Byte4
		gFunctionList4 = getvalue(env_FSG_Telephone_FctList_0x20)*0x80;
		gFunctionList4 += getvalue(env_FSG_Telephone_FctList_0x21)*0x40;
        gFunctionList4 += getvalue(env_FSG_Telephone_FctList_0x22)*0x20;
		gFunctionList4 += getvalue(env_FSG_Telephone_FctList_0x23)*0x10;
		gFunctionList4 += getvalue(env_FSG_Telephone_FctList_0x24)*0x08;
		gFunctionList4 += getvalue(env_FSG_Telephone_FctList_0x25)*0x04;
		gFunctionList4 += getvalue(env_FSG_Telephone_FctList_0x26)*0x02;
		gFunctionList4 += getvalue(env_FSG_Telephone_FctList_0x27)*0x01;
		//Byte5
		gFunctionList5 = getvalue(env_FSG_Telephone_FctList_0x28)*0x80;
		gFunctionList5 += getvalue(env_FSG_Telephone_FctList_0x29)*0x40;
		gFunctionList5 += getvalue(env_FSG_Telephone_FctList_0x2A)*0x20;
        gFunctionList5 += getvalue(env_FSG_Telephone_FctList_0x2B)*0x10;
        gFunctionList5 += getvalue(env_FSG_Telephone_FctList_0x2C)*0x08;
		gFunctionList5 += getvalue(env_FSG_Telephone_FctList_0x2D)*0x04;
		gFunctionList5 += getvalue(env_FSG_Telephone_FctList_0x2E)*0x02;
		gFunctionList5 += getvalue(env_FSG_Telephone_FctList_0x2F)*0x01;
		//Byte6
		gFunctionList6= getvalue(env_FSG_Telephone_FctList_0x30)*0x80;
        gFunctionList6 += getvalue(env_FSG_Telephone_FctList_0x31)*0x40;
        gFunctionList6 += getvalue(env_FSG_Telephone_FctList_0x32)*0x20;
        gFunctionList6 += getvalue(env_FSG_Telephone_FctList_0x33)*0x10;
        gFunctionList6 += getvalue(env_FSG_Telephone_FctList_0x34)*0x08;
        gFunctionList6 += getvalue(env_FSG_Telephone_FctList_0x35)*0x04;
        gFunctionList6 += getvalue(env_FSG_Telephone_FctList_0x36)*0x02;
        gFunctionList6 += getvalue(env_FSG_Telephone_FctList_0x37)*0x01;
        //Byte7
        gFunctionList7 = getvalue(env_FSG_Telephone_FctList_0x38)*0x80;
        gFunctionList7 += getvalue(env_FSG_Telephone_FctList_0x39)*0x40;
        //IssueList #16
        gFunctionList7 += getvalue(env_FSG_Telephone_FctList_0x3A)*0x20;
        
        //IssueList #206
        gFunctionList7 += getvalue(env_FSG_Telephone_FctList_0x3B)*0x10;
		
		gFunctionList7 += getvalue(env_FSG_Telephone_FctList_0x3C)*0x08;
		gFunctionList7 += 1*0x01;



}

//IssueList #22
on envVar env_BAPCFG_FSG_Tel_PrtclMnr
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 8, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor BAP Version.",NODE_INDEX, ret);
        }
    }    
}

//IssueList #24
Phonebook_init_CSV () //Byte & file selection
{
    //changes from Jöran Karl (28.03.2012)
    dword CSVfileHandle = 0, i = 0, j = 0, k = 0, Num_of_csv_byte = 0, element = 0, TelNumIndex = 0, count1,count2;
    char Path_CSV[TEL_BUFFERSIZE];
    byte PhonebookLine = 0, nextvalue, buffer_byte[TEL_BUFFERSIZE];
    char part[TEL_TEXTLENGTH];

    //clear  
    for(j=0;j<PHONEBOOK_ENTRIES;j++) 
    {
        // clear globals
        gPhonebook_Pos[j] = 0;
        
        //changes from Jöran Karl (28.03.2012)
	for(i=0;i<PHONEBOOK_PBNAME_LENGTH;i++)
            gPhonebook_PbName[j][i] =0;

        gPhonebook_Storage[j] = 0;
        gPhonebook_AnyVoiceTag[j] = 0;
        gPhonebook_TelNumberQuantity[j] = 0;
        
        //changes from Jöran Karl (28.03.2012)
	for(i=0;i<PHONEBOOK_N_MAX;i++)
        {
            for(k=0;k<PHONEBOOK_TELNUMBER_LENGTH;k++)
                gPhonebook_TelNumbers[i][j][k] = 0;
            gPhonebook_VoiceTags[i][j] = 0;
            gPhonebook_NumberTypes[i][j] = 0;
        }

        gPhonebook_AddressIndication[j] = 0;
    
    }

    //changes from Jöran Karl (28.03.2012)
    for(j=0;j<TEL_FILENAME_SIZE;j++)
        gPhonebook_CSV_filename[j] = 0;     

    getvalue(env_FSG_Phonebook_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        
    //changes from Jöran Karl (28.03.2012)
    i = 0; j = 0;
   //conflict with CANeasy conversion 
   /* do {
        j=i;
        i=strstr_off(Path_CSV, i+1, "\\");
    } while(i > -1);

    //changes from Jöran Karl (28.03.2012)
    substr_cpy(gPhonebook_CSV_filename, Path_CSV, j+1, TEL_FILENAME_SIZE, elcount(Path_CSV));
    Path_CSV[j+1] = 0;*/

   while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after last "\"
            {              
                gPhonebook_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
                count2++;
                               
            i++;
        }

    
    writelineEx(0, 0,"path of *.csv: %s", Path_CSV);        //output file path 
    writelineEx(0, 0,"filename of *.csv: '%s'", gPhonebook_CSV_filename);  //output filename 


        putvalue(env_FSG_Phonebook_DS_file, gPhonebook_CSV_filename); //output current loaded *.csv-file on panel        

        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gPhonebook_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

    //changes from Jöran Karl (28.03.2012)
    if (CSVfileHandle!=0) //*.csv file access successful
    {
        writelineEx(gPhonebook_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gPhonebook_CSV_filename);    //output result  
        
        putvalue(env_FSG_Phonebook_DS_result, "successful");   //output result on panel                      
        
        Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
                      
        //ignore first line in *.csv file
        for (i = 0; i < Num_of_csv_byte; i++)
        {
            if (buffer_byte[i] == 0x0D && buffer_byte[i+1] == 0x0A)
            {
                i++; // skip 0x0A
                break;
            }
        }

        // reset values
        PhonebookLine = 0;
        element = 0;
        TelNumIndex = 0;
        j = 0;

        for (; i < Num_of_csv_byte; i++) // copy data into "Phonebook"
        {      
            nextvalue = 0;
            switch (buffer_byte[i])
            {
            case 0x0D: if (buffer_byte[i+1] == 0x0A) nextvalue = 1; break;
            case 0x3B: nextvalue = 2; break;
            case 0x2C: if ((element == 5) || (element == 6) || (element == 8)) nextvalue = 3; break;
            default: break;
            }
            
            if (nextvalue > 0)
            {
                part[j++] = 0;
                switch (element)
                {
                case 0: gPhonebook_Pos[PhonebookLine] = atol(part); 
                        break;
                 
                case 1: strncpy(gPhonebook_PbName[PhonebookLine], part, j); break;
                case 2: gPhonebook_Storage[PhonebookLine] = (byte)atol(part); break;
                case 3: gPhonebook_AnyVoiceTag[PhonebookLine] = (byte)atol(part); break;
                case 4: gPhonebook_TelNumberQuantity[PhonebookLine] = (byte)atol(part); break;
                case 5: strncpy(gPhonebook_TelNumbers[TelNumIndex][PhonebookLine], part, j); break;
                case 6: gPhonebook_VoiceTags[TelNumIndex][PhonebookLine] = (byte)atol(part); break;
                // case 7: reserved
                case 8: gPhonebook_NumberTypes[TelNumIndex][PhonebookLine] = (byte)atol(part); break;
                case 9: gPhonebook_AddressIndication[PhonebookLine] = (byte)atol(part); break;
                                
                default: break;
                }
                
		//changes from Jöran Karl (28.03.2012)
                switch (nextvalue)
                {
                case 1:
                    writelineEx(gPhonebook_writeWindow, 0,"*******Element %d*******",PhonebookLine);
                    writelineEx(gPhonebook_writeWindow, 0,"Pos: %d", gPhonebook_Pos[PhonebookLine]);
                    writelineEx(gPhonebook_writeWindow, 0,"PbName: %s", gPhonebook_PbName[PhonebookLine]);
                    writelineEx(gPhonebook_writeWindow, 0,"Storage: %d", gPhonebook_Storage[PhonebookLine]);
                    writelineEx(gPhonebook_writeWindow, 0,"Pos: %d", gPhonebook_AnyVoiceTag[PhonebookLine]);
                    writelineEx(gPhonebook_writeWindow, 0,"AnyVoiceTag: %d", gPhonebook_TelNumberQuantity[PhonebookLine]);
                    writelineEx(gPhonebook_writeWindow, 0,"TelNumberQuantity: %d", gPhonebook_Pos[PhonebookLine]);
                    writelineEx(gPhonebook_writeWindow, 0,"gPhonebook_TelNumbers[0]: %d", gPhonebook_TelNumbers[0][PhonebookLine]);
                    writelineEx(gPhonebook_writeWindow, 0,"gPhonebook_VoiceTags[0]: %d", gPhonebook_VoiceTags[0][PhonebookLine]);
                    writelineEx(gPhonebook_writeWindow, 0,"Phonebook_NumberTypes[0]: %d", gPhonebook_NumberTypes[0][PhonebookLine]);
                    writelineEx(gPhonebook_writeWindow, 0,"AddressIndication: %d", gPhonebook_AddressIndication[PhonebookLine]);
                    
                    PhonebookLine++;
                    element = 0;
                    TelNumIndex = 0;
                    break;
                case 2:
                    element++;
                    TelNumIndex = 0;
                    break;
                case 3:
                    TelNumIndex++;
                    break;
                }
                j = 0;
            }
            else
            {
                part[j++] = buffer_byte[i];
            }
        }

          //IssueList #76 - MR49870 : Phonebook
	     // - if condition           
        if (getValue(env_FSG_PB_insert_UPD_button) == 0x00)
        gPhonebook_TotalNumListElements = PhonebookLine; //get "total number of list elements"
        
        putvalue(env_FSG_Phonebook_TotalNumLE, gPhonebook_TotalNumListElements);

        writelineEx(gPhonebook_writeWindow, 0,"Anzahl der Listenelemente: %d", gPhonebook_TotalNumListElements); //output total number of list elements

        if (fileClose (CSVfileHandle) !=0) //close *.csv file
            writelineEx(gPhonebook_writeWindow, 0,"Datei '%s' geschlossen", gPhonebook_CSV_filename); //output result
        else
            writelineEx(gPhonebook_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gPhonebook_CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
        writelineEx(gPhonebook_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gPhonebook_CSV_filename); //output result
        
        putvalue(env_FSG_Phonebook_DS_result,"not successful"); //output result
    }

        //IssueList #76 - MR49870 : Phonebook
         for(i =0; i<gPhonebook_TotalNumListElements; i++)
		gPhonebook_Pos_insDel[i] [0] =gPhonebook_Pos[i];

        if (getValue(env_FSG_PB_insert_UPD_button) == 0x00)
        gPB_totalDELctr = 0;


}

//IssueList #23
on envVar env_FSG_Telephone_HB_button
{
	long data[2];
    //IssueList #213
    data[0] = LSGID;
	if(getValue(this))
	{
        data[1]=getValue(env_FSG_Telephone_HB_input);
	}
	else
	{
		data[1] = 0;
	}
    ChangeConfig(0x00,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x0E_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_FSG_Setup;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x0F_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_FSG_OperationState;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x10_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_MobilServiceSupport;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x11_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_ActiveUser;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x12_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_RegisterState;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x13_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_LockState;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x14_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_NetworkProvider;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x15_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_SignalQuality;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x16_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_CallState;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x17_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_CallInfo;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x19_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_DisconnectReason;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x21_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_HandsFreeOnOff;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x22_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_MicroMuteOnOff;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x2A_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_Keypad;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x2B_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_MobileBatteryLevel;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x2C_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_DataConnectionIndication;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x2D_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_MissedCallIndication;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x33_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_PbState;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x37_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_SMSState;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x38_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_RingToneMuteOnOff;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x39_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_AutomaticRedial;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #23
on envVar env_FSG_Telephone_FctList_0x3A_HB
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_AutomaticRedialExtInfo;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #16
AutomaticRedialExtInfo_Request (byte request, byte errorcode)
{
int i, Offset;
dword requestarray [BAP_buffer_size];

//init lokal variables
	Offset=0;

	for(i=0;i<BAP_buffer_size;i++)
		requestarray [i]=0;
//********************
    switch (request)
    {
		case Data_REQ:
        //IssueList #62
    	if (getValue(env_FSG_Tel_FctList_0x3A_TimeOut)!=TRUE)
         {
    		 requestarray[0]=LSGID_Telephone;	//LSG-ID
    		 requestarray[1]=FctID_AutomaticRedialExtInfo;	//Fct.-ID
    		 requestarray[2]=request;
    			//Data
          	requestarray[3]=gAutomaticRedialTimeStamp & 0x00ff;			//Lowbyte of RedialTimeStamp
        	//requestarray[4]=(gAutomaticRedialTimeStamp & 0xff00)/0x100;
            requestarray[4]=(gAutomaticRedialTimeStamp & 0xff00)>>8;
            Offset = 5;
             requestarray[Offset]=strlen(gAutoRedialExtInfo_Name);
             Offset++;

                for(i=0;i<strlen(gAutoRedialExtInfo_Name);i++)
                {
    				requestarray[Offset]=gAutoRedialExtInfo_Name[i];
    				Offset++;
    			}
            
                requestarray[Offset]=strlen(gAutoRedialExtInfo_Number);
                Offset++;

    			for(i=0;i<strlen(gAutoRedialExtInfo_Number);i++)
                {
    				requestarray[Offset]=gAutoRedialExtInfo_Number[i];
    				Offset++;
    			}
                requestarray[Offset]=gAutomaticRedialCategory;
                Offset++;

                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
        break;
		
        case Error_REQ:
			requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=FctID_AutomaticRedialExtInfo;	//Fct.-ID
			requestarray[2]=request;	
			requestarray[3]=errorcode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
		break;
		default:	//error
			writelineEx(gError_Trace, 0, "FSG-Telephone AutoRedialExtInfo_Request: unknown request %d", request);
    }
}

//IssueList #16
AutomaticRedialExtInfo_Indication (dword indication_array[], byte indication, int datalength)
{

	switch (indication){
        case DataGet_IND:
			if(datalength != 3)															//datalength error
				AutomaticRedialExtInfo_Request(Error_REQ, Terror_unknownapllicationerror);	//send error-message 
			else
				AutomaticRedialExtInfo_Request(Data_REQ, 0);
		break;
		default:
			writelineEx(gError_Trace, 0, "FSG-Telephone AutomaticRedialExtInfo_Indication: unknown indication %d", indication);
		break;
	}
}

//IssueList #16
on envVar env_FSG_AutoRedialExtInfo_OK
{

    if(gFSG_Telephone_PowerOnOff == Power_on && getvalue(this))
    {
    getValue(env_FSG_AutoRedialExtInfo_Name, gAutoRedialExtInfo_Name);
    getvalue(env_FSG_AutoRedialExtInfo_TelNo, gAutoRedialExtInfo_Number);
    gAutomaticRedialCategory = getValue(env_FSG_AutoRedialExtInfo_Cat);

    gAutomaticRedialTimeStamp =  getValue(env_FSG_AutoRedialExtInfo_Tstamp);
   
    
     AutomaticRedialExtInfo_Request(Data_REQ, 0);
    }
}

on timer DisconnectReason_Timer
{
    if(getvalue(env_FSG_DisconnectReason_Active) != FALSE)
    {
        //DisconnectReason
    	gDisconnectReason=regulardisconnecting;                 //set Disconnect Reason to regular disconnecting
    	putvalue(env_FSG_DisconnectReason, gDisconnectReason);
    	DisconnectReason_Request(Data_REQ, 0);                  //send Disconnect Reason
    }

    //Method HangupCall.Result
	if(ghangupcall_status==1)
	{
        gHangupCall_Result=SUCCESSFUL;
		HangupCall_Request(Result_REQ, 0);
        ghangupcall_status=0;                               //method "hangupcall" finished

    }
}

//IssueList #49
on timer _tfreeBusyTimer
{
 EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);
}

CombinedNumbers_PBname ()
{
int i =0, j =0, k =0;

//changes for IssueList #152 - MR 53938
//TEL_COMBINEDNUMBERS_ENTRIES --> gCombinedNumbers_TotalNumListElements

gPhonebookRequestActive = 0x00;

    for (i=0; i<gCombinedNumbers_TotalNumListElements; i++)
    {
        if(gCombinedNumbers_ListEntryValidInformation[i] !=1)
        {       
            for (j=i; j<gCombinedNumbers_TotalNumListElements; j++)
            {
                if(gCombinedNumbers_ListEntryValidInformation[j])
                {                   
                    
                    
                    //PbName
                    for(k=0; k<TEL_COMBINEDNUMBERS_PBNAME_LENGTH; k++) //clear new position
                        gCombinedNumbers_PbName[i][k]=0; 
                    
                    for(k=0; k<strlen(gCombinedNumbers_PbName[j]); k++)
                        gCombinedNumbers_PbName[i][k]=gCombinedNumbers_PbName[j][k];

                    for(k=0; k<TEL_COMBINEDNUMBERS_PBNAME_LENGTH; k++) //clear old position
                        gCombinedNumbers_PbName[j][k]=0; 
                }
               }
            
           }
      
       }
}

//IssueList#20
putvalue_CallInfo_category(byte callID)
{
    switch(callID)
    {
        case 0:
            putvalue(env_FSG_CallInfo_Category_0_s, gCallInfo_Category[0]);
            putValue(env_FSG_CallInfo_Category_0,gDialedNumbers_NumberType_s[gDialNumber_Category]);
            //IssueList #16
            gAutomaticRedialCategory = gCallInfo_Category[0];
            break;
        case 1:
            putvalue(env_FSG_CallInfo_Category_1_s, gCallInfo_Category[1]);
            putValue(env_FSG_CallInfo_Category_1,gDialedNumbers_NumberType_s[gDialNumber_Category]);
            //IssueList #16
            gAutomaticRedialCategory = gCallInfo_Category[1];
            break;
        case 2:
            putvalue(env_FSG_CallInfo_Category_2_s, gCallInfo_Category[2]);
            putValue(env_FSG_CallInfo_Category_2,gDialedNumbers_NumberType_s[gDialNumber_Category]);
            //IssueList #16
            gAutomaticRedialCategory = gCallInfo_Category[2];
            break;
        case 3:
            putvalue(env_FSG_CallInfo_Category_3_s, gCallInfo_Category[3]);
            putValue(env_FSG_CallInfo_Category_3,gDialedNumbers_NumberType_s[gDialNumber_Category]);
            //IssueList #16
            gAutomaticRedialCategory = gCallInfo_Category[3];
            break;
        case 4:
            putvalue(env_FSG_CallInfo_Category_4_s, gCallInfo_Category[4]);
            putValue(env_FSG_CallInfo_Category_4,gDialedNumbers_NumberType_s[gDialNumber_Category]);
            //IssueList #16
            gAutomaticRedialCategory = gCallInfo_Category[4];
            break;
        case 5:
            putvalue(env_FSG_CallInfo_Category_5_s, gCallInfo_Category[5]);
            putValue(env_FSG_CallInfo_Category_5,gDialedNumbers_NumberType_s[gDialNumber_Category]);
            //IssueList #16
            gAutomaticRedialCategory = gCallInfo_Category[5];
            break;
        case 6:
            putvalue(env_FSG_CallInfo_Category_6_s, gCallInfo_Category[6]);
            putValue(env_FSG_CallInfo_Category_6,gDialedNumbers_NumberType_s[gDialNumber_Category]);
            //IssueList #16
            gAutomaticRedialCategory = gCallInfo_Category[6];
            break;
        default:
            write("putvalue_CallInfo: invalid call-ID: %d", callID);
            break;
    }
     putValue(env_FSG_AutoRedialExtInfo_Cat,gAutomaticRedialCategory);
}

on envVar env_FSG_AutoRedialExtInfo_Tstamp
{

if (getValue(this)>65535)
setTimer(updateEnvRedialTimeStamp,100);

gAutomaticRedialTimeStamp = getValue(this);

}

on timer updateEnvRedialTimeStamp
{
putValue(env_FSG_AutoRedialExtInfo_Tstamp, 65535);
}

//IssueList #69
on timer registerstatetimerDelay
{
	if(gemergencycall==2 || gemergencycall==3)
	{
		gRegisterState=registered;
		putvalue(env_FSG_RegisterState, gRegisterState);
		RegisterState_Request(Data_REQ, 0);	//send register state
		settimer(checknetworktimer, gtime_checknetworktimer);
	}
	else if(gNetworkProviderState)
	{
		gRegisterState=registered;
		putvalue(env_FSG_RegisterState, gRegisterState);
		RegisterState_Request(Data_REQ, 0);	//send register state
       
	}
		

    

}

on key 'a'
{
putValue(env_FSG_CN_CA,1);
}

on key 'b'
{
putValue(env_FSG_CN_CA,0);
}

//IssueList #76 - MR49870 : Phonebook
on envVar env_FSG_Phonebook_delete
{
    word startelement, elements, PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[PHONEBOOK_ENTRIES]; 
    dword requestarray [BAP_buffer_size], Offset, i;

    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    i                       =0;
    Offset                  =0;

    for(i =0; i<PHONEBOOK_ENTRIES; i++)
        POS[i] =0;
    
    for(i =0; i<BAP_buffer_size; i++)
        requestarray[i] =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
    gPB_DelInvalidCtr =0;
    gPB_DelValidCtr =0;

    for(i =0; i<PHONEBOOK_ENTRIES; i++)
        gPB_InvalidDel[i] =0;

    for(i =0; i<PHONEBOOK_ENTRIES; i++)
        gPhonebook_Send[i][0] =0;   //POS value


 	putvalue (env_FSG_PB_Insert_Message, empty_string);

    //MR 63332 #3   02.07.2014
    //gPB_TotalElem = getValue(env_FSG_Phonebook_TotalNumLE); 
    gPB_TotalElem = gPhonebook_TotalNumListElements;
    
        //get data from Panel
        recordaddress   =0x0F;
        shift           =0x1;
        direction       =0x1;
        transmitpos     =0x1;
        indexsize       =getvalue(env_FSG_PB_delete_size);;

        //message
        requestarray[0] =LSGID_Telephone;				//LSG-ID
    	requestarray[1] =FctID_Phonebook;		    //Fct.-ID
	    requestarray[2] =Changed_REQ;               //request type  
	    Offset =3;

    switch ( indexsize ) // POS size
    {
        case 0: //8Bit
        //MR 62005 if-else condition
        if (getValue(env_FSG_PB_delete_Auto)==0x00)
        {
        getvalue(env_FSG_Phonebook_delete_POS_8, POS);
    	startelement = getvalue(env_FSG_PB_delete_start);
        elements     =getValueSize(env_FSG_Phonebook_delete_POS_8);
        }
        else
        {
    	startelement = getvalue(env_FSG_PB_delete_start);
        elements     = 1;
        }
                
            //ErrHandler = ON
            if (getValue(env_FSG_Phonebook_delete_ErrHandler)==0x01)
            {
                if (elements==0x00)   // if no data
                    putValue(env_FSG_PB_delete_Message, "NO DATA TO SEND");

                else     // with data
                {
                    Phonebook_delete_ErrHandler_8 (POS,elements);
                    //if all elements are invalid
                    if (elements ==gPB_DelInvalidCtr)
                        putValue(env_FSG_PB_delete_Message, "POS INVALID");
                    else
                        elements = gPB_DelValidCtr;
                }
            }
            else  // no errorhandling
            {
                if (elements==0x00)   // if no data
                    transmitpos     =0x0;
            }
		
        
        //mode
        mode            =shift +(direction*0x02) +(transmitpos*0x04) +(indexsize*0x08);
		
        /***ArrayHeader***/
        requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
		Offset++;

        requestarray[Offset] =startelement;
        Offset++;  

        requestarray[Offset] =elements;
        Offset++;
                
        /***ArrayData***/
        //MR 62005 if-else condition
        if (getValue(env_FSG_PB_delete_Auto)==0x00)
        {
            if (getValue(env_FSG_Phonebook_delete_ErrHandler)==0x00)
            {
                for ( i = 0; i < elements; i++ )
                {
                requestarray[Offset] =POS[i];
                Offset++;
    	        }
    	    }//if
    		else
    		{
    			for (i=0; i<gPB_DelValidCtr; i++)
               		{
                		requestarray[Offset] =gPhonebook_Send[i][0];
                		Offset++;
    			    }
    		}
        }
        else
        {
                		requestarray[Offset] =getValue(env_FSG_PB_delete_POS_8_A);
                		Offset++;
        }
 		break;
            
      case 1:  //16Bit
        //MR 62005 if-else condition
        if (getValue(env_FSG_PB_delete_Auto)==0x00)
        {
        getvalue(env_FSG_Phonebook_delete_POS_16, POS);
        startelement  = getvalue(env_FSG_PB_delete_start);
        elements      = getValueSize(env_FSG_Phonebook_delete_POS_16)/2;
        }
        else
        {
        startelement  = getvalue(env_FSG_PB_delete_start);
        elements      = 1;
        }

        if (getValue(env_FSG_Phonebook_delete_ErrHandler)==0x01)
          { 
                    if (elements==0)   // if insufficient data
                    {
                    putValue(env_FSG_PB_delete_Message, "NO DATA TO SEND");
                    break;
                    }
                    
                    else     // with data
                    {
                    Phonebook_delete_ErrHandler_16 (POS,elements*2);
                        //if all elements are invalid
                        if (elements ==gPB_DelInvalidCtr/2)
                        {
                        putValue(env_FSG_PB_delete_Message, "ALL POS INVALID");
                        break;
                        }
                    
                        else
                       elements = gPB_DelValidCtr/2;
                    }
            }
        else  // no errorhandling
            {
            if (elements==0x00)   // if no data
            transmitpos     =0x0;
            }
        
                //mode
                mode  = shift + (direction*0x02) + (transmitpos*0x04) + (indexsize*0x08);

                /***ArrayHeader***/
                requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
                Offset++;

                requestarray[Offset] =startelement &0xff; 
                Offset++; 
                requestarray[Offset] =(startelement &0xff00) /0x100;
                Offset++;
                
                
                requestarray[Offset] =elements &0xff;
                Offset++;
                requestarray[Offset] =(elements &0xff00) /0x100;
                Offset++;

                /***ArrayData***/
                if (getValue(env_FSG_PB_delete_Auto)==0x00)
                {
                    if (getValue(env_FSG_Phonebook_delete_ErrHandler)==0x00)
                    {
                        for ( i = 0; i < elements; i++ )    //2 elements are inserted to the array below
                        {
                           requestarray[Offset] = POS[(2*i)+1];
                           Offset++;

                           requestarray[Offset] = POS[(2*i)];
                           Offset++;
                        }
                    }
                     else    // with error handling
                     {
                        for (i=0; i<elements; i++)
                        {
                               PosVal = 0x00;
                               requestarray[Offset] =gPhonebook_Send[(2*i)+1][0];
                               PosVal = requestarray[Offset];
                               Offset++;
						   
                                requestarray[Offset] = gPhonebook_Send[(2*i)+0][0];
                                PosVal = PosVal|requestarray[Offset]<<8;
                                Offset++;
							
                        } //for (i=0; i<gPB_DelValidCtr; i++)

                    } //else ERRORHANDLING
                } //env_FSG_PB_delete_Auto
                else
                {
                    requestarray[Offset]= (byte)(getValue(env_FSG_PB_delete_POS_16_A) & 0xFF);
                    Offset++;
                    requestarray[Offset]= (byte)(getValue(env_FSG_PB_delete_POS_16_A) >> 8);
                    Offset++;
                }

        break;

      default:
        break;
    }
        
        //DATA SENDING
        if (getValue(env_FSG_Phonebook_delete_ErrHandler)==0x00)
       set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 

        else
        {
            if (gPB_DelInvalidCtr!=0)
                putValue(env_FSG_PB_delete_Invalid,gPB_InvalidDel);

            if (gPB_DelValidCtr != 0x00)
            {
                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
                
                //MR 63332 #3   02.07.2014
                //if (indexsize == 0x00)
                //putValue(env_FSG_Phonebook_TotalNumLE, gPB_TotalElem -gPB_DelValidCtr);
                //else
                //putValue(env_FSG_Phonebook_TotalNumLE, gPB_TotalElem -(gPB_DelValidCtr/2));
                //gPhonebook_TotalNumListElements = getValue(env_FSG_Phonebook_TotalNumLE);

                if (indexsize == 0x00)
                gPhonebook_TotalNumListElements = gPB_TotalElem - gPB_DelValidCtr;
                else
                gPhonebook_TotalNumListElements = gPB_TotalElem - (gPB_DelValidCtr/2);
                putValue(env_FSG_Phonebook_TotalNumLE, gPhonebook_TotalNumListElements);
            }//if
        } //else

   }
}

//IssueList #68
on timer TelFctList_0x1A_ProcessingTimer
{
    if (gTelFctList_0x1A_Processing_flg==0x01)
    {
        gTelFctList_0x1A_Processing_flg = 0x00;
        gDialNumber_Result = NOT_SUCCESSFUL;
        DialNumber_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x1A_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x1E_ProcessingTimer
{
    if (gTelFctList_0x1E_Processing_flg==0x01)
    {
        gTelFctList_0x1E_Processing_flg = 0x00;
        gAcceptCall_Result = NOT_SUCCESSFUL;
        AcceptCall_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x1E_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x20_ProcessingTimer
{
    if (gTelFctList_0x20_Processing_flg==0x01)
    {
        gTelFctList_0x20_Processing_flg = 0x00;
        gResumeCall_Result = NOT_SUCCESSFUL;
        ResumeCall_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x20_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x1F_ProcessingTimer
{
    if (gTelFctList_0x1F_Processing_flg==0x01)
    {
        gTelFctList_0x1F_Processing_flg = 0x00;
        gCallHold_Result = NOT_SUCCESSFUL;
        CallHold_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x1F_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x1B_ProcessingTimer
{
    if (gTelFctList_0x1B_Processing_flg==0x01)
    {
        gTelFctList_0x1B_Processing_flg = 0x00;
        gDialService_Result = NOT_SUCCESSFUL;
        DialService_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x1B_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x1D_ProcessingTimer
{
    if (gTelFctList_0x1D_Processing_flg==0x01)
    {
        gTelFctList_0x1D_Processing_flg = 0x00;
        gHangupCall_Result = NOT_SUCCESSFUL;
        HangUpCall_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x1D_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x24_ProcessingTimer
{
    if (gTelFctList_0x24_Processing_flg==0x01)
    {
        gTelFctList_0x24_Processing_flg = 0x00;
        gMPSwap_Result = NOT_SUCCESSFUL;
        MPSwap_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x24_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x35_ProcessingTimer
{
    if (gTelFctList_0x35_Processing_flg==0x01)
    {
        gTelFctList_0x35_Processing_flg = 0x00;
        gPbSpeller_Result = NOT_SUCCESSFUL;
        PbSpeller_Request(Result_REQ, 0);
        putValue(env_FSG_Tel_FctList_0x35_3min_TO,0);	
    }
}

//IssueList #68
on timer TelFctList_0x1C_ProcessingTimer
{
    if (gTelFctList_0x1C_Processing_flg==0x01)
    {
        gTelFctList_0x1C_Processing_flg = 0x00;
        gConfirmErmergencyCall_result = NOT_SUCCESSFUL;
        ConfirmEmergencyCall_Request(Result_REQ, 0);
        putValue(env_FSG_Tel_FctList_0x1C_3min_TO,0);
         //IssueList #180
         if (gConfirmEcall_3minProc_flg ==0x01)
         {
         setTimer(checkEcallConfirmPending,3);
         gConfirmEcall_3minProc_flg = 0x00;
         }
         	
    }
}

//IssueList #68
on timer TelFctList_0x28_ProcessingTimer
{
    if (gTelFctList_0x28_Processing_flg==0x01)
    {
        gTelFctList_0x28_Processing_flg = 0x00;
        gCCJoin_Result = NOT_SUCCESSFUL;
        CCJoin_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x28_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x36_ProcessingTimer
{
    if (gTelFctList_0x36_Processing_flg==0x01)
    {
        gTelFctList_0x36_Processing_flg = 0x00;
        gGetNextListPos_Result = NOT_SUCCESSFUL;
        GetNextListPos_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x36_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x25_ProcessingTimer
{
    if (gTelFctList_0x25_Processing_flg==0x01)
    {
        gTelFctList_0x25_Processing_flg = 0x00;
        gMPCHAWC_Result = NOT_SUCCESSFUL;
        MPCHAWC_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x25_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x23_ProcessingTimer
{
    if (gTelFctList_0x23_Processing_flg==0x01)
    {
        gTelFctList_0x23_Processing_flg = 0x00;
        gMPRACAWC_Result = NOT_SUCCESSFUL;
        MPRACAWC_Request(Result_REQ, 0);
        putValue(env_FSG_Tel_FctList_0x23_3min_TO,0);	
    }
}

//IssueList #68
on timer TelFctList_0x26_ProcessingTimer
{
    if (gTelFctList_0x26_Processing_flg==0x01)
    {
        gTelFctList_0x26_Processing_flg = 0x00;
        gMPRAllCAWC_Result = NOT_SUCCESSFUL;
        MPRAllCAWC_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x26_3min_TO,0);
    }
}

//IssueList #68
on timer TelFctList_0x27_ProcessingTimer
{
    if (gTelFctList_0x27_Processing_flg==0x01)
    {
        gTelFctList_0x27_Processing_flg = 0x00;
        gMPSWCOH_Result = NOT_SUCCESSFUL;
        MPSWCOH_Request(Result_REQ, 0);	
        putValue(env_FSG_Tel_FctList_0x27_3min_TO,0);
    }
}

on envVar env_FSG_CN_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        //get data from Panel
              
        recordaddress   =0;
        shift           =0;
        direction       =0;
        transmitpos     =0;
        indexsize       =0;
        startelement    =0;
        //IssueList #76 MR49870 : CN
        elements        =255;
        //elements        =65535;
        
        //MR 63332 #2 02.07.2014
        /*putvalue(env_FSG_CN_AH_RA, recordaddress);
        putvalue(env_FSG_CN_AH_shift, shift);
        putvalue(env_FSG_CN_AH_dir, direction);
        putvalue(env_FSG_CN_AH_POS, transmitpos);
        putvalue(env_FSG_CN_AH_IS, indexsize);
        putvalue(env_FSG_CN_AH_start, startelement);
        putvalue(env_FSG_CN_AH_elements, elements);
        putvalue(env_FSG_CN_CA_switch, FALSE);*/

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        //send ChangedArray
        
        //MR 63667 11.07.2014 -TNLE with SA-button
        //CombinedNumbers_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
        CombinedNumbers_Request(Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0);
    }
}

on envVar env_FSG_FL_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        //get data from Panel
              
        recordaddress   =0;
        shift           =0;
        direction       =0;
        transmitpos     =0;
        indexsize       =0;
        startelement    =0;
        //IssueList #76 MR49870 : FL
        elements        =255;
        //elements        =65535;
        
        //MR 63332 #2 02.07.2014
        /*putvalue(env_FSG_FL_AH_RA, recordaddress);
        putvalue(env_FSG_FL_AH_shift, shift);
        putvalue(env_FSG_FL_AH_dir, direction);
        putvalue(env_FSG_FL_AH_POS, transmitpos);
        putvalue(env_FSG_FL_AH_IS, indexsize);
        putvalue(env_FSG_FL_AH_start, startelement);
        putvalue(env_FSG_FL_AH_elements, elements);
        putvalue(env_FSG_FL_CA_switch, FALSE);*/

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        //send ChangedArray
        
        //MR 63667 11.07.2014 -TNLE with SA-button
        //CombinedNumbers_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
        FavoriteList_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
    }
}

on envVar env_FSG_Phonebook_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
        //get data from Panel
              
        recordaddress   =0;
        shift           =0;
        direction       =0;
        transmitpos     =0;
        indexsize       =0;
        startelement    =1;
        elements        =255;
        
        //MR 63332 #2 02.07.2014
        /*
        putvalue(env_FSG_Phonebook_AH_RA, recordaddress);
        putvalue(env_FSG_Phonebook_AH_shift, shift);
        putvalue(env_FSG_Phonebook_AH_dir, direction);
        putvalue(env_FSG_Phonebook_AH_POS, transmitpos);
        putvalue(env_FSG_Phonebook_AH_IS, indexsize);
        putvalue(env_FSG_Phonebook_AH_start, startelement);
        putvalue(env_FSG_Phonebook_AH_elements, elements);
        */
       
        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        //send ChangedArray
        //MR 63667 11.07.2014 -TNLE with SA-button
        //Phonebook_Request(Changed_REQ, requested_startelement, startelement, elements,mode, 0);
        Phonebook_Request(Changed_REQ, 0, requested_startelement, startelement, elements,mode, 0);

    }
}

//IssueList #99
on envVar env_FSG_DialNumber_TelNumber
{
gFirstPress = 0x00;
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x1A_3min_TO
{
gTelFctList_0x1A_Processing_flg = getValue(this);

    if (gTelFctList_0x1A_Processing_flg == 0x00)
    {
    cancelTimer(TelFctList_0x1A_ProcessingTimer);
 
    //IssueList #112
    putValue(env_FSG_DialNumber_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_DialNumber_Result,NOT_SUCCESSFUL);

}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x1E_3min_TO
{
gTelFctList_0x1E_Processing_flg = getValue(this);

    if (gTelFctList_0x1E_Processing_flg == 0x00)
    {
    cancelTimer(TelFctList_0x1E_ProcessingTimer);

    //IssueList #112
    putValue(env_FSG_AcceptCall_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_AcceptCall_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x20_3min_TO
{
gTelFctList_0x20_Processing_flg = getValue(this);

if (gTelFctList_0x20_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x20_ProcessingTimer);
//IssueList #112
    putValue(env_FSG_CallResume_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_CallResume_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x1F_3min_TO
{
gTelFctList_0x1F_Processing_flg = getValue(this);

if (gTelFctList_0x1F_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x1F_ProcessingTimer);

    //IssueList #112
    putValue(env_FSG_CallHold_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_CallHold_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x1B_3min_TO
{
gTelFctList_0x1B_Processing_flg = getValue(this);

if (gTelFctList_0x1B_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x1B_ProcessingTimer);

    //IssueList #112
    putValue(env_FSG_DialService_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_DialService_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x1D_3min_TO
{
gTelFctList_0x1D_Processing_flg = getValue(this);

if (gTelFctList_0x1D_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x1D_ProcessingTimer);

  //IssueList #112
    putValue(env_FSG_HangUpCall_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_HangUpCall_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x23_3min_TO
{
gTelFctList_0x23_Processing_flg = getValue(this);

if (gTelFctList_0x23_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x23_ProcessingTimer);
    //IssueList #112
    putValue(env_FSG_MPRACAWC_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_MPRACAWC_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x24_3min_TO
{
gTelFctList_0x24_Processing_flg = getValue(this);

if (gTelFctList_0x24_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x24_ProcessingTimer);
    //IssueList #112
    putValue(env_FSG_MPSwap_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_MPSwap_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x25_3min_TO
{
gTelFctList_0x25_Processing_flg = getValue(this);

if (gTelFctList_0x25_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x25_ProcessingTimer);
  //IssueList #112
    putValue(env_FSG_MPCHAWC_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_MPCHAWC_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x35_3min_TO
{
gTelFctList_0x35_Processing_flg = getValue(this);

if (gTelFctList_0x35_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x35_ProcessingTimer);
    //IssueList #112
    putValue(env_FSG_PbSpeller_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_PbSpeller_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x1C_3min_TO
{
gTelFctList_0x1C_Processing_flg = getValue(this);

if (gTelFctList_0x1C_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x1C_ProcessingTimer);

   //IssueList #112
    putValue(env_FSG_ConfirmECall_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_ConfirmECall_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x28_3min_TO
{
gTelFctList_0x28_Processing_flg = getValue(this);

if (gTelFctList_0x28_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x28_ProcessingTimer);
    //IssueList #112
    putValue(env_FSG_CCJoin_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_CCJoin_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x26_3min_TO
{
gTelFctList_0x26_Processing_flg = getValue(this);

if (gTelFctList_0x26_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x26_ProcessingTimer);
    //IssueList #112
    putValue(env_FSG_MPRAllCAWC_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_MPRAllCAWC_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x27_3min_TO
{
gTelFctList_0x27_Processing_flg = getValue(this);

if (gTelFctList_0x27_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x27_ProcessingTimer);

    //IssueList #112
    putValue(env_FSG_MPSWCOH_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_MPSWCOH_Result,NOT_SUCCESSFUL);
}

//IssueList #68
on envVar env_FSG_Tel_FctList_0x36_3min_TO
{
gTelFctList_0x36_Processing_flg = getValue(this);

if (gTelFctList_0x36_Processing_flg == 0x00)
{
cancelTimer(TelFctList_0x36_ProcessingTimer);
//IssueList #112
    putValue(env_FSG_GetNextListPos_Result,SUCCESSFUL);
    }
    else
    putValue(env_FSG_GetNextListPos_Result,NOT_SUCCESSFUL);
}

//IssueList #160 MR49588
//addition of assumed 5 second time out for confirmPending flag check
on timer checkEcallConfirmPending
{
    if (gCallOutgoingDiverted_eCallConfirmationPending[7] == 0x01)
    {
    gCallOutgoingDiverted_eCallConfirmationPending[7] = 0;
    CallState_Request(Data_REQ, 0); // send CallState.Status: 'eCall confirmation pending' = false
    gDialNumber_status = 0;
    gDialService_status = 0;
    gFirstPress = 0;
    }
}

//IssueList #76 - MR49870 : Phonebook
on envVar env_FSG_Phonebook_delete_POS_8
{
byte DEL_POS_8[PHONEBOOK_ENTRIES];

putValue(env_FSG_PB_delete_Message, empty_string);
 
    //AUTOMATIC START VALUE
    if (getValue(env_FSG_Phonebook_delete_ErrHandler)==0x01)
    {
    getValue(this, DEL_POS_8);
    putValue(env_FSG_PB_delete_start, DEL_POS_8[0]);
    }

}

//IssueList #76 - MR49870 : Phonebook
on envVar env_FSG_Phonebook_delete_ErrHandler
{
if (getValue(this)==0x00)
putValue(env_FSG_Phonebook_TotalNumLE,gPB_CSVtotalElem);
}

//IssueList #76 - MR49870 : Phonebook
Phonebook_delete_ErrHandler_8 (byte pos[],word elementsCtr)
{
    byte i, result,delFlg;
    word PBlistCtr, PosCtr;
    
    result = 0x01;
    delFlg=0;
    gPB_DelInvalidCtr = 0;
    gPB_DelValidCtr =0;
    putValue(env_FSG_PB_delete_Message, empty_string);
    
    for (PosCtr =0; PosCtr<elementsCtr; PosCtr++)
    {
         result =0x00;
         delFlg = 0x00;

      for (PBlistCtr = 0;PBlistCtr<gPB_CSVtotalElem; PBlistCtr++)
      {    
           if (pos[PosCtr]==gPhonebook_Pos_insDel[PBlistCtr][0])   //check if POS is valid
           {
             if (gPhonebook_Pos_insDel[PBlistCtr][1]!=0x01)  //check if POS still exists
               {
               gPhonebook_Pos_insDel[PBlistCtr][1] = 0x01;    //tagging deleted Pos
               gPhonebook_Send[gPB_DelValidCtr][0] = pos[PosCtr];
               
               gPB_DelValidCtr++;
               gPB_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue(env_FSG_PB_delete_Message, "POS already deleted!");
              gPB_InvalidDel[gPB_DelInvalidCtr] = pos[PosCtr];
              gPB_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }
              
           }//if
           
       }//for
        if (result == 0x00 && delFlg == 0x00)
        {
          gPB_InvalidDel[gPB_DelInvalidCtr]=pos[PosCtr];
          gPB_DelInvalidCtr++;
          putValue(env_FSG_PB_delete_Message, "INVALID POS!");
         }

     }
}

//IssueList #76 - MR49870 : AllList
byte telephoneList_deleteCheck (word currentPos, word telephoneList_Pos_insDel[][], word totalElem)
{
byte i, posDeletedFlg;

posDeletedFlg = 0;

    for (i=0;i<totalElem;i++)
    {
        if (currentPos == telephoneList_Pos_insDel[i][0])
        {
            if (telephoneList_Pos_insDel[i][1]==0x01)  //check if POS is deleted
            {
            posDeletedFlg = 0x01;
            break;
            }
        }
    }
        return posDeletedFlg;
}

//IssueList #76 - MR49870 : Phonebook
on envVar env_FSG_Phonebook_insert
{
    word startelement, elements,successor, ctr, PosCtr,PBlistCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[PHONEBOOK_ENTRIES], posInBetweenCheck;
    dword requestarray [BAP_buffer_size], Offset, i;
 
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    i                       =0;
    Offset                  =0;
    elemTemp		        =0;
    PosVal                  =0;


    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {

        for(i =0; i<PHONEBOOK_ENTRIES; i++)
            POS[i] =0;

        for(i =0; i<BAP_buffer_size; i++)
            requestarray[i] =0;

        for(i =0; i<PHONEBOOK_ENTRIES; i++)
            gPB_InvalidIns[i] =0;

        for(i =0; i<PHONEBOOK_ENTRIES; i++)
            gPhonebook_Send[i][0] =0;
    
        putValue(env_FSG_PB_Insert_Invalid,gPB_InvalidIns);

        gPB_InsInvalidCtr=0;
        gPB_InsValidCtr =0;
        putValue(env_FSG_PB_Insert_Message, empty_string);

        //get data from Panel
        //Patch GB 11.07.2014 -commented
        //recordaddress   =0x0F;

        putvalue (env_FSG_PB_Insert_Message, empty_string);
        //MR 63332 #3   02.07.2014
        //gPB_TotalElem = getValue(env_FSG_Phonebook_TotalNumLE);
        gPB_TotalElem = gPhonebook_TotalNumListElements;

        if (getValue(env_FSG_PB_insert_UPD_button)==0x00)
        {
            shift           =0x01; //insert
            //Patch GB 11.07.2014
            recordaddress   =0x0F;
        }
        else
        {
            shift           =0x0; //update
            //Patch GB 11.07.2014
            recordaddress   =getValue(env_FSG_Phonebook_AH_RA);
        }

        direction       =0x0;
        transmitpos     =0x01;

        indexsize       =getvalue(env_FSG_PB_insert_size);
        //mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        //message
        requestarray[0] =LSGID_Telephone;				//LSG-ID
        requestarray[1] =FctID_Phonebook;		//Fct.-ID
        requestarray[2] =Changed_REQ;                  //request type  
        Offset =3;
        
        startelement    =getValue(env_FSG_PB_insert_start);
        
        successor = getValue(env_FSG_PB_insert_successor);
      

        switch (indexsize) // POS size
        {
            case 0: //8Bit
                getvalue(env_FSG_Phonebook_insert_POS_8, POS);
                //MR 62005 if-else condition
                if (getValue(env_FSG_PB_insert_Auto)==0x00)
                ctr = getValueSize(env_FSG_Phonebook_insert_POS_8);
                else
                ctr = 1;

                if (getValue(env_FSG_Phonebook_insert_Err)==0x01)
                {

                    if (ctr == 0)   // if no data
                    {
                        putValue(env_FSG_PB_Insert_Message, "NO DATA TO SEND");
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid for Insert
                        if (getvalue(env_FSG_PB_insert_start) == 0x00 && getvalue(env_FSG_PB_insert_successor) == 0x00 && getvalue(env_FSG_PB_insert_UPD_button) == 0x00)
                        {
                            //check if not all elements are deleted
                            if (gPB_totalDELctr < gPB_CSVtotalElem)
                            {
                            putValue(env_FSG_PB_Insert_Message, "INVALID START & SUCCESSOR");
                            break;
                            }
                        }
                        
                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                        posInBetweenCheck       =0;
                        if (ctr >1)
                        {
                            posInBetweenCheck =  pbPosSequence_check (indexsize,POS,ctr);
                            if (posInBetweenCheck == 0x01)
                            {
                                putValue(env_FSG_PB_Insert_Message, "INCORRECT POS SEQUENCE!");
                                break;
                            }
                        }
                     
                       //ERROR CHECKING
                        Phonebook_insert_ErrHandler_8 (POS,ctr);
                        
                        //if update has invalid POS - do not send
                        if (getvalue(env_FSG_PB_insert_UPD_button) == 0x01)  //update
                        {
                            if (gPB_InsInvalidCtr>0)
                            {
                                putValue(env_FSG_PB_Insert_Message, "INVALID POS EXISTS");
                                break;
                            }
                        }
 
                     
                        //if all elements are INVALID for INSERT
                        if (ctr == gPB_InsInvalidCtr)
                        {
                            putValue(env_FSG_PB_Insert_Message, "POS INVALID / STILL EXIST");
                            break;
                        }
                        else
                        {
                            elements = gPB_InsValidCtr+1;   //+ successor
                            ctr = gPB_InsValidCtr;
                        }

                    }//else with data
                }
                else   // no error handling
                {
                    elements = ctr+1;
                    if (ctr==0)    // if no data
                    {
                        transmitpos     =0x0;

                        if (successor == 0x00)  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                            elements = successor - startelement;
                    }    
                 }

                //mode
                mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***ArrayHeader***/
                requestarray[Offset] = ((mode *0x10) &0xF0) +(recordaddress &0x0F);
                Offset++;

                //start
                requestarray[Offset] = startelement;
                Offset++;  
                
                //elements
                requestarray[Offset] = elements;
                Offset++;

                /***ArrayData***/
                //MR 62005 if-else condition
                if (getValue(env_FSG_PB_insert_Auto)==0x00)
                {
                    //ArrayData with error handling
                    if (getValue(env_FSG_Phonebook_insert_Err)==0x01)
                    {
                        //ARRAY DATA
                            for (i=0; i<ctr; i++)
                                {
                                    //store in array the inserted item
                                    requestarray[Offset] = gPhonebook_Send[i][0];
                                    Offset++;
                                }
                  
                    } //end if with ERROR handling

                    //ArrayData WITHOUT error handling
                    else
                    {
                         for (i=0; i<ctr; i++)
                         {
                            requestarray[Offset] =POS[i];
                            Offset++;
                         }
                    }
                 }//env_FSG_PB_insert_Auto
                 else
                 {
                   requestarray[Offset] =getValue(env_FSG_CN_insert_POS_8_A);
                   Offset++;
                 }

                //successor
                if (ctr > 0)
                {
                    requestarray[Offset] = successor;
                    Offset++;    
                }

            break;
            
            case 1:  //16Bit
                //MR 62005 if-else condition
                if (getValue(env_FSG_PB_insert_Auto)==0x00)
                {
                getvalue(env_FSG_Phonebook_insert_POS_16, POS);
                elements = getValueSize(env_FSG_Phonebook_insert_POS_16);
                elemTemp = (getValueSize(env_FSG_Phonebook_insert_POS_16)/2);
                }
                else
                {
                elements = 2;
                elemTemp = 1;
                }

                if (getValue(env_FSG_Phonebook_insert_Err)==0x01)
                {
                    if (elemTemp==0)   // if no data
                    {
                        putValue(env_FSG_PB_Insert_Message, "NO DATA TO SEND");
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid
                        if ((getvalue(env_FSG_PB_insert_start) == 0x00) && (getvalue(env_FSG_PB_insert_successor) == 0x00)&& (getvalue(env_FSG_PB_insert_UPD_button) == 0x00))
                        {
                            //check if not all elements are deleted
                            if (gPB_totalDELctr < gPB_CSVtotalElem)
                            {
                            putValue(env_FSG_PB_Insert_Message, "INVALID START & SUCCESSOR");
                            break;
                            }
                        }
                          
                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                            if (ctr >1)
                            {
                                posInBetweenCheck =  pbPosSequence_check (indexsize,POS,elemTemp);
                                if (posInBetweenCheck == 0x01)
                                {
                                    putValue(env_FSG_PB_Insert_Message, "INCORRECT POS SEQUENCE!");
                                    break;
                                }
                            }

                       Phonebook_insert_ErrHandler_16 (POS,elements);
                        //if all elements are INVALID

                        //if update has invalid POS - do not send
                        if (getvalue(env_FSG_PB_insert_UPD_button) == 0x01)  //update
                        {
                            if (gPB_InsInvalidCtr>0)
                            {
                                putValue(env_FSG_PB_Insert_Message, "INVALID POS EXISTS");
                                break;
                            }
                        }
                    
                        if (elemTemp == gPB_InsInvalidCtr)
                        {
                            putValue(env_FSG_PB_Insert_Message, "POS INVALID / STILL EXIST");
                            break;
                        }
                        else
                        {
                            elements = (gPB_InsValidCtr/2)+1;     //including successor
                            elemTemp = gPB_InsValidCtr/2;
                        }

                    } //else with data
                } //with errorHandling
                else   // no error handling
                {
                    elements = elemTemp + 1;  //including successor
                    if (elemTemp==0)    // if no data
                    {
                        transmitpos = 0x0;
                         if (successor == 0x00)  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                        elements = successor - startelement;
                    }
                }

                //mode
                mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***ArrayHeader***/
                requestarray[Offset] = ((mode*0x10)&0xF0) + (recordaddress&0x0F);
                Offset++;

                requestarray[Offset] = startelement&0xff; 
                Offset++;
                requestarray[Offset] = (startelement&0xff00) / 0x100;
                Offset++;
                
                requestarray[Offset] = elements&0xff;
                Offset++;
                requestarray[Offset] = (elements&0xff00) / 0x100;
                Offset++;

                /***ArrayData***/
                //MR 62005 if-else condition
                if (getValue(env_FSG_PB_insert_Auto)==0x00)
                {
                    //ArrayData with error handling
                    if (getValue(env_FSG_Phonebook_insert_Err)==0x01)
                    {
                        for ( i = 0; i < elemTemp; i++ )
                            {
                                PosVal = 0x00;

                                //store in array the inserted item
                                requestarray[Offset] = gPhonebook_Send[(2*i)+1][0];
                                PosVal = requestarray[Offset];
                                Offset++;
                                requestarray[Offset] = gPhonebook_Send[(2*i)+0][0];
                                PosVal = PosVal|requestarray[Offset]<<8;
                                Offset++;
                             }
					
					
                    } // end if with Errorhandling
                    //ArrayData WITHOUT error handling
                    else
                    {
                        for ( i = 0; i < elemTemp; i++ )
                        {
                            requestarray[Offset] = POS[(2*i)+1];
                            Offset++;
                            requestarray[Offset] = POS[(2*i)+0];
                            Offset++;
                        }
                    }
                  }//env_FSG_PB_insert_Auto
                  else
                  {
                    requestarray[Offset]= (byte)(getValue(env_FSG_PB_insert_POS_16_A) & 0xFF);
                    Offset++;
                    requestarray[Offset]= (byte)(getValue(env_FSG_PB_insert_POS_16_A) >> 8);
                    Offset++;
                  }

                //successor
                if (elemTemp > 0)
                {
                    requestarray[Offset] = successor&0xff; 
                    Offset++;
                    requestarray[Offset] = (successor&0xff00) / 0x100;
                    Offset++;
                }
                break; 

            default:
                break; //default

        }//switch

        if (indexsize==0x01)
        gPB_InsValidCtr = gPB_InsValidCtr/2;

        //updating the totalDeletedCtr;
   		gPB_totalDELctr = gPB_totalDELctr - gPB_InsValidCtr;
        
        if (gPB_totalDELctr > gPB_CSVtotalElem)
        gPB_totalDELctr=0;

                
        //just send the data when errorhandler is OFF
        if (getValue(env_FSG_Phonebook_insert_Err)==0x00)
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
        
        else if (getValue(env_FSG_Phonebook_insert_Err)==0x01)  //with ERROR HANDLER
        {
            if (getValue(env_FSG_PB_insert_UPD_button)==0x00)  //insert
            {
                // if there's a Valid POS and Sequence is correct
                if (gPB_InsValidCtr != 0x00 && posInBetweenCheck == 0x00)
                {
                    set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
                    
                    if (gPB_TotalElem +gPB_InsValidCtr <=gPB_CSVtotalElem)
                    {
                        //MR 63332 #3   02.07.2014
                        //putValue(env_FSG_Phonebook_TotalNumLE, gPB_TotalElem +gPB_InsValidCtr);
                        //gPhonebook_TotalNumListElements = getValue(env_FSG_Phonebook_TotalNumLE);

                        gPhonebook_TotalNumListElements = gPB_TotalElem + gPB_InsValidCtr;
                        putValue(env_FSG_Phonebook_TotalNumLE, gPhonebook_TotalNumListElements);
                    } //if
               
                
                }// if gPB_InsValidCtr
            }// if insert
            else
            {
                //send only UPDATE if all POS are valid and DATA!=0
                if (gPB_InsInvalidCtr == 0x00 && gPB_InsValidCtr!=0)
                    set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
            }// else UPD button
        } //else if 
    }
    //else
    //putValue(env_FSG_PB_insert_UPD_button,0);
}

//IssueList #76 - MR49870 : Phonebook
on envVar env_FSG_Phonebook_insert_Err
{
if (getValue(this)==0x00)
putValue(env_FSG_Phonebook_TotalNumLE,gPB_CSVtotalElem);
}

//IssueList #76 - MR49870 : Phonebook
void Phonebook_insert_ErrHandler_8 (byte pos[],word elementsCtr)
{
    byte i, result,InsFlg;
    word PBlistCtr, PosCtr;
    
    result = 0x01;
    InsFlg=0;

  
    for (PosCtr =0; PosCtr<elementsCtr; PosCtr++)
    {
         result =0x00;
         InsFlg = 0x00;
        
      for (PBlistCtr = 0;PBlistCtr<gPB_CSVtotalElem; PBlistCtr++)
      {    
           if (pos[PosCtr]==gPhonebook_Pos_insDel[PBlistCtr][0])   //check if POS is valid
           {
            //UPDATE      
                if  (getValue(env_FSG_PB_insert_UPD_button) == 0x01) 
                 {  
                        if (gPhonebook_Pos_insDel[PBlistCtr][1]==0x00)  //check if POS is not deleted            {
                        {
                        result = 0x01; 
                        gPhonebook_Send[gPB_InsValidCtr][0] = pos[PosCtr];  
                        gPB_InsValidCtr++;
                        }
                    
                        else
                          {
                          putValue(env_FSG_PB_Insert_Message, "POS is already deleted!");
                          gPB_InvalidIns[gPB_InsInvalidCtr] = pos[PosCtr];
                          gPB_InsInvalidCtr++;
                          InsFlg = 0x01;
                          break;
                          }

                }  //update

                 else   //INSERT
                 {
                     if (gPhonebook_Pos_insDel[PBlistCtr][1]==0x01)  //check if POS does not exist
                       {
                       gPhonebook_Pos_insDel[PBlistCtr][1] = 0x00;
                       gPhonebook_Send[gPB_InsValidCtr][0] = pos[PosCtr];

                       gPB_InsValidCtr++;
                       result = 0x01;
                       }
                      else
                      {
                      putValue(env_FSG_PB_Insert_Message, "POS still exists!");
                      gPB_InvalidIns[gPB_InsInvalidCtr] = pos[PosCtr];
                      gPB_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                      }
               }//if
            } //else
       }//for
        if (result == 0x00 && InsFlg == 0x00)
           {
           gPB_InvalidIns[gPB_InsInvalidCtr]=pos[PosCtr];
            gPB_InsInvalidCtr++;
             putValue(env_FSG_PB_Insert_Message, "INVALID POS!");
            }
     }//for PBlistCtr

     if (gPB_InsInvalidCtr!=0)
            putValue(env_FSG_PB_Insert_Invalid,gPB_InvalidIns);
}

//IssueList #76 - MR49870 : Phonebook
//Automatic START AND SUCCESSOR VALUES
on envVar env_FSG_Phonebook_insert_POS_8
{
byte INS_POS_8[PHONEBOOK_ENTRIES];
int inputCtr,i,j;
byte valid_INS_POS_8;
byte validInputFlg_start, validInputFlg_succ;

putvalue (env_FSG_PB_Insert_Message, empty_string);


    //if (getValue(env_FSG_PB_insert_ErrHandler)==0x01 && getValue(env_FSG_PB_insert_UPD_button)==0x00)
    if (getValue(env_FSG_Phonebook_insert_Err)==0x01)
    {
    getValue(this, INS_POS_8);
    validInputFlg_start =0;
    validInputFlg_succ = 0;

     inputCtr=  getValueSize(env_FSG_Phonebook_insert_POS_8);

     if (inputCtr>0)
     {       
        //look for the valid reference for Start and successor
         for (j=0; j<inputCtr;j++)
         {
             valid_INS_POS_8 = INS_POS_8[j];
     
             for (i=0; i<gPB_CSVtotalElem;i++)
             {
             //check if input is valid and deleted
                 if (valid_INS_POS_8 == gPhonebook_Pos_insDel[i][0] && gPhonebook_Pos_insDel[i][1]==0x01)
                 {
                 validInputFlg_start = 1;
                 break;
                 }
             } 
             if (validInputFlg_start == 0x01) 
             break;   
          }

            if (validInputFlg_start == 0x01)
            {
            //start
             if (valid_INS_POS_8==gPhonebook_Pos_insDel[0][0])
                 putValue(env_FSG_PB_insert_start,0);
             
             else
             {   
                ///look for the next existing element upwards
                 for (i=0; i<gPB_CSVtotalElem;i++)
                 {
                     if (valid_INS_POS_8==gPhonebook_Pos_insDel[i][0])
                     {   
                        for (j=i-1;j>=0;j--)
                         {
                         if (gPhonebook_Pos_insDel[j][1]!=0x01)
                            {
                             putValue(env_FSG_PB_insert_start,gPhonebook_Pos_insDel[j][0]);
                             break;
                             }//if
                         }//for
                      }
                 }//for
             }//else
            } //validInputFlg

                //successor
                //look for the valid reference for Start and successor

                for (j=inputCtr-1; j>=0;j--)
                {
                     valid_INS_POS_8 = INS_POS_8[j];
     
                     for (i=0; i<gPB_CSVtotalElem;i++)
                     {
                     //check if input is valid and deleted
                         if (valid_INS_POS_8 == gPhonebook_Pos_insDel[i][0] && gPhonebook_Pos_insDel[i][1]==0x01)
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     } 
                     if (validInputFlg_succ == 0x01) 
                     break;     
                }
                if (validInputFlg_succ == 0x01)
                {
                    putValue(env_FSG_PB_insert_successor,0);
                
                    for (i=0; i<gPB_CSVtotalElem;i++)
                    {
                        if (valid_INS_POS_8==gPhonebook_Pos_insDel[i][0])
                         {
                         if (i==gPB_CSVtotalElem-1)
                         putValue(env_FSG_PB_insert_successor,0);
                         else
                            {
                                 //look for the next existing element downwards
                                 for (j=i+1;j<gPB_CSVtotalElem;j++)
                                 {
                                     if (gPhonebook_Pos_insDel[j][1]!=0x01)
                                     {
                                     putValue(env_FSG_PB_insert_successor,gPhonebook_Pos_insDel[j][0]);
                                     break;
                                     }
                                 }
                             }//else

                        }//if
                 }//for
               }
          
        } //inputCtr
    }

}

//IssueList #76 - MR49870 : Phonebook
byte pbPosSequence_check (byte Index, byte inputArray[],word inputCtr)
{
	byte posInBetween;
	word ctr,ctr1,ctr2,PosVal1_,PosVal2_;

	posInBetween = 0;
	
	for (ctr = 0; ctr < inputCtr; ctr++)
	{
		// adjust for 8bit and 16bit handling
		if (Index==0x00)
		{
			PosVal1_ = inputArray[ctr];
			PosVal2_ = inputArray[ctr+1];
		}
		else
		{
			PosVal1_ = 0x0000;
			PosVal1_ = inputArray[(2*ctr)+1];
			PosVal1_ = PosVal1_|((inputArray[(2*ctr)+0])<<8);
			PosVal2_ = 0x0000;
			PosVal2_ = inputArray[(2*ctr)+2+1];
			PosVal2_ = PosVal2_|((inputArray[(2*ctr)+2+0])<<8);			
		}
		
		// search send item in insdel array
		for( ctr1 = 0; ctr1 < gPB_CSVtotalElem; ctr1++ )
		{
			if( PosVal1_ == gPhonebook_Pos_insDel[ctr1][0]) // 1st send item is found in array			
			{
				break;
			}
		}
		
		// search insdel array for next send item
		for( ctr2 = ctr1+1; ctr2 < gPB_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
		{

			if (PosVal2_ == gPhonebook_Pos_insDel[ctr2][0]) // 2nd send item immediately next to 1st send item			
			{
				break;
			}
			else
			{
				if (gPhonebook_Pos_insDel[ctr2][1] == 0 && PosVal2_ !=0)	// in between item is not deleted
				{
					posInBetween = 0x01;
					break;
				}
			}
		}
		
		if( posInBetween == 0x01)
		{
			break;
		}
	}
	
	return posInBetween;

    }

//IssueList #76 - MR49870 : Phonebook
on envVar env_FSG_Phonebook_delete_POS_16
{
byte DEL_POS_16[PHONEBOOK_ENTRIES];
word PosVal_16;

putValue(env_FSG_PB_delete_Message, empty_string);
 

    //AUTOMATIC START VALUE
    if (getValue(env_FSG_Phonebook_delete_ErrHandler)==0x01)
    {
    getValue(this, DEL_POS_16);
    PosVal_16 = DEL_POS_16[0] << 8;
    PosVal_16 = PosVal_16|DEL_POS_16[1];

    putValue(env_FSG_PB_delete_start, PosVal_16);
    }

}

//IssueList #76 - MR49870 : Phonebook
//Automatic START AND SUCCESSOR VALUES
on envVar env_FSG_Phonebook_insert_POS_16
{
byte INS_POS_16[PHONEBOOK_ENTRIES];
int  inputCtr,i,j;
word PosVal_16_first,PosVal_16_last;
byte validInputFlg_start, validInputFlg_succ;

inputCtr=0;
PosVal_16_first=0;
PosVal_16_last=0;
validInputFlg_start = 0;
validInputFlg_succ=0;


putvalue (env_FSG_PB_Insert_Message, empty_string);

    //if (getValue(env_FSG_PB_insert_ErrHandler)==0x01 && getValue(env_FSG_PB_insert_UPD_button)==0x00)
    if (getValue(env_FSG_Phonebook_insert_Err)==0x01)
    {
    getValue(this, INS_POS_16);

     inputCtr=  getValueSize(env_FSG_Phonebook_insert_POS_16);
     
         if (inputCtr > 1)
         {
            //look for the valid reference for Start and successor
             for (j=0; j<inputCtr;j++)
             {
             //valid_INS_POS_8 = INS_POS_8[j];

             PosVal_16_first = INS_POS_16[j] << 8;
             PosVal_16_first = PosVal_16_first | INS_POS_16[j+1];

     
                for (i=0; i<gPB_CSVtotalElem;i++)
                 {
                 //check if input is valid and deleted
                     if (PosVal_16_first == gPhonebook_Pos_insDel[i][0] && gPhonebook_Pos_insDel[i][1]==0x01)
                     {
                     validInputFlg_start = 1;
                     break;
                     }
                 } 
                 if (validInputFlg_start == 0x01) 
                 break;   
               }

                if (validInputFlg_start == 0x01)
                {
                    //start
                     if (PosVal_16_first==gPhonebook_Pos_insDel[0][0])
                         putValue(env_FSG_PB_insert_start,0);
             
                     else
                     {   
                        ///look for the next existing element upwards
                         for (i=2; i<gPB_CSVtotalElem;i++)
                         {
                             if (PosVal_16_first==gPhonebook_Pos_insDel[i][0])
                             {   
                                for (j=i-1;j>0;j--)
                                 {
                                 if (gPhonebook_Pos_insDel[j][1]!=0x01)
                                    {
                                     putValue(env_FSG_PB_insert_start,gPhonebook_Pos_insDel[j][0]);
                                     break;
                                     }//if
                                 }//for
                              }
                         }//for
                     }//else
                }

                   //successor
                for (j=inputCtr; j>0;j--)
                {

                     PosVal_16_last = INS_POS_16[j-1] << 8;
                     PosVal_16_last = PosVal_16_last | INS_POS_16[j];
     
                     for (i=0; i<gPB_CSVtotalElem;i++)
                     {
                     //check if input is valid and deleted
                         if (PosVal_16_last == gPhonebook_Pos_insDel[i][0] && gPhonebook_Pos_insDel[i][1]==0x01)
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     } 
                     if (validInputFlg_succ == 0x01) 
                     break;     
                }

                if (validInputFlg_succ == 0x01)
                {

                   putValue(env_FSG_PB_insert_successor,0);
                    for (i=0; i<gPB_CSVtotalElem;i++)
                    {
                
                         if (PosVal_16_last==gPhonebook_Pos_insDel[i][0])
                         {
                             if (i==gPB_CSVtotalElem-1)
                             putValue(env_FSG_PB_insert_successor,0);
                             else
                             {
                                 //look for the next existing element downwards
                                 for (j=i+1;j<gPB_CSVtotalElem;j++)
                                 {
                                     if (gPhonebook_Pos_insDel[j][1]!=0x01)
                                     {
                                     putValue(env_FSG_PB_insert_successor,gPhonebook_Pos_insDel[j][0]);
                                     break;
                                     }
                                 }
                             }

                        }//if
                 }//for
               } //validInputFlg_succ
           }//inputCtr
    }

}

//IssueList #76 - MR49870 : Phonebook
void Phonebook_insert_ErrHandler_16 (byte pos[],word elementsCtr)
{
    byte i, result,InsFlg;
    word PosVal,PBlistCtr, PosCtr;

    result = 0x01;
    InsFlg=0;
    PosVal = 0;

    for (PosCtr =0; PosCtr<elementsCtr; PosCtr = PosCtr+2)
    {
         result =0x00;
         InsFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+1];
        
      for (PBlistCtr = 0;PBlistCtr<gPB_CSVtotalElem; PBlistCtr++)
      {    
           if (PosVal==gPhonebook_Pos_insDel[PBlistCtr][0])   //check if POS is valid
           {
            //UPDATE      
            if  (getValue(env_FSG_PB_insert_UPD_button) == 0x01) 
             {  
                if (gPhonebook_Pos_insDel[PBlistCtr][1]==0x00)  //check if POS is not deleted            {
                    {
                    result = 0x01; 
                    gPhonebook_Send[gPB_InsValidCtr][0] = pos[PosCtr];  
                    gPB_InsValidCtr++;
                    gPhonebook_Send[gPB_InsValidCtr][0] = pos[PosCtr+1];  
                    gPB_InsValidCtr++;
                    }
                        else
                      {
                      putValue(env_FSG_PB_Insert_Message, "POS is already deleted!");
                      gPB_InvalidIns[gPB_InsInvalidCtr] = pos[PosCtr];
                      gPB_InsInvalidCtr++;
                      gPB_InvalidIns[gPB_InsInvalidCtr] = pos[PosCtr+1];
                      gPB_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                  }

            }  //update

             else   //INSERT
             {
                 if (gPhonebook_Pos_insDel[PBlistCtr][1]==0x01)  //check if POS does not exist
                   {
                   gPhonebook_Pos_insDel[PBlistCtr][1] = 0x00;
                   gPhonebook_Send[gPB_InsValidCtr][0] = pos[PosCtr];
                   gPB_InsValidCtr++;
                   gPhonebook_Send[gPB_InsValidCtr][0] = pos[PosCtr+1];
                   gPB_InsValidCtr++;
                   result = 0x01;
                   
                   }
                  else
                  {
                  putValue(env_FSG_PB_Insert_Message, "POS still exists!");
                  gPB_InvalidIns[gPB_InsInvalidCtr] = pos[PosCtr];
                  gPB_InsInvalidCtr++;
                  gPB_InvalidIns[gPB_InsInvalidCtr] = pos[PosCtr+1];
                  gPB_InsInvalidCtr++;
                  InsFlg = 0x01;
                  break;
                  }
               }//if
            } //else
       }//for
        if (result == 0x00 && InsFlg == 0x00)
           {
            gPB_InvalidIns[gPB_InsInvalidCtr]=pos[PosCtr];
            gPB_InsInvalidCtr++;
	        gPB_InvalidIns[gPB_InsInvalidCtr] = pos[PosCtr+1];
            gPB_InsInvalidCtr++;
             putValue(env_FSG_PB_Insert_Message, "INVALID POS!");
            }
     }//for PBlistCtr

     if (gPB_InsInvalidCtr!=0)
            putValue(env_FSG_PB_Insert_Invalid,gPB_InvalidIns);
}

//IssueList #76 - MR49870 : Phonebook
Phonebook_delete_ErrHandler_16 (byte pos[],word elementsCtr)
{
    byte i, result,delFlg;
    word PBlistCtr, PosCtr,PosVal;
    
    result = 0x01;
    delFlg=0;
    gPB_DelInvalidCtr = 0;
    gPB_DelValidCtr =0;
    putValue(env_FSG_PB_delete_Message, empty_string);
    PosVal = 0;

    for (PosCtr =0; PosCtr<elementsCtr; PosCtr = PosCtr+2)
    {
         result =0x00;
         delFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+1];

      for (PBlistCtr = 0;PBlistCtr<gPB_CSVtotalElem; PBlistCtr++)
      {    
           if (PosVal==gPhonebook_Pos_insDel[PBlistCtr][0])   //check if POS is valid
           {
             if (gPhonebook_Pos_insDel[PBlistCtr][1]!=0x01)  //check if POS still exists
               {
               gPhonebook_Pos_insDel[PBlistCtr][1] = 0x01;    //tagging deleted Pos
               gPhonebook_Send[gPB_DelValidCtr][0] = pos[PosCtr];
               gPB_DelValidCtr++;
               gPhonebook_Send[gPB_DelValidCtr][0] = pos[PosCtr+1];
               gPB_DelValidCtr++;
               gPB_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue(env_FSG_PB_delete_Message, "POS already deleted!");
              gPB_InvalidDel[gPB_DelInvalidCtr] = pos[PosCtr];
              gPB_DelInvalidCtr++;
              gPB_InvalidDel[gPB_DelInvalidCtr] = pos[PosCtr+1];
              gPB_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }
              
           }//if
           
       }//for
        if (result == 0x00 && delFlg == 0x00)
        {
            gPB_InvalidDel[gPB_DelInvalidCtr] = pos[PosCtr];
            gPB_DelInvalidCtr++;
            gPB_InvalidDel[gPB_DelInvalidCtr] = pos[PosCtr+1];
            gPB_DelInvalidCtr++;
            putValue(env_FSG_PB_delete_Message, "INVALID POS!");
         }
     }
}

on envVar env_FSG_FL_delete
{
    word startelement, elements, PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[TEL_FAVORITELIST_ENTRIES]; 
    dword requestarray [BAP_buffer_size], Offset, i;

    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    i                       =0;
    Offset                  =0;

    for(i =0; i<TEL_FAVORITELIST_ENTRIES; i++)
        POS[i] =0;
    
    for(i =0; i<BAP_buffer_size; i++)
        requestarray[i] =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
    gFL_DelInvalidCtr =0;
    gFL_DelValidCtr =0;

    for(i =0; i<TEL_FAVORITELIST_ENTRIES; i++)
        gFL_InvalidDel[i] =0;

    for(i =0; i<TEL_FAVORITELIST_ENTRIES; i++)
        gFavoriteList_Send[i][0] =0;   //POS value


 	putvalue (env_FSG_FL_Insert_Message, empty_string);

    gFL_TotalElem = gFavoriteList_TotalNumListElements;  
        
        //get data from Panel
        recordaddress   =0x0F;
        shift           =0x1;
        direction       =0x1;
        transmitpos     =0x1;
        indexsize       =getvalue(env_FSG_FL_delete_size);;

        //message
        requestarray[0] =LSGID_Telephone;				//LSG-ID
    	requestarray[1] =FctID_FavoriteList;		    //Fct.-ID
	    requestarray[2] =Changed_REQ;               //request type  
	    Offset =3;

    switch ( indexsize ) // POS size
    {
        case 0: //8Bit
        //MR 62005 if-else condition
        if (getValue(env_FSG_FL_delete_Auto)==0x00)
        {
            getvalue(env_FSG_FL_delete_POS_8, POS);
        	startelement = getvalue(env_FSG_FL_delete_start);
            elements     =getValueSize(env_FSG_FL_delete_POS_8);
         }
         else
         {
            startelement = getvalue(env_FSG_FL_delete_start);
            elements     = 1;
         }       
            //ErrHandler = ON
            if (getValue(env_FSG_FL_delete_ErrHandler)==0x01)
            {
                if (elements==0x00)   // if no data
                    putValue(env_FSG_FL_delete_Message, "NO DATA TO SEND");

                else     // with data
                {
                    FavoriteList_delete_ErrHandler_8 (POS,elements);
                    //if all elements are invalid
                    if (elements ==gFL_DelInvalidCtr)
                        putValue(env_FSG_FL_delete_Message, "POS INVALID");
                    else
                        elements = gFL_DelValidCtr;
                }
            }
            else  // no errorhandling
            {
                if (elements==0x00)   // if no data
                    transmitpos     =0x0;
            }
		
        
        //mode
        mode            =shift +(direction*0x02) +(transmitpos*0x04) +(indexsize*0x08);
		
        /***ArrayHeader***/
        requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
		Offset++;

        requestarray[Offset] =startelement;
        Offset++;  

        requestarray[Offset] =elements;
        Offset++;
                
        /***ArrayData***/
        //MR 62005 if-else condition
        if (getValue(env_FSG_FL_delete_Auto)==0x00)
        {
            if (getValue(env_FSG_FL_delete_ErrHandler)==0x00)
            {
                for ( i = 0; i < elements; i++ )
                {
                requestarray[Offset] =POS[i];
                Offset++;
    	        }
    	    }//if
    		else
    		{
    			for (i=0; i<gFL_DelValidCtr; i++)
               		{
                		requestarray[Offset] =gFavoriteList_Send[i][0];
                		Offset++;
    			    }
    		}
        }
        else
        {
                requestarray[Offset] = getValue(env_FSG_FL_delete_POS_8_A);
                Offset++;
        }

 		break;
            
      case 1:  //16Bit
            //MR 62005 if-else condition
            if (getValue(env_FSG_FL_delete_Auto)==0x00)
            {
            getvalue(env_FSG_FL_delete_POS_16, POS);
            startelement  = getvalue(env_FSG_FL_delete_start);
            elements      = getValueSize(env_FSG_FL_delete_POS_16)/2;
            }
            else
            {
            startelement  = getvalue(env_FSG_FL_delete_start);
            elements      = 1;
            }

            if (getValue(env_FSG_FL_delete_ErrHandler)==0x01)
              { 
                        if (elements==0)   // if insufficient data
                        {
                        putValue(env_FSG_FL_delete_Message, "NO DATA TO SEND");
                        break;
                        }
                    
                        else     // with data
                        {
                        FavoriteList_delete_ErrHandler_16 (POS,elements*2);
                            //if all elements are invalid
                            if (elements ==gFL_DelInvalidCtr/2)
                            {
                            putValue(env_FSG_FL_delete_Message, "ALL POS INVALID");
                            break;
                            }
                    
                            else
                           elements = gFL_DelValidCtr/2;
                        }
                }
            else  // no errorhandling
                {
                if (elements==0x00)   // if no data
                transmitpos     =0x0;
                }
        
                //mode
                mode  = shift + (direction*0x02) + (transmitpos*0x04) + (indexsize*0x08);

                /***ArrayHeader***/
                requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
                Offset++;

                requestarray[Offset] =startelement &0xff; 
                Offset++; 
                requestarray[Offset] =(startelement &0xff00) /0x100;
                Offset++;
                
                
                requestarray[Offset] =elements &0xff;
                Offset++;
                requestarray[Offset] =(elements &0xff00) /0x100;
                Offset++;

                /***ArrayData***/
                //MR 62005 if-else condition
                if (getValue(env_FSG_FL_delete_Auto)==0x00)
                {
                    if (getValue(env_FSG_FL_delete_ErrHandler)==0x00)
                    {
                        for ( i = 0; i < elements; i++ )    //2 elements are inserted to the array below
                        {
                           requestarray[Offset] = POS[(2*i)+1];
                           Offset++;

                           requestarray[Offset] = POS[(2*i)];
                           Offset++;
                        }
                    }
                     else    // with error handling
                     {
                        for (i=0; i<elements; i++)
                        {
                        PosVal = 0x00;
                        requestarray[Offset] =gFavoriteList_Send[(2*i)+1][0];
                        PosVal = requestarray[Offset];
                        Offset++;
						   
                        requestarray[Offset] = gFavoriteList_Send[(2*i)+0][0];
                        PosVal = PosVal|requestarray[Offset]<<8;
                        Offset++;
                        } //for (i=0; i<gFL_DelValidCtr; i++)

                    } //else ERRORHANDLING
                }//env_FSG_FL_delete_Auto
                else
                {
                requestarray[Offset]= (byte)(getValue(env_FSG_FL_delete_POS_16_A) & 0xFF);
                Offset++;
                requestarray[Offset]= (byte)(getValue(env_FSG_FL_delete_POS_16_A) >> 8);
                Offset++;

                }
        break;

      default:
        break;
    }
        
        //DATA SENDING
        if (getValue(env_FSG_FL_delete_ErrHandler)==0x00)
       set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 

        else
        {
            if (gFL_DelInvalidCtr!=0)
                putValue(env_FSG_FL_delete_Invalid,gFL_InvalidDel);

            if (gFL_DelValidCtr != 0x00)
            {
                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);               

                if (indexsize == 0x00)
                gFavoriteList_TotalNumListElements = gFL_TotalElem - gFL_DelValidCtr;
                else
                gFavoriteList_TotalNumListElements = gFL_TotalElem - (gFL_DelValidCtr/2);
                putValue(env_FSG_FL_TotalNumLE, gFavoriteList_TotalNumListElements);
            }//if
        } //else

   }
}

on envVar env_FSG_FL_insert
{
    word startelement, elements,successor, ctr, PosCtr,FLlistCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[TEL_FAVORITELIST_ENTRIES], posInBetweenCheck;
    dword requestarray [BAP_buffer_size], Offset, i;
 
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    i                       =0;
    Offset                  =0;
    elemTemp		        =0;
    PosVal                  =0;


    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {

        for(i =0; i<TEL_FAVORITELIST_ENTRIES; i++)
            POS[i] =0;

        for(i =0; i<BAP_buffer_size; i++)
            requestarray[i] =0;

        for(i =0; i<TEL_FAVORITELIST_ENTRIES; i++)
            gFL_InvalidIns[i] =0;

        for(i =0; i<TEL_FAVORITELIST_ENTRIES; i++)
            gFavoriteList_Send[i][0] =0;
    
        putValue(env_FSG_FL_Insert_Invalid,gFL_InvalidIns);

        gFL_InsInvalidCtr=0;
        gFL_InsValidCtr =0;
        putValue(env_FSG_FL_Insert_Message, empty_string);

        //get data from Panel
        //Patch GB 11.07.2014 -commented
        //recordaddress   =0x0F;

        putvalue (env_FSG_FL_Insert_Message, empty_string);
        //MR 63332 #3   02.07.2014
        //gFL_TotalElem = getValue(env_FSG_FL_TotalNumLE);
        gFL_TotalElem = gFavoriteList_TotalNumListElements;

        if (getValue(env_FSG_FL_insert_UPD_button)==0x00)
        {
            shift           =0x01; //insert
            //Patch GB 11.07.2014
            recordaddress   =0x0F;
        }
        else
        {
            shift           =0x0; //update
            //Patch GB 11.07.2014
            recordaddress   =getValue(env_FSG_FL_AH_RA);
         }

        direction       =0x0;
        transmitpos     =0x01;

        indexsize       =getvalue(env_FSG_FL_insert_size);
        //mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        //message
        requestarray[0] =LSGID_Telephone;				//LSG-ID
        requestarray[1] =FctID_FavoriteList;		//Fct.-ID
        requestarray[2] =Changed_REQ;                  //request type  
        Offset =3;
        
        startelement    =getValue(env_FSG_FL_insert_start);
        
        successor = getValue(env_FSG_FL_insert_successor);
      

        switch (indexsize) // POS size
        {
            case 0: //8Bit
                getvalue(env_FSG_FL_insert_POS_8, POS);
                
                //MR 62005 if-else condition
                if (getValue(env_FSG_FL_insert_Auto)==0x00)
                ctr = getValueSize(env_FSG_FL_insert_POS_8);
                else
                ctr =1;

                if (getValue(env_FSG_FL_insert_ErrHandler)==0x01)
                {

                    if (ctr == 0)   // if no data
                    {
                        putValue(env_FSG_FL_Insert_Message, "NO DATA TO SEND");
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid for Insert
                        if (getvalue(env_FSG_FL_insert_start) == 0x00 && getvalue(env_FSG_FL_insert_successor) == 0x00 && getvalue(env_FSG_FL_insert_UPD_button) == 0x00)
                        {
                            //check if not all elements are deleted
                            if (gFL_totalDELctr < gFL_CSVtotalElem)
                            {
                            putValue(env_FSG_FL_Insert_Message, "INVALID START & SUCCESSOR");
                            break;
                            }
                        }
                        
                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                        posInBetweenCheck       =0;
                        if (ctr >1)
                        {
                            posInBetweenCheck =  pbPosSequence_check (indexsize,POS,ctr);
                            if (posInBetweenCheck == 0x01)
                            {
                                putValue(env_FSG_FL_Insert_Message, "INCORRECT POS SEQUENCE!");
                                break;
                            }
                        }
                     
                       //ERROR CHECKING
                        FavoriteList_insert_ErrHandler_8 (POS,ctr);
                        
                        //if update has invalid POS - do not send
                        if (getvalue(env_FSG_FL_insert_UPD_button) == 0x01)  //update
                        {
                            if (gFL_InsInvalidCtr>0)
                            {
                                putValue(env_FSG_FL_Insert_Message, "INVALID POS EXISTS");
                                break;
                            }
                        }
 
                     
                        //if all elements are INVALID for INSERT
                        if (ctr == gFL_InsInvalidCtr)
                        {
                            putValue(env_FSG_FL_Insert_Message, "POS INVALID / STILL EXIST");
                            break;
                        }
                        else
                        {
                            elements = gFL_InsValidCtr+1;   //+ successor
                            ctr = gFL_InsValidCtr;
                        }

                    }//else with data
                }
                else   // no error handling
                {
                    elements = ctr+1;
                    if (ctr==0)    // if no data
                    {
                        transmitpos     =0x0;

                        if (successor == 0x00)  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                            elements = successor - startelement;
                    }    
                 }

                //mode
                mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***ArrayHeader***/
                requestarray[Offset] = ((mode *0x10) &0xF0) +(recordaddress &0x0F);
                Offset++;

                //start
                requestarray[Offset] = startelement;
                Offset++;  
                
                //elements
                requestarray[Offset] = elements;
                Offset++;

                /***ArrayData***/
                //MR 62005 if-else condition
                if (getValue(env_FSG_FL_insert_Auto)==0x00)
                {
                    //ArrayData with error handling
                    if (getValue(env_FSG_FL_insert_ErrHandler)==0x01)
                    {
                        //ARRAY DATA
                            for (i=0; i<ctr; i++)
                                {
                                    //store in array the inserted item
                                    requestarray[Offset] = gFavoriteList_Send[i][0];
                                    Offset++;
                                }
                  
                    } //end if with ERROR handling

                    //ArrayData WITHOUT error handling
                    else
                    {
                         for (i=0; i<ctr; i++)
                         {
                            requestarray[Offset] =POS[i];
                            Offset++;
                         }
                    }
                } //env_FSG_FL_insert_Auto
                else
                {
                   requestarray[Offset] =getValue(env_FSG_FL_insert_POS_8_A);
                   Offset++;
                }

                //successor
                if (ctr > 0)
                {
                    requestarray[Offset] = successor;
                    Offset++;    
                }

            break;
            
            case 1:  //16Bit
                //MR 62005 if-else condition
                if (getValue(env_FSG_FL_insert_Auto)==0x00)
                {
                getvalue(env_FSG_FL_insert_POS_16, POS);
                elements = getValueSize(env_FSG_FL_insert_POS_16);
                elemTemp = (getValueSize(env_FSG_FL_insert_POS_16)/2);
                }
                else
                {
                elements = 2;
                elemTemp = 1;
                }

                if (getValue(env_FSG_FL_insert_ErrHandler)==0x01)
                {
                    if (elemTemp==0)   // if no data
                    {
                        putValue(env_FSG_FL_Insert_Message, "NO DATA TO SEND");
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid
                        if ((getvalue(env_FSG_FL_insert_start) == 0x00) && (getvalue(env_FSG_FL_insert_successor) == 0x00)&& (getvalue(env_FSG_FL_insert_UPD_button) == 0x00))
                        {
                            //check if not all elements are deleted
                            if (gFL_totalDELctr < gFL_CSVtotalElem)
                            {
                            putValue(env_FSG_FL_Insert_Message, "INVALID START & SUCCESSOR");
                            break;
                            }
                        }
                          
                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                            //if (ctr >1)
                            if (elemTemp >1)
                            {
                                posInBetweenCheck =  pbPosSequence_check (indexsize,POS,elemTemp);
                                if (posInBetweenCheck == 0x01)
                                {
                                    putValue(env_FSG_FL_Insert_Message, "INCORRECT POS SEQUENCE!");
                                    break;
                                }
                            }

                       CombinedNumbers_insert_ErrHandler_16 (POS,elements);
                        //if all elements are INVALID

                        //if update has invalid POS - do not send
                        if (getvalue(env_FSG_FL_insert_UPD_button) == 0x01)  //update
                        {
                            if (gFL_InsInvalidCtr>0)
                            {
                                putValue(env_FSG_FL_Insert_Message, "INVALID POS EXISTS");
                                break;
                            }
                        }
                    
                        if (elemTemp == gFL_InsInvalidCtr)
                        {
                            putValue(env_FSG_FL_Insert_Message, "POS INVALID / STILL EXIST");
                            break;
                        }
                        else
                        {
                            elements = (gFL_InsValidCtr/2)+1;     //including successor
                            elemTemp = gFL_InsValidCtr/2;
                        }

                    } //else with data
                } //with errorHandling
                else   // no error handling
                {
                    elements = elemTemp + 1;  //including successor
                    if (elemTemp==0)    // if no data
                    {
                        transmitpos = 0x0;
                         if (successor == 0x00)  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                        elements = successor - startelement;
                    }
                }

                //mode
                mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***ArrayHeader***/
                requestarray[Offset] = ((mode*0x10)&0xF0) + (recordaddress&0x0F);
                Offset++;

                requestarray[Offset] = startelement&0xff; 
                Offset++;
                requestarray[Offset] = (startelement&0xff00) / 0x100;
                Offset++;
                
                requestarray[Offset] = elements&0xff;
                Offset++;
                requestarray[Offset] = (elements&0xff00) / 0x100;
                Offset++;

                /***ArrayData***/
                //MR 62005 if-else condition
                if (getValue(env_FSG_FL_insert_Auto)==0x00)
                {
                    //ArrayData with error handling
                    if (getValue(env_FSG_FL_insert_ErrHandler)==0x01)
                    {
                        for ( i = 0; i < elemTemp; i++ )
                            {
                                PosVal = 0x00;

                                //store in array the inserted item
                                requestarray[Offset] = gFavoriteList_Send[(2*i)+1][0];
                                PosVal = requestarray[Offset];
                                Offset++;
                                requestarray[Offset] = gFavoriteList_Send[(2*i)+0][0];
                                PosVal = PosVal|requestarray[Offset]<<8;
                                Offset++;
                             }
					
					
                    } // end if with Errorhandling
                    //ArrayData WITHOUT error handling
                    else
                    {
                        for ( i = 0; i < elemTemp; i++ )
                        {
                            requestarray[Offset] = POS[(2*i)+1];
                            Offset++;
                            requestarray[Offset] = POS[(2*i)+0];
                            Offset++;
                        }
                    }
                } //env_FSG_FL_insert_Auto
                else
                {
                requestarray[Offset]= (byte)(getValue(env_FSG_FL_insert_POS_16_A) & 0xFF);
                Offset++;
                requestarray[Offset]= (byte)(getValue(env_FSG_FL_insert_POS_16_A) >> 8);
                Offset++;
                }


                //successor
                if (elemTemp > 0)
                {
                    requestarray[Offset] = successor&0xff; 
                    Offset++;
                    requestarray[Offset] = (successor&0xff00) / 0x100;
                    Offset++;
                }
                break; 

            default:
                break; //default

        }//switch

        if (indexsize==0x01)
        gFL_InsValidCtr = gFL_InsValidCtr/2;

        //updating the totalDeletedCtr;
   		gFL_totalDELctr = gFL_totalDELctr - gFL_InsValidCtr;
        
        if (gFL_totalDELctr > gFL_CSVtotalElem)
        gFL_totalDELctr=0;

                
        //just send the data when errorhandler is OFF
        if (getValue(env_FSG_FL_insert_ErrHandler)==0x00)
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
        
        else if (getValue(env_FSG_FL_insert_ErrHandler)==0x01)  //with ERROR HANDLER
        {
            if (getValue(env_FSG_FL_insert_UPD_button)==0x00)  //insert
            {
                // if there's a Valid POS and Sequence is correct
                if (gFL_InsValidCtr != 0x00 && posInBetweenCheck == 0x00)
                {
                    set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
                    
                    if (gFL_TotalElem +gFL_InsValidCtr <=gFL_CSVtotalElem)
                    {
                        //MR 63332 #3   02.07.2014
                        //putValue(env_FSG_FL_TotalNumLE, gFL_TotalElem +gFL_InsValidCtr);
                        //gFavoriteList_TotalNumListElements = getValue(env_FSG_FL_TotalNumLE);
                        gFavoriteList_TotalNumListElements = gFL_TotalElem + gFL_InsValidCtr;
                        putValue(env_FSG_FL_TotalNumLE, gFavoriteList_TotalNumListElements);
                    } //if
               
                
                }// if gFL_InsValidCtr
            }// if insert
            else
            {
                //send only UPDATE if all POS are valid and DATA!=0
                if (gFL_InsInvalidCtr == 0x00 && gFL_InsValidCtr!=0)
                    set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
            }// else UPD button
        } //else if 
    }
    //else
    //putValue(env_FSG_FL_insert_UPD_button,0);
}

//IssueList #76 - MR49870 : FL
on envVar env_FSG_FL_delete_POS_8
{
byte DEL_POS_8[TEL_FAVORITELIST_ENTRIES];

putValue(env_FSG_FL_delete_Message, empty_string);
 
    //AUTOMATIC START VALUE
    if (getValue(env_FSG_FL_delete_ErrHandler)==0x01)
    {
    getValue(this, DEL_POS_8);
    putValue(env_FSG_FL_delete_start, DEL_POS_8[0]);
    }

}

//IssueList #76 - MR49870 : FL
on envVar env_FSG_FL_delete_POS_16
{
byte DEL_POS_16[TEL_FAVORITELIST_ENTRIES];
word PosVal_16;

putValue(env_FSG_FL_delete_Message, empty_string);
 

    //AUTOMATIC START VALUE
    if (getValue(env_FSG_FL_delete_ErrHandler)==0x01)
    {
    getValue(this, DEL_POS_16);
    PosVal_16 = DEL_POS_16[0] << 8;
    PosVal_16 = PosVal_16|DEL_POS_16[1];

    putValue(env_FSG_FL_delete_start, PosVal_16);
    }

}

//IssueList #76 - MR49870 : FL
on envVar env_FSG_FL_delete_ErrHandler
{
if (getValue(this)==0x00)
putValue(env_FSG_FL_TotalNumLE,gFL_CSVtotalElem);
}

//IssueList #76 - MR49870 : FL
on envVar env_FSG_FL_insert_ErrHandler
{
if (getValue(this)==0x00)
putValue(env_FSG_FL_TotalNumLE,gFL_CSVtotalElem);
}

//IssueList #76 - MR49870 : FL
byte flPosSequence_check (byte Index, byte inputArray[],word inputCtr)
{
	byte posInBetween;
	word ctr,ctr1,ctr2,PosVal1_,PosVal2_;

	posInBetween = 0;
	
	for (ctr = 0; ctr < inputCtr; ctr++)
	{
		// adjust for 8bit and 16bit handling
		if (Index==0x00)
		{
			PosVal1_ = inputArray[ctr];
			PosVal2_ = inputArray[ctr+1];
		}
		else
		{
			PosVal1_ = 0x0000;
			PosVal1_ = inputArray[(2*ctr)+1];
			PosVal1_ = PosVal1_|((inputArray[(2*ctr)+0])<<8);
			PosVal2_ = 0x0000;
			PosVal2_ = inputArray[(2*ctr)+2+1];
			PosVal2_ = PosVal2_|((inputArray[(2*ctr)+2+0])<<8);			
		}
		
		// search send item in insdel array
		for( ctr1 = 0; ctr1 < gFL_CSVtotalElem; ctr1++ )
		{
			if( PosVal1_ == gFavoriteList_Pos_insDel[ctr1][0]) // 1st send item is found in array			
			{
				break;
			}
		}
		
		// search insdel array for next send item
		for( ctr2 = ctr1+1; ctr2 < gFL_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
		{

			if (PosVal2_ == gFavoriteList_Pos_insDel[ctr2][0]) // 2nd send item immediately next to 1st send item			
			{
				break;
			}
			else
			{
				if (gFavoriteList_Pos_insDel[ctr2][1] == 0 && PosVal2_ !=0)	// in between item is not deleted
				{
					posInBetween = 0x01;
					break;
				}
			}
		}
		
		if( posInBetween == 0x01)
		{
			break;
		}
	}
	
	return posInBetween;

    }

//IssueList #76 - MR49870 : FavoriteList
//Automatic START AND SUCCESSOR VALUES
on envVar env_FSG_FL_insert_POS_8
{
byte INS_POS_8[TEL_FAVORITELIST_ENTRIES];
int inputCtr,i,j;
byte valid_INS_POS_8;
byte validInputFlg_start, validInputFlg_succ;

putvalue (env_FSG_FL_Insert_Message, empty_string);


    //if (getValue(env_FSG_FL_insert_ErrHandler)==0x01 && getValue(env_FSG_FL_insert_UPD_button)==0x00)
    if (getValue(env_FSG_FL_insert_ErrHandler)==0x01)
    {
    getValue(this, INS_POS_8);
    validInputFlg_start =0;
    validInputFlg_succ = 0;

     inputCtr=  getValueSize(env_FSG_FL_insert_POS_8);

     if (inputCtr>0)
     {       
        //look for the valid reference for Start and successor
         for (j=0; j<inputCtr;j++)
         {
             valid_INS_POS_8 = INS_POS_8[j];
     
             for (i=0; i<gFL_CSVtotalElem;i++)
             {
             //check if input is valid and deleted
                 if (valid_INS_POS_8 == gFavoriteList_Pos_insDel[i][0] && gFavoriteList_Pos_insDel[i][1]==0x01)
                 {
                 validInputFlg_start = 1;
                 break;
                 }
             } 
             if (validInputFlg_start == 0x01) 
             break;   
          }

            if (validInputFlg_start == 0x01)
            {
            //start
             if (valid_INS_POS_8==gFavoriteList_Pos_insDel[0][0])
                 putValue(env_FSG_FL_insert_start,0);
             
             else
             {   
                ///look for the next existing element upwards
                 for (i=0; i<gFL_CSVtotalElem;i++)
                 {
                     if (valid_INS_POS_8==gFavoriteList_Pos_insDel[i][0])
                     {   
                        for (j=i-1;j>=0;j--)
                         {
                         if (gFavoriteList_Pos_insDel[j][1]!=0x01)
                            {
                             putValue(env_FSG_FL_insert_start,gFavoriteList_Pos_insDel[j][0]);
                             break;
                             }//if
                         }//for
                      }
                 }//for
             }//else
            } //validInputFlg

                //successor
                //look for the valid reference for Start and successor

                for (j=inputCtr-1; j>=0;j--)
                {
                     valid_INS_POS_8 = INS_POS_8[j];
     
                     for (i=0; i<gFL_CSVtotalElem;i++)
                     {
                     //check if input is valid and deleted
                         if (valid_INS_POS_8 == gFavoriteList_Pos_insDel[i][0] && gFavoriteList_Pos_insDel[i][1]==0x01)
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     } 
                     if (validInputFlg_succ == 0x01) 
                     break;     
                }
                if (validInputFlg_succ == 0x01)
                {
                    putValue(env_FSG_FL_insert_successor,0);
                
                    for (i=0; i<gFL_CSVtotalElem;i++)
                    {
                        if (valid_INS_POS_8==gFavoriteList_Pos_insDel[i][0])
                         {
                         if (i==gFL_CSVtotalElem-1)
                         putValue(env_FSG_FL_insert_successor,0);
                         else
                            {
                                 //look for the next existing element downwards
                                 for (j=i+1;j<gFL_CSVtotalElem;j++)
                                 {
                                     if (gFavoriteList_Pos_insDel[j][1]!=0x01)
                                     {
                                     putValue(env_FSG_FL_insert_successor,gFavoriteList_Pos_insDel[j][0]);
                                     break;
                                     }
                                 }
                             }//else

                        }//if
                 }//for
               }
          
        } //inputCtr
    }

}

//IssueList #76 - MR49870 : FavoriteList
//Automatic START AND SUCCESSOR VALUES
on envVar env_FSG_FL_insert_POS_16
{
byte INS_POS_16[TEL_FAVORITELIST_ENTRIES];
int  inputCtr,i,j;
word PosVal_16_first,PosVal_16_last;
byte validInputFlg_start, validInputFlg_succ;

inputCtr=0;
PosVal_16_first=0;
PosVal_16_last=0;
validInputFlg_start = 0;
validInputFlg_succ=0;


putvalue (env_FSG_FL_Insert_Message, empty_string);

    //if (getValue(env_FSG_FL_insert_ErrHandler)==0x01 && getValue(env_FSG_FL_insert_UPD_button)==0x00)
    if (getValue(env_FSG_FL_insert_ErrHandler)==0x01)
    {
    getValue(this, INS_POS_16);

     inputCtr=  getValueSize(env_FSG_FL_insert_POS_16);
     
         if (inputCtr > 1)
         {
            //look for the valid reference for Start and successor
             for (j=0; j<inputCtr;j++)
             {
             //valid_INS_POS_8 = INS_POS_8[j];

             PosVal_16_first = INS_POS_16[j] << 8;
             PosVal_16_first = PosVal_16_first | INS_POS_16[j+1];

     
                for (i=0; i<gFL_CSVtotalElem;i++)
                 {
                 //check if input is valid and deleted
                     if (PosVal_16_first == gFavoriteList_Pos_insDel[i][0] && gFavoriteList_Pos_insDel[i][1]==0x01)
                     {
                     validInputFlg_start = 1;
                     break;
                     }
                 } 
                 if (validInputFlg_start == 0x01) 
                 break;   
               }

                if (validInputFlg_start == 0x01)
                {
                    //start
                     if (PosVal_16_first==gFavoriteList_Pos_insDel[0][0])
                         putValue(env_FSG_FL_insert_start,0);
             
                     else
                     {   
                        ///look for the next existing element upwards
                         for (i=2; i<gFL_CSVtotalElem;i++)
                         {
                             if (PosVal_16_first==gFavoriteList_Pos_insDel[i][0])
                             {   
                                for (j=i-1;j>0;j--)
                                 {
                                 if (gFavoriteList_Pos_insDel[j][1]!=0x01)
                                    {
                                     putValue(env_FSG_FL_insert_start,gFavoriteList_Pos_insDel[j][0]);
                                     break;
                                     }//if
                                 }//for
                              }
                         }//for
                     }//else
                }

                   //successor
                for (j=inputCtr; j>0;j--)
                {

                     PosVal_16_last = INS_POS_16[j-1] << 8;
                     PosVal_16_last = PosVal_16_last | INS_POS_16[j];
     
                     for (i=0; i<gFL_CSVtotalElem;i++)
                     {
                     //check if input is valid and deleted
                         if (PosVal_16_last == gFavoriteList_Pos_insDel[i][0] && gFavoriteList_Pos_insDel[i][1]==0x01)
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     } 
                     if (validInputFlg_succ == 0x01) 
                     break;     
                }

                if (validInputFlg_succ == 0x01)
                {

                   putValue(env_FSG_FL_insert_successor,0);
                    for (i=0; i<gFL_CSVtotalElem;i++)
                    {
                
                         if (PosVal_16_last==gFavoriteList_Pos_insDel[i][0])
                         {
                             if (i==gFL_CSVtotalElem-1)
                             putValue(env_FSG_FL_insert_successor,0);
                             else
                             {
                                 //look for the next existing element downwards
                                 for (j=i+1;j<gFL_CSVtotalElem;j++)
                                 {
                                     if (gFavoriteList_Pos_insDel[j][1]!=0x01)
                                     {
                                     putValue(env_FSG_FL_insert_successor,gFavoriteList_Pos_insDel[j][0]);
                                     break;
                                     }
                                 }
                             }

                        }//if
                 }//for
               } //validInputFlg_succ
           }//inputCtr
    }

}

//IssueList #76 - MR49870 : CN
void FavoriteList_delete_ErrHandler_8 (byte pos[],word elementsCtr)
{
    byte i, result,delFlg;
    word FLlistCtr, PosCtr;
    
    result = 0x01;
    delFlg=0;
    gFL_DelInvalidCtr = 0;
    gFL_DelValidCtr =0;
    putValue(env_FSG_FL_delete_Message, empty_string);
    
    for (PosCtr =0; PosCtr<elementsCtr; PosCtr++)
    {

         result =0x00;
         delFlg = 0x00;

      for (FLlistCtr = 0;FLlistCtr<gFL_CSVtotalElem; FLlistCtr++)
      {    

           if (pos[PosCtr]==gFavoriteList_Pos_insDel[FLlistCtr][0])   //check if POS is valid
           {
             if (gFavoriteList_Pos_insDel[FLlistCtr][1]!=0x01)  //check if POS still exists
               {
               gFavoriteList_Pos_insDel[FLlistCtr][1] = 0x01;    //tagging deleted Pos
               gFavoriteList_Send[gFL_DelValidCtr][0] = pos[PosCtr];
               
               gFL_DelValidCtr++;
               gFL_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue(env_FSG_FL_delete_Message, "POS already deleted!");
              gFL_InvalidDel[gFL_DelInvalidCtr] = pos[PosCtr];
              gFL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }
              
           }//if
           
       }//for
        if (result == 0x00 && delFlg == 0x00)
        {
          gFL_InvalidDel[gFL_DelInvalidCtr]=pos[PosCtr];
          gFL_DelInvalidCtr++;
          putValue(env_FSG_FL_delete_Message, "INVALID POS!");
         }

     }
}

//IssueList #76 - MR49870 : FL
void FavoriteList_delete_ErrHandler_16 (byte pos[],word elementsCtr)
{
    byte i, result,delFlg;
    word FLlistCtr, PosCtr,PosVal;
    
    result = 0x01;
    delFlg=0;
    gFL_DelInvalidCtr = 0;
    gFL_DelValidCtr =0;
    putValue(env_FSG_FL_delete_Message, empty_string);
    PosVal = 0;

    for (PosCtr =0; PosCtr<elementsCtr; PosCtr = PosCtr+2)
    {
         result =0x00;
         delFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+1];

      for (FLlistCtr = 0;FLlistCtr<gFL_CSVtotalElem; FLlistCtr++)
      {    
           if (PosVal==gFavoriteList_Pos_insDel[FLlistCtr][0])   //check if POS is valid
           {
             if (gFavoriteList_Pos_insDel[FLlistCtr][1]!=0x01)  //check if POS still exists
               {
               gFavoriteList_Pos_insDel[FLlistCtr][1] = 0x01;    //tagging deleted Pos
               gFavoriteList_Send[gFL_DelValidCtr][0] = pos[PosCtr];
               gFL_DelValidCtr++;
               gFavoriteList_Send[gFL_DelValidCtr][0] = pos[PosCtr+1];
               gFL_DelValidCtr++;
               gFL_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue(env_FSG_FL_delete_Message, "POS already deleted!");
              gFL_InvalidDel[gFL_DelInvalidCtr] = pos[PosCtr];
              gFL_DelInvalidCtr++;
              gFL_InvalidDel[gFL_DelInvalidCtr] = pos[PosCtr+1];
              gFL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }
              
           }//if
           
       }//for
        if (result == 0x00 && delFlg == 0x00)
        {
            gFL_InvalidDel[gFL_DelInvalidCtr] = pos[PosCtr];
            gFL_DelInvalidCtr++;
            gFL_InvalidDel[gFL_DelInvalidCtr] = pos[PosCtr+1];
            gFL_DelInvalidCtr++;
            putValue(env_FSG_FL_delete_Message, "INVALID POS!");
         }
     }
}

//IssueList #76 - MR49870 : FL
void FavoriteList_insert_ErrHandler_8 (byte pos[],word elementsCtr)
{
    byte i, result,InsFlg;
    word FLlistCtr, PosCtr;
    
    result = 0x01;
    InsFlg=0;

  
    for (PosCtr =0; PosCtr<elementsCtr; PosCtr++)
    {
         result =0x00;
         InsFlg = 0x00;
        
      for (FLlistCtr = 0;FLlistCtr<gFL_CSVtotalElem; FLlistCtr++)
      {    
           if (pos[PosCtr]==gFavoriteList_Pos_insDel[FLlistCtr][0])   //check if POS is valid
           {
            //UPDATE      
                if  (getValue(env_FSG_FL_insert_UPD_button) == 0x01) 
                 {  
                        if (gFavoriteList_Pos_insDel[FLlistCtr][1]==0x00)  //check if POS is not deleted            {
                        {
                        result = 0x01; 
                        gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr];  
                        gFL_InsValidCtr++;
                        }
                    
                        else
                          {
                          putValue(env_FSG_FL_Insert_Message, "POS is already deleted!");
                          gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr];
                          gFL_InsInvalidCtr++;
                          InsFlg = 0x01;
                          break;
                          }

                }  //update

                 else   //INSERT
                 {
                     if (gFavoriteList_Pos_insDel[FLlistCtr][1]==0x01)  //check if POS does not exist
                       {
                       gFavoriteList_Pos_insDel[FLlistCtr][1] = 0x00;
                       gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr];

                       gFL_InsValidCtr++;
                       result = 0x01;
                       }
                      else
                      {
                      putValue(env_FSG_FL_Insert_Message, "POS still exists!");
                      gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr];
                      gFL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                      }
               }//if
            } //else
       }//for
        if (result == 0x00 && InsFlg == 0x00)
           {
           gFL_InvalidIns[gFL_InsInvalidCtr]=pos[PosCtr];
            gFL_InsInvalidCtr++;
             putValue(env_FSG_FL_Insert_Message, "INVALID POS!");
            }
     }//for FLlistCtr

     if (gFL_InsInvalidCtr!=0)
            putValue(env_FSG_FL_Insert_Invalid,gFL_InvalidIns);
}

//IssueList #76 - MR49870 : FL
void FavoriteList_insert_ErrHandler_16 (byte pos[],word elementsCtr)
{
    byte i, result,InsFlg;
    word PosVal,FLlistCtr, PosCtr;

    result = 0x01;
    InsFlg=0;
    PosVal = 0;

    for (PosCtr =0; PosCtr<elementsCtr; PosCtr = PosCtr+2)
    {
         result =0x00;
         InsFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+1];
        
      for (FLlistCtr = 0;FLlistCtr<gFL_CSVtotalElem; FLlistCtr++)
      {    
           if (PosVal==gFavoriteList_Pos_insDel[FLlistCtr][0])   //check if POS is valid
           {
            //UPDATE      
            if  (getValue(env_FSG_FL_insert_UPD_button) == 0x01) 
             {  
                if (gFavoriteList_Pos_insDel[FLlistCtr][1]==0x00)  //check if POS is not deleted            {
                    {
                    result = 0x01; 
                    gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr];  
                    gFL_InsValidCtr++;
                    gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr+1];  
                    gFL_InsValidCtr++;
                    }
                        else
                      {
                      putValue(env_FSG_FL_Insert_Message, "POS is already deleted!");
                      gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr];
                      gFL_InsInvalidCtr++;
                      gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr+1];
                      gFL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                  }

            }  //update

             else   //INSERT
             {
                 if (gFavoriteList_Pos_insDel[FLlistCtr][1]==0x01)  //check if POS does not exist
                   {
                   gFavoriteList_Pos_insDel[FLlistCtr][1] = 0x00;
                   gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr];
                   gFL_InsValidCtr++;
                   gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr+1];
                   gFL_InsValidCtr++;
                   result = 0x01;
                   
                   }
                  else
                  {
                  putValue(env_FSG_FL_Insert_Message, "POS still exists!");
                  gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr];
                  gFL_InsInvalidCtr++;
                  gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr+1];
                  gFL_InsInvalidCtr++;
                  InsFlg = 0x01;
                  break;
                  }
               }//if
            } //else
       }//for
        if (result == 0x00 && InsFlg == 0x00)
           {
            gFL_InvalidIns[gFL_InsInvalidCtr]=pos[PosCtr];
            gFL_InsInvalidCtr++;
	        gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr+1];
            gFL_InsInvalidCtr++;
             putValue(env_FSG_FL_Insert_Message, "INVALID POS!");
            }
     }//for FLlistCtr

     if (gFL_InsInvalidCtr!=0)
            putValue(env_FSG_FL_Insert_Invalid,gFL_InvalidIns);
}

//IssueList #76 - MR49870 : CN
on envVar env_FSG_CN_delete
{
    word startelement, elements, PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[TEL_COMBINEDNUMBERS_ENTRIES]; 
    dword requestarray [BAP_buffer_size], Offset, i;

    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    i                       =0;
    Offset                  =0;

    for(i =0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
        POS[i] =0;
    
    for(i =0; i<BAP_buffer_size; i++)
        requestarray[i] =0;

    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
	{
    gCN_DelInvalidCtr =0;
    gCN_DelValidCtr =0;

    for(i =0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
        gCN_InvalidDel[i] =0;

    for(i =0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
        gCombinedNum_Send[i][0] =0;   //POS value


 	putvalue (env_FSG_CN_Insert_Message, empty_string);
    //MR 63332 #3   02.07.2014
    //gCN_TotalElem = getValue(env_FSG_CN_TotalNumLE);  
    gCN_TotalElem = gCombinedNumbers_TotalNumListElements;  
        
        //get data from Panel
        recordaddress   =0x0F;
        shift           =0x1;
        direction       =0x1;
        transmitpos     =0x1;
        indexsize       =getvalue(env_FSG_CN_delete_size);;

        //message
        requestarray[0] =LSGID_Telephone;				//LSG-ID
    	requestarray[1] =FctID_CombinedNumbers;		    //Fct.-ID
	    requestarray[2] =Changed_REQ;               //request type  
	    Offset =3;

    switch ( indexsize ) // POS size
    {
        case 0: //8Bit
        //MR 62005 if-else condition
        if (getValue(env_FSG_CN_delete_Auto)==0x00)
        {
            getvalue(env_FSG_CN_delete_POS_8, POS);
        	startelement = getvalue(env_FSG_CN_delete_start);
            elements     =getValueSize(env_FSG_CN_delete_POS_8);
         }
         else
         {
            startelement = getvalue(env_FSG_CN_delete_start);
            elements     = 1;
         }       
            //ErrHandler = ON
            if (getValue(env_FSG_CN_delete_ErrHandler)==0x01)
            {
                if (elements==0x00)   // if no data
                    putValue(env_FSG_CN_delete_Message, "NO DATA TO SEND");

                else     // with data
                {
                    CombinedNumbers_delete_ErrHandler_8 (POS,elements);
                    //if all elements are invalid
                    if (elements ==gCN_DelInvalidCtr)
                        putValue(env_FSG_CN_delete_Message, "POS INVALID");
                    else
                        elements = gCN_DelValidCtr;
                }
            }
            else  // no errorhandling
            {
                if (elements==0x00)   // if no data
                    transmitpos     =0x0;
            }
		
        
        //mode
        mode            =shift +(direction*0x02) +(transmitpos*0x04) +(indexsize*0x08);
		
        /***ArrayHeader***/
        requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
		Offset++;

        requestarray[Offset] =startelement;
        Offset++;  

        requestarray[Offset] =elements;
        Offset++;
                
        /***ArrayData***/
        //MR 62005 if-else condition
        if (getValue(env_FSG_CN_delete_Auto)==0x00)
        {
            if (getValue(env_FSG_CN_delete_ErrHandler)==0x00)
            {
                for ( i = 0; i < elements; i++ )
                {
                requestarray[Offset] =POS[i];
                Offset++;
    	        }
    	    }//if
    		else
    		{
    			for (i=0; i<gCN_DelValidCtr; i++)
               		{
                		requestarray[Offset] =gCombinedNum_Send[i][0];
                		Offset++;
    			    }
    		}
        }
        else
        {
                requestarray[Offset] = getValue(env_FSG_CN_delete_POS_8_A);
                Offset++;
        }

 		break;
            
      case 1:  //16Bit
            //MR 62005 if-else condition
            if (getValue(env_FSG_CN_delete_Auto)==0x00)
            {
            getvalue(env_FSG_CN_delete_POS_16, POS);
            startelement  = getvalue(env_FSG_CN_delete_start);
            elements      = getValueSize(env_FSG_CN_delete_POS_16)/2;
            }
            else
            {
            startelement  = getvalue(env_FSG_CN_delete_start);
            elements      = 1;
            }

            if (getValue(env_FSG_CN_delete_ErrHandler)==0x01)
              { 
                        if (elements==0)   // if insufficient data
                        {
                        putValue(env_FSG_CN_delete_Message, "NO DATA TO SEND");
                        break;
                        }
                    
                        else     // with data
                        {
                        CombinedNumbers_delete_ErrHandler_16 (POS,elements*2);
                            //if all elements are invalid
                            if (elements ==gCN_DelInvalidCtr/2)
                            {
                            putValue(env_FSG_CN_delete_Message, "ALL POS INVALID");
                            break;
                            }
                    
                            else
                           elements = gCN_DelValidCtr/2;
                        }
                }
            else  // no errorhandling
                {
                if (elements==0x00)   // if no data
                transmitpos     =0x0;
                }
        
                //mode
                mode  = shift + (direction*0x02) + (transmitpos*0x04) + (indexsize*0x08);

                /***ArrayHeader***/
                requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
                Offset++;

                requestarray[Offset] =startelement &0xff; 
                Offset++; 
                requestarray[Offset] =(startelement &0xff00) /0x100;
                Offset++;
                
                
                requestarray[Offset] =elements &0xff;
                Offset++;
                requestarray[Offset] =(elements &0xff00) /0x100;
                Offset++;

                /***ArrayData***/
                //MR 62005 if-else condition
                if (getValue(env_FSG_CN_delete_Auto)==0x00)
                {
                    if (getValue(env_FSG_CN_delete_ErrHandler)==0x00)
                    {
                        for ( i = 0; i < elements; i++ )    //2 elements are inserted to the array below
                        {
                           requestarray[Offset] = POS[(2*i)+1];
                           Offset++;

                           requestarray[Offset] = POS[(2*i)];
                           Offset++;
                        }
                    }
                     else    // with error handling
                     {
                        for (i=0; i<elements; i++)
                        {
                        PosVal = 0x00;
                        requestarray[Offset] =gCombinedNum_Send[(2*i)+1][0];
                        PosVal = requestarray[Offset];
                        Offset++;
						   
                        requestarray[Offset] = gCombinedNum_Send[(2*i)+0][0];
                        PosVal = PosVal|requestarray[Offset]<<8;
                        Offset++;
                        } //for (i=0; i<gCN_DelValidCtr; i++)

                    } //else ERRORHANDLING
                }//env_FSG_CN_delete_Auto
                else
                {
                requestarray[Offset]= (byte)(getValue(env_FSG_CN_delete_POS_16_A) & 0xFF);
                Offset++;
                requestarray[Offset]= (byte)(getValue(env_FSG_CN_delete_POS_16_A) >> 8);
                Offset++;

                }
        break;

      default:
        break;
    }
        
        //DATA SENDING
        if (getValue(env_FSG_CN_delete_ErrHandler)==0x00)
       set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 

        else
        {
            if (gCN_DelInvalidCtr!=0)
                putValue(env_FSG_CN_delete_Invalid,gCN_InvalidDel);

            if (gCN_DelValidCtr != 0x00)
            {
                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
                
                //MR 63332 #3   02.07.2014
                //if (indexsize == 0x00)
                //putValue(env_FSG_CN_TotalNumLE, gCN_TotalElem -gCN_DelValidCtr);
                //else
                //putValue(env_FSG_CN_TotalNumLE, gCN_TotalElem -(gCN_DelValidCtr/2));
                //gCombinedNumbers_TotalNumListElements = getValue(env_FSG_CN_TotalNumLE);

                if (indexsize == 0x00)
                gCombinedNumbers_TotalNumListElements = gCN_TotalElem - gCN_DelValidCtr;
                else
                gCombinedNumbers_TotalNumListElements = gCN_TotalElem - (gCN_DelValidCtr/2);
                putValue(env_FSG_CN_TotalNumLE, gCombinedNumbers_TotalNumListElements);
            }//if
        } //else

   }
}

//IssueList #76 - MR49870 : CN
on envVar env_FSG_CN_insert
{
    word startelement, elements,successor, ctr, PosCtr,CNlistCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[TEL_COMBINEDNUMBERS_ENTRIES], posInBetweenCheck;
    dword requestarray [BAP_buffer_size], Offset, i;
 
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    i                       =0;
    Offset                  =0;
    elemTemp		        =0;
    PosVal                  =0;


    if(gFSG_Telephone_PowerOnOff==Power_on && getvalue(this))
    {

        for(i =0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
            POS[i] =0;

        for(i =0; i<BAP_buffer_size; i++)
            requestarray[i] =0;

        for(i =0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
            gCN_InvalidIns[i] =0;

        for(i =0; i<TEL_COMBINEDNUMBERS_ENTRIES; i++)
            gCombinedNum_Send[i][0] =0;
    
        putValue(env_FSG_CN_Insert_Invalid,gCN_InvalidIns);

        gCN_InsInvalidCtr=0;
        gCN_InsValidCtr =0;
        putValue(env_FSG_CN_Insert_Message, empty_string);

        //get data from Panel
        //Patch GB 11.07.2014 -commented
        //recordaddress   =0x0F;

        putvalue (env_FSG_CN_Insert_Message, empty_string);
        //MR 63332 #3   02.07.2014
        //gCN_TotalElem = getValue(env_FSG_CN_TotalNumLE);
        gCN_TotalElem = gCombinedNumbers_TotalNumListElements;

        if (getValue(env_FSG_CN_insert_UPD_button)==0x00)
        {
            shift           =0x01; //insert
            //Patch GB 11.07.2014
            recordaddress   =0x0F;
        }
        else
        {
            shift           =0x0; //update
            //Patch GB 11.07.2014
            recordaddress   =getValue(env_FSG_CN_AH_RA);
         }

        direction       =0x0;
        transmitpos     =0x01;

        indexsize       =getvalue(env_FSG_CN_insert_size);
        //mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        //message
        requestarray[0] =LSGID_Telephone;				//LSG-ID
        requestarray[1] =FctID_CombinedNumbers;		//Fct.-ID
        requestarray[2] =Changed_REQ;                  //request type  
        Offset =3;
        
        startelement    =getValue(env_FSG_CN_insert_start);
        
        successor = getValue(env_FSG_CN_insert_successor);
      

        switch (indexsize) // POS size
        {
            case 0: //8Bit
                getvalue(env_FSG_CN_insert_POS_8, POS);
                
                //MR 62005 if-else condition
                if (getValue(env_FSG_CN_insert_Auto)==0x00)
                ctr = getValueSize(env_FSG_CN_insert_POS_8);
                else
                ctr =1;

                if (getValue(env_FSG_CN_insert_ErrHandler)==0x01)
                {

                    if (ctr == 0)   // if no data
                    {
                        putValue(env_FSG_CN_Insert_Message, "NO DATA TO SEND");
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid for Insert
                        if (getvalue(env_FSG_CN_insert_start) == 0x00 && getvalue(env_FSG_CN_insert_successor) == 0x00 && getvalue(env_FSG_CN_insert_UPD_button) == 0x00)
                        {
                            //check if not all elements are deleted
                            if (gCN_totalDELctr < gCN_CSVtotalElem)
                            {
                            putValue(env_FSG_CN_Insert_Message, "INVALID START & SUCCESSOR");
                            break;
                            }
                        }
                        
                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                        posInBetweenCheck       =0;
                        if (ctr >1)
                        {
                            posInBetweenCheck =  pbPosSequence_check (indexsize,POS,ctr);
                            if (posInBetweenCheck == 0x01)
                            {
                                putValue(env_FSG_CN_Insert_Message, "INCORRECT POS SEQUENCE!");
                                break;
                            }
                        }
                     
                       //ERROR CHECKING
                        CombinedNumbers_insert_ErrHandler_8 (POS,ctr);
                        
                        //if update has invalid POS - do not send
                        if (getvalue(env_FSG_CN_insert_UPD_button) == 0x01)  //update
                        {
                            if (gCN_InsInvalidCtr>0)
                            {
                                putValue(env_FSG_CN_Insert_Message, "INVALID POS EXISTS");
                                break;
                            }
                        }
 
                     
                        //if all elements are INVALID for INSERT
                        if (ctr == gCN_InsInvalidCtr)
                        {
                            putValue(env_FSG_CN_Insert_Message, "POS INVALID / STILL EXIST");
                            break;
                        }
                        else
                        {
                            elements = gCN_InsValidCtr+1;   //+ successor
                            ctr = gCN_InsValidCtr;
                        }

                    }//else with data
                }
                else   // no error handling
                {
                    elements = ctr+1;
                    if (ctr==0)    // if no data
                    {
                        transmitpos     =0x0;

                        if (successor == 0x00)  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                            elements = successor - startelement;
                    }    
                 }

                //mode
                mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***ArrayHeader***/
                requestarray[Offset] = ((mode *0x10) &0xF0) +(recordaddress &0x0F);
                Offset++;

                //start
                requestarray[Offset] = startelement;
                Offset++;  
                
                //elements
                requestarray[Offset] = elements;
                Offset++;

                /***ArrayData***/
                //MR 62005 if-else condition
                if (getValue(env_FSG_CN_insert_Auto)==0x00)
                {
                    //ArrayData with error handling
                    if (getValue(env_FSG_CN_insert_ErrHandler)==0x01)
                    {
                        //ARRAY DATA
                            for (i=0; i<ctr; i++)
                                {
                                    //store in array the inserted item
                                    requestarray[Offset] = gCombinedNum_Send[i][0];
                                    Offset++;
                                }
                  
                    } //end if with ERROR handling

                    //ArrayData WITHOUT error handling
                    else
                    {
                         for (i=0; i<ctr; i++)
                         {
                            requestarray[Offset] =POS[i];
                            Offset++;
                         }
                    }
                } //env_FSG_CN_insert_Auto
                else
                {
                   requestarray[Offset] =getValue(env_FSG_CN_insert_POS_8_A);
                   Offset++;
                }

                //successor
                if (ctr > 0)
                {
                    requestarray[Offset] = successor;
                    Offset++;    
                }

            break;
            
            case 1:  //16Bit
                //MR 62005 if-else condition
                if (getValue(env_FSG_CN_insert_Auto)==0x00)
                {
                getvalue(env_FSG_CN_insert_POS_16, POS);
                elements = getValueSize(env_FSG_CN_insert_POS_16);
                elemTemp = (getValueSize(env_FSG_CN_insert_POS_16)/2);
                }
                else
                {
                elements = 2;
                elemTemp = 1;
                }

                if (getValue(env_FSG_CN_insert_ErrHandler)==0x01)
                {
                    if (elemTemp==0)   // if no data
                    {
                        putValue(env_FSG_CN_Insert_Message, "NO DATA TO SEND");
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid
                        if ((getvalue(env_FSG_CN_insert_start) == 0x00) && (getvalue(env_FSG_CN_insert_successor) == 0x00)&& (getvalue(env_FSG_CN_insert_UPD_button) == 0x00))
                        {
                            //check if not all elements are deleted
                            if (gCN_totalDELctr < gCN_CSVtotalElem)
                            {
                            putValue(env_FSG_CN_Insert_Message, "INVALID START & SUCCESSOR");
                            break;
                            }
                        }
                          
                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                            //if (ctr >1)
                            if (elemTemp >1)
                            {
                                posInBetweenCheck =  pbPosSequence_check (indexsize,POS,elemTemp);
                                if (posInBetweenCheck == 0x01)
                                {
                                    putValue(env_FSG_CN_Insert_Message, "INCORRECT POS SEQUENCE!");
                                    break;
                                }
                            }

                       CombinedNumbers_insert_ErrHandler_16 (POS,elements);
                        //if all elements are INVALID

                        //if update has invalid POS - do not send
                        if (getvalue(env_FSG_CN_insert_UPD_button) == 0x01)  //update
                        {
                            if (gCN_InsInvalidCtr>0)
                            {
                                putValue(env_FSG_CN_Insert_Message, "INVALID POS EXISTS");
                                break;
                            }
                        }
                    
                        if (elemTemp == gCN_InsInvalidCtr)
                        {
                            putValue(env_FSG_CN_Insert_Message, "POS INVALID / STILL EXIST");
                            break;
                        }
                        else
                        {
                            elements = (gCN_InsValidCtr/2)+1;     //including successor
                            elemTemp = gCN_InsValidCtr/2;
                        }

                    } //else with data
                } //with errorHandling
                else   // no error handling
                {
                    elements = elemTemp + 1;  //including successor
                    if (elemTemp==0)    // if no data
                    {
                        transmitpos = 0x0;
                         if (successor == 0x00)  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                        elements = successor - startelement;
                    }
                }

                //mode
                mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***ArrayHeader***/
                requestarray[Offset] = ((mode*0x10)&0xF0) + (recordaddress&0x0F);
                Offset++;

                requestarray[Offset] = startelement&0xff; 
                Offset++;
                requestarray[Offset] = (startelement&0xff00) / 0x100;
                Offset++;
                
                requestarray[Offset] = elements&0xff;
                Offset++;
                requestarray[Offset] = (elements&0xff00) / 0x100;
                Offset++;

                /***ArrayData***/
                //MR 62005 if-else condition
                if (getValue(env_FSG_CN_insert_Auto)==0x00)
                {
                    //ArrayData with error handling
                    if (getValue(env_FSG_CN_insert_ErrHandler)==0x01)
                    {
                        for ( i = 0; i < elemTemp; i++ )
                            {
                                PosVal = 0x00;

                                //store in array the inserted item
                                requestarray[Offset] = gCombinedNum_Send[(2*i)+1][0];
                                PosVal = requestarray[Offset];
                                Offset++;
                                requestarray[Offset] = gCombinedNum_Send[(2*i)+0][0];
                                PosVal = PosVal|requestarray[Offset]<<8;
                                Offset++;
                             }
					
					
                    } // end if with Errorhandling
                    //ArrayData WITHOUT error handling
                    else
                    {
                        for ( i = 0; i < elemTemp; i++ )
                        {
                            requestarray[Offset] = POS[(2*i)+1];
                            Offset++;
                            requestarray[Offset] = POS[(2*i)+0];
                            Offset++;
                        }
                    }
                } //env_FSG_CN_insert_Auto
                else
                {
                requestarray[Offset]= (byte)(getValue(env_FSG_CN_insert_POS_16_A) & 0xFF);
                Offset++;
                requestarray[Offset]= (byte)(getValue(env_FSG_CN_insert_POS_16_A) >> 8);
                Offset++;
                }


                //successor
                if (elemTemp > 0)
                {
                    requestarray[Offset] = successor&0xff; 
                    Offset++;
                    requestarray[Offset] = (successor&0xff00) / 0x100;
                    Offset++;
                }
                break; 

            default:
                break; //default

        }//switch

        if (indexsize==0x01)
        gCN_InsValidCtr = gCN_InsValidCtr/2;

        //updating the totalDeletedCtr;
   		gCN_totalDELctr = gCN_totalDELctr - gCN_InsValidCtr;
        
        if (gCN_totalDELctr > gCN_CSVtotalElem)
        gCN_totalDELctr=0;

                
        //just send the data when errorhandler is OFF
        if (getValue(env_FSG_CN_insert_ErrHandler)==0x00)
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
        
        else if (getValue(env_FSG_CN_insert_ErrHandler)==0x01)  //with ERROR HANDLER
        {
            if (getValue(env_FSG_CN_insert_UPD_button)==0x00)  //insert
            {
                // if there's a Valid POS and Sequence is correct
                if (gCN_InsValidCtr != 0x00 && posInBetweenCheck == 0x00)
                {
                    set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
                    
                    if (gCN_TotalElem +gCN_InsValidCtr <=gCN_CSVtotalElem)
                    {
                        //MR 63332 #3   02.07.2014
                        //putValue(env_FSG_CN_TotalNumLE, gCN_TotalElem +gCN_InsValidCtr);
                        //gCombinedNumbers_TotalNumListElements = getValue(env_FSG_CN_TotalNumLE);
                        gCombinedNumbers_TotalNumListElements = gCN_TotalElem + gCN_InsValidCtr;
                        putValue(env_FSG_CN_TotalNumLE, gCombinedNumbers_TotalNumListElements);
                    } //if
               
                
                }// if gCN_InsValidCtr
            }// if insert
            else
            {
                //send only UPDATE if all POS are valid and DATA!=0
                if (gCN_InsInvalidCtr == 0x00 && gCN_InsValidCtr!=0)
                    set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
            }// else UPD button
        } //else if 
    }
    //else
    //putValue(env_FSG_CN_insert_UPD_button,0);
}

//IssueList #76 - MR49870 : CN
on envVar env_FSG_CN_delete_POS_8
{
byte DEL_POS_8[TEL_COMBINEDNUMBERS_ENTRIES];

putValue(env_FSG_CN_delete_Message, empty_string);
 
    //AUTOMATIC START VALUE
    if (getValue(env_FSG_CN_delete_ErrHandler)==0x01)
    {
    getValue(this, DEL_POS_8);
    putValue(env_FSG_CN_delete_start, DEL_POS_8[0]);
    }

}

//IssueList #76 - MR49870 : CN
on envVar env_FSG_CN_delete_POS_16
{
byte DEL_POS_16[TEL_COMBINEDNUMBERS_ENTRIES];
word PosVal_16;

putValue(env_FSG_CN_delete_Message, empty_string);
 

    //AUTOMATIC START VALUE
    if (getValue(env_FSG_CN_delete_ErrHandler)==0x01)
    {
    getValue(this, DEL_POS_16);
    PosVal_16 = DEL_POS_16[0] << 8;
    PosVal_16 = PosVal_16|DEL_POS_16[1];

    putValue(env_FSG_CN_delete_start, PosVal_16);
    }

}

//IssueList #76 - MR49870 : CN
on envVar env_FSG_CN_delete_ErrHandler
{
if (getValue(this)==0x00)
putValue(env_FSG_CN_TotalNumLE,gCN_CSVtotalElem);
}

//IssueList #76 - MR49870 : CN
on envVar env_FSG_CN_insert_ErrHandler
{
if (getValue(this)==0x00)
putValue(env_FSG_CN_TotalNumLE,gCN_CSVtotalElem);
}

//IssueList #76 - MR49870 : CN
byte cnPosSequence_check (byte Index, byte inputArray[],word inputCtr)
{
	byte posInBetween;
	word ctr,ctr1,ctr2,PosVal1_,PosVal2_;

	posInBetween = 0;
	
	for (ctr = 0; ctr < inputCtr; ctr++)
	{
		// adjust for 8bit and 16bit handling
		if (Index==0x00)
		{
			PosVal1_ = inputArray[ctr];
			PosVal2_ = inputArray[ctr+1];
		}
		else
		{
			PosVal1_ = 0x0000;
			PosVal1_ = inputArray[(2*ctr)+1];
			PosVal1_ = PosVal1_|((inputArray[(2*ctr)+0])<<8);
			PosVal2_ = 0x0000;
			PosVal2_ = inputArray[(2*ctr)+2+1];
			PosVal2_ = PosVal2_|((inputArray[(2*ctr)+2+0])<<8);			
		}
		
		// search send item in insdel array
		for( ctr1 = 0; ctr1 < gCN_CSVtotalElem; ctr1++ )
		{
			if( PosVal1_ == gCombinedNum_Pos_insDel[ctr1][0]) // 1st send item is found in array			
			{
				break;
			}
		}
		
		// search insdel array for next send item
		for( ctr2 = ctr1+1; ctr2 < gCN_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
		{

			if (PosVal2_ == gCombinedNum_Pos_insDel[ctr2][0]) // 2nd send item immediately next to 1st send item			
			{
				break;
			}
			else
			{
				if (gCombinedNum_Pos_insDel[ctr2][1] == 0 && PosVal2_ !=0)	// in between item is not deleted
				{
					posInBetween = 0x01;
					break;
				}
			}
		}
		
		if( posInBetween == 0x01)
		{
			break;
		}
	}
	
	return posInBetween;

    }

//IssueList #76 - MR49870 : CombinedNum
//Automatic START AND SUCCESSOR VALUES
on envVar env_FSG_CN_insert_POS_8
{
byte INS_POS_8[TEL_COMBINEDNUMBERS_ENTRIES];
int inputCtr,i,j;
byte valid_INS_POS_8;
byte validInputFlg_start, validInputFlg_succ;

putvalue (env_FSG_CN_Insert_Message, empty_string);


    //if (getValue(env_FSG_CN_insert_ErrHandler)==0x01 && getValue(env_FSG_CN_insert_UPD_button)==0x00)
    if (getValue(env_FSG_CN_insert_ErrHandler)==0x01)
    {
    getValue(this, INS_POS_8);
    validInputFlg_start =0;
    validInputFlg_succ = 0;

     inputCtr=  getValueSize(env_FSG_CN_insert_POS_8);

     if (inputCtr>0)
     {       
        //look for the valid reference for Start and successor
         for (j=0; j<inputCtr;j++)
         {
             valid_INS_POS_8 = INS_POS_8[j];
     
             for (i=0; i<gCN_CSVtotalElem;i++)
             {
             //check if input is valid and deleted
                 if (valid_INS_POS_8 == gCombinedNum_Pos_insDel[i][0] && gCombinedNum_Pos_insDel[i][1]==0x01)
                 {
                 validInputFlg_start = 1;
                 break;
                 }
             } 
             if (validInputFlg_start == 0x01) 
             break;   
          }

            if (validInputFlg_start == 0x01)
            {
            //start
             if (valid_INS_POS_8==gCombinedNum_Pos_insDel[0][0])
                 putValue(env_FSG_CN_insert_start,0);
             
             else
             {   
                ///look for the next existing element upwards
                 for (i=0; i<gCN_CSVtotalElem;i++)
                 {
                     if (valid_INS_POS_8==gCombinedNum_Pos_insDel[i][0])
                     {   
                        for (j=i-1;j>=0;j--)
                         {
                         if (gCombinedNum_Pos_insDel[j][1]!=0x01)
                            {
                             putValue(env_FSG_CN_insert_start,gCombinedNum_Pos_insDel[j][0]);
                             break;
                             }//if
                         }//for
                      }
                 }//for
             }//else
            } //validInputFlg

                //successor
                //look for the valid reference for Start and successor

                for (j=inputCtr-1; j>=0;j--)
                {
                     valid_INS_POS_8 = INS_POS_8[j];
     
                     for (i=0; i<gCN_CSVtotalElem;i++)
                     {
                     //check if input is valid and deleted
                         if (valid_INS_POS_8 == gCombinedNum_Pos_insDel[i][0] && gCombinedNum_Pos_insDel[i][1]==0x01)
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     } 
                     if (validInputFlg_succ == 0x01) 
                     break;     
                }
                if (validInputFlg_succ == 0x01)
                {
                    putValue(env_FSG_CN_insert_successor,0);
                
                    for (i=0; i<gCN_CSVtotalElem;i++)
                    {
                        if (valid_INS_POS_8==gCombinedNum_Pos_insDel[i][0])
                         {
                         if (i==gCN_CSVtotalElem-1)
                         putValue(env_FSG_CN_insert_successor,0);
                         else
                            {
                                 //look for the next existing element downwards
                                 for (j=i+1;j<gCN_CSVtotalElem;j++)
                                 {
                                     if (gCombinedNum_Pos_insDel[j][1]!=0x01)
                                     {
                                     putValue(env_FSG_CN_insert_successor,gCombinedNum_Pos_insDel[j][0]);
                                     break;
                                     }
                                 }
                             }//else

                        }//if
                 }//for
               }
          
        } //inputCtr
    }

}

//IssueList #76 - MR49870 : CombinedNum
//Automatic START AND SUCCESSOR VALUES
on envVar env_FSG_CN_insert_POS_16
{
byte INS_POS_16[TEL_COMBINEDNUMBERS_ENTRIES];
int  inputCtr,i,j;
word PosVal_16_first,PosVal_16_last;
byte validInputFlg_start, validInputFlg_succ;

inputCtr=0;
PosVal_16_first=0;
PosVal_16_last=0;
validInputFlg_start = 0;
validInputFlg_succ=0;


putvalue (env_FSG_CN_Insert_Message, empty_string);

    //if (getValue(env_FSG_CN_insert_ErrHandler)==0x01 && getValue(env_FSG_CN_insert_UPD_button)==0x00)
    if (getValue(env_FSG_CN_insert_ErrHandler)==0x01)
    {
    getValue(this, INS_POS_16);

     inputCtr=  getValueSize(env_FSG_CN_insert_POS_16);
     
         if (inputCtr > 1)
         {
            //look for the valid reference for Start and successor
             for (j=0; j<inputCtr;j++)
             {
             //valid_INS_POS_8 = INS_POS_8[j];

             PosVal_16_first = INS_POS_16[j] << 8;
             PosVal_16_first = PosVal_16_first | INS_POS_16[j+1];

     
                for (i=0; i<gCN_CSVtotalElem;i++)
                 {
                 //check if input is valid and deleted
                     if (PosVal_16_first == gCombinedNum_Pos_insDel[i][0] && gCombinedNum_Pos_insDel[i][1]==0x01)
                     {
                     validInputFlg_start = 1;
                     break;
                     }
                 } 
                 if (validInputFlg_start == 0x01) 
                 break;   
               }

                if (validInputFlg_start == 0x01)
                {
                    //start
                     if (PosVal_16_first==gCombinedNum_Pos_insDel[0][0])
                         putValue(env_FSG_CN_insert_start,0);
             
                     else
                     {   
                        ///look for the next existing element upwards
                         for (i=2; i<gCN_CSVtotalElem;i++)
                         {
                             if (PosVal_16_first==gCombinedNum_Pos_insDel[i][0])
                             {   
                                for (j=i-1;j>0;j--)
                                 {
                                 if (gCombinedNum_Pos_insDel[j][1]!=0x01)
                                    {
                                     putValue(env_FSG_CN_insert_start,gCombinedNum_Pos_insDel[j][0]);
                                     break;
                                     }//if
                                 }//for
                              }
                         }//for
                     }//else
                }

                   //successor
                for (j=inputCtr; j>0;j--)
                {

                     PosVal_16_last = INS_POS_16[j-1] << 8;
                     PosVal_16_last = PosVal_16_last | INS_POS_16[j];
     
                     for (i=0; i<gCN_CSVtotalElem;i++)
                     {
                     //check if input is valid and deleted
                         if (PosVal_16_last == gCombinedNum_Pos_insDel[i][0] && gCombinedNum_Pos_insDel[i][1]==0x01)
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     } 
                     if (validInputFlg_succ == 0x01) 
                     break;     
                }

                if (validInputFlg_succ == 0x01)
                {

                   putValue(env_FSG_CN_insert_successor,0);
                    for (i=0; i<gCN_CSVtotalElem;i++)
                    {
                
                         if (PosVal_16_last==gCombinedNum_Pos_insDel[i][0])
                         {
                             if (i==gCN_CSVtotalElem-1)
                             putValue(env_FSG_CN_insert_successor,0);
                             else
                             {
                                 //look for the next existing element downwards
                                 for (j=i+1;j<gCN_CSVtotalElem;j++)
                                 {
                                     if (gCombinedNum_Pos_insDel[j][1]!=0x01)
                                     {
                                     putValue(env_FSG_CN_insert_successor,gCombinedNum_Pos_insDel[j][0]);
                                     break;
                                     }
                                 }
                             }

                        }//if
                 }//for
               } //validInputFlg_succ
           }//inputCtr
    }

}

//IssueList #76 - MR49870 : CN
void CombinedNumbers_delete_ErrHandler_8 (byte pos[],word elementsCtr)
{
    byte i, result,delFlg;
    word CNlistCtr, PosCtr;
    
    result = 0x01;
    delFlg=0;
    gCN_DelInvalidCtr = 0;
    gCN_DelValidCtr =0;
    putValue(env_FSG_CN_delete_Message, empty_string);
    
    for (PosCtr =0; PosCtr<elementsCtr; PosCtr++)
    {

         result =0x00;
         delFlg = 0x00;

      for (CNlistCtr = 0;CNlistCtr<gCN_CSVtotalElem; CNlistCtr++)
      {    

           if (pos[PosCtr]==gCombinedNum_Pos_insDel[CNlistCtr][0])   //check if POS is valid
           {
             if (gCombinedNum_Pos_insDel[CNlistCtr][1]!=0x01)  //check if POS still exists
               {
               gCombinedNum_Pos_insDel[CNlistCtr][1] = 0x01;    //tagging deleted Pos
               gCombinedNum_Send[gCN_DelValidCtr][0] = pos[PosCtr];
               
               gCN_DelValidCtr++;
               gCN_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue(env_FSG_CN_delete_Message, "POS already deleted!");
              gCN_InvalidDel[gCN_DelInvalidCtr] = pos[PosCtr];
              gCN_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }
              
           }//if
           
       }//for
        if (result == 0x00 && delFlg == 0x00)
        {
          gCN_InvalidDel[gCN_DelInvalidCtr]=pos[PosCtr];
          gCN_DelInvalidCtr++;
          putValue(env_FSG_CN_delete_Message, "INVALID POS!");
         }

     }
}

//IssueList #76 - MR49870 : CN
void CombinedNumbers_delete_ErrHandler_16 (byte pos[],word elementsCtr)
{
    byte i, result,delFlg;
    word CNlistCtr, PosCtr,PosVal;
    
    result = 0x01;
    delFlg=0;
    gCN_DelInvalidCtr = 0;
    gCN_DelValidCtr =0;
    putValue(env_FSG_CN_delete_Message, empty_string);
    PosVal = 0;

    for (PosCtr =0; PosCtr<elementsCtr; PosCtr = PosCtr+2)
    {
         result =0x00;
         delFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+1];

      for (CNlistCtr = 0;CNlistCtr<gCN_CSVtotalElem; CNlistCtr++)
      {    
           if (PosVal==gCombinedNum_Pos_insDel[CNlistCtr][0])   //check if POS is valid
           {
             if (gCombinedNum_Pos_insDel[CNlistCtr][1]!=0x01)  //check if POS still exists
               {
               gCombinedNum_Pos_insDel[CNlistCtr][1] = 0x01;    //tagging deleted Pos
               gCombinedNum_Send[gCN_DelValidCtr][0] = pos[PosCtr];
               gCN_DelValidCtr++;
               gCombinedNum_Send[gCN_DelValidCtr][0] = pos[PosCtr+1];
               gCN_DelValidCtr++;
               gCN_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue(env_FSG_CN_delete_Message, "POS already deleted!");
              gCN_InvalidDel[gCN_DelInvalidCtr] = pos[PosCtr];
              gCN_DelInvalidCtr++;
              gCN_InvalidDel[gCN_DelInvalidCtr] = pos[PosCtr+1];
              gCN_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }
              
           }//if
           
       }//for
        if (result == 0x00 && delFlg == 0x00)
        {
            gCN_InvalidDel[gCN_DelInvalidCtr] = pos[PosCtr];
            gCN_DelInvalidCtr++;
            gCN_InvalidDel[gCN_DelInvalidCtr] = pos[PosCtr+1];
            gCN_DelInvalidCtr++;
            putValue(env_FSG_CN_delete_Message, "INVALID POS!");
         }
     }
}

//IssueList #76 - MR49870 : CN
void CombinedNumbers_insert_ErrHandler_8 (byte pos[],word elementsCtr)
{
    byte i, result,InsFlg;
    word CNlistCtr, PosCtr;
    
    result = 0x01;
    InsFlg=0;

  
    for (PosCtr =0; PosCtr<elementsCtr; PosCtr++)
    {
         result =0x00;
         InsFlg = 0x00;
        
      for (CNlistCtr = 0;CNlistCtr<gCN_CSVtotalElem; CNlistCtr++)
      {    
           if (pos[PosCtr]==gCombinedNum_Pos_insDel[CNlistCtr][0])   //check if POS is valid
           {
            //UPDATE      
                if  (getValue(env_FSG_CN_insert_UPD_button) == 0x01) 
                 {  
                        if (gCombinedNum_Pos_insDel[CNlistCtr][1]==0x00)  //check if POS is not deleted            {
                        {
                        result = 0x01; 
                        gCombinedNum_Send[gCN_InsValidCtr][0] = pos[PosCtr];  
                        gCN_InsValidCtr++;
                        }
                    
                        else
                          {
                          putValue(env_FSG_CN_Insert_Message, "POS is already deleted!");
                          gCN_InvalidIns[gCN_InsInvalidCtr] = pos[PosCtr];
                          gCN_InsInvalidCtr++;
                          InsFlg = 0x01;
                          break;
                          }

                }  //update

                 else   //INSERT
                 {
                     if (gCombinedNum_Pos_insDel[CNlistCtr][1]==0x01)  //check if POS does not exist
                       {
                       gCombinedNum_Pos_insDel[CNlistCtr][1] = 0x00;
                       gCombinedNum_Send[gCN_InsValidCtr][0] = pos[PosCtr];

                       gCN_InsValidCtr++;
                       result = 0x01;
                       }
                      else
                      {
                      putValue(env_FSG_CN_Insert_Message, "POS still exists!");
                      gCN_InvalidIns[gCN_InsInvalidCtr] = pos[PosCtr];
                      gCN_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                      }
               }//if
            } //else
       }//for
        if (result == 0x00 && InsFlg == 0x00)
           {
           gCN_InvalidIns[gCN_InsInvalidCtr]=pos[PosCtr];
            gCN_InsInvalidCtr++;
             putValue(env_FSG_CN_Insert_Message, "INVALID POS!");
            }
     }//for CNlistCtr

     if (gCN_InsInvalidCtr!=0)
            putValue(env_FSG_CN_Insert_Invalid,gCN_InvalidIns);
}

//IssueList #76 - MR49870 : CN
void CombinedNumbers_insert_ErrHandler_16 (byte pos[],word elementsCtr)
{
    byte i, result,InsFlg;
    word PosVal,CNlistCtr, PosCtr;

    result = 0x01;
    InsFlg=0;
    PosVal = 0;

    for (PosCtr =0; PosCtr<elementsCtr; PosCtr = PosCtr+2)
    {
         result =0x00;
         InsFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+1];
        
      for (CNlistCtr = 0;CNlistCtr<gCN_CSVtotalElem; CNlistCtr++)
      {    
           if (PosVal==gCombinedNum_Pos_insDel[CNlistCtr][0])   //check if POS is valid
           {
            //UPDATE      
            if  (getValue(env_FSG_CN_insert_UPD_button) == 0x01) 
             {  
                if (gCombinedNum_Pos_insDel[CNlistCtr][1]==0x00)  //check if POS is not deleted            {
                    {
                    result = 0x01; 
                    gCombinedNum_Send[gCN_InsValidCtr][0] = pos[PosCtr];  
                    gCN_InsValidCtr++;
                    gCombinedNum_Send[gCN_InsValidCtr][0] = pos[PosCtr+1];  
                    gCN_InsValidCtr++;
                    }
                        else
                      {
                      putValue(env_FSG_CN_Insert_Message, "POS is already deleted!");
                      gCN_InvalidIns[gCN_InsInvalidCtr] = pos[PosCtr];
                      gCN_InsInvalidCtr++;
                      gCN_InvalidIns[gCN_InsInvalidCtr] = pos[PosCtr+1];
                      gCN_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                  }

            }  //update

             else   //INSERT
             {
                 if (gCombinedNum_Pos_insDel[CNlistCtr][1]==0x01)  //check if POS does not exist
                   {
                   gCombinedNum_Pos_insDel[CNlistCtr][1] = 0x00;
                   gCombinedNum_Send[gCN_InsValidCtr][0] = pos[PosCtr];
                   gCN_InsValidCtr++;
                   gCombinedNum_Send[gCN_InsValidCtr][0] = pos[PosCtr+1];
                   gCN_InsValidCtr++;
                   result = 0x01;
                   
                   }
                  else
                  {
                  putValue(env_FSG_CN_Insert_Message, "POS still exists!");
                  gCN_InvalidIns[gCN_InsInvalidCtr] = pos[PosCtr];
                  gCN_InsInvalidCtr++;
                  gCN_InvalidIns[gCN_InsInvalidCtr] = pos[PosCtr+1];
                  gCN_InsInvalidCtr++;
                  InsFlg = 0x01;
                  break;
                  }
               }//if
            } //else
       }//for
        if (result == 0x00 && InsFlg == 0x00)
           {
            gCN_InvalidIns[gCN_InsInvalidCtr]=pos[PosCtr];
            gCN_InsInvalidCtr++;
	        gCN_InvalidIns[gCN_InsInvalidCtr] = pos[PosCtr+1];
            gCN_InsInvalidCtr++;
             putValue(env_FSG_CN_Insert_Message, "INVALID POS!");
            }
     }//for CNlistCtr

     if (gCN_InsInvalidCtr!=0)
            putValue(env_FSG_CN_Insert_Invalid,gCN_InvalidIns);
}

on timer fsgOperationState_delayTimer
{
       FSG_OperationState_Request(Data_REQ, 0);
}

//IssueList #183 - GetAll
on envVar env_FSG_GetAll_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(env_FSG_GetAll_SegmEn,0);
           intertelegram_err(FctID_GetAll);
       }
       else
       {
           intertelegram_err_off(FctID_GetAll);
       }
}

//IssueList #183
intertelegram_err(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=1;
    data[3]=940;
    ChangeConfig(0x0020,data);
}

//IssueList #183
intertelegram_err_off(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    ChangeConfig(0x0020,data);
}

//IssueList #183
on envVar env_FSG_GetAll_SegmEn
{
       if(getValue(this)) 
       {
           putValue(env_FSG_GetAll_IntTlgEn,0);
           sequence_err(FctID_GetAll,154);
       }
       else
       {
              sequence_err_off(FctID_GetAll);
       }
}

//IssueList #183
sequence_err_off(long fctId)
{
    long data[5];

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    data[4]=0;
    ChangeConfig(0x0021,data);
}

//IssueList #183
sequence_err(long fctId, long size)
{
    long data[5];
    long lastSeg;

    lastSeg = size-5;

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=lastSeg/7+1;
    data[3]=1;
    data[4]=(lastSeg/7+4) & 15;
    ChangeConfig(0x0021,data);
}

//IssueList #182 - FunctionList
on envVar env_FSG_FctList_SegmEn
{
       if(getValue(this)) 
       {
           putValue(env_FSG_FctList_IntTlgEn,0);
           sequence_err(FctID_FunctionList,8);
       }
       else
       {
              sequence_err_off(FctID_FunctionList);
       }
}

//IssueList #182 - FunctionList
on envVar env_FSG_FctList_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(env_FSG_FctList_SegmEn,0);
           intertelegram_err(FctID_FunctionList);
       }
       else
       {
           intertelegram_err_off(FctID_FunctionList);
       }
}

//IssueList #184
//resending BAPconfig when this button is pressed
on envVar env_BAPCFG_FSG_ResetSet
{
   message 0x100 _mBAPconfig;	

    if (getValue(this))
    {
        //for BAPconfig Set/Reset button
         _mBAPconfig.CAN=1; 
		 _mBAPconfig.ID=0x97332810; 
		 _mBAPconfig.DLC=8; 
                	
         _mBAPconfig.byte(0) = 0x0a;
         _mBAPconfig.byte(1) = 0x02;
         _mBAPconfig.byte(2) = getValue(env_BAPCFG_FSG_Tel_PrtclMjr);
         _mBAPconfig.byte(3) = getValue(env_BAPCFG_FSG_Tel_PrtclMnr);
         _mBAPconfig.byte(4) = getValue(env_BAPCFG_FSG_Tel_LsgClssMjr);
         _mBAPconfig.byte(5) = getValue(env_BAPCFG_FSG_Tel_LsgClssMnr);
         _mBAPconfig.byte(6) = getValue(env_BAPCFG_FSG_Tel_DFMajor);
         _mBAPconfig.byte(7) = getValue(env_BAPCFG_FSG_Tel_DFMinor);
      
        output(_mBAPconfig);	
   }
}

//IssueList #182
Request_error (byte fctID, byte errorCode)
{
word Offset;
dword requestarray [BAP_buffer_size];

	        requestarray[0]=LSGID_Telephone;	//LSG-ID
			requestarray[1]=fctID;	//Fct.-ID
			requestarray[2]=Error_REQ;	
			requestarray[3]=errorCode;
			Offset=4;
			set_status_requestbuffer (requestarray, Offset, Bap_Error);
}

on envVar env_FSG_GetAll_ErrEn
{
if (getValue(this))
putValue(env_FSG_GetAll_FctEn,0);
}

//IssueList #182
on envVar env_FSG_FctList_ErrEn
{
if (getValue(this))
putValue(env_FSG_FctList_FctEn,0);
}

//IssueList #184
on envVar env_BAPCFG_FSG_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_BAP_Config;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #183
on envVar env_FSG_GetAll_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_GetAll;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #182
on envVar env_FSG_FctList_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_FunctionList;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

on envVar env_FSG_NetworkProviderName
{
getValue(this, gCurrent_NetworkProviderName);
}

on envVar env_FSG_ServiceProviderName
{
getValue(this, gCurrent_ServiceProviderName);
}

//-- Function 0x3B - SupportedServiceNumbers ---------------------------------------------
//-- update SupportedServiceNumbers ------------------------------------------------------
//IssueList #206
on envVar env_FSG_SSN_update
{
	if(gFSG_Telephone_PowerOnOff==Power_on && getValue(this))
  {
    int i;
    dword requestarray [BAP_buffer_size];
    byte serviceNumbers;  
    
    // get chosen service Numbers
    serviceNumbers = getValue(env_FSG_SSN_VoiceMailbox);
    serviceNumbers += getValue(env_FSG_SSN_InfoCall) << 1;
    serviceNumbers += getValue(env_FSG_SSN_ServiceCall) << 2;
    serviceNumbers += getValue(env_FSG_SSN_EmergencyCall) << 3;

  	for(i=0;i<BAP_buffer_size;++i)
  		requestarray [i]=0;
 
    requestarray[0] = LSGID_Telephone;	              //LSG-ID
		requestarray[1] = FctID_SupportedServiceNumbers;  //Fct.-ID
		requestarray[2] = Data_REQ;	
    requestarray[3] = serviceNumbers;
    requestarray[4] = 0x00;
    requestarray[5] = 0x00;
    requestarray[6] = 0x00;

    set_status_requestbuffer(requestarray, 6, Bap_ByteSequence);
  }
}

on envVar env_FSG_FL_DataSource
{
    if (getvalue(this) ==TEL_DEFAULT_LIST)
    {
        FavoriteList_init_static();
        putvalue(env_FSG_FL_DataSource_file, empty_string);
        putvalue(env_FSG_FL_DataSource_result, empty_string);
    }
}

on envVar env_FSG_FL_reload //load external ReceptionList from *.csv
{
    if(getvalue(this) && getvalue(env_FSG_FL_DataSource) ==TEL_EXTERNAL_LIST)
	    FavoriteList_init_CSV();

    else if(getvalue(env_FSG_FL_DataSource) != TEL_EXTERNAL_LIST)
        putvalue(env_FSG_FL_DataSource_result,"not successful, select 'external *.csv'");
}

void FavoriteList_init_static()
{
    byte j, i, FavoriteListLine;

    //clear
    FavoriteListLine   =0;
    gFavoriteList_sum  =0;

	for(j=0;j<TEL_FAVORITELIST_ENTRIES;j++) 
	{
		gFavoriteList_Pos[j]                       =0;
        
    for(i=0;i<TEL_FAVORITE_PBNAME_LENGTH;i++)
	    gFavoriteList_PbName[j][i] =0;

    gFavoriteList_NumberType[j]                  =0;
    
    for(i=0;i<TEL_FAVORITE_TELNUMBER_LENGTH;i++)
	    gFavoriteList_TelNumber[j][i] =0;

    gFavoriteList_ListEntryValidInformation[j] =0;
	}
	  	
    //entry 0
	  gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x01;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_0",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_FAX;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_0",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 1
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x02;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_1",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_1",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 2
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x03;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_2",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MAINOFFICE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_2",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 3
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x04;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_3",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_3",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 4
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x05;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_4",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_4",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 5
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x06;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_5",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_5",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 6
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x07;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_6",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_6",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 7
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x08;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_7",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_7",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 8
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x09;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_8",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_8",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 9
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x0A;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_9",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_9",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 10
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x0B;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_10",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_10",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 11
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x0C;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_11",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_11",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 12
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x0D;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_12",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_12",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++;

    //entry 13
    gFavoriteList_ListEntryValidInformation[FavoriteListLine]     =TRUE;
    gFavoriteList_Pos [FavoriteListLine]                          =0x0E;
    strncpy(gFavoriteList_PbName [FavoriteListLine], "PbName_13",TEL_FAVORITE_PBNAME_LENGTH);
    gFavoriteList_NumberType[FavoriteListLine] = TEL_FAVORITE_NUMBERTYPE_MOBILE;
    strncpy(gFavoriteList_TelNumber [FavoriteListLine], "TelNumber_13",TEL_FAVORITE_TELNUMBER_LENGTH);
    FavoriteListLine++; 
    
    gFavoriteList_sum                    =FavoriteListLine;
    gFavoriteList_TotalNumListElements   =gFavoriteList_sum;
    putvalue(env_FSG_FL_TotalNumLE, gFavoriteList_TotalNumListElements);
}

FavoriteList_init_CSV () //Byte & file selection
{
  dword CSVfileHandle =0, ConfigFileHandle =0, i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
  char buffer_string[TEL_BUFFERSIZE], Path_CSV[TEL_BUFFERSIZE], Path_Config[TEL_BUFFERSIZE];
  byte FavoriteListLine =0, buffer_byte[TEL_BUFFERSIZE];
  char FavoriteList_Pos_string [TEL_FAVORITELIST_ENTRIES][TEL_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
  char FavoriteList_NumberType_string [TEL_FAVORITELIST_ENTRIES][TEL_TEXTLENGTH];   //help value ->"NumberType" is stored in the ASCII(UTF-8) code in the *.csv 

  if(getvalue(env_FSG_FL_DataSource) == TEL_EXTERNAL_LIST) //output data in write window "FSG FavoriteList"  
  {
    writeClear(gFavoriteList_writeWindow);
    writelineEx(gFavoriteList_writeWindow, 0,"*******External FavoriteList*******");
    
    //clear  
	  for(j=0;j<TEL_FAVORITELIST_ENTRIES;j++) 
	  {
		  gFavoriteList_Pos[j] = 0;
      for(i=0;i<TEL_FAVORITE_PBNAME_LENGTH;i++)
			  gFavoriteList_PbName[j][i] = 0;
      gFavoriteList_NumberType[j] = 0;
      for(i=0;i<TEL_FAVORITE_TELNUMBER_LENGTH;i++)
		  	gFavoriteList_TelNumber[j][i] = 0;
      gFavoriteList_ListEntryValidInformation[j] = 0;
	  }

    for(i=0;i<TEL_FILENAME_SIZE; i++) //clear "filename"
        gFavoriteList_CSV_filename[i] =0;       
    
    for(j=0;j<TEL_FAVORITELIST_ENTRIES; j++) //clear "buffer"
    {
      buffer_string[j]    =0;
      buffer_byte[j]      =0;

      for(i=0;i<TEL_TEXTLENGTH;i++) //clear help value
		  {
        FavoriteList_Pos_string[j][i]        =0;
        FavoriteList_NumberType_string[j][i]   =0;
      }
    }        

    i = 0; j = 0; FavoriteListLine = 0; current_CSV_line = 0; //reset values 
                  
    getvalue(env_FSG_FL_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
    
    //write("complete path *.csv: %s", Path_CSV); //debug
    
    i =0;

    while (Path_CSV[i] !=0) //scan "path"
    {
        if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
            count1++;                
        
        //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
        i++;
    }  
         
    i =0; j =0; //reset values

    while (Path_CSV[i] !=0) //seperate "path" and "filename"
    {
        if(count2==count1) //get filename after last "\"
        {              
            gFavoriteList_CSV_filename[j] =Path_CSV[i];
            j++;

            Path_CSV[i] =0;              
        }

        if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
            count2++;
                           
        i++;
    }

    putvalue(env_FSG_FL_DataSource_file, gFavoriteList_CSV_filename); //output current loaded *.csv-file on panel

    setFilePath(Path_CSV, 0); //set path for *.csv file

    CSVfileHandle = openFileRead(gFavoriteList_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

    if (CSVfileHandle!=0) //*.csv file access successful
    {
      //writelineEx(gCombinedNumbers_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gCombinedNumbers_CSV_filename);    //output result  
      
      putvalue(env_FSG_FL_DataSource_result, "successful");   //output result on panel                      
      
      Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
                    
      for (i=0; i<Num_of_csv_byte; i++) //copy data into "CombinedNumbers"
      {      
        if (buffer_byte[i] != 0x3B) //read data if no ";" is detected
        {
          if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in CombinedNumbers) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
          {
            if(current_CSV_line>0 && FavoriteListLine<TEL_FAVORITELIST_ENTRIES) //ignore first line in *.csv file
            {   
              //transform 'string' to 'long' for "POS", "NumberType"
              gFavoriteList_Pos[FavoriteListLine]         = atol(FavoriteList_Pos_string[FavoriteListLine]);
              gFavoriteList_NumberType[FavoriteListLine]  = atol(FavoriteList_NumberType_string[FavoriteListLine]);
              gFavoriteList_ListEntryValidInformation[FavoriteListLine]  =TRUE;                  
              FavoriteListLine++; // -> next line in *.csv (next record element)
            }

            current_CSV_line++; //next line in *.csv file
            element =0; //start at 'POS' (first record element of "array data")
            j=0; //reset value
          }
                      
          else if(current_CSV_line>0 && FavoriteListLine<TEL_FAVORITELIST_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
          {
            switch (element)
            {
              case 0: //POS
                FavoriteList_Pos_string[FavoriteListLine][j] =buffer_byte[i];
                j++;
                break;
              case 1: //PbName
                gFavoriteList_PbName[FavoriteListLine][j] =buffer_byte[i];
                j++; 
               break;              
              case 2: //CallMode                                    
                FavoriteList_NumberType_string[FavoriteListLine][j] =buffer_byte[i];                                   
                j++;
               break;              
              case 3: //TelNumber
                gFavoriteList_TelNumber[FavoriteListLine][j] =buffer_byte[i];
                j++; 
                break;
              default:
                break;
            }
          }                               
        }
                               
        else  // ";" is detected ->next record element of "array data"
        {                                          
            element++;
            j=0; //reset value  
        }                                              
  
      }         
          
      gFavoriteList_TotalNumListElements = gFL_CSVtotalElem = gFavoriteList_sum =FavoriteListLine; //get "total number of list elements"
      
      putvalue(env_FSG_FL_TotalNumLE, gFavoriteList_TotalNumListElements);

      //writelineEx(gCombinedNumbers_writeWindow, 0, "");

      //writelineEx(gCombinedNumbers_writeWindow, 0,"Anzahl der Listenelemente: %d", gCombinedNumbers_sum); //output total number of list elements

      //writelineEx(gCombinedNumbers_writeWindow, 0, "");

      if(fileClose (CSVfileHandle) !=0) //close *.csv file
          writelineEx(gFavoriteList_writeWindow, 0,"Datei '%s' geschlossen", gFavoriteList_CSV_filename); //output result
           
      else
          writelineEx(gFavoriteList_writeWindow, 0,"Fehler beim Schlie?n der Datei '%s'", gFavoriteList_CSV_filename);//output result
    }

    else //*.csv file access not successful
    {
        writelineEx(gFavoriteList_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gFavoriteList_CSV_filename); //output result
        
        putvalue(env_FSG_FL_DataSource_result,"not successful"); //output result
    }
	
	for( i = 0; i < TEL_FAVORITELIST_ENTRIES; i++ )
		{
            gFavoriteList_Pos_insDel[i] [0] = 0;
			gFavoriteList_Pos_insDel[i] [1] = 0;
		}
		

        //IssueList #76 - MR49870 : CN
         for(i =0; i<gFavoriteList_TotalNumListElements; i++)
		gFavoriteList_Pos_insDel[i] [0] =gFavoriteList_Pos[i];

        if (getValue(env_FSG_FL_insert_UPD_button) == 0x00)
        gFL_totalDELctr = 0;
  }
}

byte FavoriteList_nextvalidLine (byte current_FavoriteListLine, byte direction)
{
    word next_FavoriteListLine;
    int i;
         
    //init lokal variables
    next_FavoriteListLine    =0;
    i                           =0;

    //search next "list entry"
    if(((gFavoriteList_sum-1)==current_FavoriteListLine && FORWARD ==direction) || (0 ==current_FavoriteListLine && BACKWARD ==direction))	//last-/fist-element of array reached
	    next_FavoriteListLine =0xFF;
  	else
  	{
  			next_FavoriteListLine =current_FavoriteListLine +1-2*direction;       //increment or decrement array-line (depends on direction);
        if(0 ==gFavoriteList_ListEntryValidInformation[next_FavoriteListLine])	// check if next element is "valid"
  			    next_FavoriteListLine =0xff; 					
  	}
    return(next_FavoriteListLine);
}

//IssueList #206
//-- Function 0x3C - FavoriteList --------------------------------------------------
//-- Request call of function 0x3C - FavoriteList
void FavoriteList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{
    int  i;
  byte shift, direction, transmitpos, indexsize, current_element;
  dword requestarray [BAP_buffer_size], Offset;
  word FavoriteListLine;
  
  byte telephoneListDelFlg;

  // Init local variables. 
  for(i=0;i<BAP_buffer_size;i++)
    requestarray [i]=0;

  shift               =0;
  direction           =0;
  transmitpos         =0;
  indexsize           =0;
  FavoriteListLine =0;
  current_element     =0;
  Offset              =0;

  // decode "mode-byte"
  shift       =mode &0x01;
  direction   =(mode &0x02)/0x02;
  transmitpos =(mode &0x04)/0x04;
  indexsize   =(mode &0x08)/0x08;

  // Handle request.
  requestarray[0] =LSGID_Telephone;				//LSG-ID
  requestarray[1] =FctID_FavoriteList;		//Fct.-ID
  requestarray[2] =request;                   //request type
  Offset =3;
  
  if( elements == 0 )
	{
	    transmitpos = 0;
		mode &= 0xFB;
	}

  switch(request)
	{
		case Changed_REQ:      
            /***ArrayHeader***/
			requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
			Offset++;
      if(indexsize)
      {
        requestarray[Offset] =requested_startelement &0xff;
        Offset++;
        requestarray[Offset] =(requested_startelement &0xff00) /0x100;
        Offset++;
        
        requestarray[Offset] =elements &0xff;
        Offset++;
        requestarray[Offset] =(elements &0xff00) /0x100;
        Offset++;
      }
      else
      {
        requestarray[Offset] =requested_startelement;
        Offset++;  
        requestarray[Offset] =elements;
        Offset++;
      }
      
      FavoriteListLine =startelement;
      if(@env_FSG_CN_CA_switch) //if "ArrayHeader + Data"
	  {
        //copy data
        switch(recordaddress)
			  {
                    case 0: //complete record
                            while(current_element <elements)
                            {
                                if(FavoriteListLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone FavoriteList_Request: invalid FavoriteListLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gFavoriteList_Pos[FavoriteListLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gFavoriteList_Pos[FavoriteListLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gFavoriteList_Pos[FavoriteListLine];
                                            Offset++;
                                        }
                                    }
                                                                                              
                                    //PbName
                                    requestarray[Offset] =strlen(gFavoriteList_PbName[FavoriteListLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gFavoriteList_PbName[FavoriteListLine]);i++)
                          			    {
      			                            requestarray[Offset] =gFavoriteList_PbName[FavoriteListLine][i];	
      			                            Offset++;
      			                        }
                                
                                    //NumberType
                                    requestarray[Offset] = gFavoriteList_NumberType[FavoriteListLine];
                                    Offset++;

                                    //TelNumber
                                    requestarray[Offset] =strlen(gFavoriteList_TelNumber[FavoriteListLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gFavoriteList_TelNumber[FavoriteListLine]);i++)
                          			    {
      			                            requestarray[Offset] =gFavoriteList_TelNumber[FavoriteListLine][i];	
      			                            Offset++;
      			                        }
                                }
                                current_element++;
                                FavoriteListLine =FavoriteList_nextvalidLine(FavoriteListLine, direction);
                            }//end while
                     break;

                    case 1: //PbName, NumberType
                            while(current_element <elements)
                            {
                                if(FavoriteListLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone FavoriteList_Request: invalid FavoriteListLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gFavoriteList_Pos[FavoriteListLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gFavoriteList_Pos[FavoriteListLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gFavoriteList_Pos[FavoriteListLine];
                                            Offset++;
                                        }
                                    }
                                                                                              
                                    //PbName
                                    requestarray[Offset] =strlen(gFavoriteList_PbName[FavoriteListLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gFavoriteList_PbName[FavoriteListLine]);i++)
                          			    {
      			                            requestarray[Offset] =gFavoriteList_PbName[FavoriteListLine][i];	
      			                            Offset++;
      			                        }
                                
                                    // NumberType
                                    requestarray[Offset] = gFavoriteList_NumberType[FavoriteListLine];
                                    Offset++;
                                }
                                current_element++;
                                FavoriteListLine =FavoriteList_nextvalidLine(FavoriteListLine, direction);
                            }//end while
                     break;

                    case 2: //Name, TelNumber
                            while(current_element <elements)
                            {
                                if(FavoriteListLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone FavoriteList_Request: invalid FavoriteListLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gFavoriteList_Pos[FavoriteListLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gFavoriteList_Pos[FavoriteListLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gFavoriteList_Pos[FavoriteListLine];
                                            Offset++;
                                        }
                                    }
                                    
                                    //PbName
                                    requestarray[Offset] =strlen(gFavoriteList_PbName[FavoriteListLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gFavoriteList_PbName[FavoriteListLine]);i++)
                          			    {
      			                            requestarray[Offset] =gFavoriteList_PbName[FavoriteListLine][i];	
      			                            Offset++;
      			                        }

                                    //TelNumber
                                    requestarray[Offset] =strlen(gFavoriteList_TelNumber[FavoriteListLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gFavoriteList_TelNumber[FavoriteListLine]);i++)
                          			    {
      			                            requestarray[Offset] =gFavoriteList_TelNumber[FavoriteListLine][i];	
      			                            Offset++;
      			                        }
                                }
                                current_element++;
                                FavoriteListLine =FavoriteList_nextvalidLine(FavoriteListLine, direction);
                            }//end while
                     break;

                    case 15: //Pos
                            while(current_element <elements)
                            {
                                if(FavoriteListLine ==0xff) //Invalid "list entry"
                                {
                                    write("FSG-Telephone FavoriteList_Request: invalid FavoriteListLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gFavoriteList_Pos[FavoriteListLine] &0xFF);
                                            Offset++;
                                            requestarray[Offset] =((gFavoriteList_Pos[FavoriteListLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gFavoriteList_Pos[FavoriteListLine];
                                            Offset++;
                                        }
                                    }
                                }
                                current_element++;
                                FavoriteListLine =FavoriteList_nextvalidLine(FavoriteListLine, direction);
                            }//end while                        
                     break;

                    default:
        					    write("FSG-Telephone FavoriteList_Request: invalid recordaddress %d", recordaddress);
        				    break;
                } //end switch "recordaddress"
            }				
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
        break; //end Changed_REQ   
  case Data_REQ:
    requestarray[Offset] =((gFavoriteList_ASGID *0x10) &0xF0) +(gFavoriteList_TAID &0x0F);	
    Offset++;
    requestarray[Offset] =gFavoriteList_TotalNumListElements;	
    Offset++;

          /***ArrayHeader***/
  	requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
  	Offset++;
    if(indexsize)
    {
      requestarray[Offset] =requested_startelement &0xff;
      Offset++;
      requestarray[Offset] =(requested_startelement &0xff00) /0x100;
      Offset++;
      
      requestarray[Offset] =elements &0xff;
      Offset++;
      requestarray[Offset] =(elements &0xff00) /0x100;
      Offset++;
    }
    else
    {
      requestarray[Offset] =requested_startelement;
      Offset++;  
      requestarray[Offset] =elements;
      Offset++;
    }
              
    FavoriteListLine =startelement;
    
    //copy data
    switch(recordaddress)
		{
      case 0: //complete record
              while(current_element <elements)
              {
                  if(FavoriteListLine ==0xff) //Invalid "list entry"
                  {
                      write("FSG-Telephone FavoriteList_Request: invalid FavoriteListLine");
                      current_element =elements;
                  }
                  else //"list entry" valid
                  {   
                      /***Array Data***/
                      if (transmitpos) // Pos  ->Array position transmitted
                      {
					       //IssueList #76 - MR49870 : CN
						  //Updating the status array excluding the deleted elements
						  telephoneListDelFlg = 0x00;
						  telephoneListDelFlg = telephoneList_deleteCheck(gFavoriteList_Pos[FavoriteListLine],gFavoriteList_Pos_insDel,gFL_CSVtotalElem);
									
						  if (telephoneListDelFlg == 0x00)
						  {
                          if (indexsize)
                          {
                              requestarray[Offset] =(gFavoriteList_Pos[FavoriteListLine] &0xFF);
                              Offset++;
                              requestarray[Offset] =((gFavoriteList_Pos[FavoriteListLine]&0xFF00) /0x100);
                              Offset++;
                          }
                          else
                          {
                              requestarray[Offset] =gFavoriteList_Pos[FavoriteListLine];
                              Offset++;
                          }
						  }
                      }
                      if (telephoneListDelFlg == 0x00)
                      {					  
                      //PbName
                      requestarray[Offset] =strlen(gFavoriteList_PbName[FavoriteListLine]);
                      Offset++;
                      
                      for(i=0;i<strlen(gFavoriteList_PbName[FavoriteListLine]);i++)
                			{
                          requestarray[Offset] =gFavoriteList_PbName[FavoriteListLine][i];	
                          Offset++;
                      }
                      
                      // NumberType
                      requestarray[Offset] = gFavoriteList_NumberType[FavoriteListLine];
                      Offset++;

                      //TelNumber
                      requestarray[Offset] =strlen(gFavoriteList_TelNumber[FavoriteListLine]);
                      Offset++;
                      
                      for(i=0;i<strlen(gFavoriteList_TelNumber[FavoriteListLine]);i++)
                			{
                          requestarray[Offset] =gFavoriteList_TelNumber[FavoriteListLine][i];	
                          Offset++;
                      }
					  }
                  }
				  if (telephoneListDelFlg == 0x00)
                  current_element++;
                  FavoriteListLine =FavoriteList_nextvalidLine(FavoriteListLine, direction);
              }//end while
              set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
          break;

                case 1: //PbName, NumberType
                        while(current_element <elements)
                        {
                            if(FavoriteListLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone FavoriteList_Request: invalid FavoriteListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
								    //Updating the status array excluding the deleted elements
                                  telephoneListDelFlg = 0x00;
                                  telephoneListDelFlg = telephoneList_deleteCheck(gFavoriteList_Pos[FavoriteListLine],gFavoriteList_Pos_insDel,gFL_CSVtotalElem);
                                            
                                  if (telephoneListDelFlg == 0x00)
                                  {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteList_Pos[FavoriteListLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteList_Pos[FavoriteListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteList_Pos[FavoriteListLine];
                                        Offset++;
                                    }
									}
                                }
                                if (telephoneListDelFlg == 0x00)
                                {                                                              
                                //PbName
                                requestarray[Offset] =strlen(gFavoriteList_PbName[FavoriteListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gFavoriteList_PbName[FavoriteListLine]);i++)
                          			{
      			                        requestarray[Offset] =gFavoriteList_PbName[FavoriteListLine][i];	
      			                        Offset++;
      			                    }
                                
                                // NumberType
                                requestarray[Offset] = gFavoriteList_NumberType[FavoriteListLine];
                                Offset++;
								}
                            }
							if (telephoneListDelFlg == 0x00)
                            current_element++;
                            FavoriteListLine =FavoriteList_nextvalidLine(FavoriteListLine, direction);  
                        }//end while
                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 2: //Name, TelNumber
                        while(current_element <elements)
                        {
                            if(FavoriteListLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone FavoriteList_Request: invalid FavoriteListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteList_Pos[FavoriteListLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteList_Pos[FavoriteListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteList_Pos[FavoriteListLine];
                                        Offset++;
                                    }
                                }
                                
                                //PbName
                                requestarray[Offset] =strlen(gFavoriteList_PbName[FavoriteListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gFavoriteList_PbName[FavoriteListLine]);i++)
                          			{
      			                        requestarray[Offset] =gFavoriteList_PbName[FavoriteListLine][i];	
      			                        Offset++;
      			                    }
                                                                                              
                                //TelNumber
                                requestarray[Offset] =strlen(gFavoriteList_TelNumber[FavoriteListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gFavoriteList_TelNumber[FavoriteListLine]);i++)
                          			{
      			                        requestarray[Offset] =gFavoriteList_TelNumber[FavoriteListLine][i];	
      			                        Offset++;
      			                    }
                            }
                            current_element++;
                            FavoriteListLine =FavoriteList_nextvalidLine(FavoriteListLine, direction);
                        }//end while
                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 15: //Pos
                        while(current_element <elements)
                        {
                            if(FavoriteListLine ==0xff) //Invalid "list entry"
                            {
                                write("FSG-Telephone FavoriteList_Request: invalid FavoriteListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
								    //Updating the status array excluding the deleted elements
                                  telephoneListDelFlg = 0x00;
                                  telephoneListDelFlg = telephoneList_deleteCheck(gFavoriteList_Pos[FavoriteListLine],gFavoriteList_Pos_insDel,gFL_CSVtotalElem);
                                            
                                  if (telephoneListDelFlg == 0x00)
                                  {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteList_Pos[FavoriteListLine] &0xFF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteList_Pos[FavoriteListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteList_Pos[FavoriteListLine];
                                        Offset++;
                                    }
								   }
                                }
                            }
							if (telephoneListDelFlg == 0x00)
                            current_element++;
                            FavoriteListLine =FavoriteList_nextvalidLine(FavoriteListLine, direction);
                        }//end while
                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                default:
        					write("FSG-Telephone FavoriteList_Request: invalid recordaddress %d", recordaddress);
        				 break;
            } //end switch "recordaddress"
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] =errorcode;
			      set_status_requestbuffer (requestarray, 4, Bap_Error);
         break; //end Error_REQ
    } //end switch "request"   
}

//IssueList #206
//-- Indication call of function 0x3C - FavoriteList
FavoriteList_Indication(dword indication_array[], byte indication, int datalength)
{
  // TODO
  byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
	word valid_startelement, requested_startelement, startelement, elementsRequested, Offset;
	int i;
	byte fl_InValidStartElemFlg;
	byte telephoneListDelFlg;
    word validStartElem_plusElem;
	
	valid_elements = 0;
	
	gFavoriteList_ASGID = (indication_array[3] & 0xF0) / 0x10;
	gFavoriteList_TAID = (indication_array[3] & 0x0F);
	
	// decode mode byte
	mode = (indication_array[4] & 0xF0) / 0x10;
	shift       =  mode & 0x01;
  direction   = (mode & 0x02) / 0x02;
  transmitpos = (mode & 0x04) / 0x04;
  indexsize   = (mode & 0x08) / 0x08; 
	
	// get record byte
	recordaddress = gBAP_Indication[4] & 0x0F;
	
	// detect startelement and number of elements depending on mode.indexsize
	if(indexsize)	// 16 bit adresses
	{
		startelement = gBAP_Indication[5];
		startelement+= gBAP_Indication[6] * 0x100;
		elementsRequested = gBAP_Indication[7];
		elementsRequested+= gBAP_Indication[8] * 0x100;
	}
	else	// 8 bit addresses
	{
		startelement = gBAP_Indication[5];
		elementsRequested = gBAP_Indication[6];
	}
	
	requested_startelement = startelement;
	
	transmitpos     =TRUE; 
	
	mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
			
	switch(gBAP_Indication[2])
	{
		case DataGet_IND:	// GetArray
			// TODO: send StatusArray
			// set startelement depending on mode.shift
			if(shift == TRUE)
				valid_startelement = startelement + 1;
			else
				valid_startelement = startelement;
				
				
			// count valid elements in favorite list depending on direction
			if(startelement == 0)
			{
				if(direction == FORWARD)
				{
					for(i = valid_startelement; i < elementsRequested; i++)
					{
						// check array-size-overflow 
						if(i >= TEL_FAVORITELIST_ENTRIES)
							i = elementsRequested;
							
						// check if array-element is valid
						if(gFavoriteList_ListEntryValidInformation[i] != 0)
							++valid_elements;
						else
							i = elementsRequested;
					}
					
				}	//-- else if(direction == FORWARD)
				else if(direction == BACKWARD)
				{
					for(i = TEL_FAVORITELIST_ENTRIES-1; i >= 0; --i)
					{
						// check if array-element is valid
						if(gFavoriteList_ListEntryValidInformation[i] != 0)
						{
								valid_startelement = i;
								i = 0;
						}
					}
					
					// check special cases
					if(valid_startelement == 0xFF)	// no valid startelement found
					{
						valid_startelement = startelement;
						valid_elements = 0;
					}
					else if(valid_startelement == 0)	// just 1 element available
						valid_elements = 1;					
					else if(valid_startelement < elementsRequested-1)	// more elements requested than available
					{				
						for(i = valid_startelement; i >= 0; --i)
						{		
							if(gFavoriteList_ListEntryValidInformation[i] != 0)
	    					++valid_elements;
	    				else
	    					i=0;
						}
					}
					else
					{
						for(i = valid_startelement; i > (valid_startelement-elementsRequested); --i)
						{		
							if(gFavoriteList_ListEntryValidInformation[i] != 0)
	    					++valid_elements;
	    				else
	    					i=0;
						}
					}
					
				}	//-- else if(direction == BACKWARD)
			}	//-- startelement == 0
			else	// startelement != 0
			{
			    fl_InValidStartElemFlg = 0;
	                for(i=0;i<gFL_CSVtotalElem;i++)
					{
                        if (startelement==gFavoriteList_Pos_insDel[i][0])
                        {
                            //check if Start is deleted then reply with 0 elements
                            if( gFavoriteList_Pos_insDel[i][1]==0x01)
                            {
                            valid_startelement  =startelement;
    						valid_elements      =0;
                            fl_InValidStartElemFlg = 1;
                            }
                        }
                    }
				if (fl_InValidStartElemFlg == 0x0)
				{
				// searching valid startelement
				for(i = 0; i < TEL_FAVORITELIST_ENTRIES; ++i)
				{
					if(gFavoriteList_Pos[i] == startelement)
					{
						if(shift == TRUE)
						{
							if(i != 0 || direction != BACKWARD)
								valid_startelement = i+1-2*direction;
							else if(i == 0 && direction == BACKWARD)
								valid_startelement = gFavoriteList_sum - 1;
							else if(i == 0 && direction == FORWARD)
								valid_startelement = 0;
						}
						else
							valid_startelement = i;
							
						i = TEL_FAVORITELIST_ENTRIES;	
					}
				}
				
				if(valid_startelement == 0xff)	// valid startelement not found
				{
					valid_startelement = startelement;
					valid_elements = 0;
				}
				else
				{
					//verify number of valid elements
        	if(direction == BACKWARD)
        	{
        		if(valid_startelement==0)	//only 1 element because valid startelement is on position 0
        			{
					telephoneListDelFlg = 0x00;
					telephoneListDelFlg = telephoneList_deleteCheck(gFavoriteList_Pos[0],gFavoriteList_Pos_insDel,gFL_CSVtotalElem );

				    if (telephoneListDelFlg == 0x00)
                                       
					valid_elements=1;
					}
        		
        		else if(elementsRequested > (valid_startelement+1))
        		{
        			for(i = valid_startelement; i >= 0; --i)
        			{
								// check if array-element is valid
        				if(gFavoriteList_ListEntryValidInformation[i] != 0)
        					++valid_elements;
        				else
        					i = 0;
        			}
        		}
        		else														//enougth array-elements available
        		{
        			for(i= valid_startelement; i > (valid_startelement-elementsRequested); --i)
        			{
								// check if array-element is valid
        				if(gFavoriteList_ListEntryValidInformation[i] != 0)	
        					++valid_elements;
        				else							
        					i = 0;
        			}
        		}
        	}	//-- if(direction == BACKWARD)
        	else
        	{
        		if((valid_startelement+elementsRequested)>=TEL_FAVORITELIST_ENTRIES)
        		{
        			for(i = valid_startelement; i < TEL_FAVORITELIST_ENTRIES; ++i)
        			{
        				// check if array-element is valid
        				if(gFavoriteList_ListEntryValidInformation[i])
						{
						telephoneListDelFlg = 0x00;
						telephoneListDelFlg = telephoneList_deleteCheck(gFavoriteList_Pos[i], gFavoriteList_Pos_insDel, gFL_CSVtotalElem );
                                        
						if (telephoneListDelFlg == 0x00 && valid_elements < elementsRequested)            
						valid_elements++;	
						}					
        				else									
        					i = TEL_FAVORITELIST_ENTRIES;
        			}
        		}
        		else
        		{
				    validStartElem_plusElem =valid_startelement+elementsRequested;
        			for(i = valid_startelement; i < validStartElem_plusElem; ++i)
        			{
        				// check if array-element is valid
        				if(gFavoriteList_ListEntryValidInformation[i])
                	    {
						telephoneListDelFlg = 0x00;
						telephoneListDelFlg = telephoneList_deleteCheck(gFavoriteList_Pos[i], gFavoriteList_Pos_insDel, gFL_CSVtotalElem );
                                        
						if (telephoneListDelFlg == 0x00)
							{
								if (valid_elements < elementsRequested) 
								valid_elements++;
							 }
							 else
							 {
								if (valid_elements < elementsRequested)
								 validStartElem_plusElem++;      //adjust the loop boundary based on number of deleted elements
							  }	
							
						}
        				else							
        					i = TEL_FAVORITELIST_ENTRIES;
        			}
        		}
        	}
					
				}	//-- valid_starelement != 0xff			
				
			}	//-- startelement != 0
			}
			mode = 0;
			mode = FavoriteList_buildModeByte(requested_startelement, valid_startelement, valid_elements, shift, direction, transmitpos, indexsize);
			
			// TODO: send StatusArray
			FavoriteList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
			break;
			
		case DataSetGet_IND:	// SetGetArray
			// TODO: fill Array with new values and send StatusArray
			break;
		case Error_IND:
			writelineEx(gError_Trace, 0, "FSG_Telepfhone FavoriteList_Indication: received error, errorcode:0x%x", indication_array[3]);
			break;
		default:
			writelineEx(gError_Trace, 0, "FSG_Telepfhone FavoriteList_Indication: invalid indication %d", indication_array[2]);
	    break;
	}
}

//MR 60899
on timer _tReleaseUpdate_buttons
{
    putValue(env_FSG_RegisterState_OK, 0x0); 
	putValue(env_FSG_NetworkProvider_OK, 0x0);
}

//MR 62005
on envVar env_FSG_CN_delete_size
{
    if (getValue(env_FSG_CN_delete_Auto)==0x01)
    {
       if (getValue(this))
       {
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_CN_delete_POS_8_A", FALSE);
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_CN_delete_POS_16_A", TRUE);
        }
       else
       {
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_CN_delete_POS_8_A", TRUE);
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_CN_delete_POS_16_A", FALSE);
        }
     }
}

//MR 62005
on envVar env_FSG_PB_delete_size
{
    if (getValue(env_FSG_PB_delete_Auto)==0x01)
    {
       if (getValue(this))
       {
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_8_A", FALSE);
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_16_A", TRUE);
        }
       else
       {
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_8_A", TRUE);
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_16_A", FALSE);
        }
     }
}

//MR62005
on envVar env_FSG_PB_delete_Auto
{

    if (getValue(this))
    {
        switch (getValue(env_FSG_PB_delete_size))
        {
        case 0: 
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_8_A", TRUE);
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_16_A", FALSE);
        break;

        case 1: 
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_8_A", FALSE);
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_16_A", TRUE);
        break;

        default: break;
        }
    }
    else
    {
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_8_A", FALSE);
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_delete_POS_16_A", FALSE);
    }
}

//MR62005
on envVar env_FSG_CN_delete_Auto
{

    if (getValue(this))
    {
        switch (getValue(env_FSG_CN_delete_size))
        {
        case 0: 
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_delete_POS_8_A", TRUE);
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_delete_POS_16_A", FALSE);
        break;

        case 1: 
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_delete_POS_8_A", FALSE);
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_delete_POS_16_A", TRUE);
        break;

        default: break;
        }
    }
    else
    {
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_delete_POS_8_A", FALSE);
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_delete_POS_16_A", FALSE);
    }
}

//MR62005
on envVar env_FSG_CN_insert_Auto
{

    if (getValue(this))
    {
        switch (getValue(env_FSG_CN_insert_size))
        {
        case 0: 
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_insert_POS_8_A", TRUE);
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_insert_POS_16_A", FALSE);
        break;

        case 1: 
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_insert_POS_8_A", FALSE);
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_insert_POS_16_A", TRUE);
        break;

        default: break;
        }
    }
    else
    {
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_insert_POS_8_A", FALSE);
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_CN_insert_POS_16_A", FALSE);
    }
}

//MR 62005
on envVar env_FSG_CN_insert_size
{
    if (getValue(env_FSG_CN_insert_Auto)==0x01)
    {
       if (getValue(this))
       {
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_CN_insert_POS_8_A", FALSE);
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_CN_insert_POS_16_A", TRUE);
        }
       else
       {
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_CN_insert_POS_8_A", TRUE);
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_CN_insert_POS_16_A", FALSE);
        }
     }
}

//MR62005
on envVar env_FSG_PB_insert_Auto
{

    if (getValue(this))
    {
        switch (getValue(env_FSG_PB_insert_size))
        {
        case 0: 
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_8_A", TRUE);
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_16_A", FALSE);
        break;

        case 1: 
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_8_A", FALSE);
        enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_16_A", TRUE);
        break;

        default: break;
        }
    }
    else
    {
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_8_A", FALSE);
    enableControl("FSG-Telephone_Phonebook_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_16_A", FALSE);
    }
}

//MR 62005
on envVar env_FSG_PB_insert_size
{
    if (getValue(env_FSG_PB_insert_Auto)==0x01)
    {
       if (getValue(this))
       {
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_8_A", FALSE);
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_16_A", TRUE);
        }
       else
       {
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_8_A", TRUE);
        enableControl("FSG-Telephone_CombinedNumbers_INSERT_DELETE", "Env:env_FSG_PB_insert_POS_16_A", FALSE);
        }
     }
}

