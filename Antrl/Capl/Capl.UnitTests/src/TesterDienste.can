/*@@var:*/
variables
{
byte debug=0;
byte tx_buffer[42];
byte rx_buffer[200];
byte SegmentedBuffer[1018];	//Segmented response can be 1018 Data bytes long
int SegmentedIndex=0;

const byte HEADER_KS_VERSION = 0x12;

byte bTPTargetLength;
byte tx_repeat;
byte bTxRequestPending;
byte TP_RxData_ready=0;
byte EcuIdent=0;

//Variablen für den Code Kanalaufbau zur Komponente
long TP_Target; //TP-Zieladresse des SG, in welches der Schlüssel

char cTPTarget[4]={0x00,0x00,0x00,0x00};
char cTempString[6]="0x000";  //Temporärer Buffer, um einen Hexadzimalen String zu erzeugen, der mit der Funktion atol in einen Bytewert umgewandelt werden kann.

long n; 					 //eingebracht werden soll.

int tx_len;
int status=0;
int oldstatus=0;
int IdenticalStateCounter=0;

byte Aktion;	//0: keine definierte Aktion
				//1: Auslesen der unterstützten Funktionen 010C
				//2: Fehlerspeicher im SG lesen
				//3: Fehlerspeicher im SG löschen
				//4: IKA-Key-Download zum SG, Service 2e
				//5: GFA-Key-Download zum SG, Service 2e
				//6: IKA Authentifikation durchführen (vollständig)
				
				//8: FAZIT-Identification-String auslesen
				   
				//40: Softwareversion auslesen
				//41: Key Download Starten und gleichzeitig eine Authentifizierung durchführen.
				//50: Key Download Starten und gleichzeitig eine unvollständige IKA durchführen.
				//60: Messwerteblöcke im Gateway lesen, die den Status des KS wiederspiegeln 
				//70: Auslesen der unterstützten Funktionen 010B

				//71: Auslesen der aktuellen KS Daten (Read Data By Identifier
				//72: Auslesen des Errorcounters
				//73: Schreiben des Errorcounters 2e
				//74: IKA-Key-Download zum SG, Service 3b
				//75: GFA-Key-Download zum SG, Service 3b
				//76: Schreiben des Errorcounters 3b
				//77: Auslesen der Softwareversion der KSB
				//80: Betriebsspannung Messen
				//81: FAZIT Identification String lesen
				//82: Selektiver Stellgliedtest zum Setzten des Errorcounters auf ECLimit
				//83: SSWVersion lesen (Standardsoftware Version)
				//90: VWApplicationSoftwareNumber
        		//91: VWApplicationSoftwareVersionNumber 
        		//92: VWEcuHardwareVersionNumber
				//95: Service 22 mit beliebigen Parametern
				
				//100: Auslesen der Checksumme mit Service 22 02 F9


//Variablen für unterstützte Funktionen
int i;


//Variablen für Fehlerspeicher lesen und auswerten
int index;


//Variablen für den Key-Download
char cKey[80]; //Puffer für einen Key aus der Offline-Maske Fazit als 68-Zeichen String: Achtung: String ist Nullterminiert, deshalb muss ein Zeichen mehr reserviert werden
byte bKey[34]; //Puffer für einen Key aus der Offline-Maske Fazit als 34-Byte Wert
byte bKeyLength;  //Speichert die Länge des eingegebenen Downloadcontainers
byte tx_buffer_index;

//Variablen für Authentifikation

byte plain[16]=     {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};          // inputbuffer for encryption
byte dest[16];           // result buffer for encryption

char cKey_Verify[80]="df3026994fc8e9ad4fdbd2472a448d4389a502395217185890d5384eb8f8f5e60000"; //Verifiaktionsdatensatz für alle Komponenten gleich

//Variablen für das Bestimmen der erweiterten Steuergeräte Identifikation
char EcuSerialNumber[24];  //BaugruppenSeriennummer
char SoftwareVersion[5];   //SoftwareVersion
char SSWVersion[9]="00.00.00";	   //SSW Version
	
char KSBVersion[9]="00.00.00"; 
char KSBVersionDefault[9]="00.00.00"; 

long TP_TxData_sent=0;


msTimer t_Tx;
msTimer t_Test;

//Variablen für den Verzug des Schlüsseldownloads während einer IKA

msTimer t_VerzugKeyDown;
int msVerzugKeyDown=0; //Verzugszeit in Millisekunden


  //Variables for OSEK TP-Communication
  
  char gECU[10] = "Node A";

  // 0: EnvVariables; 1: Dll (either INI or DBC Attributes)

  int gInitFromDLL=1; 

  const int cRxSize = 4098;
  byte gRxDataBuffer[cRxSize];

  const int cTxSize = 4096;
  byte gTxDataBuffer[cTxSize];

  char cCaplRxStrBuffer[4098];
   
  byte gAddressingMode;

  // dummy must be used for PutValue(EvSendData_1,..)

  byte gClearData[10];

  int OsekTlTxId=0;	

  byte LockValue=0;	
   
  byte NumberOfDTCs;

  byte LengthOfUDSResponse=0;

  char Service22Response[100]="";   

  char SoftwareTeileNummer[12]="";
  char VWApplicationSoftwareVersionNumber[5]="";	
  char HardwareVersion[5]="";		


  char Service22Parameters[7]="";	
  char Service22ParametersTemp[9]="0x";
  
  byte ServiceLength;
  long ConvertedValue;
  
  long ReadCheckSum=0;

byte crc32tab2[1024] = {
    0x00, 0x00, 0x00, 0x00, 0x77, 0x07, 0x30, 0x96, 0xEE, 0x0E, 
    0x61, 0x2C, 0x99, 0x09, 0x51, 0xBA, 0x07, 0x6D, 0xC4, 0x19, 
    0x70, 0x6A, 0xF4, 0x8F, 0xE9, 0x63, 0xA5, 0x35, 0x9E, 0x64, 
    0x95, 0xA3, 0x0E, 0xDB, 0x88, 0x32, 0x79, 0xDC, 0xB8, 0xA4, 
    0xE0, 0xD5, 0xE9, 0x1E, 0x97, 0xD2, 0xD9, 0x88, 0x09, 0xB6, 
    0x4C, 0x2B, 0x7E, 0xB1, 0x7C, 0xBD, 0xE7, 0xB8, 0x2D, 0x07, 
    0x90, 0xBF, 0x1D, 0x91, 0x1D, 0xB7, 0x10, 0x64, 0x6A, 0xB0, 
    0x20, 0xF2, 0xF3, 0xB9, 0x71, 0x48, 0x84, 0xBE, 0x41, 0xDE, 
    0x1A, 0xDA, 0xD4, 0x7D, 0x6D, 0xDD, 0xE4, 0xEB, 0xF4, 0xD4, 
    0xB5, 0x51, 0x83, 0xD3, 0x85, 0xC7, 0x13, 0x6C, 0x98, 0x56, 
    0x64, 0x6B, 0xA8, 0xC0, 0xFD, 0x62, 0xF9, 0x7A, 0x8A, 0x65, 
    0xC9, 0xEC, 0x14, 0x01, 0x5C, 0x4F, 0x63, 0x06, 0x6C, 0xD9, 
    0xFA, 0x0F, 0x3D, 0x63, 0x8D, 0x08, 0x0D, 0xF5, 0x3B, 0x6E, 
    0x20, 0xC8, 0x4C, 0x69, 0x10, 0x5E, 0xD5, 0x60, 0x41, 0xE4, 
    0xA2, 0x67, 0x71, 0x72, 0x3C, 0x03, 0xE4, 0xD1, 0x4B, 0x04, 
    0xD4, 0x47, 0xD2, 0x0D, 0x85, 0xFD, 0xA5, 0x0A, 0xB5, 0x6B, 
    0x35, 0xB5, 0xA8, 0xFA, 0x42, 0xB2, 0x98, 0x6C, 0xDB, 0xBB, 
    0xC9, 0xD6, 0xAC, 0xBC, 0xF9, 0x40, 0x32, 0xD8, 0x6C, 0xE3, 
    0x45, 0xDF, 0x5C, 0x75, 0xDC, 0xD6, 0x0D, 0xCF, 0xAB, 0xD1, 
    0x3D, 0x59, 0x26, 0xD9, 0x30, 0xAC, 0x51, 0xDE, 0x00, 0x3A, 
    0xC8, 0xD7, 0x51, 0x80, 0xBF, 0xD0, 0x61, 0x16, 0x21, 0xB4, 
    0xF4, 0xB5, 0x56, 0xB3, 0xC4, 0x23, 0xCF, 0xBA, 0x95, 0x99, 
    0xB8, 0xBD, 0xA5, 0x0F, 0x28, 0x02, 0xB8, 0x9E, 0x5F, 0x05, 
    0x88, 0x08, 0xC6, 0x0C, 0xD9, 0xB2, 0xB1, 0x0B, 0xE9, 0x24, 
    0x2F, 0x6F, 0x7C, 0x87, 0x58, 0x68, 0x4C, 0x11, 0xC1, 0x61, 
    0x1D, 0xAB, 0xB6, 0x66, 0x2D, 0x3D, 0x76, 0xDC, 0x41, 0x90, 
    0x01, 0xDB, 0x71, 0x06, 0x98, 0xD2, 0x20, 0xBC, 0xEF, 0xD5, 
    0x10, 0x2A, 0x71, 0xB1, 0x85, 0x89, 0x06, 0xB6, 0xB5, 0x1F, 
    0x9F, 0xBF, 0xE4, 0xA5, 0xE8, 0xB8, 0xD4, 0x33, 0x78, 0x07, 
    0xC9, 0xA2, 0x0F, 0x00, 0xF9, 0x34, 0x96, 0x09, 0xA8, 0x8E, 
    0xE1, 0x0E, 0x98, 0x18, 0x7F, 0x6A, 0x0D, 0xBB, 0x08, 0x6D, 
    0x3D, 0x2D, 0x91, 0x64, 0x6C, 0x97, 0xE6, 0x63, 0x5C, 0x01, 
    0x6B, 0x6B, 0x51, 0xF4, 0x1C, 0x6C, 0x61, 0x62, 0x85, 0x65, 
    0x30, 0xD8, 0xF2, 0x62, 0x00, 0x4E, 0x6C, 0x06, 0x95, 0xED, 
    0x1B, 0x01, 0xA5, 0x7B, 0x82, 0x08, 0xF4, 0xC1, 0xF5, 0x0F, 
    0xC4, 0x57, 0x65, 0xB0, 0xD9, 0xC6, 0x12, 0xB7, 0xE9, 0x50, 
    0x8B, 0xBE, 0xB8, 0xEA, 0xFC, 0xB9, 0x88, 0x7C, 0x62, 0xDD, 
    0x1D, 0xDF, 0x15, 0xDA, 0x2D, 0x49, 0x8C, 0xD3, 0x7C, 0xF3, 
    0xFB, 0xD4, 0x4C, 0x65, 0x4D, 0xB2, 0x61, 0x58, 0x3A, 0xB5, 
    0x51, 0xCE, 0xA3, 0xBC, 0x00, 0x74, 0xD4, 0xBB, 0x30, 0xE2,
    0x4A, 0xDF, 0xA5, 0x41, 0x3D, 0xD8, 0x95, 0xD7, 0xA4, 0xD1, 
    0xC4, 0x6D, 0xD3, 0xD6, 0xF4, 0xFB, 0x43, 0x69, 0xE9, 0x6A, 
    0x34, 0x6E, 0xD9, 0xFC, 0xAD, 0x67, 0x88, 0x46, 0xDA, 0x60, 
    0xB8, 0xD0, 0x44, 0x04, 0x2D, 0x73, 0x33, 0x03, 0x1D, 0xE5, 
    0xAA, 0x0A, 0x4C, 0x5F, 0xDD, 0x0D, 0x7C, 0xC9, 0x50, 0x05, 
    0x71, 0x3C, 0x27, 0x02, 0x41, 0xAA, 0xBE, 0x0B, 0x10, 0x10, 
    0xC9, 0x0C, 0x20, 0x86, 0x57, 0x68, 0xB5, 0x25, 0x20, 0x6F, 
    0x85, 0xB3, 0xB9, 0x66, 0xD4, 0x09, 0xCE, 0x61, 0xE4, 0x9F,
    0x5E, 0xDE, 0xF9, 0x0E, 0x29, 0xD9, 0xC9, 0x98, 0xB0, 0xD0, 
    0x98, 0x22, 0xC7, 0xD7, 0xA8, 0xB4, 0x59, 0xB3, 0x3D, 0x17, 
    0x2E, 0xB4, 0x0D, 0x81, 0xB7, 0xBD, 0x5C, 0x3B, 0xC0, 0xBA, 
    0x6C, 0xAD, 0xED, 0xB8, 0x83, 0x20, 0x9A, 0xBF, 0xB3, 0xB6, 
    0x03, 0xB6, 0xE2, 0x0C, 0x74, 0xB1, 0xD2, 0x9A, 0xEA, 0xD5, 
    0x47, 0x39, 0x9D, 0xD2, 0x77, 0xAF, 0x04, 0xDB, 0x26, 0x15, 
    0x73, 0xDC, 0x16, 0x83, 0xE3, 0x63, 0x0B, 0x12, 0x94, 0x64, 
    0x3B, 0x84, 0x0D, 0x6D, 0x6A, 0x3E, 0x7A, 0x6A, 0x5A, 0xA8,
    0xE4, 0x0E, 0xCF, 0x0B, 0x93, 0x09, 0xFF, 0x9D, 0x0A, 0x00, 
    0xAE, 0x27, 0x7D, 0x07, 0x9E, 0xB1, 0xF0, 0x0F, 0x93, 0x44, 
    0x87, 0x08, 0xA3, 0xD2, 0x1E, 0x01, 0xF2, 0x68, 0x69, 0x06, 
    0xC2, 0xFE, 0xF7, 0x62, 0x57, 0x5D, 0x80, 0x65, 0x67, 0xCB, 
    0x19, 0x6C, 0x36, 0x71, 0x6E, 0x6B, 0x06, 0xE7, 0xFE, 0xD4, 
    0x1B, 0x76, 0x89, 0xD3, 0x2B, 0xE0, 0x10, 0xDA, 0x7A, 0x5A, 
    0x67, 0xDD, 0x4A, 0xCC, 0xF9, 0xB9, 0xDF, 0x6F, 0x8E, 0xBE, 
    0xEF, 0xF9, 0x17, 0xB7, 0xBE, 0x43, 0x60, 0xB0, 0x8E, 0xD5,
    0xD6, 0xD6, 0xA3, 0xE8, 0xA1, 0xD1, 0x93, 0x7E, 0x38, 0xD8, 
    0xC2, 0xC4, 0x4F, 0xDF, 0xF2, 0x52, 0xD1, 0xBB, 0x67, 0xF1, 
    0xA6, 0xBC, 0x57, 0x67, 0x3F, 0xB5, 0x06, 0xDD, 0x48, 0xB2, 
    0x36, 0x4B, 0xD8, 0x0D, 0x2B, 0xDA, 0xAF, 0x0A, 0x1B, 0x4C, 
    0x36, 0x03, 0x4A, 0xF6, 0x41, 0x04, 0x7A, 0x60, 0xDF, 0x60, 
    0xEF, 0xC3, 0xA8, 0x67, 0xDF, 0x55, 0x31, 0x6E, 0x8E, 0xEF, 
    0x46, 0x69, 0xBE, 0x79, 0xCB, 0x61, 0xB3, 0x8C, 0xBC, 0x66, 
    0x83, 0x1A, 0x25, 0x6F, 0xD2, 0xA0, 0x52, 0x68, 0xE2, 0x36,
    0xCC, 0x0C, 0x77, 0x95, 0xBB, 0x0B, 0x47, 0x03, 0x22, 0x02, 
    0x16, 0xB9, 0x55, 0x05, 0x26, 0x2F, 0xC5, 0xBA, 0x3B, 0xBE, 
    0xB2, 0xBD, 0x0B, 0x28, 0x2B, 0xB4, 0x5A, 0x92, 0x5C, 0xB3, 
    0x6A, 0x04, 0xC2, 0xD7, 0xFF, 0xA7, 0xB5, 0xD0, 0xCF, 0x31, 
    0x2C, 0xD9, 0x9E, 0x8B, 0x5B, 0xDE, 0xAE, 0x1D, 0x9B, 0x64, 
    0xC2, 0xB0, 0xEC, 0x63, 0xF2, 0x26, 0x75, 0x6A, 0xA3, 0x9C, 
    0x02, 0x6D, 0x93, 0x0A, 0x9C, 0x09, 0x06, 0xA9, 0xEB, 0x0E, 
    0x36, 0x3F, 0x72, 0x07, 0x67, 0x85, 0x05, 0x00, 0x57, 0x13,
    0x95, 0xBF, 0x4A, 0x82, 0xE2, 0xB8, 0x7A, 0x14, 0x7B, 0xB1, 
    0x2B, 0xAE, 0x0C, 0xB6, 0x1B, 0x38, 0x92, 0xD2, 0x8E, 0x9B, 
    0xE5, 0xD5, 0xBE, 0x0D, 0x7C, 0xDC, 0xEF, 0xB7, 0x0B, 0xDB, 
    0xDF, 0x21, 0x86, 0xD3, 0xD2, 0xD4, 0xF1, 0xD4, 0xE2, 0x42, 
    0x68, 0xDD, 0xB3, 0xF8, 0x1F, 0xDA, 0x83, 0x6E, 0x81, 0xBE, 
    0x16, 0xCD, 0xF6, 0xB9, 0x26, 0x5B, 0x6F, 0xB0, 0x77, 0xE1, 
    0x18, 0xB7, 0x47, 0x77, 0x88, 0x08, 0x5A, 0xE6, 0xFF, 0x0F, 
    0x6A, 0x70, 0x66, 0x06, 0x3B, 0xCA, 0x11, 0x01, 0x0B, 0x5C,
    0x8F, 0x65, 0x9E, 0xFF, 0xF8, 0x62, 0xAE, 0x69, 0x61, 0x6B, 
    0xFF, 0xD3, 0x16, 0x6C, 0xCF, 0x45, 0xA0, 0x0A, 0xE2, 0x78, 
    0xD7, 0x0D, 0xD2, 0xEE, 0x4E, 0x04, 0x83, 0x54, 0x39, 0x03, 
    0xB3, 0xC2, 0xA7, 0x67, 0x26, 0x61, 0xD0, 0x60, 0x16, 0xF7, 
    0x49, 0x69, 0x47, 0x4D, 0x3E, 0x6E, 0x77, 0xDB, 0xAE, 0xD1, 
    0x6A, 0x4A, 0xD9, 0xD6, 0x5A, 0xDC, 0x40, 0xDF, 0x0B, 0x66, 
    0x37, 0xD8, 0x3B, 0xF0, 0xA9, 0xBC, 0xAE, 0x53, 0xDE, 0xBB, 
    0x9E, 0xC5, 0x47, 0xB2, 0xCF, 0x7F, 0x30, 0xB5, 0xFF, 0xE9,
    0xBD, 0xBD, 0xF2, 0x1C, 0xCA, 0xBA, 0xC2, 0x8A, 0x53, 0xB3, 
    0x93, 0x30, 0x24, 0xB4, 0xA3, 0xA6, 0xBA, 0xD0, 0x36, 0x05, 
    0xCD, 0xD7, 0x06, 0x93, 0x54, 0xDE, 0x57, 0x29, 0x23, 0xD9, 
    0x67, 0xBF, 0xB3, 0x66, 0x7A, 0x2E, 0xC4, 0x61, 0x4A, 0xB8, 
    0x5D, 0x68, 0x1B, 0x02, 0x2A, 0x6F, 0x2B, 0x94, 0xB4, 0x0B, 
    0xBE, 0x37, 0xC3, 0x0C, 0x8E, 0xA1, 0x5A, 0x05, 0xDF, 0x1B, 
    0x2D, 0x02, 0xEF, 0x8D
};


byte pCrc32[4];



}
/*@@end*/

/*@@timer:t_Tx:*/
on timer t_Tx
{
	if (debug == 1)  
	  write ("DEBUG : Function.t_Tx"); 

	bTxRequestPending=1;  //TP-Dll auf belegt setzen, kein neuer Sendevorgang kann angestossen werden

  	write("Transmit UDS Service, tx_repeat: %d",tx_repeat);

	OSEKTL_SetTxId(getValue(evIsoReqId));
	OSEKTL_SetRxId(getValue(evIsoResId));
	
	OSEKTL_DataReq(tx_buffer,tx_len);
}
/*@@end*/

/*@@timer:t_Test:*/
on timer t_Test
{
//if (debug == 1)  
//  write("Timer abgelaufen: t_Test");
MainStateMaschine();
//write("set timer t_Test");


setTimer(t_Test,100);

}
/*@@end*/

/*@@caplFunc:MainStateMaschine():*/
MainStateMaschine ()
{
if (debug == 1)
  write("MainStateMaschine, status1: %d",status);


switch (status)
{ 

  case (0): //Nichts tun
  {

  break;
  }

   
  case (30)://Auslesen des Fehlerspeichers
  {
  	
	tx_len=3;
		
	tx_buffer[0]=0x19;	//SID Read DTC
	tx_buffer[1]=0x02;	//ReportDTCByStatusMask
	tx_buffer[2]=0x08;	//Status Mask, Confirmed DTC
		
	
	if (!bTxRequestPending)
	{  
	  if (debug==2)
	    write("setTimer(t_Tx, 100)");
	  
	  setTimer(t_Tx, 20);
      
	
	}  
  
  break;
  } //case(30)
  

  case (31):  //Wait for response
  {
  if(TP_RxData_ready==1)  //Data received
  {
		if (rx_buffer[0] == 0x59) //positive answer for reading Fehlerspeicher
	    {
			write("Fehlerspeicher ausgelesen");
		    
			status=0; 
		    EvaluateDTCResponseUDS();
		}
		
		else
		
		//Response pending
		if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x19) && (rx_buffer[2] == 0x78))
		{  
		//Auf nächste Antwort warten
		TP_RxData_ready=0;
 	    }
		
		else
		{
		  write("Fehler beim Auslesen des Fehlerspeichers (Service 0x18 0x02 0xff 0x00)");
		  status=0; 
	      
		  
		}
	
	
  
  } //Data Received
  
  	
  break;
  }//case (31)


  case (40)://Löschen des Fehlerspeichers
  {
  	
	    tx_len=4;
		
		tx_buffer[0]=0x14;	//Sid, Clear DTC's
		tx_buffer[1]=0xFF;	//Parameter 0xFFFFFF: clear all DTC's
		tx_buffer[2]=0xFF;
		tx_buffer[3]=0xFF;

		if (!bTxRequestPending)
		  setTimer(t_Tx, 20);
    
  break;
  } //case(40)

  case (41):  //Wait for response
  {
  if(TP_RxData_ready==1)  //Data received
  {
	
		if (rx_buffer[0] == 0x54) //positive answer for clearing Fehlerspeicher
	    {
			write("Fehlerspeicher gelöscht");
			status=0; 
		    
			 
		}
    
		else 
		{
		  if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x14) && (rx_buffer[2] == 0x78) )  //Response pending
		  {
		    write("Response Pending Received");
		    writetologex("Response Pending Received");
	    
			TP_RxData_ready=0; //Reset nötig
		  }
		  else   
		  {	
			write("Fehler beim Loeschen des Fehlerspeichers.");
		    status=0; 
	        
		    
		  }
		}
	
  
  } //Data Received
  
  break;
  }//case (41)

  case (50)://Ika-Key-Download,Service 2e
  {
  	// Normaler Schlüsseldownload
	
	
		tx_len=0x25;
		
		tx_buffer[0]=0x2e;
		tx_buffer[1]=0x00;
		tx_buffer[2]=0xbe;

	
		bKeyLength=getValue(evDownloadcontainer, cKey);
		
		if (bKeyLength==68)  //Eingegebene Daten haben die richtige Länge
		{
		  ConvertToBytes(); //cKey in bKey (String array in Byte Array convertieren)
		  
		  
		  for (tx_buffer_index=3;tx_buffer_index<37;tx_buffer_index++)
		    tx_buffer[tx_buffer_index]=bKey[tx_buffer_index-3];
	    }
		

	
	
		if (!bTxRequestPending)
		  setTimer(t_Tx, 20);
    
  break;
  } //case(50)

  case (51):  //Wait for response
  {
	  
	  if(TP_RxData_ready==1)  //Data received
	  {

	  	 
		 	if ((rx_buffer[0] == 0x6e) && (rx_buffer[2] == 0xbe)) //positive answer Ika-Key-Download
		    {
	
			write("Ika-Key-Download erfolgreich");
		    putValue(evIkaLed,2);
	
			status=0; 
    
			
			 
	
		    }
    
			else  //negative Antworten auf den Schlüsseldownload 
			{
	
				//Response pending
				if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x78))
				  {  
				  //Auf nächste Antwort warten
				  TP_RxData_ready=0;
	 			  } 
	
				//Daten falsch verschlüsselt
			    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x31))
				  {  
				    //Fehlermeldung ausgeben
				    putValue(evIkaLed,3);
			        write("Fehler beim Schlüsseldownload, Daten falsch verschlüsselt.");	  
				    status=0; 
			        
				 
	  
				  } 
	
				//Conditions not correct
			    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x22))
				  {  
				    //Fehlermeldung ausgeben
				    putValue(evIkaLed,3);
			        write("Fehler beim Schlüsseldownload, Conditions not correct.");	  
				    status=0; 
			        
				 
				  } 
	
			    //Sub Service not supported
			    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x12))
				  {  
				    //Fehlermeldung ausgeben
				    putValue(evIkaLed,3);
			        write("Fehler beim Schlüsseldownload, Sub-Service not supported.");	  
				    status=0; 
			        
				 
				  } 
	
			    //Service not supported
			    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x11))
				  {  
				    //Fehlermeldung ausgeben
				    putValue(evIkaLed,3);
			        write("Fehler beim Schlüsseldownload, Service not supported.");	  
				    
					status=0; 
		         
				  } 
	 
				//Gerneral Reject
			    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x10))
				  {  
				    //Fehlermeldung ausgeben
				    putValue(evIkaLed,3);
			        write("Fehler beim Schlüsseldownload, Gernal Reject.");	  
				    
					status=0; 
		         
				  } 
	
				//Busy repeat request
			    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x21))
				  {  
				    //Fehlermeldung ausgeben
				    write("Busy repeat request. (0x7f 0x2e 0x21).");	  
				    status=50;   
	  
				  }




				}//negative Antworten auf Schlüsseleinbringung	 
	

		 
    
  
	  } //Data Received
  
  	
  break;
  }//case (51)

  
  
  
  
  
  case (60)://Gfa-Key-Download
  {
  	// Normaler Schlüsseldownload
	
	
		tx_len=0x25;
		
		tx_buffer[0]=0x2e;
		tx_buffer[1]=0x00;
		tx_buffer[2]=0xbd;

	
		bKeyLength=getValue(evDownloadcontainer, cKey);
		
    	if (bKeyLength==68)  //Eingegebene Daten haben die richtige Länge
		{
		  ConvertToBytes(); //cKey in bKey (String array in Byte Array convertieren)
		  
		  for (tx_buffer_index=3;tx_buffer_index<37;tx_buffer_index++)
		    tx_buffer[tx_buffer_index]=bKey[tx_buffer_index-3];
	    }
		

	
	
	if (!bTxRequestPending)
	  setTimer(t_Tx, 20);
    
  break;
  } //case(60)

  case (61):  //Wait for response
  {
  if(TP_RxData_ready==1)  //Data received
	  {
		 
		 	if ((rx_buffer[0] == 0x6e) && (rx_buffer[2] == 0xbd)) //positive answer Gfa-Key-Download
		    {
	
			write("Gfa-Key-Download erfolgreich");
		    putValue(evGfaLed,2);
	
			status=0; 
    
			
			 
	
		    }
    
			else  //negative Antworten auf den Schlüsseldownload 
			{
	
			//Response pending
			if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x78))
			  {  
			  //Auf nächste Antwort warten
			  TP_RxData_ready=0;
 			  } 
	
			//Daten falsch verschlüsselt
		    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x31))
			  {  
			    //Fehlermeldung ausgeben
			    putValue(evGfaLed,3);
		        write("Fehler beim Schlüsseldownload, Daten falsch verschlüsselt.");	  
			    status=0; 
		        
				 
	  
			  } 
	
			//Conditions not correct
		    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x22))
			  {  
			    //Fehlermeldung ausgeben
			    putValue(evGfaLed,3);
		        write("Fehler beim Schlüsseldownload, Conditions not correct.");	  
			    status=0; 
		        
				 
			  } 
	
		    //Sub Service not supported
		    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x12))
			  {  
			    //Fehlermeldung ausgeben
			    putValue(evGfaLed,3);
		        write("Fehler beim Schlüsseldownload, Sub-Service not supported.");	  
			    status=0; 
		        
				 
			  } 
	
		    //Service not supported
		    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x11))
			  {  
			    //Fehlermeldung ausgeben
			    putValue(evGfaLed,3);
		        write("Fehler beim Schlüsseldownload, Service not supported.");	  
			    
				status=0; 
		         
			  } 
	 
			//Gerneral Reject
		    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x10))
			  {  
			    //Fehlermeldung ausgeben
			    putValue(evGfaLed,3);
		        write("Fehler beim Schlüsseldownload, Gernal Reject.");	  
			    
				status=0; 
		         
			  } 
	
			//Busy repeat request
		    if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x2e) && (rx_buffer[2] == 0x21))
			  {  
			    //Fehlermeldung ausgeben
			    write("Busy repeat request. (0x7f 0x2e 0x21).");	  
			    status=60;   
	  
			  }




			}//negative Antworten auf Schlüsseleinbringung	 
	

		 
	  } //Data Received
  break;
  }//case (61)

  
  case (90): //SG-Kennzeichnung auslesen
  {
    
		tx_len=3;	//Fazit Identification String

		tx_buffer[0]=0x22; 
	    tx_buffer[1]=0xF1; 
	    tx_buffer[2]=0x7c;
		
	
	if (!bTxRequestPending)
	  setTimer(t_Tx, 20);
    
  
  break;
  }//case (90)
  
  case (91):  //Wait for response
  
  {
  if(TP_RxData_ready==1)  //Data received
  {
	 	if (rx_buffer[0]==0x62) //positive Answer
	 	{
			  for(index=3;index<26;index++)
		      {
			    EcuSerialNumber[index-3] = rx_buffer[index]; 	
		      }
			  EcuSerialNumber[23]=0x00;  //Null-Termination of String
	 
			  write("Seriennummer des Steuergerätes für FAZIT: %s",EcuSerialNumber);
			  putValue(evESGIdentString,EcuSerialNumber);
				
			  CalculateChecksum(EcuSerialNumber);			  
			  status=0; 
		       	
		}
	 	else
		{
			//Response pending
			  if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x22) && (rx_buffer[2] == 0x78))
			  {  
			  //Auf nächste Antwort warten
			  TP_RxData_ready=0;
 	  
			  } 
			  else
			  {
	
			  write("Fehler beim Auslesen des Fazit-Identification-Strings. (Service 0x22 0xF1 0x7C))");
	
			  
			  status=0; 
		       
	  
			  }
		}	
	 
	 
	 
	
  
  } //Data Received
  
  break;
  }//case (91)

  case (92): //FAZIT Identification String
  {
    
	
	tx_len=3;

	tx_buffer[0]=0x22;
	tx_buffer[1]=0xF1;
	tx_buffer[2]=0x7c;
	
	
	
	if (!bTxRequestPending)
	  setTimer(t_Tx, 20);
    
  
  break;
  }//case (92)
  
  case (93):  //Wait for response
  
  {
  if(TP_RxData_ready==1)  //Data received
  {
	 	if (rx_buffer[0]==0x62) //positive Answer
	 	{
			  for(index=3;index<26;index++)
		      {
			    EcuSerialNumber[index-3] = rx_buffer[index]; 	
		      }
			  EcuSerialNumber[23]=0x00;  //Null-Termination of String
	 
			  write("Seriennummer des Steuergerätes für FAZIT: %s",EcuSerialNumber);
			  putValue(evESGIdentString,EcuSerialNumber);
			  
			  status=0; 
		       	
		}
	 	else
		{
			//Response pending
			  if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x22) && (rx_buffer[2] == 0x78))
			  {  
			  //Auf nächste Antwort warten
			  TP_RxData_ready=0;
 	  
			  } 
			  else
			  {
	
			  write("Fehler beim Auslesen des Fazit-Identification-Strings. (Service 0x22 0xF1 0x7C))");
	
			  
			  status=0; 
		       
	  
			  }
		}	
	 
	 
	 
	
  } //Data Received
  
  break;
  }//case (93)


  case (95): //SSW Version
  {
    
	
	tx_len=3;

	tx_buffer[0]=0x22;
	tx_buffer[1]=0xF1;
	tx_buffer[2]=0x81;
	tx_buffer[3]=0x00;	//steht für Komponentenschutz, andere Werte 
						//vgl. VW 80125, Seite 24
	
	
	if (!bTxRequestPending)
	  setTimer(t_Tx, 20);
    
  
  break;
  }//case (95)
  
  case (96):  //Wait for response
  
  {
  if(TP_RxData_ready==1)  //Data received
  {
	 	if (rx_buffer[0]==0x62) //positive Answer
	 	{
			  
	 		  ProcessSSWVersionISO();	
	 	
			  write("SSW Version: %s",SSWVersion);
			  putValue(evSSWVersionString,SSWVersion);
			  
			  status=0; 
		       	
		}
	 	else
		{
			//Response pending
			  if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x22) && (rx_buffer[2] == 0x78))
			  {  
			  //Auf nächste Antwort warten
			  TP_RxData_ready=0;
 	  
			  } 
			  else
			  {
	
			  write("Fehler beim Auslesen der SSW Version. (Service 0x22 0xF1 0x81)");
	
			  
			  status=0; 
		       
	  
			  }
		}	
	 
	 
	 
	
  } //Data Received
  
  break;
  }//case (93)	




  
  case (105): //Service 22 mit beliebigen Parametern
  {
    
	getValue(evDienst22,Service22Parameters);
	
	Service22ParametersTemp[2]=Service22Parameters[0];
	Service22ParametersTemp[3]=Service22Parameters[1];
	Service22ParametersTemp[4]=Service22Parameters[2];
	Service22ParametersTemp[5]=Service22Parameters[3];
	Service22ParametersTemp[6]=Service22Parameters[4];
	Service22ParametersTemp[7]=Service22Parameters[5];
	Service22ParametersTemp[8]=0x00;

	ServiceLength=strlen(Service22ParametersTemp);
	
	ConvertedValue=atol(Service22ParametersTemp);
	
	
		tx_len=ServiceLength/2;
		tx_buffer[0]=0x22;

		if (tx_len==4)
		{
		tx_buffer[1]=(char)(ConvertedValue>>16);
		tx_buffer[2]=(char)(ConvertedValue>>8);
		tx_buffer[3]=(char)(ConvertedValue & 0x000000FF);
		}
	
		if (tx_len==3)
		{
		tx_buffer[1]=(char)(ConvertedValue>>8);
		tx_buffer[2]=(char)(ConvertedValue & 0x000000FF);
		}

		
	if (!bTxRequestPending)
	  setTimer(t_Tx, 20);
    
  
  break;
  }//case (105)
  
  case (106):  //Wait for response
  
  {
  if(TP_RxData_ready==1)  //Data received
  {
	
	 	if (rx_buffer[0]==0x62) //positive Answer
	 	{
			  
			  write("LenthOfUDSResponse: %d",LengthOfUDSResponse);
			  
			  for(index=3;index<LengthOfUDSResponse;index++)
		      {
			    Service22Response[index-3] = rx_buffer[index]; 	
		      }
			  Service22Response[index-3]=0x00;  //Null-Termination of String
	 
	 		  write("%s",Service22Response);	
			  putValue(evDienst22Response,Service22Response);
			  
			  status=0; 
		       	
		}
	 	else
		{
			//Response pending
			  if ( (rx_buffer[0] == 0x7f) && (rx_buffer[1] == 0x22) && (rx_buffer[2] == 0x78))
			  {  
			  //Auf nächste Antwort warten
			  TP_RxData_ready=0;
 	  
			  } 
			  else
			  {
	
			  write("Fehler beim Auslesen Dienst 22.");
	
			  
			  status=0; 
		       
	  
			  }
		}	
  } //Data Received
  
  break;
  }//case (106)




  case (117): //Messwerteblock des Errorcounters Lesen
  {
    
	tx_len=3;

	tx_buffer[0]=0x22;
	tx_buffer[1]=0x03;
	tx_buffer[2]=0xde;
	
	
	if (!bTxRequestPending)
	  setTimer(t_Tx, 20);
    
  
  break;
  }//case (117)
  
  case (118):  //Wait for response
  {
  
  if(TP_RxData_ready==1)  //Data received
  {
	if (rx_buffer[0] == 0x62) //Positive Antwort Errorcounter lesen
	    {
			write("Errorcounter ausgelesen. EC = %d",rx_buffer[4]);
		    putValue(evEcRed,rx_buffer[4]);
			
			status=0; 
		     
		}
		else
		{
		  
		  if ((rx_buffer[0]==0x7f) && (rx_buffer[2]==0x78)) //Response pending
		  {
		  //Auf nächste Antwort warten
	  	  TP_RxData_ready=0;
 	  	  }
		  else
		  {	
		  write("Fehler beim Auslesen des Errorcounters. Service (0x22 0x03 0xde )");
		  status=0; 
	      
		  
		  }
		
		}

	
	
	
  
  } //Data Received
  
  break;
  }//case (118)		



  

  case(160):	//Selektiver Stellgliedtest zum setzen des EC auf ECLimit+1
  {
    	tx_len=8;
		
		tx_buffer[0]=0x2f;	//SID InputOutputControlByIdentifier
		tx_buffer[1]=0x03;	//VWCommonInputOutputIdentifier-Adjustment für nichtflüchtige Anpassung von Systemeigenschaften
		tx_buffer[2]=0x48;	
		tx_buffer[3]=0x03;	//
        tx_buffer[4]=0xff;
        tx_buffer[5]=0x00;
        tx_buffer[6]=0x00;
        tx_buffer[7]=0x00;
		
	
		if (!bTxRequestPending)
		  setTimer(t_Tx, 20);

  break;
  } //case(160)

  case(161):
  {
  	
	if(TP_RxData_ready==1)  //Data received
    {
    
		if ((rx_buffer[0] == 0x6f) && (rx_buffer[1] == 0x03) && (rx_buffer[2] == 0x48) && (rx_buffer[3] == 0x03) )//Positive Antwort InputOutputControlByIdentifier: Errorcounter auf ECLimit+1 gesetzt
	    {
			write("Errorcounter auf ECLimit+1 gesetzt.");
		    
			status=0; 
		     
			
		}
		else
		{
		  
		  if ((rx_buffer[0]==0x7f) && (rx_buffer[2]==0x78)) //Response pending
		  {
		  //Auf nächste Antwort warten
	  	  TP_RxData_ready=0;
 	  	  }
		  else
		  {	
		  write("Fehler beim setzen des Errorcounters auf ECLimit+1 (Service 0x2f 0x03 0x48 0x01)");
		  status=0; 
	      
		  
		  }
		
		}

	
	}//Data received
  
  break;
  }	//case(161)

  
			
  case (170):	//Read VWApplicationSoftwareNumber
  {
	    
			tx_len=3;

			tx_buffer[0]=0x22;
			tx_buffer[1]=0xF1;
			tx_buffer[2]=0x88;
		
			if (!bTxRequestPending)
			  setTimer(t_Tx, 20);

  break;
  }	


  case (171):  //Wait for response
  {
  if(TP_RxData_ready==1)  //Data received
  {
	
		if ((rx_buffer[0]==0x62) && (rx_buffer[1]==0xf1) && (rx_buffer[2]==0x88))  //positive answer for reading ecu identification
		{
		    //Construction of the VWApplicationSoftwareNumberOrVWFlashContainerNumber  out of the rx_buffer
	
			for(index=3;index<14;index++)
		    {
			    SoftwareTeileNummer[index-3] = rx_buffer[index]; 	
		    }
	
			SoftwareTeileNummer[11]=0x00;  //Null-Termination of String
	 
			write("VWApplicationSoftwareNumberOrVWFlashContainerNumber: %s",SoftwareTeileNummer);
		
			putValue(evVWApplicationSoftwareNumber,SoftwareTeileNummer);

			status=0;
		
		}//Positive Answer

		else //no positive answer 
		{
	      if ((rx_buffer[0]==0x7f) && (rx_buffer[1]==0x22) && (rx_buffer[2]==0x78))  //Response Pending
	      {  
			TP_RxData_ready=0; //Reset nötig, damit die nächste Antwort wieder ausgewertet wird.
		    write("Response Pending Received");
		    
		  } 
	      else //nicht definierte Antwort, bzw. Service not supported
		  {
		    write("Fehler beim Auslesen der SoftwareTeileNummer! (Service 0x22 0xF1 0x88)");
		    
		    status=0; 
	         
		  }
		}
	
	
	
  } //Data Received
  
  break;
  }//case (171)		



case (180): //Read VWApplicationSoftwareVersionNumber
  {
	
			tx_len=3;

			tx_buffer[0]=0x22;
			tx_buffer[1]=0xF1;
			tx_buffer[2]=0x89;
	
		if (!bTxRequestPending)
		  setTimer(t_Tx, 20);

  break;
  }	


  case (181):  //Wait for response
  {
  if(TP_RxData_ready==1)  //Data received
  {
	
		if ((rx_buffer[0]==0x62) && (rx_buffer[1]==0xf1) && (rx_buffer[2]==0x89))  //positive answer 
		{
		    
			for(index=3;index<7;index++)
		    {
			    VWApplicationSoftwareVersionNumber[index-3] = rx_buffer[index]; 	
		    }
	
			VWApplicationSoftwareVersionNumber[4]=0x00;  //Null-Termination of String
	 
			write("VWApplicationSoftwareVersionNumber: %s",VWApplicationSoftwareVersionNumber);
		
			putValue(evVWApplSoftwareVersionNumber,VWApplicationSoftwareVersionNumber);

			status=0;
		
		}//Positive Answer

		else //no positive answer 
		{
	      if ((rx_buffer[0]==0x7f) && (rx_buffer[1]==0x22) && (rx_buffer[2]==0x78))  //Response Pending
	      {  
			TP_RxData_ready=0; //Reset nötig, damit die nächste Antwort wieder ausgewertet wird.
		    write("Response Pending Received");
		    
		  } 
	      else //nicht definierte Antwort, bzw. Service not supported
		  {
		    write("Fehler beim Auslesen der VWApplicationSoftwareVersionNumber! (Service 0x22 0xF1 0x89)");
		    
		    status=0; 
	         
		  }
		}
	
	
	
  } //Data Received
  
  break;
  }//case (181)		


case (190): //Read VWEcuHardwareVersionNumber
  {
	
			tx_len=3;

			tx_buffer[0]=0x22;
			tx_buffer[1]=0xF1;
			tx_buffer[2]=0xa3;
	
		if (!bTxRequestPending)
		  setTimer(t_Tx, 20);

  break;
  }	


  case (191):  //Wait for response
  {
  if(TP_RxData_ready==1)  //Data received
  {
	
		if ((rx_buffer[0]==0x62) && (rx_buffer[1]==0xf1) && (rx_buffer[2]==0xa3))  //positive answer
		{
		    for(index=3;index<7;index++)
		    {
			    HardwareVersion[index-3] = rx_buffer[index]; 	
		    }
	
			HardwareVersion[4]=0x00;  //Null-Termination of String
	 
			write("VWEcuHardwareVersionNumber: %s",HardwareVersion);
		
			putValue(evVWEcuHardwareVersionNumber,HardwareVersion);

			status=0;
		
		}//Positive Answer

		else //no positive answer 
		{
	      if ((rx_buffer[0]==0x7f) && (rx_buffer[1]==0x22) && (rx_buffer[2]==0x78))  //Response Pending
	      {  
			TP_RxData_ready=0; //Reset nötig, damit die nächste Antwort wieder ausgewertet wird.
		    write("Response Pending Received");
		    
		  } 
	      else //nicht definierte Antwort, bzw. Service not supported
		  {
		    write("Fehler beim Auslesen der VWEcuHardwareVersionNumber! (Service 0x22 0xF1 0xa3)");
		    
		    status=0; 
	         
		  }
		}
	
	
	
  } //Data Received
  
  break;
  }//case (191)		


  case (200): //Checksumme auslesen
  {
		tx_len=3;

		tx_buffer[0]=0x22;
		tx_buffer[1]=0x02;
		tx_buffer[2]=0xF9;
	
		if (!bTxRequestPending)
		  setTimer(t_Tx, 20);

  break;
  }	


  case (201):  //Wait for response
  {
  if(TP_RxData_ready==1)  //Data received
  {
	
		if ((rx_buffer[0]==0x62) && (rx_buffer[1]==0x02) && (rx_buffer[2]==0xF9))  //positive answer
		{
		    
			if (rx_buffer[3]==0x01)	//Correct version of checksum
			{
				ReadCheckSum = (rx_buffer[4] << 24) + (rx_buffer[5] << 16)  + (rx_buffer[6] << 8) + rx_buffer[7];
				write("CheckSum read out: %x",ReadCheckSum);
				putValue(evReadCheckSum,ReadCheckSum);
			}			
			
			else
			{
				putValue(evReadCheckSum,0);
				write("Falsche Versionsnummer der Checksumme.");
			}
			
			status=0;
		
		}//Positive Answer

		else //no positive answer 
		{
	      if ((rx_buffer[0]==0x7f) && (rx_buffer[1]==0x22) && (rx_buffer[2]==0x78))  //Response Pending
	      {  
			TP_RxData_ready=0; //Reset nötig, damit die nächste Antwort wieder ausgewertet wird.
		    write("Response Pending Received");
		    
		  } 
	      else //nicht definierte Antwort, bzw. Service not supported
		  {
		    write("Fehler beim Auslesen der Checksumme! (Service 0x22 0x02 0xF9)");
		    
		    status=0; 
	         
		  }
		}
	
  } //Data Received
  
  break;
  }//case (201)


} //switch


}
/*@@end*/

/*@@startStart:Start:*/
on start
{
    write("*******************************************************************************************");
	write("* Komponentenschutz Prüftool für Typ 010C 2. Generation                                   *");
	write("* ISO-TP Version: Diagnosedienste auf ISO-TP Normal Adressing                             *");
	write("*                 Authentifikation mit 11-Bit-Identifiern auf ISO-TP Extended Adressing   *");
    write("*                 Authentifikation mit 29-Bit-Identifiern auf ISO-TP Normal Adressing     *");
	write("* Support: AUDI AG I/EE-6                                                                 *");
	write("* Tel.: 0841 / 89 - 38671                                                                 *");
	write("* Version: 2.0                                                                            *");
	write("*******************************************************************************************");

	setTimer(t_Test,100);
	
    OSEKTL_UseExtId(1);  /* geändert (dh) */
	OSEKTL_SetUseFC(1);	  //Use Flow-Control Frames
	OSEKTL_SetBS(15);     //Blocksize set to 15
	OSEKTL_SetSTMIN(20);  //Separation Time
 	
	//Hier die CAN-Ids für Normal Adressing eintragen, damit nicht jedes mal 
	//beim Start des Tools die Identifier neu eingetragen werden müssen 
	putValue(evIsoReqId,0x14); /* geändert (dh) */
    putValue(evIsoResId,0x14); /* geändert (dh) */

	

}
/*@@end*/

/*@@preStart:PreStart:*/
/*@@end*/

/*@@envVar:evFehlerspeicherLesen010C:*/
on envVar evFehlerspeicherLesen010C
{

	if ( getValue(this) == 1 )
  	{
		Aktion=2;
		GetNextState();
	}

}
/*@@end*/

/*@@envVar:evFehlerspeicherLoeschen010C:*/
on envVar evFehlerspeicherLoeschen010C

{

	if ( getValue(this) == 1 )
    {
	Aktion=3; //Fehlerspeicher löschen
	GetNextState();
	}
   
}
/*@@end*/

/*@@envVar:evIkaKeyDownload2e:*/
on envVar evIkaKeyDownload2e
{
  if ( getValue(this) == 1 )
  {  
      Aktion=4; //Ika-Key-Download
	  GetNextState();	
  }

}
/*@@end*/

/*@@envVar:evGfaKeyDownload2e:*/
on envVar evGfaKeyDownload2e
{
  if ( getValue(this) == 1 )
  {  
      Aktion=5; //Gfa-Key-Download
 	  GetNextState(); 
  }

}
/*@@end*/

/*@@caplFunc:ConvertToBytes():*/
ConvertToBytes ()
{
  index=0;

  cTempString[4]=0x00;	
	
  while (index<68)
  {
    cTempString[2]=cKey[index];  //cTempString[5]="0x00" wurde unter variablen initialisiert.
    cTempString[3]=cKey[index+1];
    bKey[index/2]=atol(cTempString);
    index=index+2;
  }

}
/*@@end*/

/*@@timer:t_VerzugKeyDown:*/
on timer t_VerzugKeyDown
{

LockValue=0;

msVerzugKeyDown=msVerzugKeyDown + 50;
putValue(evVerzug,msVerzugKeyDown);

status=50;

}
/*@@end*/

/*@@envVar:evReadEc:*/
on envVar evReadEc
{

  if ( getValue(this) == 1 )
  {  
      Aktion=72; //Auslesen des Errorcounters
	  GetNextState();	
  }

}
/*@@end*/

/*@@caplFunc:TPTargetToMWBNr():*/
char TPTargetToMWBNr()		//Funktion bestimmt anhand der TP-Zieladresse die Messwerteblocknummer des SG,
							//wo der Errorcounter gespeichert ist.

{

	switch (TP_Target)
	{
		case(0x2f): //Standheizung
		{
	
		return 0x0e; //Messwerteblock 14 
	    
		}
		
		case(0x07): //Standheizung
		{
	
		return 0x28; //Messwerteblock 
	    
		}
		
		case(0x20): //BCM1
		{
	
		return 0x28; //Messwerteblock 
	    
		}

	
		default:	//falls für ein SG noch kein MBW bekannt ist, wird die Eingabe in
		{			//das Panel verwendet
		
		
		return getValue(evMWBNR);
		
		}

	
	
	}

}
/*@@end*/

/*@@caplFunc:EvaluateMWBEc():*/
EvaluateMWBEc()		//Gibt anhand der TP-Zieladresse an, wo der Wert des Errorcounters
 					//zurückgeliefert wird.

/* Beispiel-Trace:

Time          Chn ID            
  |  180.942704    1   325         Rx     5   1c 00 02 21 0e             
  |  180.951913    1   300         Rx     1   bd                         
  |  180.962713    1   300         Rx     8   22 00 0e 61 0e 25 00 88    
  |  180.972730    1   300         Rx     8   23 4b 00 00 4b 00 00 4b    
  |  180.982194    1   300         Rx     3   14 00 1f					Bei der Standheizung wird derzeit                   
  |  180.982654    1   325         Rx     1   b5                        als Messwert im 4.Messwert des MWB  
																		der EC zurückgeliefert.	
*/

{

	switch (TP_Target)
    {
		case (0x2f):	//Standheizung
		{
		
		//putValue(evEcRed,rx_buffer[6]);	//Messwert 1
		//putValue(evEcRed,rx_buffer[9]);	//Messwert 2
		//putValue(evEcRed,rx_buffer[12]);	//Messwert 3
		putValue(evEcRed,rx_buffer[15]);	//Messwert 4
		break;
		}
	
		case (0x07):	//Kombi
		{
		putValue(evEcRed,rx_buffer[6]);	//Messwert 1
		break;
		}
	
		case (0x20):	//BCM1
		{
		putValue(evEcRed,rx_buffer[6]);	//Messwert 1
		break;
		}
	
	
	}


}
/*@@end*/

/*@@caplFunc:ShowVersion():*/
ShowVersion ()
{
//Zusammenbau des Anzeigestrings
//Vollversion
KSBVersion[0]=0x30;
KSBVersion[1]=rx_buffer[5]+0x30;
KSBVersion[2]=0x2e;
KSBVersion[3]=0x30;
KSBVersion[4]=rx_buffer[6]+0x30;

KSBVersion[5]=0x2e;

//Bugfixversion
KSBVersion[6]=0x30;
KSBVersion[7]=rx_buffer[7]+0x30;

putValue(evKSBVersion,KSBVersion);

}
/*@@end*/

/*@@envVar:evKeyDownAut2e:*/
on envVar evKeyDownAut2e
{
if ( getValue(this) == 1 )
  {  
      
	  putValue(evIkaLed,0);
	  putValue(evAutLed,0);
	  Aktion=41; //Key Download Starten und gleichzeitig eine Authentifizierung durchführen.
	  GetNextState();
  
  }

}
/*@@end*/

/*@@envVar:evFazitIdentString:*/
on envVar evFazitIdentString
{
  
  if ( getValue(this) == 1 )
  {  
	  Aktion=8;	//eventuell auf 81 setzen 
	  GetNextState();
  }


}
/*@@end*/

/*@@envVar:evSetEcLimit:*/
on envVar evSetEcLimit
{

if ( getValue(this) == 1 )
  {  
      Aktion=82; //EC auf ECLimit setzen (Selektiver Stellgliedtest)
      GetNextState();
  }

}
/*@@end*/

/*@@caplFunc:OSEKTL_DataCon(long):*/
OSEKTL_DataCon(long osek_status)
{

bTxRequestPending=0;
TP_RxData_ready = 0;

GetNextStateCon();	

}
/*@@end*/

/*@@caplFunc:OSEKTL_DataInd(long):*/
OSEKTL_DataInd( long rxCount )
{
  // Output of Source Address
  long src;
  src = OSEKTL_GetSrcAdr();

  TP_RxData_ready = 1;
  
  ClearRxBuffer();	

  /* Get received data */
  OSEKTL_GetRxData( rx_buffer, elcount(rx_buffer) );
  LengthOfUDSResponse=rxCount;
  
}
/*@@end*/

/*@@caplFunc:OSEKTL_ErrorInd(int):*/
OSEKTL_ErrorInd(int error)
{
  switch (error)
  {
    case 1:     write("CAPL: %s: Error (%d): Timeout while waiting for CF", gECU, error);     break;
    case 2:     write("CAPL: %s: Error (%d): Timeout while waiting for FC", gECU, error);     break;
    case 3:     write("CAPL: %s: Error (%d): Wrong Sequence Number", gECU, error);            break;
    case 4:     write("CAPL: %s: Error (%d): TP_DLL busy", gECU, error);                      break;
    case 5:     write("CAPL: %s: Error (%d): Unexpected PDU", gECU, error);                   break;
    case 6:     write("CAPL: %s: Error (%d): Timeout while waiting for Tx-Ack", gECU, error); break;
    case 7:     write("CAPL: %s: Error (%d): WFT Overrun", gECU, error);                      break;
    default:    write("CAPL: %s: Error (%d): unknown error", gECU, error);                    break;
  }

  status=0;	
  bTxRequestPending=0;
}
/*@@end*/

/*@@caplFunc:OSEKTL_FirstFrameIndication(long,long,long):*/
OSEKTL_FirstFrameIndication( long sourceadr, long destadr, long rxCount )
{
  /* Print message to write window */
  write("CAPL: %s: FF indication called, SA= 0x%02lx, TA= 0x%02lx, RxCount = %ld", 
         gECU, sourceadr, destadr, rxCount);
}
/*@@end*/

/*@@caplFunc:GetNextState():*/
GetNextState ()	//After Channel Setup
{
//write("GetNextState");
write("Aktion:%d",Aktion);
switch (Aktion)
{
  case (0):
  {
  status=0;
  
  break;
  }
  
  case (1):		//010C
  case (70):	//010B
  {
  status=20;
  break;
  }

  case (2):
  {
  status=30;
  break;
  }

  case (3):
  {
  status=40;
  break;
  }

  case (4):
  {
  status=50;
  break;
  }

  case (5):
  {
  status=60;
  break;
  }

  case (6):
  {
  status=70;
  break;
  }
  

  case (7):
  {
  status=70;
  break;
  }

  case (8):
  {
  status=90;
  break;
  }

  case (23):
  case (24):
  case (25):
  case (26):
  case (27):
  case (28):
  case (30):
  
  {
  
  break;
  }

  case(29):
  {
  break;
  }
  
  
  case (40):
  {
  status=100;
  break;
  }
  
  case (41):	
  case (42):
  {
  	  
	  if (LockValue==0)
	  {
		  LockValue=1;	//LockValue verhindert, dass die folgende Funktion mehrmals aufgerufen wird.
		  putValue(evDownloadcontainer,cKey_Verify);
		  msVerzugKeyDown=getValue(evVerzug);
		  setTimer(t_VerzugKeyDown,msVerzugKeyDown);
	      putValue(evDoIka,1);   
	  }
  
  break;
  }

  case (50):
  {
  putValue(evDownloadcontainer,cKey_Verify);
  status=50; //IKA-Key download
  break;
  }

  case (60):
  {
  status=110; //Messwerteblock lesen aus dem Gateway
  break;
  }

  case (72):
  {
  status=117; //Read Errorcounter MWB
  break;
  }
  
  case (73):
  {
  status=65; //Write Errorcounter
  break;
  }	

  case (74):
  {
  status=52;
  break;
  }

  case (75):
  {
  status=62;
  break;
  }

  case (76):
  {
  status=67;
  break;
  }
	
  case (77):
  {
  status=25;
  break;
  }

  case (80):
  {
  status=145;
  break;
  } 

  case (81):
  {
  status=92;
  break;
  } 	

  case (82):
  {
  status=160;
  break;
  }

  case (83):
  {
  status=95;
  break;
  }

  case (90):
  {
  status=170;
  break;
  }

  case (91):
  {
  status=180;
  break;
  }	

  case (92):
  {
  status=190;
  break;
  }	

  case (93):
  {
  status=190;
  break;
  }	

  case (95):
  {
  status=105;
  break;
  }

  case (100):
  {
  status=200;
  break;
  }	
	
}

}
/*@@end*/

/*@@caplFunc:GetNextStateCon():*/
GetNextStateCon ()	//Get next State after Data were sent to ECU (Data were confirmed)
{

switch (status)
  {
    
	case (20): //Abfrage der unterstützten Funktionen wurde gesendet
    {
	status=21;
	break;
	}
  
  	case (25): //Auslesen der Softwareversion wurde gesendet
    {
	status=26;
	break;
	}
	 
    case (30): //Fehlerspeicher lesen wurde gesendet
    {
	status=31;
	break;
	}
  
    case (40): //Fehlerspeicher loeschen wurde gesendet
    {
	status=41;
	break;
	}
   
    case (50): //Ika-Key-Download wurde gesendet
    {
	status=51;
	break;
	}

	case (52): //Ika-Key-Download wurde gesendet
    {
	status=53;
	break;
	}


	case (60): //Gfa-Key-Download wurde gesendet
    {
	status=61;
	break;
	}
    
	case (62): //Gfa-Key-Download wurde gesendet
    {
	status=63;
	break;
	}

	case (65): //Schreiben des Errorcounters 2e
    {
	status=66;
	break;
	}

	case (67): //Schreiben des Errorcounters 3b
    {
	status=68;
	break;
	}

    case (70): //Authentfikation: Challenge_M wurde gesendet
    {
	status=71;
	break;
	}

	case (80): //Authentfikation: Response_M wurde gesendet
    {
	status=81;
	break;
	}
    
    case (90): //Erweiterte SG-Identifikation Anfrage wurde gesendet
    {
	status=91;
	break;
	}

    case (92): //FAZIT Identification String lesen
    {
	status=93;
	break;
	}

	case (95): //SSW Version auslesen
    {
	status=96;
	break;
	}
	
	
	case (100): //ECU-Identifikation Anfrage wurde gesendet
    {
	status=101;
	break;
	}
  
	case (105):
	{
	status=106;
	break;
	}	

	
	
	case (110): //Anfrage des Messwerteblocks 60 wurde gesendet
    {
	status=111;
	break;
	}

  	case (115): //Anfrage des Messwerteblocks 61 wurde gesendet
    {
	status=116;
	break;
	}
  
	case (117): //Anfrage des Messwerteblocks für Ec wurde gesendet
    {
	status=118;
	break;
	}

	case (120): //Write FSC + PIN
    {
	status=121;
	break;
	}	

	case (125): //Read FSC + PIN
    {
	status=126;
	break;
	}

	case (130): //Security Access request challenge (Unlock Ecu)
    {
	status=131;
	break;
	}
	
	case (135): //Security Access send Key
    {
	status=136;
	break;
	}	

	case (140): //Write FSC
    {
	status=141;
	break;
	}
  
    case (145): //Messwerteblock der Betriebsspannung lesen.
    {
	status=146;
	break;
	}
    
  	
  	case (150): //Security Access request Challenge (Lock Ecu)
    {
	status=151;
	break;
	}

	case (155): //Security Access send Key
    {
	status=156;
	break;
	}
  
  	case (160): 
    {
	status=161;
	break;
	}
  
    case (162): 
    {
	status=163;
	break;
	}

	case (164): 
    {
	status=165;
	break;
	}
  	
	case (170):	//SoftwareTeileNummer mit Dienst 22 f1 88 
    {
	status=171;
	break;
	}


	case (180): //VWApplicationSoftwareVersionNumber 22 f1 89
    {
	status=181;
	break;
	}

	case (190): //Hardware Version mit Dienst 22 f1 a3
    {
	status=191;
	break;
	}

	case (200): //CheckSum mit Dienst 22 02 F9
    {
	status=201;
	break;
	}

  }

}
/*@@end*/

/*@@caplFunc:EvaluateDTCResponseUDS():*/
EvaluateDTCResponseUDS()
{
	
	putValue(ev053504,2);	 //Fehler ist nicht qualifiziert
	putValue(ev060001,2);	 //Fehler ist nicht qualifiziert
	putValue(ev060002,2);	 //Fehler ist nicht qualifiziert
	putValue(ev060003,2);	 //Fehler ist nicht qualifiziert
	putValue(ev060004,2);	 //Fehler ist nicht qualifiziert
		

	putValue(evAnz,((LengthOfUDSResponse - 3) / 4 ));
						 //Assumed a maximum number of DTC's of 25 	
	for (index=0;index<4*25;index=index+4)
    {
	  
	  if (( rx_buffer[index+3] == 0xd1) && ( rx_buffer[index+4] == 0x00) ) 
	  {
	  
	  	if( rx_buffer[index+5] == 0x00)	//Fehler 053504 vorhanden
		{
			if(rx_buffer[index+6] & 0x08) //Fehler ist qualifiziert
			{
			
				if (rx_buffer[index+6] & 0x01)	
				  putValue(ev053504,3);		//Fehler aktiv
				else
				  putValue(ev053504,1);		//Fehler passiv	
					
			}
			
		}
	  }  
	
	  
	  if (( rx_buffer[index+3] == 0xea) && ( rx_buffer[index+4] == 0x61) ) 
	  {
	  
		  if( rx_buffer[index+5] == 0x00) //Fehler 060001 vorhanden
		  {
				if(rx_buffer[index+6] & 0x08) //Fehler ist qualifiziert
				{
					if (rx_buffer[index+6] & 0x01)	
					  putValue(ev060001,3);		//Fehler aktiv
					else
					  putValue(ev060001,1);		//Fehler passiv	
				}
				
		  }
	  
	  }

	  
	  if (( rx_buffer[index+3] == 0xea) && ( rx_buffer[index+4] == 0x62) ) 
	  {
	  
		  if( rx_buffer[index+5] == 0x00) //Fehler 060002 vorhanden
		  {
				if(rx_buffer[index+6] & 0x08) //Fehler ist qualifiziert
				{
					if (rx_buffer[index+6] & 0x01)	
					  putValue(ev060002,3);		//Fehler aktiv
					else
					  putValue(ev060002,1);		//Fehler passiv	
				}
				
		  }
	  
	  }


	  if (( rx_buffer[index+3] == 0xea) && ( rx_buffer[index+4] == 0x63) ) 
	  {
	  
		  if( rx_buffer[index+5] == 0x00) //Fehler 060003 vorhanden
		  {
				if(rx_buffer[index+6] & 0x08) //Fehler ist qualifiziert
				{
					if (rx_buffer[index+6] & 0x01)	
					  putValue(ev060003,3);		//Fehler aktiv
					else
					  putValue(ev060003,1);		//Fehler passiv	
				}
				
		  }
	  
	  }


	  if (( rx_buffer[index+3] == 0xea) && ( rx_buffer[index+4] == 0x64) ) 
	  {
	  
		  if( rx_buffer[index+5] == 0x00) //Fehler 060004 vorhanden
		  {
				if(rx_buffer[index+6] & 0x08) //Fehler ist qualifiziert
				{
					if (rx_buffer[index+6] & 0x01)	
					  putValue(ev060004,3);		//Fehler aktiv
					else
					  putValue(ev060004,1);		//Fehler passiv	
				}
				
		  }
	  
	  }
	  


	  	


    } 


}
/*@@end*/

/*@@envVar:evISOKeyDownload:*/
on envVar evISOKeyDownload
{

	if (getValue(this)==1)
	{
		putValue(evDownloadcontainer,cKey_Verify);
		status=50; //Keydownload starten
		putValue(this,0);
	
	}


}
/*@@end*/

/*@@envVar:evSSWVersion:*/
on envVar evSSWVersion
{

  if ( getValue(this) == 1 )
  {  
	  
	  Aktion=83; //SSWVersion lesen (Standardsoftware Version)
	  GetNextState();
	  
  }

}
/*@@end*/

/*@@caplFunc:ProcessSSWVersionISO():*/
ProcessSSWVersionISO()
{

int index;

for (index=3;index<LengthOfUDSResponse;index=index+4)
{

    if (rx_buffer[index] == HEADER_KS_VERSION) 
        break;
}


//Zusammenbau des Anzeigestrings
//Freigegebene Version
SSWVersion[0]=0x30;
SSWVersion[1]=rx_buffer[index+1]+0x30;
SSWVersion[2]=0x2e;
//Kompatible Änderung
SSWVersion[3]=0x30;
SSWVersion[4]=rx_buffer[index+2]+0x30;
SSWVersion[5]=0x2e;

//Bugfixversion
SSWVersion[6]=0x30;
SSWVersion[7]=rx_buffer[index+3]+0x30;

}
/*@@end*/

/*@@envVar:evVWApplicationSoftwareNumberS:*/
on envVar evVWApplicationSoftwareNumberS
{
  
  if ( getValue(this) == 1 )
  {  
	  Aktion=90; //VWApplicationSoftwareNumber
      GetNextState();	
  }	

}
/*@@end*/

/*@@envVar:evVWApplSoftwareVersionNumberS:*/
on envVar evVWApplSoftwareVersionNumberS
{
  if ( getValue(this) == 1 )
  {  
	  Aktion=91; //VWApplicationSoftwareVersionNumber
    
	  GetNextState();	
  }
}
/*@@end*/

/*@@envVar:evVWEcuHardwareVersionNumberS:*/
on envVar evVWEcuHardwareVersionNumberS
{
  if ( getValue(this) == 1 )
  {  
	  Aktion=92; //VWEcuHardwareVersionNumber
    
	  GetNextState();	
  }

}
/*@@end*/

/*@@envVar:evDienst22Start:*/
on envVar evDienst22Start
{
  if ( getValue(this) == 1 )
  {  
	  Aktion=95; //Service 22 mit beliebigen Paramentern
      GetNextState();  
  }	

}
/*@@end*/

/*@@caplFunc:ClearRxBuffer():*///function
ClearRxBuffer ()
{

	for(i=0;i<200;i++)
	{
		rx_buffer[i]=0;
	}

}
/*@@end*/

/*@@envVar:evOBDDEFAULT:*/
on envVar evOBDDEFAULT
{

if (getValue(this)==1)
{
	
	tx_len=2;
	
	tx_buffer[0]=0x10;
	tx_buffer[1]=0x01; //OBD / Default Session

	setTimer(t_Tx,20);

}


}
/*@@end*/

/*@@envVar:evExtended:*/
on envVar evExtended
{

if (getValue(this)==1)
{
	
	tx_len=2;
	
	tx_buffer[0]=0x10;
	tx_buffer[1]=0x03; //Extended

	setTimer(t_Tx,20);

}


}
/*@@end*/

/*@@envVar:evDevelopment:*/
on envVar evDevelopment
{

if (getValue(this)==1)
{
	
	tx_len=2;
	
	tx_buffer[0]=0x10;
	tx_buffer[1]=0x4f; //Development

	setTimer(t_Tx,20);

}


}
/*@@end*/

/*@@envVar:evEOL:*/
on envVar evEOL
{

if (getValue(this)==1)
{
	
	tx_len=2;
	
	tx_buffer[0]=0x10;
	tx_buffer[1]=0x40; //End of Line Session

	setTimer(t_Tx,20);

}


}
/*@@end*/

/*@@envVar:evDoKeyDownload:*/
on envVar evDoKeyDownload
{
	if (getValue(this)==1)
	{
	putValue(evDoKeyDownload,0);
	putValue(evDownloadcontainer,cKey_Verify);
	status=50;	  
	}

}
/*@@end*/

/*@@caplFunc:crc32Init_u8():*///function
void crc32Init_u8(void)
{
    pCrc32[0]   = 0xFF;
    pCrc32[1]   = 0xFF;
    pCrc32[2]   = 0xFF;
    pCrc32[3]   = 0xFF;
    
}
/*@@end*/

/*@@caplFunc:crc32Finish_u8():*///function
void crc32Finish_u8(void)
{
    pCrc32[0]  = ~pCrc32[0];
    pCrc32[1]  = ~pCrc32[1];
    pCrc32[2]  = ~pCrc32[2];
    pCrc32[3]  = ~pCrc32[3];
    
}
/*@@end*/

/*@@caplFunc:crc32Update_u8(char[],byte):*///function
void crc32Update_u8(char pData[],byte uSize)
{
    byte i = 0;
    byte tmpCRC32[4];

    for(i = 0; i < uSize; i++)
    {
        tmpCRC32[0] = pCrc32[0];
        tmpCRC32[1] = pCrc32[1];
        tmpCRC32[2] = pCrc32[2];
        tmpCRC32[3] = pCrc32[3];

        pCrc32[3]   = crc32tab2[ ((pData[i] ^ tmpCRC32[0]) <<2) + 0];
        
        pCrc32[2]   = tmpCRC32[3] ^ crc32tab2[ ((pData[i] ^ tmpCRC32[0]) << 2) + 1];
        
        pCrc32[1]   = tmpCRC32[2] ^ crc32tab2[ ((pData[i] ^ tmpCRC32[0]) << 2) + 2];
        
        pCrc32[0]   = tmpCRC32[1] ^ crc32tab2[ ((pData[i] ^ tmpCRC32[0]) << 2) + 3];
    
    }
}
/*@@end*/

/*@@caplFunc:CalculateChecksum(char[]):*///function
void CalculateChecksum (char ChecksummeInput[])
{
	long CheckSum=0;
	
	crc32Init_u8();
	crc32Update_u8(ChecksummeInput, 23);
	crc32Finish_u8();

	CheckSum = (pCrc32[3]<<24) + (pCrc32[2]<<16) + (pCrc32[1]<<8) + pCrc32[0] ;

	write("Calculated Checksum: %08x",CheckSum);

    putValue(evCalculatedCheckSum,CheckSum);

}
/*@@end*/

/*@@envVar:evStartReadCheckSum:*/
on envVar evStartReadCheckSum
{

  if ( getValue(this) == 1 )
  {  
      Aktion=100; //Auslesen der Checksumme mit Service 22 02 F9
	  GetNextState();	
  }

}
/*@@end*/

/*@@caplFunc:OSEKTL_FI_PreSend(word[],byte[]):*///callback
OSEKTL_FI_PreSend (word dlc_1[], byte message_1[])
{
}
/*@@end*/

