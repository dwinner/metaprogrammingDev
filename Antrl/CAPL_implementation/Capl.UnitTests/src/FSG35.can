/*@!Encoding:1252*/
includes
{
    #include "..\..\..\_DLL\latest_BAP_DLL.cin"
    #include "VarDef_FSG.cin"
}

variables
{
    char  dbc_path[255]             = "BAP\\_DBC\\BAP_V9.04F.dbc";
    char  xml_path[255]             = "BAP\\BCmE_P31DF45_V2.52_FSG35\\FSG035\\bapxml\\BAP_SW16_BCmE_P31DF45_FSG_V2.52.xml";
    dword NODE_INDEX                =  0;
    char  NODE_NAME[100]            = "BCmE";
    const LSGID                     = 35;
    char  panel_name[100]           = "FSG35_0";
    char  bapconfig_panel_name[100] = "panel4";
    char  common_panel_name[100]    = "panel2";
    const TaskTime                  = 10;

    const C_FSG_35_0_0_1_ID = 1;
    char gCheckbox1[100] = "checkbox_C_FSG_35_0_0_1";
    char gErrField1[100] = "errfield_C_FSG_35_0_0_1";
    byte gC_FSG_35_0_0_1_ErrCode = 1;

    const P_FSG_35_0_0_2_ID = 2;
    byte P_FSG_35_0_0_2Reset_BTN_already_pressed = 0;
    char gCheckbox2[100] = "checkbox_P_FSG_35_0_0_2";
    char gErrField2[100] = "errfield_P_FSG_35_0_0_2";
    byte gP_FSG_35_0_0_2_ErrCode = 1;

    const P_FSG_35_0_0_3_ID = 3;
    byte P_FSG_35_0_0_3Status_BTN_already_pressed = 0;
    char gCheckbox3[100] = "checkbox_P_FSG_35_0_0_3";
    char gErrField3[100] = "errfield_P_FSG_35_0_0_3";
    byte gP_FSG_35_0_0_3_ErrCode = 1;

    const P_FSG_35_0_0_4_ID = 4;
    byte P_FSG_35_0_0_4Status_BTN_already_pressed = 0;
    char gCheckbox4[100] = "checkbox_P_FSG_35_0_0_4";
    char gErrField4[100] = "errfield_P_FSG_35_0_0_4";
    byte gP_FSG_35_0_0_4_ErrCode = 1;

    const P_FSG_35_0_0_13_ID = 13;
    byte P_FSG_35_0_0_13Status_BTN_already_pressed = 0;
    char gCheckbox13[100] = "checkbox_P_FSG_35_0_0_13";
    char gErrField13[100] = "errfield_P_FSG_35_0_0_13";
    byte gP_FSG_35_0_0_13_ErrCode = 1;
    char gPanel13[100] = "panel_P_FSG_35_0_0_13";

    const P_FSG_35_0_0_14_ID = 14;
    byte P_FSG_35_0_0_14Status_BTN_already_pressed = 0;
    char gCheckbox14[100] = "checkbox_P_FSG_35_0_0_14";
    char gErrField14[100] = "errfield_P_FSG_35_0_0_14";
    byte gP_FSG_35_0_0_14_ErrCode = 1;
    char gPanel14[100] = "panel_P_FSG_35_0_0_14";

    const P_FSG_35_0_0_15_ID = 15;
    byte P_FSG_35_0_0_15Status_BTN_already_pressed = 0;
    char gCheckbox15[100] = "checkbox_P_FSG_35_0_0_15";
    char gErrField15[100] = "errfield_P_FSG_35_0_0_15";
    byte gP_FSG_35_0_0_15_ErrCode = 1;
    char gPanel15[100] = "panel_P_FSG_35_0_0_15";

    const A_FSG_35_0_0_16_ID = 16;
    byte A_FSG_35_0_0_16Changed_BTN_already_pressed = 0;
    byte A_FSG_35_0_0_16Status_BTN_already_pressed = 0;
    char gCheckbox16[100] = "checkbox_A_FSG_35_0_0_16";
    char gErrField16[100] = "errfield_A_FSG_35_0_0_16";
    byte gA_FSG_35_0_0_16_ErrCode = 1;
    char gPanel16[100] = "panel_A_FSG_35_0_0_16";
    byte A_FSG_35_0_0_16_DataIndex_Decr_already_pressed = 0;
    byte A_FSG_35_0_0_16_DataIndex_Incr_already_pressed = 0;
    byte A_FSG_35_0_0_16_DataIndex_SetGet_Decr_already_pressed = 0;
    byte A_FSG_35_0_0_16_DataIndex_SetGet_Incr_already_pressed = 0;
    byte A_FSG_35_0_0_16_generateData_Btn_already_pressed = 0;
    byte A_FSG_35_0_0_16_loadArray_Btn_already_pressed = 0;
    _align(1) struct A_FSG_35_0_0_16_ArrayDataStruct
    {
        byte Param1;
        byte Param2;
    };
    struct A_FSG_35_0_0_16_ArrayDataStruct A_FSG_35_0_0_16_ArrayDataList[255];
    const A_FSG_35_0_0_16_ArrayDataList_Length = 255;

    const P_FSG_35_0_0_17_ID = 17;
    byte P_FSG_35_0_0_17Status_BTN_already_pressed = 0;
    char gCheckbox17[100] = "checkbox_P_FSG_35_0_0_17";
    char gErrField17[100] = "errfield_P_FSG_35_0_0_17";
    byte gP_FSG_35_0_0_17_ErrCode = 1;
    char gPanel17[100] = "panel_P_FSG_35_0_0_17";

    const P_FSG_35_0_0_18_ID = 18;
    byte P_FSG_35_0_0_18Status_BTN_already_pressed = 0;
    byte P_FSG_35_0_0_18StatusAck_BTN_already_pressed = 0;
    char gCheckbox18[100] = "checkbox_P_FSG_35_0_0_18";
    char gErrField18[100] = "errfield_P_FSG_35_0_0_18";
    byte gP_FSG_35_0_0_18_ErrCode = 1;
    char gPanel18[100] = "panel_P_FSG_35_0_0_18";

    const P_FSG_35_0_0_19_ID = 19;
    byte P_FSG_35_0_0_19Status_BTN_already_pressed = 0;
    char gCheckbox19[100] = "checkbox_P_FSG_35_0_0_19";
    char gErrField19[100] = "errfield_P_FSG_35_0_0_19";
    byte gP_FSG_35_0_0_19_ErrCode = 1;
    char gPanel19[100] = "panel_P_FSG_35_0_0_19";

    const P_FSG_35_0_0_20_ID = 20;
    byte P_FSG_35_0_0_20Status_BTN_already_pressed = 0;
    char gCheckbox20[100] = "checkbox_P_FSG_35_0_0_20";
    char gErrField20[100] = "errfield_P_FSG_35_0_0_20";
    byte gP_FSG_35_0_0_20_ErrCode = 1;
    char gPanel20[100] = "panel_P_FSG_35_0_0_20";

    const A_FSG_35_0_0_21_ID = 21;
    byte A_FSG_35_0_0_21Changed_BTN_already_pressed = 0;
    byte A_FSG_35_0_0_21Status_BTN_already_pressed = 0;
    char gCheckbox21[100] = "checkbox_A_FSG_35_0_0_21";
    char gErrField21[100] = "errfield_A_FSG_35_0_0_21";
    byte gA_FSG_35_0_0_21_ErrCode = 1;
    char gPanel21[100] = "panel_A_FSG_35_0_0_21";
    byte A_FSG_35_0_0_21_DataIndex_Decr_already_pressed = 0;
    byte A_FSG_35_0_0_21_DataIndex_Incr_already_pressed = 0;
    byte A_FSG_35_0_0_21_DataIndex_SetGet_Decr_already_pressed = 0;
    byte A_FSG_35_0_0_21_DataIndex_SetGet_Incr_already_pressed = 0;
    byte A_FSG_35_0_0_21_generateData_Btn_already_pressed = 0;
    byte A_FSG_35_0_0_21_loadArray_Btn_already_pressed = 0;
    _align(1) struct A_FSG_35_0_0_21_ArrayDataStruct
    {
        byte Param1;
        byte Param2;
        byte Param3;
    };
    struct A_FSG_35_0_0_21_ArrayDataStruct A_FSG_35_0_0_21_ArrayDataList[255];
    const A_FSG_35_0_0_21_ArrayDataList_Length = 255;

    const A_FSG_35_0_0_22_ID = 22;
    byte A_FSG_35_0_0_22Changed_BTN_already_pressed = 0;
    byte A_FSG_35_0_0_22Status_BTN_already_pressed = 0;
    char gCheckbox22[100] = "checkbox_A_FSG_35_0_0_22";
    char gErrField22[100] = "errfield_A_FSG_35_0_0_22";
    byte gA_FSG_35_0_0_22_ErrCode = 1;
    char gPanel22[100] = "panel_A_FSG_35_0_0_22";
    byte A_FSG_35_0_0_22_DataIndex_Decr_already_pressed = 0;
    byte A_FSG_35_0_0_22_DataIndex_Incr_already_pressed = 0;
    byte A_FSG_35_0_0_22_DataIndex_SetGet_Decr_already_pressed = 0;
    byte A_FSG_35_0_0_22_DataIndex_SetGet_Incr_already_pressed = 0;
    byte A_FSG_35_0_0_22_generateData_Btn_already_pressed = 0;
    byte A_FSG_35_0_0_22_loadArray_Btn_already_pressed = 0;
    _align(1) struct A_FSG_35_0_0_22_ArrayDataStruct
    {
        byte Param1;
        byte Param2;
        word Param3;
        word Param4;
        byte Param5;
    };
    struct A_FSG_35_0_0_22_ArrayDataStruct A_FSG_35_0_0_22_ArrayDataList[255];
    const A_FSG_35_0_0_22_ArrayDataList_Length = 255;

    const P_FSG_35_0_0_23_ID = 23;
    byte P_FSG_35_0_0_23Status_BTN_already_pressed = 0;
    char gCheckbox23[100] = "checkbox_P_FSG_35_0_0_23";
    char gErrField23[100] = "errfield_P_FSG_35_0_0_23";
    byte gP_FSG_35_0_0_23_ErrCode = 1;
    char gPanel23[100] = "panel_P_FSG_35_0_0_23";

    const P_FSG_35_0_0_24_ID = 24;
    byte P_FSG_35_0_0_24Status_BTN_already_pressed = 0;
    char gCheckbox24[100] = "checkbox_P_FSG_35_0_0_24";
    char gErrField24[100] = "errfield_P_FSG_35_0_0_24";
    byte gP_FSG_35_0_0_24_ErrCode = 1;
    char gPanel24[100] = "panel_P_FSG_35_0_0_24";

    const P_FSG_35_0_0_25_ID = 25;
    byte P_FSG_35_0_0_25Status_BTN_already_pressed = 0;
    char gCheckbox25[100] = "checkbox_P_FSG_35_0_0_25";
    char gErrField25[100] = "errfield_P_FSG_35_0_0_25";
    byte gP_FSG_35_0_0_25_ErrCode = 1;
    char gPanel25[100] = "panel_P_FSG_35_0_0_25";
}

on preStart
{
    char Version[200];
    char Path[255];

    /***** Erzeugen der Ausgabeconsolen *****/  
    gBAP_Trace=writecreate("BAP-Trace");        //write-window for BAP-cummunication
    writeclear(gBAP_Trace);                     //clear BAP-window in write-window
    
    gError_Trace=writecreate("Error");          //error-window for BAP-cummunication
    writeclear(gError_Trace);                   //clear error-window in write-window
    
    writeclear(1);                              //clear CAPL-window in write-window
    
    /**** Versionsstring von DLL holen und auf Bildschirm ausgeben ***/ 
    BAP150_GetVersions(Version, 200);
    writelineEx(gBAP_Trace, 0, "Versionx:%s", Version);
                                            
    NODE_INDEX = BAP150_CreateNode();
    writelineEx(gBAP_Trace, 0, "FSG %d Nodeindex:%d", LSGID, Version);
    
    /**** Laden der CANoe Datenbank *****/
    getAbsFilePath(dbc_path, Path, 255);
    writelineEx(gBAP_Trace, 0, "Load BAP_DBC-File: %s", Path);
    if(BAP150_LoadDBC(NODE_INDEX, 1, Path)  != 0) {        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
    }

    /**** Laden des BAP XML Files ****/
    getAbsFilePath(xml_path, Path, 255);
    writelineEx(gBAP_Trace, 0, "Load BAP-XML-File: %s", Path);
    if (BAP150_LoadConfig(NODE_INDEX, Path) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
    }

    if (BAP150_AddCanMap(NODE_INDEX, 1, 1) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Mappen!");
    }   
    
    // FLEXRAY NOT ENABLED!
}

DisableFctCtrl ()
{
      EnableControl(panel_name, common_panel_name, 0);
    EnableControl(panel_name,gErrField1,0);
    EnableControl(panel_name,gErrField2,0);
    EnableControl(panel_name,gErrField3,0);
    EnableControl(panel_name,gErrField4,0);
    EnableControl(panel_name,gErrField13,0);
    EnableControl(panel_name,gPanel13,0);
    EnableControl(panel_name,"panel_P_FSG_35_0_0_13",0);
    EnableControl(panel_name,gErrField14,0);
    EnableControl(panel_name,gPanel14,0);
    EnableControl(panel_name,"panel_P_FSG_35_0_0_14",0);
    EnableControl(panel_name,gErrField15,0);
    EnableControl(panel_name,gPanel15,0);
    EnableControl(panel_name,"panel_P_FSG_35_0_0_15",0);
    EnableControl(panel_name,gErrField16,0);
    EnableControl(panel_name,gPanel16,0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_16",0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Status",0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Changed",0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_16_SetGet",0);
    EnableControl(panel_name,gErrField17,0);
    EnableControl(panel_name,gPanel17,0);
    EnableControl(panel_name,"panel_P_FSG_35_0_0_17",0);
    EnableControl(panel_name,gErrField18,0);
    EnableControl(panel_name,gPanel18,0);
    EnableControl(panel_name,"panel_P_FSG_35_0_0_18",0);
    EnableControl(panel_name,gErrField19,0);
    EnableControl(panel_name,gPanel19,0);
    EnableControl(panel_name,"panel_P_FSG_35_0_0_19",0);
    EnableControl(panel_name,gErrField20,0);
    EnableControl(panel_name,gPanel20,0);
    EnableControl(panel_name,"panel_P_FSG_35_0_0_20",0);
    EnableControl(panel_name,gErrField21,0);
    EnableControl(panel_name,gPanel21,0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_21",0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Status",0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Changed",0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_21_SetGet",0);
    EnableControl(panel_name,gErrField22,0);
    EnableControl(panel_name,gPanel22,0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_22",0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Status",0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Changed",0);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_22_SetGet",0);
    EnableControl(panel_name,gErrField23,0);
    EnableControl(panel_name,gPanel23,0);
    EnableControl(panel_name,"panel_P_FSG_35_0_0_23",0);
    EnableControl(panel_name,gErrField24,0);
    EnableControl(panel_name,gPanel24,0);
    EnableControl(panel_name,"panel_P_FSG_35_0_0_24",0);
    EnableControl(panel_name,gErrField25,0);
    EnableControl(panel_name,gPanel25,0);
    EnableControl(panel_name,"panel_P_FSG_35_0_0_25",0);

}

EnableFctCtrl ()
{
      EnableControl(panel_name, common_panel_name, 1);
    if(getValue(P_FSG_35_0_0_13_FctLstItemEn)){
         EnableControl(panel_name,gPanel13,1);
         EnableControl(panel_name,gErrField13,1);
    }
    if(getValue(P_FSG_35_0_0_14_FctLstItemEn)){
         EnableControl(panel_name,gPanel14,1);
         EnableControl(panel_name,gErrField14,1);
    }
    if(getValue(P_FSG_35_0_0_15_FctLstItemEn)){
         EnableControl(panel_name,gPanel15,1);
         EnableControl(panel_name,gErrField15,1);
    }
    if(getValue(A_FSG_35_0_0_16_FctLstItemEn)){
         EnableControl(panel_name,gPanel16,1);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Status",1);
         EnableControl(panel_name,gErrField16,1);
    }
    if(getValue(P_FSG_35_0_0_17_FctLstItemEn)){
         EnableControl(panel_name,gPanel17,1);
         EnableControl(panel_name,gErrField17,1);
    }
    if(getValue(P_FSG_35_0_0_18_FctLstItemEn)){
         EnableControl(panel_name,gPanel18,1);
         EnableControl(panel_name,gErrField18,1);
    }
    if(getValue(P_FSG_35_0_0_19_FctLstItemEn)){
         EnableControl(panel_name,gPanel19,1);
         EnableControl(panel_name,gErrField19,1);
    }
    if(getValue(P_FSG_35_0_0_20_FctLstItemEn)){
         EnableControl(panel_name,gPanel20,1);
         EnableControl(panel_name,gErrField20,1);
    }
    if(getValue(A_FSG_35_0_0_21_FctLstItemEn)){
         EnableControl(panel_name,gPanel21,1);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Status",1);
         EnableControl(panel_name,gErrField21,1);
    }
    if(getValue(A_FSG_35_0_0_22_FctLstItemEn)){
         EnableControl(panel_name,gPanel22,1);
    EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Status",1);
         EnableControl(panel_name,gErrField22,1);
    }
    if(getValue(P_FSG_35_0_0_23_FctLstItemEn)){
         EnableControl(panel_name,gPanel23,1);
         EnableControl(panel_name,gErrField23,1);
    }
    if(getValue(P_FSG_35_0_0_24_FctLstItemEn)){
         EnableControl(panel_name,gPanel24,1);
         EnableControl(panel_name,gErrField24,1);
    }
    if(getValue(P_FSG_35_0_0_25_FctLstItemEn)){
         EnableControl(panel_name,gPanel25,1);
         EnableControl(panel_name,gErrField25,1);
    }

}

DisableConfigCtrl ()
{
      EnableControl(panel_name, bapconfig_panel_name, 0);
    EnableControl(panel_name, "panel4_edit", 0);
//    EnableControl(panel_name,gCheckbox1,0);
//    if(!getValue(C_FSG_35_0_0_1_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox1,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox2,0);
//    if(!getValue(P_FSG_35_0_0_2_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox2,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox3,0);
//    if(!getValue(P_FSG_35_0_0_3_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox3,MakeRGB(200,200,200));
//    }
    EnableControl(panel_name, "panel_P_FSG_35_0_0_4", 0);
//    EnableControl(panel_name,gCheckbox4,0);
//    if(!getValue(P_FSG_35_0_0_4_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox4,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox13,0);
//    if(!getValue(P_FSG_35_0_0_13_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox13,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox14,0);
//    if(!getValue(P_FSG_35_0_0_14_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox14,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox15,0);
//    if(!getValue(P_FSG_35_0_0_15_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox15,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox16,0);
//    if(!getValue(A_FSG_35_0_0_16_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox16,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox17,0);
//    if(!getValue(P_FSG_35_0_0_17_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox17,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox18,0);
//    if(!getValue(P_FSG_35_0_0_18_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox18,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox19,0);
//    if(!getValue(P_FSG_35_0_0_19_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox19,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox20,0);
//    if(!getValue(P_FSG_35_0_0_20_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox20,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox21,0);
//    if(!getValue(A_FSG_35_0_0_21_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox21,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox22,0);
//    if(!getValue(A_FSG_35_0_0_22_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox22,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox23,0);
//    if(!getValue(P_FSG_35_0_0_23_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox23,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox24,0);
//    if(!getValue(P_FSG_35_0_0_24_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox24,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox25,0);
//    if(!getValue(P_FSG_35_0_0_25_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox25,MakeRGB(200,200,200));
//    }

}

EnableConfigCtrl ()
{
      EnableControl(panel_name, bapconfig_panel_name, 1);
    EnableControl(panel_name, "panel4_edit", 1);
    if(getValue(C_FSG_35_0_0_1_FctLstItemEn))
    {
        setControlForeColor(panel_name, gCheckbox1, MakeRGB(0,240,0));
    }
    else
    {
        setControlForeColor(panel_name, gCheckbox1, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_2_FctLstItemEn))
    {
        setControlForeColor(panel_name, gCheckbox2, MakeRGB(0,240,0));
    }
    else
    {
        setControlForeColor(panel_name, gCheckbox2, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_3_FctLstItemEn))
    {
        setControlForeColor(panel_name, gCheckbox3, MakeRGB(0,240,0));
    }
    else
    {
        setControlForeColor(panel_name, gCheckbox3, MakeRGB(250,0,0));
    }
    EnableControl(panel_name, "panel_P_FSG_35_0_0_4", 1);
    if(getValue(P_FSG_35_0_0_4_FctLstItemEn))
    {
        setControlForeColor(panel_name, gCheckbox4, MakeRGB(0,240,0));
    }
    else
    {
        setControlForeColor(panel_name, gCheckbox4, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_13_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_13",1);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_13",1);
        setControlForeColor(panel_name, gCheckbox13, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_13",0);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_13",0);
        setControlForeColor(panel_name, gCheckbox13, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_14_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_14",1);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_14",1);
        setControlForeColor(panel_name, gCheckbox14, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_14",0);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_14",0);
        setControlForeColor(panel_name, gCheckbox14, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_15_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_15",1);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_15",1);
        setControlForeColor(panel_name, gCheckbox15, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_15",0);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_15",0);
        setControlForeColor(panel_name, gCheckbox15, MakeRGB(250,0,0));
    }
    if(getValue(A_FSG_35_0_0_16_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_A_FSG_35_0_0_16",1);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Status",1);
        EnableControl(panel_name,"errfield_A_FSG_35_0_0_16",1);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Changed",1);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_16_SetGet",1);
        setControlForeColor(panel_name, gCheckbox16, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_A_FSG_35_0_0_16",0);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Status",0);
        EnableControl(panel_name,"errfield_A_FSG_35_0_0_16",0);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Changed",0);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_16_SetGet",0);
        setControlForeColor(panel_name, gCheckbox16, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_17_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_17",1);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_17",1);
        setControlForeColor(panel_name, gCheckbox17, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_17",0);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_17",0);
        setControlForeColor(panel_name, gCheckbox17, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_18_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_18",1);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_18",1);
        setControlForeColor(panel_name, gCheckbox18, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_18",0);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_18",0);
        setControlForeColor(panel_name, gCheckbox18, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_19_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_19",1);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_19",1);
        setControlForeColor(panel_name, gCheckbox19, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_19",0);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_19",0);
        setControlForeColor(panel_name, gCheckbox19, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_20_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_20",1);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_20",1);
        setControlForeColor(panel_name, gCheckbox20, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_20",0);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_20",0);
        setControlForeColor(panel_name, gCheckbox20, MakeRGB(250,0,0));
    }
    if(getValue(A_FSG_35_0_0_21_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_A_FSG_35_0_0_21",1);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Status",1);
        EnableControl(panel_name,"errfield_A_FSG_35_0_0_21",1);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Changed",1);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_21_SetGet",1);
        setControlForeColor(panel_name, gCheckbox21, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_A_FSG_35_0_0_21",0);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Status",0);
        EnableControl(panel_name,"errfield_A_FSG_35_0_0_21",0);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Changed",0);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_21_SetGet",0);
        setControlForeColor(panel_name, gCheckbox21, MakeRGB(250,0,0));
    }
    if(getValue(A_FSG_35_0_0_22_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_A_FSG_35_0_0_22",1);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Status",1);
        EnableControl(panel_name,"errfield_A_FSG_35_0_0_22",1);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Changed",1);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_22_SetGet",1);
        setControlForeColor(panel_name, gCheckbox22, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_A_FSG_35_0_0_22",0);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Status",0);
        EnableControl(panel_name,"errfield_A_FSG_35_0_0_22",0);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Changed",0);
        EnableControl(panel_name,"panel_A_FSG_35_0_0_22_SetGet",0);
        setControlForeColor(panel_name, gCheckbox22, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_23_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_23",1);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_23",1);
        setControlForeColor(panel_name, gCheckbox23, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_23",0);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_23",0);
        setControlForeColor(panel_name, gCheckbox23, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_24_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_24",1);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_24",1);
        setControlForeColor(panel_name, gCheckbox24, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_24",0);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_24",0);
        setControlForeColor(panel_name, gCheckbox24, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_35_0_0_25_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_25",1);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_25",1);
        setControlForeColor(panel_name, gCheckbox25, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_35_0_0_25",0);
        EnableControl(panel_name,"errfield_P_FSG_35_0_0_25",0);
        setControlForeColor(panel_name, gCheckbox25, MakeRGB(250,0,0));
    }

}

resetErrfieldColor()
{
      setControlBackColor(panel_name, "errfield_C_FSG_35_0_0_1", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_2", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_3", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_4", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_13", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_14", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_15", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_16", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_17", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_18", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_19", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_20", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_21", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_22", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_23", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_24", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_25", MakeRGB(255,255,255));

}

CANoe_Shutdown ()
{
    // Timer: cancel real CAN-communication timer
    canceltimer(TaskTimer);
    // Ruecksetzen der Hintergrundfarbe der Error-Felder
    resetErrfieldColor();
    // Deaktivierung aller Panel Elemente 
    EnableConfigCtrl();
}

on timer TaskTimer
{
    /*** Aufruf des BAP Task in DLL fuer NODE_INDEX ***/
    BAP150_Task(NODE_INDEX);    

    /*** Pollen ueber die anstehenden Indications (Lesen aus DLL, Auslesen eines Puffers der DLL) ***/
    BAP_DLL_Indication();    
    
    /*** Pollen ueber die anstehenden Requests (Schreiben in DLL, dort werden evt. Sendeauftraege gesetzt) ***/
    BAP_DLL_Request();
    
    /*** Abarbeiten der ausstehenden Sendeauftraege innerhalb der BAP DLL und Versenden ueber CANoe ***/
    if (getValue(eSendEnabled))
    {
        BAP_CAN_TX_Request();
    }

    /*** Der Empfang von CAN Daten geschieht ueber on message CAN message Mechanismen ***/
    // keine Funktion hier

    /*** Retriggern des Timers mit 10 ms ***/
    setTimer(TaskTimer, TaskTime); // @TODO bei anderer Taskzeit muss hier modifiziert werden
}

BAP_DLL_Indication()    //function to get received BAP-data from DLL (at BAL-interface)
{
    int i, length, datalength, temp;
    byte Indication_data[BAP_buffer_size];        // indication data from DLL
    dword Indication_header[6];                    // indication header from DLL
    byte BAP_data_type;

    // init local variables
    length=0;
    datalength=0;
    temp=0;
    BAP_data_type=0;

    for(i = 0; i < 6; i++)
        Indication_header[i]=0;

    for(i = 0; i < BAP_buffer_size; i++)
        Indication_data[i]=0;

    // BAP-Stack needs this information for successful BAP150_GetIndication 
    Indication_header[4]=BAP_buffer_size;

    while (BAP150_GetInd(NODE_INDEX, Indication_header, Indication_data) == 0)
    {        
        //read header and write in global variable
        for (i = 0; i < 6; i++) {
            gBAP_Indication_header[i]=Indication_header[i];    
        }

        // nur Bytesequneces haben Datenanteil
        if (gBAP_Indication_header[3] == Bap_byteSequence)
        {
            for (i = 0; i < BAP_buffer_size; i++) {
                gBAP_Indication_data[i]=Indication_data[i];    
            }
        }    
        // Verarbeiten der Indication
        Process_Current_Indication();

        // Vorbereiten fuer naechsten Durchlauf 
        Indication_header[4]=BAP_buffer_size;
    } 
}

setBitInFctList(word fctid, byte fctList[])
{
    byte byteNo ;
    byte bitno ;
    byte fctValue ;

    byteNo = fctid / 8;
    bitno = fctid % 8;
    fctValue = 0x80 >> bitno;
    fctList[byteNo] |= fctValue;
}

float round (float value, float step)
{
    return _floor(value / step + 0.5) * step;
}

ChangeConfig(long paramIndex,long config[])
{

        byte temp ;
        temp = BAP150_ChangeConfig(NODE_INDEX, paramIndex, config);
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP150_ChangeConfig for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP150_ChangeConfig error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        
}

PrintIndicationError(char reason[])
{
    writelineEx(gError_Trace, 0, "%s - %s lsgId:%d fctid:%d indType:%d dataType:%s",
        reason, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]]);
}

initBapConfig()
{
        long config[3];
    config[0] = LSGID;
    config[1] = 0;
    config[2] = getValue(BAPCFG_FSG_35_0_0_ProtocolMajor);
    ChangeConfig(0x0012,config);
    config[2] = getValue(BAPCFG_FSG_35_0_0_ProtocolMinor);
    ChangeConfig(0x0013,config);
    config[2] = getValue(BAPCFG_FSG_35_0_0_LsgClassMajor);
    ChangeConfig(0x0010,config);
    config[2] = getValue(BAPCFG_FSG_35_0_0_LsgClassMinor);
    ChangeConfig(0x0011,config);
    config[2] = getValue(BAPCFG_FSG_35_0_0_DFMajor);
    ChangeConfig(0x0014,config);
    config[2] = getValue(BAPCFG_FSG_35_0_0_DFMinor);
    ChangeConfig(0x0015,config);
    
}

initFctList()
{
    byte fctList[8]={0,0,0,0,0,0,0,0};
    int i;
    dword request[6];
    byte errorCode;

    fctList[0]=0;
    fctList[1]=0;
    fctList[2]=0;
    fctList[3]=0;
    fctList[4]=0;
    fctList[5]=0;
    fctList[6]=0;
    fctList[7]=0;

    /*if(getValue(P_FSG_44_0_13_FunctionListId))
    {
        setBitInFctList(P_FSG_44_0_13_ID, fctList);
    }*/
           if(getValue(P_FSG_35_0_0_25_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_25_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_24_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_24_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_23_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_23_ID, fctList);
       }
       if(getValue(A_FSG_35_0_0_22_FctLstItemEn))
       {
           setBitInFctList(A_FSG_35_0_0_22_ID, fctList);
       }
       if(getValue(A_FSG_35_0_0_21_FctLstItemEn))
       {
           setBitInFctList(A_FSG_35_0_0_21_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_19_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_19_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_20_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_20_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_18_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_18_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_17_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_17_ID, fctList);
       }
       if(getValue(A_FSG_35_0_0_16_FctLstItemEn))
       {
           setBitInFctList(A_FSG_35_0_0_16_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_15_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_15_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_14_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_14_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_4_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_4_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_13_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_13_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_3_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_3_ID, fctList);
       }
       if(getValue(P_FSG_35_0_0_2_FctLstItemEn))
       {
           setBitInFctList(P_FSG_35_0_0_2_ID, fctList);
       }
       if(getValue(C_FSG_35_0_0_1_FctLstItemEn))
       {
           setBitInFctList(C_FSG_35_0_0_1_ID, fctList);
       }


    for(i=0;i<8;i++){
        writelineEx(gBAP_Trace, 0, "fctList[%d]: 0x%02x ",i,fctList[i]);
    }

    request [0]=LSGID;
    request [1]=3;
    request [3]= Bap_byteSequence;
    request [4]= 8;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,fctList);
    if(errorCode)
        writelineEx(gError_Trace, 0, "BAP150_InitSendBuf(Functionlist) returns 0x%02x ",errorCode);
}

initHeartbeat()
{
       long data[2];
   data[0]=LSGID;
   if( getValue(P_FSG_35_0_0_4_FctLstItemEn) )
      data[1]=getValue(P_FSG_35_0_0_4);
   else
      data[1]=0;
   ChangeConfig(0x00,data);
   InitSendBuf_int8(P_FSG_35_0_0_4_ID, data[1]);

}

BapOnOff(byte _on)
{
    int length, temp;

    /***** Einschalten ******/
    if(_on==1){
        // soll der BAP Stack wieder initlialisiert werden?                                 
        if(gBAP_Init==0){
            gBAP_Init=1;
            temp=BAP150_Init(NODE_INDEX, LSGID);
            if(temp==0)
                writelineEx(gBAP_Trace, 0, "BAP_Init for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
            else
                writelineEx(gError_Trace, 0, "BAP_Init error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);         
        }

        // Initialisierung aller Variablen
        Initialize_Variables();                     

        // Aktivierung aller Panelelemente
        EnableFctCtrl();
        //EnableControl(panel_name, bapconfig_panel_name, 0); // @TODO
        DisableConfigCtrl();


        //BAP-Shutdown
        temp = BAP150_Shutdown(NODE_INDEX, LSGID);
        if(temp==0)
            writelineEx(gBAP_Trace, 0, "BAP_Shutdown for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP_Shutdown error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX); 

        initBapConfig();
        initFctList();
        initHeartbeat();

        temp = BAP150_Start(NODE_INDEX, LSGID);             
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP_Start for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP_Start error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        
    
        // setze den Timer fuer den zyklischen Aufruf des CANoe-"Tasks"
        setTimer(TaskTimer, 10);                
    
        //  BAPFsg_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID, DEBUG_SWITCH_ON);    
    }
    else{ /***** Ausschalten ****/
        
        BAP150_Shutdown(NODE_INDEX,LSGID);
        
        CANoe_Shutdown();
        
        // ETHERNET NOT ENABLED! (CALL_FCT_CLOSE_UPD_SOCKET_TOKEN)
    }

}

Initialize_Variables()    //initialize/reset all global variables
{
    int temp, i;
    byte  InitSend_data[BAP_buffer_size];    // InitSend data for DLL
    dword InitSend_header[6];    // InitSend header for DLL

    /**** Request Buffer Geschichten initialisieren ****/
    for (i = 0; i < Requestbuffer_lines; i++)
    {
        gBAP_Requestbuffer_status[i] = 0;
    }    
    for (i = 0; i < BAP_buffer_size; i++)
    {
        InitSend_data[i] = 0;
    }    

    // @TODO nur FSG relevant
    /**** Es ist notwendig mittels InitSendbuffer alle Properties im FSG zu initialisieren ****/
           InitSend_header[0] = LSGID;       
       InitSend_header[1] = 13; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_35_0_0_13);
     putValue(P_FSG_35_0_0_13, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 14; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 1;
       InitSend_header[5] = 0;
       getValue(P_FSG_35_0_0_14,InitSend_data);
       putValue(P_FSG_35_0_0_14,InitSend_data, 1);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_35_0_0_14)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 15; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_35_0_0_15);
     putValue(P_FSG_35_0_0_15, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 17; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 5;
       InitSend_header[5] = 0;
       getValue(P_FSG_35_0_0_17,InitSend_data);
       putValue(P_FSG_35_0_0_17,InitSend_data, 5);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_35_0_0_17)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 18; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 2;
       InitSend_header[5] = 0;
       getValue(P_FSG_35_0_0_18,InitSend_data);
       putValue(P_FSG_35_0_0_18,InitSend_data, 2);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_35_0_0_18)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 19; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_35_0_0_19);
     putValue(P_FSG_35_0_0_19, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 20; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 3;
       InitSend_header[5] = 0;
       getValue(P_FSG_35_0_0_20,InitSend_data);
       putValue(P_FSG_35_0_0_20,InitSend_data, 3);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_35_0_0_20)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 23; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 13;
       InitSend_header[5] = 0;
       getValue(P_FSG_35_0_0_23,InitSend_data);
       putValue(P_FSG_35_0_0_23,InitSend_data, 13);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_35_0_0_23)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 24; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_35_0_0_24,InitSend_data);
       putValue(P_FSG_35_0_0_24,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_35_0_0_24)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 25; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_35_0_0_25,InitSend_data);
       putValue(P_FSG_35_0_0_25,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_35_0_0_25)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);

}

on start
{
    // noch nicht eingeschaltet
    gSG_PowerOnOff=0;
    // noch nicht initialisiert
    gBAP_Init=0;
    // open the panel, nur fuer CANoe-Version >= 5.1 erlaubt
    //openPanel(panel_name);
    // deaktiviere alle aktiven Panel Elemente, ausser AN/AUSS
    CANoe_Shutdown();
    
// ETHERNET AND FLEXRAY NOT ENABLED!
        
}

BAP_CAN_TX_Request()    //Function to send BAP-data over CAN
{
   int i;
   byte TX_Data[8];                // CAN-data
   byte TX_Data_FR[10];            // FlexRay-Data
   dword TX_Header[3];            // CAN-header
   message 0x100 TX_Message;    // dummy-message, Adresse wird noch modifiziert
   
   byte send_result;
   
   // ONLY CAN IS ENABLED! 
           TX_Header[2] = 8; // max-Length of TX_Data

        // Pollen ueber die Queue, die von der DLL zur Verfuegung gestellt wird
        // Diese Daten muessen ueber den CAN Bus gesendet werden
           while (BAP150_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) {    
            TX_Message.CAN = TX_Header[0];         //CAN channel
            TX_Message.ID =TX_Header[1];             //Can ID
            TX_Message.DLC = TX_Header[2];         // received length
            
            for (i=0; i<TX_Message.DLC; i++) {    //CAN data-bytes
                  TX_Message.byte(i) = TX_Data[i];
              }
              
              output(TX_Message);                    //send CAN message
              
              //Versions Output
              if(TX_Data[0] == 0x40 && TX_Data[1] == 0x00 && TX_Header[2] == 4)
              {
                writelineEx(gBAP_Trace, 0,"Major Version: %i, Minor Version: %i", TX_Data[2], TX_Data[3]);
              }       
              TX_Header[2] = 8; // max-Length of TX_Data
           } 
   // ONLY CAN IS ENABLED!
   // FLEXRAY NOT ENABLED! (TX_FR_TOKEN)
   // ETHERNET NOT ENABLED! (TX_IP_TOKEN)
}

ringbuffer_write (byte lsgID, byte fctID, byte request, byte dataType, word length, dword singleData, byte data[])
{
    int bufferline, i;

    bufferline = getNextWriteIndex();    //get next free position in ring-buffer

    if (bufferline == -1) 
    {
        writelineEx(gError_Trace, 0, "Crititcal Error: No free buffer found!");
        return;
    }
        
    gBAP_Request_header[bufferline][0] = lsgID;    // LSG
    gBAP_Request_header[bufferline][1] = fctID;    // FCT
    gBAP_Request_header[bufferline][3] = dataType; // dataType
    //writelineEx(gBAP_Trace, 0, "Write request in buffer FSG NODEINDEX:%d lsgid:%d fctid:%d requesttype:%d datatype:%d length:%d", 
    //        NODE_INDEX,lsgID,fctID,request,dataType,length);


    switch (dataType)
    {
        case Bap_void:
            gBAP_Request_header[bufferline][2] = request;    // request
            gBAP_Request_header[bufferline][4] = 0;    // length
                // Void
            // @TODO?        
            break;
        case Bap_uint8:
            gBAP_Request_header[bufferline][2] = request;        // request
            gBAP_Request_header[bufferline][5] = singleData;    // Daten        
            break;
        case Bap_uint16:
            gBAP_Request_header[bufferline][2] = request;        // request
            gBAP_Request_header[bufferline][5] = singleData;    // Daten
            break;            
        case Bap_uint32:
            gBAP_Request_header[bufferline][2] = request;        // request
            gBAP_Request_header[bufferline][5] = singleData;    // Daten        
            break;    
        case Bap_byteSequence:
            gBAP_Request_header[bufferline][2] = request;    // request
            gBAP_Request_header[bufferline][4] = length;    // length
            // Daten der ByteSequence kopieren
            for(i = 0; i < BAP_buffer_size; i++)                                    
                gBAP_Request_data[bufferline][i] = data[i];
        case Bap_error:
            gBAP_Request_header[bufferline][5] = singleData;    // Errorcode                        
            break;
        default:
            break;
    }

            

}

Request_void (byte lsgID, byte fctID, byte request)
{
    int i;
    byte dataArray [BAP_buffer_size];

    // Initialisieren eines Arrays
    for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

    ringbuffer_write (lsgID, fctID, request, Bap_void, 0, 0, dataArray);    
}

Request_int8 (byte lsgID, byte fctID, byte request, dword data)
{
    int i;
    byte dataArray [BAP_buffer_size];

    // Initialisieren eines Arrays
    for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

    ringbuffer_write (lsgID, fctID, request, Bap_uint8, 0, data, dataArray);

}

Request_int16 (byte lsgID, byte fctID, byte request, dword data)
{
    int i;
    byte dataArray [BAP_buffer_size];

    // Initialisieren eines Arrays
    for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

    ringbuffer_write (lsgID, fctID, request, Bap_uint16, 0, data, dataArray);

}

Request_int32 (byte lsgID, byte fctID, byte request, dword data)
{
    int i;
    byte dataArray [BAP_buffer_size];

    // Initialisieren eines Arrays
    for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

    ringbuffer_write (lsgID, fctID, request, Bap_uint32, 0, data, dataArray);
}

Request_byteSequence (byte lsgID, byte fctID, byte request, byte data[], word length)
{
    int i;
    byte dataArray [BAP_buffer_size];

    // Initialisieren eines Arrays
    for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

    // Fuellen des Arrays
    for(i=0;i<length;i++) dataArray [i]=data[i];

    ringbuffer_write (lsgID, fctID, request, Bap_byteSequence, length, 0, dataArray);
}

Request_error (byte lsgID, byte fctID, byte errorCode)
{
    int i;
    byte dataArray [BAP_buffer_size];

    // Initialisieren eines Arrays
    for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

    ringbuffer_write (lsgID, fctID, Error_REQ, Bap_error, 0, errorCode, dataArray);
}

InitSendBuf_int8 (byte fctID, dword data)
{
    dword request[6];
    int errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint8;
    request [5]= data;

    errorCode=
    BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int8 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
    
}

InitSendBuf_int16 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint16;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int16 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_int32 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int32 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_byteSequence (byte fctID, byte data[], word length)
{
    dword request[6];
    byte errorCode;

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [4]= length;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_byteSequence error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

DisplayRequestErrorCode(dword fctID, dword errCode)
{
       switch(fctID)
   {
       case C_FSG_35_0_0_1_ID:
           gC_FSG_35_0_0_1_ErrCode = 0;
           putValue(C_FSG_35_0_0_1_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_C_FSG_35_0_0_1", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_2_ID:
           gP_FSG_35_0_0_2_ErrCode = 0;
           putValue(P_FSG_35_0_0_2_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_2", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_3_ID:
           gP_FSG_35_0_0_3_ErrCode = 0;
           putValue(P_FSG_35_0_0_3_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_3", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_4_ID:
           gP_FSG_35_0_0_4_ErrCode = 0;
           putValue(P_FSG_35_0_0_4_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_4", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_13_ID:
           gP_FSG_35_0_0_13_ErrCode = 0;
           putValue(P_FSG_35_0_0_13_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_13", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_14_ID:
           gP_FSG_35_0_0_14_ErrCode = 0;
           putValue(P_FSG_35_0_0_14_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_14", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_15_ID:
           gP_FSG_35_0_0_15_ErrCode = 0;
           putValue(P_FSG_35_0_0_15_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_15", MakeRGB(255,79,79));
       break;
       case A_FSG_35_0_0_16_ID:
           gA_FSG_35_0_0_16_ErrCode = 0;
           putValue(A_FSG_35_0_0_16_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_35_0_0_16", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_17_ID:
           gP_FSG_35_0_0_17_ErrCode = 0;
           putValue(P_FSG_35_0_0_17_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_17", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_18_ID:
           gP_FSG_35_0_0_18_ErrCode = 0;
           putValue(P_FSG_35_0_0_18_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_18", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_19_ID:
           gP_FSG_35_0_0_19_ErrCode = 0;
           putValue(P_FSG_35_0_0_19_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_19", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_20_ID:
           gP_FSG_35_0_0_20_ErrCode = 0;
           putValue(P_FSG_35_0_0_20_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_20", MakeRGB(255,79,79));
       break;
       case A_FSG_35_0_0_21_ID:
           gA_FSG_35_0_0_21_ErrCode = 0;
           putValue(A_FSG_35_0_0_21_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_35_0_0_21", MakeRGB(255,79,79));
       break;
       case A_FSG_35_0_0_22_ID:
           gA_FSG_35_0_0_22_ErrCode = 0;
           putValue(A_FSG_35_0_0_22_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_35_0_0_22", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_23_ID:
           gP_FSG_35_0_0_23_ErrCode = 0;
           putValue(P_FSG_35_0_0_23_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_23", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_24_ID:
           gP_FSG_35_0_0_24_ErrCode = 0;
           putValue(P_FSG_35_0_0_24_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_24", MakeRGB(255,79,79));
       break;
       case P_FSG_35_0_0_25_ID:
           gP_FSG_35_0_0_25_ErrCode = 0;
           putValue(P_FSG_35_0_0_25_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_25", MakeRGB(255,79,79));
       break;
       default:
           writelineEx(gError_Trace, 0, "%s%d/%d Unknown Functionid in  displayErrorCode", SGtype, LSGID,fctID);
   }

}

BAP_DLL_Request ()
{
    int i;
    int l=0;
    byte temp;
    byte Request_data[4096];    //Request data for DLL
    dword Request_header[6];    //Request header for DLL
    byte dataValid;
    int nextElementToRead;
    
    // defaultmaessig ist senden OK
    dataValid = 1;

    // loeschen der Daten "Container"
    for(i=0;i<6;i++)
        Request_header[i]=0;
    for(i=0;i<BAP_buffer_size;i++)
        Request_data[i]=0;

    
    // Verarbeiten aller noch offenen Requests  
    while ((nextElementToRead = getNextReadIndex()) != -1) 
    {
        // Fuer alle Datentypen gleich
        Request_header[0]=gBAP_Request_header [nextElementToRead][0];       //LSG-ID
        Request_header[1]=gBAP_Request_header [nextElementToRead][1];       //Function-ID
        Request_header[2]=gBAP_Request_header [nextElementToRead][2];       //request type
        Request_header[3]=gBAP_Request_header [nextElementToRead][3];       //BAP data type

        switch(gBAP_Request_header[nextElementToRead][3]){
            case Bap_uint32:
                l=2;
            case Bap_uint16:
                l++;
            case Bap_uint8:
            case Bap_error: // Request (2) wird dabei ignoriert
                l++;
            case Bap_void:  // Datenfeld (5) wird dabei ignoriert
                Request_header[4]=l;                                                //  not used
                Request_header[5]=gBAP_Request_header [nextElementToRead][5];       // Daten
            break;
            case Bap_byteSequence:                                  
                Request_header[4]=gBAP_Request_header [nextElementToRead][4];       // length
                Request_header[5]=0;                                                // not used

                // data-array for BAP-DLL funcion 'BAP_Request'
                for(i=0;i<BAP_buffer_size;i++)
                    Request_data[i]=gBAP_Request_data [nextElementToRead][i];
                break;          
            default:
                writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Request_header[nextElementToRead][3]);
                dataValid = 0;
            break;          
        }
        
        if(dataValid){
            // wie heisst der Request?
            writelineEx(gBAP_Trace, 0, "%s%d/%d BAP_Request %s datatype:%s length:%d", SGtype, Request_header[0],Request_header[1],Requesttype_Text[Request_header[2]],Datatype_Text[Request_header[3]],Request_header[4]);
            temp = BAP150_Request(NODE_INDEX, Request_header, Request_data);    //send data to BAP-DLL  
            // BAP-Request failed
            if(temp != 0){
                // Fehlercode: Request failed
                writelineEx(gError_Trace, 0, "%s%d/%d Error during BAP_Request errorcode: 0x%X", SGtype, Request_header[0],Request_header[1],temp);
                DisplayRequestErrorCode(Request_header[1],temp);
            } 
        }

    }
} 

int getNextReadIndex ()
{
    int i, ret;
    // der Puffer wird nach dem naechsten zu lesenden Eintrag durchsucht
    // Existiert keiner wird -1 zurueckgegeben
    ret = -1;

    for (i = 0; i < Requestbuffer_lines; i++)
    {
        if (gBAP_Requestbuffer_status[i] == 1)
        {
            // zum verschicken
            ret = i;
            // und wieder freigeben
            gBAP_Requestbuffer_status[i] = 0;
            break;
        }
    }

    return (ret);
}

int getNextWriteIndex ()
{
    int i, ret;
    // der Puffer wird nach dem naechsten freien Eintrag durchsucht
    // Existiert keiner wird -1 zurueckgegeben
    ret = -1;

    for (i = 0; i < Requestbuffer_lines; i++)
    {
        if (gBAP_Requestbuffer_status[i] == 0)
        {
            // zum schreiben
            ret = i;
            // belegen
            gBAP_Requestbuffer_status[i] = 1;
            break;
        }
    }

    return (ret);
}

//gBAP_Indication_header[0])  // LSGID
//gBAP_Indication_header[1]) // FCTID
//gBAP_Indication_header[2]) // IndType
//gBAP_Indication_header[3]) // Datentyp



Process_Current_Indication ()
{
   int rxsize;
   int txsize;
   byte temp[BAP_buffer_size];
   char buffer[BAP_buffer_size];
   if(strncmp(Datatype_Text[gBAP_Indication_header[3]], "acknowledge", 4)!=0) 
       writelineEx(gBAP_Trace, 0, "NodeIndex: %d: CurrentIndication %s lsgid:%d fctid:%d indType:%s dataType=%s length=%d",
               NODE_INDEX, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   else 
       writelineEx(gBAP_Trace, 0, "Internal acknowledge %s-%d fctid:%d indType:%s dataType=%s length=%d",
               SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Acknowledgetype_Text[gBAP_Indication_header[5]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   switch(gBAP_Indication_header[0])  // LSGID
   {
   case LSGID:
       switch(gBAP_Indication_header[1]) // FCTID
       {
    case P_FSG_35_0_0_13_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_35_0_0_13_ErrEn)) { 
                               Request_error(LSGID,P_FSG_35_0_0_13_ID,getValue(P_FSG_35_0_0_13_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_35_0_0_13, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_13", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_35_0_0_13_ErrEn)) { 
                               Request_error(LSGID,P_FSG_35_0_0_13_ID,getValue(P_FSG_35_0_0_13_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_35_0_0_13, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_13", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_35_0_0_13_ID, Data_REQ, getValue(P_FSG_35_0_0_13));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_35_0_0_13_ErrCode = 0;
                putValue(P_FSG_35_0_0_13_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_13", MakeRGB(255,79,79));  
                gP_FSG_35_0_0_13_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_35_0_0_14_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_35_0_0_14_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_14", MakeRGB(255,79,79));  
                gP_FSG_35_0_0_14_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_35_0_0_15_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_35_0_0_15_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_15", MakeRGB(255,79,79));  
                gP_FSG_35_0_0_15_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_35_0_0_16_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_35_0_0_16_ErrEn)) { 
                               Request_error(LSGID,A_FSG_35_0_0_16_ID,getValue(A_FSG_35_0_0_16_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_35_0_0_16_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_35_0_0_16_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_16", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_35_0_0_16_ErrEn)) { 
                               Request_error(LSGID,A_FSG_35_0_0_16_ID,getValue(A_FSG_35_0_0_16_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_35_0_0_16_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_35_0_0_16_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_16", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_35_0_0_16, temp);
                    //Request_byteSequence(LSGID, A_FSG_35_0_0_16_ID, Data_REQ, temp, getValueSize(A_FSG_35_0_0_16));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_35_0_0_16Status_BTN, 1);
                    //putValue(A_FSG_35_0_0_16Status_BTN, 0);
                    A_FSG_35_0_0_16_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_35_0_0_16_ErrEn)) { 
                               Request_error(LSGID,A_FSG_35_0_0_16_ID,getValue(A_FSG_35_0_0_16_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_35_0_0_16_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_35_0_0_16_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_16", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_35_0_0_16, temp);
                    //Request_byteSequence(LSGID, A_FSG_35_0_0_16_ID, Data_REQ, temp, getValueSize(A_FSG_35_0_0_16));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_35_0_0_16Status_BTN, 1);
                    //putValue(A_FSG_35_0_0_16Status_BTN, 0);
                    A_FSG_35_0_0_16_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_35_0_0_16_ErrCode = 0;
                putValue(A_FSG_35_0_0_16_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_16", MakeRGB(255,79,79));  
                gA_FSG_35_0_0_16_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_35_0_0_17_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_35_0_0_17_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_17", MakeRGB(255,79,79));  
                gP_FSG_35_0_0_17_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_35_0_0_18_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_35_0_0_18_ErrEn)) { 
                           Request_error(LSGID,P_FSG_35_0_0_18_ID,getValue(P_FSG_35_0_0_18_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_35_0_0_18, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_18", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_35_0_0_18_ErrEn)) { 
                           Request_error(LSGID,P_FSG_35_0_0_18_ID,getValue(P_FSG_35_0_0_18_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_35_0_0_18, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_18", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_35_0_0_18, temp);
                        Request_byteSequence(LSGID, P_FSG_35_0_0_18_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                     case Ack_IND: // Indication pruefen
                         //write("ASG hat Ack geschickt (BYTESEQUENCE)");
                        putValue(P_FSG_35_0_0_18_Ack, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_18", MakeRGB(255,255,255));  
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_35_0_0_18_ErrCode = 0;
                putValue(P_FSG_35_0_0_18_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_18", MakeRGB(255,79,79));  
                gP_FSG_35_0_0_18_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_35_0_0_19_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_35_0_0_19_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_19", MakeRGB(255,79,79));  
                gP_FSG_35_0_0_19_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_35_0_0_20_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_35_0_0_20_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_20", MakeRGB(255,79,79));  
                gP_FSG_35_0_0_20_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_35_0_0_21_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_35_0_0_21_ErrEn)) { 
                               Request_error(LSGID,A_FSG_35_0_0_21_ID,getValue(A_FSG_35_0_0_21_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_35_0_0_21_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_35_0_0_21_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_21", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_35_0_0_21_ErrEn)) { 
                               Request_error(LSGID,A_FSG_35_0_0_21_ID,getValue(A_FSG_35_0_0_21_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_35_0_0_21_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_35_0_0_21_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_21", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_35_0_0_21, temp);
                    //Request_byteSequence(LSGID, A_FSG_35_0_0_21_ID, Data_REQ, temp, getValueSize(A_FSG_35_0_0_21));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_35_0_0_21Status_BTN, 1);
                    //putValue(A_FSG_35_0_0_21Status_BTN, 0);
                    A_FSG_35_0_0_21_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_35_0_0_21_ErrEn)) { 
                               Request_error(LSGID,A_FSG_35_0_0_21_ID,getValue(A_FSG_35_0_0_21_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_35_0_0_21_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_35_0_0_21_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_21", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_35_0_0_21, temp);
                    //Request_byteSequence(LSGID, A_FSG_35_0_0_21_ID, Data_REQ, temp, getValueSize(A_FSG_35_0_0_21));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_35_0_0_21Status_BTN, 1);
                    //putValue(A_FSG_35_0_0_21Status_BTN, 0);
                    A_FSG_35_0_0_21_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_35_0_0_21_ErrCode = 0;
                putValue(A_FSG_35_0_0_21_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_21", MakeRGB(255,79,79));  
                gA_FSG_35_0_0_21_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_35_0_0_22_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_35_0_0_22_ErrEn)) { 
                               Request_error(LSGID,A_FSG_35_0_0_22_ID,getValue(A_FSG_35_0_0_22_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_35_0_0_22_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_35_0_0_22_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_22", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_35_0_0_22_ErrEn)) { 
                               Request_error(LSGID,A_FSG_35_0_0_22_ID,getValue(A_FSG_35_0_0_22_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_35_0_0_22_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_35_0_0_22_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_22", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_35_0_0_22, temp);
                    //Request_byteSequence(LSGID, A_FSG_35_0_0_22_ID, Data_REQ, temp, getValueSize(A_FSG_35_0_0_22));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_35_0_0_22Status_BTN, 1);
                    //putValue(A_FSG_35_0_0_22Status_BTN, 0);
                    A_FSG_35_0_0_22_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_35_0_0_22_ErrEn)) { 
                               Request_error(LSGID,A_FSG_35_0_0_22_ID,getValue(A_FSG_35_0_0_22_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_35_0_0_22_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_35_0_0_22_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_22", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_35_0_0_22, temp);
                    //Request_byteSequence(LSGID, A_FSG_35_0_0_22_ID, Data_REQ, temp, getValueSize(A_FSG_35_0_0_22));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_35_0_0_22Status_BTN, 1);
                    //putValue(A_FSG_35_0_0_22Status_BTN, 0);
                    A_FSG_35_0_0_22_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_35_0_0_22_ErrCode = 0;
                putValue(A_FSG_35_0_0_22_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_35_0_0_22", MakeRGB(255,79,79));  
                gA_FSG_35_0_0_22_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_35_0_0_23_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_35_0_0_23_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_23", MakeRGB(255,79,79));  
                gP_FSG_35_0_0_23_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_35_0_0_24_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_35_0_0_24_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_24", MakeRGB(255,79,79));  
                gP_FSG_35_0_0_24_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_35_0_0_25_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_35_0_0_25_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_35_0_0_25", MakeRGB(255,79,79));  
                gP_FSG_35_0_0_25_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
       default:
           writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal Fct: lsgid:%d fctid:%d indType:%d",
           NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], gBAP_Indication_header[2]);
           break;
       }
       break;
   default:
       writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal LSGID: lsgid:%d fctid:%d indType:%s", NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]]);
       break;
   }
}

/*
on message BAP_BCmE_ASG_02
{
   int i, temp;
   byte RX_Data[8];            // received CAN-DATA
   dword RX_Header[3];         // received CAN-Header
   if(gSG_PowerOnOff==Power_on){
       RX_Header[0]=this.CAN;
       RX_Header[1]=this.ID;
       RX_Header[2]=this.DLC; // received length
       for (i=0; i<this.DLC; i++) {
           RX_Data[i]=this.byte(i);
       }
        //MR61529 - start
        //temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    
         switch ((RX_Data[1] & 0x0F))
        {
        //getAll
        case 1: //error
                if (getValue(C_FSG_35_0_0_1_ErrEn)==0x01)
                Request_error(LSGID,FctID_GetAll,getValue(C_FSG_35_0_0_1_ErrCode)); 
                
                else if (getValue(C_FSG_35_0_0_1_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 2: //error
                if (getValue(P_FSG_35_0_0_2_ErrEn)==0x01)
                Request_error(LSGID,FctID_BAP_Config,getValue(P_FSG_35_0_0_2_ErrCode)); 

                else if (getValue(P_FSG_35_0_0_2_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 3: //error
                if (getValue(P_FSG_35_0_0_3_ErrEn)==0x01)
                Request_error(LSGID,FctID_FunctionList,getValue(P_FSG_35_0_0_3_ErrCode)); 
                
                else if (getValue(P_FSG_35_0_0_3_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);
                break;
             
        
        default: temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    //send recieved CAN-data with CAN-header to BAP-DLL
                break;
        }
        //MR61529 - end
   }
}
*/

on message BAP_BCmE_ASG_01
{
   int i, temp;
   byte RX_Data[8];            // received CAN-DATA
   dword RX_Header[3];         // received CAN-Header
   if(gSG_PowerOnOff==Power_on){
       RX_Header[0]=this.CAN;
       RX_Header[1]=this.ID;
       RX_Header[2]=this.DLC; // received length
       for (i=0; i<this.DLC; i++) {
           RX_Data[i]=this.byte(i);
       }
        //MR61529 - start
        //temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    
         switch ((RX_Data[1] & 0x0F))
        {
        //getAll
        case 1: //error
                if (getValue(C_FSG_35_0_0_1_ErrEn)==0x01)
                Request_error(LSGID,FctID_GetAll,getValue(C_FSG_35_0_0_1_ErrCode)); 
                
                else if (getValue(C_FSG_35_0_0_1_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 2: //error
                if (getValue(P_FSG_35_0_0_2_ErrEn)==0x01)
                Request_error(LSGID,FctID_BAP_Config,getValue(P_FSG_35_0_0_2_ErrCode)); 

                else if (getValue(P_FSG_35_0_0_2_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 3: //error
                if (getValue(P_FSG_35_0_0_3_ErrEn)==0x01)
                Request_error(LSGID,FctID_FunctionList,getValue(P_FSG_35_0_0_3_ErrCode)); 
                
                else if (getValue(P_FSG_35_0_0_3_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);
                break;
             
        
        default: temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    //send recieved CAN-data with CAN-header to BAP-DLL
                break;
        }
        //MR61529 - end
   }
}



intertelegram_err(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=1;
    data[3]=940;
    ChangeConfig(0x0020,data);
}

sequence_err(long fctId, long size)
{
    long data[5];
    long lastSeg;

    lastSeg = size-5;

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=lastSeg/7+1;
    data[3]=1;
    data[4]=(lastSeg/7+4) & 15;
    ChangeConfig(0x0021,data);
}

intertelegram_err_off(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    ChangeConfig(0x0020,data);
}

sequence_err_off(long fctId)
{
    long data[5];

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    data[4]=0;
    ChangeConfig(0x0021,data);
}

// START OF BUS CONFIG PANEL CAPL

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_BUS_SELECTOR_PANEL_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_CAN_FRAME_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_FR_FRAME_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_ETHERNET_FRAME_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_IP_FORMAT_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ON_ENVVAR_BUSTYPE_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_ETHERNET_APPLY_BTN_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_ETHERNET_RESET_BTN_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_IP_INTERFACE_LIST_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_IP_FORMAT_TOKEN)

// ETHERNET NOT ENABLED! (ON_UDP_RECEIVE_FROM_TOKEN)

// ETHERNET NOT ENABLED!

on envVar ON_OFF_FSG35_0
{
   BapOnOff(getvalue(this));
   gSG_PowerOnOff=getvalue(ON_OFF_FSG35_0);
}
on envVar BAPCFG_FSG_35_0_0_DFMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 9, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_35_0_0_DFMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 10, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_35_0_0_LsgClassMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 5, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_35_0_0_LsgClassMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 6, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_35_0_0_ProtocolMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 7, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_35_0_0_ProtocolMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 8, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID C_FSG_35_0_0_1_ID
on envVar C_FSG_35_0_0_1_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_C_FSG_35_0_0_1", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_C_FSG_35_0_0_1", MakeRGB(250,0,0));
       }
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_35_0_0_2_ID
on envVar P_FSG_35_0_0_2_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_2", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_2", MakeRGB(250,0,0));
       }
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_2_ErrCode
{
       if(gP_FSG_35_0_0_2_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_2", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_2_ErrCode = 1;
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_35_0_0_3_ID
on envVar P_FSG_35_0_0_3_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_3", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_3", MakeRGB(250,0,0));
       }
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_3_ErrCode
{
       if(gP_FSG_35_0_0_3_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_3", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_3_ErrCode = 1;
}
// De-Aktivierung der Eingabefelder der HB-FCT P_FSG_35_0_0_4
on envVar P_FSG_35_0_0_4_FctLstItemEn
{
       if(getValue(this)) 
       {
//           EnableControl(panel_name,"panel_FSG_35_0_0_4",1);
//           EnableControl(panel_name,"${ERRFIELD}",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_4_HBEn",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_4", MakeRGB(0,240,0));
       }
       else
       {
//           EnableControl(panel_name,"panel_FSG_35_0_0_4",0);
//           EnableControl(panel_name,"${ERRFIELD}",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_4_HBEn",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_4", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_35_0_0_4_FctEn
{
    long data[2];
    if(getValue(P_FSG_35_0_0_4_FctEn)>0)
    {
        data[0] = 35;
        data[1] = getValue(P_FSG_35_0_0_4);
        write("enable HB");
    }
    else
    {
        data[0] = 35;
        data[1] = 0;
        write("disable HB");
    }
    ChangeConfig(0x00, data);
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_4_ErrCode
{
       if(gP_FSG_35_0_0_4_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_4", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_4_ErrCode = 1;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_13_ErrCode
{
       if(gP_FSG_35_0_0_13_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_13", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_13_ErrCode = 1;
}
on envVar P_FSG_35_0_0_13Status_BTN
{
    if (P_FSG_35_0_0_13Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_35_0_0_13_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_13",MakeRGB(255,255,255));
       P_FSG_35_0_0_13Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_35_0_0_13_ID, Data_REQ, getValue(P_FSG_35_0_0_13));
      P_FSG_35_0_0_13Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_35_0_0_13_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_35_0_0_13_ID;
    data[2]=getValue(P_FSG_35_0_0_13_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_35_0_0_13
on envVar P_FSG_35_0_0_13_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_13",1);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_13",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_13",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_13", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_13",0);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_13",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_13",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_13", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_35_0_0_13 // bus value of FSG_Control (13).
{
    // opcodes: Error-Status
    byte param1; // Controlcode
    // DATATYPE_UINTXX
    param1 = getValue(P_FSG_35_0_0_13);
    putValue(P_FSG_35_0_0_13_1, param1);
}

on envVar P_FSG_35_0_0_13_1_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert, 
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Controlcode
    bitval= getValue(this);
    thisval = getValue(P_FSG_35_0_0_13_1);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_35_0_0_13_1,thisval);
}

on envVar P_FSG_35_0_0_13_1 // FSG_Control.Controlcode
{
    byte superval;

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // Controlcode
    thisval = getValue(this);
    if(thisval&(mask<<4))
        putValue(P_FSG_35_0_0_13_1_4, 1);
    else
        putValue(P_FSG_35_0_0_13_1_4, 0);

    // Update superval
    superval = getValue(P_FSG_35_0_0_13);
    superval = thisval;
    putValue(P_FSG_35_0_0_13,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_14_ErrCode
{
       if(gP_FSG_35_0_0_14_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_14", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_14_ErrCode = 1;
}
on envVar P_FSG_35_0_0_14Status_BTN
{
    byte BAPTemp[1];
   if (P_FSG_35_0_0_14Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_35_0_0_14_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_14",MakeRGB(255,255,255));
      P_FSG_35_0_0_14Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_35_0_0_14, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_35_0_0_14_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_35_0_0_14));
      P_FSG_35_0_0_14Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_35_0_0_14_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_35_0_0_14_ID;
    data[2]=getValue(P_FSG_35_0_0_14_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_35_0_0_14
on envVar P_FSG_35_0_0_14_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_14",1);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_14",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_14",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_14", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_14",0);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_14",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_14",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_14", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_35_0_0_14 // bus value of FSG_Setup (14).
{
    // opcodes: Error-Status
    byte param1; // PrimaryEngineType
    byte param2; // SecondaryEngineType
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    int i;
    byte superval[1];
    int currentPos;
    currentPos = 0;
    for( i = 0; i < 1; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_35_0_0_14, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(P_FSG_35_0_0_14_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(P_FSG_35_0_0_14_2, param2);
}

on envVar P_FSG_35_0_0_14_1 // FSG_Setup.PrimaryEngineType
{
    byte superval[1];

    //Update Childvalue (Enum)
    byte thisval; // PrimaryEngineType
    thisval = 0x0f & getValue(this);

    // Update superval
    getValue(P_FSG_35_0_0_14, superval);
    superval[0]= superval[0]&0x0f;
    superval[0]= superval[0]|(thisval<<4);
    putValue(P_FSG_35_0_0_14,superval);
}

on envVar P_FSG_35_0_0_14_2 // FSG_Setup.SecondaryEngineType
{
    byte superval[1];

    //Update Childvalue (Enum)
    byte thisval; // SecondaryEngineType
    thisval = 0x0f & getValue(this);

    // Update superval
    getValue(P_FSG_35_0_0_14, superval);
    superval[0]= superval[0]&0xf0;
    superval[0]= superval[0]|thisval;
    putValue(P_FSG_35_0_0_14,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_15_ErrCode
{
       if(gP_FSG_35_0_0_15_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_15", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_15_ErrCode = 1;
}
on envVar P_FSG_35_0_0_15Status_BTN
{
    if (P_FSG_35_0_0_15Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_35_0_0_15_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_15",MakeRGB(255,255,255));
       P_FSG_35_0_0_15Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_35_0_0_15_ID, Data_REQ, getValue(P_FSG_35_0_0_15));
      P_FSG_35_0_0_15Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_35_0_0_15_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_35_0_0_15_ID;
    data[2]=getValue(P_FSG_35_0_0_15_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_35_0_0_15
on envVar P_FSG_35_0_0_15_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_15",1);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_15",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_15",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_15", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_15",0);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_15",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_15",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_15", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_35_0_0_15 // bus value of FSG_OperationState (15).
{
    // opcodes: Error-Status
    byte param1; // OP_State
    // DATATYPE_UINTXX
    param1 = getValue(P_FSG_35_0_0_15);
    putValue(P_FSG_35_0_0_15_1, param1);
}

on envVar P_FSG_35_0_0_15_1 // FSG_OperationState.OP_State
{
    byte superval;

    //Update Childvalue (Enum)
    byte thisval; // OP_State
    thisval = getValue(this);

    // Update superval
    superval = getValue(P_FSG_35_0_0_15);
    superval = thisval;
    putValue(P_FSG_35_0_0_15,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_35_0_0_16_ErrCode
{
       if(gA_FSG_35_0_0_16_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_35_0_0_16", MakeRGB(255,255,255));
       }
       gA_FSG_35_0_0_16_ErrCode = 1;
}
on envVar A_FSG_35_0_0_16Changed_BTN
{
    byte data[24]; 
    byte stringValue[24];
    byte head[5];
    int i;
    int headLength;
    long tempValue;
    word currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_35_0_0_16Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_35_0_0_16_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_35_0_0_16",MakeRGB(255,255,255));
        A_FSG_35_0_0_16Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_35_0_0_16_Changed);
        getValue(A_FSG_35_0_0_16_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_35_0_0_16_Changed_Start);
     elementsVal = getValue(A_FSG_35_0_0_16_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_35_0_0_16_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 16");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_35_0_0_16_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_35_0_0_16_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 16");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_35_0_0_16_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_35_0_0_16_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_35_0_0_16_ID);
       }
       if(getValue(A_FSG_35_0_0_16_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_35_0_0_16_ID,getValueSize(A_FSG_35_0_0_16_Changed));
       }
        A_FSG_35_0_0_16Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_35_0_0_16Status_BTN
{
    byte data[24]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[24];
    byte head[5];
    int i = 0;
    int j = 0;
    long StringLength = 0;
    int headLength;
    long tempValue;
    word currentPos;

    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_35_0_0_16Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_35_0_0_16_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_35_0_0_16",MakeRGB(255,255,255));
        A_FSG_35_0_0_16Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_35_0_0_16_1);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_35_0_0_16);
        getValue(A_FSG_35_0_0_16,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_35_0_0_16_Start);
     elementsVal = getValue(A_FSG_35_0_0_16_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_35_0_0_16_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 16");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_16_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_16_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_16_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_16_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_16_ArrayDataList[i].Param2 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_35_0_0_16_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_35_0_0_16_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 16");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_16_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_16_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_16_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_16_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_16_ArrayDataList[i].Param2 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_35_0_0_16, data);
        Request_ByteSequence(LSGID, A_FSG_35_0_0_16_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_35_0_0_16_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_35_0_0_16_ID);
        }
        if(getValue(A_FSG_35_0_0_16_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_35_0_0_16_ID,getValueSize(A_FSG_35_0_0_16));
        }
        A_FSG_35_0_0_16Status_BTN_already_pressed = 0;
    }
}
A_FSG_35_0_0_16_SendStatus()
{
    word currentPos;
    word headLength;
    int i;
    int j;
    word StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[24];
    byte stringValue[24];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_35_0_0_16_1);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_35_0_0_16);
        getValue(A_FSG_35_0_0_16,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_35_0_0_16_Start);
     elementsVal = getValue(A_FSG_35_0_0_16_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_35_0_0_16_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 16");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_16_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_16_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_16_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_16_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_16_ArrayDataList[i].Param2 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_35_0_0_16_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_35_0_0_16_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 16");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_16_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_16_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_16_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_16_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_16_ArrayDataList[i].Param2 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_35_0_0_16_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_35_0_0_16
{
    byte temp[24];
    getValue(A_FSG_35_0_0_16, temp);
    putValue(A_FSG_35_0_0_16_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_35_0_0_16_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_35_0_0_16_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_35_0_0_16_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_35_0_0_16_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_35_0_0_16_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_35_0_0_16_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_35_0_0_16_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_35_0_0_16_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_35_0_0_16_IndexSize))
    {
        putValue(A_FSG_35_0_0_16_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_35_0_0_16_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_35_0_0_16_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_35_0_0_16_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_35_0_0_16_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_35_0_0_16_RecAdr) > 0x0F)
        putValue(A_FSG_35_0_0_16_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_35_0_0_16_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_35_0_0_16_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_35_0_0_16_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_35_0_0_16_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_35_0_0_16_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_35_0_0_16_Start) & 0xFF;
        head[2] = (getValue(A_FSG_35_0_0_16_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_35_0_0_16_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_35_0_0_16_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_35_0_0_16_Start) & 0xFF;
        head[2] = getValue(A_FSG_35_0_0_16_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_35_0_0_16, head, headLength); 
}

on envVar A_FSG_35_0_0_16_RecAdr
{
    A_FSG_35_0_0_16_GenerateStatus();
}

on envVar A_FSG_35_0_0_16_Shift
{
    A_FSG_35_0_0_16_GenerateStatus();
}

on envVar A_FSG_35_0_0_16_Direction
{
    A_FSG_35_0_0_16_GenerateStatus();
}

on envVar A_FSG_35_0_0_16_Start
{
    A_FSG_35_0_0_16_GenerateStatus();
}

on envVar A_FSG_35_0_0_16_Elements
{
    A_FSG_35_0_0_16_GenerateStatus();
}

on envVar A_FSG_35_0_0_16_IndexSize
{
    A_FSG_35_0_0_16_GenerateStatus();
}
on envVar A_FSG_35_0_0_16_TransPos
{
    A_FSG_35_0_0_16_GenerateStatus();
}
A_FSG_35_0_0_16_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_35_0_0_16_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_35_0_0_16_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_35_0_0_16_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_35_0_0_16_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_35_0_0_16_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_35_0_0_16_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_35_0_0_16_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_35_0_0_16_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_35_0_0_16_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_35_0_0_16_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_35_0_0_16_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_35_0_0_16_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_35_0_0_16_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_35_0_0_16_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_35_0_0_16_Changed, head, 3); 
    }
}

on envVar A_FSG_35_0_0_16_Changed_RecAdr
{
    A_FSG_35_0_0_16_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_16_Changed_Shift
{
    A_FSG_35_0_0_16_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_16_Changed_Direction
{
    A_FSG_35_0_0_16_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_16_Changed_Start
{
    A_FSG_35_0_0_16_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_16_Changed_Elements
{
    A_FSG_35_0_0_16_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_16_Changed_IndexSize
{
    A_FSG_35_0_0_16_Changed_GenerateChanged();
}
on envVar A_FSG_35_0_0_16_Changed_TransPos
{
    A_FSG_35_0_0_16_Changed_GenerateChanged();
}
on envVar A_FSG_35_0_0_16_SetGet
{
    byte temp[24];
    getValue(A_FSG_35_0_0_16_SetGet, temp);
    putValue(A_FSG_35_0_0_16_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_35_0_0_16_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_35_0_0_16_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_35_0_0_16_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_35_0_0_16_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_35_0_0_16_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_35_0_0_16_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_35_0_0_16_SetGet_IndexSize))
    {
        putValue(A_FSG_35_0_0_16_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_35_0_0_16_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_35_0_0_16_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_35_0_0_16_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_35_0_0_16_LoadArray()
{
    /********* Statische Deklarationen ***********/
    dword CSVfileHandle;
    dword filePos;
    dword paramPos;
    dword Num_of_csv_byte;
    dword element;
    dword current_CSV_line;
    byte buffer_byte[0xFFFF];
    dword i;
    dword j;
    char CSV_filename[255];

    /********* Param Puffer Deklarationen ***********/
    char temp1[25];
    char temp2[25];

    /********* Initialisierungen ***********/
    CSVfileHandle = 0;
    filePos = 0;
    paramPos = 0;
    Num_of_csv_byte = 0;
    element = 1;
    current_CSV_line = 0;
    for(i = 0; i < A_FSG_35_0_0_16_ArrayDataList_Length; i++)
    { /* Initialisierung von den Ziel-Strukturen */
        A_FSG_35_0_0_16_ArrayDataList[i].Param1 = 0;
        A_FSG_35_0_0_16_ArrayDataList[i].Param2 = 0;
    }

    /********* Laden der CSV-Datei ***********/
    getValue(A_FSG_35_0_0_16_fileSelector, CSV_filename);
    CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

    if (CSVfileHandle!=0) //*.csv file access successful
    {
        writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
        //get data from *.csv and store the total number of byte in *.csv-file
        Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

        for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
        {
            if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
            {
                //nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
                {
                    if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
                    {
                        A_FSG_35_0_0_16_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
                        A_FSG_35_0_0_16_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //ConsumerIdentifier
                        for(i = 0; i < 25; i++)
                        { /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
                            temp1[i]=0;
                            temp2[i]=0;
                        }
                    }
                    current_CSV_line++; //next line in *.csv file
                    element = 1; //start at 'POS' (first record element of "array data")
                    paramPos = 0; //reset value
                }
                 //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                else if(current_CSV_line > 0 && current_CSV_line < 256)
                {
                    //writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
                    switch (element)
                    {
                        case 1: //Pos
                                if( paramPos >= elCount(temp1) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp1[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 2: //ConsumerIdentifier
                                if( paramPos >= elCount(temp2) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp2[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        default:
                        break;
                    }
                }
            }
            else  // ";" is detected ->next record element of "array data"
            {
                //writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
                element++;
                paramPos=0; //reset value
            }
        }

        if(fileClose (CSVfileHandle) !=0) //close *.csv file
            writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
        else
            writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
        writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
    }
}

on envVar A_FSG_35_0_0_16_loadArray_Btn
{
    char filePath[255];
    if (A_FSG_35_0_0_16_generateData_Btn_already_pressed == 0)
    {
        A_FSG_35_0_0_16_generateData_Btn_already_pressed = 1;
    }
    else
    {
        A_FSG_35_0_0_16_generateData_Btn_already_pressed = 0;
        getValue(A_FSG_35_0_0_16_fileSelector, filePath);
        if(0 == strlen(filePath))
        {
            writelineEx(gBAP_Trace, 0, "Invalid file path!");
        }
        else
        {
            A_FSG_35_0_0_16_LoadArray();
            writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
        }
    }
    putValue(A_FSG_35_0_0_16_Data_1, A_FSG_35_0_0_16_ArrayDataList[ getValue( A_FSG_35_0_0_16_DataIndex) ].Param1);
    putValue(A_FSG_35_0_0_16_Data_2, A_FSG_35_0_0_16_ArrayDataList[ getValue( A_FSG_35_0_0_16_DataIndex) ].Param2);
}


on envVar A_FSG_35_0_0_16_generateData_Btn
{
    word i;
    dword elementsArray[2] = {1, 1};
    byte elementsTypeArray[2] = {0, 0};
    dword elementsMaxSizeArray[2] = {255, 0xFF};
    byte tempArray[510];
    if (A_FSG_35_0_0_16_generateData_Btn_already_pressed == 0)
    {
        A_FSG_35_0_0_16_generateData_Btn_already_pressed = 1;
    }
    else
    {
        initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 16, 255 );
        for(i = 0; i < 255; i++)
        {
            memcpy(A_FSG_35_0_0_16_ArrayDataList[i], tempArray, (i * 2) );
        }
        A_FSG_35_0_0_16_generateData_Btn_already_pressed = 0;
    }
    putValue(A_FSG_35_0_0_16_Data_1, A_FSG_35_0_0_16_ArrayDataList[ getValue( A_FSG_35_0_0_16_DataIndex) ].Param1);
    putValue(A_FSG_35_0_0_16_Data_2, A_FSG_35_0_0_16_ArrayDataList[ getValue( A_FSG_35_0_0_16_DataIndex) ].Param2);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_35_0_0_16_DataIndex
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_35_0_0_16_Data_1, A_FSG_35_0_0_16_ArrayDataList[index].Param1);
    putValue(A_FSG_35_0_0_16_Data_2, A_FSG_35_0_0_16_ArrayDataList[index].Param2);

}
on envVar A_FSG_35_0_0_16_DataIndex_Incr
{
    long index;
    if(A_FSG_35_0_0_16_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_35_0_0_16_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_35_0_0_16_DataIndex);
        index++;
        putValue(A_FSG_35_0_0_16_DataIndex, index);
        A_FSG_35_0_0_16_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_35_0_0_16_DataIndex_Decr
{
    long index;
    if(A_FSG_35_0_0_16_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_35_0_0_16_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_35_0_0_16_DataIndex);
        index--;
        putValue(A_FSG_35_0_0_16_DataIndex, index);
        A_FSG_35_0_0_16_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_35_0_0_16_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_35_0_0_16_ID;
    data[2]=getValue(A_FSG_35_0_0_16_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_35_0_0_16
on envVar A_FSG_35_0_0_16_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_16",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_35_0_0_16",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_16",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_16_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_35_0_0_16", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_16",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_35_0_0_16",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_16",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_16_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_35_0_0_16", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_35_0_0_16_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_35_0_0_16_SegmEn,0);
           intertelegram_err(A_FSG_35_0_0_16_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_35_0_0_16_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_35_0_0_16_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_35_0_0_16_IntTlgEn,0);
           sequence_err(A_FSG_35_0_0_16_ID,getValueSize(A_FSG_35_0_0_16_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_35_0_0_16_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_35_0_0_16_AT
{
    if(getValue(this))
    {
        EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Status",0);
    }
    else
    {
       EnableControl(panel_name,"panel_A_FSG_35_0_0_16_Status",1);
     }
}



A_FSG_35_0_0_16_SetInd () { /* leere Function*/ }

A_FSG_35_0_0_16_SetGetInd () { /* leere Function*/ }

A_FSG_35_0_0_16_GetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[24];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_35_0_0_16_SetGet, head, 5);
                if(getValue(A_FSG_35_0_0_16_AT))
                {
                    putValue(A_FSG_35_0_0_16,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_35_0_0_16_SetGet, head, 3);
            if(getValue(A_FSG_35_0_0_16_AT))
            {
                putValue(A_FSG_35_0_0_16,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_35_0_0_16_AT))
        {
            putValue(A_FSG_35_0_0_16_RecAdr,recordAddressVal);
            putValue(A_FSG_35_0_0_16_Start, startVal);
            putValue(A_FSG_35_0_0_16_Elements, elementsVal);
            putValue(A_FSG_35_0_0_16_TransPos, transmitPosVal);
        }
    }
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_16_1_range // Consumer.TotalNumListElements 
{
    @A_FSG_35_0_0_16_1 = @A_FSG_35_0_0_16_1_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_16_1
{
    byte superval[24];

    //Update Childvalue (Number)
    byte thisval; // TotalNumListElements
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_16_1, 1.0);
    @A_FSG_35_0_0_16_1_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_16_Data_1_range // Consumer.Pos 
{
    @A_FSG_35_0_0_16_Data_1 = @A_FSG_35_0_0_16_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_16_Data_1
{
    byte superval[24];

    //Update Childvalue (Number)
    byte thisval; // Pos
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_16_Data_1, 1.0);
    @A_FSG_35_0_0_16_Data_1_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_35_0_0_16_ArrayDataList[getValue(A_FSG_35_0_0_16_DataIndex)].Param1 = thisval;
}
on envVar A_FSG_35_0_0_16_Data_2
{
    byte superval[24];

    //Update Childvalue (Enum)
    byte thisval; // ConsumerIdentifier
    thisval = getValue(this);
    A_FSG_35_0_0_16_ArrayDataList[getValue(A_FSG_35_0_0_16_DataIndex)].Param2 = thisval;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_17_ErrCode
{
       if(gP_FSG_35_0_0_17_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_17", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_17_ErrCode = 1;
}
on envVar P_FSG_35_0_0_17Status_BTN
{
    byte BAPTemp[5];
   if (P_FSG_35_0_0_17Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_35_0_0_17_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_17",MakeRGB(255,255,255));
      P_FSG_35_0_0_17Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_35_0_0_17, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_35_0_0_17_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_35_0_0_17));
      P_FSG_35_0_0_17Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_35_0_0_17_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_35_0_0_17_ID;
    data[2]=getValue(P_FSG_35_0_0_17_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_35_0_0_17
on envVar P_FSG_35_0_0_17_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_17",1);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_17",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_17",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_17", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_17",0);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_17",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_17",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_17", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_35_0_0_17 // bus value of Consumption (17).
{
    // opcodes: Error-Status
    word param1; // ConsumptionValue
    word param2; // MaxConsumptionValue
    byte param3; // ConsumptionUnit
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    int i;
    byte superval[5];
    int currentPos;
    currentPos = 0;
    for( i = 0; i < 5; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_35_0_0_17, superval);
    ///////// Start param1 - UINT16 /////////
    param1 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_17_1, round((param1 * 0.001) - (0) + (0), 0.001));
    ///////// Start param2 - UINT16 /////////
    param2 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_17_2, round((param2 * 0.001) - (0) + (0), 0.001));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_35_0_0_17_3, param3);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_17_1_range // Consumption.ConsumptionValue 
{
    @P_FSG_35_0_0_17_1 = @P_FSG_35_0_0_17_1_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_17_1 // Consumption.ConsumptionValue
{
    byte superval[5];

    //Update Childvalue (Number)
    word thisval; // ConsumptionValue
    float slider_value;

    slider_value = round(@P_FSG_35_0_0_17_1, 0.001);
    @P_FSG_35_0_0_17_1_range = slider_value + (0); // real value := slider value + range min.
    thisval = (word)round((slider_value + (0) - (0)) / (0.001), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_17, superval);
    superval[0]=thisval&0x00ff;
    superval[1]=(thisval&0xff00)>>8;
    putValue(P_FSG_35_0_0_17,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_17_2_range // Consumption.MaxConsumptionValue 
{
    @P_FSG_35_0_0_17_2 = @P_FSG_35_0_0_17_2_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_17_2 // Consumption.MaxConsumptionValue
{
    byte superval[5];

    //Update Childvalue (Number)
    word thisval; // MaxConsumptionValue
    float slider_value;

    slider_value = round(@P_FSG_35_0_0_17_2, 0.001);
    @P_FSG_35_0_0_17_2_range = slider_value + (0); // real value := slider value + range min.
    thisval = (word)round((slider_value + (0) - (0)) / (0.001), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_17, superval);
    superval[2]=thisval&0x00ff;
    superval[3]=(thisval&0xff00)>>8;
    putValue(P_FSG_35_0_0_17,superval);
}

on envVar P_FSG_35_0_0_17_3 // Consumption.ConsumptionUnit
{
    byte superval[5];

    //Update Childvalue (Enum)
    byte thisval; // ConsumptionUnit
    thisval = getValue(this);

    // Update superval
    getValue(P_FSG_35_0_0_17, superval);
    superval[4]=thisval;
    putValue(P_FSG_35_0_0_17,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_18_ErrCode
{
       if(gP_FSG_35_0_0_18_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_18", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_18_ErrCode = 1;
}
on envVar P_FSG_35_0_0_18Status_BTN
{
    byte BAPTemp[2];
   if (P_FSG_35_0_0_18Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_35_0_0_18_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_18",MakeRGB(255,255,255));
      P_FSG_35_0_0_18Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_35_0_0_18, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_35_0_0_18_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_35_0_0_18));
      P_FSG_35_0_0_18Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_35_0_0_18StatusAck_BTN
{
    byte BAPTemp[2];
   if (P_FSG_35_0_0_18StatusAck_BTN_already_pressed == 0)
   {
      putValue(P_FSG_35_0_0_18_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_18",MakeRGB(255,255,255));
      P_FSG_35_0_0_18StatusAck_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_35_0_0_18, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_35_0_0_18_ID, DataAck_REQ, BAPTemp, getValueSize(P_FSG_35_0_0_18));
      P_FSG_35_0_0_18StatusAck_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_35_0_0_18_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_35_0_0_18_ID;
    data[2]=getValue(P_FSG_35_0_0_18_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_35_0_0_18
on envVar P_FSG_35_0_0_18_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_18",1);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_18",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_18",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_18", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_18",0);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_18",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_18",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_18", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_35_0_0_18 // bus value of LiveTip (18).
{
    // opcodes: Error-Status-StatusAck
    byte param1; // LiveTipIdentifier
    byte param2; // Confirmation
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    int i;
    byte superval[2];
    int currentPos;
    currentPos = 0;
    for( i = 0; i < 2; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_35_0_0_18, superval);
    ///////// Start param1 - UINT8 /////////
    param1 = superval[currentPos++];
    putValue(P_FSG_35_0_0_18_1, param1);
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_35_0_0_18_2, param2);
}

on envVar P_FSG_35_0_0_18_1 // LiveTip.LiveTipIdentifier
{
    byte superval[2];

    //Update Childvalue (Enum)
    byte thisval; // LiveTipIdentifier
    thisval = getValue(this);

    // Update superval
    getValue(P_FSG_35_0_0_18, superval);
    superval[0]=thisval;
    putValue(P_FSG_35_0_0_18,superval);
}

on envVar P_FSG_35_0_0_18_2_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert, 
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Confirmation
    bitval= getValue(this);
    thisval = getValue(P_FSG_35_0_0_18_2);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_35_0_0_18_2,thisval);
}

on envVar P_FSG_35_0_0_18_2 // LiveTip.Confirmation
{
    byte superval[2];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // Confirmation
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_35_0_0_18_2_0, 1);
    else
        putValue(P_FSG_35_0_0_18_2_0, 0);

    // Update superval
    getValue(P_FSG_35_0_0_18, superval);
    superval[1]=thisval;
    putValue(P_FSG_35_0_0_18,superval);
}

on envVar P_FSG_35_0_0_18_Ack // bus value of LiveTip (18).
{
    // opcodes: Error-Status-StatusAck
    byte param1; // LiveTipIdentifier
    byte param2; // Confirmation
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    int i;
    byte superval[2];
    int currentPos;
    currentPos = 0;
    for( i = 0; i < 2; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_35_0_0_18_Ack, superval);
    ///////// Start param1 - UINT8 /////////
    param1 = superval[currentPos++];
    putValue(P_FSG_35_0_0_18_Ack_1, param1);
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_35_0_0_18_Ack_2, param2);
}

on envVar P_FSG_35_0_0_18_Ack_1 // LiveTip.LiveTipIdentifier
{
    byte superval[2];

    //Update Childvalue (Enum)
    byte thisval; // LiveTipIdentifier
    thisval = getValue(this);

    // Update superval
    getValue(P_FSG_35_0_0_18_Ack, superval);
    superval[0]=thisval;
    putValue(P_FSG_35_0_0_18_Ack,superval);
}

on envVar P_FSG_35_0_0_18_Ack_2_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert, 
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Confirmation
    bitval= getValue(this);
    thisval = getValue(P_FSG_35_0_0_18_Ack_2);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_35_0_0_18_Ack_2,thisval);
}

on envVar P_FSG_35_0_0_18_Ack_2 // LiveTip.Confirmation
{
    byte superval[2];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // Confirmation
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_35_0_0_18_Ack_2_0, 1);
    else
        putValue(P_FSG_35_0_0_18_Ack_2_0, 0);

    // Update superval
    getValue(P_FSG_35_0_0_18_Ack, superval);
    superval[1]=thisval;
    putValue(P_FSG_35_0_0_18_Ack,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_19_ErrCode
{
       if(gP_FSG_35_0_0_19_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_19", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_19_ErrCode = 1;
}
on envVar P_FSG_35_0_0_19Status_BTN
{
    if (P_FSG_35_0_0_19Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_35_0_0_19_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_19",MakeRGB(255,255,255));
       P_FSG_35_0_0_19Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_35_0_0_19_ID, Data_REQ, getValue(P_FSG_35_0_0_19));
      P_FSG_35_0_0_19Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_35_0_0_19_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_35_0_0_19_ID;
    data[2]=getValue(P_FSG_35_0_0_19_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_35_0_0_19
on envVar P_FSG_35_0_0_19_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_19",1);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_19",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_19",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_19", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_19",0);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_19",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_19",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_19", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_35_0_0_19 // bus value of EnergyFlowComfort (19).
{
    // opcodes: Error-Status
    byte param1; // ComfortConsumer
    // DATATYPE_UINTXX
    param1 = getValue(P_FSG_35_0_0_19);
    putValue(P_FSG_35_0_0_19_1, param1);
}

on envVar P_FSG_35_0_0_19_1_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert, 
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // ComfortConsumer
    bitval= getValue(this);
    thisval = getValue(P_FSG_35_0_0_19_1);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_35_0_0_19_1,thisval);
}

on envVar P_FSG_35_0_0_19_1_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert, 
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // ComfortConsumer
    bitval= getValue(this);
    thisval = getValue(P_FSG_35_0_0_19_1);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_35_0_0_19_1,thisval);
}

on envVar P_FSG_35_0_0_19_1 // EnergyFlowComfort.ComfortConsumer
{
    byte superval;

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // ComfortConsumer
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_35_0_0_19_1_0, 1);
    else
        putValue(P_FSG_35_0_0_19_1_0, 0);
    if(thisval&(mask<<1))
        putValue(P_FSG_35_0_0_19_1_1, 1);
    else
        putValue(P_FSG_35_0_0_19_1_1, 0);

    // Update superval
    superval = getValue(P_FSG_35_0_0_19);
    superval = thisval;
    putValue(P_FSG_35_0_0_19,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_20_ErrCode
{
       if(gP_FSG_35_0_0_20_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_20", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_20_ErrCode = 1;
}
on envVar P_FSG_35_0_0_20Status_BTN
{
    byte BAPTemp[3];
   if (P_FSG_35_0_0_20Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_35_0_0_20_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_20",MakeRGB(255,255,255));
      P_FSG_35_0_0_20Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_35_0_0_20, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_35_0_0_20_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_35_0_0_20));
      P_FSG_35_0_0_20Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_35_0_0_20_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_35_0_0_20_ID;
    data[2]=getValue(P_FSG_35_0_0_20_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_35_0_0_20
on envVar P_FSG_35_0_0_20_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_20",1);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_20",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_20",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_20", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_20",0);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_20",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_20",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_20", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_35_0_0_20 // bus value of RangeGainTotal (20).
{
    // opcodes: Error-Status
    word param1; // RangeGainTotalValue
    byte param2; // Range_Unit
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    int i;
    byte superval[3];
    int currentPos;
    currentPos = 0;
    for( i = 0; i < 3; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_35_0_0_20, superval);
    ///////// Start param1 - UINT16 /////////
    param1 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_20_1, round((param1 * 0.01) - (0) + (0), 0.01));
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_35_0_0_20_2, param2);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_20_1_range // RangeGainTotal.RangeGainTotalValue 
{
    @P_FSG_35_0_0_20_1 = @P_FSG_35_0_0_20_1_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_20_1 // RangeGainTotal.RangeGainTotalValue
{
    byte superval[3];

    //Update Childvalue (Number)
    word thisval; // RangeGainTotalValue
    float slider_value;

    slider_value = round(@P_FSG_35_0_0_20_1, 0.01);
    @P_FSG_35_0_0_20_1_range = slider_value + (0); // real value := slider value + range min.
    thisval = (word)round((slider_value + (0) - (0)) / (0.01), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_20, superval);
    superval[0]=thisval&0x00ff;
    superval[1]=(thisval&0xff00)>>8;
    putValue(P_FSG_35_0_0_20,superval);
}

on envVar P_FSG_35_0_0_20_2 // RangeGainTotal.Range_Unit
{
    byte superval[3];

    //Update Childvalue (Enum)
    byte thisval; // Range_Unit
    thisval = getValue(this);

    // Update superval
    getValue(P_FSG_35_0_0_20, superval);
    superval[2]=thisval;
    putValue(P_FSG_35_0_0_20,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_35_0_0_21_ErrCode
{
       if(gA_FSG_35_0_0_21_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_35_0_0_21", MakeRGB(255,255,255));
       }
       gA_FSG_35_0_0_21_ErrCode = 1;
}
on envVar A_FSG_35_0_0_21Changed_BTN
{
    byte data[35]; 
    byte stringValue[35];
    byte head[5];
    int i;
    int headLength;
    long tempValue;
    word currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_35_0_0_21Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_35_0_0_21_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_35_0_0_21",MakeRGB(255,255,255));
        A_FSG_35_0_0_21Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_35_0_0_21_Changed);
        getValue(A_FSG_35_0_0_21_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_35_0_0_21_Changed_Start);
     elementsVal = getValue(A_FSG_35_0_0_21_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_35_0_0_21_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 21");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_35_0_0_21_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_35_0_0_21_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 21");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_35_0_0_21_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_35_0_0_21_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_35_0_0_21_ID);
       }
       if(getValue(A_FSG_35_0_0_21_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_35_0_0_21_ID,getValueSize(A_FSG_35_0_0_21_Changed));
       }
        A_FSG_35_0_0_21Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_35_0_0_21Status_BTN
{
    byte data[35 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[35];
    byte head[5];
    int i = 0;
    int j = 0;
    long StringLength = 0;
    int headLength;
    long tempValue;
    word currentPos;

    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_35_0_0_21Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_35_0_0_21_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_35_0_0_21",MakeRGB(255,255,255));
        A_FSG_35_0_0_21Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_35_0_0_21_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_35_0_0_21_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_35_0_0_21_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_35_0_0_21);
        getValue(A_FSG_35_0_0_21,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_35_0_0_21_Start);
     elementsVal = getValue(A_FSG_35_0_0_21_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_35_0_0_21_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 21");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_21_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_21_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_21_RecAdr ) || 1 == getValue( A_FSG_35_0_0_21_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable ConsumptionRelative:
      if( 0 || 0 == getValue( A_FSG_35_0_0_21_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param3 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_35_0_0_21_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_35_0_0_21_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 21");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_21_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_21_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_21_RecAdr ) || 1 == getValue( A_FSG_35_0_0_21_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable ConsumptionRelative:
      if( 0 || 0 == getValue( A_FSG_35_0_0_21_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param3 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_35_0_0_21, data);
        Request_ByteSequence(LSGID, A_FSG_35_0_0_21_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_35_0_0_21_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_35_0_0_21_ID);
        }
        if(getValue(A_FSG_35_0_0_21_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_35_0_0_21_ID,getValueSize(A_FSG_35_0_0_21));
        }
        A_FSG_35_0_0_21Status_BTN_already_pressed = 0;
    }
}
A_FSG_35_0_0_21_SendStatus()
{
    word currentPos;
    word headLength;
    int i;
    int j;
    word StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[35];
    byte stringValue[35];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_35_0_0_21_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_35_0_0_21_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_35_0_0_21_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_35_0_0_21);
        getValue(A_FSG_35_0_0_21,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_35_0_0_21_Start);
     elementsVal = getValue(A_FSG_35_0_0_21_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_35_0_0_21_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 21");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_21_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_21_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_21_RecAdr ) || 1 == getValue( A_FSG_35_0_0_21_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable ConsumptionRelative:
      if( 0 || 0 == getValue( A_FSG_35_0_0_21_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param3 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_35_0_0_21_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_35_0_0_21_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 21");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_21_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_21_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_21_RecAdr ) || 1 == getValue( A_FSG_35_0_0_21_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable ConsumptionRelative:
      if( 0 || 0 == getValue( A_FSG_35_0_0_21_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_21_ArrayDataList[i].Param3 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_35_0_0_21_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_35_0_0_21
{
    byte temp[35];
    getValue(A_FSG_35_0_0_21, temp);
    putValue(A_FSG_35_0_0_21_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_35_0_0_21_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_35_0_0_21_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_35_0_0_21_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_35_0_0_21_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_35_0_0_21_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_35_0_0_21_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_35_0_0_21_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_35_0_0_21_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_35_0_0_21_IndexSize))
    {
        putValue(A_FSG_35_0_0_21_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_35_0_0_21_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_35_0_0_21_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_35_0_0_21_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_35_0_0_21_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_35_0_0_21_RecAdr) > 0x0F)
        putValue(A_FSG_35_0_0_21_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_35_0_0_21_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_35_0_0_21_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_35_0_0_21_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_35_0_0_21_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_35_0_0_21_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_35_0_0_21_Start) & 0xFF;
        head[2] = (getValue(A_FSG_35_0_0_21_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_35_0_0_21_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_35_0_0_21_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_35_0_0_21_Start) & 0xFF;
        head[2] = getValue(A_FSG_35_0_0_21_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_35_0_0_21, head, headLength); 
}

on envVar A_FSG_35_0_0_21_RecAdr
{
    A_FSG_35_0_0_21_GenerateStatus();
}

on envVar A_FSG_35_0_0_21_Shift
{
    A_FSG_35_0_0_21_GenerateStatus();
}

on envVar A_FSG_35_0_0_21_Direction
{
    A_FSG_35_0_0_21_GenerateStatus();
}

on envVar A_FSG_35_0_0_21_Start
{
    A_FSG_35_0_0_21_GenerateStatus();
}

on envVar A_FSG_35_0_0_21_Elements
{
    A_FSG_35_0_0_21_GenerateStatus();
}

on envVar A_FSG_35_0_0_21_IndexSize
{
    A_FSG_35_0_0_21_GenerateStatus();
}
on envVar A_FSG_35_0_0_21_TransPos
{
    A_FSG_35_0_0_21_GenerateStatus();
}
A_FSG_35_0_0_21_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_35_0_0_21_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_35_0_0_21_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_35_0_0_21_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_35_0_0_21_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_35_0_0_21_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_35_0_0_21_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_35_0_0_21_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_35_0_0_21_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_35_0_0_21_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_35_0_0_21_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_35_0_0_21_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_35_0_0_21_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_35_0_0_21_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_35_0_0_21_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_35_0_0_21_Changed, head, 3); 
    }
}

on envVar A_FSG_35_0_0_21_Changed_RecAdr
{
    A_FSG_35_0_0_21_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_21_Changed_Shift
{
    A_FSG_35_0_0_21_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_21_Changed_Direction
{
    A_FSG_35_0_0_21_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_21_Changed_Start
{
    A_FSG_35_0_0_21_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_21_Changed_Elements
{
    A_FSG_35_0_0_21_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_21_Changed_IndexSize
{
    A_FSG_35_0_0_21_Changed_GenerateChanged();
}
on envVar A_FSG_35_0_0_21_Changed_TransPos
{
    A_FSG_35_0_0_21_Changed_GenerateChanged();
}
on envVar A_FSG_35_0_0_21_SetGet
{
    byte temp[35];
    getValue(A_FSG_35_0_0_21_SetGet, temp);
    putValue(A_FSG_35_0_0_21_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_35_0_0_21_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_35_0_0_21_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_35_0_0_21_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_35_0_0_21_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_35_0_0_21_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_35_0_0_21_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_35_0_0_21_SetGet_IndexSize))
    {
        putValue(A_FSG_35_0_0_21_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_35_0_0_21_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_35_0_0_21_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_35_0_0_21_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_35_0_0_21_LoadArray()
{
    /********* Statische Deklarationen ***********/
    dword CSVfileHandle;
    dword filePos;
    dword paramPos;
    dword Num_of_csv_byte;
    dword element;
    dword current_CSV_line;
    byte buffer_byte[0xFFFF];
    dword i;
    dword j;
    char CSV_filename[255];

    /********* Param Puffer Deklarationen ***********/
    char temp1[25];
    char temp2[25];
    char temp3[25];

    /********* Initialisierungen ***********/
    CSVfileHandle = 0;
    filePos = 0;
    paramPos = 0;
    Num_of_csv_byte = 0;
    element = 1;
    current_CSV_line = 0;
    for(i = 0; i < A_FSG_35_0_0_21_ArrayDataList_Length; i++)
    { /* Initialisierung von den Ziel-Strukturen */
        A_FSG_35_0_0_21_ArrayDataList[i].Param1 = 0;
        A_FSG_35_0_0_21_ArrayDataList[i].Param2 = 0;
        A_FSG_35_0_0_21_ArrayDataList[i].Param3 = 0;
    }

    /********* Laden der CSV-Datei ***********/
    getValue(A_FSG_35_0_0_21_fileSelector, CSV_filename);
    CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

    if (CSVfileHandle!=0) //*.csv file access successful
    {
        writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
        //get data from *.csv and store the total number of byte in *.csv-file
        Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

        for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
        {
            if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
            {
                //nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
                {
                    if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
                    {
                        A_FSG_35_0_0_21_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
                        A_FSG_35_0_0_21_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //ConsumerIdentifier
                        A_FSG_35_0_0_21_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //ConsumptionRelative
                        for(i = 0; i < 25; i++)
                        { /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
                            temp1[i]=0;
                            temp2[i]=0;
                            temp3[i]=0;
                        }
                    }
                    current_CSV_line++; //next line in *.csv file
                    element = 1; //start at 'POS' (first record element of "array data")
                    paramPos = 0; //reset value
                }
                 //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                else if(current_CSV_line > 0 && current_CSV_line < 256)
                {
                    //writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
                    switch (element)
                    {
                        case 1: //Pos
                                if( paramPos >= elCount(temp1) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp1[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 2: //ConsumerIdentifier
                                if( paramPos >= elCount(temp2) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp2[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 3: //ConsumptionRelative
                                if( paramPos >= elCount(temp3) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp3[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        default:
                        break;
                    }
                }
            }
            else  // ";" is detected ->next record element of "array data"
            {
                //writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
                element++;
                paramPos=0; //reset value
            }
        }

        if(fileClose (CSVfileHandle) !=0) //close *.csv file
            writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
        else
            writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
        writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
    }
}

on envVar A_FSG_35_0_0_21_loadArray_Btn
{
    char filePath[255];
    if (A_FSG_35_0_0_21_generateData_Btn_already_pressed == 0)
    {
        A_FSG_35_0_0_21_generateData_Btn_already_pressed = 1;
    }
    else
    {
        A_FSG_35_0_0_21_generateData_Btn_already_pressed = 0;
        getValue(A_FSG_35_0_0_21_fileSelector, filePath);
        if(0 == strlen(filePath))
        {
            writelineEx(gBAP_Trace, 0, "Invalid file path!");
        }
        else
        {
            A_FSG_35_0_0_21_LoadArray();
            writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
        }
    }
    putValue(A_FSG_35_0_0_21_Data_1, A_FSG_35_0_0_21_ArrayDataList[ getValue( A_FSG_35_0_0_21_DataIndex) ].Param1);
    putValue(A_FSG_35_0_0_21_Data_2, A_FSG_35_0_0_21_ArrayDataList[ getValue( A_FSG_35_0_0_21_DataIndex) ].Param2);
    putValue(A_FSG_35_0_0_21_Data_3, A_FSG_35_0_0_21_ArrayDataList[ getValue( A_FSG_35_0_0_21_DataIndex) ].Param3);
}


on envVar A_FSG_35_0_0_21_generateData_Btn
{
    word i;
    dword elementsArray[3] = {1, 1, 1};
    byte elementsTypeArray[3] = {0, 0, 0};
    dword elementsMaxSizeArray[3] = {255, 0xFF, 100};
    byte tempArray[765];
    if (A_FSG_35_0_0_21_generateData_Btn_already_pressed == 0)
    {
        A_FSG_35_0_0_21_generateData_Btn_already_pressed = 1;
    }
    else
    {
        initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 21, 255 );
        for(i = 0; i < 255; i++)
        {
            memcpy(A_FSG_35_0_0_21_ArrayDataList[i], tempArray, (i * 3) );
        }
        A_FSG_35_0_0_21_generateData_Btn_already_pressed = 0;
    }
    putValue(A_FSG_35_0_0_21_Data_1, A_FSG_35_0_0_21_ArrayDataList[ getValue( A_FSG_35_0_0_21_DataIndex) ].Param1);
    putValue(A_FSG_35_0_0_21_Data_2, A_FSG_35_0_0_21_ArrayDataList[ getValue( A_FSG_35_0_0_21_DataIndex) ].Param2);
    putValue(A_FSG_35_0_0_21_Data_3, A_FSG_35_0_0_21_ArrayDataList[ getValue( A_FSG_35_0_0_21_DataIndex) ].Param3);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_35_0_0_21_DataIndex
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_35_0_0_21_Data_1, A_FSG_35_0_0_21_ArrayDataList[index].Param1);
    putValue(A_FSG_35_0_0_21_Data_2, A_FSG_35_0_0_21_ArrayDataList[index].Param2);
    putValue(A_FSG_35_0_0_21_Data_3, A_FSG_35_0_0_21_ArrayDataList[index].Param3);

}
on envVar A_FSG_35_0_0_21_DataIndex_Incr
{
    long index;
    if(A_FSG_35_0_0_21_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_35_0_0_21_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_35_0_0_21_DataIndex);
        index++;
        putValue(A_FSG_35_0_0_21_DataIndex, index);
        A_FSG_35_0_0_21_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_35_0_0_21_DataIndex_Decr
{
    long index;
    if(A_FSG_35_0_0_21_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_35_0_0_21_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_35_0_0_21_DataIndex);
        index--;
        putValue(A_FSG_35_0_0_21_DataIndex, index);
        A_FSG_35_0_0_21_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_35_0_0_21_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_35_0_0_21_ID;
    data[2]=getValue(A_FSG_35_0_0_21_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_35_0_0_21
on envVar A_FSG_35_0_0_21_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_21",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_35_0_0_21",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_21",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_21_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_35_0_0_21", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_21",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_35_0_0_21",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_21",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_21_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_35_0_0_21", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_35_0_0_21_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_35_0_0_21_SegmEn,0);
           intertelegram_err(A_FSG_35_0_0_21_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_35_0_0_21_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_35_0_0_21_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_35_0_0_21_IntTlgEn,0);
           sequence_err(A_FSG_35_0_0_21_ID,getValueSize(A_FSG_35_0_0_21_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_35_0_0_21_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_35_0_0_21_AT
{
    if(getValue(this))
    {
        EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Status",0);
    }
    else
    {
       EnableControl(panel_name,"panel_A_FSG_35_0_0_21_Status",1);
     }
}



A_FSG_35_0_0_21_SetInd () { /* leere Function*/ }

A_FSG_35_0_0_21_SetGetInd () { /* leere Function*/ }

A_FSG_35_0_0_21_GetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[35];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_35_0_0_21_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_35_0_0_21_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_35_0_0_21_SetGet, head, 5);
                if(getValue(A_FSG_35_0_0_21_AT))
                {
                    putValue(A_FSG_35_0_0_21,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_35_0_0_21_SetGet, head, 3);
            if(getValue(A_FSG_35_0_0_21_AT))
            {
                putValue(A_FSG_35_0_0_21,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_35_0_0_21_AT))
        {
            putValue(A_FSG_35_0_0_21_RecAdr,recordAddressVal);
            putValue(A_FSG_35_0_0_21_Start, startVal);
            putValue(A_FSG_35_0_0_21_Elements, elementsVal);
            putValue(A_FSG_35_0_0_21_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_35_0_0_21_1
{
    byte superval[35];

    //Update Childvalue (Enum)
    byte thisval; // ASG_ID
    thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_21_2_range // ConsumerListConsumption.TAID 
{
    @A_FSG_35_0_0_21_2 = @A_FSG_35_0_0_21_2_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_21_2
{
    byte superval[35];

    //Update Childvalue (Number)
    byte thisval; // TAID
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_21_2, 1.0);
    @A_FSG_35_0_0_21_2_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_21_3_range // ConsumerListConsumption.TotalNumListElements 
{
    @A_FSG_35_0_0_21_3 = @A_FSG_35_0_0_21_3_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_21_3
{
    byte superval[35];

    //Update Childvalue (Number)
    byte thisval; // TotalNumListElements
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_21_3, 1.0);
    @A_FSG_35_0_0_21_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_21_Data_1_range // ConsumerListConsumption.Pos 
{
    @A_FSG_35_0_0_21_Data_1 = @A_FSG_35_0_0_21_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_21_Data_1
{
    byte superval[35];

    //Update Childvalue (Number)
    byte thisval; // Pos
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_21_Data_1, 1.0);
    @A_FSG_35_0_0_21_Data_1_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_35_0_0_21_ArrayDataList[getValue(A_FSG_35_0_0_21_DataIndex)].Param1 = thisval;
}
on envVar A_FSG_35_0_0_21_Data_2
{
    byte superval[35];

    //Update Childvalue (Enum)
    byte thisval; // ConsumerIdentifier
    thisval = getValue(this);
    A_FSG_35_0_0_21_ArrayDataList[getValue(A_FSG_35_0_0_21_DataIndex)].Param2 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_21_Data_3_range // ConsumerListConsumption.ConsumptionRelative 
{
    @A_FSG_35_0_0_21_Data_3 = @A_FSG_35_0_0_21_Data_3_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_21_Data_3
{
    byte superval[35];

    //Update Childvalue (Number)
    byte thisval; // ConsumptionRelative
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_21_Data_3, 0.5);
    @A_FSG_35_0_0_21_Data_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (0.5), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_35_0_0_21_ArrayDataList[getValue(A_FSG_35_0_0_21_DataIndex)].Param3 = thisval;
}
on envVar A_FSG_35_0_0_21_1_SetGet
{
    byte superval[4];

    //Update Childvalue (Enum)
    byte thisval; // ASG_ID
    thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_21_2_SetGet_range // ConsumerListConsumption.TAID 
{
    @A_FSG_35_0_0_21_2_SetGet = @A_FSG_35_0_0_21_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_21_2_SetGet
{
    byte superval[4];

    //Update Childvalue (Number)
    byte thisval; // TAID
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_21_2_SetGet, 1.0);
    @A_FSG_35_0_0_21_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_35_0_0_22_ErrCode
{
       if(gA_FSG_35_0_0_22_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_35_0_0_22", MakeRGB(255,255,255));
       }
       gA_FSG_35_0_0_22_ErrCode = 1;
}
on envVar A_FSG_35_0_0_22Changed_BTN
{
    byte data[75]; 
    byte stringValue[75];
    byte head[5];
    int i;
    int headLength;
    long tempValue;
    word currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_35_0_0_22Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_35_0_0_22_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_35_0_0_22",MakeRGB(255,255,255));
        A_FSG_35_0_0_22Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_35_0_0_22_Changed);
        getValue(A_FSG_35_0_0_22_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_35_0_0_22_Changed_Start);
     elementsVal = getValue(A_FSG_35_0_0_22_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_35_0_0_22_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 22");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_35_0_0_22_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_35_0_0_22_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 22");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_35_0_0_22_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_35_0_0_22_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_35_0_0_22_ID);
       }
       if(getValue(A_FSG_35_0_0_22_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_35_0_0_22_ID,getValueSize(A_FSG_35_0_0_22_Changed));
       }
        A_FSG_35_0_0_22Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_35_0_0_22Status_BTN
{
    byte data[75 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[75];
    byte head[5];
    int i = 0;
    int j = 0;
    long StringLength = 0;
    int headLength;
    long tempValue;
    word currentPos;

    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_35_0_0_22Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_35_0_0_22_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_35_0_0_22",MakeRGB(255,255,255));
        A_FSG_35_0_0_22Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_35_0_0_22_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_35_0_0_22_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_35_0_0_22_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_35_0_0_22);
        getValue(A_FSG_35_0_0_22,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_35_0_0_22_Start);
     elementsVal = getValue(A_FSG_35_0_0_22_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_35_0_0_22_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 22");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_22_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_22_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeGainPrimary:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param3     ) & 0xFF;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param3 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeGainSecondary:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeUnit:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param5 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_35_0_0_22_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_35_0_0_22_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 22");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_22_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_22_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeGainPrimary:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param3     ) & 0xFF;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param3 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeGainSecondary:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeUnit:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param5 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_35_0_0_22, data);
        Request_ByteSequence(LSGID, A_FSG_35_0_0_22_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_35_0_0_22_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_35_0_0_22_ID);
        }
        if(getValue(A_FSG_35_0_0_22_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_35_0_0_22_ID,getValueSize(A_FSG_35_0_0_22));
        }
        A_FSG_35_0_0_22Status_BTN_already_pressed = 0;
    }
}
A_FSG_35_0_0_22_SendStatus()
{
    word currentPos;
    word headLength;
    int i;
    int j;
    word StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[75];
    byte stringValue[75];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_35_0_0_22_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_35_0_0_22_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_35_0_0_22_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_35_0_0_22);
        getValue(A_FSG_35_0_0_22,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_35_0_0_22_Start);
     elementsVal = getValue(A_FSG_35_0_0_22_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_35_0_0_22_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 22");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_22_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_22_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeGainPrimary:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param3     ) & 0xFF;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param3 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeGainSecondary:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeUnit:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param5 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_35_0_0_22_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_35_0_0_22_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 22");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_22_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_35_0_0_22_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ConsumerIdentifier:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeGainPrimary:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param3     ) & 0xFF;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param3 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeGainSecondary:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param4     ) & 0xFF;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param4 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable RangeUnit:
      if( 0 || 0 == getValue( A_FSG_35_0_0_22_RecAdr ) || 1 == getValue( A_FSG_35_0_0_22_RecAdr ) || 2 == getValue( A_FSG_35_0_0_22_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_35_0_0_22_ArrayDataList[i].Param5 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_35_0_0_22_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_35_0_0_22
{
    byte temp[75];
    getValue(A_FSG_35_0_0_22, temp);
    putValue(A_FSG_35_0_0_22_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_35_0_0_22_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_35_0_0_22_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_35_0_0_22_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_35_0_0_22_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_35_0_0_22_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_35_0_0_22_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_35_0_0_22_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_35_0_0_22_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_35_0_0_22_IndexSize))
    {
        putValue(A_FSG_35_0_0_22_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_35_0_0_22_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_35_0_0_22_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_35_0_0_22_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_35_0_0_22_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_35_0_0_22_RecAdr) > 0x0F)
        putValue(A_FSG_35_0_0_22_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_35_0_0_22_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_35_0_0_22_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_35_0_0_22_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_35_0_0_22_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_35_0_0_22_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_35_0_0_22_Start) & 0xFF;
        head[2] = (getValue(A_FSG_35_0_0_22_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_35_0_0_22_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_35_0_0_22_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_35_0_0_22_Start) & 0xFF;
        head[2] = getValue(A_FSG_35_0_0_22_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_35_0_0_22, head, headLength); 
}

on envVar A_FSG_35_0_0_22_RecAdr
{
    A_FSG_35_0_0_22_GenerateStatus();
}

on envVar A_FSG_35_0_0_22_Shift
{
    A_FSG_35_0_0_22_GenerateStatus();
}

on envVar A_FSG_35_0_0_22_Direction
{
    A_FSG_35_0_0_22_GenerateStatus();
}

on envVar A_FSG_35_0_0_22_Start
{
    A_FSG_35_0_0_22_GenerateStatus();
}

on envVar A_FSG_35_0_0_22_Elements
{
    A_FSG_35_0_0_22_GenerateStatus();
}

on envVar A_FSG_35_0_0_22_IndexSize
{
    A_FSG_35_0_0_22_GenerateStatus();
}
on envVar A_FSG_35_0_0_22_TransPos
{
    A_FSG_35_0_0_22_GenerateStatus();
}
A_FSG_35_0_0_22_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_35_0_0_22_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_35_0_0_22_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_35_0_0_22_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_35_0_0_22_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_35_0_0_22_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_35_0_0_22_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_35_0_0_22_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_35_0_0_22_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_35_0_0_22_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_35_0_0_22_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_35_0_0_22_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_35_0_0_22_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_35_0_0_22_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_35_0_0_22_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_35_0_0_22_Changed, head, 3); 
    }
}

on envVar A_FSG_35_0_0_22_Changed_RecAdr
{
    A_FSG_35_0_0_22_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_22_Changed_Shift
{
    A_FSG_35_0_0_22_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_22_Changed_Direction
{
    A_FSG_35_0_0_22_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_22_Changed_Start
{
    A_FSG_35_0_0_22_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_22_Changed_Elements
{
    A_FSG_35_0_0_22_Changed_GenerateChanged();
}

on envVar A_FSG_35_0_0_22_Changed_IndexSize
{
    A_FSG_35_0_0_22_Changed_GenerateChanged();
}
on envVar A_FSG_35_0_0_22_Changed_TransPos
{
    A_FSG_35_0_0_22_Changed_GenerateChanged();
}
on envVar A_FSG_35_0_0_22_SetGet
{
    byte temp[75];
    getValue(A_FSG_35_0_0_22_SetGet, temp);
    putValue(A_FSG_35_0_0_22_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_35_0_0_22_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_35_0_0_22_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_35_0_0_22_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_35_0_0_22_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_35_0_0_22_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_35_0_0_22_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_35_0_0_22_SetGet_IndexSize))
    {
        putValue(A_FSG_35_0_0_22_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_35_0_0_22_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_35_0_0_22_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_35_0_0_22_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_35_0_0_22_LoadArray()
{
    /********* Statische Deklarationen ***********/
    dword CSVfileHandle;
    dword filePos;
    dword paramPos;
    dword Num_of_csv_byte;
    dword element;
    dword current_CSV_line;
    byte buffer_byte[0xFFFF];
    dword i;
    dword j;
    char CSV_filename[255];

    /********* Param Puffer Deklarationen ***********/
    char temp1[25];
    char temp2[25];
    char temp3[25];
    char temp4[25];
    char temp5[25];

    /********* Initialisierungen ***********/
    CSVfileHandle = 0;
    filePos = 0;
    paramPos = 0;
    Num_of_csv_byte = 0;
    element = 1;
    current_CSV_line = 0;
    for(i = 0; i < A_FSG_35_0_0_22_ArrayDataList_Length; i++)
    { /* Initialisierung von den Ziel-Strukturen */
        A_FSG_35_0_0_22_ArrayDataList[i].Param1 = 0;
        A_FSG_35_0_0_22_ArrayDataList[i].Param2 = 0;
        A_FSG_35_0_0_22_ArrayDataList[i].Param3 = 0;
        A_FSG_35_0_0_22_ArrayDataList[i].Param4 = 0;
        A_FSG_35_0_0_22_ArrayDataList[i].Param5 = 0;
    }

    /********* Laden der CSV-Datei ***********/
    getValue(A_FSG_35_0_0_22_fileSelector, CSV_filename);
    CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

    if (CSVfileHandle!=0) //*.csv file access successful
    {
        writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
        //get data from *.csv and store the total number of byte in *.csv-file
        Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

        for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
        {
            if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
            {
                //nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
                {
                    if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
                    {
                        A_FSG_35_0_0_22_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
                        A_FSG_35_0_0_22_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //ConsumerIdentifier
                        A_FSG_35_0_0_22_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //RangeGainPrimary
                        A_FSG_35_0_0_22_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //RangeGainSecondary
                        A_FSG_35_0_0_22_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //RangeUnit
                        for(i = 0; i < 25; i++)
                        { /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
                            temp1[i]=0;
                            temp2[i]=0;
                            temp3[i]=0;
                            temp4[i]=0;
                            temp5[i]=0;
                        }
                    }
                    current_CSV_line++; //next line in *.csv file
                    element = 1; //start at 'POS' (first record element of "array data")
                    paramPos = 0; //reset value
                }
                 //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                else if(current_CSV_line > 0 && current_CSV_line < 256)
                {
                    //writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
                    switch (element)
                    {
                        case 1: //Pos
                                if( paramPos >= elCount(temp1) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp1[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 2: //ConsumerIdentifier
                                if( paramPos >= elCount(temp2) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp2[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 3: //RangeGainPrimary
                                if( paramPos >= elCount(temp3) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp3[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 4: //RangeGainSecondary
                                if( paramPos >= elCount(temp4) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp4[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 5: //RangeUnit
                                if( paramPos >= elCount(temp5) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp5[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        default:
                        break;
                    }
                }
            }
            else  // ";" is detected ->next record element of "array data"
            {
                //writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
                element++;
                paramPos=0; //reset value
            }
        }

        if(fileClose (CSVfileHandle) !=0) //close *.csv file
            writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
        else
            writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
        writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
    }
}

on envVar A_FSG_35_0_0_22_loadArray_Btn
{
    char filePath[255];
    if (A_FSG_35_0_0_22_generateData_Btn_already_pressed == 0)
    {
        A_FSG_35_0_0_22_generateData_Btn_already_pressed = 1;
    }
    else
    {
        A_FSG_35_0_0_22_generateData_Btn_already_pressed = 0;
        getValue(A_FSG_35_0_0_22_fileSelector, filePath);
        if(0 == strlen(filePath))
        {
            writelineEx(gBAP_Trace, 0, "Invalid file path!");
        }
        else
        {
            A_FSG_35_0_0_22_LoadArray();
            writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
        }
    }
    putValue(A_FSG_35_0_0_22_Data_1, A_FSG_35_0_0_22_ArrayDataList[ getValue( A_FSG_35_0_0_22_DataIndex) ].Param1);
    putValue(A_FSG_35_0_0_22_Data_2, A_FSG_35_0_0_22_ArrayDataList[ getValue( A_FSG_35_0_0_22_DataIndex) ].Param2);
    putValue(A_FSG_35_0_0_22_Data_3, A_FSG_35_0_0_22_ArrayDataList[ getValue( A_FSG_35_0_0_22_DataIndex) ].Param3);
    putValue(A_FSG_35_0_0_22_Data_4, A_FSG_35_0_0_22_ArrayDataList[ getValue( A_FSG_35_0_0_22_DataIndex) ].Param4);
    putValue(A_FSG_35_0_0_22_Data_5, A_FSG_35_0_0_22_ArrayDataList[ getValue( A_FSG_35_0_0_22_DataIndex) ].Param5);
}


on envVar A_FSG_35_0_0_22_generateData_Btn
{
    word i;
    dword elementsArray[5] = {1, 1, 2, 2, 1};
    byte elementsTypeArray[5] = {0, 0, 0, 0, 0};
    dword elementsMaxSizeArray[5] = {255, 0xFF, 655.35, 655.35, 0xFF};
    byte tempArray[1785];
    if (A_FSG_35_0_0_22_generateData_Btn_already_pressed == 0)
    {
        A_FSG_35_0_0_22_generateData_Btn_already_pressed = 1;
    }
    else
    {
        initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 22, 255 );
        for(i = 0; i < 255; i++)
        {
            memcpy(A_FSG_35_0_0_22_ArrayDataList[i], tempArray, (i * 7) );
        }
        A_FSG_35_0_0_22_generateData_Btn_already_pressed = 0;
    }
    putValue(A_FSG_35_0_0_22_Data_1, A_FSG_35_0_0_22_ArrayDataList[ getValue( A_FSG_35_0_0_22_DataIndex) ].Param1);
    putValue(A_FSG_35_0_0_22_Data_2, A_FSG_35_0_0_22_ArrayDataList[ getValue( A_FSG_35_0_0_22_DataIndex) ].Param2);
    putValue(A_FSG_35_0_0_22_Data_3, A_FSG_35_0_0_22_ArrayDataList[ getValue( A_FSG_35_0_0_22_DataIndex) ].Param3);
    putValue(A_FSG_35_0_0_22_Data_4, A_FSG_35_0_0_22_ArrayDataList[ getValue( A_FSG_35_0_0_22_DataIndex) ].Param4);
    putValue(A_FSG_35_0_0_22_Data_5, A_FSG_35_0_0_22_ArrayDataList[ getValue( A_FSG_35_0_0_22_DataIndex) ].Param5);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_35_0_0_22_DataIndex
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_35_0_0_22_Data_1, A_FSG_35_0_0_22_ArrayDataList[index].Param1);
    putValue(A_FSG_35_0_0_22_Data_2, A_FSG_35_0_0_22_ArrayDataList[index].Param2);
    putValue(A_FSG_35_0_0_22_Data_3, A_FSG_35_0_0_22_ArrayDataList[index].Param3);
    putValue(A_FSG_35_0_0_22_Data_4, A_FSG_35_0_0_22_ArrayDataList[index].Param4);
    putValue(A_FSG_35_0_0_22_Data_5, A_FSG_35_0_0_22_ArrayDataList[index].Param5);

}
on envVar A_FSG_35_0_0_22_DataIndex_Incr
{
    long index;
    if(A_FSG_35_0_0_22_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_35_0_0_22_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_35_0_0_22_DataIndex);
        index++;
        putValue(A_FSG_35_0_0_22_DataIndex, index);
        A_FSG_35_0_0_22_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_35_0_0_22_DataIndex_Decr
{
    long index;
    if(A_FSG_35_0_0_22_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_35_0_0_22_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_35_0_0_22_DataIndex);
        index--;
        putValue(A_FSG_35_0_0_22_DataIndex, index);
        A_FSG_35_0_0_22_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_35_0_0_22_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_35_0_0_22_ID;
    data[2]=getValue(A_FSG_35_0_0_22_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_35_0_0_22
on envVar A_FSG_35_0_0_22_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_22",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_35_0_0_22",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_22",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_22_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_35_0_0_22", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_22",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_35_0_0_22",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_22",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_35_0_0_22_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_35_0_0_22", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_35_0_0_22_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_35_0_0_22_SegmEn,0);
           intertelegram_err(A_FSG_35_0_0_22_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_35_0_0_22_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_35_0_0_22_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_35_0_0_22_IntTlgEn,0);
           sequence_err(A_FSG_35_0_0_22_ID,getValueSize(A_FSG_35_0_0_22_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_35_0_0_22_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_35_0_0_22_AT
{
    if(getValue(this))
    {
        EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Status",0);
    }
    else
    {
       EnableControl(panel_name,"panel_A_FSG_35_0_0_22_Status",1);
     }
}



A_FSG_35_0_0_22_SetInd () { /* leere Function*/ }

A_FSG_35_0_0_22_SetGetInd () { /* leere Function*/ }

A_FSG_35_0_0_22_GetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[75];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_35_0_0_22_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_35_0_0_22_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_35_0_0_22_SetGet, head, 5);
                if(getValue(A_FSG_35_0_0_22_AT))
                {
                    putValue(A_FSG_35_0_0_22,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_35_0_0_22_SetGet, head, 3);
            if(getValue(A_FSG_35_0_0_22_AT))
            {
                putValue(A_FSG_35_0_0_22,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_35_0_0_22_AT))
        {
            putValue(A_FSG_35_0_0_22_RecAdr,recordAddressVal);
            putValue(A_FSG_35_0_0_22_Start, startVal);
            putValue(A_FSG_35_0_0_22_Elements, elementsVal);
            putValue(A_FSG_35_0_0_22_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_35_0_0_22_1
{
    byte superval[75];

    //Update Childvalue (Enum)
    byte thisval; // ASG_ID
    thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_22_2_range // ConsumerListRange.TAID 
{
    @A_FSG_35_0_0_22_2 = @A_FSG_35_0_0_22_2_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_22_2
{
    byte superval[75];

    //Update Childvalue (Number)
    byte thisval; // TAID
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_22_2, 1.0);
    @A_FSG_35_0_0_22_2_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_22_3_range // ConsumerListRange.TotalNumListElements 
{
    @A_FSG_35_0_0_22_3 = @A_FSG_35_0_0_22_3_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_22_3
{
    byte superval[75];

    //Update Childvalue (Number)
    byte thisval; // TotalNumListElements
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_22_3, 1.0);
    @A_FSG_35_0_0_22_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_22_Data_1_range // ConsumerListRange.Pos 
{
    @A_FSG_35_0_0_22_Data_1 = @A_FSG_35_0_0_22_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_22_Data_1
{
    byte superval[75];

    //Update Childvalue (Number)
    byte thisval; // Pos
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_22_Data_1, 1.0);
    @A_FSG_35_0_0_22_Data_1_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_35_0_0_22_ArrayDataList[getValue(A_FSG_35_0_0_22_DataIndex)].Param1 = thisval;
}
on envVar A_FSG_35_0_0_22_Data_2
{
    byte superval[75];

    //Update Childvalue (Enum)
    byte thisval; // ConsumerIdentifier
    thisval = getValue(this);
    A_FSG_35_0_0_22_ArrayDataList[getValue(A_FSG_35_0_0_22_DataIndex)].Param2 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_22_Data_3_range // ConsumerListRange.RangeGainPrimary 
{
    @A_FSG_35_0_0_22_Data_3 = @A_FSG_35_0_0_22_Data_3_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_22_Data_3
{
    byte superval[75];

    //Update Childvalue (Number)
    word thisval; // RangeGainPrimary
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_22_Data_3, 0.01);
    @A_FSG_35_0_0_22_Data_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (word)round((slider_value + (0) - (0)) / (0.01), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_35_0_0_22_ArrayDataList[getValue(A_FSG_35_0_0_22_DataIndex)].Param3 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_22_Data_4_range // ConsumerListRange.RangeGainSecondary 
{
    @A_FSG_35_0_0_22_Data_4 = @A_FSG_35_0_0_22_Data_4_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_22_Data_4
{
    byte superval[75];

    //Update Childvalue (Number)
    word thisval; // RangeGainSecondary
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_22_Data_4, 0.01);
    @A_FSG_35_0_0_22_Data_4_range = slider_value + (0); // real value := slider value + range min.
    thisval = (word)round((slider_value + (0) - (0)) / (0.01), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_35_0_0_22_ArrayDataList[getValue(A_FSG_35_0_0_22_DataIndex)].Param4 = thisval;
}
on envVar A_FSG_35_0_0_22_Data_5
{
    byte superval[75];

    //Update Childvalue (Enum)
    byte thisval; // RangeUnit
    thisval = getValue(this);
    A_FSG_35_0_0_22_ArrayDataList[getValue(A_FSG_35_0_0_22_DataIndex)].Param5 = thisval;
}
on envVar A_FSG_35_0_0_22_1_SetGet
{
    byte superval[4];

    //Update Childvalue (Enum)
    byte thisval; // ASG_ID
    thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_35_0_0_22_2_SetGet_range // ConsumerListRange.TAID 
{
    @A_FSG_35_0_0_22_2_SetGet = @A_FSG_35_0_0_22_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_35_0_0_22_2_SetGet
{
    byte superval[4];

    //Update Childvalue (Number)
    byte thisval; // TAID
    float slider_value;

    slider_value = round(@A_FSG_35_0_0_22_2_SetGet, 1.0);
    @A_FSG_35_0_0_22_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_23_ErrCode
{
       if(gP_FSG_35_0_0_23_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_23", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_23_ErrCode = 1;
}
on envVar P_FSG_35_0_0_23Status_BTN
{
    byte BAPTemp[13];
    if (P_FSG_35_0_0_23Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_35_0_0_23_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_23",MakeRGB(255,255,255));
        P_FSG_35_0_0_23Status_BTN_already_pressed = 1;
    }
    else
    {
        P_FSG_35_0_0_23_BuildFct();
        getValue(P_FSG_35_0_0_23, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_35_0_0_23_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_35_0_0_23));
        if(getValue(P_FSG_35_0_0_23_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_35_0_0_23_ID);
        }
        if(getValue(P_FSG_35_0_0_23_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_35_0_0_23_ID,elCount(BAPTemp));
        }
       P_FSG_35_0_0_23Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_35_0_0_23_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_35_0_0_23_ID;
    data[2]=getValue(P_FSG_35_0_0_23_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_35_0_0_23
on envVar P_FSG_35_0_0_23_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_23",1);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_23",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_23",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_23", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_23",0);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_23",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_23",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_23", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_35_0_0_23_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_35_0_0_23_SegmEn,0);
           intertelegram_err(P_FSG_35_0_0_23_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_35_0_0_23_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_35_0_0_23_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_35_0_0_23_IntTlgEn,0);
           sequence_err(P_FSG_35_0_0_23_ID,getValueSize(P_FSG_35_0_0_23_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_35_0_0_23_ID);
       }
}
on envVar P_FSG_35_0_0_23 // bus value of CurrentRange (23).
{
    // opcodes: Error-Status
    word param1; // RangeGainValuePrimary
    word param2; // RangeGainValueSecondary
    word param3; // RangeGainValueTotal
    word param4; // RangeValuePrimary
    word param5; // RangeValueSecondary
    word param6; // RangeValueTotal
    byte param7; // RangeUnit
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    int i;
    byte superval[13];
    int currentPos;
    currentPos = 0;
    for( i = 0; i < 13; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_35_0_0_23, superval);
    ///////// Start param1 - UINT16 /////////
    param1 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_23_1, round((param1 * 0.1) - (0) + (0), 0.1));
    ///////// Start param2 - UINT16 /////////
    param2 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_23_2, round((param2 * 0.1) - (0) + (0), 0.1));
    ///////// Start param3 - UINT16 /////////
    param3 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_23_3, round((param3 * 0.1) - (0) + (0), 0.1));
    ///////// Start param4 - UINT16 /////////
    param4 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_23_4, round((param4 * 0.1) - (0) + (0), 0.1));
    ///////// Start param5 - UINT16 /////////
    param5 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_23_5, round((param5 * 0.1) - (0) + (0), 0.1));
    ///////// Start param6 - UINT16 /////////
    param6 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_23_6, round((param6 * 0.1) - (0) + (0), 0.1));
    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(P_FSG_35_0_0_23_7, param7);
}

// Updates the bus value field and other dependencies.
P_FSG_35_0_0_23_BuildFct()
{
    word param1; // RangeGainValuePrimary
    word param2; // RangeGainValueSecondary
    word param3; // RangeGainValueTotal
    word param4; // RangeValuePrimary
    word param5; // RangeValueSecondary
    word param6; // RangeValueTotal
    byte param7; // RangeUnit

    int i;
    byte superval[13];
    int currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals 
    @P_FSG_35_0_0_23_1_range = round(@P_FSG_35_0_0_23_1 + (0), 0.1); // slider value + min = real value
    param1 = round( (@P_FSG_35_0_0_23_1 + (0) - (0)) / (0.1), 0.1); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param1&0x00ff;
    superval[currentPos++]=(param1&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
    @P_FSG_35_0_0_23_2_range = round(@P_FSG_35_0_0_23_2 + (0), 0.1); // slider value + min = real value
    param2 = round( (@P_FSG_35_0_0_23_2 + (0) - (0)) / (0.1), 0.1); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param2&0x00ff;
    superval[currentPos++]=(param2&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
    @P_FSG_35_0_0_23_3_range = round(@P_FSG_35_0_0_23_3 + (0), 0.1); // slider value + min = real value
    param3 = round( (@P_FSG_35_0_0_23_3 + (0) - (0)) / (0.1), 0.1); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param3&0x00ff;
    superval[currentPos++]=(param3&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
    @P_FSG_35_0_0_23_4_range = round(@P_FSG_35_0_0_23_4 + (0), 0.1); // slider value + min = real value
    param4 = round( (@P_FSG_35_0_0_23_4 + (0) - (0)) / (0.1), 0.1); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param4&0x00ff;
    superval[currentPos++]=(param4&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
    @P_FSG_35_0_0_23_5_range = round(@P_FSG_35_0_0_23_5 + (0), 0.1); // slider value + min = real value
    param5 = round( (@P_FSG_35_0_0_23_5 + (0) - (0)) / (0.1), 0.1); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param5&0x00ff;
    superval[currentPos++]=(param5&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
    @P_FSG_35_0_0_23_6_range = round(@P_FSG_35_0_0_23_6 + (0), 0.1); // slider value + min = real value
    param6 = round( (@P_FSG_35_0_0_23_6 + (0) - (0)) / (0.1), 0.1); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param6&0x00ff;
    superval[currentPos++]=(param6&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
    param7 = getValue(P_FSG_35_0_0_23_7);
    superval[currentPos++]=param7;
    putValue(P_FSG_35_0_0_23, superval, currentPos);
}


// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_23_1_range // CurrentRange.RangeGainValuePrimary 
{
    @P_FSG_35_0_0_23_1 = @P_FSG_35_0_0_23_1_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_23_1 // CurrentRange.RangeGainValuePrimary
{
    P_FSG_35_0_0_23_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_23_2_range // CurrentRange.RangeGainValueSecondary 
{
    @P_FSG_35_0_0_23_2 = @P_FSG_35_0_0_23_2_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_23_2 // CurrentRange.RangeGainValueSecondary
{
    P_FSG_35_0_0_23_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_23_3_range // CurrentRange.RangeGainValueTotal 
{
    @P_FSG_35_0_0_23_3 = @P_FSG_35_0_0_23_3_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_23_3 // CurrentRange.RangeGainValueTotal
{
    P_FSG_35_0_0_23_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_23_4_range // CurrentRange.RangeValuePrimary 
{
    @P_FSG_35_0_0_23_4 = @P_FSG_35_0_0_23_4_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_23_4 // CurrentRange.RangeValuePrimary
{
    P_FSG_35_0_0_23_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_23_5_range // CurrentRange.RangeValueSecondary 
{
    @P_FSG_35_0_0_23_5 = @P_FSG_35_0_0_23_5_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_23_5 // CurrentRange.RangeValueSecondary
{
    P_FSG_35_0_0_23_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_23_6_range // CurrentRange.RangeValueTotal 
{
    @P_FSG_35_0_0_23_6 = @P_FSG_35_0_0_23_6_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_23_6 // CurrentRange.RangeValueTotal
{
    P_FSG_35_0_0_23_BuildFct();
}

on envVar P_FSG_35_0_0_23_7 // CurrentRange.RangeUnit
{
    P_FSG_35_0_0_23_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_24_ErrCode
{
       if(gP_FSG_35_0_0_24_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_24", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_24_ErrCode = 1;
}
on envVar P_FSG_35_0_0_24Status_BTN
{
    byte BAPTemp[6];
   if (P_FSG_35_0_0_24Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_35_0_0_24_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_24",MakeRGB(255,255,255));
      P_FSG_35_0_0_24Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_35_0_0_24, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_35_0_0_24_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_35_0_0_24));
      P_FSG_35_0_0_24Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_35_0_0_24_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_35_0_0_24_ID;
    data[2]=getValue(P_FSG_35_0_0_24_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_35_0_0_24
on envVar P_FSG_35_0_0_24_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_24",1);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_24",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_24",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_24", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_24",0);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_24",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_24",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_24", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_35_0_0_24 // bus value of CurrentRangeSOC (24).
{
    // opcodes: Error-Status
    word param1; // SOCRangeElectrical
    byte param2; // RangeUnit
    byte param3; // TAID
    byte param4; // Dummy_1
    byte param5; // Dummy_2
    byte param6; // Dummy_3
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    int i;
    byte superval[6];
    int currentPos;
    currentPos = 0;
    for( i = 0; i < 6; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_35_0_0_24, superval);
    ///////// Start param1 - UINT16 /////////
    param1 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_24_1, round((param1 * 0.1) - (0) + (0), 0.1));
    ///////// Start param2 - NIBBLE /////////
    param2 = (superval[currentPos] & 0xf0)>>4;
    putValue(P_FSG_35_0_0_24_2, param2);
    ///////// Start param3 - NIBBLE /////////
    param3 = superval[currentPos++] & 0x0f;
    putValue(P_FSG_35_0_0_24_3, round((param3 * 1.0) - (0) + (0), 1.0));
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_35_0_0_24_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_35_0_0_24_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_35_0_0_24_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_24_1_range // CurrentRangeSOC.SOCRangeElectrical 
{
    @P_FSG_35_0_0_24_1 = @P_FSG_35_0_0_24_1_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_24_1 // CurrentRangeSOC.SOCRangeElectrical
{
    byte superval[6];

    //Update Childvalue (Number)
    word thisval; // SOCRangeElectrical
    float slider_value;

    slider_value = round(@P_FSG_35_0_0_24_1, 0.1);
    @P_FSG_35_0_0_24_1_range = slider_value + (0); // real value := slider value + range min.
    thisval = (word)round((slider_value + (0) - (0)) / (0.1), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_24, superval);
    superval[0]=thisval&0x00ff;
    superval[1]=(thisval&0xff00)>>8;
    putValue(P_FSG_35_0_0_24,superval);
}

on envVar P_FSG_35_0_0_24_2 // CurrentRangeSOC.RangeUnit
{
    byte superval[6];

    //Update Childvalue (Enum)
    byte thisval; // RangeUnit
    thisval = 0x0f & getValue(this);

    // Update superval
    getValue(P_FSG_35_0_0_24, superval);
    superval[2]= superval[2]&0x0f;
    superval[2]= superval[2]|(thisval<<4);
    putValue(P_FSG_35_0_0_24,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_24_3_range // CurrentRangeSOC.TAID 
{
    @P_FSG_35_0_0_24_3 = @P_FSG_35_0_0_24_3_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_24_3 // CurrentRangeSOC.TAID
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // TAID
    float slider_value;

    slider_value = round(@P_FSG_35_0_0_24_3, 1.0);
    @P_FSG_35_0_0_24_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_24, superval);
    superval[2]= superval[2]&0xf0;
    superval[2]= superval[2]|thisval;
    putValue(P_FSG_35_0_0_24,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_24_4_range // CurrentRangeSOC.Dummy_1 
{
    @P_FSG_35_0_0_24_4 = @P_FSG_35_0_0_24_4_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_24_4 // CurrentRangeSOC.Dummy_1
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Dummy_1
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_35_0_0_24_4_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_24, superval);
    superval[3]=thisval;
    putValue(P_FSG_35_0_0_24,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_24_5_range // CurrentRangeSOC.Dummy_2 
{
    @P_FSG_35_0_0_24_5 = @P_FSG_35_0_0_24_5_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_24_5 // CurrentRangeSOC.Dummy_2
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Dummy_2
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_35_0_0_24_5_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_24, superval);
    superval[4]=thisval;
    putValue(P_FSG_35_0_0_24,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_24_6_range // CurrentRangeSOC.Dummy_3 
{
    @P_FSG_35_0_0_24_6 = @P_FSG_35_0_0_24_6_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_24_6 // CurrentRangeSOC.Dummy_3
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Dummy_3
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_35_0_0_24_6_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_24, superval);
    superval[5]=thisval;
    putValue(P_FSG_35_0_0_24,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_35_0_0_25_ErrCode
{
       if(gP_FSG_35_0_0_25_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_35_0_0_25", MakeRGB(255,255,255));
       }
       gP_FSG_35_0_0_25_ErrCode = 1;
}
on envVar P_FSG_35_0_0_25Status_BTN
{
    byte BAPTemp[6];
   if (P_FSG_35_0_0_25Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_35_0_0_25_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_35_0_0_25",MakeRGB(255,255,255));
      P_FSG_35_0_0_25Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_35_0_0_25, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_35_0_0_25_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_35_0_0_25));
      P_FSG_35_0_0_25Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_35_0_0_25_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_35_0_0_25_ID;
    data[2]=getValue(P_FSG_35_0_0_25_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_35_0_0_25
on envVar P_FSG_35_0_0_25_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_25",1);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_25",1);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_25",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_25", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_35_0_0_25",0);
           EnableControl(panel_name,"errfield_P_FSG_35_0_0_25",0);
           EnableControl(panel_name,"panel_P_FSG_35_0_0_25",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_35_0_0_25", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_35_0_0_25 // bus value of CatalogueRange (25).
{
    // opcodes: Error-Status
    word param1; // CatalogueRangeElectrical
    byte param2; // RangeUnit
    byte param3; // DisplayStyle
    byte param4; // Dummy_1
    byte param5; // Dummy_2
    byte param6; // Dummy_3
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    int i;
    byte superval[6];
    int currentPos;
    currentPos = 0;
    for( i = 0; i < 6; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_35_0_0_25, superval);
    ///////// Start param1 - UINT16 /////////
    param1 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_35_0_0_25_1, round((param1 * 0.1) - (0) + (0), 0.1));
    ///////// Start param2 - NIBBLE /////////
    param2 = (superval[currentPos] & 0xf0)>>4;
    putValue(P_FSG_35_0_0_25_2, param2);
    ///////// Start param3 - NIBBLE /////////
    param3 = superval[currentPos++] & 0x0f;
    putValue(P_FSG_35_0_0_25_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_35_0_0_25_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_35_0_0_25_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_35_0_0_25_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_25_1_range // CatalogueRange.CatalogueRangeElectrical 
{
    @P_FSG_35_0_0_25_1 = @P_FSG_35_0_0_25_1_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_25_1 // CatalogueRange.CatalogueRangeElectrical
{
    byte superval[6];

    //Update Childvalue (Number)
    word thisval; // CatalogueRangeElectrical
    float slider_value;

    slider_value = round(@P_FSG_35_0_0_25_1, 0.1);
    @P_FSG_35_0_0_25_1_range = slider_value + (0); // real value := slider value + range min.
    thisval = (word)round((slider_value + (0) - (0)) / (0.1), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_25, superval);
    superval[0]=thisval&0x00ff;
    superval[1]=(thisval&0xff00)>>8;
    putValue(P_FSG_35_0_0_25,superval);
}

on envVar P_FSG_35_0_0_25_2 // CatalogueRange.RangeUnit
{
    byte superval[6];

    //Update Childvalue (Enum)
    byte thisval; // RangeUnit
    thisval = 0x0f & getValue(this);

    // Update superval
    getValue(P_FSG_35_0_0_25, superval);
    superval[2]= superval[2]&0x0f;
    superval[2]= superval[2]|(thisval<<4);
    putValue(P_FSG_35_0_0_25,superval);
}

on envVar P_FSG_35_0_0_25_3 // CatalogueRange.DisplayStyle
{
    byte superval[6];

    //Update Childvalue (Enum)
    byte thisval; // DisplayStyle
    thisval = 0x0f & getValue(this);

    // Update superval
    getValue(P_FSG_35_0_0_25, superval);
    superval[2]= superval[2]&0xf0;
    superval[2]= superval[2]|thisval;
    putValue(P_FSG_35_0_0_25,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_25_4_range // CatalogueRange.Dummy_1 
{
    @P_FSG_35_0_0_25_4 = @P_FSG_35_0_0_25_4_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_25_4 // CatalogueRange.Dummy_1
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Dummy_1
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_35_0_0_25_4_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_25, superval);
    superval[3]=thisval;
    putValue(P_FSG_35_0_0_25,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_25_5_range // CatalogueRange.Dummy_2 
{
    @P_FSG_35_0_0_25_5 = @P_FSG_35_0_0_25_5_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_25_5 // CatalogueRange.Dummy_2
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Dummy_2
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_35_0_0_25_5_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_25, superval);
    superval[4]=thisval;
    putValue(P_FSG_35_0_0_25,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_35_0_0_25_6_range // CatalogueRange.Dummy_3 
{
    @P_FSG_35_0_0_25_6 = @P_FSG_35_0_0_25_6_range - (0); // slider = range - min
}

on envVar P_FSG_35_0_0_25_6 // CatalogueRange.Dummy_3
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Dummy_3
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_35_0_0_25_6_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_35_0_0_25, superval);
    superval[5]=thisval;
    putValue(P_FSG_35_0_0_25,superval);
}



/**
*
* Template-Funktion zum automatischen befuellen der Array-Daten, die in einer Arrayfunktion genutzt werden.
* Die Funktion wird durch den von BAPSimGen generierten Code aufgerufen.
*
* Parameter:
* - structArray: Muss mindestens nMax * Arraygroesse Bytes Platz haben, wird vom BAPSimGen automatisch generiert
* - structElementsSizeArray: Enthaelt die Groesseangabe jedes Array-Elements. Die Arraygroesse entspricht der Elementanzahl im Array.
*       Byte & Nibble = 1; Word = 2; usw. Bei Strings wird die maximale Stringlaenge angegeben.
* - structElementsTypeArray: Gibt den Datentyp eines Array-Elements zurueck. Die Arraygroesse entspricht der Elmentanzahl im Array.
*                               0x0 = Zahlenwert, also ein Slider, Enum, Bitfield,...
*                               0xE = String (darauf folgt immer eine 2, mit der Angabe der benutzen Bytes im String)
*                               0xF = Laenge der Nutzdaten des Strings, nur return Wert
* - fctID: Kann zur Fallunterscheidung der Funktions-IDs verwendet werden.
* - nMax: Array-Index
*
* Die Funktion kann im Switch-Case beliebig erweitert werden. Der Switch-Case wertet den Parameter fctID aus.
*           
*                    
**/
initStruct(byte structArray[], dword structElementsSizeArray[], byte structElementsTypeArray[], dword structElementsMaxSizeArray[], word fctID, word nMax )
{
    byte rand8;
    word rand16;
    word randSize;
    word index;           //indexNr die an die String Parameter angehaengt wird.
    dword destArraySize;   //groesse von structArray
    dword destStructSize;  //groesse eines "Structs" also destArraySize / Anzahl Elemente (nMax))
    dword rand32;    
    dword i;
    dword pos;    //aktuelle Position im structArray
    dword elpos;  //aktuelle Position in den structElementsXXXArray's
    
    destArraySize = elCount(structArray);
    destStructSize = destArraySize / nMax;    

    Switch(fctID){

        //Idee ist, die Arrays je nach Funcion-ID speziell initalisieren zu koennen.
        //hierbei koennten die Daten z.B. aus einer Datei eingelesen werden,
        //oder auch ueber spezielle init Funktionen mit festen Werten initialisiert werden.
        //Der Default-Fall befuellt das Array mit Random-Werten und Strings mit einem vordefinierten Wort (hier test,)

        default :
        {
            pos = 0; 
            for(i = 1; i <= nMax; i++)
            {
                //walk through the array
                
                elpos = 0;
                while(pos < (destStructSize * i) )
                {   
                    //check Element type
                    if( structElementsTypeArray[elpos] == 0x0)          
                    { //Params like int, word, etc.
                        //check element length
                        Switch(structElementsSizeArray[elpos])
                        {
                            case(1) : //byte / nibble
                                rand8 = random(structElementsMaxSizeArray[elpos]);
                                structArray[pos] = rand8;
                                pos++;
                                break;

                            case(2) : //word / int
                                rand16 = random(structElementsMaxSizeArray[elpos]);
                                int2byte(structArray, pos, rand16);
                                pos += 2;
                                break;

                            case (4) : //dword / long
                                rand32 = random(structElementsMaxSizeArray[elpos]);
                                long2byte(structArray, pos, rand32);
                                pos += 4;
                                break;                        
                         }
                    }
                    else if(structElementsTypeArray[elpos] == 0xE)          
                    { //String Params like byte[]
                        randSize = random(structElementsSizeArray[elpos]);
                        if(randSize < 2) randSize = 2; 
                        index = i-1;
                        setRandomString(structArray ,pos ,structElementsSizeArray[elpos], randSize, index);
                        pos += structElementsSizeArray[elpos];
                    }
                    else if(structElementsTypeArray[elpos] == 0xF)          
                    {
                        int2byte(structArray, pos, randSize);
                        pos += 2;
                        //write("Pos: %d Strlth: %d Type: %d ",pos-1,randSize,structElementsTypeArray[elpos]);
                    
                    }
                    elpos++;
                }
            }   
        break;
        }            
    }
}

long2Byte(byte in[], dword pos, dword value)
{
    if( (elCount(in)-pos) < 4)
        write("Array out ouf bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);
    in[++pos] = (value >> 16);
    in[++pos] = (value >> 24);
}

int2byte (byte in[],dword pos,word value)
{
    if( (elCount(in)-pos) < 2 )
        write("Array out of bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);        
}

setRandomString (byte in[], dword pos, word strSize, word randSize, word count)
{
    word endPos, endString, j;
    byte testString[4]={'t','e','s','t'};
    
    endPos = pos + strSize;
    endString = pos + randSize;
    j=0;
    
    int2ascii(in, pos, count);
    pos += 2;
    
    for(pos; pos < endPos ;pos ++)
    {
        if(j > 3 )
            j = 0;
        if(pos < endString)
            in[pos] = testString[j++];
        else
            in[pos] = 0x0;
    }
}

int2ascii (byte in[], dword pos, word value)
{
    //Konvertiert nur die erste und zweite Dezimalstelle, also Zahlen zw. 0 und 99.
    
    //auf 2 Stellen kuerzen
    value = value%100;
    //10er schreiben
    in[pos] = (value/10) + 48;    //  0x30 hex = 48 dez = ascii null
    //1er schreiben
    in[pos+1] = (value%10) + 48;  //  0x30 hex = 48 dez = ascii null
}


on envVar P_FSG_35_0_0_2Reset_BTN
{
   message 0x100 _mBAPconfig;    

    if (getValue(this))
    {
        //for BAPconfig Set/Reset button
         _mBAPconfig.CAN=1; 
         _mBAPconfig.ID=0x97332310; 
         _mBAPconfig.DLC=8; 
                    
         _mBAPconfig.byte(0) = 0x08;
         _mBAPconfig.byte(1) = 0xC2;
         _mBAPconfig.byte(2) = getValue(BAPCFG_FSG_35_0_0_ProtocolMajor);
         _mBAPconfig.byte(3) = getValue(BAPCFG_FSG_35_0_0_ProtocolMinor);
         _mBAPconfig.byte(4) = getValue(BAPCFG_FSG_35_0_0_LsgClassMajor);
         _mBAPconfig.byte(5) = getValue(BAPCFG_FSG_35_0_0_LsgClassMinor);
         _mBAPconfig.byte(6) = getValue(BAPCFG_FSG_35_0_0_DFMajor);
         _mBAPconfig.byte(7) = getValue(BAPCFG_FSG_35_0_0_DFMinor);
      
        output(_mBAPconfig);    
   }

}

//MR61529 
on envVar P_FSG_35_0_0_2_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_BAP_Config;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//MR61529 
on envVar C_FSG_35_0_0_1_SegmEn
{
       if(getValue(this)) 
       {
           putValue(C_FSG_35_0_0_1_IntTlgEn,0);
           sequence_err(FctID_GetAll,154);
       }
       else
       {
              sequence_err_off(FctID_GetAll);
       }
}

//MR61529 
on envVar C_FSG_35_0_0_1_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(C_FSG_35_0_0_1_SegmEn,0);
           intertelegram_err(FctID_GetAll);
       }
       else
       {
           intertelegram_err_off(FctID_GetAll);
       }
}

//MR61529 
on envVar C_FSG_35_0_0_1_ErrEn
{
if (getValue(this))
putValue(C_FSG_35_0_0_1_FctEn,0);
}

//MR61529 
on envVar C_FSG_35_0_0_1_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_GetAll;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//MR61529 
on envVar P_FSG_35_0_0_3_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_35_0_0_3_IntTlgEn,0);
           sequence_err(FctID_FunctionList,8);
       }
       else
       {
              sequence_err_off(FctID_FunctionList);
       }
}

//MR61529 
on envVar P_FSG_35_0_0_3_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_35_0_0_3_SegmEn,0);
           intertelegram_err(FctID_FunctionList);
       }
       else
       {
           intertelegram_err_off(FctID_FunctionList);
       }
}

//MR61529 
on envVar P_FSG_35_0_0_3_ErrEn
{
if (getValue(this))
putValue(P_FSG_35_0_0_3_FctEn,0);
}

//MR61529 
on envVar P_FSG_35_0_0_3_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_FunctionList;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}
