/*@!Encoding:1252*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                      //
//   v 1.0  Neuerstellung                                                                                               //
//   v 1.1  Umstellung auf BAP180.dll                                                                                   //
//   v 1.2  Navigation: GetArray opcodes angepasst                                                                      //
//          Navigation: AddressList jetzt funktional                                                                    //
//          BatteryControl / BCmE: NodeIndex in sendRequest verdreht                                                    //
//          SDS: Ausnahme hinzugefügt für LSGID=0                                                                       //
//   v 1.3  BAP On_Off: FSG33 hinzugefügt                                                                               //
//   v 1.4  Audio: SourceList, es werden nicht mehr zu viele Elemente gesendet, wenn Start > 0                          //
//          Audio: ActiveSourceList.Status Parameter angepasst nach Auswahl einer Quelle aus SourceList                 //
//          Audio: ReceptionListType Array erweiterte für 0xB Online Podcast & kein Absturz mehr bei hoeheren Werten    //
//          InfoSettings: Integration BTDeviceList & LicenseInformation                                                 //
//          Telefon/Telefon2: Unterscheidung für verschiedene MobileServiceSupport hinzugefuegt                         //
//   v 1.5  DoorLocking: Antwort mit Status Array wieder einkommentiert                                                 //
//          BatteryControl: Erweiterung um ASG_06 (fuer HUD)                                                            //
//   v 1.6  MLBevo: Bezeichnung für BAP Buttons auf Deckblatt angepasst (neu)                                           //
//   v 1.7  Erweiterung für Profilwechsel über Personalisierungs-Panel                                                  //
//   v 1.8  Telefon2: MobileServiceSupport für DF47 ergaenzt                                                            //
//          BAP Variant für MQB2020 erweitert                                                                           //
//   v 1.9  Navigation: Erweiterung für DF50                                                                            //
//   v 1.10 Telefon: MobileServiceSupport alle Bits ergaenzt                                                            //
//   v 1.11 DoorLocking: setzten von ActiveUser bei Startup erfolgt nur, wenn BAP Knoten Index intialisiert wurde       //
//   v 1.12 Update auf BAP1101.dll (für BAP Nav ueber Ethernet)                                                         //
//   v 1.13 Audio: CurrentStationInfo2 für Elementauswahl aus Listen ergaenzt                                           //
//   v 1.14 Audio: Processing/Result Logik für Funktion DedicatedAudioControl hinzugefuegt                              //
//   v 1.15 Audio: DedicatedAudioControl Logik erweitert                                                                //
//          laden von csv Listen erweitert um korrekte Darstellung der Sonderzeichen im ASCII / UTF-8                   //
//   v 1.16 DisplayConfig: Anpassung ElementContentSelection                                                            //
//   v 1.17 DisplayConfig: Ruecksetzen von Fahrzeugtyp entfernt                                                         //
//   v 1.18 Audio: SourceList, letztes Element hat gefehlt                                                              //
//   v 1.19 Telefon: CombinedNumbers bei Anfrage in negativer Richtung wurde ein Byte zu viel uebertragen               //
//   v 1.20 RaceMeasurement: zu BAP on/off hinzugefuegt                                                                 //
//   v 1.21 Telefon: Phonebook bei Anfrage in negativer Richtung leere Elemente                                         //
//          Navigation: Last & FavDestList bei Anfrage in negativer Richtung leere Elemente                             //
//   v 1.22 Telefon2: CallPicture Logik hinzugefuegt                                                                    //
//          Telefon2: Bugfix fuer Auswertung der ASG Botschaften                                                        //
//   v 1.23 FSG 39, 58, 60, 82, 85 zu BAP on/off hinzugefuegt                                                           //
//   v 1.24 DisplayConfig: Elemente fuer ElementContentSelection koennen nun einzeln ausgewaehlt werden                 //
//   v 1.25 Navigation: ASG_03 & ASG_04 hinzugefügt                                                                     //
//   v 1.26 Audio: Picture Array hinzugefügt für DynamicIcon                                                            //
//          Audio: MediaBrowser hat ein Element zu viel uebertragen                                                     //
//   v 1.27 DisplayConfig: Skin 6 ergaenzt                                                                              //
//   v 1.28 InfoSettings: automatisches Result hinzufügen                                                               //
//   v 1.29 Audio: Anpassung Picture IPv6 Address Ausleselogik                                                          //
//          Audio: Anpassung Picture URI length identifier (nochmal pruefen!!)                                          //
//   v 1.30 Navigation: Heimat- und Geschaeftsadresse zu AddressList hinzugefuegt                                       //
//          Navigation: LaneGuidance csv wird nun wieder bei Simulationsstart geladen                                   //
//          Navigation: POI_List hinzugefuegt                                                                           //
//          Audio: Anpassung fuer ReceptionList Sonderzeichen (doppelte Konvertierung entfernt)                         //
//   v 1.31 Audio: Anpassung LastStationList                                                                            //
//          DisplayConfig: Anpassung Sportnebenanzeige                                                                  //
//                                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

includes
{
  //#pragma library ("../_install/iavhints.dll")
  //#pragma library ("../_install/BAP1101.dll")
     #include "..\BAP\_DLL\latest_BAP_DLL.cin"
}

variables
{
  ///////////////////// Allgemeines /////////////////////
  
  const BAP_BUFFERSIZE = 4096;
  const Max_Array_Size = 1024;
  const TRUE = 1;
  const FALSE = 0;
  
  
  ///////////////////// Write Window Variables ///////////////////// 
    
  dword gBAP_Trace;
  dword gTrace;
  
  
  ///////////////////// Structs DoorLocking /////////////////////
  
  _align(1) struct DoorLocking_UserList_ArrayDataStruct
  {
	  byte  Param1;
		byte  Param2;
	  byte  Param3[67];
	  word  Param3_Length;
		byte  Param4[2];
		word  Param4_Length;
	};
  
  struct  DoorLocking_UserList_ArrayDataStruct   DoorLocking_UserList[255];
  
  
  ///////////////////// Structs BCmE /////////////////////
  
  _align(1) struct BCmE_Consumer_ArrayDataStruct
  {
	  byte  Param1;
	  byte  Param2;
  };
  
  struct  BCmE_Consumer_ArrayDataStruct   BCmE_Consumer[255];
  
  
  ///////////////////// Structs BatteryControl /////////////////////
  
  _align(1) struct BatteryControl_ProfilesExtended_ArrayDataStruct
  {
    byte  Param1;
		byte  Param2[62];
		word  Param2_Length;
		byte  Param3;
		byte  Param4;
		byte  Param5;
		byte  Param6;
		byte  Param7;
		byte  Param8;
		byte  Param9;
		byte  Param10;
		byte  Param11;
		byte  Param12;
		byte  Param13;
		byte  Param14;
		byte  Param15;
		byte  Param16;
		byte  Param17;
		char  Param18;
		byte  Param19[4];
		word  Param19_Length;
		byte  Param20;
		byte  Param21;
		byte  Param22;
		byte  Param23;
		byte  Param24;
		byte  Param25;
		byte  Param26;
		byte  Param27;
		qword Param28;
		qword Param29;
		word  Param30;
		byte  Param31;
		byte  Param32[2];
		word  Param32_Length;
	};
  
  _align(1) struct BatteryControl_Contracts_ArrayDataStruct
  {
	  byte  Param1;
		byte  Param2[62];
		word  Param2_Length;
		byte  Param3[19];
		word  Param3_Length;
		byte  Param4;
		byte  Param5;
		byte  Param6;
		byte  Param7;
		byte  Param8;
		byte  Param9;
		byte  Param10;
		byte  Param11;
		byte  Param12;
		byte  Param13;
		byte  Param14;
		byte  Param15;
		byte  Param16;
		byte  Param17;
		byte  Param18;
		char  Param19;
		byte  Param20[4];
		word  Param20_Length;
	};
  
  struct  BatteryControl_ProfilesExtended_ArrayDataStruct   BatteryControl_ProfilesExtended[255];
  struct  BatteryControl_Contracts_ArrayDataStruct          BatteryControl_Contracts[255];
  
  
  ///////////////////// Structs Telefon /////////////////////
  
  _align(1)struct Telefon_CombinedNumbers_ArrayDataStruct
  {
    word  Param1;
	  char  Param2[100];
	  word  Param2_Length;
	  byte  Param3;
	  byte  Param4;    
	  char  Param5[41];
	  word  Param5_Length;
	  byte  Param6;
	  byte  Param7;
	  byte  Param8;
	  byte  Param9;
	  byte  Param10;
	  byte  Param11;
  };

  _align(1)struct Telefon_Phonebook_ArrayDataStruct
  {
    word  Pos;
	  char  PbName[100];
	  word  PbName_Length;
	  byte  Storage;
	  byte  AnyVoiceTag;
	  byte  TelNumberQuantity;
	  char  TelNumber01[410];
	  word  TelNumber01_Length;
    char  TelNumber02[410];
	  word  TelNumber02_Length;
    char  TelNumber03[410];
	  word  TelNumber03_Length;
    char  TelNumber04[410];
	  word  TelNumber04_Length;
    char  TelNumber05[410];
	  word  TelNumber05_Length;
    char  TelNumber06[410];
	  word  TelNumber06_Length;
    char  TelNumber07[410];
	  word  TelNumber07_Length;
    char  TelNumber08[410];
	  word  TelNumber08_Length;
    char  TelNumber09[410];
	  word  TelNumber09_Length;
    char  TelNumber10[410];
	  word  TelNumber10_Length;
	  byte  VoiceTag01;
    byte  VoiceTag02;
    byte  VoiceTag03;
    byte  VoiceTag04;
    byte  VoiceTag05;
    byte  VoiceTag06;
    byte  VoiceTag07;
    byte  VoiceTag08;
    byte  VoiceTag09;
    byte  VoiceTag10;
	  byte  Reserve01;
    byte  Reserve02;
    byte  Reserve03;
    byte  Reserve04;
    byte  Reserve05;
    byte  Reserve06;
    byte  Reserve07;
    byte  Reserve08;
    byte  Reserve09;
    byte  Reserve10;
	  byte  NumberType01;
    byte  NumberType02;
    byte  NumberType03;
    byte  NumberType04;
    byte  NumberType05;
    byte  NumberType06;
    byte  NumberType07;
    byte  NumberType08;
    byte  NumberType09;
    byte  NumberType10;
	  byte  AdressIndication;
  };
  
  _align(1)struct Telefon_FavoriteList_ArrayDataStruct
  {
    word  Param1;
	  char  Param2[100];
	  word  Param2_Length;
	  byte  Param3;
	  char  Param4[41]; 
    word  Param4_Length;
  };
  
  struct  Telefon_CombinedNumbers_ArrayDataStruct   Telefon_CombinedNumbers[Max_Array_Size];
  struct  Telefon_Phonebook_ArrayDataStruct         Telefon_Phonebook[Max_Array_Size];
  struct  Telefon_FavoriteList_ArrayDataStruct      Telefon_FavoriteList[Max_Array_Size];
  
  
  ///////////////////// Structs Telefon2 /////////////////////

  _align(1) struct Telefon2_CallPicture_ArrayDataStruct
  {
    byte Param1;
		byte Param2;
		byte Param3;
		byte Param4;
		byte Param5[34]; // Verdopplung
		word Param5_Length;
		word Param6;
		byte Param7[602];
		word Param7_Length;
	};
  
  struct  Telefon2_CallPicture_ArrayDataStruct      Telefon2_CallPicture[Max_Array_Size];
  
  
  ///////////////////// Structs Audio /////////////////////
  
  _align(1) struct Audio_ReceptionList_ArrayDataStruct
  {
	  int   Param1;
	  byte  Param2;
	  word  Param3;
	  byte  Param4;
	  byte  Param5;
	  byte  Param6;
	  char  Param7[97];
	  word  Param7_Length;
	  char  Param8[31];
	  word  Param8_Length;
  };
  
  _align(1) struct Audio_SourceList_ArrayDataStruct
  {
	  word  Param1;
	  byte  Param2;
	  byte  Param3;
	  byte  Param4;
	  byte  Param5;
	  char  Param6[61];
	  word  Param6_Length;
  };
  
  _align(1) struct Audio_RadioTVPresetList_ArrayDataStruct
  {
	  byte  Param1;
	  byte  Param2;
	  byte  Param3;
	  word  Param4;
	  char  Param5[49];
	  word  Param5_Length;
  };

  _align(1) struct Audio_MediaBrowser_ArrayDataStruct
  {
	  word  Param1;
	  byte  Param2;
	  word  Param3;
	  char  Param4[49];
	  word  Param4_Length;  
  };
  
  _align(1) struct Audio_SiriusAlertList_ArrayDataStruct
  {
	  word  Param1;
		word  Param2;
		byte  Param3;
		byte  Param4[49];
		word  Param4_Length;
		byte  Param5[31];
		word  Param5_Length;
		byte  Param6;
		byte  Param7[61];
		word  Param7_Length;
		byte  Param8[2];
		word  Param8_Length;
 };
  
  _align(1) struct Audio_LastStationList_ArrayDataStruct
  {
		byte  Param1;
		byte  Param2;
		byte  Param3;
		word  Param4;
		byte  Param5[49];
		word  Param5_Length;
	  byte  Param6[31];
		word  Param6_Length; 
  };
  
  _align(1) struct Audio_Picture_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 word Param3;
		 byte Param4[33];
		 word Param4_Length;
		 word Param5;
		 byte Param6[602];
		 word Param6_Length;
	 };
  
  _align(1) struct Audio_FavoriteList_ArrayDataStruct
  {
		byte  Param1;
		byte  Param2;
	  byte  Param3;
		word  Param4;
		byte  Param5[49];
		word  Param5_Length;
		byte  Param6[31];
		word  Param6_Length;
	};
  
  struct  Audio_ReceptionList_ArrayDataStruct       Audio_ReceptionList[Max_Array_Size];
  struct  Audio_SourceList_ArrayDataStruct          Audio_SourceList[Max_Array_Size];
  struct  Audio_RadioTVPresetList_ArrayDataStruct   Audio_RadioTVPresetList[Max_Array_Size];
  struct  Audio_MediaBrowser_ArrayDataStruct        Audio_MediaBrowser[Max_Array_Size];
  struct  Audio_SiriusAlertList_ArrayDataStruct     Audio_SiriusAlertList[Max_Array_Size];
  struct  Audio_LastStationList_ArrayDataStruct     Audio_LastStationList[Max_Array_Size];
  struct  Audio_Picture_ArrayDataStruct             Audio_Picture[Max_Array_Size];
  struct  Audio_FavoriteList_ArrayDataStruct        Audio_FavoriteList[Max_Array_Size];
  
  
  ///////////////////// Structs Navigation /////////////////////
  
  _align(1) struct Navigation_LaneGuidance_ArrayDataStruct
  {
	  byte  Param1;
	  byte  Param2;
	  char  Param3[35]; // CG: verdoppelt +2 zweck anderer Eingabe
	  word  Param3_Length;
 	  byte  Param4;
 	  byte  Param5;
	  byte  Param6;
	  byte  Param7;
	  byte  Param8;
  };
  
  _align(1) struct Navigation_LastDestList_ArrayDataStruct
  {
	  byte  Param1;
	  byte  Param2;
	  char  Param3[97];
	  word  Param3_Length;
  };
  
  _align(1) struct Navigation_FavoriteDestList_ArrayDataStruct
  {
	  byte  Param1;
	  byte  Param2;
	  char  Param3[97];
	  word  Param3_Length;
  };
  
  _align(1) struct Navigation_AddressList_ArrayDataStruct
  {
  	 word Param1;
  	 byte Param2[61];
  	 word Param2_Length;
  	 byte Param3[61];
  	 word Param3_Length;
  	 byte Param4[61];
  	 word Param4_Length;
  	 byte Param5[61];
  	 word Param5_Length;
  	 byte Param6[61];
  	 word Param6_Length;
  	 byte Param7[22];
  	 word Param7_Length;
  	 byte Param8[61];
  	 word Param8_Length;
  	 byte Param9[61];
  	 word Param9_Length;
  	 byte Param10[61];
  	 word Param10_Length;
  	 byte Param11;
  	 byte Param12;
	 };
  
   _align(1) struct Navigation_POI_List_ArrayDataStruct
   {
		 byte Param1;
		 byte Param2;
		 byte Param3;
		 byte Param4;
		 dword Param5;
		 byte Param6;
		 byte Param7[91];
		 word Param7_Length;
		 byte Param8[91];
		 word Param8_Length;
		 byte Param9[91];
		 word Param9_Length;
		 byte Param10[22];
		 word Param10_Length;
	 };
	
  _align(1) struct Navigation_VideoStreams_ArrayDataStruct
  {
	  byte  Param1;
	  byte  Param2;
	  byte  Param3[33];
	  word  Param3_Length;
	  word  Param4;
	  char  Param5[602];
	  word  Param5_Length;
  };
  
  _align(1) struct Navigation_LaneGuidance2_ArrayDataStruct
  {
	  byte  Param1;
	  byte  Param2;
	  byte  Param3;
	  byte  Param4;
 	  byte  Param5;
 	  byte  Param6;
	  char  Param7[35];
	  word  Param7_Length;
	  byte  Param8;
	  byte  Param9;
	  byte  Param10;
	  byte  Param11;
	  byte  Param12;
  };
  
  _align(1) struct Navigation_Picture_ArrayDataStruct
  {
	  byte  Param1;
	  byte  Param2;
	  byte  Param3[33];
	  word  Param3_Length;
	  word  Param4;
	  char  Param5[602];
	  word  Param5_Length;
  };
  
  struct  Navigation_LaneGuidance_ArrayDataStruct       Navigation_LaneGuidance[Max_Array_Size];
  struct  Navigation_LastDestList_ArrayDataStruct       Navigation_LastDestList[Max_Array_Size];
  struct  Navigation_FavoriteDestList_ArrayDataStruct   Navigation_FavoriteDestList[Max_Array_Size];
  struct  Navigation_AddressList_ArrayDataStruct        Navigation_AddressList[Max_Array_Size];
  struct  Navigation_POI_List_ArrayDataStruct           Navigation_POI_List[Max_Array_Size];
  struct  Navigation_VideoStreams_ArrayDataStruct       Navigation_VideoStreams[Max_Array_Size];
  struct  Navigation_LaneGuidance2_ArrayDataStruct      Navigation_LaneGuidance2[Max_Array_Size];
  struct  Navigation_Picture_ArrayDataStruct            Navigation_Picture[Max_Array_Size];
  
  
  ///////////////////// Structs SDS /////////////////////
  
  _align(1) struct SDS_CommandList_ArrayDataStruct
  {
	  byte Param1;
	  word Param2;
	  byte Param3[61];
	  word Param3_Length;
	  byte Param4[2];
	  word Param4_Length;
  };
    
  _align(1) struct SDS_ResultList_ArrayDataStruct
  {
  	byte Param1;
    byte Param2;
    byte Param3[171];
    word Param3_Length;
  	byte Param4[2];
  	word Param4_Length;
  };
  
  struct  SDS_CommandList_ArrayDataStruct               SDS_CommandList[Max_Array_Size];
  struct  SDS_ResultList_ArrayDataStruct                SDS_ResultList[Max_Array_Size];
  
  
  ///////////////////// Structs InfoSettings /////////////////////
  
  _align(1) struct InfoSettings_BTDeviceList_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3[100];
		 word Param3_Length;
	 };
  
  _align(1) struct InfoSettings_LicenseInformation_ArrayDataStruct {
		 word Param1;
		 byte Param2[1202];
		 word Param2_Length;
	 };
  
  struct  InfoSettings_BTDeviceList_ArrayDataStruct          InfoSettings_BTDeviceList[Max_Array_Size];
  struct  InfoSettings_LicenseInformation_ArrayDataStruct    InfoSettings_LicenseInformation[Max_Array_Size];
  
  
  ///////////////////// Struct ListPath /////////////////////
  
  _align(1) struct Listpath_ArrayDataStruct
  {
	  char  Param1[255];
	  word  Param1_Length;
    char  Param2[255];
	  word  Param2_Length;
  };
  
  struct Listpath_ArrayDataStruct                       Listpath[Max_Array_Size];
  
  
  ///////////////////// LSGIDs /////////////////////
  
  const LSGID_DoorLocking         = 13;
  const LSGID_BCmE                = 35;
  const LSGID_BatteryControl      = 37;
  const LSGID_Telefon             = 40;
  const LSGID_Telefon2            = 41;
  const LSGID_Audio               = 49;
  const LSGID_Navigation          = 50;
  const LSGID_SDS                 = 70;
  const LSGID_SDS_header          = 0;
  const LSGID_InfoSettings        = 80;
  const LSGID_InfoSettings_header = 0;
  
  
  ///////////////////// Node Index /////////////////////
  
  dword Node_Index_DoorLocking     = 0;
  dword Node_Index_BCmE            = 0;
  dword Node_Index_BatteryControl  = 0;
  dword Node_Index_Telefon         = 0;
  dword Node_Index_Telefon2        = 0;
  dword Node_Index_Audio           = 0;
  dword Node_Index_Navigation      = 0;
  dword Node_Index_SDS             = 0;
  dword Node_Index_InfoSettings    = 0;
  
  
  ///////////////////// Node Index (ASG = 1 / FSG = 2) /////////////////////

  byte DoorLocking_Source     = 0;
  byte BCmE_Source            = 0;
  byte BatteryControl_Source  = 0;
  byte Telefon_Source         = 0;
  byte Telefon2_Source        = 0;
  byte Audio_Source           = 0;
  byte Navigation_Source      = 0;
  byte SDS_Source             = 0;
  byte InfoSettings_Source    = 0;
  
  
  ///////////////////// BAP Request Types /////////////////////

 	const DataSetGet_REQ	   = 0x00;
	const DataSet_REQ			   = 0x01;
	const DataGet_REQ			   = 0x02;
	const Data_REQ				   = 0x03;
	const Changed_REQ			   = 0x04;
	const Start_REQ				   = 0x05;
	const StartResult_REQ		 = 0x06;
	const AbortResult_REQ		 = 0x07;
	const Processing_REQ		 = 0x08;
	const Result_REQ			   = 0x09;
	const DataAck_REQ        = 0x0A;
	const Ack_REQ            = 0x0B;
	const Invalid_REQ    		 = 0x1F; 
  
  
  ///////////////////// BAP Data Type  /////////////////////

  const Bap_void				        = 0;
	const Bap_uint8			         	= 1;
	const Bap_uint16		        	= 2;
	const Bap_uint32		        	= 3;
	const Bap_byteSequence	    	= 4;
  const Bap_fixedByteSequence   = 4;
  const Bap_error				        = 5;
  const Bap_acknowledge		      = 6;
  
  
  ///////////////////// BAP Indication Types /////////////////////

	const Data_IND				     = 0x00;
	const Reset_IND				     = 0x01;
  const DataAck_IND          = 0x02;
	const Result_IND			     = 0x03;
	const Processing_IND	     = 0x04;
  const Changed_IND			     = 0x05;
  const DataSetGet_IND	     = 0x06;
  const DataSet_IND			     = 0x07;
	const DataGet_IND			     = 0x08;
	const Ack_IND              = 0x09;
  const Processing_CNF_IND   = 0x0A;
	const Start_IND				     = 0x0B;
	const StartResult_IND		   = 0x0C;
	const AbortResult_IND		   = 0x0D;
	const Invalid_IND			     = 0x1F; 
  
  
  ///////////////////// BAP OpCodes /////////////////////
      
  const setget_OP            = 0x2;
  const get_OP               = 0x1;
  const reset_set_OP         = 0x0;
  const heartBeatStatus_OP   = 0x3;
  const status_OP            = 0x4;
  const statusACK_OP         = 0x5;
  const ack_OP               = 0x6;
  const error_OP             = 0x7;
  
  
  ///////////////////// BA Rx/Tx Variables DoorLocking /////////////////////
  
  byte  DoorLocking_app_data_ASG03[4][BAP_BUFFERSIZE];
  byte  DoorLocking_app_data_FSG01[4][BAP_BUFFERSIZE];
  
  byte  DoorLocking_received_function_ASG03[4][3];
  byte  DoorLocking_received_function_FSG01[4][3];
  
  dword DoorLocking_data_length_ASG03[4];
  dword DoorLocking_data_length_FSG01[4];
  
  byte  DoorLocking_sequenceNumberASG03[4];
  byte  DoorLocking_sequenceNumberFSG01[4];
  
  byte  DoorLocking_currentPosASG03[4];
  byte  DoorLocking_currentPosFSG01[4];
  
  
  ///////////////////// BAP Rx/Tx Variables BCmE /////////////////////
  
  byte  BCmE_app_data_ASG01[4][BAP_BUFFERSIZE];
  
  byte  BCmE_received_function_ASG01[4][3];
  
  dword BCmE_data_length_ASG01[4];
  
  byte  BCmE_sequenceNumberASG01[4];
  
  byte  BCmE_currentPosASG01[4];
  
  
  ///////////////////// BAP Rx/Tx Variables BatteryControl /////////////////////
  
  byte  BatteryControl_app_data_ASG03[4][BAP_BUFFERSIZE];
  byte  BatteryControl_app_data_ASG06[4][BAP_BUFFERSIZE];
  
  byte  BatteryControl_received_function_ASG03[4][3];
  byte  BatteryControl_received_function_ASG06[4][3];
  
  dword BatteryControl_data_length_ASG03[4];
  dword BatteryControl_data_length_ASG06[4];
  
  byte  BatteryControl_sequenceNumberASG03[4];
  byte  BatteryControl_sequenceNumberASG06[4];
  
  byte  BatteryControl_currentPosASG03[4];
  byte  BatteryControl_currentPosASG06[4];
  
    
  ///////////////////// BAP Rx/Tx Variables Telefon /////////////////////
  
  byte  Telefon_app_data_ASG01[4][BAP_BUFFERSIZE];
  byte  Telefon_app_data_ASG02[4][BAP_BUFFERSIZE];
  byte  Telefon_app_data_FSG01[4][BAP_BUFFERSIZE];
  byte  Telefon_app_data_FSG02[4][BAP_BUFFERSIZE];
  
  byte  Telefon_received_function_ASG01[4][3];
  byte  Telefon_received_function_ASG02[4][3];
  byte  Telefon_received_function_FSG01[4][3];
  byte  Telefon_received_function_FSG02[4][3];
  
  dword Telefon_data_length_ASG01[4];
  dword Telefon_data_length_ASG02[4];
  dword Telefon_data_length_FSG01[4];
  dword Telefon_data_length_FSG02[4];
  
  byte  Telefon_sequenceNumberASG01[4];
  byte  Telefon_sequenceNumberASG02[4];
  byte  Telefon_sequenceNumberFSG01[4];
  byte  Telefon_sequenceNumberFSG02[4];
  
  byte  Telefon_currentPosASG01[4];
  byte  Telefon_currentPosASG02[4];
  byte  Telefon_currentPosFSG01[4];
  byte  Telefon_currentPosFSG02[4];
  
    
  ///////////////////// BAP Rx/Tx Variables Telefon2 /////////////////////
  
  byte  Telefon2_app_data_ASG01[4][BAP_BUFFERSIZE];
  byte  Telefon2_app_data_ASG02[4][BAP_BUFFERSIZE];
  byte  Telefon2_app_data_FSG01[4][BAP_BUFFERSIZE];
  
  byte  Telefon2_received_function_ASG01[4][3];
  byte  Telefon2_received_function_ASG02[4][3];
  byte  Telefon2_received_function_FSG01[4][3];
  
  dword Telefon2_data_length_ASG01[4];
  dword Telefon2_data_length_ASG02[4];
  dword Telefon2_data_length_FSG01[4];
  
  byte  Telefon2_sequenceNumberASG01[4];
  byte  Telefon2_sequenceNumberASG02[4];
  byte  Telefon2_sequenceNumberFSG01[4];
  
  byte  Telefon2_currentPosASG01[4];
  byte  Telefon2_currentPosASG02[4];
  byte  Telefon2_currentPosFSG01[4];
  

  ///////////////////// BAP Rx/Tx Variables Audio /////////////////////

  byte  Audio_app_data_ASG01[4][BAP_BUFFERSIZE];
  byte  Audio_app_data_ASG02[4][BAP_BUFFERSIZE];
  byte  Audio_app_data_FSG01[4][BAP_BUFFERSIZE];
  byte  Audio_app_data_FSG02[4][BAP_BUFFERSIZE];
  
  byte  Audio_received_function_ASG01[4][3];
  byte  Audio_received_function_ASG02[4][3];
  byte  Audio_received_function_FSG01[4][3];
  byte  Audio_received_function_FSG02[4][3];
  
  dword Audio_data_length_ASG01[4];
  dword Audio_data_length_ASG02[4];
  dword Audio_data_length_FSG01[4];
  dword Audio_data_length_FSG02[4];
  
  byte  Audio_sequenceNumberASG01[4];
  byte  Audio_sequenceNumberASG02[4];
  byte  Audio_sequenceNumberFSG01[4];
  byte  Audio_sequenceNumberFSG02[4];
  
  byte  Audio_currentPosASG01[4];
  byte  Audio_currentPosASG02[4];
  byte  Audio_currentPosFSG01[4];
  byte  Audio_currentPosFSG02[4];

  
  ///////////////////// BAP Rx/Tx Variables Navigation /////////////////////
  
  byte  Navigation_app_data_ASG01[4][BAP_BUFFERSIZE];
  byte  Navigation_app_data_ASG02[4][BAP_BUFFERSIZE];
  byte  Navigation_app_data_ASG03[4][BAP_BUFFERSIZE];
  byte  Navigation_app_data_ASG04[4][BAP_BUFFERSIZE];
  byte  Navigation_app_data_FSG01[4][BAP_BUFFERSIZE];
  byte  Navigation_app_data_FSG02[4][BAP_BUFFERSIZE];
  
  byte  Navigation_received_function_ASG01[4][3];
  byte  Navigation_received_function_ASG02[4][3];
  byte  Navigation_received_function_ASG03[4][3];
  byte  Navigation_received_function_ASG04[4][3];
  byte  Navigation_received_function_FSG01[4][3];
  byte  Navigation_received_function_FSG02[4][3];
  
  dword Navigation_data_length_ASG01[4];
  dword Navigation_data_length_ASG02[4];
  dword Navigation_data_length_ASG03[4];
  dword Navigation_data_length_ASG04[4];
  dword Navigation_data_length_FSG01[4];
  dword Navigation_data_length_FSG02[4];
  
  byte  Navigation_sequenceNumberASG01[4];
  byte  Navigation_sequenceNumberASG02[4];
  byte  Navigation_sequenceNumberASG03[4];
  byte  Navigation_sequenceNumberASG04[4];
  byte  Navigation_sequenceNumberFSG01[4];
  byte  Navigation_sequenceNumberFSG02[4];
  
  byte  Navigation_currentPosASG01[4];
  byte  Navigation_currentPosASG02[4];
  byte  Navigation_currentPosASG03[4];
  byte  Navigation_currentPosASG04[4];
  byte  Navigation_currentPosFSG01[4];
  byte  Navigation_currentPosFSG02[4];
  
  
  ///////////////////// BAP Rx/Tx Variables SDS /////////////////////
  
  byte SDS_app_data_ASG01[4][BAP_BUFFERSIZE];
  
  byte SDS_received_function_ASG01[4][3];
  
  dword SDS_data_length_ASG01[4];
  
  byte SDS_sequenceNumberASG01[4];
  
  byte SDS_currentPosASG01[4];
  
  
  ///////////////////// BAP Rx/Tx Variables InfoSettings /////////////////////
  
  byte InfoSettings_app_data_ASG01[4][BAP_BUFFERSIZE];
  byte InfoSettings_app_data_FSG01[4][BAP_BUFFERSIZE];
  
  byte InfoSettings_received_function_ASG01[4][3];
  byte InfoSettings_received_function_FSG01[4][3];
  
  dword InfoSettings_data_length_ASG01[4];
  dword InfoSettings_data_length_FSG01[4];
  
  byte InfoSettings_sequenceNumberASG01[4];
  byte InfoSettings_sequenceNumberFSG01[4];
  
  byte InfoSettings_currentPosASG01[4];
  byte InfoSettings_currentPosFSG01[4];
  
  
  ///////////////////// Listen Variablen /////////////////////
  
  byte   DoorLocking_UserList_TotalListNum                = 0;
  char  gDoorLocking_UserList_Path[255]                   = "";
  const  DoorLocking_UserList_Length                      = 255;
  
  byte   BCmE_Consumer_TotalListNum                       = 0;
  char  gBCmE_Consumer_Path[255]                          = "";
  const  BCmE_Consumer_Length                             = 255;
  
  byte   BatteryControl_ProfilesExtended_TotalListNum     = 0;
  char  gBatteryControl_ProfilesExtended_Path[255]        = "";
  const  BatteryControl_ProfilesExtended_Length           = 255;
  byte   BatteryControl_Contracts_TotalListNum            = 0;
  char  gBatteryControl_Contracts_Path[255]               = "";
  const  BatteryControl_Contracts_Length                  = 255;
  
  byte   Telefon_CombinedNumbers_TotalListNum             = 0;
  char  gTelefon_CombinedNumbers_Path[255]                = "";
  const  Telefon_CombinedNumbers_Length                   = 255;
  int    Telefon_Phonebook_TotalListNum                   = 0;
  char  gTelefon_Phonebook_Path[255]                      = "";
  const  Telefon_Phonebook__Length                        = 255;
  byte   Telefon_FavoriteList_TotalListNum                = 0;
  char  gTelefon_FavoriteList_Path[255]                   = "";
  const  Telefon_FavoriteList_Length                      = 255;
  
  byte   Telefon2_CallPicture_TotalListNum                = 0;
  char  gTelefon2_CallPicture_Path[255]                   = "";
  const  Telefon2_CallPicture_Length                      = 255;
  
  int    Audio_ReceptionList_TotalListNum                 = 0;
  char  gAudio_ReceptionList_Path[11][255]                = { "", "", "", "", "", "", "", "", "", "", "" };
  const  Audio_ReceptionList_Length                       = 255;
  int    Audio_SourceList_TotalListNum                    = 0;
  char  gAudio_SourceList_Path[255]                       = "";
  const  Audio_SourceList_Length                          = 255;
  byte   Audio_RadioTVPresetList_TotalListNum             = 0;
  char  gAudio_RadioTVPresetList_Path[255]                = "";
  const  Audio_RadioTVPresetList_Length                   = 255;
  int    Audio_MediaBrowser_TotalListNum                  = 0;
  char  gAudio_MediaBrowser_Path[255]                     = "";
  const  Audio_MediaBrowser_Length                        = 255;
  int    Audio_SiriusAlertList_TotalListNum               = 0;
  char  gAudio_SiriusAlertList_Path[255]                  = "";
  const  Audio_SiriusAlertList_Length                     = 255;
  byte   Audio_LastStationList_TotalListNum               = 0;
  char  gAudio_LastStationList_Path[255]                  = "";
  const  Audio_LastStationList_Length                     = 255;
  byte   Audio_Picture_TotalListNum                       = 0;
  char  gAudio_Picture_Path[255]                          = "";
  const  Audio_Picture_Length                             = 255;
  byte   Audio_FavoriteList_TotalListNum                  = 0;
  char  gAudio_FavoriteList_Path[255]                     = "";
  const  Audio_FavoriteList_Length                        = 255;

  byte   Navigation_LaneGuidance_TotalListNum             = 0;
  char  gNavigation_LaneGuidance_Path[255]                = "";
  const  Navigation_LaneGuidance_Length                   = 255;
  byte   Navigation_LastDestList_TotalListNum             = 0;
  char  gNavigation_LastDestList_Path[255]                = "";
  const  Navigation_LastDestList_Length                   = 255;
  byte   Navigation_FavoriteDestList_TotalListNum         = 0;
  char  gNavigation_FavoriteDestList_Path[255]            = "";
  const  Navigation_FavoriteDestList_Length               = 255;
  int    Navigation_AddressList_TotalListNum              = 0;
  char  gNavigation_AddressList_Path[255]                 = "";
  const  Navigation_AddressList_Length                    = 255;
  int    Navigation_POI_List_TotalListNum                 = 0;
  char  gNavigation_POI_List_Path[255]                    = "";
  const  Navigation_POI_List_Length                       = 255;
  byte   Navigation_VideoStreams_TotalListNum             = 0;
  char  gNavigation_VideoStreams_Path[255]                = "";
  const  Navigation_VideoStreams_Length                   = 255;
  byte   Navigation_LaneGuidance2_TotalListNum            = 0;
  char  gNavigation_LaneGuidance2_Path[255]               = "";
  const  Navigation_LaneGuidance2_Length                  = 255;
  byte   Navigation_Picture_TotalListNum                  = 0;
  char  gNavigation_Picture_Path[255]                     = "";
  const  Navigation_Picture_Length                        = 255;
  
  byte   SDS_CommandList_TotalListNum                     = 0;
  char  gSDS_CommandList_Path[255]                        = "";
  const  SDS_CommandList_Length                           = 255;
  byte   SDS_ResultList_TotalListNum                      = 0;
  char  gSDS_ResultList_Path[255]                         = "";
  const  SDS_ResultList_Length                            = 255;
  
  byte   InfoSettings_BTDeviceList_TotalListNum           = 0;
  char  gInfoSettings_BTDeviceList_Path[255]              = "";
  const  InfoSettings_BTDeviceList_Length                 = 255;
  byte   InfoSettings_LicenseInformation_TotalListNum     = 0;
  char  gInfoSettings_LicenseInformation_Path[255]        = "";
  const  InfoSettings_LicenseInformation_Length           = 255;
  
  char  gIni_List_Path[255]                               = ".\\BAP_Sim\\Listpath.ini";
  const  Ini_List_Length                                  = 255;
  
  ///////////////////// Logische Kanäle /////////////////////
  
  byte   DoorLocking_UserList_Log_Channel;
  
  byte   BCmE_Consumer_Log_Channel;
  
  byte   BatteryControl_ProfilesExtended_Log_Channel;
  byte   BatteryControl_Contracts_Log_Channel;
  
  byte   Telefon_CombinedNumbers_Log_Channel;
  byte   Telefon_Phonebook_Log_Channel;
  byte   Telefon_FavoriteList_Log_Channel;
  
  byte   Telefon2_CallPicture_Log_Channel;
  
  byte   Audio_ReceptionList_Log_Channel;
  byte   Audio_SourceList_Log_Channel;
  byte   Audio_RadioTVPresetList_Log_Channel;
  byte   Audio_MediaBrowser_Log_Channel;
  byte   Audio_SiriusAlertList_Log_Channel;
  byte   Audio_LastStationList_Log_Channel;
  byte   Audio_Picture_Log_Channel;
  byte   Audio_FavoriteList_Log_Channel;

  byte   Navigation_LaneGuidance_Log_Channel;
  byte   Navigation_LastDestList_Log_Channel;
  byte   Navigation_FavoriteDestList_Log_Channel;
  byte   Navigation_AddressList_Log_Channel;
  byte   Navigation_POI_List_Log_Channel;
  
  byte   SDS_CommandList_Log_Channel;
  byte   SDS_ResultList_Log_Channel;
  
  byte   InfoSettings_BTDeviceList_Log_Channel;
  byte   InfoSettings_LicenseInformation_Log_Channel;
  
  
  ///////////////////// Array Variablen /////////////////////
  
  byte   Data_DoorLocking_UserList[BAP_BUFFERSIZE];
  int       j_DoorLocking_UserList = 0;
  
  byte   Data_BCmE_Consumer[BAP_BUFFERSIZE];
  int       j_BCmE_Consumer = 0;
  
  byte   Data_BatteryControl_ProfilesExtended[BAP_BUFFERSIZE];
  int       j_BatteryControl_ProfilesExtended = 0; 
  byte   Data_BatteryControl_Contracts[BAP_BUFFERSIZE];
  int       j_BatteryControl_Contracts = 0;
  
  byte   Data_Telefon_CombinedNumbers[BAP_BUFFERSIZE];
  int       j_Telefon_CombinedNumbers = 0; 
  byte   Data_Telefon_Phonebook[BAP_BUFFERSIZE];
  int       j_Telefon_Phonebook = 0;
  byte   Data_Telefon_FavoriteList[BAP_BUFFERSIZE];
  int       j_Telefon_FavoriteList = 0;
  
  byte   Data_Telefon2_CallPicture[BAP_BUFFERSIZE];
  int       j_Telefon2_CallPicture = 0;
  
  byte   Data_Audio_ReceptionList[BAP_BUFFERSIZE];
  int       j_Audio_ReceptionList = 0;
  byte   Data_Audio_SourceList[BAP_BUFFERSIZE];
  int       j_Audio_SourceList = 0;
  byte   Data_Audio_RadioTVPresetList[BAP_BUFFERSIZE];
  int       j_Audio_RadioTVPresetList = 0;
  byte   Data_Audio_MediaBrowser[BAP_BUFFERSIZE];
  int       j_Audio_MediaBrowser = 0;
  byte   Data_Audio_SiriusAlertList[BAP_BUFFERSIZE];
  int       j_Audio_SiriusAlertList=0;
  byte   Data_Audio_LastStationList[BAP_BUFFERSIZE];
  int       j_Audio_LastStationList=0;
  byte   Data_Audio_Picture[BAP_BUFFERSIZE];
  int       j_Audio_Picture=0;
  byte   Data_Audio_FavoriteList[BAP_BUFFERSIZE];
  int       j_Audio_FavoriteList=0;
  
  byte   Data_Navigation_LaneGuidance[BAP_BUFFERSIZE];
  int       j_Navigation_LaneGuidance = 0;
  byte   Data_Navigation_LastDestList[BAP_BUFFERSIZE];
  int       j_Navigation_LastDestList = 0;
  byte   Data_Navigation_FavoriteDestList[BAP_BUFFERSIZE];
  int       j_Navigation_FavoriteDestList = 0;
  byte   Data_Navigation_AddressList[BAP_BUFFERSIZE];
  int       j_Navigation_AddressList = 0;
  byte   Data_Navigation_POI_List[BAP_BUFFERSIZE];
  int       j_Navigation_POI_List = 0;
  byte   Data_Navigation_VideoStreams[BAP_BUFFERSIZE];
  int       j_Navigation_VideoStreams = 0;
  byte   Data_Navigation_LaneGuidance2[BAP_BUFFERSIZE];
  int       j_Navigation_LaneGuidance2 = 0;
  byte   Data_Navigation_Picture[BAP_BUFFERSIZE];
  int       j_Navigation_Picture = 0;
  
  byte   Data_SDS_CommandList[BAP_BUFFERSIZE];
  int       j_SDS_CommandList = 0;
  byte   Data_SDS_ResultList[BAP_BUFFERSIZE];
  int       j_SDS_ResultList = 0;
  
  byte   Data_InfoSettings_BTDeviceList[BAP_BUFFERSIZE];
  int       j_InfoSettings_BTDeviceList = 0;
  byte   Data_InfoSettings_LicenseInformation[BAP_BUFFERSIZE];
  int       j_InfoSettings_LicenseInformation = 0;
  
  
  ///////////////////// Delay Timer /////////////////////
  
  mstimer Delay_DoorLocking_UserList;
  
  mstimer Delay_BCmE_Consumer;
  
  mstimer Delay_BatteryControl_Contracts;
  mstimer Delay_BatteryControl_ProfilesExtended;
  
  mstimer Delay_Telefon_CombinedNumbers;
  mstimer Delay_Telefon_Phonebook;
  mstimer Delay_Telefon_FavoriteList;
  
  mstimer Delay_Telefon2_CallPicture;
  
  mstimer Delay_Audio_ReceptionList;
  mstimer Delay_Audio_SouceList;
  mstimer Delay_Audio_RadioTVPresetList;
  mstimer Delay_Audio_MediaBrowser;
  mstimer Delay_Audio_SiriusAlertList;
  mstimer Delay_Audio_LastStationList;
  mstimer Delay_Audio_Picture;
  mstimer Delay_Audio_FavoriteList;
  
  mstimer Delay_Navigation_LaneGuidance;
  mstimer Delay_Navigation_LastDestList;
  mstimer Delay_Navigation_FavoriteDestList;
  mstimer Delay_Navigation_AddressList;
  mstimer Delay_Navigation_POI_List;
  mstimer Delay_Navigation_VideoStreams;
  mstimer Delay_Navigation_LaneGuidance2;
  mstimer Delay_Navigation_Picture;
  
  mstimer Delay_SDS_CommandList;
  mstimer Delay_SDS_ResultList;
  
  mstimer Delay_InfoSettings_BTDeviceList;
  mstimer Delay_InfoSettings_LicenseInformation;
  
  
  ///////////////////// Mix Variablen /////////////////////
  
  //Allgemein
  int  log_channel=0;
  byte dummy_data[1];
  
  // DoorLocking
  msTimer UserProfileOn;
  
  // Telefon
  byte TelNumberQuantity;
  
  // Audio
  dword activeSource_Reference = 0;
  dword previous_AudioSource = 0;
  byte  Audio_ReceptionList_available;
  byte  Audio_RadioTV_PresetList_available;
  byte  Audio_MediaBrowser_available;
  byte  Audio_SiriusAlertList_available;
  byte  Audio_LastStationList_available;
  byte  Audio_FavoriteList_available;
  dword gCurrentFile_absolutePosition;
  byte  bool_dedicatedAudioControl = FALSE;
  int   gFolder_Level = 0;
  int   gCurrentFolder[256];
  dword gActiveListPosition;
  dword gFsgHandle_absolutePosition = 0;
  dword gFsgHandle =0;
  dword PresetList_Ref =0;
  dword PresetList_absolutePosition =0;
  dword gListType = 0;
  dword gWaveband[100];
  dword gFileType[100];
  char  gCategory[96][72] = {"Unbekannt","Nachrichten","current Affairs","Information", "Sport","Erziehung","Drama","Kultur","Wissenschaft","varied",
                            "Pop","Rock","easy listening","leichte Klassik","seriöse Klassik","andere Musik","Wetter","Finanzen",
                            "Kinderprogramm","Klatsch","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",
                            "","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",
                            "","","","","",""};
  
  // DisplayConfig Testpanel
  mstimer set;
  mstimer reset;
  mstimer reset2;
  mstimer check_display_fcts;
  byte    seg_flag = 0;
  byte    DisplayConfig_log_Kanal;
  byte    DisCon_TAID = 1;
  mstimer ElementContent01_SetGet;
  mstimer ElementContent02_SetGet;
  mstimer ElementContent03_SetGet;
  mstimer ElementContent04_SetGet;
  mstimer ElementContent05_SetGet;
  mstimer ElementContent06_SetGet;
  mstimer ElementContent07_SetGet;
  const   ElementContent_timer_delay = 50;
  byte    ElementContentSelection_lock1_1;
  byte    ElementContentSelection_lock2_1;
  byte    ElementContentSelection_lock3_1;
  byte    ElementContentSelection_lock1_2;
  byte    ElementContentSelection_lock2_2;
  byte    ElementContentSelection_lock3_2;
  
  // BAP Listen_Test
  byte Audio_ReceptionList_Offset = 0;
  byte Audio_ReceptionList_Changed_Offset = 0;
  byte Audio_ReceptionList_Changed_Max = 0;
  byte Audio_ReceptionList_Changed_Min = 0;
  word Audio_ReceptionList_Changed_Array_Pos[BAP_BUFFERSIZE];
  byte Audio_ReceptionList_Changed_Array_Type[BAP_BUFFERSIZE];
  word Audio_ReceptionList_Changed_Array_Attributes[BAP_BUFFERSIZE];
  byte Audio_ReceptionList_Changed_Array_PresetID[BAP_BUFFERSIZE];
  byte Audio_ReceptionList_Changed_Array_FmREG_Code[BAP_BUFFERSIZE];
  byte Audio_ReceptionList_Changed_Array_Category[BAP_BUFFERSIZE];
  char Audio_ReceptionList_Changed_Array_Name[49][BAP_BUFFERSIZE];
  char Audio_ReceptionList_Changed_Array_Frequency[31][BAP_BUFFERSIZE];
  
  // (GVBP-193)
  byte u8Info1[97];
  byte u8Info2[31];
  char cInfo1[97];
  char cInfo2[31];

}

on preStart
{   
  byte temp = 0;
  char Path[255];    

  ///////////////////// Erzeugen der Ausgabeconsole /////////////////////
  
  gBAP_Trace=writecreate("BAPControl");        //write-window for BAP-cummunication
  writeclear(gBAP_Trace);                     //clear BAP-window in write-window
}

on preStop
{
  ///////////////////// Node Index rücksetzen /////////////////////
  
  @Node_Index_FSG_13 = 0;
  @Node_Index_FSG_35 = 0;
  @Node_Index_FSG_37 = 0;
  @Node_Index_FSG_40 = 0;
  @Node_Index_FSG_41 = 0;
  @Node_Index_FSG_49 = 0;
  @Node_Index_FSG_50 = 0;
  @Node_Index_FSG_70 = 0;
  @Node_Index_FSG_80 = 0;
}

on start
{   
  int i, j; 
  
  ///////////////////// Start Initialisierungen /////////////////////
  
  BAP_off();          // alle BAP Panels deaktivieren
  check_ini();        // csv-Pfade auslesen
  clear_List_panel(); // Listentestpanel löschen
  

  ///////////////////// Laden der BAP-Listen /////////////////////

  DoorLocking_UserList_LoadArray();
  putValue(Env_DoorLocking_UserList_Path, gDoorLocking_UserList_Path);
  
  BCmE_Consumer_LoadArray();
  putValue(Env_BCmE_Consumer_Path, gBCmE_Consumer_Path);
  
  BatteryControl_ProfilesExtended_LoadArray();
  putValue(Env_BatteryControl_ProfilesExtended_Path, gBatteryControl_ProfilesExtended_Path);
  BatteryControl_Contracts_LoadArray();
  putValue(Env_BatteryControl_Contracts_Path,        gBatteryControl_Contracts_Path);
  
  Telefon_CombinedNumbers_LoadArray();
  putValue(Env_Telefon_CombinedNumbers_Path,         gTelefon_CombinedNumbers_Path);
  Telefon_Phonebook_LoadArray();
  putValue(Env_Telefon_Phonebook_Path,               gTelefon_Phonebook_Path);
  Telefon_FavoriteList_LoadArray();
  putValue(Env_Telefon_FavoriteList_Path,            gTelefon_FavoriteList_Path);
  
  Telefon2_CallPicture_LoadArray();
  putValue(Env_Telefon2_CallPicture_Path,            gTelefon2_CallPicture_Path);
  
  Audio_ReceptionList_LoadArray();
  putValue(Env_Audio_ReceptionList_FM_Path,          gAudio_ReceptionList_Path[0]);
  putValue(Env_Audio_ReceptionList_AM_Path,          gAudio_ReceptionList_Path[1]);
  putValue(Env_Audio_ReceptionList_DAB_Path,         gAudio_ReceptionList_Path[2]);
  putValue(Env_Audio_ReceptionList_SDARS_Path,       gAudio_ReceptionList_Path[3]);
  putValue(Env_Audio_ReceptionList_DVB_Path,         gAudio_ReceptionList_Path[4]);
  putValue(Env_Audio_ReceptionList_TV_Path,          gAudio_ReceptionList_Path[5]);
  putValue(Env_Audio_ReceptionList_AM_SW_Path,       gAudio_ReceptionList_Path[6]);
  putValue(Env_Audio_ReceptionList_AM_LW_Path,       gAudio_ReceptionList_Path[7]);
  putValue(Env_Audio_ReceptionList_OnlineRadio_Path, gAudio_ReceptionList_Path[8]);
  putValue(Env_Audio_ReceptionList_CommonList_Path,  gAudio_ReceptionList_Path[9]);
  Audio_SourceList_LoadArray();
  putValue(Env_Audio_SourceList_Path,                gAudio_SourceList_Path);
  Audio_RadioTVPresetList_LoadArray();
  putValue(Env_Audio_RadioTVPresetList_Path,         gAudio_RadioTVPresetList_Path);
  Audio_MediaBrowser_LoadArray();
  putValue(Env_Audio_MediaBrowser_Path,              gAudio_MediaBrowser_Path);
  Audio_SiriusAlertList_LoadArray();
  putValue(Env_Audio_SiriusAlertList_Path,           gAudio_SiriusAlertList_Path);
  Audio_LastStationList_LoadArray();
  putValue(Env_Audio_LastStationList_Path,           gAudio_LastStationList_Path);
  Audio_Picture_LoadArray();
  putValue(Env_Audio_Picture_Path,                   gAudio_Picture_Path);
  Audio_FavoriteList_LoadArray();
  putValue(Env_Audio_FavoriteList_Path,              gAudio_FavoriteList_Path);
  
  Navigation_LaneGuidance_LoadArray();
  putValue(Env_Navigation_LaneGuidance_Path,         gNavigation_LaneGuidance_Path);
  Navigation_LastDestList_LoadArray();
  putValue(Env_Navigation_LastDestList_Path,         gNavigation_LastDestList_Path);
  Navigation_FavoriteDestList_LoadArray();
  putValue(Env_Navigation_FavoriteDestList_Path,     gNavigation_FavoriteDestList_Path);
  Navigation_AddressList_LoadArray();
  putValue(Env_Navigation_AddressList_Path,          gNavigation_AddressList_Path);
  Navigation_POI_List_LoadArray();
  putValue(Env_Navigation_POI_List_Path,             gNavigation_POI_List_Path);
  Navigation_VideoStreams_LoadArray();
  putValue(Env_Navigation_VideoStreams_Path,         gNavigation_VideoStreams_Path);
  Navigation_LaneGuidance2_LoadArray();
  putValue(Env_Navigation_LaneGuidance2_Path,        gNavigation_LaneGuidance2_Path);
  Navigation_Picture_LoadArray();
  putValue(Env_Navigation_Picture_Path,              gNavigation_Picture_Path);
  
  SDS_CommandList_LoadArray();
  putValue(Env_SDS_CommandList_Path,                 gSDS_CommandList_Path);
  SDS_ResultList_LoadArray();
  putValue(Env_SDS_ResultList_Path,                  gSDS_ResultList_Path);
  
  InfoSettings_BTDeviceList_LoadArray();
  putValue(Env_InfoSettings_BTDeviceList_Path,       gInfoSettings_BTDeviceList_Path);
  InfoSettings_LicenseInformation_LoadArray();
  putValue(Env_InfoSettings_LicenseInformation_Path, gInfoSettings_LicenseInformation_Path);
  

  // Listen Delays auf 0 setzen
  @Env_DoorLocking_UserList_ListDelay               = 0;
  @Env_BCmE_Consumer_ListDelay                      = 0;
  @Env_BatteryControl_ProfilesExtended_ListDelay    = 0;
  @Env_BatteryControl_Contracts_ListDelay           = 0;
  @Env_Telefon_CombinedNumbers_ListDelay            = 0;
  @Env_Telefon_Phonebook_ListDelay                  = 0;
  @Env_Telefon_FavoriteList_ListDelay               = 0;
  @Env_Telefon2_CallPicture_ListDelay               = 0;
  @Env_Audio_ReceptionList_ListDelay                = 0;
  @Env_Audio_SourceList_ListDelay                   = 0;
  @Env_Audio_RadioTVPresetList_ListDelay            = 0;
  @Env_Audio_MediaBrowser_ListDelay                 = 0;
  @Env_Audio_SiriusAlertList_ListDelay              = 0;
  @Env_Audio_LastStationList_ListDelay              = 0;
  @Env_Audio_Picture_ListDelay                      = 0;
  @Env_Audio_FavoriteList_ListDelay                 = 0;
  @Env_Navigation_LaneGuidance_ListDelay            = 0;
  @Env_Navigation_LastDestList_ListDelay            = 0;
  @Env_Navigation_FavoriteDestList_ListDelay        = 0;
  @Env_Navigation_AddressList_ListDelay             = 0;
  @Env_Navigation_POI_List_ListDelay                = 0;
  @Env_SDS_CommandList_ListDelay                    = 0;
  @Env_SDS_ResultList_ListDelay                     = 0;
  @Env_InfoSettings_BTDeviceList_ListDelay          = 0;
  @Env_InfoSettings_LicenseInformation_ListDelay    = 0;
  
  @Env_BAP_Pro_Res = 1;
  
  
  // MLBevo Gen1: BAP Buttons auf Deckblatt ein-/ausblenden
  switch (@BAP::Variant)
  {
    case 0:
      // MLBevo Gen1
      setControlVisibility("deckblatt","BAP_Q7"              ,1);
      setControlVisibility("deckblatt","BAP_B9PA_TOP_MED_MM" ,0);
      setControlVisibility("deckblatt","BAP_B9PA_FPK2+_RB"   ,0);
      setControlVisibility("deckblatt","BAP_B9PA_TOP_RB"     ,0);
      
      // MQB 2020
      setControlVisibility("Deckblatt","BAP_FPK2+"           ,1);
      setControlVisibility("Deckblatt","BAP_FPK_Medium"      ,0);
      setControlVisibility("Deckblatt","BAP_HUD_AU"          ,0);
      setControlVisibility("Deckblatt","BAP_HUD_VW"          ,0);
    break;
      
    case 1:
      // MLBevo Gen1
      setControlVisibility("deckblatt","BAP_Q7"              ,0);
      setControlVisibility("deckblatt","BAP_B9PA_TOP_MED_MM" ,1);
      setControlVisibility("deckblatt","BAP_B9PA_FPK2+_RB"   ,0);
      setControlVisibility("deckblatt","BAP_B9PA_TOP_RB"     ,0);
      
      // MQB 2020
      setControlVisibility("Deckblatt","BAP_FPK2+"           ,0);
      setControlVisibility("Deckblatt","BAP_FPK_Medium"      ,1);
      setControlVisibility("Deckblatt","BAP_HUD_AU"          ,0);
      setControlVisibility("Deckblatt","BAP_HUD_VW"          ,0);
    break;
      
    case 2:
      // MLBevo Gen1
      setControlVisibility("deckblatt","BAP_Q7"              ,0);
      setControlVisibility("deckblatt","BAP_B9PA_TOP_MED_MM" ,0);
      setControlVisibility("deckblatt","BAP_B9PA_FPK2+_RB"   ,1);
      setControlVisibility("deckblatt","BAP_B9PA_TOP_RB"     ,0);
      
      // MQB 2020
      setControlVisibility("Deckblatt","BAP_FPK2+"           ,0);
      setControlVisibility("Deckblatt","BAP_FPK_Medium"      ,0);
      setControlVisibility("Deckblatt","BAP_HUD_AU"          ,1);
      setControlVisibility("Deckblatt","BAP_HUD_VW"          ,0);
    break;
      
    case 3:
      // MLBevo Gen1
      setControlVisibility("deckblatt","BAP_Q7"              ,0);
      setControlVisibility("deckblatt","BAP_B9PA_TOP_MED_MM" ,0);
      setControlVisibility("deckblatt","BAP_B9PA_FPK2+_RB"   ,0);
      setControlVisibility("deckblatt","BAP_B9PA_TOP_RB"     ,1);
      
      // MQB 2020
      setControlVisibility("Deckblatt","BAP_FPK2+"           ,0);
      setControlVisibility("Deckblatt","BAP_FPK_Medium"      ,0);
      setControlVisibility("Deckblatt","BAP_HUD_AU"          ,0);
      setControlVisibility("Deckblatt","BAP_HUD_VW"          ,1);
    break;
  }
  
  Audio_ReceptionList_Offset = 0;
  
  // Arrays leeren
  for (i=0; i<BAP_BUFFERSIZE; i++)
  {
    Audio_ReceptionList_Changed_Array_Pos[i]        = 0;
    Audio_ReceptionList_Changed_Array_Type[i]       = 0;
    Audio_ReceptionList_Changed_Array_Attributes[i] = 0;
    Audio_ReceptionList_Changed_Array_PresetID[i]   = 0;
    Audio_ReceptionList_Changed_Array_FmREG_Code[i] = 0;
    Audio_ReceptionList_Changed_Array_Category[i]   = 0;
    for (j=0; j<49; j++)
      Audio_ReceptionList_Changed_Array_Name[j][i]  = 0;
    for (j=0; j<31; j++)
      Audio_ReceptionList_Changed_Array_Frequency[j][i] = 0;
  }
  
  @Audio_ReceptionList_Changed_Pos = 0;
  @Audio_ReceptionList_Changed_Type = 0;
  @Audio_ReceptionList_Changed_Attributes = 0;
  @Audio_ReceptionList_Changed_PresetID = 0;
  @Audio_ReceptionList_Changed_FmREG_Code = 0;
  @Audio_ReceptionList_Changed_Category = 0;
  putvalue (Audio_ReceptionList_Changed_Name, "");
  putvalue (Audio_ReceptionList_Changed_Frequency, "");
  
  
  
  ///////////////////// Defaultwerte CBEV-Ladepanel /////////////////////
  
  @A_FSG_37_0_0_39_1           = 0; // ASG ID
  @A_FSG_37_0_0_39_2_range     = 1; // TAID
  @A_FSG_37_0_0_39_3_range     = 1; // TotalNumListElements
  @A_FSG_37_0_0_39_RecAdr      = 4; // RecordAddress
  @A_FSG_37_0_0_39_Shift       = 0; // Mode: Shift
  @A_FSG_37_0_0_39_Direction   = 0; // Mode: Direction
  @A_FSG_37_0_0_39_TransPos    = 0; // Mode: TransPos
  @A_FSG_37_0_0_39_IndexSize   = 0; // Mode: IndexSize
  @A_FSG_37_0_0_39_Start       = 0; // Start
  @A_FSG_37_0_0_39_Elements    = 3; // Elements
  
  
  
  @Env_DisCon_Start = 0;
  @Env_DisCon_ElementContentSelection_Nebenanzeige = 1;
  @Env_DisCon_ElementContentSelection_linkesRundelement = 1;
  @Env_DisCon_ElementContentSelection_NebenanzeigeSport = 1;
}
  
check_ini()
{ 
 /********* Statische Deklarationen ***********/
	dword fileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_byte;
	dword element;
	dword current_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char filename[255];
  char filepath[255];
  byte pos;
  byte path_stop=0;

	/********* Param Puffer Deklarationen ***********/
	//char temp1[25];
  //char temp2[25];
  
	/********* Initialisierungen ***********/
  
	fileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_byte = 0;
	element = 1;
	current_line = 0;

	for (i = 0; i < Ini_List_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		for (j=0; j<255; j++) 
	  Listpath[i].Param1[j] = 0;
		Listpath[i].Param1_Length = 0;
	
		for (j=0; j<255; j++)
		Listpath[i].Param2[j] = 0;
		Listpath[i].Param2_Length = 0;
	}

	/********* Laden der ini-Datei ***********/
  for (i = 0; i < strlen(gIni_List_Path); i++)
  {
    if (gIni_List_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(filepath, filepath, "");
  str_replace(filename, filename, "");
 
  // Strings aufteilen
  substr_cpy(filepath, gIni_List_Path, 0, pos, elcount(filepath)); 
  substr_cpy(filename, gIni_List_Path, (pos+1), -1, elcount(filename)); 
  
	setFilePath(filepath,0);
  fileHandle = openFileRead(filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (fileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", filename);    //output result
		//get data from *.csv and store the total number of byte in file
		Num_of_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), fileHandle);

		for (filePos = 0; filePos < Num_of_byte; filePos++) 
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.in (next "record element" in Listpath) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{     //writelineex(4,0,"LF / CR detected");
					if (current_line > 0 && current_line < 181) //ignore first line in file
					{
            //Listpath[current_line-1].Param1 = atol(temp1);
						//Listpath[current_line-1].Param2 = atol(temp2);
            
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
              //temp1[i]=0;
              //temp2[i]=0;
						}
					}
					current_line++; //next line in file
          element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from file) in help values and "name" until end of line is not detected
				else if (current_line > 0 && current_line < 181)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1:
								if (paramPos < 255)
								{
									Listpath[current_line-1].Param1[paramPos] = buffer_byte[filePos];
									Listpath[current_line-1].Param1_Length = paramPos +1;
								}
								paramPos++;
						break;
                
						case 2:
								if (paramPos < 255)
								{
									Listpath[current_line-1].Param2[paramPos] = buffer_byte[filePos];
									Listpath[current_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						  break;
                
						default:
                  
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (fileHandle) !=0) //close file
      writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",filename); //output result
	}
  
  
  ///////////////////// Auswertung der einzelnen Pfade /////////////////////
  
  // DoorLocking-UserList
  for (i=0; i<elcount(Listpath[0].Param2) && path_stop == 0; i++)
  {
    if (Listpath[0].Param2[i] != 0x00)  // solang nicht leer
      gDoorLocking_UserList_Path[i] = Listpath[0].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // BCmE-Consumer
  for (i=0; i<elcount(Listpath[3].Param2) && path_stop == 0; i++)
  {
    if (Listpath[3].Param2[i] != 0x00)  // solang nicht leer
      gBCmE_Consumer_Path[i] = Listpath[3].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // BatteryControl-ProfilesExtended
  for (i=0; i<elcount(Listpath[6].Param2) && path_stop == 0; i++)
  {
    if (Listpath[6].Param2[i] != 0x00)  // solang nicht leer
      gBatteryControl_ProfilesExtended_Path[i] = Listpath[6].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // BatteryControl-Contracts
  for (i=0; i<elcount(Listpath[7].Param2) && path_stop == 0; i++)
  {
    if (Listpath[7].Param2[i] != 0x00)  // solang nicht leer
      gBatteryControl_Contracts_Path[i] = Listpath[7].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // Telefon-CombinedNumbers   
  for (i=0; i<elcount(Listpath[10].Param2) && path_stop == 0; i++)
  {
    if (Listpath[10].Param2[i] != 0x00)  // solang nicht leer
      gTelefon_CombinedNumbers_Path[i] = Listpath[10].Param2[i];
    else
      path_stop = 1;
  }
  
  path_stop = 0;
  
  // Telefon-Telefon_Phonebook_TotalListNum
  for (i=0; i<elcount(Listpath[11].Param2) && path_stop == 0; i++)
  {
    if (Listpath[11].Param2[i] != 0x00)  // solang nicht leer
      gTelefon_Phonebook_Path[i] = Listpath[11].Param2[i];
    else
      path_stop = 1;
  }  
  
  path_stop = 0;
  
  // Telefon-FavoriteList
  for (i=0; i<elcount(Listpath[12].Param2) && path_stop == 0; i++)
  {
    if (Listpath[12].Param2[i] != 0x00)  // solang nicht leer
      gTelefon_FavoriteList_Path[i] = Listpath[12].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // Telefon2-CallPicture
  for (i=0; i<elcount(Listpath[15].Param2) && path_stop == 0; i++)
  {
    if (Listpath[15].Param2[i] != 0x00)  // solang nicht leer
      gTelefon2_CallPicture_Path[i] = Listpath[15].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // Audio-ReceptionList-FM
  for (i=0; i<elcount(Listpath[18].Param2) && path_stop == 0; i++)
  {
    if (Listpath[18].Param2[i] != 0x00)  // solang nicht leer
      gAudio_ReceptionList_Path[0][i] = Listpath[18].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Audio-ReceptionList-AM
  for (i=0; i<elcount(Listpath[19].Param2) && path_stop == 0; i++)
  {
    if (Listpath[19].Param2[i] != 0x00)  // solang nicht leer
      gAudio_ReceptionList_Path[1][i] = Listpath[19].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Audio-ReceptionList-DAB
  for (i=0; i<elcount(Listpath[20].Param2) && path_stop == 0; i++)
  {
    if (Listpath[20].Param2[i] != 0x00)  // solang nicht leer
      gAudio_ReceptionList_Path[2][i] = Listpath[20].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Audio-ReceptionList-SDARS
  for (i=0; i<elcount(Listpath[21].Param2) && path_stop == 0; i++)
  {
    if (Listpath[21].Param2[i] != 0x00)  // solang nicht leer
      gAudio_ReceptionList_Path[3][i] = Listpath[21].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Audio-ReceptionList-AM-LW
  for (i=0; i<elcount(Listpath[22].Param2) && path_stop == 0; i++)
  {
    if (Listpath[22].Param2[i] != 0x00)  // solang nicht leer
      gAudio_ReceptionList_Path[7][i] = Listpath[22].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Audio-ReceptionList-AM-SW
  for (i=0; i<elcount(Listpath[23].Param2) && path_stop == 0; i++)
  {
    if (Listpath[23].Param2[i] != 0x00)  // solang nicht leer
      gAudio_ReceptionList_Path[6][i] = Listpath[23].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Audio-ReceptionList-TV
  for (i=0; i<elcount(Listpath[24].Param2) && path_stop == 0; i++)
  {
    if (Listpath[24].Param2[i] != 0x00)  // solang nicht leer
      gAudio_ReceptionList_Path[5][i] = Listpath[24].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Audio-ReceptionList-DVB
  for (i=0; i<elcount(Listpath[25].Param2) && path_stop == 0; i++)
  {
    if (Listpath[25].Param2[i] != 0x00)  // solang nicht leer
      gAudio_ReceptionList_Path[4][i] = Listpath[25].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Audio-ReceptionList-OnlineRadio
  for (i=0; i<elcount(Listpath[26].Param2) && path_stop == 0; i++)
  {
    if (Listpath[26].Param2[i] != 0x00)  // solang nicht leer
      gAudio_ReceptionList_Path[8][i] = Listpath[26].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Audio-ReceptionList-CommonList
  for (i=0; i<elcount(Listpath[27].Param2) && path_stop == 0; i++)
  {
    if (Listpath[27].Param2[i] != 0x00)  // solang nicht leer
      gAudio_ReceptionList_Path[9][i] = Listpath[27].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // Audio-SourceList
  for (i=0; i<elcount(Listpath[28].Param2) && path_stop == 0; i++)
  {
    if (Listpath[28].Param2[i] != 0x00)  // solang nicht leer
      gAudio_SourceList_Path[i] = Listpath[28].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
    
  // Audio-PresetList
  for (i=0; i<elcount(Listpath[29].Param2) && path_stop == 0; i++)
  {
    if (Listpath[29].Param2[i] != 0x00)  // solang nicht leer
      gAudio_RadioTVPresetList_Path[i] = Listpath[29].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
    
  // Audio-MediaBrowser
  for (i=0; i<elcount(Listpath[30].Param2) && path_stop == 0; i++)
  {
    if (Listpath[30].Param2[i] != 0x00)  // solang nicht leer
      gAudio_MediaBrowser_Path[i] = Listpath[30].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
    
  // Audio-SiriusAlertList
  for (i=0; i<elcount(Listpath[31].Param2) && path_stop == 0; i++)
  {
    if (Listpath[31].Param2[i] != 0x00)  // solang nicht leer
      gAudio_SiriusAlertList_Path[i] = Listpath[31].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
    
  // Audio-LastStationList
  for (i=0; i<elcount(Listpath[32].Param2) && path_stop == 0; i++)
  {
    if (Listpath[32].Param2[i] != 0x00)  // solang nicht leer
      gAudio_LastStationList_Path[i] = Listpath[32].Param2[i];
    else
      path_stop = 1;
  }
  
  path_stop = 0;
  
  // Audio-Picture
  for (i=0; i<elcount(Listpath[33].Param2) && path_stop == 0; i++)
  {
    if (Listpath[33].Param2[i] != 0x00)  // solang nicht leer
      gAudio_Picture_Path[i] = Listpath[33].Param2[i];
    else
      path_stop = 1;
  }
  
  path_stop = 0;
  
  // Audio-FavoriteList
  for (i=0; i<elcount(Listpath[34].Param2) && path_stop == 0; i++)
  {
    if (Listpath[34].Param2[i] != 0x00)  // solang nicht leer
      gAudio_FavoriteList_Path[i] = Listpath[34].Param2[i];
    else
      path_stop = 1;
  }
  
  path_stop = 0;
    
  // Navigation-LaneGuidance
  for (i=0; i<elcount(Listpath[37].Param2) && path_stop == 0; i++)
  {
    if (Listpath[37].Param2[i] != 0x00)  // solang nicht leer
      gNavigation_LaneGuidance_Path[i] = Listpath[37].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Navigation-VideoStreams
  for (i=0; i<elcount(Listpath[42].Param2) && path_stop == 0; i++)
  {
    if (Listpath[42].Param2[i] != 0x00)  // solang nicht leer
      gNavigation_VideoStreams_Path[i] = Listpath[42].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Navigation-LaneGuidance2
  for (i=0; i<elcount(Listpath[43].Param2) && path_stop == 0; i++)
  {
    if (Listpath[43].Param2[i] != 0x00)  // solang nicht leer
      gNavigation_LaneGuidance2_Path[i] = Listpath[43].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
  
  // Navigation-Picture
  for (i=0; i<elcount(Listpath[44].Param2) && path_stop == 0; i++)
  {
    if (Listpath[44].Param2[i] != 0x00)  // solang nicht leer
      gNavigation_Picture_Path[i] = Listpath[44].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
    
  // Navigation-LastDestList
  for (i=0; i<elcount(Listpath[38].Param2) && path_stop == 0; i++)
  {
    if (Listpath[38].Param2[i] != 0x00)  // solang nicht leer
      gNavigation_LastDestList_Path[i] = Listpath[38].Param2[i];
    else
      path_stop = 1;
  } 
    
  path_stop = 0;
    
  // Navigation-FavoriteDestList
  for (i=0; i<elcount(Listpath[39].Param2) && path_stop == 0; i++)
  {
    if (Listpath[39].Param2[i] != 0x00)  // solang nicht leer
      gNavigation_FavoriteDestList_Path[i] = Listpath[39].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // Navigation-AddressList
  for (i=0; i<elcount(Listpath[40].Param2) && path_stop == 0; i++)
  {
    if (Listpath[40].Param2[i] != 0x00)  // solang nicht leer
      gNavigation_AddressList_Path[i] = Listpath[40].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // Navigation-POI_List
  for (i=0; i<elcount(Listpath[41].Param2) && path_stop == 0; i++)
  {
    if (Listpath[41].Param2[i] != 0x00)  // solang nicht leer
      gNavigation_POI_List_Path[i] = Listpath[41].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // SDS-CommandList
  for (i=0; i<elcount(Listpath[47].Param2) && path_stop == 0; i++)
  {
    if (Listpath[47].Param2[i] != 0x00)  // solang nicht leer
      gSDS_CommandList_Path[i] = Listpath[47].Param2[i];
    else
      path_stop = 1;
  } 
  
  path_stop = 0;
  
  // SDS-ResultList
  for (i=0; i<elcount(Listpath[48].Param2) && path_stop == 0; i++)
  {
    if (Listpath[48].Param2[i] != 0x00)  // solang nicht leer
      gSDS_ResultList_Path[i] = Listpath[48].Param2[i];
    else
      path_stop = 1;
  }
  
  path_stop = 0;
  
  // InfoSettings-BTDeviceList
  for (i=0; i<elcount(Listpath[51].Param2) && path_stop == 0; i++)
  {
    if (Listpath[51].Param2[i] != 0x00)  // solang nicht leer
      gInfoSettings_BTDeviceList_Path[i] = Listpath[51].Param2[i];
    else
      path_stop = 1;
  }
  
  path_stop = 0;
  
  // InfoSettings-LicenseInformation
  for (i=0; i<elcount(Listpath[52].Param2) && path_stop == 0; i++)
  {
    if (Listpath[52].Param2[i] != 0x00)  // solang nicht leer
      gInfoSettings_LicenseInformation_Path[i] = Listpath[52].Param2[i];
    else
      path_stop = 1;
  }
}
          

// Allgemein

on envVar env_BAPControl_On_Off
{
  if (@this)
		BAP_on();
	else
		BAP_off();
}

BAP_on() //aktiviert alle BAP Strecken
{
  @ON_OFF_ASG4_0  = 1;
	@ON_OFF_ASG15_1 = 1;
	@ON_OFF_ASG17_1 = 1;
	@ON_OFF_ASG18_1 = 1;
	@ON_OFF_ASG19_1 = 1;
  @ON_OFF_ASG69_0 = 1;
  @ON_OFF_ASG74_1 = 1;
  @ON_OFF_FSG4_0  = 1;
  @ON_OFF_FSG6_0  = 1;
  @ON_OFF_FSG7_0  = 1; @DF50_ON_OFF_FSG7_0 = 1;
  @ON_OFF_FSG13_0 = 1;
  @ON_OFF_FSG15_0 = 1;
  @ON_OFF_FSG17_0 = 1;
  @ON_OFF_FSG24_0 = 1;
  @ON_OFF_FSG25_0 = 1;
  @ON_OFF_FSG26_0 = 1;
  @ON_OFF_FSG29_0 = 1;
  @ON_OFF_FSG31_0 = 1;
  @ON_OFF_FSG33_0 = 1;
  @ON_OFF_FSG35_0 = 1;
  @ON_OFF_FSG36_0 = 1;
  @ON_OFF_FSG37_0 = 1;
  @ON_OFF_FSG39_0 = 1;
	@ON_OFF_FSG40_0 = 1;
	@ON_OFF_FSG41_0 = 1;
  @ON_OFF_FSG42_0 = 1;
	@ON_OFF_FSG49_0 = 1;
	@ON_OFF_FSG50_0 = 1;
	@ON_OFF_FSG52_0 = 1;
  @ON_OFF_FSG58_0 = 1;
  @ON_OFF_FSG60_0 = 1;
  @ON_OFF_FSG70_0 = 1;
  @ON_OFF_FSG80_0 = 1;
  @ON_OFF_FSG82_0 = 1;
  @ON_OFF_FSG85_0 = 1;
  @ON_OFF_FSG114_0 = 1;
}

BAP_off() //deaktiviert alle BAP Strecken
{
	@ON_OFF_ASG4_0  = 0;
	@ON_OFF_ASG15_1 = 0;
	@ON_OFF_ASG17_1 = 0;
	@ON_OFF_ASG18_1 = 0;
	@ON_OFF_ASG19_1 = 0;
  @ON_OFF_ASG69_0 = 0;
  @ON_OFF_ASG74_1 = 0;
  @ON_OFF_FSG4_0  = 0;
  @ON_OFF_FSG6_0  = 0;
  @ON_OFF_FSG7_0  = 0; @DF50_ON_OFF_FSG7_0 = 0;
  @ON_OFF_FSG13_0 = 0;
  @ON_OFF_FSG15_0 = 0;
  @ON_OFF_FSG17_0 = 0;
  @ON_OFF_FSG24_0 = 0;
  @ON_OFF_FSG25_0 = 0;
  @ON_OFF_FSG26_0 = 0;
  @ON_OFF_FSG29_0 = 0;
  @ON_OFF_FSG31_0 = 0;
  @ON_OFF_FSG33_0 = 0;
  @ON_OFF_FSG35_0 = 0;
  @ON_OFF_FSG36_0 = 0;
  @ON_OFF_FSG37_0 = 0;
  @ON_OFF_FSG39_0 = 0;
	@ON_OFF_FSG40_0 = 0;
	@ON_OFF_FSG41_0 = 0;
  @ON_OFF_FSG42_0 = 0;
	@ON_OFF_FSG49_0 = 0;
	@ON_OFF_FSG50_0 = 0;
	@ON_OFF_FSG52_0 = 0;
  @ON_OFF_FSG58_0 = 0;
  @ON_OFF_FSG60_0 = 0;
  @ON_OFF_FSG70_0 = 0;
  @ON_OFF_FSG80_0 = 0;
  @ON_OFF_FSG82_0 = 0;
  @ON_OFF_FSG85_0 = 0;
  @ON_OFF_FSG114_0 = 0;
}

sendRequestByteSequence(byte LSGID, byte fctID, byte req, dword length,byte data[])
{
  int i;
  byte temp = 0;
  dword NodeIndex;
  dword header[6];
  byte request_data[BAP_BUFFERSIZE];
 
  for (i = 0; i <BAP_BUFFERSIZE; i++)
      request_data[i] = 0;
  for (i = 0; i < length; i++)
      request_data[i] = data[i];

  switch(LSGID)
  {
    case 13: NodeIndex = Node_Index_DoorLocking; break;
    case 35: NodeIndex = Node_Index_BCmE; break;
    case 37: NodeIndex = Node_Index_BatteryControl; break;
    case 40: NodeIndex = Node_Index_Telefon; break;
    case 41: NodeIndex = Node_Index_Telefon2; break;
    case 49: NodeIndex = Node_Index_Audio; break;
    case 50: NodeIndex = Node_Index_Navigation; break;
    case 70: NodeIndex = Node_Index_SDS; break;
    case 80: NodeIndex = Node_Index_InfoSettings; break;
    default: writelineex(gBAP_Trace, 3, "ungültige LSGID");
      
    return;
  }

  header[0] = LSGID;
  header[1] = fctID;
  header[2] = req;
  header[3] = Bap_byteSequence;
  header[4] = length;
  header[5] = 0;
  
  ///Debug Ausgaben///
  /*writelineex(4,0,"------------------");
  writelineex(4,0,"NodeIndex: %d", NodeIndex);
  writelineex(4,0,"LSGID: %d", LSGID);
  writelineex(4,0,"fctID: 0x%x", fctID);
  writelineex(4,0,"req: 0x%x", req);
  writelineex(4,0,"BAP: 0x%x", Bap_byteSequence);
  writelineex(4,0,"length: %d", length);*/
  
  /*for (i=0; i<length; i++)
    writelineex(4,0,"data[%d]: %x", i,data[i]);*/

  temp = BAP180_Request(NodeIndex, header, request_data);
  
  if (temp != 0)
    writelineex(gBAP_Trace, 3, "ERROR: 0x%X LSGID: 0x%X fctID: 0x%X REQ: 0x%X NodeIndex: %d", temp , LSGID, fctID, req, NodeIndex);
  else
    writelineex(gBAP_Trace, 1, "Request successful LSGID: 0x%X fctID: 0x%X REQ: 0x%X NodeIndex: %d",LSGID, fctID, req, NodeIndex);
}

sendRequest(byte LSGID, byte fctID, byte req, byte dataType, dword data)
{
  byte temp = 0;
  dword NodeIndex;
  byte  senddata[BAP_BUFFERSIZE];
  dword header[6];
  
  switch(LSGID)
  {
    case 13: NodeIndex = Node_Index_DoorLocking; break;
    case 35: NodeIndex = Node_Index_BCmE; break;
    case 37: NodeIndex = Node_Index_BatteryControl; break;
    case 40: NodeIndex = Node_Index_Telefon; break;
    case 41: NodeIndex = Node_Index_Telefon2; break;
    case 49: NodeIndex = Node_Index_Audio; break;
    case 50: NodeIndex = Node_Index_Navigation; break;
    case 70: NodeIndex = Node_Index_SDS; break;
    case 80: NodeIndex = Node_Index_InfoSettings; break;
    default: writelineex(gBAP_Trace, 3, "ungültige LSGID");
      
    return;
  }
  
  header[0] = LSGID;
  header[1] = fctID;
  header[2] = req;
  header[3] = dataType;
  header[4] = 0;
  header[5] = data;

  temp = BAP180_Request(NodeIndex, header,senddata);
  
  if (temp != 0)
    writelineex(gBAP_Trace, 3, "ERROR: 0x%X LSGID: 0x%X fctID: 0x%X REQ: 0x%X Data: 0x%X NodeIndex: %d", temp , LSGID, fctID, req, data, NodeIndex);
  else
    writelineex(gBAP_Trace, 1, "Request successful LSGID: 0x%X fctID: 0x%X REQ: 0x%X Data: 0x%X NodeIndex: %d", LSGID, fctID, req, data, NodeIndex);
}

on envVar env_BAPControl_Request
{
  byte data[4] = { 0x11,0x00, 0x00, 0x04 };
  
  sendRequestByteSequence(0x31, 0x20, 0x01, 4, data);
}

checkFunction (byte opcode, byte LSGID, byte fctID, byte data[])
{
  switch(LSGID)
  {
    //--------------------------------------------------------------------------------//
    
    case LSGID_DoorLocking:
      
      switch(fctID)
      {
        // Arrays
        case 0x24: DoorLocking_UserList                           (opcode, data); break;
      }
    
    break;
      
    //--------------------------------------------------------------------------------//
    
    case LSGID_BCmE:
      
      switch(fctID)
      {
        // Arrays
        case 0x10: BCmE_Consumer                                  (opcode, data); break;
      }
    
    break;
      
    //--------------------------------------------------------------------------------//
      
    case LSGID_BatteryControl:
          
      switch(fctID)
      {
        // Arrays
        case 0x27: BatteryControl_ProfilesExtended                (opcode, data); break;
        case 0x30: BatteryControl_Contracts                       (opcode, data); break;
      }
      
    break;
    
    //--------------------------------------------------------------------------------//
    
    case LSGID_Audio:
      
      switch(fctID)
      {
        // Arrays
        case 0x17: Audio_ReceptionList                            (opcode, data); break;
        case 0x20: Audio_SourceList                               (opcode, data); break;
        case 0x21: Audio_RadioTVPresetList                        (opcode, data); break;
        case 0x24: Audio_MediaBrowser                             (opcode, data); break;
        case 0x32: Audio_SiriusAlertList                          (opcode, data); break;
        case 0x38: Audio_LastStationList                          (opcode, data); break;
        case 0x3A: Audio_Picture                                  (opcode, data); break;
        case 0x3B: Audio_FavoriteList                             (opcode, data); break;
        
        // Methoden
        case 0x18: Audio_DedicatedAudioControl                    (opcode, data); break;
        case 0x1D: Audio_AnnouncementEscape                       (opcode, data); break;
        case 0x22: if (@M_FSG_49_0_0_34_3min_TO == 0) {Audio_SwitchSource                             (opcode, data);} break; // GVAA-7433
        case 0x26: Audio_MediaBrowserControl                      (opcode, data); break;
        case 0x27: Audio_MediaFileInfo                            (opcode, data); break;
        case 0x2C: Audio_GetNextListPos                           (opcode, data); break;
        case 0x2D: if (@M_FSG_49_0_0_45_3min_TO == 0) {Audio_SwitchRadioMedia                         (opcode, data);} break; // GVAA-7433
          
        // Properties
        case 0x10: Audio_ActiveSource                             (opcode, data); break;
        case 0x16: Audio_CurrentStation_Handle                    (opcode, data); break;
        case 0x1F: Audio_ReceptionListType                        (opcode, data); break;
        case 0x28: Audio_PreferredList                        (opcode, data); break;
      }
      
    break;
      
    //--------------------------------------------------------------------------------//
    
    case LSGID_Telefon:
      
      switch(fctID)
      {
        // Arrays
        case 0x31: Telefon_CombinedNumbers                        (opcode, data); break;
        case 0x34: Telefon_Phonebook                              (opcode, data); break;
        case 0x3C: Telefon_FavoriteList                           (opcode, data); break;
        
        // Methoden
        case 0x1A: Telefon_DialNumber                             (opcode, data); break;
        case 0x1B: Telefon_DialService                            (opcode, data); break;
        case 0x1C: Telefon_ConfirmEmergencyCall                   (opcode, data); break;
        case 0x1D: Telefon_HangupCall                             (opcode, data); break;
        case 0x1E: Telefon_AcceptCall                             (opcode, data); break;
        case 0x1F: Telefon_CallHold                               (opcode, data); break;
        case 0x20: Telefon_ResumeCall                             (opcode, data); break;
        case 0x23: Telefon_MPRelActiveCallAcceptWC                (opcode, data); break;
        case 0x24: Telefon_MPSwap                                 (opcode, data); break;
        case 0x25: Telefon_MPCallHoldAcceptWC                     (opcode, data); break;
        case 0x26: Telefon_MPRelAllCallsAcceptWC                  (opcode, data); break;
        case 0x27: Telefon_MPSetWaitingCallOnHold                 (opcode, data); break;
        case 0x28: Telefon_CCJoin                                 (opcode, data); break;
        case 0x29: Telefon_CCSplit                                (opcode, data); break;
        case 0x32: Telefon_CallStackDeleteAll                     (opcode, data); break;
        case 0x35: Telefon_PbSpeller                              (opcode, data); break;
        case 0x36: Telefon_GetNextListPos                         (opcode, data); break;
        case 0x3F: Telefon_CallFunctions                          (opcode, data); break;
      }
      
    break;
      
    //--------------------------------------------------------------------------------//
    
    case LSGID_Telefon2:
      
      switch(fctID)
      {
        // Methoden
        case 0x21: Telefon2_CallFunctions2                        (opcode, data); break;
        case 0x2E: Telefon2_CallFunctions3                        (opcode, data); break;
        case 0x30: Telefon2_SelectPhone                           (opcode, data); break;
        case 0x33: Telefon2_CallPicture                           (opcode, data); break;
      }
      
    break;
      
    //--------------------------------------------------------------------------------//

    case LSGID_Navigation:
       
      switch(fctID)
      {
        // Arrays
        case 0x18: Navigation_LaneGuidance                        (opcode, data); break;
        case 0x1D: Navigation_LastDestList                        (opcode, data); break;
        case 0x1E: Navigation_FavoriteDestList                    (opcode, data); break;
        case 0x21: Navigation_AddressList                         (opcode, data); break;
        case 0x34: Navigation_POI_List                            (opcode, data); break;
		case 0x3A: Navigation_VideoStreams                        (opcode, data); break;
		case 0x3D: Navigation_LaneGuidance2                       (opcode, data); break;
		case 0x3E: Navigation_Picture                             (opcode, data); break;
          
        // Methoden
        case 0x22: Navigation_RG_ActDeact                         (opcode, data); break;
        case 0x23: Navigation_RepeatLastNavAnnouncement           (opcode, data); break;
        case 0x29: Navigation_GetNextListPos                      (opcode, data); break;
        case 0x2A: Navigation_NbSpeller                           (opcode, data); break;
        case 0x33: Navigation_POI_Search                          (opcode, data); break;
        case 0x3B: Navigation_RequestSync_Video                   (opcode, data); break;
      }
      
    break;
      
    //--------------------------------------------------------------------------------//
      
    case (LSGID_SDS_header || LSGID_InfoSettings_header):
          
      switch(fctID)
      {
        // SDS
        if(@ON_OFF_FSG70_0 == 1) // Abfrage, um Probleme mit anderen Steuergeräten mit LSGID=0
        {
          // Arrays
        	case 0x12: SDS_CommandList                              (opcode, data); break;
          case 0x13: SDS_ResultList                               (opcode, data); break;
        }
        
        // InfoSettings
        if(@ON_OFF_FSG80_0 == 1) // Abfrage, um Probleme mit anderen Steuergeräten mit LSGID=0
        {
          // Arrays
        	case 0x16: InfoSettings_BTDeviceList                    (opcode, data); break;
          case 0x18: InfoSettings_LicenseInformation              (opcode, data); break;
          
          // Methoden
          case 0x10: InfoSettings_ResetFactorySettings            (opcode, data); break;
          case 0x14: InfoSettings_RadioFavoriteCommands           (opcode, data); break;
          case 0x17: InfoSettings_BTPairingCommands               (opcode, data); break;
          case 0x1B: InfoSettings_UpdateCommands                  (opcode, data); break;
        }
      }
      
    break;
  }
}


on envVar env_LoadBTN_All
{
  if (@this == 1)
  {
    DoorLocking_UserList_LoadArray();
    putValue(Env_DoorLocking_UserList_Path,            gDoorLocking_UserList_Path);
    
    BCmE_Consumer_LoadArray();
    putValue(Env_BCmE_Consumer_Path,                   gBCmE_Consumer_Path);
    
    BatteryControl_ProfilesExtended_LoadArray();
    putValue(Env_BatteryControl_ProfilesExtended_Path, gBatteryControl_ProfilesExtended_Path);
    BatteryControl_Contracts_LoadArray();
    putValue(Env_BatteryControl_Contracts_Path,        gBatteryControl_Contracts_Path);
    
    Telefon_CombinedNumbers_LoadArray();
    putValue(Env_Telefon_CombinedNumbers_Path,         gTelefon_CombinedNumbers_Path);
    Telefon_Phonebook_LoadArray();
    putValue(Env_Telefon_Phonebook_Path,               gTelefon_Phonebook_Path);
    Telefon_FavoriteList_LoadArray();
    putValue(Env_Telefon_FavoriteList_Path,            gTelefon_FavoriteList_Path);
    
    Telefon2_CallPicture_LoadArray();
    putValue(Env_Telefon2_CallPicture_Path,            gTelefon2_CallPicture_Path);
    
    Audio_ReceptionList_LoadArray();
    putValue(Env_Audio_ReceptionList_FM_Path,          gAudio_ReceptionList_Path[0]);
    putValue(Env_Audio_ReceptionList_AM_Path,          gAudio_ReceptionList_Path[1]);
    putValue(Env_Audio_ReceptionList_DAB_Path,         gAudio_ReceptionList_Path[2]);
    putValue(Env_Audio_ReceptionList_SDARS_Path,       gAudio_ReceptionList_Path[3]);
    putValue(Env_Audio_ReceptionList_DVB_Path,         gAudio_ReceptionList_Path[4]);
    putValue(Env_Audio_ReceptionList_TV_Path,          gAudio_ReceptionList_Path[5]);
    putValue(Env_Audio_ReceptionList_AM_SW_Path,       gAudio_ReceptionList_Path[6]);
    putValue(Env_Audio_ReceptionList_AM_LW_Path,       gAudio_ReceptionList_Path[7]);
    putValue(Env_Audio_ReceptionList_OnlineRadio_Path, gAudio_ReceptionList_Path[8]);
    putValue(Env_Audio_ReceptionList_CommonList_Path,  gAudio_ReceptionList_Path[9]);
    Audio_SourceList_LoadArray();
    putValue(Env_Audio_SourceList_Path,                gAudio_SourceList_Path);
    Audio_RadioTVPresetList_LoadArray();
    putValue(Env_Audio_RadioTVPresetList_Path,         gAudio_RadioTVPresetList_Path);
    Audio_MediaBrowser_LoadArray();
    putValue(Env_Audio_MediaBrowser_Path,              gAudio_MediaBrowser_Path);
    Audio_SiriusAlertList_LoadArray();
    putValue(Env_Audio_SiriusAlertList_Path,           gAudio_SiriusAlertList_Path);
    Audio_LastStationList_LoadArray();
    putValue(Env_Audio_LastStationList_Path,           gAudio_LastStationList_Path);
    Audio_Picture_LoadArray();
    putValue(Env_Audio_Picture_Path,                   gAudio_FavoriteList_Path);
    Audio_FavoriteList_LoadArray();
    putValue(Env_Audio_FavoriteList_Path,              gAudio_FavoriteList_Path);
    
    Navigation_LaneGuidance_LoadArray();
    putValue(Env_Navigation_LaneGuidance_Path,         gNavigation_LaneGuidance_Path);
    Navigation_LastDestList_LoadArray();
    putValue(Env_Navigation_LastDestList_Path,         gNavigation_LastDestList_Path);
    Navigation_FavoriteDestList_LoadArray();
    putValue(Env_Navigation_FavoriteDestList_Path,     gNavigation_FavoriteDestList_Path);
    Navigation_AddressList_LoadArray();
    putValue(Env_Navigation_AddressList_Path,          gNavigation_AddressList_Path);
    Navigation_POI_List_LoadArray();
    putValue(Env_Navigation_POI_List_Path,             gNavigation_POI_List_Path);
	Navigation_VideoStreams_LoadArray();
    putValue(Env_Navigation_VideoStreams_Path,         gNavigation_VideoStreams_Path);
	Navigation_LaneGuidance2_LoadArray();
    putValue(Env_Navigation_LaneGuidance2_Path,        gNavigation_LaneGuidance2_Path);
	Navigation_Picture_LoadArray();
    putValue(Env_Navigation_Picture_Path,              gNavigation_Picture_Path);
    
    InfoSettings_BTDeviceList_LoadArray();
    putValue(Env_InfoSettings_BTDeviceList_Path,       gInfoSettings_BTDeviceList_Path);
    InfoSettings_LicenseInformation_LoadArray();
    putValue(Env_InfoSettings_LicenseInformation_Path, gInfoSettings_LicenseInformation_Path);
  } 
}

on envVar env_AutoGetArray_All_PanelBTN  // BAP-Array Listen "Set FSG-Response: All from Panel-Values"
{
  if (@this == 1)
  {
    putValue(env_AutoGetArray_ASG_ID   ,1);
    putValue(env_AutoGetArray_TAID     ,1);
    putValue(env_AutoGetArray_RecAdr   ,1);
    putValue(env_AutoGetArray_Shift    ,1);
    putValue(env_AutoGetArray_Dir      ,1);
    putValue(env_AutoGetArray_Start    ,1);
  }
}

on envVar env_AutoGetArray_All_GetArrayBTN  // BAP-Array Listen "Set FSG-Response: All from Get-Array"
{
  if (@this == 1)
  {
    putValue(env_AutoGetArray_ASG_ID   ,0);
    putValue(env_AutoGetArray_TAID     ,0);
    putValue(env_AutoGetArray_RecAdr   ,0);
    putValue(env_AutoGetArray_Shift    ,0);
    putValue(env_AutoGetArray_Dir      ,0);
    putValue(env_AutoGetArray_Start    ,0);
  }
}







/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////// DoorLocking ////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

on envVar Node_Index_FSG_13
{   
    Node_Index_DoorLocking = getValue(this);
}

on message BAP_Doorlocking_ASG_03
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  DoorLocking_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG13_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          DoorLocking_app_data_ASG03[log_channel][i] = 0;

      // BAP Header auswerten
      DoorLocking_received_function_ASG03[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      DoorLocking_received_function_ASG03[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      DoorLocking_received_function_ASG03[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          DoorLocking_app_data_ASG03[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,DoorLocking_received_function_ASG03[log_channel][2]);
      
      // an checkfunction übergeben
      if (DoorLocking_received_function_ASG03[log_channel][2] == 0x24) { DoorLocking_UserList_Log_Channel = log_channel; } // UserList
      checkFunction(DoorLocking_received_function_ASG03[log_channel][0], DoorLocking_received_function_ASG03[log_channel][1], DoorLocking_received_function_ASG03[log_channel][2], DoorLocking_app_data_ASG03[log_channel]);
      
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          DoorLocking_app_data_ASG03[log_channel][i] = 0;        

      // BAP Header auswerten
      DoorLocking_received_function_ASG03[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      DoorLocking_received_function_ASG03[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      DoorLocking_received_function_ASG03[log_channel][2] = (data[3] & 0x3F); // FctID
      DoorLocking_data_length_ASG03[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          DoorLocking_app_data_ASG03[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      DoorLocking_data_length_ASG03[log_channel] = DoorLocking_data_length_ASG03[log_channel] - 4;
      DoorLocking_currentPosASG03[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (DoorLocking_data_length_ASG03[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,DoorLocking_received_function_ASG03[log_channel][2]);
        
        // an checkfunction übergeben
        if (DoorLocking_received_function_ASG03[log_channel][2] == 0x24) { DoorLocking_UserList_Log_Channel = log_channel; } // UserList
        checkFunction(DoorLocking_received_function_ASG03[log_channel][0], DoorLocking_received_function_ASG03[log_channel][1], DoorLocking_received_function_ASG03[log_channel][2], DoorLocking_app_data_ASG03[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      DoorLocking_sequenceNumberASG03[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (DoorLocking_data_length_ASG03[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
            DoorLocking_app_data_ASG03[log_channel][DoorLocking_currentPosASG03[log_channel]] = data[i+1];
            DoorLocking_currentPosASG03[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        DoorLocking_data_length_ASG03[log_channel] = DoorLocking_data_length_ASG03[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (DoorLocking_data_length_ASG03[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < DoorLocking_data_length_ASG03[log_channel]; i++)
        {
            DoorLocking_app_data_ASG03[log_channel][DoorLocking_currentPosASG03[log_channel]] = data[i+1];
            DoorLocking_currentPosASG03[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,DoorLocking_received_function_ASG03[log_channel][2]);
        
        // an checkfunction übergeben
        if (DoorLocking_received_function_ASG03[log_channel][2] == 0x24) { DoorLocking_UserList_Log_Channel = log_channel; } // UserList
        checkFunction(DoorLocking_received_function_ASG03[log_channel][0], DoorLocking_received_function_ASG03[log_channel][1], DoorLocking_received_function_ASG03[log_channel][2], DoorLocking_app_data_ASG03[log_channel]);
      }
    }
  }
}

on message BAP_Doorlocking_FSG_01
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: FSG
  DoorLocking_Source = 2;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG13_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          DoorLocking_app_data_FSG01[log_channel][i] = 0;

      // BAP Header auswerten
      DoorLocking_received_function_FSG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      DoorLocking_received_function_FSG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      DoorLocking_received_function_FSG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          DoorLocking_app_data_FSG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,DoorLocking_received_function_FSG01[log_channel][2]);
      
      // an checkfunction übergeben
      checkFunction(DoorLocking_received_function_FSG01[log_channel][0], DoorLocking_received_function_FSG01[log_channel][1], DoorLocking_received_function_FSG01[log_channel][2], DoorLocking_app_data_FSG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          DoorLocking_app_data_FSG01[log_channel][i] = 0;        

      // BAP Header auswerten
      DoorLocking_received_function_FSG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      DoorLocking_received_function_FSG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      DoorLocking_received_function_FSG01[log_channel][2] = (data[3] & 0x3F); // FctID
      DoorLocking_data_length_FSG01[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          DoorLocking_app_data_FSG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      DoorLocking_data_length_FSG01[log_channel] = DoorLocking_data_length_FSG01[log_channel] - 4;
      DoorLocking_currentPosFSG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (DoorLocking_data_length_FSG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,DoorLocking_received_function_FSG01[log_channel][2]);
        
        // an checkfunction übergeben
        checkFunction(DoorLocking_received_function_FSG01[log_channel][0], DoorLocking_received_function_FSG01[log_channel][1], DoorLocking_received_function_FSG01[log_channel][2], DoorLocking_app_data_FSG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      DoorLocking_sequenceNumberFSG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (DoorLocking_data_length_FSG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
            DoorLocking_app_data_FSG01[log_channel][DoorLocking_currentPosFSG01[log_channel]] = data[i+1];
            DoorLocking_currentPosFSG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        DoorLocking_data_length_FSG01[log_channel] = DoorLocking_data_length_FSG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (DoorLocking_data_length_FSG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < DoorLocking_data_length_FSG01[log_channel]; i++)
        {
            DoorLocking_app_data_FSG01[log_channel][DoorLocking_currentPosFSG01[log_channel]] = data[i+1];
            DoorLocking_currentPosFSG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,DoorLocking_received_function_FSG01[log_channel][2]);
        
        // an checkfunction übergeben
        checkFunction(DoorLocking_received_function_FSG01[log_channel][0], DoorLocking_received_function_FSG01[log_channel][1], DoorLocking_received_function_FSG01[log_channel][2], DoorLocking_app_data_FSG01[log_channel]);
      }
    }
  }
}


// DoorLocking 0x24 User List

on envVar Env_DoorLocking_UserList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_DoorLocking_UserList_Path,gDoorLocking_UserList_Path);
    DoorLocking_UserList_LoadArray();
  }
}

on envVar Env_DoorLocking_UserList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_DoorLocking_UserList_Path,gDoorLocking_UserList_Path);
    DoorLocking_UserList_LoadArray();
    DoorLocking_UserList_Changed(0x0,0x0, 0x00, 0xFF);
  } 
}
DoorLocking_UserList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;
  dword index;
  

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for (i = 0; i < DoorLocking_UserList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		DoorLocking_UserList[i].Param1 = 0;
		DoorLocking_UserList[i].Param2 = 0;
		for (j=0; j<67; j++)
	    DoorLocking_UserList[i].Param3[j] = 0;
		DoorLocking_UserList[i].Param3_Length = 0;
		for (j=0; j<2; j++)
			DoorLocking_UserList[i].Param4[j] = 0;
		DoorLocking_UserList[i].Param4_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gDoorLocking_UserList_Path); i++)
  {
    if (gDoorLocking_UserList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gDoorLocking_UserList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gDoorLocking_UserList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "UserList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
					{
						DoorLocking_UserList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						DoorLocking_UserList[current_CSV_line-1].Param2 = atol(temp2); //Type
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 256)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Type
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Name
								if (paramPos < 66)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_DoorLocking_UserList_ListFormat == 1) )
                  {
                    DoorLocking_UserList[current_CSV_line-1].Param3[paramPos++] = buffer_byte[filePos++];
                    DoorLocking_UserList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_DoorLocking_UserList_ListFormat == 0) )
                  {
                    DoorLocking_UserList[current_CSV_line-1].Param3[paramPos++] = 0xC2;
                    DoorLocking_UserList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_DoorLocking_UserList_ListFormat == 0) )
                  {
                    DoorLocking_UserList[current_CSV_line-1].Param3[paramPos++] = 0xC3;
                    DoorLocking_UserList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    DoorLocking_UserList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
									DoorLocking_UserList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 4: //Extension
								if (paramPos < 1)
								{
									DoorLocking_UserList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									DoorLocking_UserList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  DoorLocking_UserList_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
}

DoorLocking_UserList (byte opcode, byte data[])
{
  byte ASG_ID, TAID, TotalNumListElements;
  byte IndexSize, Shift, Direction, TransPos, mode, recordaddress;
  dword list_start, elements;

  if ((opcode == 1) && (DoorLocking_Source == 1)) // ASG GetArray
  { 
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
   
    TotalNumListElements = DoorLocking_UserList_TotalListNum;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
       
    list_start = data[2];
    elements = data[3];
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////
                   
    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_13_0_0_36_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_13_0_0_36_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_13_0_0_36_2 = TAID;
    else
      TAID = @A_FSG_13_0_0_36_2;
     
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_13_0_0_36_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_13_0_0_36_RecAdr;
     
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_13_0_0_36_Shift = (mode>>0);
    else
      mode = ((@A_FSG_13_0_0_36_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_13_0_0_36_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_13_0_0_36_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_13_0_0_36_Start = list_start;
    else
      list_start = @A_FSG_13_0_0_36_Start;
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      DoorLocking_UserList_Status (ASG_ID, TAID, TotalNumListElements, mode, recordaddress,list_start, elements);
    }
  }
}

DoorLocking_UserList_Status (byte ASG_ID, byte TAID, byte TotalNumListElements, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction, trans_pos; 
  int  startposition, endposition, elements ;
  byte sequenceNumber = 0;
    
  int i, k , strctr; 
  int stringsize;   
  
  elements = received_elements;
  
  Data_DoorLocking_UserList[0] = ASG_ID*16 + (TAID & 0xF);  
  Data_DoorLocking_UserList[1] = TotalNumListElements;
  
  Data_DoorLocking_UserList[2] = ((mode|0x4) & 0x5)*16 + (recordaddress & 0xF);
      
  IndexSize = (mode>>3) & 0x1;
  trans_pos = 1; // immer aktiv
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
    
  switch(direction)
  {
    case 0:
      
      if (list_start == 0)
      {
         startposition =  shift; 
         endposition = startposition + elements - 1; 
      }
      
      else if (list_start > 0)
      {
         startposition = list_start + shift - 1;
         endposition = startposition+ elements - 1;
      }

      if (endposition >= DoorLocking_UserList_TotalListNum)
      {
         elements = DoorLocking_UserList_TotalListNum - startposition;
         endposition = DoorLocking_UserList_TotalListNum - 1;
      }
      
      if (startposition >= DoorLocking_UserList_TotalListNum)
      {
         elements=0;
      }

    break;
 
    case 1:
      
      if (list_start > 0)
      {
         startposition = list_start - shift - 1; 
         endposition = startposition - elements + 1; 
      }
      
      else if ((list_start == 0) && (shift == 1))
      {
         startposition = DoorLocking_UserList_TotalListNum -1;
         endposition = startposition - elements + 1;
      }
        
      if (endposition < 0)
      {
         elements = elements + endposition;
         endposition = 0;
      }

      if ((startposition >= DoorLocking_UserList_TotalListNum) || ((list_start == 0) && (shift == 0)))
      {
         elements=0;
      }
              
      break;
  }
       
  Data_DoorLocking_UserList[3] = list_start & 0xFF;
  Data_DoorLocking_UserList[4] = elements & 0xFF;

  j_DoorLocking_UserList = 5;
   
  switch(direction)
  {
    case 0:
       
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_DoorLocking_UserList[j_DoorLocking_UserList++] = DoorLocking_UserList[i].param1;
        
        if (recordaddress == 0x1)  //Type
        {
          Data_DoorLocking_UserList[j_DoorLocking_UserList++] = DoorLocking_UserList[i].param2;
        }
        
        if (recordaddress == 0x1) //Name
        {
          Data_DoorLocking_UserList[j_DoorLocking_UserList++] = DoorLocking_UserList[i].param3_Length;
          stringsize = DoorLocking_UserList[i].param3_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_DoorLocking_UserList[j_DoorLocking_UserList++] = DoorLocking_UserList[i].param3[strctr];
          } 
        }
      }
      
    break;
          
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        Data_DoorLocking_UserList[j_DoorLocking_UserList++] = DoorLocking_UserList[i].param1;
          
        if (recordaddress == 0x1)  //Type
        {
          Data_DoorLocking_UserList[j_DoorLocking_UserList++] = DoorLocking_UserList[i].param2;
        }
        
        if (recordaddress == 0x1) //Name
        {
          Data_DoorLocking_UserList[j_DoorLocking_UserList++] = DoorLocking_UserList[i].param3_Length;
          stringsize = DoorLocking_UserList[i].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_DoorLocking_UserList[j_DoorLocking_UserList++] = DoorLocking_UserList[i].param3[strctr];
          } 
        }
      }
    break;
  }
  settimer (Delay_DoorLocking_UserList, @Env_DoorLocking_UserList_ListDelay);
}

DoorLocking_UserList_Changed (byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  SendRequestByteSequence (LSGID_DoorLocking, 0x24, Changed_REQ, length, data);
}

on timer Delay_DoorLocking_UserList
{
  sendRequestByteSequence (LSGID_DoorLocking, 0x24, Data_REQ, j_DoorLocking_UserList, Data_DoorLocking_UserList);
}


// DoorLocking 0x26 UserProfileOnOff

on envVar ON_OFF_FSG13_0
{
	if (@this == 1)
    settimer (UserProfileOn, 2000);
}

on timer UserProfileOn
{
  if (@Node_Index_FSG_13 != 0)
    DoorLocking_UserProfileOnOff(1);
}

DoorLocking_UserProfileOnOff(byte Control)
{
  byte data[2];
  
  @M_FSG_13_0_0_39_Result_4 = 1;
  
  data[0] = Control;
  data[1] = 0;

  //UserProfileOnOff
  sendRequestByteSequence(LSGID_DoorLocking, 0x26, Data_REQ, 2,data);
  
  //ActiveUser
  sendRequest(LSGID_DoorLocking, 0x25, Data_REQ, 1, @P_FSG_13_0_0_37_1);
}


// DoorLocking 0x27 UserProfileControl

DoorLocking_UserProfileControl (byte opcode, byte data[])
{
  byte ASG_ID, Control;
  byte TargetProfile;
  byte send_data_UPC_Result[4];
  
  if ((opcode == 2) && (DoorLocking_Source == 1)) //StartResult ASG
  {
    // Start Result auswerten
    ASG_ID = data[0] >> 4 & 0xF;
    Control = data[0] & 0xF;
    TargetProfile = data[1] & 0xFF;
    
    // Parameter aus StartResult in Processing übernehmen
    @M_FSG_13_0_0_39_Processing_1 = ASG_ID;
    @M_FSG_13_0_0_39_Processing_2 = Control;
    
    // Parameter aus StartResult in StartResult übernehmen
    @M_FSG_13_0_0_39_Result_3 = TargetProfile;
  }
  
  if (opcode == 3 && DoorLocking_Source == 2 && @Env_BAP_Pro_Res == 1) // Processing FSG
  {
    // UserProfileControl Result schicken
    send_data_UPC_Result[0] = ASG_ID + Control*64;
    send_data_UPC_Result[1] = @M_FSG_13_0_0_39_Result_3;
    send_data_UPC_Result[2] = @M_FSG_13_0_0_39_Result_4;
    send_data_UPC_Result[3] = @M_FSG_13_0_0_39_Result_5;
    
    SendRequestByteSequence(LSGID_DoorLocking, 0x27, Result_REQ, 4, send_data_UPC_Result);
    
    // ActiveUser Status schicken
    if (@M_FSG_13_0_0_39_Result_4 == 1)
      sendRequest(LSGID_DoorLocking, 0x25, Data_REQ, 1, TargetProfile);
  }
}

//////// Mapping alter Variablen ////////

on envVar env_LoadBTN_UL
{ @Env_DoorLocking_UserList_LoadBTN = @this; }
on envVar env_LoadBTN_UL_Full
{ @Env_DoorLocking_UserList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_DoorLocking_UL
{ @Env_DoorLocking_UserList_ListDelay = @this; }
on envVar envUserListPath
{ char temp[255]; getValue (this, temp); putvalue (Env_DoorLocking_UserList_Path, temp); }










/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////// BCmE /////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

on envVar Node_Index_FSG_35
{   
  Node_Index_BCmE = @this;
}

on envVar Env_BCmE_Consumer_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_BCmE_Consumer_Path,gBCmE_Consumer_Path);
    BCmE_Consumer_LoadArray();
  }
}

on envVar Env_BCmE_Consumer_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_BCmE_Consumer_Path,gBCmE_Consumer_Path);
    BCmE_Consumer_LoadArray();
    BCmE_Consumer_Changed(0x0, 0x0, 0x00, 0xFF);
  } 
}

on message BAP_BCmE_ASG_01
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  BCmE_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG35_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          BCmE_app_data_ASG01[log_channel][i] = 0;

      // BAP Header auswerten
      BCmE_received_function_ASG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      BCmE_received_function_ASG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      BCmE_received_function_ASG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          BCmE_app_data_ASG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,BCmE_received_function_ASG01[log_channel][2]);
      
      // an checkfunction übergeben
      if (BCmE_received_function_ASG01[log_channel][2] == 0x10) { BCmE_Consumer_Log_Channel = log_channel; } // Consumer
      checkFunction(BCmE_received_function_ASG01[log_channel][0], BCmE_received_function_ASG01[log_channel][1], BCmE_received_function_ASG01[log_channel][2], BCmE_app_data_ASG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          BCmE_app_data_ASG01[log_channel][i] = 0;        

      // BAP Header auswerten
      BCmE_received_function_ASG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      BCmE_received_function_ASG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      BCmE_received_function_ASG01[log_channel][2] = (data[3] & 0x3F); // FctID
      BCmE_data_length_ASG01[log_channel] = ((data[0] &0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          BCmE_app_data_ASG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      BCmE_data_length_ASG01[log_channel] = BCmE_data_length_ASG01[log_channel] - 4;
      BCmE_currentPosASG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (BCmE_data_length_ASG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,BCmE_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (BCmE_received_function_ASG01[log_channel][2] == 0x10) { BCmE_Consumer_Log_Channel = log_channel; } // Consumer
        checkFunction(BCmE_received_function_ASG01[log_channel][0], BCmE_received_function_ASG01[log_channel][1], BCmE_received_function_ASG01[log_channel][2], BCmE_app_data_ASG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      BCmE_sequenceNumberASG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (BCmE_data_length_ASG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
            BCmE_app_data_ASG01[log_channel][BCmE_currentPosASG01[log_channel]] = data[i+1];
            BCmE_currentPosASG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        BCmE_data_length_ASG01[log_channel] = BCmE_data_length_ASG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (BCmE_data_length_ASG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < BCmE_data_length_ASG01[log_channel]; i++)
        {
            BCmE_app_data_ASG01[log_channel][BCmE_currentPosASG01[log_channel]] = data[i+1];
            BCmE_currentPosASG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,BCmE_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (BCmE_received_function_ASG01[log_channel][2] == 0x10) { BCmE_Consumer_Log_Channel = log_channel; } // Consumer
        checkFunction(BCmE_received_function_ASG01[log_channel][0], BCmE_received_function_ASG01[log_channel][1], BCmE_received_function_ASG01[log_channel][2], BCmE_app_data_ASG01[log_channel]);
      }
    }
  }
}

BCmE_Consumer_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for (i = 0; i < BCmE_Consumer_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		BCmE_Consumer[i].Param1 = 0;
		BCmE_Consumer[i].Param2 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gBCmE_Consumer_Path); i++)
  {
    if (gBCmE_Consumer_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gBCmE_Consumer_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gBCmE_Consumer_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "ConsumerList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
					{
						BCmE_Consumer[current_CSV_line-1].Param1 = atol(temp1); //Pos
						BCmE_Consumer[current_CSV_line-1].Param2 = atol(temp2); //ConsumerIdentifier
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 256)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //ConsumerIdentifier
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  BCmE_Consumer_TotalListNum = current_CSV_line- 1 -empty;
  empty=0;
}

BCmE_Consumer(byte opcode, byte data[])
{
  byte TotalNumListElements;
  byte IndexSize, Shift, Direction, TransPos, mode, recordaddress;
  dword list_start, elements;
  
  if ((opcode == 1) && (BCmE_Source == 1)) // ASG GetArray
  {
    TotalNumListElements = BCmE_Consumer_TotalListNum;
    mode = data[0] >> 4 & 0xF;
    recordaddress = data[0] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
 
    list_start = data[1];
    elements = data[2];
                     
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_35_0_0_16_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_35_0_0_16_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_35_0_0_16_Shift = (mode>>0);
    else
      mode = ((@A_FSG_35_0_0_16_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_35_0_0_16_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_35_0_0_16_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_35_0_0_16_Start = list_start;
    else
      list_start = @A_FSG_35_0_0_16_Start;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      BCmE_Consumer_Status(TotalNumListElements, mode, recordaddress,list_start, elements);
    }
  }
}

BCmE_Consumer_Status(byte TotalNumListElements, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition, elements ;
  byte sequenceNumber = 0;
  
  int i, /*j,*/k , strctr; 
  int stringsize;   

  elements = received_elements;

  Data_BCmE_Consumer[0] = TotalNumListElements;

  if (recordaddress == 0x0) // ohne Pos
    Data_BCmE_Consumer[1] = mode*16 + (recordaddress & 0xF);
  
  if (recordaddress == 0xF) // mit Pos
    Data_BCmE_Consumer[1] = ((mode|0x4) & 0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
  
  switch(direction)
  {
    case 0:
    
      if (list_start == 0)
      {
        startposition =  shift; 
        endposition = startposition + elements - 1; 
      }
      
      else if (list_start > 0)
      {
        startposition = list_start + shift - 1;
        endposition = startposition+ elements - 1;
      }

      if (endposition >= BCmE_Consumer_TotalListNum)
      {
        elements = BCmE_Consumer_TotalListNum - startposition;
        endposition = BCmE_Consumer_TotalListNum - 1;
      }
      
      if (startposition >= BCmE_Consumer_TotalListNum)
      {
        elements=0;
      }

    break;
   
    case 1:
        
      if (list_start > 0)
      {
        startposition = list_start - shift - 1; 
        endposition = startposition - elements + 1; 
      }
      
      else if ((list_start == 0) && (shift == 1))
      {
        startposition = BCmE_Consumer_TotalListNum -1;
        endposition = startposition - elements + 1;
      }
        
      if (endposition < 0)
      {
        elements = elements + endposition;
        endposition = 0;
      }
      
      if ((startposition >= BCmE_Consumer_TotalListNum) || ((list_start == 0) && (shift == 0)))
      {
        elements=0;
      }
                
     break;
    }
       
    Data_BCmE_Consumer[2] = list_start & 0xFF;
    Data_BCmE_Consumer[3] = elements & 0xFF;

    j_BCmE_Consumer = 4;
   
    switch(direction)
    {
      case 0:
         
        for (i = startposition ; i <= endposition && i >= 0; i++)
        {
          if (recordaddress == 0xF)  //Pos
            Data_BCmE_Consumer[j_BCmE_Consumer++] = BCmE_Consumer[i].param1;
            
          if (recordaddress == 0x0)  //ConsumerIdentifier
          {
            Data_BCmE_Consumer[j_BCmE_Consumer++] = BCmE_Consumer[i].param2;
          }
        }
        
      break;
            
      case 1:
        
        for (i = startposition ; i >= endposition && i >= 0; i--)
        {
          if (recordaddress == 0xF)  //Pos
              Data_BCmE_Consumer[j_BCmE_Consumer++] = BCmE_Consumer[i].param1;
          
          if (recordaddress == 0x0)  //ConsumerIdentifier
              Data_BCmE_Consumer[j_BCmE_Consumer++] = BCmE_Consumer[i].param2;
        }
      break;
      }
    
    settimer(Delay_BCmE_Consumer, @Env_BCmE_Consumer_ListDelay);
}

BCmE_Consumer_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  SendRequestByteSequence(LSGID_BCmE, 0x10, Changed_REQ, length, data);
}

on timer Delay_BCmE_Consumer
{
  sendRequestByteSequence(LSGID_BCmE, 0x10, Data_REQ, j_BCmE_Consumer, Data_BCmE_Consumer);
}

//////// Mapping alter Variablen ////////

on envVar env_LoadBTN_Con
{ @Env_BCmE_Consumer_LoadBTN = @this; }
on envVar env_LoadBTN_Con_Full
{ @Env_BCmE_Consumer_LoadBTN_Full = @this; }
on envVar Env_ListDelay_BCmE_Con
{ @Env_BCmE_Consumer_ListDelay = @this; }
on envVar envConsumerListPath
{ char temp[255]; getValue (this, temp); putvalue (Env_BCmE_Consumer_Path, temp); }










/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////// BatteryControl ///////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

on envVar Node_Index_FSG_37
{
  Node_Index_BatteryControl = @Node_Index_FSG_37;
}

on message BAP_BatteryControl_ASG_03
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  BatteryControl_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG37_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          BatteryControl_app_data_ASG03[log_channel][i] = 0;

      // BAP Header auswerten
      BatteryControl_received_function_ASG03[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      BatteryControl_received_function_ASG03[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      BatteryControl_received_function_ASG03[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          BatteryControl_app_data_ASG03[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,BatteryControl_received_function_ASG06[log_channel][2]);
      
      // an checkfunction übergeben
      if (BatteryControl_received_function_ASG03[log_channel][2] == 0x27) { BatteryControl_ProfilesExtended_Log_Channel = log_channel; } // ProfilesExtended
      if (BatteryControl_received_function_ASG03[log_channel][2] == 0x30) { BatteryControl_Contracts_Log_Channel = log_channel; } // Contracts
      checkFunction (BatteryControl_received_function_ASG03[log_channel][0], BatteryControl_received_function_ASG03[log_channel][1], BatteryControl_received_function_ASG03[log_channel][2], BatteryControl_app_data_ASG03[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          BatteryControl_app_data_ASG03[log_channel][i] = 0;        

      // BAP Header auswerten
      BatteryControl_received_function_ASG03[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      BatteryControl_received_function_ASG03[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      BatteryControl_received_function_ASG03[log_channel][2] = (data[3] & 0x3F); // FctID
      BatteryControl_data_length_ASG03[log_channel] = ((data[0] &0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          BatteryControl_app_data_ASG03[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      BatteryControl_data_length_ASG03[log_channel] = BatteryControl_data_length_ASG03[log_channel] - 4;
      BatteryControl_currentPosASG03[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (BatteryControl_data_length_ASG03[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,BatteryControl_received_function_ASG06[log_channel][2]);
        
        // an checkfunction übergeben
        if (BatteryControl_received_function_ASG03[log_channel][2] == 0x27) { BatteryControl_ProfilesExtended_Log_Channel = log_channel; } // ProfilesExtended
        if (BatteryControl_received_function_ASG03[log_channel][2] == 0x30) { BatteryControl_Contracts_Log_Channel = log_channel; } // Contracts
        checkFunction (BatteryControl_received_function_ASG03[log_channel][0], BatteryControl_received_function_ASG03[log_channel][1], BatteryControl_received_function_ASG03[log_channel][2], BatteryControl_app_data_ASG03[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      BatteryControl_sequenceNumberASG03[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (BatteryControl_data_length_ASG03[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
            BatteryControl_app_data_ASG03[log_channel][BatteryControl_currentPosASG03[log_channel]] = data[i+1];
            BatteryControl_currentPosASG03[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        BatteryControl_data_length_ASG03[log_channel] = BatteryControl_data_length_ASG03[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (BatteryControl_data_length_ASG03[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < BatteryControl_data_length_ASG03[log_channel]; i++)
        {
            BatteryControl_app_data_ASG03[log_channel][BatteryControl_currentPosASG03[log_channel]] = data[i+1];
            BatteryControl_currentPosASG03[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,BatteryControl_received_function_ASG03[log_channel][2]);
        
        // an checkfunction übergeben
        if (BatteryControl_received_function_ASG03[log_channel][2] == 0x27) { BatteryControl_ProfilesExtended_Log_Channel = log_channel; } // ProfilesExtended
        if (BatteryControl_received_function_ASG03[log_channel][2] == 0x30) { BatteryControl_Contracts_Log_Channel = log_channel; } // Contracts
        checkFunction (BatteryControl_received_function_ASG03[log_channel][0], BatteryControl_received_function_ASG03[log_channel][1], BatteryControl_received_function_ASG03[log_channel][2], BatteryControl_app_data_ASG03[log_channel]);
      }
    }
  }
}

on message BAP_BatteryControl_ASG_06
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  BatteryControl_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG37_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          BatteryControl_app_data_ASG06[log_channel][i] = 0;

      // BAP Header auswerten
      BatteryControl_received_function_ASG06[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      BatteryControl_received_function_ASG06[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      BatteryControl_received_function_ASG06[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          BatteryControl_app_data_ASG06[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,BatteryControl_received_function_ASG06[log_channel][2]);
      
      // an checkfunction übergeben
      if (BatteryControl_received_function_ASG06[log_channel][2] == 0x27) { BatteryControl_ProfilesExtended_Log_Channel = log_channel; } // ProfilesExtended
      if (BatteryControl_received_function_ASG06[log_channel][2] == 0x30) { BatteryControl_Contracts_Log_Channel = log_channel; } // Contracts
      checkFunction (BatteryControl_received_function_ASG06[log_channel][0], BatteryControl_received_function_ASG06[log_channel][1], BatteryControl_received_function_ASG06[log_channel][2], BatteryControl_app_data_ASG06[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          BatteryControl_app_data_ASG06[log_channel][i] = 0;        

      // BAP Header auswerten
      BatteryControl_received_function_ASG06[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      BatteryControl_received_function_ASG06[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      BatteryControl_received_function_ASG06[log_channel][2] = (data[3] & 0x3F); // FctID
      BatteryControl_data_length_ASG06[log_channel] = ((data[0] &0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          BatteryControl_app_data_ASG06[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      BatteryControl_data_length_ASG06[log_channel] = BatteryControl_data_length_ASG06[log_channel] - 4;
      BatteryControl_currentPosASG06[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (BatteryControl_data_length_ASG06[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,BatteryControl_received_function_ASG06[log_channel][2]);
        
        // an checkfunction übergeben
        if (BatteryControl_received_function_ASG06[log_channel][2] == 0x27) { BatteryControl_ProfilesExtended_Log_Channel = log_channel; } // ProfilesExtended
        if (BatteryControl_received_function_ASG06[log_channel][2] == 0x30) { BatteryControl_Contracts_Log_Channel = log_channel; } // Contracts
        checkFunction (BatteryControl_received_function_ASG06[log_channel][0], BatteryControl_received_function_ASG06[log_channel][1], BatteryControl_received_function_ASG06[log_channel][2], BatteryControl_app_data_ASG06[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      BatteryControl_sequenceNumberASG06[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (BatteryControl_data_length_ASG06[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
            BatteryControl_app_data_ASG06[log_channel][BatteryControl_currentPosASG06[log_channel]] = data[i+1];
            BatteryControl_currentPosASG06[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        BatteryControl_data_length_ASG06[log_channel] = BatteryControl_data_length_ASG06[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (BatteryControl_data_length_ASG06[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < BatteryControl_data_length_ASG06[log_channel]; i++)
        {
            BatteryControl_app_data_ASG06[log_channel][BatteryControl_currentPosASG06[log_channel]] = data[i+1];
            BatteryControl_currentPosASG06[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,BatteryControl_received_function_ASG06[log_channel][2]);
        
        // an checkfunction übergeben
        if (BatteryControl_received_function_ASG06[log_channel][2] == 0x27) { BatteryControl_ProfilesExtended_Log_Channel = log_channel; } // ProfilesExtended
        if (BatteryControl_received_function_ASG06[log_channel][2] == 0x30) { BatteryControl_Contracts_Log_Channel = log_channel; } // Contracts
        checkFunction (BatteryControl_received_function_ASG06[log_channel][0], BatteryControl_received_function_ASG06[log_channel][1], BatteryControl_received_function_ASG06[log_channel][2], BatteryControl_app_data_ASG06[log_channel]);
      }
    }
  }
}


// BatteryControl 0x27 ProfilesExtended

on envVar Env_BatteryControl_ProfilesExtended_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_BatteryControl_ProfilesExtended_Path, gBatteryControl_ProfilesExtended_Path);
    BatteryControl_ProfilesExtended_LoadArray();
  }
}

on envVar Env_BatteryControl_ProfilesExtended_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_BatteryControl_ProfilesExtended_Path, gBatteryControl_ProfilesExtended_Path);
    BatteryControl_ProfilesExtended_LoadArray();
    BatteryControl_ProfilesExtended_Changed(0x0,0x0, 0x00, 0xFF);    
  }
}

BatteryControl_ProfilesExtended_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;
  dword index;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];
	char temp11[25];
	char temp12[25];
	char temp13[25];
	char temp14[25];
	char temp15[25];
	char temp16[25];
	char temp17[25];
	char temp18[25];
	char temp20[25];
	char temp21[25];
	char temp22[25];
	char temp23[25];
	char temp24[25];
	char temp25[25];
	char temp26[25];
	char temp27[25];
	char temp28[25];
	char temp29[25];
	char temp30[25];
	char temp31[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for (i = 0; i < BatteryControl_ProfilesExtended_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		BatteryControl_ProfilesExtended[i].Param1 = 0;
		for (j=0; j<62; j++)
			BatteryControl_ProfilesExtended[i].Param2[j] = 0;
		BatteryControl_ProfilesExtended[i].Param2_Length = 0;
		BatteryControl_ProfilesExtended[i].Param3 = 0;
		BatteryControl_ProfilesExtended[i].Param4 = 0;
		BatteryControl_ProfilesExtended[i].Param5 = 0;
		BatteryControl_ProfilesExtended[i].Param6 = 0;
		BatteryControl_ProfilesExtended[i].Param7 = 0;
		BatteryControl_ProfilesExtended[i].Param8 = 0;
		BatteryControl_ProfilesExtended[i].Param9 = 0;
		BatteryControl_ProfilesExtended[i].Param10 = 0;
		BatteryControl_ProfilesExtended[i].Param11 = 0;
		BatteryControl_ProfilesExtended[i].Param12 = 0;
		BatteryControl_ProfilesExtended[i].Param13 = 0;
		BatteryControl_ProfilesExtended[i].Param14 = 0;
		BatteryControl_ProfilesExtended[i].Param15 = 0;
		BatteryControl_ProfilesExtended[i].Param16 = 0;
		BatteryControl_ProfilesExtended[i].Param17 = 0;
		BatteryControl_ProfilesExtended[i].Param18 = 0;
		for (j=0; j<4; j++)
			BatteryControl_ProfilesExtended[i].Param19[j] = 0;
		BatteryControl_ProfilesExtended[i].Param19_Length = 0;
		BatteryControl_ProfilesExtended[i].Param20 = 0;
		BatteryControl_ProfilesExtended[i].Param21 = 0;
		BatteryControl_ProfilesExtended[i].Param22 = 0;
		BatteryControl_ProfilesExtended[i].Param23 = 0;
		BatteryControl_ProfilesExtended[i].Param24 = 0;
		BatteryControl_ProfilesExtended[i].Param25 = 0;
		BatteryControl_ProfilesExtended[i].Param26 = 0;
		BatteryControl_ProfilesExtended[i].Param27 = 0;
		BatteryControl_ProfilesExtended[i].Param28 = 0;
		BatteryControl_ProfilesExtended[i].Param29 = 0;
		BatteryControl_ProfilesExtended[i].Param30 = 0;
		BatteryControl_ProfilesExtended[i].Param31 = 0;
		for (j=0; j<2; j++)
			BatteryControl_ProfilesExtended[i].Param32[j] = 0;
		BatteryControl_ProfilesExtended[i].Param32_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
  for (i = 0; i < strlen(gBatteryControl_ProfilesExtended_Path); i++)
  {
    if (gBatteryControl_ProfilesExtended_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gBatteryControl_ProfilesExtended_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gBatteryControl_ProfilesExtended_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 12) //ignore first line in *.csv file
					{
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param1 = atol(temp1); //Pos
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param3 = atol(temp3); //ProfileOptions
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param4 = atol(temp4); //ProfileOptions2
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param5 = atol(temp5); //MinSoC
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param6 = atol(temp6); //TargetSoC
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param7 = atol(temp7); //PowerLimitation_Power
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param8 = atol(temp8); //PowerLimitation_StartHour
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param9 = atol(temp9); //PowerLimitation_StartMinute
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param10 = atol(temp10); //PowerLimitation_EndHour
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param11 = atol(temp11); //PowerLimitation_EndMinute
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param12 = atol(temp12); //PreferredCharging_StartHour
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param13 = atol(temp13); //PreferredCharging_StartMinute
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param14 = atol(temp14); //PreferredCharging_EndHour
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param15 = atol(temp15); //PreferredCharging_EndMinute
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param16 = atol(temp16); //OptimisationStrategy
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param17 = atol(temp17); //ElectricityRate_Threshold
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param18 = atol(temp18); //ElectricityRate_Multiplier
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param20 = atol(temp20); //Ref_Ext_Timer1
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param21 = atol(temp21); //Ref_Ext_Timer2
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param22 = atol(temp22); //Ref_Ext_Timer3
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param23 = atol(temp23); //Ref_Ext_Timer4
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param24 = atol(temp24); //Ref_Ext_Timer5
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param25 = atol(temp25); //Ref_Ext_Timer6
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param26 = atol(temp26); //Ref_Ext_Timer7
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param27 = atol(temp27); //Activation
						//BatteryControl_ProfilesExtended[current_CSV_line-1].Param28 = atol(temp28); //PositionLatitude
            strtoull(temp28, 0, BatteryControl_ProfilesExtended[current_CSV_line-1].Param28);
            //BatteryControl_ProfilesExtended[current_CSV_line-1].Param29 = atol(temp29); //PositionLongitude
            strtoull(temp29, 0, BatteryControl_ProfilesExtended[current_CSV_line-1].Param29);
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param30 = atol(temp30); //PositionRadius
						BatteryControl_ProfilesExtended[current_CSV_line-1].Param31 = atol(temp31); //UnitPositionRadius
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
							temp11[i]=0;
							temp12[i]=0;
							temp13[i]=0;
							temp14[i]=0;
							temp15[i]=0;
							temp16[i]=0;
							temp17[i]=0;
							temp18[i]=0;
							temp20[i]=0;
							temp21[i]=0;
							temp22[i]=0;
							temp23[i]=0;
							temp24[i]=0;
							temp25[i]=0;
							temp26[i]=0;
							temp27[i]=0;
							temp28[i]=0;
							temp29[i]=0;
							temp30[i]=0;
							temp31[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 12)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Name
								if (paramPos < 61)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_BatteryControl_ProfilesExtended_ListFormat == 1) )
                  {
                    BatteryControl_ProfilesExtended[current_CSV_line-1].Param2[paramPos++] = buffer_byte[filePos++];
                    BatteryControl_ProfilesExtended[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_BatteryControl_ProfilesExtended_ListFormat == 0) )
                  {
                    BatteryControl_ProfilesExtended[current_CSV_line-1].Param2[paramPos++] = 0xC2;
                    BatteryControl_ProfilesExtended[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_BatteryControl_ProfilesExtended_ListFormat == 0) )
                  {
                    BatteryControl_ProfilesExtended[current_CSV_line-1].Param2[paramPos++] = 0xC3;
                    BatteryControl_ProfilesExtended[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    BatteryControl_ProfilesExtended[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
									BatteryControl_ProfilesExtended[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //ProfileOptions
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //ProfileOptions2
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //MinSoC
								if ( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //TargetSoC
								if ( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //PowerLimitation_Power
								if ( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //PowerLimitation_StartHour
								if ( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //PowerLimitation_StartMinute
								if ( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //PowerLimitation_EndHour
								if ( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 11: //PowerLimitation_EndMinute
								if ( paramPos >= elCount(temp11) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp11[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 12: //PreferredCharging_StartHour
								if ( paramPos >= elCount(temp12) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp12[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 13: //PreferredCharging_StartMinute
								if ( paramPos >= elCount(temp13) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp13[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 14: //PreferredCharging_EndHour
								if ( paramPos >= elCount(temp14) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp14[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 15: //PreferredCharging_EndMinute
								if ( paramPos >= elCount(temp15) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp15[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 16: //OptimisationStrategy
								if ( paramPos >= elCount(temp16) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp16[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 17: //ElectricityRate_Threshold
								if ( paramPos >= elCount(temp17) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp17[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 18: //ElectricityRate_Multiplier
								if ( paramPos >= elCount(temp18) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp18[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 19: //CurrencyUnit
								if (paramPos < 3)
								{
									BatteryControl_ProfilesExtended[current_CSV_line-1].Param19[paramPos] = buffer_byte[filePos];
									BatteryControl_ProfilesExtended[current_CSV_line-1].Param19_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 20: //Ref_Ext_Timer1
								if ( paramPos >= elCount(temp20) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp20[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 21: //Ref_Ext_Timer2
								if ( paramPos >= elCount(temp21) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp21[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 22: //Ref_Ext_Timer3
								if ( paramPos >= elCount(temp22) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp22[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 23: //Ref_Ext_Timer4
								if ( paramPos >= elCount(temp23) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp23[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 24: //Ref_Ext_Timer5
								if ( paramPos >= elCount(temp24) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp24[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 25: //Ref_Ext_Timer6
								if ( paramPos >= elCount(temp25) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp25[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 26: //Ref_Ext_Timer7
								if ( paramPos >= elCount(temp26) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp26[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 27: //Activation
								if ( paramPos >= elCount(temp27) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp27[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 28: //PositionLatitude
								if ( paramPos >= elCount(temp28) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp28[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 29: //PositionLongitude
								if ( paramPos >= elCount(temp29) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp29[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 30: //PositionRadius
								if ( paramPos >= elCount(temp30) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp30[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 31: //UnitPositionRadius
								if ( paramPos >= elCount(temp31) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp31[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 32: //Extension
								if (paramPos < 1)
								{
									BatteryControl_ProfilesExtended[current_CSV_line-1].Param32[paramPos] = buffer_byte[filePos];
									BatteryControl_ProfilesExtended[current_CSV_line-1].Param32_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}

  BatteryControl_ProfilesExtended_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
}

BatteryControl_ProfilesExtended (byte opcode, byte data[])
{
  byte TotalNumListElements;
  byte IndexSize, Shift, Direction, TransPos, mode, recordaddress;
  dword list_start, elements;
  byte ASG_ID, TAID;
  
  if ((opcode == 1) && (BatteryControl_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    @A_FSG_37_0_0_39_2_range = TAID;

    TotalNumListElements = BatteryControl_ProfilesExtended_TotalListNum;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
    
    list_start = data[2];
    elements = data[3];

    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////
  
    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_37_0_0_39_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_37_0_0_39_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_37_0_0_39_2 = TAID;
    else
      TAID = @A_FSG_37_0_0_39_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_37_0_0_39_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_37_0_0_39_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_37_0_0_39_Shift = (mode>>0);
    else
      mode = ((@A_FSG_37_0_0_39_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_37_0_0_39_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_37_0_0_39_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_37_0_0_39_Start = list_start;
    else
      list_start = @A_FSG_37_0_0_39_Start;
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
   {
     BatteryControl_ProfilesExtended_Status (ASG_ID, TAID, TotalNumListElements, mode, recordaddress,list_start, elements);
   }
  }
}

BatteryControl_ProfilesExtended_Status (byte ASG_ID, byte TAID, byte TotalNumListElements, byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition;
  byte sequenceNumber = 0;
  byte transmit_pos;

  int i, k , strctr; 
  int stringsize;

  Data_BatteryControl_ProfilesExtended[0] = ASG_ID*16 + (TAID & 0xF);
  Data_BatteryControl_ProfilesExtended[1] = TotalNumListElements;
  Data_BatteryControl_ProfilesExtended[2] = (mode|0x4)*16 + recordaddress;
    
  IndexSize = (mode>>3) & 0x1;
  transmit_pos = (mode>>2) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction)
  {
    case 0:
      
      if (list_start == 0)
      {
        startposition =  shift; 
        endposition = startposition - 1 + elements;
      }
      
      else if (list_start > 0)
      {
        startposition = list_start + shift - 1;
        endposition = startposition+ elements - 1;
      }
      
      if (endposition >= BatteryControl_ProfilesExtended_TotalListNum)
      {
        elements = BatteryControl_ProfilesExtended_TotalListNum - startposition;
        endposition = BatteryControl_ProfilesExtended_TotalListNum - 1;
      }

      if (startposition >= BatteryControl_ProfilesExtended_TotalListNum)
      {
        elements=0;
      }
  
    break;
   
    case 1:
        
      if (list_start > 0)
      {
        startposition = list_start - shift - 1; 
        endposition = startposition - elements + 1; 
      }
      
      else if ((list_start == 0) && (shift == 1))
      {
        startposition = BatteryControl_ProfilesExtended_TotalListNum -1;
        endposition = startposition - elements + 1;
      }
        
      if (endposition < 0)
      {
        elements = elements + endposition;
        endposition = 0;
      }
      
      if ((startposition >= BatteryControl_ProfilesExtended_TotalListNum) || ((list_start == 0) && (shift == 0)))
      {
        elements=0;
      }
    break;
  }
 
  Data_BatteryControl_ProfilesExtended[3] = list_start & 0xFF;
  Data_BatteryControl_ProfilesExtended[4] = elements & 0xFF;

  j_BatteryControl_ProfilesExtended = 5;
 

  switch(direction)
  {
    case 0:
       
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param1;
          
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x7)  //Name
        {
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param2_Length;
          stringsize = BatteryControl_ProfilesExtended[i].param2_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param2[strctr];           
          }
        }
            
        if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4 || recordaddress == 0x7) // ProfileOptions
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param3 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4 || recordaddress == 0x7) // ProfileOptions2
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param4 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4 || recordaddress == 0x7) // MinSoC
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param5 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4 || recordaddress == 0x7) // TargetSoC
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param6 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // PowerLimitation_Power
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param7 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // PowerLimitation_StartHour
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param8 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // PowerLimitation_StartMinute
        {  
           Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param9 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // PowerLimitation_EndHour
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param10 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // PowerLimitation_EndMinute
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param11 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // PreferredCharging_StartHour
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param12 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // PreferredCharging_StartMinute
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param13 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // PreferredCharging_EndHour
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param14 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // PreferredCharging_EndMinute
        {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param15 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x4 || recordaddress == 0x7) // OptimisationStrategy
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param16 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x4) // ElectricityRate_Threshold
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param17 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x4) // ElectricityRate_Multiplier
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param18 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x4) // CurrencyUnit
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param19_Length;
          stringsize = BatteryControl_ProfilesExtended[i].param19_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param19[strctr];           
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer1
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param20 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer2
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param21 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer3
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param22 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer4
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param23 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer5
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param24 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer6
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param25 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer7
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param26 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x5 || recordaddress == 0x7) // Activation
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param27 & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x6 || recordaddress == 0x7) // PositionLatitude
        { 
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param28) & 0xFF;
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param28>>8) & 0xFF;
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param28>>16) & 0xFF;
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param28>>24) & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x6 || recordaddress == 0x7) // PositionLongitude
        {
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param29) & 0xFF;
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param29>>8) & 0xFF;
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param29>>16) & 0xFF;
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param29>>24) & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x6 || recordaddress == 0x7) // PositionRadius
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] =  BatteryControl_ProfilesExtended[i].param30 & 0xFF;
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param30>>8) & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x6 || recordaddress == 0x7) // UnitPositionRadius
        {  
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param31 & 0xFF;
        }
        
        // Extension
        /*{ 
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param32_Length;
          stringsize = BatteryControl_ProfilesExtended[i].param32_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param32[strctr];           
          } */
        }
      break;
          
      case 1:
    
        for (i = startposition ; i >= endposition && i >= 0; i--)
        {
          Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param1;
            
          if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x7)  //Name
          {
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param2_Length;
            stringsize = BatteryControl_ProfilesExtended[i].param2_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param2[strctr];           
            }
          }
            
          if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4 || recordaddress == 0x7) // ProfileOptions
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param3 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4 || recordaddress == 0x7) // ProfileOptions2
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param4 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4 || recordaddress == 0x7) // MinSoC
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param5 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4 || recordaddress == 0x7) // TargetSoC
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param6 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // PowerLimitation_Power
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param7 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // PowerLimitation_StartHour
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param8 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // PowerLimitation_StartMinute
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param9 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // PowerLimitation_EndHour
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param10 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // PowerLimitation_EndMinute
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param11 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // PreferredCharging_StartHour
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param12 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // PreferredCharging_StartMinute
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param13 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // PreferredCharging_EndHour
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param14 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // PreferredCharging_EndMinute
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param15 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x4 || recordaddress == 0x7) // OptimisationStrategy
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param16 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x4) // ElectricityRate_Threshold
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param17 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x4) // ElectricityRate_Multiplier
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param18 & 0xFF;
          }
            
          if (recordaddress == 0x0 || recordaddress == 0x4) // CurrencyUnit
          {
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param19_Length;
            stringsize = BatteryControl_ProfilesExtended[i].param19_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param19[strctr];           
            } 
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer1
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param20 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer2
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param21 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer3
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param22 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer4
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param23 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer5
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param24 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer6
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param25 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1) // Ref_Ext_Timer7
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param26 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x5 || recordaddress == 0x7) // Activation
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param27 & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x6 || recordaddress == 0x7) // PositionLatitude
          { 
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param28) & 0xFF;
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param28>>8) & 0xFF;
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param28>>16) & 0xFF;
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param28>>24) & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x6 || recordaddress == 0x7) // PositionLongitude
          {
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param29) & 0xFF;
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param29>>8) & 0xFF;
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param29>>16) & 0xFF;
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param29>>24) & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x6 || recordaddress == 0x7) // PositionRadius
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] =  BatteryControl_ProfilesExtended[i].param30 & 0xFF;
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = (BatteryControl_ProfilesExtended[i].param30>>8) & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x6 || recordaddress == 0x7) // UnitPositionRadius
          {  
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param31 & 0xFF;
          }
          
          // Extension
          /*{
            Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param32_Length;
            stringsize = BatteryControl_ProfilesExtended[i].param32_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_BatteryControl_ProfilesExtended[j_BatteryControl_ProfilesExtended++] = BatteryControl_ProfilesExtended[i].param32[strctr];           
            } 
          }*/
        }
      break;
  }
  settimer (Delay_BatteryControl_ProfilesExtended, @Env_BatteryControl_ProfilesExtended_ListDelay);
}

BatteryControl_ProfilesExtended_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  SendRequestByteSequence (LSGID_BatteryControl, 0x27, Changed_REQ, length, data);
}

on timer Delay_BatteryControl_ProfilesExtended
{ 
  sendRequestByteSequence(LSGID_BatteryControl, 0x27, Data_REQ, j_BatteryControl_ProfilesExtended, Data_BatteryControl_ProfilesExtended);
}


// BatteryControl 0x30 Contracts

on envVar Env_BatteryControl_Contracts_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_BatteryControl_Contracts_Path, gBatteryControl_Contracts_Path);
    BatteryControl_Contracts_LoadArray();
  }
}

on envVar Env_BatteryControl_Contracts_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_BatteryControl_Contracts_Path, gBatteryControl_Contracts_Path);
    BatteryControl_Contracts_LoadArray();
    BatteryControl_Contracts_Changed(0x0,0x0, 0x00, 0xFF);    
  } 
}

BatteryControl_Contracts_LoadArray()
{
  /********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;
  dword index;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];
	char temp11[25];
	char temp12[25];
	char temp13[25];
	char temp14[25];
	char temp15[25];
	char temp16[25];
	char temp17[25];
	char temp18[25];
	char temp19[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for (i = 0; i < BatteryControl_Contracts_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		BatteryControl_Contracts[i].Param1 = 0;
		for (j=0; j<62; j++)
			BatteryControl_Contracts[i].Param2[j] = 0;
		BatteryControl_Contracts[i].Param2_Length = 0;
		for (j=0; j<19; j++)
			BatteryControl_Contracts[i].Param3[j] = 0;
		BatteryControl_Contracts[i].Param3_Length = 0;
		BatteryControl_Contracts[i].Param4 = 0;
		BatteryControl_Contracts[i].Param5 = 0;
		BatteryControl_Contracts[i].Param6 = 0;
		BatteryControl_Contracts[i].Param7 = 0;
		BatteryControl_Contracts[i].Param8 = 0;
		BatteryControl_Contracts[i].Param9 = 0;
		BatteryControl_Contracts[i].Param10 = 0;
		BatteryControl_Contracts[i].Param11 = 0;
		BatteryControl_Contracts[i].Param12 = 0;
		BatteryControl_Contracts[i].Param13 = 0;
		BatteryControl_Contracts[i].Param14 = 0;
		BatteryControl_Contracts[i].Param15 = 0;
		BatteryControl_Contracts[i].Param16 = 0;
		BatteryControl_Contracts[i].Param17 = 0;
		BatteryControl_Contracts[i].Param18 = 0;
		BatteryControl_Contracts[i].Param19 = 0;
		for (j=0; j<4; j++)
			BatteryControl_Contracts[i].Param20[j] = 0;
		BatteryControl_Contracts[i].Param20_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
  for (i = 0; i < strlen(gBatteryControl_Contracts_Path); i++)
  {
    if (gBatteryControl_Contracts_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gBatteryControl_Contracts_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gBatteryControl_Contracts_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 11) //ignore first line in *.csv file
					{
						BatteryControl_Contracts[current_CSV_line-1].Param1 = atol(temp1); //Pos
						BatteryControl_Contracts[current_CSV_line-1].Param4 = atol(temp4); //StartYear
						BatteryControl_Contracts[current_CSV_line-1].Param5 = atol(temp5); //StartMonth
						BatteryControl_Contracts[current_CSV_line-1].Param6 = atol(temp6); //StartDay
						BatteryControl_Contracts[current_CSV_line-1].Param7 = atol(temp7); //StartHour
						BatteryControl_Contracts[current_CSV_line-1].Param8 = atol(temp8); //StartMinute
						BatteryControl_Contracts[current_CSV_line-1].Param9 = atol(temp9); //EndYear
						BatteryControl_Contracts[current_CSV_line-1].Param10 = atol(temp10); //EndMonth
						BatteryControl_Contracts[current_CSV_line-1].Param11 = atol(temp11); //EndDay
						BatteryControl_Contracts[current_CSV_line-1].Param12 = atol(temp12); //EndHour
						BatteryControl_Contracts[current_CSV_line-1].Param13 = atol(temp13); //EndMinute
						BatteryControl_Contracts[current_CSV_line-1].Param14 = atol(temp14); //Activation
						BatteryControl_Contracts[current_CSV_line-1].Param15 = atol(temp15); //Blocking
						BatteryControl_Contracts[current_CSV_line-1].Param16 = atol(temp16); //Priority
						BatteryControl_Contracts[current_CSV_line-1].Param17 = atol(temp17); //ContractState
						BatteryControl_Contracts[current_CSV_line-1].Param18 = atol(temp18); //MaxPrice
						BatteryControl_Contracts[current_CSV_line-1].Param19 = atol(temp19); //MaxPrice_Multiplier
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
							temp11[i]=0;
							temp12[i]=0;
							temp13[i]=0;
							temp14[i]=0;
							temp15[i]=0;
							temp16[i]=0;
							temp17[i]=0;
							temp18[i]=0;
							temp19[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 11)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Name
								if (paramPos < 61)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_BatteryControl_Contracts_ListFormat == 1) )
                  {
                    BatteryControl_Contracts[current_CSV_line-1].Param2[paramPos++] = buffer_byte[filePos++];
                    BatteryControl_Contracts[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_BatteryControl_Contracts_ListFormat == 0) )
                  {
                    BatteryControl_Contracts[current_CSV_line-1].Param2[paramPos++] = 0xC2;
                    BatteryControl_Contracts[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_BatteryControl_Contracts_ListFormat == 0) )
                  {
                    BatteryControl_Contracts[current_CSV_line-1].Param2[paramPos++] = 0xC3;
                    BatteryControl_Contracts[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    BatteryControl_Contracts[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
									BatteryControl_Contracts[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //ContractID
								if (paramPos < 18)
								{
									BatteryControl_Contracts[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
									BatteryControl_Contracts[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 4: //StartYear
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //StartMonth
								if ( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //StartDay
								if ( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //StartHour
								if ( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //StartMinute
								if ( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //EndYear
								if ( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //EndMonth
								if ( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 11: //EndDay
								if ( paramPos >= elCount(temp11) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp11[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 12: //EndHour
								if ( paramPos >= elCount(temp12) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp12[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 13: //EndMinute
								if ( paramPos >= elCount(temp13) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp13[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 14: //Activation
								if ( paramPos >= elCount(temp14) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp14[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 15: //Blocking
								if ( paramPos >= elCount(temp15) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp15[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 16: //Priority
								if ( paramPos >= elCount(temp16) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp16[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 17: //ContractState
								if ( paramPos >= elCount(temp17) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp17[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 18: //MaxPrice
								if ( paramPos >= elCount(temp18) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp18[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 19: //MaxPrice_Multiplier
								if ( paramPos >= elCount(temp19) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp19[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 20: //CurrencyUnit
								if (paramPos < 3)
								{
									BatteryControl_Contracts[current_CSV_line-1].Param20[paramPos] = buffer_byte[filePos];
									BatteryControl_Contracts[current_CSV_line-1].Param20_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  BatteryControl_Contracts_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
}

BatteryControl_Contracts(byte opcode, byte data[])
{
  byte TotalNumListElements;
  byte IndexSize, Shift, Direction, TransPos, mode, recordaddress;
  dword list_start, elements;
  byte ASG_ID, TAID;

  if ((opcode == 1) && (BatteryControl_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    @A_FSG_37_0_0_48_2_range = TAID;

    TotalNumListElements = BatteryControl_Contracts_TotalListNum;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
   
    list_start = data[2];
    elements = data[3];

    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_37_0_0_48_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_37_0_0_48_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_37_0_0_48_2 = TAID;
    else
      TAID = @A_FSG_37_0_0_48_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_37_0_0_48_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_37_0_0_48_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_37_0_0_48_Shift = (mode>>0);
    else
      mode = ((@A_FSG_37_0_0_48_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_37_0_0_48_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_37_0_0_48_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_37_0_0_48_Start = list_start;
    else
      list_start = @A_FSG_37_0_0_48_Start;
                      
                      
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////            

    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      BatteryControl_Contracts_Status(ASG_ID, TAID, TotalNumListElements, mode, recordaddress,list_start, elements);
    }
  }
}

BatteryControl_Contracts_Status(byte ASG_ID, byte TAID, byte TotalNumListElements, byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition;
  byte sequenceNumber = 0;
  byte transmit_pos;
  byte temp;

  int i, k , strctr; 
  int stringsize;

  Data_BatteryControl_Contracts[0] = ASG_ID*16 + (TAID & 0xF);
  Data_BatteryControl_Contracts[1] = TotalNumListElements;
  Data_BatteryControl_Contracts[2] = (mode|0x4)*16 + recordaddress;
    
  IndexSize = (mode>>3) & 0x1;
  transmit_pos = (mode>>2) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
  
  switch(direction)
  {
    case 0:
      
      if (list_start == 0)
      {
        startposition =  shift; 
        endposition = startposition - 1 + elements;
      }
      
      else if (list_start > 0)
      {
        startposition = list_start + shift - 1;
        endposition = startposition+ elements - 1;
      }
      
      if (endposition >= BatteryControl_Contracts_TotalListNum)
      {
        elements = BatteryControl_Contracts_TotalListNum - startposition;
        endposition = BatteryControl_Contracts_TotalListNum - 1;
      }

      if (startposition >= BatteryControl_Contracts_TotalListNum)
      {
        elements = 0;
      }

    break;
   
    case 1:
      
      if (list_start > 0)
      {
        startposition = list_start - shift - 1; 
        endposition = startposition - elements + 1; 
      }
      
      else if ((list_start == 0) && (shift == 1))
      {
        startposition = BatteryControl_Contracts_TotalListNum -1;
        endposition = startposition - elements + 1;
      }
        
      if (endposition < 0)
      {
        elements = elements + endposition;
        endposition = 0;
      }
      
      if ((startposition >= BatteryControl_Contracts_TotalListNum) || ((list_start == 0) && (shift == 0)))
      {
        elements = 0;
      }
              
    break;
  }
       
  Data_BatteryControl_Contracts[3] = list_start & 0xFF;
  Data_BatteryControl_Contracts[4] = elements & 0xFF;

  j_BatteryControl_Contracts = 5;
 
  switch(direction)
  {
     case 0:
   
       for (i = startposition ; i <= endposition && i >= 0; i++)
       {
         Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param1;
        
         if (recordaddress == 0x0 || recordaddress == 0x3) // Name
         {  
            Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param2_Length;
            stringsize = BatteryControl_Contracts[i].param2_Length;
         
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param2[strctr];           
            }
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x4) // ContractID
         {  
            Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param3_Length;
            stringsize = BatteryControl_Contracts[i].param3_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param3[strctr];           
            } 
         }
          
         if (recordaddress == 0x0 || recordaddress == 0x1)  // StartYear
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param4;
         }
         
         if (recordaddress == 0x0 || recordaddress == 0x1)  // StartMonth
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param5;
         }
         
         if (recordaddress == 0x0 || recordaddress == 0x1)  // StartDay
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param6;
         }
         
         if (recordaddress == 0x0 || recordaddress == 0x1)  // StartHour
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param7;
         }
         
         if (recordaddress == 0x0 || recordaddress == 0x1)  // StartMinute
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param8;
         }
         
         if (recordaddress == 0x0 || recordaddress == 0x1)  // EndYear
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param9;
         }
         
         if (recordaddress == 0x0 || recordaddress == 0x1)  // EndMonth
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param10;
         }
         
         if (recordaddress == 0x0 || recordaddress == 0x1)  // EndDay
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param11;
         }
          
         if (recordaddress == 0x0 || recordaddress == 0x1)  // EndHour
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param12;
         }
         
         if (recordaddress == 0x0 || recordaddress == 0x1)  // EndMinute
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param13;
         }
         
         if (recordaddress == 0x0 || recordaddress == 0x4)  // Activation
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts] = BatteryControl_Contracts[i].param14 * 16;
           temp = Data_BatteryControl_Contracts[j_BatteryControl_Contracts];
         }
          
         if (recordaddress == 0x0 || recordaddress == 0x4)  // Blocking
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = temp + BatteryControl_Contracts[i].param15;
         }
          
         if (recordaddress == 0x0 || recordaddress == 0x4 || recordaddress == 0x5)  // Priority
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts] = BatteryControl_Contracts[i].param16 * 16;
           temp = Data_BatteryControl_Contracts[j_BatteryControl_Contracts];
         }
          
         if (recordaddress == 0x0 || recordaddress == 0x4)  // ContractState
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = temp + BatteryControl_Contracts[i].param17;
         }
          
         if (recordaddress == 0x0 || recordaddress == 0x2)  // MaxPrice
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param18;
         }
          
         if (recordaddress == 0x0 || recordaddress == 0x2)  // MaxPrice_Multiplier
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param19;
         }
          
         /*if (recordaddress == 0x0) // CurrencyUnit -> es gibt keine RecordAddresse, in der der Paramter mit übertragen wird
         {  
             Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param20_Length;
             stringsize = BatteryControl_Contracts[i].param20_Length;
         
             for (strctr = 0; strctr < stringsize; strctr++)
             {
                 Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param20[strctr];           
             } 
         }*/
      }
    break;
      
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
         Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param1;
        
         if (recordaddress == 0x0 || recordaddress == 0x3) // Name
         {  
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param2_Length;
           stringsize = BatteryControl_Contracts[i].param2_Length;
         
           for (strctr = 0; strctr < stringsize; strctr++)
           {
             Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param2[strctr];           
           }
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x4) // ContractID
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param3_Length;
           stringsize = BatteryControl_Contracts[i].param3_Length;
        
           for (strctr = 0; strctr < stringsize; strctr++)
           {
              Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param3[strctr];           
           }
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x1)  // StartYear
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param4;
         }
         
         if (recordaddress == 0x0 || recordaddress == 0x1)  // StartMonth
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param5;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x1)  // StartDay
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param6;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x1)  // StartHour
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param7;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x1)  // StartMinute
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param8;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x1)  // EndYear
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param9;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x1)  // EndMonth
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param10;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x1)  // EndDay
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param11;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x1)  // EndHour
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param12;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x1)  // EndMinute
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param13;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x4)  // Activation
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts] = BatteryControl_Contracts[i].param14 * 16;
           temp = Data_BatteryControl_Contracts[j_BatteryControl_Contracts];
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x4)  // Blocking
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = temp + BatteryControl_Contracts[i].param15;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x4 || recordaddress == 0x5)  // Priority
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts] = BatteryControl_Contracts[i].param16 * 16;
           temp = Data_BatteryControl_Contracts[j_BatteryControl_Contracts];
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x4)  // ContractState
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = temp + BatteryControl_Contracts[i].param17;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x2)  // MaxPrice
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param18;
         }
        
         if (recordaddress == 0x0 || recordaddress == 0x2)  // MaxPrice_Multiplier
         {
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param19;
         }
        
         /*if (recordaddress == 0x0) // CurrencyUnit -> es gibt keine RecordAddresse, in der der Paramter mit übertragen wird
         {  
           Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param20_Length;
           stringsize = BatteryControl_Contracts[i].param20_Length;
        
           for (strctr = 0; strctr < stringsize; strctr++)
           {
             Data_BatteryControl_Contracts[j_BatteryControl_Contracts++] = BatteryControl_Contracts[i].param20[strctr];           
           } 
         }*/
      }
    break;
  }
  settimer(Delay_BatteryControl_Contracts, @Env_BatteryControl_Contracts_ListDelay);
}

BatteryControl_Contracts_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  SendRequestByteSequence(LSGID_BatteryControl, 0x30, Changed_REQ, length, data);
}

on timer Delay_BatteryControl_Contracts
{ 
  sendRequestByteSequence(LSGID_BatteryControl, 0x30, Data_REQ, j_BatteryControl_Contracts, Data_BatteryControl_Contracts);
}
















/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////// Telefon ///////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

on envVar Node_Index_FSG_40
{   
  Node_Index_Telefon = getValue(this);
  writelineex(gBAP_Trace,0, "NodeIndex FSG 40: %d", Node_Index_Telefon);
}

on envVar Node_Index_FSG_41
{
  Node_Index_Telefon2 = getValue(this);
  writelineex(gBAP_Trace,0, "NodeIndex FSG 41: %d", Node_Index_Telefon2);
}

on message BAP_Telefon_ASG_01
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  Telefon_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG40_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon_app_data_ASG01[log_channel][i] = 0;

      // BAP Header auswerten
      Telefon_received_function_ASG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Telefon_received_function_ASG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Telefon_received_function_ASG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Telefon_app_data_ASG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_ASG01[log_channel][2]);
      
      // an checkfunction übergeben
      if (Telefon_received_function_ASG01[log_channel][2] == 0x31) { Telefon_CombinedNumbers_Log_Channel = log_channel; } // CombinedNumbers
      checkFunction (Telefon_received_function_ASG01[log_channel][0], Telefon_received_function_ASG01[log_channel][1], Telefon_received_function_ASG01[log_channel][2], Telefon_app_data_ASG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon_app_data_ASG01[log_channel][i] = 0;        

      // BAP Header auswerten
      Telefon_received_function_ASG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Telefon_received_function_ASG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Telefon_received_function_ASG01[log_channel][2] = (data[3] & 0x3F); // FctID
      Telefon_data_length_ASG01[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Telefon_app_data_ASG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Telefon_data_length_ASG01[log_channel] = Telefon_data_length_ASG01[log_channel] - 4;
      Telefon_currentPosASG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Telefon_data_length_ASG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (Telefon_received_function_ASG01[log_channel][2] == 0x31) { Telefon_CombinedNumbers_Log_Channel = log_channel; } // CombinedNumbers
        checkFunction (Telefon_received_function_ASG01[log_channel][0], Telefon_received_function_ASG01[log_channel][1], Telefon_received_function_ASG01[log_channel][2], Telefon_app_data_ASG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Telefon_sequenceNumberASG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Telefon_data_length_ASG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Telefon_app_data_ASG01[log_channel][Telefon_currentPosASG01[log_channel]] = data[i+1];
           Telefon_currentPosASG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Telefon_data_length_ASG01[log_channel] = Telefon_data_length_ASG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Telefon_data_length_ASG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Telefon_data_length_ASG01[log_channel]; i++)
        {
           Telefon_app_data_ASG01[log_channel][Telefon_currentPosASG01[log_channel]] = data[i+1];
           Telefon_currentPosASG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (Telefon_received_function_ASG01[log_channel][2] == 0x31) { Telefon_CombinedNumbers_Log_Channel = log_channel; } // CombinedNumbers
        checkFunction (Telefon_received_function_ASG01[log_channel][0], Telefon_received_function_ASG01[log_channel][1], Telefon_received_function_ASG01[log_channel][2], Telefon_app_data_ASG01[log_channel]);
      }
    }
  }
}

on message BAP_Telefon_ASG_02
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  Telefon_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG40_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon_app_data_ASG02[log_channel][i] = 0;

      // BAP Header auswerten
      Telefon_received_function_ASG02[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Telefon_received_function_ASG02[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Telefon_received_function_ASG02[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Telefon_app_data_ASG02[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_ASG02[log_channel][2]);
      
      // an checkfunction übergeben
      if (Telefon_received_function_ASG02[log_channel][2] == 0x34) { Telefon_Phonebook_Log_Channel = log_channel; } // Phonebook
      if (Telefon_received_function_ASG02[log_channel][2] == 0x3C) { Telefon_FavoriteList_Log_Channel = log_channel; } // FavoriteList
      checkFunction (Telefon_received_function_ASG02[log_channel][0], Telefon_received_function_ASG02[log_channel][1], Telefon_received_function_ASG02[log_channel][2], Telefon_app_data_ASG02[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon_app_data_ASG02[log_channel][i] = 0;        

      // BAP Header auswerten
      Telefon_received_function_ASG02[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Telefon_received_function_ASG02[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Telefon_received_function_ASG02[log_channel][2] = (data[3] & 0x3F); // FctID
      Telefon_data_length_ASG02[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Telefon_app_data_ASG02[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Telefon_data_length_ASG02[log_channel] = Telefon_data_length_ASG02[log_channel] - 4;
      Telefon_currentPosASG02[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Telefon_data_length_ASG02[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_ASG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Telefon_received_function_ASG02[log_channel][2] == 0x34) { Telefon_Phonebook_Log_Channel = log_channel; } // Phonebook
        if (Telefon_received_function_ASG02[log_channel][2] == 0x3C) { Telefon_FavoriteList_Log_Channel = log_channel; } // FavoriteList
        checkFunction (Telefon_received_function_ASG02[log_channel][0], Telefon_received_function_ASG02[log_channel][1], Telefon_received_function_ASG02[log_channel][2], Telefon_app_data_ASG02[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Telefon_sequenceNumberASG02[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Telefon_data_length_ASG02[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Telefon_app_data_ASG02[log_channel][Telefon_currentPosASG02[log_channel]] = data[i+1];
           Telefon_currentPosASG02[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Telefon_data_length_ASG02[log_channel] = Telefon_data_length_ASG02[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Telefon_data_length_ASG02[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Telefon_data_length_ASG02[log_channel]; i++)
        {
           Telefon_app_data_ASG02[log_channel][Telefon_currentPosASG02[log_channel]] = data[i+1];
           Telefon_currentPosASG02[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_ASG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Telefon_received_function_ASG02[log_channel][2] == 0x34) { Telefon_Phonebook_Log_Channel = log_channel; } // Phonebook
        if (Telefon_received_function_ASG02[log_channel][2] == 0x3C) { Telefon_FavoriteList_Log_Channel = log_channel; } // FavoriteList
        checkFunction (Telefon_received_function_ASG02[log_channel][0], Telefon_received_function_ASG02[log_channel][1], Telefon_received_function_ASG02[log_channel][2], Telefon_app_data_ASG02[log_channel]);
      }
    }
  }
}

on message BAP_Telefon_FSG_01
{
  byte data[8];
  byte FSG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: FSG
  Telefon_Source = 2;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG40_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon_app_data_FSG01[log_channel][i] = 0;

      // BAP Header auswerten
      Telefon_received_function_FSG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Telefon_received_function_FSG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Telefon_received_function_FSG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Telefon_app_data_FSG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_FSG01[log_channel][2]);
      
      // an checkfunction übergeben
      checkFunction (Telefon_received_function_FSG01[log_channel][0], Telefon_received_function_FSG01[log_channel][1], Telefon_received_function_FSG01[log_channel][2], Telefon_app_data_FSG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon_app_data_FSG01[log_channel][i] = 0;        

      // BAP Header auswerten
      Telefon_received_function_FSG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Telefon_received_function_FSG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Telefon_received_function_FSG01[log_channel][2] = (data[3] & 0x3F); // FctID
      Telefon_data_length_FSG01[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Telefon_app_data_FSG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Telefon_data_length_FSG01[log_channel] = Telefon_data_length_FSG01[log_channel] - 4;
      Telefon_currentPosFSG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Telefon_data_length_FSG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_FSG01[log_channel][2]);
        
        // an checkfunction übergeben
        checkFunction (Telefon_received_function_FSG01[log_channel][0], Telefon_received_function_FSG01[log_channel][1], Telefon_received_function_FSG01[log_channel][2], Telefon_app_data_FSG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Telefon_sequenceNumberFSG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Telefon_data_length_FSG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Telefon_app_data_FSG01[log_channel][Telefon_currentPosFSG01[log_channel]] = data[i+1];
           Telefon_currentPosFSG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Telefon_data_length_FSG01[log_channel] = Telefon_data_length_FSG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Telefon_data_length_FSG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Telefon_data_length_FSG01[log_channel]; i++)
        {
           Telefon_app_data_FSG01[log_channel][Telefon_currentPosFSG01[log_channel]] = data[i+1];
           Telefon_currentPosFSG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_FSG01[log_channel][2]);
        
        // an checkfunction übergeben
        checkFunction (Telefon_received_function_FSG01[log_channel][0], Telefon_received_function_FSG01[log_channel][1], Telefon_received_function_FSG01[log_channel][2], Telefon_app_data_FSG01[log_channel]);
      }
    }
  }
}

on message BAP_Telefon_FSG_02
{
  byte data[8];
  byte FSG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: FSG
  Telefon_Source = 2;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG40_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon_app_data_FSG02[log_channel][i] = 0;

      // BAP Header auswerten
      Telefon_received_function_FSG02[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Telefon_received_function_FSG02[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Telefon_received_function_FSG02[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Telefon_app_data_FSG02[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_FSG02[log_channel][2]);
      
      // an checkfunction übergeben
      checkFunction (Telefon_received_function_FSG02[log_channel][0], Telefon_received_function_FSG02[log_channel][1], Telefon_received_function_FSG02[log_channel][2], Telefon_app_data_FSG02[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon_app_data_FSG02[log_channel][i] = 0;        

      // BAP Header auswerten
      Telefon_received_function_FSG02[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Telefon_received_function_FSG02[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Telefon_received_function_FSG02[log_channel][2] = (data[3] & 0x3F); // FctID
      Telefon_data_length_FSG02[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Telefon_app_data_FSG02[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Telefon_data_length_FSG02[log_channel] = Telefon_data_length_FSG02[log_channel] - 4;
      Telefon_currentPosFSG02[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Telefon_data_length_FSG02[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_FSG02[log_channel][2]);
        
        // an checkfunction übergeben
        checkFunction (Telefon_received_function_FSG02[log_channel][0], Telefon_received_function_FSG02[log_channel][1], Telefon_received_function_FSG02[log_channel][2], Telefon_app_data_FSG02[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Telefon_sequenceNumberFSG02[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Telefon_data_length_FSG02[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Telefon_app_data_FSG02[log_channel][Telefon_currentPosFSG02[log_channel]] = data[i+1];
           Telefon_currentPosFSG02[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Telefon_data_length_FSG02[log_channel] = Telefon_data_length_FSG02[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Telefon_data_length_FSG02[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Telefon_data_length_FSG02[log_channel]; i++)
        {
           Telefon_app_data_FSG02[log_channel][Telefon_currentPosFSG02[log_channel]] = data[i+1];
           Telefon_currentPosFSG02[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon_received_function_FSG02[log_channel][2]);
        
        // an checkfunction übergeben
        checkFunction (Telefon_received_function_FSG02[log_channel][0], Telefon_received_function_FSG02[log_channel][1], Telefon_received_function_FSG02[log_channel][2], Telefon_app_data_FSG02[log_channel]);
      }
    }
  }
}


// Telefon - 0x10 MobileServiceSupport

Telefon_MobileServiceSupport_Status (byte fctList[])
{
  sendRequestByteSequence(LSGID_Telefon, 0x10, Data_REQ, 8, fctList);
}

on envVar Env_Telefon_MobileServiceSupport_On_43
{
  if (@this == 1)
    Telefon_MobileServiceSupport_All_On_43();
}

on envVar Env_Telefon_MobileServiceSupport_Off_43
{
  if (@this == 1)
    Telefon_MobileServiceSupport_All_Off_43();
}

Telefon_MobileServiceSupport_All_On_43()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x7F;
  values[3]=0xFF;
  values[4]=0xFF;
  values[5]=0xFF;
  values[6]=0xFF;
  values[7]=0xF8;
  
  putvalue(P_FSG_40_0_0_16_1, values);
} 

Telefon_MobileServiceSupport_All_Off_43()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x00;
  values[3]=0x00;
  values[4]=0x00;
  values[5]=0x00;
  values[6]=0x00;
  values[7]=0x00;
  
  putvalue(P_FSG_40_0_0_16_1, values);
}

on envVar Env_Telefon_MobileServiceSupport_On_46
{
  if (@this == 1)
    Telefon_MobileServiceSupport_All_On_46();
}

on envVar Env_Telefon_MobileServiceSupport_Off_46
{
  if (@this == 1)
    Telefon_MobileServiceSupport_All_Off_46();
}

Telefon_MobileServiceSupport_All_On_46()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0xFF;
  values[3]=0xFF;
  values[4]=0xFF;
  values[5]=0xFF;
  values[6]=0xFF;
  values[7]=0xFF;
  
  putvalue(P_FSG_40_0_0_16_1, values);
} 

Telefon_MobileServiceSupport_All_Off_46()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x00;
  values[3]=0x00;
  values[4]=0x00;
  values[5]=0x00;
  values[6]=0x00;
  values[7]=0x00;
  
  putvalue(P_FSG_40_0_0_16_1, values);
}


// Telefon - 0x1A DialNumber

Telefon_DialNumber (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // DialNumber Result senden
    Result = @M_FSG_40_0_0_26_Result_1;
    
    sendRequest (LSGID_Telefon, 0x1A, Result_REQ, 1, Result);
  }
}


// Telefon - 0x1B DialService

Telefon_DialService (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // DialService Result senden
    Result = @M_FSG_40_0_0_27_Result_1;
    
    sendRequest (LSGID_Telefon, 0x1B, Result_REQ, 1, Result);
  }
}


// Telefon - 0x1C ConfirmEmergencyCall

Telefon_ConfirmEmergencyCall (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // ConfirmEmergencyCall Result senden
    Result = @M_FSG_40_0_0_28_Result_1;
    
    sendRequest (LSGID_Telefon, 0x1C, Result_REQ, 1, Result);
  }
}


// Telefon - 0x1D HangupCall

Telefon_HangupCall (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // HangupCall Result senden
    Result = @M_FSG_40_0_0_29_Result_1;
    
    sendRequest (LSGID_Telefon, 0x1D, Result_REQ, 1, Result);
  }
}


// Telefon - 0x1E AcceptCall

Telefon_AcceptCall (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // AcceptCall Result senden
    Result = @M_FSG_40_0_0_30_Result_1;
    
    sendRequest (LSGID_Telefon, 0x1E, Result_REQ, 1, Result);
  }
}


// Telefon - 0x1F CallHold

Telefon_CallHold (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // CallHold Result senden
    Result = @M_FSG_40_0_0_31_Result_1;
    
    sendRequest (LSGID_Telefon, 0x1F, Result_REQ, 1, Result);
  }
}


// Telefon - 0x20 ResumeCall

Telefon_ResumeCall (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // ResumeCall Result senden
    Result = @M_FSG_40_0_0_32_Result_1;
    
    sendRequest (LSGID_Telefon, 0x20, Result_REQ, 1, Result);
  }
}


// Telefon - 0x23 MPRelActiveCallAcceptWC

Telefon_MPRelActiveCallAcceptWC (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // MPRelActiveCallAcceptWC Result senden
    Result = @M_FSG_40_0_0_35_Result_1;
    
    sendRequest (LSGID_Telefon, 0x23, Result_REQ, 1, Result);
  }
}


// Telefon - 0x24 MPSwap

Telefon_MPSwap (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // MPSwap Result senden
    Result = @M_FSG_40_0_0_36_Result_1;
    
    sendRequest (LSGID_Telefon, 0x24, Result_REQ, 1, Result);
  }
}


// Telefon - 0x25 MPCallHoldAcceptWC

Telefon_MPCallHoldAcceptWC (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // MPCallHoldAcceptWC Result senden
    Result = @M_FSG_40_0_0_37_Result_1;
    
    sendRequest (LSGID_Telefon, 0x25, Result_REQ, 1, Result);
  }
}


// Telefon - 0x26 MPRelAllCallsAcceptWC

Telefon_MPRelAllCallsAcceptWC (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // MPRelAllCallsAcceptWC Result senden
    Result = @M_FSG_40_0_0_38_Result_1;
    
    sendRequest (LSGID_Telefon, 0x26, Result_REQ, 1, Result);
  }
}


// Telefon - 0x27 MPSetWaitingCallOnHold

Telefon_MPSetWaitingCallOnHold (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // MPSetWaitingCallOnHold Result senden
    Result = @M_FSG_40_0_0_39_Result_1;
    
    sendRequest (LSGID_Telefon, 0x27, Result_REQ, 1, Result);
  }
}


// Telefon - 0x28 CCJoin

Telefon_CCJoin (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // CCJoin Result senden
    Result = @M_FSG_40_0_0_40_Result_1;
    
    sendRequest (LSGID_Telefon, 0x28, Result_REQ, 1, Result);
  }
}


// Telefon - 0x29 CCSplit

Telefon_CCSplit (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // CCSplit Result senden
    Result = @M_FSG_40_0_0_41_Result_1;
    
    sendRequest (LSGID_Telefon, 0x29, Result_REQ, 1, Result);
  }
}


// Telefon - 0x31 CombinedNumbers

on envVar Env_Telefon_CombinedNumbers_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Telefon_CombinedNumbers_Path, gTelefon_CombinedNumbers_Path);
    Telefon_CombinedNumbers_LoadArray();
  } 
}

on envVar Env_Telefon_CombinedNumbers_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Telefon_CombinedNumbers_Path, gTelefon_CombinedNumbers_Path);
    Telefon_CombinedNumbers_LoadArray();
    Telefon_CombinedNumbers_Changed(0x8,0x0, 0x0000, 0xFFFF);
  }
}

Telefon_CombinedNumbers_LoadArray()
{ 
 /********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
  //char temp2[25];
	char temp3[25];
  char temp4[25];
	//char temp5[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];
  char temp11[25];
  
	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
    //putValue(A_FSG_40_0_0_49_fileSelector,gTelefon_CombinedNumbers_Path);
    //putValue(A_FSG_40_0_0_49_loadArray_Btn, TRUE);
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Telefon_CombinedNumbers[i].Param1 = 0;
    
		for (j=0; j<100; j++) 
	  Telefon_CombinedNumbers[i].Param2[j] = 0;
		Telefon_CombinedNumbers[i].Param2_Length = 0;
		Telefon_CombinedNumbers[i].Param3 = 0;
    Telefon_CombinedNumbers[i].Param4 = 0;
		for (j=0; j<41; j++)
		Telefon_CombinedNumbers[i].Param5[j] = 0;
		Telefon_CombinedNumbers[i].Param5_Length = 0;
		Telefon_CombinedNumbers[i].Param6 = 0;
		Telefon_CombinedNumbers[i].Param7 = 0;
		Telefon_CombinedNumbers[i].Param8 = 0;
		Telefon_CombinedNumbers[i].Param9 = 0;
		Telefon_CombinedNumbers[i].Param10 = 0;
    Telefon_CombinedNumbers[i].Param11 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gTelefon_CombinedNumbers_Path); i++)
  {
    if (gTelefon_CombinedNumbers_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gTelefon_CombinedNumbers_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gTelefon_CombinedNumbers_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)
  

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

    //writelineEx(4, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);
   // writelineEx(4, 0,"Num_of_csv_byte '%d'", Num_of_csv_byte);
    
		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "CombinedNumbers"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in CombinedNumbers) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{     //writelineex(4,0,"LF / CR detected");
					if (current_CSV_line > 0 && current_CSV_line < 1024) //ignore first line in *.csv file
					{
						Telefon_CombinedNumbers[current_CSV_line-1].Param1 = atol(temp1); //Pos
            //Telefon_CombinedNumbers[current_CSV_line-1].Param2 = atol(temp2); //PbName
						Telefon_CombinedNumbers[current_CSV_line-1].Param3 = atol(temp3); //NumberType
            Telefon_CombinedNumbers[current_CSV_line-1].Param4= atol(temp4); //CallMode
						//Telefon_CombinedNumbers[current_CSV_line-1].Param5 = atol(temp5); //TelNumber
						Telefon_CombinedNumbers[current_CSV_line-1].Param6 = atol(temp6); //Day
						Telefon_CombinedNumbers[current_CSV_line-1].Param7 = atol(temp7); //Month
						Telefon_CombinedNumbers[current_CSV_line-1].Param8 = atol(temp8); //Year
						Telefon_CombinedNumbers[current_CSV_line-1].Param9 = atol(temp9); //Hour
						Telefon_CombinedNumbers[current_CSV_line-1].Param10 = atol(temp10); //Minute
            Telefon_CombinedNumbers[current_CSV_line-1].Param11 = atol(temp11); //Second
            
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
              //temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
              //temp5[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
              temp11[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
          
          //writelineEx(4, 0, "current_CSV_line %d", current_CSV_line);
          
          element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 1024)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
                  temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}          
							break;
						case 2: //PbName
								if (paramPos < 99)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Telefon_CombinedNumbers_ListFormat == 1) )
                  {
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos++] = buffer_byte[filePos++];
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Telefon_CombinedNumbers_ListFormat == 0) )
                  {
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos++] = 0xC2;
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Telefon_CombinedNumbers_ListFormat == 0) )
                  {
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos++] = 0xC3;
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
									Telefon_CombinedNumbers[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
							/*if(paramPos < 99)
								{
									Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
									Telefon_CombinedNumbers[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;	*/
						break;
						case 3: //NumberType
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
            case 4: //CallMode
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //TelNumber
								if (paramPos < 40)
								{
									Telefon_CombinedNumbers[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									Telefon_CombinedNumbers[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						  break;
						case 6: //Day
								if ( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //Month
								if ( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //Year
								if ( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //Hour
								if ( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //Minute
								if ( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
								    //write("ddasd = %d", buffer_byte[filePos]);
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
                }
				break;
					 	case 11: //Second
						 		if ( paramPos >= elCount(temp11) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp11[paramPos] = buffer_byte[filePos];
									paramPos++;                  
								}
							break;
                
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
        //writelineEx(4, 0,"element: %d", element);
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
      writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  Telefon_CombinedNumbers_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Telefon_CombinedNumbers (byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements;
  
  if ((opcode == 1) && (Telefon_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;

    if (IndexSize == 1)
    {
      list_start = data[2] +data[3]*256;
      elements = data[4] + data[5]*256;
    }
    else
    {
      list_start = data[2];
      elements = data[3];
    }
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////
  
    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_40_0_0_49_1 = ASG_ID;  // Set to panel value
    else
      ASG_ID = @A_FSG_40_0_0_49_1; // Set from panel value
      
    if (@env_AutoGetArray_TAID == 0)  // TAID
      @A_FSG_40_0_0_49_2 = TAID;
    else
      TAID = @A_FSG_40_0_0_49_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
      @A_FSG_40_0_0_49_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_40_0_0_49_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
      @A_FSG_40_0_0_49_Shift = (mode>>0);
    else
      mode = ((@A_FSG_40_0_0_49_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
      @A_FSG_40_0_0_49_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_40_0_0_49_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start
      @A_FSG_40_0_0_49_Start = list_start;
    else
      list_start = @A_FSG_40_0_0_49_Start;
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
    if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
    {
      Telefon_CombinedNumbers_Status (ASG_ID, TAID, mode, recordaddress,list_start, elements);
    }
  }
}

dword Telefon_CombinedNumbers_Search_Pos (dword position)
{
  dword i;
  
  for (i = 0; i<Telefon_CombinedNumbers_TotalListNum; i++)
  {
    if (position == Telefon_CombinedNumbers[i].param1)
    { 
      return i;
    } 
  }
  return 0;
}

Telefon_CombinedNumbers_Status (byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{   
  byte string[60];
  byte IndexSize, shift, direction;
  int startposition, endposition, elements;
  byte sequenceNumber = 0;
  int i, k , strctr;
  int stringsize;
  
  elements = received_elements;
  
  Data_Telefon_CombinedNumbers[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Telefon_CombinedNumbers[1] = (Telefon_CombinedNumbers_TotalListNum & 0xFF);
  Data_Telefon_CombinedNumbers[2] = (mode|0x4)*16 + (recordaddress & 0xF);
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
  
  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift;
        endposition = startposition + elements - 1;
      }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Telefon_CombinedNumbers_Search_Pos(list_start) != 0)
        {
          startposition = Telefon_CombinedNumbers_Search_Pos(list_start) + shift;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Telefon_CombinedNumbers_TotalListNum)
      {
        endposition = Telefon_CombinedNumbers_TotalListNum -1;
        elements = Telefon_CombinedNumbers_TotalListNum - startposition;
      }
      
    break;
  
    case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Telefon_CombinedNumbers_Search_Pos(list_start) != 0)
        {
          startposition = Telefon_CombinedNumbers_Search_Pos(list_start) - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift + 1;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Telefon_CombinedNumbers_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
      
    break;
  }
    
  if (IndexSize == 0)
  {
    Data_Telefon_CombinedNumbers[3] = list_start & 0xFF;
    Data_Telefon_CombinedNumbers[4] = elements & 0xFF;

    j_Telefon_CombinedNumbers = 5;
  }
  else
  {
    Data_Telefon_CombinedNumbers[4] = (list_start >> 8) & 0xFF;
    Data_Telefon_CombinedNumbers[3] = list_start & 0xFF;
    Data_Telefon_CombinedNumbers[6] = (elements >> 8) & 0xFF;
    Data_Telefon_CombinedNumbers[5] = elements & 0xFF;

    j_Telefon_CombinedNumbers = 7;
  }
  
  if (elements > 0)
  {
    switch(direction)
    {
      case 0:        

        for (i = startposition ; i <= endposition && i >= 0; i++) 
        {              
          switch(IndexSize) // Pos
          {
            case 0: Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param1;
                    break;
            case 1: Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param1 &0xFF;
                    Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = (Telefon_CombinedNumbers[i].param1 >> 8)&0xFF;
                    break;
          }

          if (recordaddress == 0x0 || recordaddress == 0x1) // PbName
          {
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param2_Length; 
            stringsize = Telefon_CombinedNumbers[i].param2_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param2[strctr];            
            }
          }

          if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x2) // NumberType & CallMode
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = (Telefon_CombinedNumbers[i].param3 & 0xF) *16 + (Telefon_CombinedNumbers[i].param4 & 0xF);

          if (recordaddress == 0x0 ||  recordaddress == 0x2) // TelNumber
          {
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param5_Length; 
            stringsize = Telefon_CombinedNumbers[i].param5_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param5[strctr];            
            }
          }

          if (recordaddress == 0x0 || recordaddress == 0x2)// Day
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param6;
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // Month
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param7;
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // Year
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param8;
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // Hour
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param9;
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // Minute
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param10;
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // Second
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param11;
                
        }
            
      break;
        
      case 1:
              
        for (i = startposition ; i >= endposition && i >= 0; i--) // Pos
        {
          switch(IndexSize)
          {
            case 0: Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param1;
                    break;
            case 1: Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param1 &0xFF;
                    Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = (Telefon_CombinedNumbers[i].param1 >> 8)&0xFF;
                    break;
          }

          if (recordaddress == 0x0 || recordaddress == 0x1) // PbName
          {
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param2_Length; 
            stringsize = Telefon_CombinedNumbers[i].param2_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param2[strctr];
            }
          }

          if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x2) // NumberType & CallMode
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = (Telefon_CombinedNumbers[i].param3 & 0xF) *16 + (Telefon_CombinedNumbers[i].param4 & 0xF);

          if (recordaddress == 0x0 ||  recordaddress == 0x2) // TelNumber
          {
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param5_Length; 
            stringsize = Telefon_CombinedNumbers[i].param5_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param5[strctr];            
            }
          }

          if (recordaddress == 0x0 || recordaddress == 0x2) // Day
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param6;
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // Month
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param7;
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // Year
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param8;
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // Hour
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param9;
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // Minute
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param10;
          
          if (recordaddress == 0x0 || recordaddress == 0x2) // Second
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param11;
        }
        
      break;
    }
  }
  settimer (Delay_Telefon_CombinedNumbers, @Env_Telefon_CombinedNumbers_ListDelay);
}

Telefon_CombinedNumbers_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;
  
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
    data[1] = list_start;
    data[2] = elements;
    length = 3;
  }
  else if (IndexSize == 1)
  {
    data[1] = list_start & 0xFF;
    data[2] = (list_start >> 8) & 0xFF;
    data[3] = elements & 0xFF;
    data[4] = (elements >> 8) & 0xFF;
    
    length = 5;
  }
  SendRequestByteSequence(LSGID_Telefon, 0x31, Changed_REQ, length, data);
}

on timer Delay_Telefon_CombinedNumbers
{
  sendRequestByteSequence(LSGID_Telefon, 0x31, Data_REQ, j_Telefon_CombinedNumbers, Data_Telefon_CombinedNumbers);
}


// Telefon - 0x32 CallStackDeleteAll

Telefon_CallStackDeleteAll (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // CallStackDeleteAll Result senden
    Result = @M_FSG_40_0_0_50_Result_1;
    
    sendRequest (LSGID_Telefon, 0x32, Result_REQ, 1, Result);
  }
}


// Telefon - 0x34 Phonebook

on envVar Env_Telefon_Phonebook_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Telefon_Phonebook_Path, gTelefon_Phonebook_Path);
    Telefon_Phonebook_LoadArray();
  }
}

on envVar Env_Telefon_Phonebook_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Telefon_Phonebook_Path, gTelefon_Phonebook_Path);
    Telefon_Phonebook_LoadArray();
    Telefon_Phonebook_Changed(0x8,0x0, 0x0000, 0xFFFF); 
  }
}

Telefon_Phonebook_LoadArray ()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp_Pos[25];
	char temp_Storage[25];
	char temp_AnyVoiceTag[25];
	char temp_TelNumberQuantity[25];
	char temp_VoiceTag01[25];
  char temp_VoiceTag02[25];
  char temp_VoiceTag03[25];
  char temp_VoiceTag04[25];
  char temp_VoiceTag05[25];
  char temp_VoiceTag06[25];
  char temp_VoiceTag07[25];
  char temp_VoiceTag08[25];
  char temp_VoiceTag09[25];
  char temp_VoiceTag10[25];
	char temp_Reserve01[25];
  char temp_Reserve02[25];
  char temp_Reserve03[25];
  char temp_Reserve04[25];
  char temp_Reserve05[25];
  char temp_Reserve06[25];
  char temp_Reserve07[25];
  char temp_Reserve08[25];
  char temp_Reserve09[25];
  char temp_Reserve10[25];
	char temp_NumberType01[25];
  char temp_NumberType02[25];
  char temp_NumberType03[25];
  char temp_NumberType04[25];
  char temp_NumberType05[25];
  char temp_NumberType06[25];
  char temp_NumberType07[25];
  char temp_NumberType08[25];
  char temp_NumberType09[25];
  char temp_NumberType10[25];
	char temp_AdressIndication[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
    //putValue(A_FSG_40_0_0_52_fileSelector, gTelefon_Phonebook_Path);
    //putValue(A_FSG_40_0_0_52_loadArray_Btn, TRUE);
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Telefon_Phonebook[i].Pos = 0;
		for (j=0; j<100; j++)
			Telefon_Phonebook[i].PbName[j] = 0;
		Telefon_Phonebook[i].PbName_Length = 0;
		Telefon_Phonebook[i].Storage = 0;
		Telefon_Phonebook[i].AnyVoiceTag = 0;
		Telefon_Phonebook[i].TelNumberQuantity = 0;
		for (j=0; j<410; j++)
    {
			Telefon_Phonebook[i].TelNumber01[j] = 0;
      Telefon_Phonebook[i].TelNumber02[j] = 0;
      Telefon_Phonebook[i].TelNumber03[j] = 0;
      Telefon_Phonebook[i].TelNumber04[j] = 0;
      Telefon_Phonebook[i].TelNumber05[j] = 0;
      Telefon_Phonebook[i].TelNumber06[j] = 0;
      Telefon_Phonebook[i].TelNumber07[j] = 0;
      Telefon_Phonebook[i].TelNumber08[j] = 0;
      Telefon_Phonebook[i].TelNumber09[j] = 0;
      Telefon_Phonebook[i].TelNumber10[j] = 0;
    }
		Telefon_Phonebook[i].TelNumber01_Length = 0;
    Telefon_Phonebook[i].TelNumber02_Length = 0;
    Telefon_Phonebook[i].TelNumber03_Length = 0;
    Telefon_Phonebook[i].TelNumber04_Length = 0;
    Telefon_Phonebook[i].TelNumber05_Length = 0;
    Telefon_Phonebook[i].TelNumber06_Length = 0;
    Telefon_Phonebook[i].TelNumber07_Length = 0;
    Telefon_Phonebook[i].TelNumber08_Length = 0;
    Telefon_Phonebook[i].TelNumber09_Length = 0;
    Telefon_Phonebook[i].TelNumber10_Length = 0;
		Telefon_Phonebook[i].VoiceTag01 = 0;
    Telefon_Phonebook[i].VoiceTag02 = 0;
    Telefon_Phonebook[i].VoiceTag03 = 0;
    Telefon_Phonebook[i].VoiceTag04 = 0;
    Telefon_Phonebook[i].VoiceTag05 = 0;
    Telefon_Phonebook[i].VoiceTag06 = 0;
    Telefon_Phonebook[i].VoiceTag07 = 0;
    Telefon_Phonebook[i].VoiceTag08 = 0;
    Telefon_Phonebook[i].VoiceTag09 = 0;
    Telefon_Phonebook[i].VoiceTag10 = 0;
		Telefon_Phonebook[i].Reserve01 = 0;
    Telefon_Phonebook[i].Reserve02 = 0;
    Telefon_Phonebook[i].Reserve03 = 0;
    Telefon_Phonebook[i].Reserve04 = 0;
    Telefon_Phonebook[i].Reserve05 = 0;
    Telefon_Phonebook[i].Reserve06 = 0;
    Telefon_Phonebook[i].Reserve07 = 0;
    Telefon_Phonebook[i].Reserve08 = 0;
    Telefon_Phonebook[i].Reserve09 = 0;
    Telefon_Phonebook[i].Reserve10 = 0;
		Telefon_Phonebook[i].NumberType01 = 0;
    Telefon_Phonebook[i].NumberType02 = 0;
    Telefon_Phonebook[i].NumberType03 = 0;
    Telefon_Phonebook[i].NumberType04 = 0;
    Telefon_Phonebook[i].NumberType05 = 0;
    Telefon_Phonebook[i].NumberType06 = 0;
    Telefon_Phonebook[i].NumberType07 = 0;
    Telefon_Phonebook[i].NumberType08 = 0;
    Telefon_Phonebook[i].NumberType09 = 0;
    Telefon_Phonebook[i].NumberType10 = 0;
    
		Telefon_Phonebook[i].AdressIndication = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gTelefon_Phonebook_Path); i++)
  {
    if (gTelefon_Phonebook_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gTelefon_Phonebook_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gTelefon_Phonebook_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "Phonebook"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
            
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in Phonebook) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 65535) //ignore first line in *.csv file
					{
            Telefon_Phonebook[current_CSV_line-1].Pos = atol(temp_Pos); //Pos
						Telefon_Phonebook[current_CSV_line-1].Storage = atol(temp_Storage); //Storage
						Telefon_Phonebook[current_CSV_line-1].AnyVoiceTag = atol(temp_AnyVoiceTag); //AnyVoiceTag
						Telefon_Phonebook[current_CSV_line-1].TelNumberQuantity = atol(temp_TelNumberQuantity); //TelNumberQuantity
						Telefon_Phonebook[current_CSV_line-1].VoiceTag01 = atol(temp_VoiceTag01); //VoiceTag(n)
            Telefon_Phonebook[current_CSV_line-1].VoiceTag02 = atol(temp_VoiceTag02); //VoiceTag(n)
            Telefon_Phonebook[current_CSV_line-1].VoiceTag03 = atol(temp_VoiceTag03); //VoiceTag(n)
            Telefon_Phonebook[current_CSV_line-1].VoiceTag04 = atol(temp_VoiceTag04); //VoiceTag(n)
            Telefon_Phonebook[current_CSV_line-1].VoiceTag05 = atol(temp_VoiceTag05); //VoiceTag(n)
            Telefon_Phonebook[current_CSV_line-1].VoiceTag06 = atol(temp_VoiceTag06); //VoiceTag(n)
            Telefon_Phonebook[current_CSV_line-1].VoiceTag07 = atol(temp_VoiceTag07); //VoiceTag(n)
            Telefon_Phonebook[current_CSV_line-1].VoiceTag08 = atol(temp_VoiceTag08); //VoiceTag(n)
            Telefon_Phonebook[current_CSV_line-1].VoiceTag09 = atol(temp_VoiceTag09); //VoiceTag(n)
            Telefon_Phonebook[current_CSV_line-1].VoiceTag10 = atol(temp_VoiceTag10); //VoiceTag(n)
						Telefon_Phonebook[current_CSV_line-1].Reserve01 = atol(temp_Reserve01); //Reserve(n)
            Telefon_Phonebook[current_CSV_line-1].Reserve02 = atol(temp_Reserve02); //Reserve(n)
            Telefon_Phonebook[current_CSV_line-1].Reserve03 = atol(temp_Reserve03); //Reserve(n)
            Telefon_Phonebook[current_CSV_line-1].Reserve04 = atol(temp_Reserve04); //Reserve(n)
            Telefon_Phonebook[current_CSV_line-1].Reserve05 = atol(temp_Reserve05); //Reserve(n)
            Telefon_Phonebook[current_CSV_line-1].Reserve06 = atol(temp_Reserve06); //Reserve(n)
            Telefon_Phonebook[current_CSV_line-1].Reserve07 = atol(temp_Reserve07); //Reserve(n)
            Telefon_Phonebook[current_CSV_line-1].Reserve08 = atol(temp_Reserve08); //Reserve(n)
            Telefon_Phonebook[current_CSV_line-1].Reserve09 = atol(temp_Reserve09); //Reserve(n)
            Telefon_Phonebook[current_CSV_line-1].Reserve10 = atol(temp_Reserve10); //Reserve(n)
						Telefon_Phonebook[current_CSV_line-1].NumberType01 = atol(temp_NumberType01); //NumberType(n)
            Telefon_Phonebook[current_CSV_line-1].NumberType02 = atol(temp_NumberType02); //NumberType(n)
            Telefon_Phonebook[current_CSV_line-1].NumberType03 = atol(temp_NumberType03); //NumberType(n)
            Telefon_Phonebook[current_CSV_line-1].NumberType04 = atol(temp_NumberType04); //NumberType(n)
            Telefon_Phonebook[current_CSV_line-1].NumberType05 = atol(temp_NumberType05); //NumberType(n)
            Telefon_Phonebook[current_CSV_line-1].NumberType06 = atol(temp_NumberType06); //NumberType(n)
            Telefon_Phonebook[current_CSV_line-1].NumberType07 = atol(temp_NumberType07); //NumberType(n)
            Telefon_Phonebook[current_CSV_line-1].NumberType08 = atol(temp_NumberType08); //NumberType(n)
            Telefon_Phonebook[current_CSV_line-1].NumberType09 = atol(temp_NumberType09); //NumberType(n)
            Telefon_Phonebook[current_CSV_line-1].NumberType10 = atol(temp_NumberType10); //NumberType(n)
						Telefon_Phonebook[current_CSV_line-1].AdressIndication = atol(temp_AdressIndication); //addressIndication
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp_Pos[i]=0;
							temp_Storage[i]=0;
							temp_AnyVoiceTag[i]=0;
							temp_TelNumberQuantity[i]=0;
							temp_VoiceTag01[i]=0;
              temp_VoiceTag02[i]=0;
              temp_VoiceTag03[i]=0;
              temp_VoiceTag04[i]=0;
              temp_VoiceTag05[i]=0;
              temp_VoiceTag06[i]=0;
              temp_VoiceTag07[i]=0;
              temp_VoiceTag08[i]=0;
              temp_VoiceTag09[i]=0;
              temp_VoiceTag10[i]=0;
							temp_Reserve01[i]=0;
              temp_Reserve02[i]=0;
              temp_Reserve03[i]=0;
              temp_Reserve04[i]=0;
              temp_Reserve05[i]=0;
              temp_Reserve06[i]=0;
              temp_Reserve07[i]=0;
              temp_Reserve08[i]=0;
              temp_Reserve09[i]=0;
              temp_Reserve10[i]=0;
							temp_NumberType01[i]=0;
              temp_NumberType02[i]=0;
              temp_NumberType03[i]=0;
              temp_NumberType04[i]=0;
              temp_NumberType05[i]=0;
              temp_NumberType06[i]=0;
              temp_NumberType07[i]=0;
              temp_NumberType08[i]=0;
              temp_NumberType09[i]=0;
              temp_NumberType10[i]=0;
							temp_AdressIndication[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
          TelNumberQuantity = 0;
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 65535)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp_Pos) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Pos[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 2: //PbName
								if (paramPos < 99)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Telefon_Phonebook_ListFormat == 1) )
                  {
                    Telefon_Phonebook[current_CSV_line-1].PbName[paramPos++] = buffer_byte[filePos++];
                    Telefon_Phonebook[current_CSV_line-1].PbName[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Telefon_Phonebook_ListFormat == 0) )
                  {
                    Telefon_Phonebook[current_CSV_line-1].PbName[paramPos++] = 0xC2;
                    Telefon_Phonebook[current_CSV_line-1].PbName[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Telefon_Phonebook_ListFormat == 0) )
                  {
                    Telefon_Phonebook[current_CSV_line-1].PbName[paramPos++] = 0xC3;
                    Telefon_Phonebook[current_CSV_line-1].PbName[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Telefon_Phonebook[current_CSV_line-1].PbName[paramPos] = buffer_byte[filePos];
                  }
									Telefon_Phonebook[current_CSV_line-1].PbName_Length = paramPos +1;
								}
								paramPos++;
						break;
                
						case 3: //Storage
								if ( paramPos >= elCount(temp_Storage) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Storage[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 4: //AnyVoiceTag
								if ( paramPos >= elCount(temp_AnyVoiceTag) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AnyVoiceTag[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 5: //TelNumberQuantity
								if ( paramPos >= elCount(temp_TelNumberQuantity) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_TelNumberQuantity[paramPos] = buffer_byte[filePos];
                  TelNumberQuantity = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 6: //TelNumber(n)
								if (paramPos < 408)
								{
									Telefon_Phonebook[current_CSV_line-1].TelNumber01[paramPos] = buffer_byte[filePos];
									Telefon_Phonebook[current_CSV_line-1].TelNumber01_Length = paramPos +1;
								}
								paramPos++;
						break;
                
						case 7: //VoiceTag(n)
								if ( paramPos >= elCount(temp_VoiceTag01) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_VoiceTag01[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 8: //Reserve(n)
								if ( paramPos >= elCount(temp_Reserve01) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Reserve01[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 9: //NumberType(n)
								if ( paramPos >= elCount(temp_NumberType01) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_NumberType01[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
  					case 10: //AdressIndication / TelNumber
              
             // TelNumberQuantity = 2
             if (TelNumberQuantity <= 2){
            
								if ( paramPos >= elCount(temp_AdressIndication) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AdressIndication[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
               }
                  
              else {if (paramPos < 408)
								{
									Telefon_Phonebook[current_CSV_line-1].TelNumber02[paramPos] = buffer_byte[filePos];
									Telefon_Phonebook[current_CSV_line-1].TelNumber02_Length = paramPos +1;
								}
								paramPos++;
               }   
     
            break;
              
						case 11: //VoiceTag(n)
								if ( paramPos >= elCount(temp_VoiceTag02) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_VoiceTag02[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 12: //Reserve(n)
								if ( paramPos >= elCount(temp_Reserve02) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Reserve02[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 13: //NumberType(n)
								if ( paramPos >= elCount(temp_NumberType02) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_NumberType02[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
            case 14: //AdressIndication / TelNumber
              
             // TelNumberQuantity = 3
             if (TelNumberQuantity <= 3){
            
								if ( paramPos >= elCount(temp_AdressIndication) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AdressIndication[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
               }
                  
              else {if (paramPos < 408)
								{
									Telefon_Phonebook[current_CSV_line-1].TelNumber03[paramPos] = buffer_byte[filePos];
									Telefon_Phonebook[current_CSV_line-1].TelNumber03_Length = paramPos +1;
								}
								paramPos++;
               }   
     
            break;
              
						case 15: //VoiceTag(n)
								if ( paramPos >= elCount(temp_VoiceTag03) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_VoiceTag03[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 16: //Reserve(n)
								if ( paramPos >= elCount(temp_Reserve03) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Reserve03[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 17: //NumberType(n)
								if ( paramPos >= elCount(temp_NumberType03) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_NumberType03[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
            case 18: //AdressIndication / TelNumber
              
             // TelNumberQuantity = 4
             if (TelNumberQuantity <= 4){
            
								if ( paramPos >= elCount(temp_AdressIndication) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AdressIndication[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
               }
                  
              else {if (paramPos < 408)
								{
									Telefon_Phonebook[current_CSV_line-1].TelNumber04[paramPos] = buffer_byte[filePos];
									Telefon_Phonebook[current_CSV_line-1].TelNumber04_Length = paramPos +1;
								}
								paramPos++;
               }   
     
            break;
              
						case 19: //VoiceTag(n)
								if ( paramPos >= elCount(temp_VoiceTag04) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_VoiceTag04[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 20: //Reserve(n)
								if ( paramPos >= elCount(temp_Reserve04) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Reserve04[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 21: //NumberType(n)
								if ( paramPos >= elCount(temp_NumberType04) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_NumberType04[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
             case 22: //AdressIndication / TelNumber
              
             // TelNumberQuantity = 5
             if (TelNumberQuantity <= 5){
            
								if ( paramPos >= elCount(temp_AdressIndication) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AdressIndication[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
               }
                  
              else {if (paramPos < 408)
								{
									Telefon_Phonebook[current_CSV_line-1].TelNumber05[paramPos] = buffer_byte[filePos];
									Telefon_Phonebook[current_CSV_line-1].TelNumber05_Length = paramPos +1;
								}
								paramPos++;
               }   
     
            break;
              
						case 23: //VoiceTag(n)
								if ( paramPos >= elCount(temp_VoiceTag05) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_VoiceTag05[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 24: //Reserve(n)
								if ( paramPos >= elCount(temp_Reserve05) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Reserve05[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 25: //NumberType(n)
								if ( paramPos >= elCount(temp_NumberType05) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_NumberType05[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
             case 26: //AdressIndication / TelNumber
              
             // TelNumberQuantity = 6
             if (TelNumberQuantity <= 6){
            
								if ( paramPos >= elCount(temp_AdressIndication) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AdressIndication[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
               }
                  
              else {if (paramPos < 408)
								{
									Telefon_Phonebook[current_CSV_line-1].TelNumber06[paramPos] = buffer_byte[filePos];
									Telefon_Phonebook[current_CSV_line-1].TelNumber06_Length = paramPos +1;
								}
								paramPos++;
               }   
     
            break;
              
						case 27: //VoiceTag(n)
								if ( paramPos >= elCount(temp_VoiceTag06) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_VoiceTag06[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 28: //Reserve(n)
								if ( paramPos >= elCount(temp_Reserve06) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Reserve06[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 29: //NumberType(n)
								if ( paramPos >= elCount(temp_NumberType06) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_NumberType06[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
             case 30: //AdressIndication / TelNumber
              
             // TelNumberQuantity = 7
             if (TelNumberQuantity <= 7){
            
								if ( paramPos >= elCount(temp_AdressIndication) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AdressIndication[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
               }
                  
              else {if (paramPos < 408)
								{
									Telefon_Phonebook[current_CSV_line-1].TelNumber07[paramPos] = buffer_byte[filePos];
									Telefon_Phonebook[current_CSV_line-1].TelNumber07_Length = paramPos +1;
								}
								paramPos++;
               }   
     
            break;
              
						case 31: //VoiceTag(n)
								if ( paramPos >= elCount(temp_VoiceTag07) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_VoiceTag07[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 32: //Reserve(n)
								if ( paramPos >= elCount(temp_Reserve07) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Reserve07[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 33: //NumberType(n)
								if ( paramPos >= elCount(temp_NumberType07) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_NumberType07[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
             case 34: //AdressIndication / TelNumber
              
             // TelNumberQuantity = 8
             if (TelNumberQuantity <= 8){
            
								if ( paramPos >= elCount(temp_AdressIndication) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AdressIndication[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
               }
                  
              else {if (paramPos < 408)
								{
									Telefon_Phonebook[current_CSV_line-1].TelNumber08[paramPos] = buffer_byte[filePos];
									Telefon_Phonebook[current_CSV_line-1].TelNumber08_Length = paramPos +1;
								}
								paramPos++;
               }   
     
            break;
              
						case 35: //VoiceTag(n)
								if ( paramPos >= elCount(temp_VoiceTag08) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_VoiceTag08[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 36: //Reserve(n)
								if ( paramPos >= elCount(temp_Reserve08) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Reserve08[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 37: //NumberType(n)
								if ( paramPos >= elCount(temp_NumberType08) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_NumberType08[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
             case 38: //AdressIndication / TelNumber
              
             // TelNumberQuantity = 9
             if (TelNumberQuantity <= 9){
            
								if ( paramPos >= elCount(temp_AdressIndication) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AdressIndication[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
               }
                  
              else {if (paramPos < 408)
								{
									Telefon_Phonebook[current_CSV_line-1].TelNumber09[paramPos] = buffer_byte[filePos];
									Telefon_Phonebook[current_CSV_line-1].TelNumber09_Length = paramPos +1;
								}
								paramPos++;
               }   
     
            break;
              
						case 39: //VoiceTag(n)
								if ( paramPos >= elCount(temp_VoiceTag09) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_VoiceTag09[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 40: //Reserve(n)
								if ( paramPos >= elCount(temp_Reserve09) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Reserve09[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 41: //NumberType(n)
								if ( paramPos >= elCount(temp_NumberType09) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_NumberType09[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
            case 42: //AdressIndication / TelNumber
              
             // TelNumberQuantity = 10
             if (TelNumberQuantity <= 10){
            
								if ( paramPos >= elCount(temp_AdressIndication) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AdressIndication[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
               }
                  
              else {if (paramPos < 408)
								{
									Telefon_Phonebook[current_CSV_line-1].TelNumber10[paramPos] = buffer_byte[filePos];
									Telefon_Phonebook[current_CSV_line-1].TelNumber10_Length = paramPos +1;
								}
								paramPos++;
               }   
     
            break;
              
						case 43: //VoiceTag(n)
								if ( paramPos >= elCount(temp_VoiceTag10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_VoiceTag10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 44: //Reserve(n)
								if ( paramPos >= elCount(temp_Reserve10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_Reserve10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
						case 45: //NumberType(n)
								if ( paramPos >= elCount(temp_NumberType10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_NumberType10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
                
            case 46: //AdressIndication
              
								if ( paramPos >= elCount(temp_AdressIndication) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp_AdressIndication[paramPos] = buffer_byte[filePos];
									paramPos++;
								}

            default:
						break;

					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}
		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'", CSV_filename); //output result
	}

  Telefon_Phonebook_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Telefon_Phonebook(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements;
  
  if ((opcode == 1) && (Telefon_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;

    if (IndexSize == 1)
    {
      list_start = data[2] +data[3]*256;
      elements = data[4] + data[5]*256;
    }
    else
    {
      list_start = data[2];
      elements = data[3];
    }
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////
    
    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_40_0_0_52_1 = ASG_ID;  // Set to panel value
    else
      ASG_ID = @A_FSG_40_0_0_52_1; // Set from panel value
      
    if (@env_AutoGetArray_TAID == 0)  // TAID
      @A_FSG_40_0_0_52_2 = TAID;
    else
      TAID = @A_FSG_40_0_0_52_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
      @A_FSG_40_0_0_52_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_40_0_0_52_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
      @A_FSG_40_0_0_52_Shift = (mode>>0);
    else
      mode = ((@A_FSG_40_0_0_52_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
      @A_FSG_40_0_0_52_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_40_0_0_52_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start
      @A_FSG_40_0_0_52_Start = list_start;
    else
      list_start = @A_FSG_40_0_0_52_Start;
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    
    if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
    {
      Telefon_Phonebook_Status(ASG_ID, TAID, mode, recordaddress,list_start, elements);
    }
  }
}

Telefon_Phonebook_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{   
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition=0, endposition=0, elements ;
  byte sequenceNumber = 0;
  byte j_max = 0, j_temp;
   byte data2[8]= {0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07};
  int i, k, strctr; 
  int stringsize;
  
  j_max = 0;

  elements = received_elements;
  
  Data_Telefon_Phonebook[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Telefon_Phonebook[1] = (Telefon_Phonebook_TotalListNum & 0xFF);
  Data_Telefon_Phonebook[2] = (Telefon_Phonebook_TotalListNum >>  8) & 0xFF;
  Data_Telefon_Phonebook[3] = (mode|0x4)*16 + (recordaddress & 0xF);
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift; 
        endposition = startposition + elements - 1; 
      }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float)Telefon_Phonebook_Search_Pos(list_start) <= Telefon_Phonebook_TotalListNum)
        {
          startposition = Telefon_Phonebook_Search_Pos(list_start) + shift - 1;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Telefon_Phonebook_TotalListNum)
      {
        endposition = Telefon_Phonebook_TotalListNum - 1;
        elements = Telefon_Phonebook_TotalListNum - startposition;
      }
      
    break;
    
    case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float)Telefon_Phonebook_Search_Pos(list_start) <= Telefon_Phonebook_TotalListNum)
        {
          startposition = Telefon_Phonebook_Search_Pos(list_start) - shift - 1;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Telefon_Phonebook_TotalListNum;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
    break;
  }
    
  if (IndexSize == 0)
  {
    Data_Telefon_Phonebook[4] = list_start & 0xFF;
    Data_Telefon_Phonebook[5] = elements & 0xFF;

    j_Telefon_Phonebook = 6;
  }
  else
  {
    Data_Telefon_Phonebook[5] = (list_start >> 8) & 0xFF;
    Data_Telefon_Phonebook[4] = list_start & 0xFF;
    Data_Telefon_Phonebook[7] = (elements >> 8) & 0xFF;
    Data_Telefon_Phonebook[6] = elements & 0xFF;

    j_Telefon_Phonebook = 8;
  }
  
  if (elements > 0)
  {
    switch(direction)
    {
      case 0:
        
        for (i = startposition ; i <= endposition && i >= 0 && j_max == 0; i++)
        {
          j_temp = j_Telefon_Phonebook; // aktuelle Länge zwischenspeichern
          
          //Pos
          switch(IndexSize)
          {
            case 0: Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].Pos;
                    break;
            case 1: Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].Pos & 0xFF;
                    Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].Pos >> 8) & 0xFF;
                    break;
          }

          // PbName
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3)
          {
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].PbName_Length; 
              stringsize = Telefon_Phonebook[i].PbName_Length;

              for (strctr = 0; strctr < stringsize; strctr++)
              {
                  Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].PbName[strctr];
              }
          }
          
          // Storage
          if (recordaddress == 0x0 || recordaddress == 0x1)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].Storage;
          
          // AnyVoiceTag + TelNumberQuantity
          if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].AnyVoiceTag & 0xF) *16 + (Telefon_Phonebook[i].TelNumberQuantity & 0xF);
          
          TelNumberQuantity = Telefon_Phonebook[i].TelNumberQuantity;
          
          // TelNumberQuantity = 1
          if (TelNumberQuantity >= 1)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber01_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber01_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber01_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber01_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++){
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber01[strctr];            
              }
            }
            
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag01 & 0xF) + (Telefon_Phonebook[i].Reserve01 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType01;
          }
          
          // TelNumberQuantity = 2
          if (TelNumberQuantity >= 2)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber02_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber02_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber02_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber02_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber02_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber02[strctr];            
              }
            }
            
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag02 & 0xF) + (Telefon_Phonebook[i].Reserve02 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType02;
          }
                
          // TelNumberQuantity = 3
          if (TelNumberQuantity >= 3)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber03_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber03_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber03_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber03_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++){
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber03[strctr];            
              }
            }
            
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag03 & 0xF) + (Telefon_Phonebook[i].Reserve03 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType03;
          }
          
          // TelNumberQuantity = 4
          if (TelNumberQuantity >= 4)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber04_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber04_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber04_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber04_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber04_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber04[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag04 & 0xF) + (Telefon_Phonebook[i].Reserve04 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType04;
          }
          
          // TelNumberQuantity = 5
          if (TelNumberQuantity >= 5)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber05_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber05_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber05_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber05_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber05_Length;
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber05[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag05 & 0xF) + (Telefon_Phonebook[i].Reserve05 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType05;
          }
          
          // TelNumberQuantity = 6
          if (TelNumberQuantity >= 6)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber06_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber06_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber06_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber06_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber06[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag06 & 0xF) + (Telefon_Phonebook[i].Reserve06 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType06;
          }
          
          // TelNumberQuantity = 7
          if (TelNumberQuantity >= 7)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber07_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber07_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber07_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber07_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber07[strctr];            
              }
            }
            
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag07 & 0xF) + (Telefon_Phonebook[i].Reserve07 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType07;
          }
          
          // TelNumberQuantity = 8
          if (TelNumberQuantity >= 8)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber08_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber08_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber08_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber08_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber08[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag08 & 0xF) + (Telefon_Phonebook[i].Reserve08 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType08;
          }
          
          // TelNumberQuantity = 9
          if (TelNumberQuantity >= 9)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber09_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber09_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber09_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber09_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber09[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag09 & 0xF) + (Telefon_Phonebook[i].Reserve09 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType09;
          }
          
          // TelNumberQuantity = 10
          if (TelNumberQuantity >= 10)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber10_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber10_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber10_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber10_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber10_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber10[strctr];            
              }
            }
            
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag10 & 0xF) + (Telefon_Phonebook[i].Reserve10 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType10;
          }

          // AdressIndication
          if (recordaddress == 0x0 || recordaddress == 0x1)
            Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].AdressIndication;
          
          if (j_Telefon_Phonebook > 255) // wenn Länge > 255 rücksetzen, da sonst Überlauf
          {
            j_max = 1;
            j_Telefon_Phonebook = j_temp;
            elements = i-startposition; // Elemente anpassen
              
            if (IndexSize == 0)
              Data_Telefon_Phonebook[5] = elements & 0xFF;
            if (IndexSize == 1)
            {
              Data_Telefon_Phonebook[7] = (elements >> 8) & 0xFF;
              Data_Telefon_Phonebook[6] = elements & 0xFF;
            }
          }
        }
        
      break;
        
      case 1:

        if (startposition == Telefon_Phonebook_TotalListNum)
        {
          startposition--;
          endposition--; 
        }
                  
        for (i = startposition ; i >= endposition && i >= 0 && j_max == 0; i--)
        {
          j_temp = j_Telefon_Phonebook; // aktuelle Länge zwischenspeichern

          switch(IndexSize)
          {
            case 0: Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].Pos;
                    break;
            case 1: Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].Pos &0xFF;
                    Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].Pos >> 8)&0xFF;
                    break;
          } 

          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3)
          {
            Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].PbName_Length;
            stringsize = Telefon_Phonebook[i].PbName_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].PbName[strctr];
            }
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 )
            Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].Storage;
          
          if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x3 || recordaddress == 0x4)
            Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].AnyVoiceTag & 0xF) *16 + (Telefon_Phonebook[i].TelNumberQuantity & 0xF);
          
          TelNumberQuantity = Telefon_Phonebook[i].TelNumberQuantity;
                
          // TelNumberQuantity = 1
          if (TelNumberQuantity >= 1)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber01_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber01_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber01_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber01_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber01[strctr];
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag01 & 0xF) + (Telefon_Phonebook[i].Reserve01 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType01;
          }
          
          // TelNumberQuantity = 2
          if (TelNumberQuantity >= 2)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber02_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber02_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber02_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber02_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber02_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber02[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag02 & 0xF) + (Telefon_Phonebook[i].Reserve02 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType02;
          }
          
          // TelNumberQuantity = 3
          if (TelNumberQuantity >= 3)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber03_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber03_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber03_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber03_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber03[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag03 & 0xF) + (Telefon_Phonebook[i].Reserve03 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType03;
          }
          
          // TelNumberQuantity = 4
          if (TelNumberQuantity >= 4)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber04_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber04_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber04_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber04_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber04_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber04[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag04 & 0xF) + (Telefon_Phonebook[i].Reserve04 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType04;
          
          }
          
          // TelNumberQuantity = 5
          if (TelNumberQuantity >= 5)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber05_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber05_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber05_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber05_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber05_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber05[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag05 & 0xF) + (Telefon_Phonebook[i].Reserve05 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType05;
          }
          
          // TelNumberQuantity = 6
          if (TelNumberQuantity >= 6)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber06_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber06_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber06_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber06_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber06[strctr];            
              }
            }
            
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag06 & 0xF) + (Telefon_Phonebook[i].Reserve06 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType06;
          }
          
          // TelNumberQuantity = 7
          if (TelNumberQuantity >= 7)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber07_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber07_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber07_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber07_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber07[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag07 & 0xF) + (Telefon_Phonebook[i].Reserve07 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType07;
          }
          
          // TelNumberQuantity = 8
          if (TelNumberQuantity >= 8)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber08_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber08_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber08_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber08_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber08[strctr];            
              }
            }
          
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag08 & 0xF) + (Telefon_Phonebook[i].Reserve08 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType08;
          }
          
          // TelNumberQuantity = 9
          if (TelNumberQuantity >= 9)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber01_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber09_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber09_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber09_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber09_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber09[strctr];            
              }
            }
            
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag09 & 0xF) + (Telefon_Phonebook[i].Reserve09 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType09;
          }
          
          // TelNumberQuantity = 10
          if (TelNumberQuantity >= 10)
          {
            //TelNumber
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x4)
            {
              if (Telefon_Phonebook[i].TelNumber10_Length < 128)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber10_Length;
              }
              else
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = 128 + (Telefon_Phonebook[i].TelNumber10_Length >> 8) & 0x7F;
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber10_Length & 0xFF;
              }

              stringsize = Telefon_Phonebook[i].TelNumber10_Length;
              
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].TelNumber10[strctr];            
              }
            }
            
            // VoiceTag + Reserve
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = (Telefon_Phonebook[i].VoiceTag10 & 0xF) + (Telefon_Phonebook[i].Reserve10 & 0xF);
            
            // NumberType
            if (recordaddress == 0x0 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x4)
              Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].NumberType10;
          }
                
          if (recordaddress == 0x0 || recordaddress == 0x1)
            Data_Telefon_Phonebook[j_Telefon_Phonebook++] = Telefon_Phonebook[i].AdressIndication;
                
          if (j_Telefon_Phonebook > 255) // wenn Länge > 255 rücksetzen, da sonst Überlauf
          {
            j_max = 1;
            j_Telefon_Phonebook = j_temp;
            elements = i-startposition;  // Elemente anpassen
            
            if (IndexSize == 0)
              Data_Telefon_Phonebook[5] = elements & 0xFF;
            if (IndexSize == 1)
            {
              Data_Telefon_Phonebook[7] = (elements >> 8) & 0xFF;
              Data_Telefon_Phonebook[6] = elements & 0xFF;
            }
          }
        }
      break;
    }
  }
  settimer (Delay_Telefon_Phonebook, @Env_Telefon_Phonebook_ListDelay);
}

Telefon_Phonebook_Changed (byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
    data[1] = list_start;
    data[2] = elements;
    length = 3;
  }
  else if (IndexSize == 1)
  {
    data[1] = list_start & 0xFF;
    data[2] = (list_start >> 8) & 0xFF;
    data[3] = elements & 0xFF;
    data[4] = (elements >> 8) & 0xFF;
      
    length = 5;
  }
  SendRequestByteSequence(LSGID_Telefon, 0x34, Changed_REQ, length, data);
}

dword Telefon_Phonebook_Search_Pos (dword position)
{    
  int i;
  
  for (i = 0; i<Telefon_Phonebook_TotalListNum; i++)
  {
    if (position == Telefon_Phonebook[i].Pos)
    {
      return i + 1;
    } 
  }
  return 0;
}

on timer Delay_Telefon_Phonebook
{
  sendRequestByteSequence(LSGID_Telefon, 0x34, Data_REQ, j_Telefon_Phonebook, Data_Telefon_Phonebook);
}


// Telefon - 0x35 PbSpeller

Telefon_PbSpeller (byte opcode, byte data[])
{
  byte Result;
  int  MatchingEntries;
  int  POS_Guete_horizontal;
  byte send_data[5];

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // PbSpeller Result senden
    Result               = @M_FSG_40_0_0_53_Result_1;
    MatchingEntries      = @M_FSG_40_0_0_53_Result_2;
    POS_Guete_horizontal = @M_FSG_40_0_0_53_Result_3;
    
    send_data[0] =  Result;
    send_data[1] =  MatchingEntries            & 0x00FF;
    send_data[2] = (MatchingEntries      >> 8) & 0x00FF;
    send_data[3] =  POS_Guete_horizontal       & 0x00FF;
    send_data[4] = (POS_Guete_horizontal >> 8) & 0x00FF;
    
    SendRequestByteSequence (LSGID_Telefon, 0x35, Result_REQ, 5, send_data);
  }
}


// Telefon - 0x36 GetNextListPos

Telefon_GetNextListPos(byte opcode, byte data[])
{
  long currentPos;
  long Offset;
  float fOffset;
  long nextPos;
  byte ListType;
  byte send_data_GNLP_Result[7];
  
  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // Start Result auswerten
    currentPos = data[0] + data[1]*256;
    Offset = data[2] + data[3]*256;
    ListType = data[4];
    
    if (Offset > 0x0000 && Offset <= 0x7FFF)
      fOffset = Offset;
    if (Offset > 0x7FFF && Offset <= 0xFFFF)
      fOffset = Offset - 0xFFFF - 1;

   // writelineex(4,0,"GetNextListPos /// currentPos: %d / Offset: %x / fOffset: %f / ListType: %d",currentPos,Offset,fOffset,ListType);
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // GetNextListPos Result schicken
    
    // Result = successful
    send_data_GNLP_Result[0] = 0;
    
    // currentPos
    send_data_GNLP_Result[1] = currentPos & 0x00FF;
    send_data_GNLP_Result[2] = currentPos>>8 & 0x00FF;
    
    // nextPos
    switch (ListType)
    {
      case 0x00: // Phonebook
        
        if (currentPos + fOffset > Telefon_Phonebook_TotalListNum)
          nextPos = Telefon_Phonebook_TotalListNum;
        if (currentPos + fOffset < 0)
          nextPos = 0;
        if ((currentPos + fOffset <= Telefon_Phonebook_TotalListNum) && (currentPos + fOffset >= 0))
          nextPos = currentPos + fOffset;
        
      break;
        
      case 0x01: // CombinedNumbers
        
        if (currentPos + fOffset > Telefon_CombinedNumbers_TotalListNum)
          nextPos = Telefon_CombinedNumbers_TotalListNum;
        if (currentPos + fOffset < 0)
          nextPos = 0;
        if ((currentPos + fOffset <= Telefon_CombinedNumbers_TotalListNum) && (currentPos + fOffset >= 0))
          nextPos = currentPos + fOffset;
        
      break;
        
      case 0x02: // FavoriteList
        
        if (currentPos + fOffset > Telefon_FavoriteList_TotalListNum)
          nextPos = Telefon_FavoriteList_TotalListNum;
        if (currentPos + fOffset < 0)
          nextPos = 0;
        if ((currentPos + fOffset <= Telefon_FavoriteList_TotalListNum) && (currentPos + fOffset >= 0))
          nextPos = currentPos + fOffset;
        
      break;
    }

    send_data_GNLP_Result[3] = nextPos & 0x00FF;
    send_data_GNLP_Result[4] = nextPos>>8 & 0x00FF;
    send_data_GNLP_Result[5] = nextPos & 0x00FF;
    send_data_GNLP_Result[6] = nextPos>>8 & 0x00FF;
    
    SendRequestByteSequence(LSGID_Telefon, 0x36, Result_REQ, 7, send_data_GNLP_Result);
  }
}


// Telefon - 0x3C FavoriteList

on envVar Env_Telefon_FavoriteList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Telefon_FavoriteList_Path, gTelefon_FavoriteList_Path);
    Telefon_FavoriteList_LoadArray();
  }
}

on envVar Env_Telefon_FavoriteList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Telefon_FavoriteList_Path, gTelefon_FavoriteList_Path);
    Telefon_FavoriteList_LoadArray();
    Telefon_FavoriteList_Changed(0x8,0x0, 0x0000, 0xFFFF);
  }
} 

Telefon_FavoriteList_LoadArray()
{ 
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
  //char temp2[25];
	char temp3[25];
  //char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
    //putValue(A_FSG_40_0_0_49_fileSelector,gTelefon_FavoriteList_Path);
    //putValue(A_FSG_40_0_0_49_loadArray_Btn, TRUE);
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Telefon_FavoriteList[i].Param1 = 0;
		for (j=0; j<100; j++)
	   Telefon_FavoriteList[i].Param2[j] = 0;
		Telefon_FavoriteList[i].Param2_Length = 0;
		Telefon_FavoriteList[i].Param3 = 0;
    for (j=0; j<41; j++)
     Telefon_FavoriteList[i].Param4[j] = 0;
		Telefon_FavoriteList[i].Param4_Length = 0;
    }

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gTelefon_FavoriteList_Path); i++)
  {
    if (gTelefon_FavoriteList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gTelefon_FavoriteList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gTelefon_FavoriteList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

    //writelineEx(4, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);
   // writelineEx(4, 0,"Num_of_csv_byte '%d'", Num_of_csv_byte);
    
		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "FavoriteListTel"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in FavoriteListTel) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{     //writelineex(4,0,"LF / CR detected");
					if (current_CSV_line > 0 && current_CSV_line < 65535) //ignore first line in *.csv file
					{
            
						Telefon_FavoriteList[current_CSV_line-1].Param1 = atol(temp1); //Pos
            //CombinedNumbers[current_CSV_line-1].Param2 = atol(temp2); //Name
						Telefon_FavoriteList[current_CSV_line-1].Param3 = atol(temp3); //NumberType
            //FavoriteListTel[current_CSV_line-1].Param4= atol(temp4); //TelNumber

            
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
              //temp2[i]=0;
							temp3[i]=0;
							//temp4[i]=0;

						}
					}
					current_CSV_line++; //next line in *.csv file
          
          //writelineEx(4, 0, "current_CSV_line %d", current_CSV_line);
          
          element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 65535)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
                  temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}          
							break;
						case 2: //PbName
								if (paramPos < 99)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Telefon_FavoriteList_ListFormat == 1) )
                  {
                    Telefon_FavoriteList[current_CSV_line-1].Param2[paramPos++] = buffer_byte[filePos++];
                    Telefon_FavoriteList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Telefon_FavoriteList_ListFormat == 0) )
                  {
                    Telefon_FavoriteList[current_CSV_line-1].Param2[paramPos++] = 0xC2;
                    Telefon_FavoriteList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Telefon_FavoriteList_ListFormat == 0) )
                  {
                    Telefon_FavoriteList[current_CSV_line-1].Param2[paramPos++] = 0xC3;
                    Telefon_FavoriteList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Telefon_FavoriteList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
									Telefon_FavoriteList[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //NumberType
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
            case 4: //TelNum
								if (paramPos < 40)
								{
									Telefon_FavoriteList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									Telefon_FavoriteList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
							break;
                
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
        //writelineEx(4, 0,"element: %d", element);
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
      writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  Telefon_FavoriteList_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Telefon_FavoriteList(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements;
 
  if ((opcode == 1) && (Telefon_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;

    if (IndexSize == 1)
    {
      list_start = data[2] +data[3]*256;
      elements = data[4] + data[5]*256;
    }
    else
    {
      list_start = data[2];
      elements = data[3];
    }
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////
          
    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_40_0_0_60_1 = ASG_ID;  // Set to panel value
    else
      ASG_ID = @A_FSG_40_0_0_60_1; // Set from panel value
      
    if (@env_AutoGetArray_TAID == 0)  // TAID
      @A_FSG_40_0_0_60_2 = TAID;
    else
      TAID = @A_FSG_40_0_0_60_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
      @A_FSG_40_0_0_60_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_40_0_0_60_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
      @A_FSG_40_0_0_60_Shift = (mode>>0);
    else
      mode = ((@A_FSG_40_0_0_60_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
      @A_FSG_40_0_0_60_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_40_0_0_60_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start
      @A_FSG_40_0_0_60_Start = list_start;
    else
      list_start = @A_FSG_40_0_0_60_Start;
                    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
    {
      Telefon_FavoriteList_Status (ASG_ID, TAID, mode, recordaddress,list_start, elements);
    }
  }
}

dword Telefon_FavoriteList_Search_Pos (dword position)
{
  dword i;
  
  for (i = 0; i < Telefon_FavoriteList_TotalListNum; i++)
  {
    if (position == Telefon_FavoriteList[i].param1)
    { 
      return i;  // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}

Telefon_FavoriteList_Status (byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{   
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition, elements ;
  byte sequenceNumber = 0;
  int i, k , strctr; 
  int stringsize;   

  elements = received_elements;

  Data_Telefon_FavoriteList[0] =  ASG_ID*16 + (TAID & 0xF);
  Data_Telefon_FavoriteList[1] = (Telefon_FavoriteList_TotalListNum & 0xFF);
  Data_Telefon_FavoriteList[2] = (mode|0x4)*16 + (recordaddress & 0xF);
  IndexSize  = (mode>>3) & 0x1;
  direction  = (mode>>1) & 0x1;
  shift      =  mode & 0x1;

  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift; 
        endposition = startposition + elements - 1; 
      }
    
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float)Telefon_FavoriteList_Search_Pos(list_start) != 0)
        {
          startposition = Telefon_FavoriteList_Search_Pos(list_start) + shift;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Telefon_FavoriteList_TotalListNum)
      {
        endposition = Telefon_FavoriteList_TotalListNum -1;
        elements = Telefon_FavoriteList_TotalListNum - startposition;
      }
      
    break;
    
    case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float)Telefon_FavoriteList_Search_Pos(list_start) != 0)
        {
          startposition = Telefon_FavoriteList_Search_Pos(list_start) - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift + 1;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Telefon_FavoriteList_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
    break;
  }
    
  if (IndexSize == 0)
  {
    Data_Telefon_FavoriteList[3] = list_start & 0xFF;
    Data_Telefon_FavoriteList[4] = elements & 0xFF;

    j_Telefon_FavoriteList = 5;
  }
  else
  {
    Data_Telefon_FavoriteList[4] = (list_start >> 8) & 0xFF;
    Data_Telefon_FavoriteList[3] = list_start & 0xFF;
    Data_Telefon_FavoriteList[6] = (elements >> 8) & 0xFF;
    Data_Telefon_FavoriteList[5] = elements & 0xFF;

    j_Telefon_FavoriteList = 7;
  }

  switch(direction)
  {
    case 0:
      
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        switch(IndexSize) // Pos
        {
          case 0: Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param1;
                  break;
          case 1: Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param1 &0xFF;
                  Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = (Telefon_FavoriteList[i].param1 >> 8)&0xFF;
                  break;
        }

        if (recordaddress == 0x0 || recordaddress == 0x1) // Name
        {
          Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param2_Length;
          stringsize = Telefon_FavoriteList[i].param2_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param2[strctr];            
          }
        }

        if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x2) // NumberType
          Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = (Telefon_FavoriteList[i].param3 & 0xF);
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // TelNumber
        {
          Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param4_Length; 
          stringsize = Telefon_FavoriteList[i].param4_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param4[strctr];            
          }
        }
      }
     
    break;
      
    case 1:
            
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        switch(IndexSize) // Pos
        {
          case 0: Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param1;
                  break;
          case 1: Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param1 &0xFF;
                  Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = (Telefon_FavoriteList[i].param1 >> 8)&0xFF;
                  break;
        }
                    
        if (recordaddress == 0x0 || recordaddress == 0x1) // Name
        {
          Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param2_Length; 
          stringsize = Telefon_FavoriteList[i].param2_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param2[strctr];            
          }
        }

        if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x2) // NumberType
          Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = (Telefon_FavoriteList[i].param3 & 0xF);
           
        if (recordaddress == 0x0 || recordaddress == 0x2) // TelNumber
        {
          Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param4_Length; 
          stringsize = Telefon_FavoriteList[i].param4_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Telefon_FavoriteList[j_Telefon_FavoriteList++] = Telefon_FavoriteList[i].param4[strctr];            
          }
        }
      }
    break;
  }
  settimer (Delay_Telefon_FavoriteList, @Env_Telefon_FavoriteList_ListDelay);
}

Telefon_FavoriteList_Changed (byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
    data[1] = list_start;
    data[2] = elements;
    length = 3;
  }
  else if (IndexSize == 1)
  {
    data[1] = list_start & 0xFF;
    data[2] = (list_start >> 8) & 0xFF;
    data[3] = elements & 0xFF;
    data[4] = (elements >> 8) & 0xFF;
    
    length = 5;
  }

  SendRequestByteSequence(LSGID_Telefon, 0x3C, Changed_REQ, length, data);
}

on timer Delay_Telefon_FavoriteList
{
  sendRequestByteSequence(LSGID_Telefon, 0x3C, Data_REQ, j_Telefon_FavoriteList, Data_Telefon_FavoriteList);
}


// Telefon - 0x3F CallFunctions

Telefon_CallFunctions (byte opcode, byte data[])
{
  byte CallFunction;
  byte CallFunction_Result;
  byte send_data[2];

  if ((opcode == 2) && (Telefon_Source == 1)) // ASG StartResult
  {
    // CallFunction in Processing uebernehmen
    CallFunction = data[0];
    
    @M_FSG_40_0_0_63_Processing_1 = CallFunction;
  }
  
  if ((opcode == 3) && (Telefon_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // CallFunction in Result uebernehmen
    CallFunction = data[0];
    
    @M_FSG_40_0_0_63_Result_1 = CallFunction;
    
    // CallFunction_Result aus Panel uebernehmen
    CallFunction_Result = @M_FSG_40_0_0_63_Result_2;
    
    // Result erstellen
    send_data[0] = CallFunction;
    send_data[1] = CallFunction_Result;

    sendRequestByteSequence(LSGID_Telefon, 0x3F, Result_REQ, 2, send_data);
  }
}


//////// Uhrzeit Mapping ////////

on message Diagnose_01
{
  if (@P_FSG_40_0_0_24_UseDiagValues == 1)
  {
    @P_FSG_40_0_0_24_1 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_2 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_3 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_4 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_5 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_6 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_7 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
  }
  
  if (@P_FSG_40_0_0_58_UseDiagValues == 1)
  {
    @P_FSG_40_0_0_58_1 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
  }
}


//////// Mapping alter Variablen ////////

on envVar env_LoadBTN_CN
{ @Env_Telefon_CombinedNumbers_LoadBTN = @this; }
on envVar env_LoadBTN_CN_Full
{ @Env_Telefon_CombinedNumbers_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Tel_CN
{ @Env_Telefon_CombinedNumbers_ListDelay = @this; }
on envVar envCombinedNumbersPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Telefon_CombinedNumbers_Path, temp); }

on envVar env_LoadBTN_PB
{ @Env_Telefon_Phonebook_LoadBTN = @this; }
on envVar env_LoadBTN_PB_Full
{ @Env_Telefon_Phonebook_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Tel_PB
{ @Env_Telefon_Phonebook_ListDelay = @this; }
on envVar envPhonebookPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Telefon_Phonebook_Path, temp); }

on envVar env_LoadBTN_FLT
{ @Env_Telefon_FavoriteList_LoadBTN = @this; }
on envVar env_LoadBTN_FLT_Full
{ @Env_Telefon_FavoriteList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Tel_FL
{ @Env_Telefon_FavoriteList_ListDelay = @this; }
on envVar envFavoriteListTelPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Telefon_FavoriteList_Path, temp); }









/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////// Telefon2 ///////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

on message BAP_Telefon2_ASG_01
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  Telefon2_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG41_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon2_app_data_ASG01[log_channel][i] = 0;

      // BAP Header auswerten
      Telefon2_received_function_ASG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Telefon2_received_function_ASG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Telefon2_received_function_ASG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Telefon2_app_data_ASG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon2_received_function_ASG01[log_channel][2]);
      
      // an checkfunction übergeben
      if (Telefon2_received_function_ASG01[log_channel][2] == 0x33) { Telefon2_CallPicture_Log_Channel = log_channel; } // CallPicture
      checkFunction (Telefon2_received_function_ASG01[log_channel][0], Telefon2_received_function_ASG01[log_channel][1], Telefon2_received_function_ASG01[log_channel][2], Telefon2_app_data_ASG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon2_app_data_ASG01[log_channel][i] = 0;        

      // BAP Header auswerten
      Telefon2_received_function_ASG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Telefon2_received_function_ASG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Telefon2_received_function_ASG01[log_channel][2] = (data[3] & 0x3F); // FctID
      Telefon2_data_length_ASG01[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Telefon2_app_data_ASG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Telefon2_data_length_ASG01[log_channel] = Telefon2_data_length_ASG01[log_channel] - 4;
      Telefon2_currentPosASG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Telefon2_data_length_ASG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon2_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (Telefon2_received_function_ASG01[log_channel][2] == 0x33) { Telefon2_CallPicture_Log_Channel = log_channel; } // CallPicture
        checkFunction (Telefon2_received_function_ASG01[log_channel][0], Telefon2_received_function_ASG01[log_channel][1], Telefon2_received_function_ASG01[log_channel][2], Telefon2_app_data_ASG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Telefon2_sequenceNumberASG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Telefon2_data_length_ASG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Telefon2_app_data_ASG01[log_channel][Telefon2_currentPosASG01[log_channel]] = data[i+1];
           Telefon2_currentPosASG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Telefon2_data_length_ASG01[log_channel] = Telefon2_data_length_ASG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Telefon2_data_length_ASG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Telefon2_data_length_ASG01[log_channel]; i++)
        {
           Telefon2_app_data_ASG01[log_channel][Telefon2_currentPosASG01[log_channel]] = data[i+1];
           Telefon2_currentPosASG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon2_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (Telefon2_received_function_ASG01[log_channel][2] == 0x33) { Telefon2_CallPicture_Log_Channel = log_channel; } // CallPicture
        checkFunction (Telefon2_received_function_ASG01[log_channel][0], Telefon2_received_function_ASG01[log_channel][1], Telefon2_received_function_ASG01[log_channel][2], Telefon2_app_data_ASG01[log_channel]);
      }
    }
  }
}

on message BAP_Telefon2_ASG_02
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  Telefon2_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG40_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon2_app_data_ASG02[log_channel][i] = 0;

      // BAP Header auswerten
      Telefon2_received_function_ASG02[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Telefon2_received_function_ASG02[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Telefon2_received_function_ASG02[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Telefon2_app_data_ASG02[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon2_received_function_ASG02[log_channel][2]);
      
      // an checkfunction übergeben
      if (Telefon2_received_function_ASG02[log_channel][2] == 0x33) { Telefon2_CallPicture_Log_Channel = log_channel; } // CallPicture
      checkFunction (Telefon2_received_function_ASG02[log_channel][0], Telefon2_received_function_ASG02[log_channel][1], Telefon2_received_function_ASG02[log_channel][2], Telefon2_app_data_ASG02[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon2_app_data_ASG02[log_channel][i] = 0;        

      // BAP Header auswerten
      Telefon2_received_function_ASG02[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Telefon2_received_function_ASG02[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Telefon2_received_function_ASG02[log_channel][2] = (data[3] & 0x3F); // FctID
      Telefon2_data_length_ASG02[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Telefon2_app_data_ASG02[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Telefon2_data_length_ASG02[log_channel] = Telefon2_data_length_ASG02[log_channel] - 4;
      Telefon2_currentPosASG02[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Telefon2_data_length_ASG02[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon2_received_function_ASG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Telefon2_received_function_ASG02[log_channel][2] == 0x33) { Telefon2_CallPicture_Log_Channel = log_channel; } // CallPicture
        checkFunction (Telefon2_received_function_ASG02[log_channel][0], Telefon2_received_function_ASG02[log_channel][1], Telefon2_received_function_ASG02[log_channel][2], Telefon2_app_data_ASG02[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Telefon2_sequenceNumberASG02[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Telefon2_data_length_ASG02[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Telefon2_app_data_ASG02[log_channel][Telefon2_currentPosASG02[log_channel]] = data[i+1];
           Telefon2_currentPosASG02[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Telefon2_data_length_ASG02[log_channel] = Telefon2_data_length_ASG02[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Telefon2_data_length_ASG02[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Telefon2_data_length_ASG02[log_channel]; i++)
        {
           Telefon2_app_data_ASG02[log_channel][Telefon2_currentPosASG02[log_channel]] = data[i+1];
           Telefon2_currentPosASG02[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon2_received_function_ASG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Telefon2_received_function_ASG02[log_channel][2] == 0x33) { Telefon2_CallPicture_Log_Channel = log_channel; } // CallPicture
        checkFunction (Telefon2_received_function_ASG02[log_channel][0], Telefon2_received_function_ASG02[log_channel][1], Telefon2_received_function_ASG02[log_channel][2], Telefon2_app_data_ASG02[log_channel]);
      }
    }
  }
}

on message BAP_Telefon2_FSG_01
{
  byte data[8];
  byte FSG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: FSG
  Telefon2_Source = 2;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG40_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon2_app_data_FSG01[log_channel][i] = 0;

      // BAP Header auswerten
      Telefon2_received_function_FSG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Telefon2_received_function_FSG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Telefon2_received_function_FSG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Telefon2_app_data_FSG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon2_received_function_FSG01[log_channel][2]);
      
      // an checkfunction übergeben
      checkFunction (Telefon2_received_function_FSG01[log_channel][0], Telefon2_received_function_FSG01[log_channel][1], Telefon2_received_function_FSG01[log_channel][2], Telefon2_app_data_FSG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Telefon2_app_data_FSG01[log_channel][i] = 0;        

      // BAP Header auswerten
      Telefon2_received_function_FSG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Telefon2_received_function_FSG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Telefon2_received_function_FSG01[log_channel][2] = (data[3] & 0x3F); // FctID
      Telefon2_data_length_FSG01[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Telefon2_app_data_FSG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Telefon2_data_length_FSG01[log_channel] = Telefon2_data_length_FSG01[log_channel] - 4;
      Telefon2_currentPosFSG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Telefon2_data_length_FSG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon2_received_function_FSG01[log_channel][2]);
        
        // an checkfunction übergeben
        checkFunction (Telefon2_received_function_FSG01[log_channel][0], Telefon2_received_function_FSG01[log_channel][1], Telefon2_received_function_FSG01[log_channel][2], Telefon2_app_data_FSG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Telefon2_sequenceNumberFSG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Telefon2_data_length_FSG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Telefon2_app_data_FSG01[log_channel][Telefon2_currentPosFSG01[log_channel]] = data[i+1];
           Telefon2_currentPosFSG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Telefon2_data_length_FSG01[log_channel] = Telefon2_data_length_FSG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Telefon2_data_length_FSG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Telefon2_data_length_FSG01[log_channel]; i++)
        {
           Telefon2_app_data_FSG01[log_channel][Telefon2_currentPosFSG01[log_channel]] = data[i+1];
           Telefon2_currentPosFSG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Telefon2_received_function_FSG01[log_channel][2]);
        
        // an checkfunction übergeben
        checkFunction (Telefon2_received_function_FSG01[log_channel][0], Telefon2_received_function_FSG01[log_channel][1], Telefon2_received_function_FSG01[log_channel][2], Telefon2_app_data_FSG01[log_channel]);
      }
    }
  }
}


// Telefon2 0x10 MobileServiceSupport

on envVar Env_Telefon2_MobileServiceSupport_On_41
{
  if (@this == 1)
    Telefon2_MobileServiceSupport_All_On_41();
}

on envVar Env_Telefon2_MobileServiceSupport_Off_41
{
  if (@this == 1)
    Telefon2_MobileServiceSupport_All_Off_41();
}

Telefon2_MobileServiceSupport_All_On_41()
{
  byte values[8];
  
  values[0]=0x78;
  values[1]=0x03;
  values[2]=0xFF;
  values[3]=0xF0;
  values[4]=0x00;
  values[5]=0x00;
  values[6]=0x00;
  values[7]=0x00;
  
  putvalue(P_FSG_41_0_0_16_1, values);
} 

Telefon2_MobileServiceSupport_All_Off_41()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x00;
  values[3]=0x00;
  values[4]=0x00;
  values[5]=0x00;
  values[6]=0x00;
  values[7]=0x00;
  
  putvalue(P_FSG_41_0_0_16_1, values);
}


on envVar Env_Telefon2_MobileServiceSupport_On_46
{
  if (@this == 1)
    Telefon2_MobileServiceSupport_All_On_46();
}

on envVar Env_Telefon2_MobileServiceSupport_Off_46
{
  if (@this == 1)
    Telefon2_MobileServiceSupport_All_Off_46();
}

Telefon2_MobileServiceSupport_All_On_46()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x7F;
  values[3]=0xFF;
  values[4]=0xFF;
  values[5]=0xFF;
  values[6]=0xF0;
  values[7]=0x00;
  
  putvalue(P_FSG_41_0_0_16_1, values);
} 

Telefon2_MobileServiceSupport_All_Off_46()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x00;
  values[3]=0x00;
  values[4]=0x00;
  values[5]=0x00;
  values[6]=0x00;
  values[7]=0x00;
  
  putvalue(P_FSG_41_0_0_16_1, values);
}


on envVar Env_Telefon2_MobileServiceSupport_On_47
{
  if (@this == 1)
    Telefon2_MobileServiceSupport_All_On_47();
}

on envVar Env_Telefon2_MobileServiceSupport_Off_47
{
  if (@this == 1)
    Telefon2_MobileServiceSupport_All_Off_47();
}

Telefon2_MobileServiceSupport_All_On_47()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x7F;
  values[3]=0xFF;
  values[4]=0xFF;
  values[5]=0xFF;
  values[6]=0xF0;
  values[7]=0x00;
  
  putvalue(P_FSG_41_0_0_16_1, values);
} 

Telefon2_MobileServiceSupport_All_Off_47()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x00;
  values[3]=0x00;
  values[4]=0x00;
  values[5]=0x00;
  values[6]=0x00;
  values[7]=0x00;
  
  putvalue(P_FSG_41_0_0_16_1, values);
}


// Telefon2 0x21 CallFunctions2

Telefon2_CallFunctions2 (byte opcode, byte data[])
{
  byte CallFunction;
  byte send_data[2];
    
  if ((opcode == 2) && (Telefon2_Source == 1)) // ASG StartResult
  {
    // StartResult auswerten
    CallFunction = data[0];
    @M_FSG_41_0_0_33_Processing_1 = CallFunction;
  }
  
  if ((opcode == 3) && (Telefon2_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // Result CallFunctions2 senden
    send_data[0] = CallFunction;
    send_data[1] = @M_FSG_41_0_0_33_Result_2;
    sendRequestByteSequence(LSGID_Telefon2, 0x21, Result_REQ, 2, send_data);
  }
}


// Telefon2 0x22 MobileServiceSupport3

on envVar Env_Telefon2_MobileServiceSupport3_On_46
{
  if (@this == 1)
    Telefon2_MobileServiceSupport3_All_On_46();
}

on envVar Env_Telefon2_MobileServiceSupport3_Off_46
{
  if (@this == 1)
    Telefon2_MobileServiceSupport3_All_Off_46();
}

Telefon2_MobileServiceSupport3_All_On_46()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x7F;
  values[3]=0xFF;
  values[4]=0xFF;
  values[5]=0xFF;
  values[6]=0xE0;
  values[7]=0x00;
  
  putvalue(P_FSG_41_0_0_34_1, values);
} 

Telefon2_MobileServiceSupport3_All_Off_46()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x00;
  values[3]=0x00;
  values[4]=0x00;
  values[5]=0x00;
  values[6]=0x00;
  values[7]=0x00;
  
  putvalue(P_FSG_41_0_0_34_1, values);
}

on envVar Env_Telefon2_MobileServiceSupport3_On_47
{
  if (@this == 1)
    Telefon2_MobileServiceSupport3_All_On_47();
}

on envVar Env_Telefon2_MobileServiceSupport3_Off_47
{
  if (@this == 1)
    Telefon2_MobileServiceSupport3_All_Off_47();
}

Telefon2_MobileServiceSupport3_All_On_47()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x7F;
  values[3]=0xFF;
  values[4]=0xFF;
  values[5]=0xFF;
  values[6]=0xE0;
  values[7]=0x00;
  
  putvalue(P_FSG_41_0_0_34_1, values);
} 

Telefon2_MobileServiceSupport3_All_Off_47()
{
  byte values[8];
  
  values[0]=0x00;
  values[1]=0x00;
  values[2]=0x00;
  values[3]=0x00;
  values[4]=0x00;
  values[5]=0x00;
  values[6]=0x00;
  values[7]=0x00;
  
  putvalue(P_FSG_41_0_0_34_1, values);
}


// Telefon2 0x2E CallFunctions3

Telefon2_CallFunctions3 (byte opcode, byte data[])
{
  byte CallFunction;
  byte send_data[2];
    
  if ((opcode == 2) && (Telefon2_Source == 1)) // ASG StartResult
  {
    // StartResult auswerten
    CallFunction = data[0];
    @M_FSG_41_0_0_46_Processing_1 = CallFunction;
  }
  
  if ((opcode == 3) && (Telefon2_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // Result schicken
    send_data[0] = CallFunction;
    send_data[1] = @M_FSG_41_0_0_46_Result_2;
    sendRequestByteSequence(LSGID_Telefon2, 0x2E, Result_REQ, 2, send_data);
  }
}       


// Telefon2 0x30 SelectPhone

Telefon2_SelectPhone (byte opcode, byte data[])
{
  byte PhoneID;
  byte send_data[2];
    
  if (opcode == 2 && Telefon2_Source == 1) //StartResult ASG
  {
    // Start Result auswerten
    PhoneID = data[0];
    
    // Parameter aus StartResult in Processing übernehmen
    @M_FSG_41_0_0_46_Processing_1 = PhoneID;
  }
  
  if (opcode == 3 && Telefon2_Source == 2 && @Env_BAP_Pro_Res == 1) // Processing FSG
  {
    // Result schicken
    send_data[0] = PhoneID;
    send_data[1] = @M_FSG_41_0_0_46_Result_2;
    sendRequestByteSequence(LSGID_Telefon2, 0x30, Result_REQ, 2, send_data);
  }
}




// Telefon2 0x33 CallPicture

on envVar Env_Telefon2_CallPicture_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Telefon2_CallPicture_Path,gTelefon2_CallPicture_Path);
    Telefon2_CallPicture_LoadArray();
  }
}

on envVar Env_Telefon2_CallPicture_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Telefon2_CallPicture_Path,gTelefon2_CallPicture_Path);
    Telefon2_CallPicture_LoadArray();
    Telefon2_CallPicture_Changed(0x0,0x0, 0x00, 0xFF);
  } 
}
Telefon2_CallPicture_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte  buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;
  byte offset = 0;
  byte high_nibble, low_nibble;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];
	char temp6[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
  offset = 0;
	for(i = 0; i < Telefon2_CallPicture_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Telefon2_CallPicture[i].Param1 = 0;
		Telefon2_CallPicture[i].Param2 = 0;
		Telefon2_CallPicture[i].Param3 = 0;
		Telefon2_CallPicture[i].Param4 = 0;
		for(j=0; j<17; j++)
			Telefon2_CallPicture[i].Param5[j] = 0;
		Telefon2_CallPicture[i].Param5_Length = 0;
		//A_FSG_41_0_0_51_Data_5_LenList[i] = 0;
		Telefon2_CallPicture[i].Param6 = 0;
		for(j=0; j<602; j++)
			Telefon2_CallPicture[i].Param7[j] = 0;
		Telefon2_CallPicture[i].Param7_Length = 0;
		//A_FSG_41_0_0_51_Data_7_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
  for (i = 0; i < strlen(gTelefon2_CallPicture_Path); i++)
  {
    if (gTelefon2_CallPicture_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gTelefon2_CallPicture_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gTelefon2_CallPicture_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

  if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "CallPicture"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
            // CG: Anpassung PSO
            offset=0;
            Telefon2_CallPicture[current_CSV_line-1].Param5_Length = Telefon2_CallPicture[current_CSV_line-1].Param5_Length/2;
            
						Telefon2_CallPicture[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Telefon2_CallPicture[current_CSV_line-1].Param2 = atol(temp2); //InstanceID
						Telefon2_CallPicture[current_CSV_line-1].Param3 = atol(temp3); //CallID
						Telefon2_CallPicture[current_CSV_line-1].Param4 = atol(temp4); //PictureType
						Telefon2_CallPicture[current_CSV_line-1].Param6 = atol(temp6); //TCP_Port
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp6[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //InstanceID
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //CallID
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //PictureType
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //IPv6_Address
								/*if(paramPos < 16)
								{
									Telefon2_CallPicture[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									Telefon2_CallPicture[current_CSV_line-1].Param5_Length = paramPos +1;
								}*/
              
                if(paramPos < 32) // CG: Verdopplung wegen anderer Auswertung
								{
                  Telefon2_CallPicture[current_CSV_line-1].Param5_Length = paramPos + 1;

                  if (Telefon2_CallPicture[current_CSV_line-1].Param5_Length != 0 && (paramPos+2)%2 == 0) // gerade Stellen
                  {
                    if (buffer_byte[filePos] >= 0x30 && buffer_byte[filePos] <= 0x39) // High Nibble 0...9
                      high_nibble = buffer_byte[filePos]-48;
                    
                    if (buffer_byte[filePos] >= 0x41 && buffer_byte[filePos] <= 0x46) // High Nibble Byte A...F
                      high_nibble = buffer_byte[filePos]-55;
                    
                    if (buffer_byte[filePos] >= 0x61 && buffer_byte[filePos] <= 0x66) // High Nibble Byte a...f
                      high_nibble = buffer_byte[filePos]-87;
                  }
                  
                  if (Telefon2_CallPicture[current_CSV_line-1].Param5_Length != 0 && (paramPos+2)%2 == 1) // ungerade Stellen
                  {
                    if (buffer_byte[filePos] >= 0x30 && buffer_byte[filePos] <= 0x39) // Low Nibble 0...9
                      low_nibble = buffer_byte[filePos]-48;
                    
                    if (buffer_byte[filePos] >= 0x41 && buffer_byte[filePos] <= 0x46) // Low Nibble Byte A...F
                      low_nibble = buffer_byte[filePos]-55;
                    
                    if (buffer_byte[filePos] >= 0x61 && buffer_byte[filePos] <= 0x66) // Low Nibble Byte a...f
                      low_nibble = buffer_byte[filePos]-87;
                    
                    offset++;
                    Telefon2_CallPicture[current_CSV_line-1].Param5[paramPos-offset] = high_nibble*16 + low_nibble;
                  }
                }
                paramPos++;
						break;
						case 6: //TCP_Port
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //URI
								if(paramPos < 600)
								{
									Telefon2_CallPicture[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
									Telefon2_CallPicture[current_CSV_line-1].Param7_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  Telefon2_CallPicture_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
}

Telefon2_CallPicture (byte opcode, byte data[])
{
  byte ASG_ID, TAID, TotalNumListElements;
  byte IndexSize, Shift, Direction, TransPos, mode, recordaddress;
  dword list_start, elements;

  if ((opcode == 1) && (Telefon2_Source == 1)) // ASG GetArray
  { 
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
   
    TotalNumListElements = Telefon2_CallPicture_TotalListNum;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
       
    list_start = data[2];
    elements = data[3];
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////
                   
    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_41_0_0_51_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_41_0_0_51_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_41_0_0_51_2 = TAID;
    else
      TAID = @A_FSG_41_0_0_51_2;
     
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_41_0_0_51_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_41_0_0_51_RecAdr;
     
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_41_0_0_51_Shift = (mode>>0);
    else
      mode = ((@A_FSG_41_0_0_51_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_41_0_0_51_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_41_0_0_51_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_41_0_0_51_Start = list_start;
    else
      list_start = @A_FSG_41_0_0_51_Start;
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      Telefon2_CallPicture_Status (ASG_ID, TAID, TotalNumListElements, mode, recordaddress,list_start, elements);
    }
  }
}

dword Telefon2_CallPicture_Search_Pos (dword position)
{
  dword i;
  
  for (i = 0; i<Telefon2_CallPicture_TotalListNum; i++)
  {
    if (position == Telefon2_CallPicture[i].param1)
    { 
      return i + 1;  // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}

Telefon2_CallPicture_Status (byte ASG_ID, byte TAID, byte TotalNumListElements, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction, trans_pos; 
  int  startposition, endposition, elements ;
  byte sequenceNumber = 0;
    
  int i, k , strctr; 
  int stringsize;   
  
  elements = received_elements;
  
  Data_Telefon2_CallPicture[0] = ASG_ID*16 + (TAID & 0xF);  
  Data_Telefon2_CallPicture[1] = TotalNumListElements;
  
  Data_Telefon2_CallPicture[2] = ((mode|0x4) & 0x5)*16 + (recordaddress & 0xF);
      
  IndexSize = (mode>>3) & 0x1;
  trans_pos = 1; // immer aktiv
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
    
  switch(direction)
  {
    case 0:
      
      if (list_start == 0)
      {
         startposition =  shift; 
         endposition = startposition + elements - 1; 
      }
      
      else if ((float)Telefon2_CallPicture_Search_Pos(list_start) != 0)
      {
         startposition = Telefon2_CallPicture_Search_Pos(list_start) + shift - 1;
         endposition = startposition+ elements - 1;
      }

      if (endposition >= Telefon2_CallPicture_TotalListNum)
      {
         elements = Telefon2_CallPicture_TotalListNum - startposition;
         endposition = Telefon2_CallPicture_TotalListNum - 1;
      }
      
      if (startposition >= Telefon2_CallPicture_TotalListNum)
      {
         elements=0;
      }

    break;
 
    case 1:
      
      if ((float)Telefon2_CallPicture_Search_Pos(list_start) != 0)
      {
         startposition = Telefon2_CallPicture_Search_Pos(list_start) - shift - 1; 
         endposition = startposition - elements + 1; 
      }
      
      else if ((list_start == 0) && (shift == 1))
      {
         startposition = Telefon2_CallPicture_TotalListNum -1;
         endposition = startposition - elements + 1;
      }
        
      if (endposition < 0)
      {
         elements = elements + endposition;
         endposition = 0;
      }

      if ((startposition >= Telefon2_CallPicture_TotalListNum) || ((list_start == 0) && (shift == 0)))
      {
         elements=0;
      }
              
      break;
  }
       
  Data_Telefon2_CallPicture[3] = list_start & 0xFF;
  Data_Telefon2_CallPicture[4] = elements & 0xFF;

  j_Telefon2_CallPicture = 5;
   
  switch(direction)
  {
    case 0:
      
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param1; // Pos
        
        if (recordaddress == 0x1 || recordaddress == 0x3)  //InstanceID
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param2;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3)  //CallID
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param3;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3)  //PictureType
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param4;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2) //IPv6_Address
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param5_Length;
          stringsize = Telefon2_CallPicture[i].param5_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param5[strctr];
          }
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2)  //TCP_Port
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] =  Telefon2_CallPicture[i].param6 & 0xFF;
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = (Telefon2_CallPicture[i].param6 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3) //URI
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] =  Telefon2_CallPicture[i].param7_Length+1 & 0xFF;
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = (Telefon2_CallPicture[i].param7_Length >> 8) & 0xFF;
          stringsize = Telefon2_CallPicture[i].param7_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param7[strctr];
          }
        }
      }
      
    break;
          
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param1; // Pos
        
        if (recordaddress == 0x1 || recordaddress == 0x3)  //InstanceID
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param2;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3)  //CallID
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param3;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3)  //PictureType
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param4;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2) //IPv6_Address
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param5_Length;
          stringsize = Telefon2_CallPicture[i].param5_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param5[strctr];
          }
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2)  //TCP_Port
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] =  Telefon2_CallPicture[i].param6 & 0xFF;
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = (Telefon2_CallPicture[i].param6 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3) //URI
        {
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] =  Telefon2_CallPicture[i].param7_Length+1 & 0xFF;
          Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = (Telefon2_CallPicture[i].param7_Length >> 8) & 0xFF;
          stringsize = Telefon2_CallPicture[i].param7_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Telefon2_CallPicture[j_Telefon2_CallPicture++] = Telefon2_CallPicture[i].param7[strctr];
          }
        }
      }
    break;
  }
  settimer (Delay_Telefon2_CallPicture, @Env_Telefon2_CallPicture_ListDelay);
}

Telefon2_CallPicture_Changed (byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  SendRequestByteSequence (LSGID_Telefon2, 0x33, Changed_REQ, length, data);
}

on timer Delay_Telefon2_CallPicture
{
  sendRequestByteSequence (LSGID_Telefon2, 0x33, Data_REQ, j_Telefon2_CallPicture, Data_Telefon2_CallPicture);
}





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////// Audio ////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


on envVar Node_Index_FSG_49
{
  Node_Index_Audio = @this;
}

on message BAP_Audio_ASG_01
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  Audio_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG49_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Audio_app_data_ASG01[log_channel][i] = 0;

      // BAP Header auswerten
      Audio_received_function_ASG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Audio_received_function_ASG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Audio_received_function_ASG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Audio_app_data_ASG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Audio_received_function_ASG01[log_channel][2]);
      
      // an checkfunction übergeben
      if (Audio_received_function_ASG01[log_channel][2] == 0x32) { Audio_SiriusAlertList_Log_Channel = log_channel; } // SiriusAlertList
      checkFunction (Audio_received_function_ASG01[log_channel][0], Audio_received_function_ASG01[log_channel][1], Audio_received_function_ASG01[log_channel][2], Audio_app_data_ASG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Audio_app_data_ASG01[log_channel][i] = 0;        

      // BAP Header auswerten
      Audio_received_function_ASG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Audio_received_function_ASG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Audio_received_function_ASG01[log_channel][2] = (data[3] & 0x3F); // FctID
      Audio_data_length_ASG01[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Audio_app_data_ASG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Audio_data_length_ASG01[log_channel] = Audio_data_length_ASG01[log_channel] - 4;
      Audio_currentPosASG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Audio_data_length_ASG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Audio_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (Audio_received_function_ASG01[log_channel][2] == 0x32) { Audio_SiriusAlertList_Log_Channel = log_channel; } // SiriusAlertList
        checkFunction (Audio_received_function_ASG01[log_channel][0], Audio_received_function_ASG01[log_channel][1], Audio_received_function_ASG01[log_channel][2], Audio_app_data_ASG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Audio_sequenceNumberASG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Audio_data_length_ASG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Audio_app_data_ASG01[log_channel][Audio_currentPosASG01[log_channel]] = data[i+1];
           Audio_currentPosASG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Audio_data_length_ASG01[log_channel] = Audio_data_length_ASG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Audio_data_length_ASG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Audio_data_length_ASG01[log_channel]; i++)
        {
           Audio_app_data_ASG01[log_channel][Audio_currentPosASG01[log_channel]] = data[i+1];
           Audio_currentPosASG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Audio_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (Audio_received_function_ASG01[log_channel][2] == 0x32) { Audio_SiriusAlertList_Log_Channel = log_channel; } // SiriusAlertList
        checkFunction (Audio_received_function_ASG01[log_channel][0], Audio_received_function_ASG01[log_channel][1], Audio_received_function_ASG01[log_channel][2], Audio_app_data_ASG01[log_channel]);
      }
    }
  }
}

on message BAP_Audio_ASG_02
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  Audio_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG49_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Audio_app_data_ASG02[log_channel][i] = 0;

      // BAP Header auswerten
      Audio_received_function_ASG02[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Audio_received_function_ASG02[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Audio_received_function_ASG02[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Audio_app_data_ASG02[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Audio_received_function_ASG02[log_channel][2]);
      
      // an checkfunction übergeben
      if (Audio_received_function_ASG02[log_channel][2] == 0x17) { Audio_ReceptionList_Log_Channel = log_channel; } // ReceptionList
      if (Audio_received_function_ASG02[log_channel][2] == 0x20) { Audio_SourceList_Log_Channel = log_channel; } // SourceList
      if (Audio_received_function_ASG02[log_channel][2] == 0x21) { Audio_RadioTVPresetList_Log_Channel = log_channel; } // RadioTVPresetList
      if (Audio_received_function_ASG02[log_channel][2] == 0x24) { Audio_MediaBrowser_Log_Channel = log_channel; } // MediaBrowser
      if (Audio_received_function_ASG02[log_channel][2] == 0x38) { Audio_LastStationList_Log_Channel = log_channel; } // LastStationList
      if (Audio_received_function_ASG02[log_channel][2] == 0x3A) { Audio_Picture_Log_Channel = log_channel; } // Picture
      if (Audio_received_function_ASG02[log_channel][2] == 0x3B) { Audio_FavoriteList_Log_Channel = log_channel; } // FavoriteList
      checkFunction (Audio_received_function_ASG02[log_channel][0], Audio_received_function_ASG02[log_channel][1], Audio_received_function_ASG02[log_channel][2], Audio_app_data_ASG02[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Audio_app_data_ASG02[log_channel][i] = 0;        

      // BAP Header auswerten
      Audio_received_function_ASG02[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Audio_received_function_ASG02[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Audio_received_function_ASG02[log_channel][2] = (data[3] & 0x3F); // FctID
      Audio_data_length_ASG02[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Audio_app_data_ASG02[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Audio_data_length_ASG02[log_channel] = Audio_data_length_ASG02[log_channel] - 4;
      Audio_currentPosASG02[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Audio_data_length_ASG02[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Audio_received_function_ASG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Audio_received_function_ASG02[log_channel][2] == 0x17) { Audio_ReceptionList_Log_Channel = log_channel; } // ReceptionList
        if (Audio_received_function_ASG02[log_channel][2] == 0x20) { Audio_SourceList_Log_Channel = log_channel; } // SourceList
        if (Audio_received_function_ASG02[log_channel][2] == 0x21) { Audio_RadioTVPresetList_Log_Channel = log_channel; } // RadioTVPresetList
        if (Audio_received_function_ASG02[log_channel][2] == 0x24) { Audio_MediaBrowser_Log_Channel = log_channel; } // MediaBrowser
        if (Audio_received_function_ASG02[log_channel][2] == 0x38) { Audio_LastStationList_Log_Channel = log_channel; } // LastStationList
        if (Audio_received_function_ASG02[log_channel][2] == 0x3A) { Audio_Picture_Log_Channel = log_channel; } // Picture
        if (Audio_received_function_ASG02[log_channel][2] == 0x3B) { Audio_FavoriteList_Log_Channel = log_channel; } // FavoriteList
        checkFunction (Audio_received_function_ASG02[log_channel][0], Audio_received_function_ASG02[log_channel][1], Audio_received_function_ASG02[log_channel][2], Audio_app_data_ASG02[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Audio_sequenceNumberASG02[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Audio_data_length_ASG02[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Audio_app_data_ASG02[log_channel][Audio_currentPosASG02[log_channel]] = data[i+1];
           Audio_currentPosASG02[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Audio_data_length_ASG02[log_channel] = Audio_data_length_ASG02[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Audio_data_length_ASG02[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Audio_data_length_ASG02[log_channel]; i++)
        {
           Audio_app_data_ASG02[log_channel][Audio_currentPosASG02[log_channel]] = data[i+1];
           Audio_currentPosASG02[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Audio_received_function_ASG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Audio_received_function_ASG02[log_channel][2] == 0x17) { Audio_ReceptionList_Log_Channel = log_channel; } // ReceptionList
        if (Audio_received_function_ASG02[log_channel][2] == 0x20) { Audio_SourceList_Log_Channel = log_channel; } // SourceList
        if (Audio_received_function_ASG02[log_channel][2] == 0x21) { Audio_RadioTVPresetList_Log_Channel = log_channel; } // RadioTVPresetList
        if (Audio_received_function_ASG02[log_channel][2] == 0x24) { Audio_MediaBrowser_Log_Channel = log_channel; } // MediaBrowser
        if (Audio_received_function_ASG02[log_channel][2] == 0x38) { Audio_LastStationList_Log_Channel = log_channel; } // LastStationList
        if (Audio_received_function_ASG02[log_channel][2] == 0x3A) { Audio_Picture_Log_Channel = log_channel; } // Picture
        if (Audio_received_function_ASG02[log_channel][2] == 0x3B) { Audio_FavoriteList_Log_Channel = log_channel; } // FavoriteList
        checkFunction (Audio_received_function_ASG02[log_channel][0], Audio_received_function_ASG02[log_channel][1], Audio_received_function_ASG02[log_channel][2], Audio_app_data_ASG02[log_channel]);
      }
    }
  }
}

on message BAP_Audio_FSG_01
{
  byte data[8];
  byte FSG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: FSG
  Audio_Source = 2;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG49_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Audio_app_data_FSG01[log_channel][i] = 0;

      // BAP Header auswerten
      Audio_received_function_FSG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Audio_received_function_FSG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Audio_received_function_FSG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Audio_app_data_FSG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: %x", messageType,log_channel,Audio_received_function_FSG01[log_channel][2]);
      
      // an checkfunction übergeben
      checkFunction (Audio_received_function_FSG01[log_channel][0], Audio_received_function_FSG01[log_channel][1], Audio_received_function_FSG01[log_channel][2], Audio_app_data_FSG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Audio_app_data_FSG01[log_channel][i] = 0;        

      // BAP Header auswerten
      Audio_received_function_FSG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Audio_received_function_FSG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Audio_received_function_FSG01[log_channel][2] = (data[3] & 0x3F); // FctID
      Audio_data_length_FSG01[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Audio_app_data_FSG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Audio_data_length_FSG01[log_channel] = Audio_data_length_FSG01[log_channel] - 4;
      Audio_currentPosFSG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Audio_data_length_FSG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: %x", messageType,log_channel,Audio_received_function_FSG01[log_channel][1]);
        
        // an checkfunction übergeben
        checkFunction (Audio_received_function_FSG01[log_channel][0], Audio_received_function_FSG01[log_channel][1], Audio_received_function_FSG01[log_channel][2], Audio_app_data_FSG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Audio_sequenceNumberFSG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Audio_data_length_FSG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
            Audio_app_data_FSG01[log_channel][Audio_currentPosFSG01[log_channel]] = data[i+1];
            Audio_currentPosFSG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Audio_data_length_FSG01[log_channel] = Audio_data_length_FSG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Audio_data_length_FSG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Audio_data_length_FSG01[log_channel]; i++)
        {
            Audio_app_data_FSG01[log_channel][Audio_currentPosFSG01[log_channel]] = data[i+1];
            Audio_currentPosFSG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: %x", messageType,log_channel,Audio_received_function_FSG01[log_channel][1]);
        
        // an checkfunction übergeben
        checkFunction (Audio_received_function_FSG01[log_channel][0], Audio_received_function_FSG01[log_channel][1], Audio_received_function_FSG01[log_channel][2], Audio_app_data_FSG01[log_channel]);
      }
    }
  }
}

on message BAP_Audio_FSG_02
{
  byte data[8];
  byte FSG_TAID[8];
  int  i, length;
  byte messageType, log_channel;
  
  // Source: FSG
  Audio_Source = 2;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG49_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Audio_app_data_FSG02[log_channel][i] = 0;

      // BAP Header auswerten
      Audio_received_function_FSG02[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Audio_received_function_FSG02[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Audio_received_function_FSG02[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Audio_app_data_FSG02[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Audio_received_function_FSG02[log_channel][2]);
      
      // an checkfunction übergeben
      if (Audio_received_function_FSG02[log_channel][2] == 0x17) { Audio_ReceptionList_Log_Channel = log_channel; } // ReceptionList
      if (Audio_received_function_FSG02[log_channel][2] == 0x20) { Audio_SourceList_Log_Channel = log_channel; } // SourceList
      if (Audio_received_function_FSG02[log_channel][2] == 0x21) { Audio_RadioTVPresetList_Log_Channel = log_channel; } // RadioTVPresetList
      if (Audio_received_function_FSG02[log_channel][2] == 0x24) { Audio_MediaBrowser_Log_Channel = log_channel; } // MediaBrowser
      if (Audio_received_function_FSG02[log_channel][2] == 0x32) { Audio_SiriusAlertList_Log_Channel = log_channel; } // SiriusAlertList
      if (Audio_received_function_FSG02[log_channel][2] == 0x38) { Audio_LastStationList_Log_Channel = log_channel; } // LastStationList
      if (Audio_received_function_FSG02[log_channel][2] == 0x3B) { Audio_Picture_Log_Channel = log_channel; } // Picture
      if (Audio_received_function_FSG02[log_channel][2] == 0x3B) { Audio_FavoriteList_Log_Channel = log_channel; } // FavoriteList
      checkFunction (Audio_received_function_FSG02[log_channel][0], Audio_received_function_FSG02[log_channel][1], Audio_received_function_FSG02[log_channel][2], Audio_app_data_FSG02[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Audio_app_data_FSG02[log_channel][i] = 0;        

      // BAP Header auswerten
      Audio_received_function_FSG02[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Audio_received_function_FSG02[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Audio_received_function_FSG02[log_channel][2] = (data[3] & 0x3F); // FctID
      Audio_data_length_FSG02[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge

      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Audio_app_data_FSG02[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Audio_data_length_FSG02[log_channel] = Audio_data_length_FSG02[log_channel] - 4;
      Audio_currentPosFSG02[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Audio_data_length_FSG02[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Audio_received_function_FSG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Audio_received_function_FSG02[log_channel][2] == 0x17) { Audio_ReceptionList_Log_Channel = log_channel; } // ReceptionList
        if (Audio_received_function_FSG02[log_channel][2] == 0x20) { Audio_SourceList_Log_Channel = log_channel; } // SourceList
        if (Audio_received_function_FSG02[log_channel][2] == 0x21) { Audio_RadioTVPresetList_Log_Channel = log_channel; } // RadioTVPresetList
        if (Audio_received_function_FSG02[log_channel][2] == 0x24) { Audio_MediaBrowser_Log_Channel = log_channel; } // MediaBrowser
        if (Audio_received_function_FSG02[log_channel][2] == 0x32) { Audio_SiriusAlertList_Log_Channel = log_channel; } // SiriusAlertList
        if (Audio_received_function_FSG02[log_channel][2] == 0x38) { Audio_LastStationList_Log_Channel = log_channel; } // LastStationList
        if (Audio_received_function_FSG02[log_channel][2] == 0x3B) { Audio_Picture_Log_Channel = log_channel; } // Picture
        if (Audio_received_function_FSG02[log_channel][2] == 0x3B) { Audio_FavoriteList_Log_Channel = log_channel; } // FavoriteList
        checkFunction (Audio_received_function_FSG02[log_channel][0], Audio_received_function_FSG02[log_channel][1], Audio_received_function_FSG02[log_channel][2], Audio_app_data_FSG02[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Audio_sequenceNumberFSG02[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Audio_data_length_FSG02[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
            Audio_app_data_FSG02[log_channel][Audio_currentPosFSG02[log_channel]] = data[i+1];
            Audio_currentPosFSG02[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Audio_data_length_FSG02[log_channel] = Audio_data_length_FSG02[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Audio_data_length_FSG02[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Audio_data_length_FSG02[log_channel]; i++)
        {
            Audio_app_data_FSG02[log_channel][Audio_currentPosFSG02[log_channel]] = data[i+1];
            Audio_currentPosFSG02[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Audio_received_function_FSG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Audio_received_function_FSG02[log_channel][2] == 0x17) { Audio_ReceptionList_Log_Channel = log_channel; } // ReceptionList
        if (Audio_received_function_FSG02[log_channel][2] == 0x20) { Audio_SourceList_Log_Channel = log_channel; } // SourceList
        if (Audio_received_function_FSG02[log_channel][2] == 0x21) { Audio_RadioTVPresetList_Log_Channel = log_channel; } // RadioTVPresetList
        if (Audio_received_function_FSG02[log_channel][2] == 0x24) { Audio_MediaBrowser_Log_Channel = log_channel; } // MediaBrowser
        if (Audio_received_function_FSG02[log_channel][2] == 0x32) { Audio_SiriusAlertList_Log_Channel = log_channel; } // SiriusAlertList
        if (Audio_received_function_FSG02[log_channel][2] == 0x38) { Audio_LastStationList_Log_Channel = log_channel; } // LastStationList
        if (Audio_received_function_FSG02[log_channel][2] == 0x3B) { Audio_Picture_Log_Channel = log_channel; } // Picture
        if (Audio_received_function_FSG02[log_channel][2] == 0x3B) { Audio_FavoriteList_Log_Channel = log_channel; } // FavoriteList
        checkFunction (Audio_received_function_FSG02[log_channel][0], Audio_received_function_FSG02[log_channel][1], Audio_received_function_FSG02[log_channel][2], Audio_app_data_FSG02[log_channel]);
      }
    }
  }
}


// Audio 0x10 Active Source

Audio_ActiveSource(byte opcode, byte data[])
{
  byte Source_Type,  TypeOfNumber, number, List_State, List_Type; 
  dword SourceList_Reference;
  
  if ((opcode == 4) && (Audio_Source == 2)) // FSG Status
  {
    Source_Type = data[0];
    SourceList_Reference = data[1] + data[2] * 256;
    TypeOfNumber = (data[3] >> 4) & 0xF;
    Audio_ReceptionList_available = data[3] & 0x1;
    Audio_RadioTV_PresetList_available = (data[3]>>1) &0x1;
    Audio_MediaBrowser_available = (data[3]>>2) &0x1;
    Audio_SiriusAlertList_available = (data[3]>>3) &0x1;
    Audio_LastStationList_available = data[4] & 0x1;
    Audio_FavoriteList_available = (data[4]>>1) &0x1;
    List_State = (data[4] >> 4) & 0xF;
    number = data[5];  

    List_Type = getListType(Source_Type);
                        
    if (List_Type != 0)
    {
      Audio_ReceptionListType_Status(List_Type);
    }
                            
    switch (Source_Type)
    {
      case 0x00: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // no source
      case 0x01: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // FM
      case 0x02: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // AM
      case 0x03: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // DAB
      case 0x04: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // SDARS-XM
      case 0x05: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // SDARS-SIRIUS
        
      case 0x06: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // CD
      case 0x07: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // CD changer
      case 0x08: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // DVD
        
      case 0x09: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // TV
        
      case 0x0A: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // HDD
      case 0x0B: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // SD
        
      case 0x0C: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // TP-Memo
        
      case 0x0D: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // Aux-In Audio
      case 0x0E: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // Aux-In Video
      case 0x0F: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // portable device
      case 0x10: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // generic player
        
      case 0x11: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // AM-TI-Japan
        
      case 0x12: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // DVD changer
      case 0x13: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // USB
      case 0x14: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // Jukebox
      case 0x15: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // Bluetooth connection BT-stream
      case 0x16: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // Bluetooth connection RCP
        
      case 0x17: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // DVB-video-service
      case 0x18: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // DVB-audio-service
      case 0x19: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // AW-SW
      case 0x1A: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // AM-LW
        
      case 0x1B: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // WLAN - mass storage
      case 0x1C: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // WLAN - RCP
      case 0x1D: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // BluRay
      case 0x1E: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // BluRay changer
      case 0x1F: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // Flash
      case 0x20: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // Aux-In Video (TV)
      case 0x21: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // HDMI
      case 0x22: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // Online Mass Storage
        
      case 0x23: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // Online-Radio
      case 0x24: Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data); break; // CommonList
        
      case 0x25: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // MobileDevice (AppleLink)
      case 0x26: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // MobileDevice (MirrorLink)
      case 0x27: Audio_MediaBrowser_Changed(0x8, 0x0, 0x0000, 0xFFFF); break; // MobileDevice (GoogleLink)
    }
  }
}

Audio_ActiveSource_Status (dword SourceList_Reference, byte TypeOfNumber, byte ListAvailable, byte List_State, byte ListAvailable2, byte number)
{
  dword index;
  int i;
  byte data[6];

  index = Audio_SourceList_Search_Pos(SourceList_Reference-1);
  
  data[0] = Audio_SourceList[index].Param1;
  data[1] = Audio_SourceList[index].Param2 & 0xFF;
  data[2] = (Audio_SourceList[index].Param2 >> 8) & 0xFF;
  data[3] = TypeOfNumber*16 + ListAvailable;
  data[4] = List_State*16 + ListAvailable2;
  data[5] = number;

  sendRequestByteSequence(LSGID_Audio, 0x10, Data_REQ, 6, data);
}


// Audio 0x15 CurrentStationInfo

Audio_CurrentStationInfo_Status (char PrimaryInformation[], byte PI_Type, word PI_ID, char SecondaryInformation[], byte SI_Type, char TertiaryInformation[], byte TI_Type, char QuaternaryInformation[], byte QI_Type)
{
  byte PI_length, SI_length, TI_length, QI_length, data[BAP_BUFFERSIZE];
  byte StationInfoSwitches, StationProperties;
  int ChannelID;
  int i, j = 0;

  StationInfoSwitches = @P_FSG_49_0_0_21_10;
  StationProperties = @P_FSG_49_0_0_21_11;
  ChannelID = @P_FSG_49_0_0_21_12_range;
  
  PI_length = strlen(PrimaryInformation);
  SI_length = strlen(SecondaryInformation);
  TI_length = strlen(TertiaryInformation);
  QI_length = strlen(QuaternaryInformation);
  
  j = 0;
  data[j++] = PI_length; 

  for (i = 0; i < PI_length; i++)
  {
    data[j++] = PrimaryInformation[i];
  }
 
  data[j++] = PI_Type;
  data[j++] = PI_ID & 0xFF;
  data[j++] = (PI_ID >> 8) & 0xFF;
  data[j++] = SI_length;
   
  for (i = 0; i < SI_length; i++)
  {
    data[j++] = SecondaryInformation[i];
  }
  
  data[j++] = SI_Type;
  data[j++] = TI_length;

  for (i = 0; i < TI_length; i++)
  {
    data[j++] = TertiaryInformation[i];
  }
  
  data[j++] = TI_Type;
  data[j++] = QI_length;

  for (i = 0; i < QI_length; i++)
  {
    data[j++] = QuaternaryInformation[i];
  }

  data[j++] = QI_Type;            
  data[j++] = StationInfoSwitches;
  data[j++] = StationProperties;
  data[j++] = ChannelID;
  data[j++] = ChannelID>>8;

  sendRequestByteSequence(LSGID_Audio, 0x15, Data_REQ, j, data);
}


// Audio 0x16 CurrentStation_Handle

Audio_CurrentStation_Handle(byte opcode, byte data[])
{
  if ((opcode == 4) && (Audio_Source == 2)) // FSG Status
  {
    if (bool_dedicatedAudioControl == TRUE)
    {
      Audio_DedicatedAudioControl_Result(getvalue(M_FSG_49_0_0_24_Result_1));
      bool_dedicatedAudioControl = FALSE;        
    }
  }
}

Audio_CurrentStation_Handle_Status(dword FsgHandle, dword FsgHandle_absolutePosition,byte PresetList_Ref, byte PresetList_absolutePosition, dword DAB_EnsembleHandle, dword DAB_EnsembleHandle_absolutePosition)
{
  byte data[10];

  gFsgHandle= FsgHandle;
  gFsgHandle_absolutePosition = FsgHandle_absolutePosition;
  data[0] = FsgHandle & 0xFF;
  data[1] = (FsgHandle >> 8) & 0xFF;
  data[2] = FsgHandle_absolutePosition & 0xFF;
  data[3] = (FsgHandle_absolutePosition >> 8) & 0xFF;
  data[4] = PresetList_Ref;
  data[5] = PresetList_absolutePosition;
  data[6] = DAB_EnsembleHandle & 0xFF;
  data[7] = (DAB_EnsembleHandle >> 8) & 0xFF;
  data[8] = DAB_EnsembleHandle_absolutePosition & 0xFF;
  data[9] = (DAB_EnsembleHandle_absolutePosition >> 8) & 0xFF;

  sendRequestByteSequence(LSGID_Audio, 0x16, Data_REQ, 10, data);
}


Audio_CurrentStation_Handle2_Status(dword SiriusAlertList_FsgHandle, dword SiriusAlertList_FsgHandle_absolutePosition, byte LastStationList_FsgHandle, byte LastStationList_FsgHandle_absolutePosition)
{
  byte data[6];

  data[0] = SiriusAlertList_FsgHandle & 0xFF;
  data[1] = (SiriusAlertList_FsgHandle >> 8) & 0xFF;
  data[2] = SiriusAlertList_FsgHandle_absolutePosition & 0xFF;
  data[3] = (SiriusAlertList_FsgHandle_absolutePosition >> 8) & 0xFF;
  data[4] = LastStationList_FsgHandle;
  data[5] = LastStationList_FsgHandle_absolutePosition;

  sendRequestByteSequence(LSGID_Audio, 0x33, Data_REQ, 6, data);
}

Audio_CurrentStation_Handle3_Status(byte FavoriteList_FsgHandle, byte FavoriteList_FsgHandle_absolutePosition, byte Extension1, byte Extension2, byte Extension3, byte Extension4)
{
  byte data[6];

  data[0] = FavoriteList_FsgHandle;
  data[1] = FavoriteList_FsgHandle_absolutePosition;
  data[2] = Extension1;
  data[3] = Extension2;
  data[4] = Extension3;
  data[5] = Extension4;

  sendRequestByteSequence(LSGID_Audio, 0x37, Data_REQ, 6, data);
}


// Audio 0x17 ReceptionList

Audio_ReceptionList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	    for (i = 0; i < Max_Array_Size; i++)
	    { /* Initialisierung von den Ziel-Strukturen */
		    Audio_ReceptionList[i].Param1 = 0;
		    Audio_ReceptionList[i].Param2 = 0;
		    Audio_ReceptionList[i].Param3 = 0;
		    Audio_ReceptionList[i].Param4 = 0;
		    Audio_ReceptionList[i].Param5 = 0;
		    Audio_ReceptionList[i].Param6 = 0;
		    for (j=0; j<49; j++)
			Audio_ReceptionList[i].Param7[j] = 0;
		    Audio_ReceptionList[i].Param7_Length = 0;
		    
		    for (j=0; j<31; j++)
			Audio_ReceptionList[i].Param8[j] = 0;
		    Audio_ReceptionList[i].Param8_Length = 0;
		    
	    }

	/********* Laden der CSV-Datei ***********/
  // Pos von letztem  / ermitteln
  for (i = 0; i < strlen(gAudio_ReceptionList_Path[gListType]); i++)
  {
    if (gAudio_ReceptionList_Path[gListType][i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gAudio_ReceptionList_Path[gListType], 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gAudio_ReceptionList_Path[gListType], (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "ReceptionList"
		{
      
      
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
            
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in ReceptionList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 65535) //ignore first line in *.csv file
					{
						Audio_ReceptionList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Audio_ReceptionList[current_CSV_line-1].Param2 = atol(temp2); //Type
						Audio_ReceptionList[current_CSV_line-1].Param3 = atol(temp3); //Attributes
						Audio_ReceptionList[current_CSV_line-1].Param4 = atol(temp4); //PresetID
						Audio_ReceptionList[current_CSV_line-1].Param5 = atol(temp5); //FmREG_Code
						Audio_ReceptionList[current_CSV_line-1].Param6 = atol(temp6); //Category
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 65535)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Type
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Attributes
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //PresetID
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //FmREG_Code
								if ( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //Category
								if ( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //Name
								if (paramPos < 48)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_ReceptionList_ListFormat == 1) )
                  {
                    Audio_ReceptionList[current_CSV_line-1].Param7[paramPos++] = buffer_byte[filePos++];
                    Audio_ReceptionList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_ReceptionList_ListFormat == 0) )
                  {
                    Audio_ReceptionList[current_CSV_line-1].Param7[paramPos++] = 0xC2;
                    Audio_ReceptionList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_ReceptionList_ListFormat == 0) )
                  {
                    Audio_ReceptionList[current_CSV_line-1].Param7[paramPos++] = 0xC3;
                    Audio_ReceptionList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos] - 0x40;
                    
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_ReceptionList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
                  }
									Audio_ReceptionList[current_CSV_line-1].Param7_Length = paramPos + 1;
								}
								paramPos++;
						break;
						case 8: //Frequency
								if (paramPos < 30)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_ReceptionList_ListFormat == 1) )
                  {
                    Audio_ReceptionList[current_CSV_line-1].Param8[paramPos++] = buffer_byte[filePos++];
                    Audio_ReceptionList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_ReceptionList_ListFormat == 0) )
                  {
                    Audio_ReceptionList[current_CSV_line-1].Param8[paramPos++] = 0xC2;
                    Audio_ReceptionList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_ReceptionList_ListFormat == 0) )
                  {
                    Audio_ReceptionList[current_CSV_line-1].Param8[paramPos++] = 0xC3;
                    Audio_ReceptionList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_ReceptionList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
                  }
									Audio_ReceptionList[current_CSV_line-1].Param8_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}
        
		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  Audio_ReceptionList_TotalListNum = current_CSV_line - 1- empty;
  empty=0;
  
  putValue(P_FSG_49_0_0_22_1_range, Audio_ReceptionList[0].Param1);
  putValue(P_FSG_49_0_0_22_2_range, Audio_ReceptionList[0].Param1);
  
  putValue(P_FSG_49_0_0_51_1_range, Audio_ReceptionList[0].Param1);
  putValue(P_FSG_49_0_0_51_2_range, Audio_ReceptionList[0].Param1);
  putValue(P_FSG_49_0_0_51_3_range, Audio_ReceptionList[0].Param1);
  putValue(P_FSG_49_0_0_51_4_range, Audio_ReceptionList[0].Param1);
  
  putValue(P_FSG_49_0_0_55_1_range, Audio_ReceptionList[0].Param1);
  putValue(P_FSG_49_0_0_55_2_range, Audio_ReceptionList[0].Param1);

  for(i=0;i<elcount(cInfo1); i++)
  {
  cInfo1[i] = 0;
  }
  
  for(i=0;i<elcount(cInfo2); i++)
  {
  cInfo2[i] = 0;
  }

  for(i=0;i<Audio_ReceptionList[0].Param7_Length; i++)
  {
  u8Info1[i] = Audio_ReceptionList[0].Param7[i];
  cInfo1[i] = Audio_ReceptionList[0].Param7[i];
  }
  
  for(i=0;i<Audio_ReceptionList[0].Param8_Length; i++)
  {
  u8Info2[i] = Audio_ReceptionList[0].Param8[i];
  cInfo2[i] = Audio_ReceptionList[0].Param8[i];
  }
  
  putValue(P_FSG_49_0_0_54_2, 0x44);
  putValue(P_FSG_49_0_0_54_1, u8Info1, Audio_ReceptionList[0].Param7_Length);
  putValue(P_FSG_49_0_0_54_4, u8Info2, Audio_ReceptionList[0].Param8_Length);
  
  @Audio_ReceptionList_Elements = Audio_ReceptionList_TotalListNum;
  init_List_panel();
}

on envVar Env_Audio_ReceptionList_FM_Path
{
  char buffer[255];
  
  getValue (Env_Audio_ReceptionList_FM_Path, buffer);
  putValue (Audio_ReceptionList_CSV_Path, buffer);
}

on envVar Audio_ReceptionList_CSV_Path
{
  char buffer[255];
  
  getValue (Audio_ReceptionList_CSV_Path, buffer);
  putValue (Env_Audio_ReceptionList_FM_Path, buffer);
}

on envVar Audio_ReceptionList_CSV_Load
{
  if (@this == 1) clear_List_panel();
  Audio_ReceptionList_Offset = 0;
  @Env_Audio_ReceptionList_LoadBTN = @this;
}

on envVar Audio_ReceptionList_FullRangeUpdate
{
  if (@this == 1) clear_List_panel();
  Audio_ReceptionList_Offset = 0;
  @Env_Audio_ReceptionList_LoadBTN = @this;
  
  Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data);
}

on envVar Audio_ReceptionList_Elements
{
  Audio_ReceptionList_TotalListNum = @this;
}

init_List_panel()
{
  @Audio_ReceptionList_Element_01 =      Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_02 =  1 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_03 =  2 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_04 =  3 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_05 =  4 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_06 =  5 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_07 =  6 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_08 =  7 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_09 =  8 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_10 =  9 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_11 = 10 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_12 = 11 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_13 = 12 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_14 = 13 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_15 = 14 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_16 = 15 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_17 = 16 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_18 = 17 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_19 = 18 + Audio_ReceptionList_Offset;
  @Audio_ReceptionList_Element_20 = 19 + Audio_ReceptionList_Offset;
  
  
  // max 20 Elemente
  @Audio_ReceptionList_Pos_01 = Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_01 = Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_01 = Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_01 = Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_01 = Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_01 = Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_01, Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_01, Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_02 = Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_02 = Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_02 = Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_02 = Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_02 = Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_02 = Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_02, Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_02, Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_03 = Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_03 = Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_03 = Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_03 = Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_03 = Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_03 = Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_03, Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_03, Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_04 = Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_04 = Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_04 = Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_04 = Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_04 = Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_04 = Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_04, Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_04, Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_05 = Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_05 = Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_05 = Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_05 = Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_05 = Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_05 = Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_05, Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_05, Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_06 = Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_06 = Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_06 = Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_06 = Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_06 = Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_06 = Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_06, Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_06, Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_07 = Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_07 = Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_07 = Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_07 = Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_07 = Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_07 = Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_07, Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_07, Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_08 = Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_08 = Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_08 = Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_08 = Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_08 = Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_08 = Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_08, Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_08, Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_09 = Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_09 = Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_09 = Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_09 = Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_09 = Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_09 = Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_09, Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_09, Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_10 = Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_10 = Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_10 = Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_10 = Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_10 = Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_10 = Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_10, Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_10, Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_11 = Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_11 = Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_11 = Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_11 = Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_11 = Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_11 = Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_11, Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_11, Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_12 = Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_12 = Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_12 = Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_12 = Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_12 = Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_12 = Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_12, Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_12, Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_13 = Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_13 = Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_13 = Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_13 = Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_13 = Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_13 = Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_13, Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_13, Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_14 = Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_14 = Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_14 = Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_14 = Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_14 = Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_14 = Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_14, Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_14, Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_15 = Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_15 = Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_15 = Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_15 = Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_15 = Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_15 = Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_15, Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_15, Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_16 = Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_16 = Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_16 = Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_16 = Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_16 = Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_16 = Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_16, Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_16, Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_17 = Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_17 = Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_17 = Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_17 = Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_17 = Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_17 = Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_17, Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_17, Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_18 = Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_18 = Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_18 = Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_18 = Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_18 = Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_18 = Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_18, Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_18, Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_19 = Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_19 = Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_19 = Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_19 = Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_19 = Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_19 = Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_19, Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_19, Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param8);

  @Audio_ReceptionList_Pos_20 = Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param1;
  @Audio_ReceptionList_Type_20 = Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param2;
  @Audio_ReceptionList_Attributes_20 = Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param3;
  @Audio_ReceptionList_PresetID_20 = Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param4;
  @Audio_ReceptionList_FmREG_Code_20 = Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param5;
  @Audio_ReceptionList_Category_20 = Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param6;
  putvalue (Audio_ReceptionList_Name_20, Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param7);
  putvalue (Audio_ReceptionList_Frequency_20, Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param8);
}

clear_List_panel()
{
  @Audio_ReceptionList_Pos_01 = 0;
  @Audio_ReceptionList_Pos_02 = 0;
  @Audio_ReceptionList_Pos_03 = 0;
  @Audio_ReceptionList_Pos_04 = 0;
  @Audio_ReceptionList_Pos_05 = 0;
  @Audio_ReceptionList_Pos_06 = 0;
  @Audio_ReceptionList_Pos_07 = 0;
  @Audio_ReceptionList_Pos_08 = 0;
  @Audio_ReceptionList_Pos_09 = 0;
  @Audio_ReceptionList_Pos_10 = 0;
  @Audio_ReceptionList_Pos_11 = 0;
  @Audio_ReceptionList_Pos_12 = 0;
  @Audio_ReceptionList_Pos_13 = 0;
  @Audio_ReceptionList_Pos_14 = 0;
  @Audio_ReceptionList_Pos_15 = 0;
  @Audio_ReceptionList_Pos_16 = 0;
  @Audio_ReceptionList_Pos_17 = 0;
  @Audio_ReceptionList_Pos_18 = 0;
  @Audio_ReceptionList_Pos_19 = 0;
  @Audio_ReceptionList_Pos_20 = 0;

  @Audio_ReceptionList_Type_01 = 0;
  @Audio_ReceptionList_Type_02 = 0;
  @Audio_ReceptionList_Type_03 = 0;
  @Audio_ReceptionList_Type_04 = 0;
  @Audio_ReceptionList_Type_05 = 0;
  @Audio_ReceptionList_Type_06 = 0;
  @Audio_ReceptionList_Type_07 = 0;
  @Audio_ReceptionList_Type_08 = 0;
  @Audio_ReceptionList_Type_09 = 0;
  @Audio_ReceptionList_Type_10 = 0;
  @Audio_ReceptionList_Type_11 = 0;
  @Audio_ReceptionList_Type_12 = 0;
  @Audio_ReceptionList_Type_13 = 0;
  @Audio_ReceptionList_Type_14 = 0;
  @Audio_ReceptionList_Type_15 = 0;
  @Audio_ReceptionList_Type_16 = 0;
  @Audio_ReceptionList_Type_17 = 0;
  @Audio_ReceptionList_Type_18 = 0;
  @Audio_ReceptionList_Type_19 = 0;
  @Audio_ReceptionList_Type_20 = 0;

  @Audio_ReceptionList_Attributes_01 = 0;
  @Audio_ReceptionList_Attributes_02 = 0;
  @Audio_ReceptionList_Attributes_03 = 0;
  @Audio_ReceptionList_Attributes_04 = 0;
  @Audio_ReceptionList_Attributes_05 = 0;
  @Audio_ReceptionList_Attributes_06 = 0;
  @Audio_ReceptionList_Attributes_07 = 0;
  @Audio_ReceptionList_Attributes_08 = 0;
  @Audio_ReceptionList_Attributes_09 = 0;
  @Audio_ReceptionList_Attributes_10 = 0;
  @Audio_ReceptionList_Attributes_11 = 0;
  @Audio_ReceptionList_Attributes_12 = 0;
  @Audio_ReceptionList_Attributes_13 = 0;
  @Audio_ReceptionList_Attributes_14 = 0;
  @Audio_ReceptionList_Attributes_15 = 0;
  @Audio_ReceptionList_Attributes_16 = 0;
  @Audio_ReceptionList_Attributes_17 = 0;
  @Audio_ReceptionList_Attributes_18 = 0;
  @Audio_ReceptionList_Attributes_19 = 0;
  @Audio_ReceptionList_Attributes_20 = 0;

  @Audio_ReceptionList_PresetID_01 = 0;
  @Audio_ReceptionList_PresetID_02 = 0;
  @Audio_ReceptionList_PresetID_03 = 0;
  @Audio_ReceptionList_PresetID_04 = 0;
  @Audio_ReceptionList_PresetID_05 = 0;
  @Audio_ReceptionList_PresetID_06 = 0;
  @Audio_ReceptionList_PresetID_07 = 0;
  @Audio_ReceptionList_PresetID_08 = 0;
  @Audio_ReceptionList_PresetID_09 = 0;
  @Audio_ReceptionList_PresetID_10 = 0;
  @Audio_ReceptionList_PresetID_11 = 0;
  @Audio_ReceptionList_PresetID_12 = 0;
  @Audio_ReceptionList_PresetID_13 = 0;
  @Audio_ReceptionList_PresetID_14 = 0;
  @Audio_ReceptionList_PresetID_15 = 0;
  @Audio_ReceptionList_PresetID_16 = 0;
  @Audio_ReceptionList_PresetID_17 = 0;
  @Audio_ReceptionList_PresetID_18 = 0;
  @Audio_ReceptionList_PresetID_19 = 0;
  @Audio_ReceptionList_PresetID_20 = 0;

  @Audio_ReceptionList_FmREG_Code_01 = 0;
  @Audio_ReceptionList_FmREG_Code_02 = 0;
  @Audio_ReceptionList_FmREG_Code_03 = 0;
  @Audio_ReceptionList_FmREG_Code_04 = 0;
  @Audio_ReceptionList_FmREG_Code_05 = 0;
  @Audio_ReceptionList_FmREG_Code_06 = 0;
  @Audio_ReceptionList_FmREG_Code_07 = 0;
  @Audio_ReceptionList_FmREG_Code_08 = 0;
  @Audio_ReceptionList_FmREG_Code_09 = 0;
  @Audio_ReceptionList_FmREG_Code_10 = 0;
  @Audio_ReceptionList_FmREG_Code_11 = 0;
  @Audio_ReceptionList_FmREG_Code_12 = 0;
  @Audio_ReceptionList_FmREG_Code_13 = 0;
  @Audio_ReceptionList_FmREG_Code_14 = 0;
  @Audio_ReceptionList_FmREG_Code_15 = 0;
  @Audio_ReceptionList_FmREG_Code_16 = 0;
  @Audio_ReceptionList_FmREG_Code_17 = 0;
  @Audio_ReceptionList_FmREG_Code_18 = 0;
  @Audio_ReceptionList_FmREG_Code_19 = 0;
  @Audio_ReceptionList_FmREG_Code_20 = 0;

  @Audio_ReceptionList_Category_01 = 0;
  @Audio_ReceptionList_Category_02 = 0;
  @Audio_ReceptionList_Category_03 = 0;
  @Audio_ReceptionList_Category_04 = 0;
  @Audio_ReceptionList_Category_05 = 0;
  @Audio_ReceptionList_Category_06 = 0;
  @Audio_ReceptionList_Category_07 = 0;
  @Audio_ReceptionList_Category_08 = 0;
  @Audio_ReceptionList_Category_09 = 0;
  @Audio_ReceptionList_Category_10 = 0;
  @Audio_ReceptionList_Category_11 = 0;
  @Audio_ReceptionList_Category_12 = 0;
  @Audio_ReceptionList_Category_13 = 0;
  @Audio_ReceptionList_Category_14 = 0;
  @Audio_ReceptionList_Category_15 = 0;
  @Audio_ReceptionList_Category_16 = 0;
  @Audio_ReceptionList_Category_17 = 0;
  @Audio_ReceptionList_Category_18 = 0;
  @Audio_ReceptionList_Category_19 = 0;
  @Audio_ReceptionList_Category_20 = 0;
  
  putvalue (Audio_ReceptionList_Name_01, "");
  putvalue (Audio_ReceptionList_Name_02, "");
  putvalue (Audio_ReceptionList_Name_03, "");
  putvalue (Audio_ReceptionList_Name_04, "");
  putvalue (Audio_ReceptionList_Name_05, "");
  putvalue (Audio_ReceptionList_Name_06, "");
  putvalue (Audio_ReceptionList_Name_07, "");
  putvalue (Audio_ReceptionList_Name_08, "");
  putvalue (Audio_ReceptionList_Name_09, "");
  putvalue (Audio_ReceptionList_Name_10, "");
  putvalue (Audio_ReceptionList_Name_11, "");
  putvalue (Audio_ReceptionList_Name_12, "");
  putvalue (Audio_ReceptionList_Name_13, "");
  putvalue (Audio_ReceptionList_Name_14, "");
  putvalue (Audio_ReceptionList_Name_15, "");
  putvalue (Audio_ReceptionList_Name_16, "");
  putvalue (Audio_ReceptionList_Name_17, "");
  putvalue (Audio_ReceptionList_Name_18, "");
  putvalue (Audio_ReceptionList_Name_19, "");
  putvalue (Audio_ReceptionList_Name_20, "");

  putvalue (Audio_ReceptionList_Frequency_01, "");
  putvalue (Audio_ReceptionList_Frequency_02, "");
  putvalue (Audio_ReceptionList_Frequency_03, "");
  putvalue (Audio_ReceptionList_Frequency_04, "");
  putvalue (Audio_ReceptionList_Frequency_05, "");
  putvalue (Audio_ReceptionList_Frequency_06, "");
  putvalue (Audio_ReceptionList_Frequency_07, "");
  putvalue (Audio_ReceptionList_Frequency_08, "");
  putvalue (Audio_ReceptionList_Frequency_09, "");
  putvalue (Audio_ReceptionList_Frequency_10, "");
  putvalue (Audio_ReceptionList_Frequency_11, "");
  putvalue (Audio_ReceptionList_Frequency_12, "");
  putvalue (Audio_ReceptionList_Frequency_13, "");
  putvalue (Audio_ReceptionList_Frequency_14, "");
  putvalue (Audio_ReceptionList_Frequency_15, "");
  putvalue (Audio_ReceptionList_Frequency_16, "");
  putvalue (Audio_ReceptionList_Frequency_17, "");
  putvalue (Audio_ReceptionList_Frequency_18, "");
  putvalue (Audio_ReceptionList_Frequency_19, "");
  putvalue (Audio_ReceptionList_Frequency_20, "");
  
  @Audio_ReceptionList_Changed_Start = 0;
  @Audio_ReceptionList_Changed_Elements = 0;
}

on envVar Audio_ReceptionList_Down
{
  if (@this == 1)
  {
    if (@Audio_ReceptionList_Element_20 < @Audio_ReceptionList_Elements - 1)
    {
      writelineex(4,0,"List +");
      Audio_ReceptionList_Offset++;
      init_List_panel();
    }
  }
}

on envVar Audio_ReceptionList_Up
{
  if (@this == 1)
  {
    if (Audio_ReceptionList_Offset > 0)
    {
      writelineex(4,0,"List -");
      Audio_ReceptionList_Offset--;
      init_List_panel();
    }
  }
}

on envVar Audio_ReceptionList_Changed_SendMode
{
  switch (@this)
  {
    // bitte Modus waehlen
    case 0: @Audio_ReceptionList_Changed_Shift = 0;
            @Audio_ReceptionList_Changed_Direction = 0;
            @Audio_ReceptionList_Changed_Transmit_Pos = 0;
            @Audio_ReceptionList_Changed_RecordAddress = 0x0;
    break;
      
    // Einfuegen von Elementen - consecutive IDs bzw. einzelnes Element
    case 1: @Audio_ReceptionList_Changed_Shift = 1;
            @Audio_ReceptionList_Changed_Direction = 0;
            @Audio_ReceptionList_Changed_Transmit_Pos = 0;
            @Audio_ReceptionList_Changed_RecordAddress = 0x0;
    break;
      
    // Einfuegen von Elementen - Einfuegen eines Blockes von ''n'' Elementen
    case 2: @Audio_ReceptionList_Changed_Shift = 1;
            @Audio_ReceptionList_Changed_Direction = 0;
            @Audio_ReceptionList_Changed_Transmit_Pos = 1;
            @Audio_ReceptionList_Changed_RecordAddress = 0xF;
    break;
      
    // Loeschen von Elementen - consecutive IDs
    case 3: @Audio_ReceptionList_Changed_Shift = 1;
            @Audio_ReceptionList_Changed_Direction = 1;
            @Audio_ReceptionList_Changed_Transmit_Pos = 0;
            @Audio_ReceptionList_Changed_RecordAddress = 0x0;
    break;
      
    // Loeschen von Elementen - arbitrary IDs
    case 4: @Audio_ReceptionList_Changed_Shift = 1;
            @Audio_ReceptionList_Changed_Direction = 1;
            @Audio_ReceptionList_Changed_Transmit_Pos = 1;
            @Audio_ReceptionList_Changed_RecordAddress = 0xF;
    break;
      
    // Aenderung von Elementen - Aenderung eines einzelnen Elementes bzw. mehrerer bei Verwendung von consecutive IDs
    case 5: @Audio_ReceptionList_Changed_Shift = 0;
            @Audio_ReceptionList_Changed_Direction = 0;
            @Audio_ReceptionList_Changed_Transmit_Pos = 0;
            @Audio_ReceptionList_Changed_RecordAddress = 0x0;
    break;
      
    // Aenderung von Elementen - Aenderung eines zusammenhaengenden Blocks von Elementen bei Verwendung von arbitrary IDs
    case 6: @Audio_ReceptionList_Changed_Shift = 0;
            @Audio_ReceptionList_Changed_Direction = 0;
            @Audio_ReceptionList_Changed_Transmit_Pos = 1;
            @Audio_ReceptionList_Changed_RecordAddress = 0xF;
    break;
  }
}

on envVar Audio_ReceptionList_Pos_01
{
  Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_01
{
  Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_01
{
  Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_01
{
  Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_01
{
  Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_01
{
  Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_01
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_01
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[0 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_02
{
  Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_02
{
  Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_02
{
  Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_02
{
  Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_02
{
  Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_02
{
  Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_02
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_02
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[1 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_03
{
  Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_03
{
  Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_03
{
  Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_03
{
  Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_03
{
  Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_03
{
  Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_03
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_03
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[2 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_04
{
  Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_04
{
  Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_04
{
  Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_04
{
  Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_04
{
  Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_04
{
  Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_04
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_04
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[3 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_05
{
  Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_05
{
  Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_05
{
  Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_05
{
  Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_05
{
  Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_05
{
  Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_05
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_05
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[4 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_06
{
  Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_06
{
  Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_06
{
  Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_06
{
  Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_06
{
  Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_06
{
  Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_06
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_06
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[5 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_07
{
  Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_07
{
  Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_07
{
  Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_07
{
  Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_07
{
  Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_07
{
  Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_07
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_07
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[6 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_08
{
  Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_08
{
  Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_08
{
  Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_08
{
  Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_08
{
  Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_08
{
  Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_08
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_08
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[7 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_09
{
  Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_09
{
  Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_09
{
  Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_09
{
  Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_09
{
  Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_09
{
  Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_09
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_09
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[8 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_10
{
  Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_10
{
  Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_10
{
  Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_10
{
  Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_10
{
  Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_10
{
  Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_10
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_10
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[9 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_11
{
  Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_11
{
  Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_11
{
  Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_11
{
  Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_11
{
  Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_11
{
  Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_11
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_11
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[10 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_12
{
  Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_12
{
  Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_12
{
  Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_12
{
  Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_12
{
  Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_12
{
  Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_12
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_12
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[11 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_13
{
  Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_13
{
  Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_13
{
  Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_13
{
  Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_13
{
  Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_13
{
  Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_13
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_13
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[12 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_14
{
  Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_14
{
  Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_14
{
  Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_14
{
  Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_14
{
  Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_14
{
  Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_14
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_14
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[13 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_15
{
  Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_15
{
  Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_15
{
  Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_15
{
  Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_15
{
  Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_15
{
  Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_15
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_15
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[14 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_16
{
  Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_16
{
  Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_16
{
  Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_16
{
  Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_16
{
  Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_16
{
  Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_16
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_16
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[15 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_17
{
  Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_17
{
  Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_17
{
  Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_17
{
  Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_17
{
  Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_17
{
  Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_17
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_17
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[16 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_18
{
  Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_18
{
  Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_18
{
  Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_18
{
  Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_18
{
  Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_18
{
  Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_18
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_18
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[17 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_19
{
  Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_19
{
  Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_19
{
  Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_19
{
  Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_19
{
  Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_19
{
  Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_19
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_19
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[18 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Pos_20
{
  Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param1 = @this;
}

on envVar Audio_ReceptionList_Type_20
{
  Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param2 = @this;
}

on envVar Audio_ReceptionList_Attributes_20
{
  Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param3 = @this;
}

on envVar Audio_ReceptionList_PresetID_20
{
  Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param4 = @this;
}

on envVar Audio_ReceptionList_FmREG_Code_20
{
  Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param5 = @this;
}

on envVar Audio_ReceptionList_Category_20
{
  Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param6 = @this;
}

on envVar Audio_ReceptionList_Name_20
{
  byte i;
  char buffer[49];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param7_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param7_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param7);
}

on envVar Audio_ReceptionList_Frequency_20
{
  byte i;
  char buffer[31];
  
  getvalue (this, buffer);
  
  Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param8_Length = getValueSize(this) - 1;

  // prüfen ob 2 Byte Sonderzeichen vorhanden sind, wenn ja: Länge++
  for (i=0; i < getValueSize(this); i++)
  {
    if (((buffer[i] & 0x000000FF) >= 0xA0) && ((buffer[i] & 0x000000FF) <= 0xFF))
     Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param8_Length++;
  }
  
  getvalue (this, Audio_ReceptionList[19 + Audio_ReceptionList_Offset].Param8);
}

on envVar Audio_ReceptionList_Changed_Send
{
  byte mode;
  long i = 0;
  long j = 0;
  long k = 0;
  long l = 0;
  byte stringsize;
  byte data[BAP_BUFFERSIZE];
  char buffer_31[31];
  char buffer_49[49];
  word utf8;
  byte changed_offset;

  // [A: LAH-BAPDT1980] Wenn Transmit_Pos=0 gesetzt ist, wird in der ChangedArray-Nachricht nur der ArrayHeader uebertragen
  // [A: LAH-BAPDT1982] Shift=0 signalisiert die Aenderung bestehender Elemente
 
  if (@this == 1)
  {
    // Data_Buffer loeschen
    for (i=0; i<BAP_BUFFERSIZE; i++)
      data[i] = 0;
    
    i = 0;
    
  
    mode = @Audio_ReceptionList_Changed_Shift + @Audio_ReceptionList_Changed_Direction * 2 + @Audio_ReceptionList_Changed_Transmit_Pos * 4 + @Audio_ReceptionList_Changed_IndexSize * 8;
    
    // Pos
    if (@Audio_ReceptionList_Changed_RecordAddress == 0xF)
    {
      for (k=0; k<@Audio_ReceptionList_Changed_Elements; k++)
      {
        if (@Audio_ReceptionList_Changed_Transmit_Pos == 1)
        {
          if (@Audio_ReceptionList_Changed_IndexSize == 0) // 8 Bit
            data[i++] = Audio_ReceptionList_Changed_Array_Pos[k];
          if (@Audio_ReceptionList_Changed_IndexSize == 1) // 16 Bit
          {
            data[i++] =  Audio_ReceptionList_Changed_Array_Pos[k]       & 0x00FF;
            data[i++] = (Audio_ReceptionList_Changed_Array_Pos[k] >> 8) & 0x00FF;
          }
        }
          
        else
        {
          i = 0;
        }
      }
    }
    
   
    // Type
    if (@Audio_ReceptionList_Changed_RecordAddress == 0x0 || @Audio_ReceptionList_Changed_RecordAddress == 0x1 || @Audio_ReceptionList_Changed_RecordAddress == 0x2 || @Audio_ReceptionList_Changed_RecordAddress == 0x6)
      data[i++] = @Audio_ReceptionList_Changed_Type;
    
    // Attributes
    if (@Audio_ReceptionList_Changed_RecordAddress == 0x0 || @Audio_ReceptionList_Changed_RecordAddress == 0x1 || @Audio_ReceptionList_Changed_RecordAddress == 0x2 || @Audio_ReceptionList_Changed_RecordAddress == 0x6)
    {
      data[i++] =  @Audio_ReceptionList_Changed_Attributes & 0x00FF;
      data[i++] = (@Audio_ReceptionList_Changed_Attributes >> 8) & 0x00FF;
    }
    
    // PresetID
    if (@Audio_ReceptionList_Changed_RecordAddress == 0x0 || @Audio_ReceptionList_Changed_RecordAddress == 0x1)
      data[i++] = @Audio_ReceptionList_Changed_PresetID;
    
    // FmREG_Code
    if (@Audio_ReceptionList_Changed_RecordAddress == 0x0 || @Audio_ReceptionList_Changed_RecordAddress == 0x1 || @Audio_ReceptionList_Changed_RecordAddress == 0x3)
      data[i++] = @Audio_ReceptionList_Changed_FmREG_Code;
    
    // Category
    if (@Audio_ReceptionList_Changed_RecordAddress == 0x0 || @Audio_ReceptionList_Changed_RecordAddress == 0x1 || @Audio_ReceptionList_Changed_RecordAddress == 0x3 || @Audio_ReceptionList_Changed_RecordAddress == 0x6)
      data[i++] = @Audio_ReceptionList_Changed_Category;
    
    // Name
    if (@Audio_ReceptionList_Changed_RecordAddress == 0x0 || @Audio_ReceptionList_Changed_RecordAddress == 0x1 || @Audio_ReceptionList_Changed_RecordAddress == 0x3 || @Audio_ReceptionList_Changed_RecordAddress == 0x4 || @Audio_ReceptionList_Changed_RecordAddress == 0x6)
    {
      data[i++]  = getValueSize(Audio_ReceptionList_Changed_Name) - 1; // Länge
      stringsize = getValueSize(Audio_ReceptionList_Changed_Name) - 1;
      
      getvalue (Audio_ReceptionList_Changed_Name, buffer_49);
      
      for (j = 0; j < stringsize; j++)
      {
        if ( (buffer_49[j] & 0x000000FF) >= 0xA0 && (buffer_49[j] <= 0xBF) )
        {
          data[i] = 0xC2;
          data[i] = buffer_49[j];
          stringsize--;
        }
        else if ( (buffer_49[j] & 0x000000FF) >= 0xC0 && (buffer_49[j] & 0x000000FF) <= 0xFF ) 
        {
          utf8 = (buffer_49[j] & 0x000000FF) + 0xC2C0;
          data[i++] = (utf8 >> 8);
          data[i++] = utf8;
          stringsize--;
        }
        else
        {
          data[i++] = buffer_49[j]; 
        }
      }
    }
      
    // Frequency
    if (@Audio_ReceptionList_Changed_RecordAddress == 0x0 || @Audio_ReceptionList_Changed_RecordAddress == 0x1 || @Audio_ReceptionList_Changed_RecordAddress == 0x3 || @Audio_ReceptionList_Changed_RecordAddress == 0x5 || @Audio_ReceptionList_Changed_RecordAddress == 0x6)
    {
      data[i++]  = getValueSize(Audio_ReceptionList_Changed_Frequency) - 1; // Länge
      stringsize = getValueSize(Audio_ReceptionList_Changed_Frequency) - 1;
      
      getvalue (Audio_ReceptionList_Changed_Frequency, buffer_31);
      
      for (j = 0; j < stringsize; j++)
      {
        if ( (buffer_31[j] & 0x000000FF) >= 0xA0 && (buffer_31[j] <= 0xBF) )
        {
          data[i] = 0xC2;
          data[i] = buffer_31[j];
          stringsize--;
        }
        else if ( (buffer_31[j] & 0x000000FF) >= 0xC0 && (buffer_31[j] & 0x000000FF) <= 0xFF ) 
        {
          utf8 = (buffer_31[j] & 0x000000FF) + 0xC2C0;
          data[i++] = (utf8 >> 8);
          data[i++] =  utf8;
          stringsize--;
        }
        else
        {
          data[i++] = buffer_31[j]; 
        }
      }
    }
    
    // tenn Trans_pos = 0, dann nur Header senden (also Länge der Daten = 0)
    if (@Audio_ReceptionList_Changed_Transmit_Pos == 0)
      i = 0;
    
    Audio_ReceptionList_Changed(mode, @Audio_ReceptionList_Changed_RecordAddress, @Audio_ReceptionList_Changed_Start, @Audio_ReceptionList_Changed_Elements, i, data);
    
    
    // Listenparameter anpassen
    
    // Einfuegen von Elementen - consecutive IDs bzw. einzelnes Element
    if (@Audio_ReceptionList_Changed_SendMode == 1)
    {
      // keine Daten, nur Header
      for (i=@Audio_ReceptionList_Elements+@Audio_ReceptionList_Changed_Elements; i>=0; i--)
      {
        // Elemente aufrutschen lassen (von unten nach oben)
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Elements-changed_offset].Param1 = Audio_ReceptionList[i].Param1;
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Elements-changed_offset].Param2 = Audio_ReceptionList[i].Param2;
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Elements-changed_offset].Param3 = Audio_ReceptionList[i].Param3;
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Elements-changed_offset].Param4 = Audio_ReceptionList[i].Param4;
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Elements-changed_offset].Param5 = Audio_ReceptionList[i].Param5;
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Elements-changed_offset].Param6 = Audio_ReceptionList[i].Param6;
        
        for (k=0; k<49; k++)
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Elements-changed_offset].Param7[k] = Audio_ReceptionList[i].Param7[k];
          
        for (k=0; k<31; k++)
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Elements-changed_offset].Param8[k] = Audio_ReceptionList[i].Param8[k];
        
        // wenn Pos für einzufügende Elemente erreicht
        if (i == @Audio_ReceptionList_Changed_Start - 1)
        {
          for (changed_offset = 1; changed_offset <= @Audio_ReceptionList_Changed_Elements; changed_offset++)
          {
            Audio_ReceptionList[@Audio_ReceptionList_Changed_Start-2+changed_offset].Param1 = Audio_ReceptionList_Changed_Array_Pos[changed_offset-1];
            Audio_ReceptionList[@Audio_ReceptionList_Changed_Start-2+changed_offset].Param2 = Audio_ReceptionList_Changed_Array_Type[changed_offset-1];
            Audio_ReceptionList[@Audio_ReceptionList_Changed_Start-2+changed_offset].Param3 = Audio_ReceptionList_Changed_Array_Attributes[changed_offset-1];
            Audio_ReceptionList[@Audio_ReceptionList_Changed_Start-2+changed_offset].Param4 = Audio_ReceptionList_Changed_Array_PresetID[changed_offset-1];
            Audio_ReceptionList[@Audio_ReceptionList_Changed_Start-2+changed_offset].Param5 = Audio_ReceptionList_Changed_Array_FmREG_Code[changed_offset-1];
            Audio_ReceptionList[@Audio_ReceptionList_Changed_Start-2+changed_offset].Param6 = Audio_ReceptionList_Changed_Array_Category[changed_offset-1];
            
            for (k=0; k<49; k++)
              Audio_ReceptionList[@Audio_ReceptionList_Changed_Start-2+changed_offset].Param7[k] = Audio_ReceptionList_Changed_Array_Name[changed_offset-1][k];
            
            for (k=0; k<31; k++)
              Audio_ReceptionList[@Audio_ReceptionList_Changed_Start-2+changed_offset].Param8[k] = Audio_ReceptionList_Changed_Array_Frequency[changed_offset-1][k];
          }
          i = i - changed_offset;
        }
      }
      @Audio_ReceptionList_Elements = @Audio_ReceptionList_Elements + @Audio_ReceptionList_Changed_Elements;
      changed_offset=0;
    }
    
    // Einfuegen von Elementen - Einfuegen eines Blockes von ''n'' Elementen
    if (@Audio_ReceptionList_Changed_SendMode == 2)
    {
      // Logik muss umgebaut werden, um Anfragen auf Pos ui bedienen
    }
    
    // Loeschen von Elementen - consecutive IDs
    if (@Audio_ReceptionList_Changed_SendMode == 3)
    {
      // keine Daten, nur Header
    }
    
    // Loeschen von Elementen - arbitrary IDs
    if (@Audio_ReceptionList_Changed_SendMode == 4)
    {
      for (i=0; i<@Audio_ReceptionList_Elements; i++) // Pos von Liste
      {
        for (j=0; j<@Audio_ReceptionList_Changed_Elements; j++) // Pos von Changed
        {
          if (Audio_ReceptionList[i].Param1 == Audio_ReceptionList_Changed_Array_Pos[j])
          { 
            changed_offset++;
            @Audio_ReceptionList_Elements = @Audio_ReceptionList_Elements - 1;
          }
          
          Audio_ReceptionList[i].Param1 = Audio_ReceptionList[i+changed_offset].Param1;
          Audio_ReceptionList[i].Param2 = Audio_ReceptionList[i+changed_offset].Param2;
          Audio_ReceptionList[i].Param3 = Audio_ReceptionList[i+changed_offset].Param3;
          Audio_ReceptionList[i].Param4 = Audio_ReceptionList[i+changed_offset].Param4;
          Audio_ReceptionList[i].Param5 = Audio_ReceptionList[i+changed_offset].Param5;
          Audio_ReceptionList[i].Param6 = Audio_ReceptionList[i+changed_offset].Param6;
        
          for (k=0; k<49; k++)
            Audio_ReceptionList[i].Param7[k] = Audio_ReceptionList[i+changed_offset].Param7[k];
          
          for (k=0; k<31; k++)
            Audio_ReceptionList[i].Param8[k] = Audio_ReceptionList[i+changed_offset].Param8[k];
          
        }
      }
      
      if (@Audio_ReceptionList_Elements < 20)
      {
        for (l=@Audio_ReceptionList_Elements;l<20;l++)
        {
          Audio_ReceptionList[l].Param1 = 0;
          Audio_ReceptionList[l].Param2 = 0;
          Audio_ReceptionList[l].Param3 = 0;
          Audio_ReceptionList[l].Param4 = 0;
          Audio_ReceptionList[l].Param5 = 0;
          Audio_ReceptionList[l].Param6 = 0;
          
          for (k=0; k<49; k++)
            Audio_ReceptionList[l].Param7[k] = 0;
          for (k=0; k<31; k++)
            Audio_ReceptionList[l].Param8[k] = 0;
        }
      }
          
      changed_offset = 0;
    }
    
    // Aenderung von Elementen - Aenderung eines einzelnen Elementes bzw. mehrerer bei Verwendung von consecutive IDs
    if (@Audio_ReceptionList_Changed_SendMode == 5)
    {
      // keine Daten, nur Header
      for (i=0; i<@Audio_ReceptionList_Changed_Elements; i++)
      {
        if (@Audio_ReceptionList_Changed_Start == 0)
        {
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param1 = Audio_ReceptionList_Changed_Array_Pos[i];
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param2 = Audio_ReceptionList_Changed_Array_Type[i];
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param3 = Audio_ReceptionList_Changed_Array_Attributes[i];
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param4 = Audio_ReceptionList_Changed_Array_PresetID[i];
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param5 = Audio_ReceptionList_Changed_Array_FmREG_Code[i];
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param6 = Audio_ReceptionList_Changed_Array_Category[i];
          
          for (k=0; k<49; k++)
            Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param7[k] = Audio_ReceptionList_Changed_Array_Name[i][k];
          for (k=0; k<31; k++)
            Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param8[k] = Audio_ReceptionList_Changed_Array_Frequency[i][k];
        }
        else
        {
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start-1].Param1 = Audio_ReceptionList_Changed_Array_Pos[i];
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start-1].Param2 = Audio_ReceptionList_Changed_Array_Type[i];
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start-1].Param3 = Audio_ReceptionList_Changed_Array_Attributes[i];
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start-1].Param4 = Audio_ReceptionList_Changed_Array_PresetID[i];
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start-1].Param5 = Audio_ReceptionList_Changed_Array_FmREG_Code[i];
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start-1].Param6 = Audio_ReceptionList_Changed_Array_Category[i];
          
          for (k=0; k<49; k++)
            Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start-1].Param7[k] = Audio_ReceptionList_Changed_Array_Name[i][k];
          for (k=0; k<31; k++)
            Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start-1].Param8[k] = Audio_ReceptionList_Changed_Array_Frequency[i][k];
        }
      }
    }
    
    // Aenderung von Elementen - Aenderung eines zusammenhaengenden Blocks von Elementen bei Verwendung von arbitrary IDs
    if (@Audio_ReceptionList_Changed_SendMode == 6)
    {
      for (i=0; i<@Audio_ReceptionList_Changed_Elements; i++)
      {
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param1 = Audio_ReceptionList_Changed_Array_Pos[i];
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param2 = Audio_ReceptionList_Changed_Array_Type[i];
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param3 = Audio_ReceptionList_Changed_Array_Attributes[i];
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param4 = Audio_ReceptionList_Changed_Array_PresetID[i];
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param5 = Audio_ReceptionList_Changed_Array_FmREG_Code[i];
        Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param6 = Audio_ReceptionList_Changed_Array_Category[i];
        
        for (k=0; k<49; k++)
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param7[k] = Audio_ReceptionList_Changed_Array_Name[i][k];
        for (k=0; k<31; k++)
          Audio_ReceptionList[i+@Audio_ReceptionList_Changed_Start].Param8[k] = Audio_ReceptionList_Changed_Array_Frequency[i][k];
      }
    }
  init_List_panel();
    
  }
}

on envVar Audio_ReceptionList_Changed_Start
{
  Audio_ReceptionList_Changed_Min = @this;
  Audio_ReceptionList_Changed_Max = @this + @Audio_ReceptionList_Changed_Elements;
  
  if (Audio_ReceptionList_Changed_Min != Audio_ReceptionList_Changed_Max)
    calc_recent_element();
}

on envVar Audio_ReceptionList_Changed_Elements
{
  Audio_ReceptionList_Changed_Min = @Audio_ReceptionList_Changed_Start;
  
  if (@this == 0)
    Audio_ReceptionList_Changed_Max = Audio_ReceptionList_Changed_Min;
  else
    Audio_ReceptionList_Changed_Max = Audio_ReceptionList_Changed_Min + @this;
  
  Audio_ReceptionList_TotalListNum = @Audio_ReceptionList_Elements;
  
  calc_recent_element();
}

on envVar Audio_ReceptionList_Changed_Element_Next
{
  if (@this == 1)
  {
    if (@Audio_ReceptionList_Changed_Element < Audio_ReceptionList_Changed_Max-1)
      Audio_ReceptionList_Changed_Offset++;
    
    @Audio_ReceptionList_Changed_Pos = Audio_ReceptionList_Changed_Array_Pos[Audio_ReceptionList_Changed_Offset];
    @Audio_ReceptionList_Changed_Type = Audio_ReceptionList_Changed_Array_Type[Audio_ReceptionList_Changed_Offset];
    @Audio_ReceptionList_Changed_Attributes = Audio_ReceptionList_Changed_Array_Attributes[Audio_ReceptionList_Changed_Offset];
    @Audio_ReceptionList_Changed_PresetID = Audio_ReceptionList_Changed_Array_PresetID[Audio_ReceptionList_Changed_Offset];
    @Audio_ReceptionList_Changed_FmREG_Code = Audio_ReceptionList_Changed_Array_FmREG_Code[Audio_ReceptionList_Changed_Offset];
    @Audio_ReceptionList_Changed_Category = Audio_ReceptionList_Changed_Array_Category[Audio_ReceptionList_Changed_Offset];
    putvalue (Audio_ReceptionList_Changed_Name, Audio_ReceptionList_Changed_Array_Name[Audio_ReceptionList_Changed_Offset]);
    putvalue (Audio_ReceptionList_Changed_Frequency, Audio_ReceptionList_Changed_Array_Frequency[Audio_ReceptionList_Changed_Offset]);
    
    calc_recent_element();
  }
}

on envVar Audio_ReceptionList_Changed_Element_Last
{
  if (@this == 1)
  {
    if (@Audio_ReceptionList_Changed_Element > Audio_ReceptionList_Changed_Min)
      Audio_ReceptionList_Changed_Offset--;
    
    @Audio_ReceptionList_Changed_Pos = Audio_ReceptionList_Changed_Array_Pos[Audio_ReceptionList_Changed_Offset];
    @Audio_ReceptionList_Changed_Type = Audio_ReceptionList_Changed_Array_Type[Audio_ReceptionList_Changed_Offset];
    @Audio_ReceptionList_Changed_Attributes = Audio_ReceptionList_Changed_Array_Attributes[Audio_ReceptionList_Changed_Offset];
    @Audio_ReceptionList_Changed_PresetID = Audio_ReceptionList_Changed_Array_PresetID[Audio_ReceptionList_Changed_Offset];
    @Audio_ReceptionList_Changed_FmREG_Code = Audio_ReceptionList_Changed_Array_FmREG_Code[Audio_ReceptionList_Changed_Offset];
    @Audio_ReceptionList_Changed_Category = Audio_ReceptionList_Changed_Array_Category[Audio_ReceptionList_Changed_Offset];
    putvalue (Audio_ReceptionList_Changed_Name, Audio_ReceptionList_Changed_Array_Name[Audio_ReceptionList_Changed_Offset]);
    putvalue (Audio_ReceptionList_Changed_Frequency, Audio_ReceptionList_Changed_Array_Frequency[Audio_ReceptionList_Changed_Offset]);
    
    calc_recent_element();
  }
}

calc_recent_element ()
{
  @Audio_ReceptionList_Changed_Element = Audio_ReceptionList_Changed_Min + Audio_ReceptionList_Changed_Offset;
}

on envvar Audio_ReceptionList_Changed_RecordAddress
{
  Audio_ReceptionList_Changed_Array_Pos[Audio_ReceptionList_Changed_Offset] = @this;
  
  switch (@this)
  {
    /*case 0:  enableControl ("BAP_Test","Audio_ReceptionList_Changed_Pos"        , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Type"       , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Attributes" , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_PresetID"   , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_FmREG_Code" , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Category"   , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Name"       , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Frequency"  , 1);
    break;
      
    case 1:  enableControl ("BAP_Test","Audio_ReceptionList_Changed_Pos"        , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Type"       , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Attributes" , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_PresetID"   , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_FmREG_Code" , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Category"   , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Name"       , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Frequency"  , 0);
    break;
      
    case 2:  enableControl ("BAP_Test","Audio_ReceptionList_Changed_Pos"        , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Type"       , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Attributes" , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_PresetID"   , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_FmREG_Code" , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Category"   , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Name"       , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Frequency"  , 0);
    break;
      
    case 3:  enableControl ("BAP_Test","Audio_ReceptionList_Changed_Pos"        , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Type"       , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Attributes" , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_PresetID"   , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_FmREG_Code" , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Category"   , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Name"       , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Frequency"  , 0);
    break;
      
    case 4:  enableControl ("BAP_Test","Audio_ReceptionList_Changed_Pos"        , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Type"       , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Attributes" , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_PresetID"   , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_FmREG_Code" , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Category"   , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Name"       , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Frequency"  , 0);
    break;
      
    case 5:  enableControl ("BAP_Test","Audio_ReceptionList_Changed_Pos"        , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Type"       , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Attributes" , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_PresetID"   , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_FmREG_Code" , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Category"   , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Name"       , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Frequency"  , 1);
    break;
      
    case 6:  enableControl ("BAP_Test","Audio_ReceptionList_Changed_Pos"        , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Type"       , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Attributes" , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_PresetID"   , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_FmREG_Code" , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Category"   , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Name"       , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Frequency"  , 0);
    break;
      
    case 15: enableControl ("BAP_Test","Audio_ReceptionList_Changed_Pos"        , 1);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Type"       , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Attributes" , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_PresetID"   , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_FmREG_Code" , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Category"   , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Name"       , 0);
             enableControl ("BAP_Test","Audio_ReceptionList_Changed_Frequency"  , 0);
    break;*/
  }
}

on envvar Audio_ReceptionList_Changed_Pos
{
  Audio_ReceptionList_Changed_Array_Pos[Audio_ReceptionList_Changed_Offset] = @this;
}

on envvar Audio_ReceptionList_Changed_Type
{
  Audio_ReceptionList_Changed_Array_Type[Audio_ReceptionList_Changed_Offset] = @this;
}

on envvar Audio_ReceptionList_Changed_Attributes
{
  Audio_ReceptionList_Changed_Array_Attributes[Audio_ReceptionList_Changed_Offset] = @this;
}

on envvar Audio_ReceptionList_Changed_PresetID
{
  Audio_ReceptionList_Changed_Array_PresetID[Audio_ReceptionList_Changed_Offset] = @this;
}

on envvar Audio_ReceptionList_Changed_FmREG_Code
{
  Audio_ReceptionList_Changed_Array_FmREG_Code[Audio_ReceptionList_Changed_Offset] = @this;
}

on envvar Audio_ReceptionList_Changed_Category
{
  Audio_ReceptionList_Changed_Array_Category[Audio_ReceptionList_Changed_Offset] = @this;
}

on envvar Audio_ReceptionList_Changed_Name
{
  getValue (this, Audio_ReceptionList_Changed_Array_Name[Audio_ReceptionList_Changed_Offset]);
}

on envvar Audio_ReceptionList_Changed_Frequency
{
  getValue (this, Audio_ReceptionList_Changed_Array_Frequency[Audio_ReceptionList_Changed_Offset]);
}









Audio_ReceptionList(byte opcode, byte data[])
{
  byte ASG_ID, TAID, elementType, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword parentID, list_start, elements;

  if ((opcode == 1) && (Audio_Source == 1)) // ASG GetArray
  {
    ASG_ID = (data[0] >> 4) & 0xF;
    TAID = data[0] & 0xF;
    elementType = data[1];
    parentID = data[3] *256 + data[2];
    mode = (data[4] >> 4) & 0xF;
    recordaddress = data[4] & 0xF;
    IndexSize = (mode>> 3) & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
          
    // Werte aus Get Array in Panel übertragen
    @A_FSG_49_0_0_23_1 = ASG_ID;
    @A_FSG_49_0_0_23_2 = TAID;
    @A_FSG_49_0_0_23_RecAdr = recordaddress;
          
    if (IndexSize == 0)
    {
      list_start = data[5] ;
      elements = data[6];               
    }
    else if (IndexSize == 1)
    {
      list_start = data[6] * 256 + data[5];
      elements = data[8] * 256 + data[7];
    }

      
   ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////
    
   if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
     @A_FSG_49_0_0_23_1 = ASG_ID;
   else
     ASG_ID = @A_FSG_49_0_0_23_1;
     
   if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
     @A_FSG_49_0_0_23_2 = TAID;
   else
     TAID = @A_FSG_49_0_0_23_2;
   
   if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
     @A_FSG_49_0_0_23_RecAdr = recordaddress;
   else
     recordaddress = @A_FSG_49_0_0_23_RecAdr;
   
   if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
     @A_FSG_49_0_0_23_Shift = (mode>>0);
   else
     mode = ((@A_FSG_49_0_0_23_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
   
   if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
     @A_FSG_49_0_0_23_Direction = (mode>>1);
   else
     mode = ((Shift*1)+(@A_FSG_49_0_0_23_Direction*2)+(TransPos*4)+(IndexSize*8));
   
   if (@env_AutoGetArray_Start == 0)  // Start from GetArray
     @A_FSG_49_0_0_23_Start = list_start;
   else
     list_start = @A_FSG_49_0_0_23_Start;
      
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
   if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
   {
     Audio_ReceptionList_Status(ASG_ID, TAID,elementType, parentID, mode, recordaddress, list_start, elements);
   }
  }
}

Audio_ReceptionList_Status(byte ASG_ID, byte TAID, byte elementType, dword parentID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte errorData[5] = {0,0,0,0,0};
  byte string[60];
  byte IndexSize, direction, shift;
  byte sequenceNumber = 0;
  int  startposition, endposition, elements;
  word utf8;

  int i, k, strctr; 
  int stringsize;   

  elements = received_elements;

  Data_Audio_ReceptionList[0] =  ASG_ID*16 + (TAID & 0xF);
  Data_Audio_ReceptionList[1] =  elementType;
  Data_Audio_ReceptionList[3] = (parentID >> 8) & 0xFF;
  Data_Audio_ReceptionList[2] = (parentID) & 0xFF;
  Data_Audio_ReceptionList[4] =  Audio_ReceptionList_TotalListNum  & 0xFF;
  Data_Audio_ReceptionList[5] = (Audio_ReceptionList_TotalListNum >>  8) & 0xFF;
  Data_Audio_ReceptionList[6] = (mode|0x4)*16 + (recordaddress & 0xF);
  
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     =  mode     & 0x1;

  switch (direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift; 
        endposition = startposition + elements - 1;
      }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Audio_ReceptionList_Search_Pos(list_start) != 0)
        {
          startposition = Audio_ReceptionList_Search_Pos(list_start) - 1 + shift;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Audio_ReceptionList_TotalListNum)
      {
        endposition = Audio_ReceptionList_TotalListNum - 1;
        elements = Audio_ReceptionList_TotalListNum - startposition;
      }
      
    break;
  
    case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Audio_ReceptionList_Search_Pos(list_start) != 0)
        {
          startposition = Audio_ReceptionList_Search_Pos(list_start) - 1 - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Audio_ReceptionList_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
      break;
    }
    
    // Start & Elemente in Abhängigkeit von IndexSize befüllen    
    if (IndexSize == 0)
    {
      Data_Audio_ReceptionList[7] = list_start & 0xFF;
      Data_Audio_ReceptionList[8] = elements & 0xFF;
      j_Audio_ReceptionList = 9;
    }
    else
    {
      Data_Audio_ReceptionList[8] = (list_start >> 8) & 0xFF;
      Data_Audio_ReceptionList[7] = list_start & 0xFF;
      Data_Audio_ReceptionList[10] = (elements >> 8) & 0xFF;
      Data_Audio_ReceptionList[9] = elements & 0xFF;
      j_Audio_ReceptionList = 11;
    }

    switch(direction)
    {
      case 0:
        
        for (i = startposition ; i <= endposition && i >= 0; i++)
        {
          switch(IndexSize) // Pos
          {
            case 0:   Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param1;
                      break;
              
            case 1:   Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param1 & 0xFF;
                      Data_Audio_ReceptionList[j_Audio_ReceptionList++] = (Audio_ReceptionList[i].param1>>8) & 0xFF;
                      break; 
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1|| recordaddress == 0x2 || recordaddress == 0x6) // Type
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param2;
          
          if (recordaddress == 0x0 || recordaddress == 0x1|| recordaddress == 0x2 || recordaddress == 0x6) // Attributes
          {
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param3 & 0xFF;
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = (Audio_ReceptionList[i].param3 >> 8 ) & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x3) // PresetID
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param4;
          
          if (recordaddress == 0x0 ||recordaddress == 0x1 || recordaddress == 0x3) // FmREG_Code
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param5;
          
          if (recordaddress == 0x0 ||recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x6) // Category
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param6;
          
          if (recordaddress == 0x0 ||recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // Name
          {
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param7_Length;
            stringsize = Audio_ReceptionList[i].param7_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
                Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param7[strctr];
            }
          }
        
          if (recordaddress == 0x0 || recordaddress == 0x5) // Frequency
          {
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param8_Length;
            stringsize = Audio_ReceptionList[i].param8_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
                Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param8[strctr];
            }
          }
        }
        
      break;
        
      case 1:

        for (i = startposition ; i >= endposition && i >= 0; i--)
        {
          switch(IndexSize) // Pos
          {
            case 0:   Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param1;
                      break;
                      
            case 1:   Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param1 & 0xFF;
                      Data_Audio_ReceptionList[j_Audio_ReceptionList++] = (Audio_ReceptionList[i].param1>>8) & 0xFF;
                      break; 
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1|| recordaddress == 0x2 || recordaddress == 0x6) // Type
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param2;
          
          if (recordaddress == 0x0 || recordaddress == 0x1|| recordaddress == 0x2 || recordaddress == 0x6) // Attributes
          {
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param3 & 0xFF;
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = (Audio_ReceptionList[i].param3 >> 8 ) & 0xFF;
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x3) // PresetID
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param4;
          
          if (recordaddress == 0x0 ||recordaddress == 0x1 || recordaddress == 0x3) // FmREG_Code
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param5;
          
          if (recordaddress == 0x0 ||recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x6) // Category
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param6;
          
          if (recordaddress == 0x0 ||recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // Name
          {
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param7_Length;
            stringsize = Audio_ReceptionList[i].param7_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
                Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param7[strctr];
            }
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x5) // Frequency
          {
            Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param8_Length;
            stringsize = Audio_ReceptionList[i].param8_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
                Data_Audio_ReceptionList[j_Audio_ReceptionList++] = Audio_ReceptionList[i].param8[strctr];
            }
          }
        }
      break;
  }
  settimer(Delay_Audio_ReceptionList, @Env_Audio_ReceptionList_ListDelay);
}

Audio_ReceptionList_Changed(byte mode, byte recordaddress, dword list_start, dword elements, word length_val, byte data_val[])
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;
  byte i;
  
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 

  data[0] =  @Audio_ReceptionList_Changed_ElementType;
  data[1] =  @Audio_ReceptionList_Changed_Parent_ID & 0xFF;
  data[2] = (@Audio_ReceptionList_Changed_Parent_ID >> 8) & 0xFF;


  data[3] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
    data[4] = list_start;
    data[5] = elements;
    length = 6;
  }
  else if (IndexSize == 1)
  {
    data[4] = list_start & 0xFF;
    data[5] = (list_start >> 8) & 0xFF;
    data[6] = elements & 0xFF;
    data[7] = (elements >> 8) & 0xFF;
    
    length = 8;
  }
  
  // Daten auffüllen
  if (length_val > 0)
  {
    for (i=0; i < length_val; i++)
      data[length++] = data_val[i];
  }
  
  SendRequestByteSequence(LSGID_Audio, 0x17, Changed_REQ, length, data);
}

on timer Delay_Audio_ReceptionList
{
  sendRequestByteSequence(LSGID_Audio, 0x17, Data_REQ, j_Audio_ReceptionList, Data_Audio_ReceptionList);
}

dword Audio_ReceptionList_Search_Pos(dword position)
{
  dword i;
        
  for (i = 0; i<Audio_ReceptionList_TotalListNum; i++)
  {
    if (position == Audio_ReceptionList[i].param1)
    {
      return i+1; // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}

byte getPI_TypeReceptionList(byte ListType)
{
  switch(ListType)
  {
      case 0x01: return 0x44; break;
      case 0x02: return 0x44; break;
      case 0x03: return 0x46; break;
      case 0x04: return 0x45; break;
      case 0x05: return 0x47; break;
      case 0x06: return 0x47; break;
      case 0x07: return 0x44; break;
      case 0x08: return 0x44; break;
      case 0x09: return 0x44; break;
      default: return 0x00;
  }
  return 0x00;
}

on envVar Env_Audio_ReceptionList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Audio_ReceptionList_FM_Path,          gAudio_ReceptionList_Path[0]);
    getValue(Env_Audio_ReceptionList_AM_Path,          gAudio_ReceptionList_Path[1]);
    getValue(Env_Audio_ReceptionList_DAB_Path,         gAudio_ReceptionList_Path[2]);
    getValue(Env_Audio_ReceptionList_SDARS_Path,       gAudio_ReceptionList_Path[3]);
    getValue(Env_Audio_ReceptionList_DVB_Path,         gAudio_ReceptionList_Path[4]);
    getValue(Env_Audio_ReceptionList_TV_Path,          gAudio_ReceptionList_Path[5]);
    getValue(Env_Audio_ReceptionList_AM_SW_Path,       gAudio_ReceptionList_Path[6]);
    getValue(Env_Audio_ReceptionList_AM_LW_Path,       gAudio_ReceptionList_Path[7]);
    getValue(Env_Audio_ReceptionList_OnlineRadio_Path, gAudio_ReceptionList_Path[8]);
    getValue(Env_Audio_ReceptionList_CommonList_Path,  gAudio_ReceptionList_Path[9]);
    Audio_ReceptionList_LoadArray();
  } 
}

on envVar Env_Audio_ReceptionList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Audio_ReceptionList_FM_Path,          gAudio_ReceptionList_Path[0]);
    getValue(Env_Audio_ReceptionList_AM_Path,          gAudio_ReceptionList_Path[1]);
    getValue(Env_Audio_ReceptionList_DAB_Path,         gAudio_ReceptionList_Path[2]);
    getValue(Env_Audio_ReceptionList_SDARS_Path,       gAudio_ReceptionList_Path[3]);
    getValue(Env_Audio_ReceptionList_DVB_Path,         gAudio_ReceptionList_Path[4]);
    getValue(Env_Audio_ReceptionList_TV_Path,          gAudio_ReceptionList_Path[5]);
    getValue(Env_Audio_ReceptionList_AM_SW_Path,       gAudio_ReceptionList_Path[6]);
    getValue(Env_Audio_ReceptionList_AM_LW_Path,       gAudio_ReceptionList_Path[7]);
    getValue(Env_Audio_ReceptionList_OnlineRadio_Path, gAudio_ReceptionList_Path[8]);;
    getValue(Env_Audio_ReceptionList_CommonList_Path,  gAudio_ReceptionList_Path[9]);
    Audio_ReceptionList_LoadArray();
    Audio_ReceptionList_Changed(0x8, 0x0, 0x0000, 0xFFFF, 0x0, dummy_data);    
  } 
}


// Audio 0x18 DedicatedAudioControl

Audio_DedicatedAudioControl(byte opcode, byte data[])
{
  byte ControlType, ListType, dedicatedAudioControlResult, PI_Type;
  dword AdditionalControlInformation;
  char Name[60], Frequenz[60], File;
  int i, offset;
  byte Result;

  if ((opcode == 2) && (Audio_Source == 1)) // ASG StartResult
  {
    ControlType = data[0];
    AdditionalControlInformation  = data[1] + data[2] * 256;
    ListType = data[3];
    gFsgHandle = AdditionalControlInformation;
    
    if (ListType==2)
      PresetList_Ref = gFsgHandle;
    
    if (ControlType == 0x00) // select list entry
    {
      if ((Audio_ReceptionList_available == 1) && (ListType == 1)) // Reception List
      {
        for (i = 0; i < Audio_ReceptionList[Audio_ReceptionList_Search_Pos(gFsgHandle)-1].param7_length; i++)
        {
          Name[i] = (char)Audio_ReceptionList[Audio_ReceptionList_Search_Pos(gFsgHandle)-1].param7[i]; 
        }
        Name[i] = 0;
        

        for (i = 0; i < Audio_ReceptionList[Audio_ReceptionList_Search_Pos(gFsgHandle)-1].param8_length; i++)
        {
          Frequenz[i] = (char)Audio_ReceptionList[Audio_ReceptionList_Search_Pos(gFsgHandle)-1].param8[i]; 
        }
        Frequenz[i] = 0;
      }
      
      if ((Audio_RadioTV_PresetList_available == 1) && (ListType == 2)) // Preset List
      {
        for (i = 0; i < Audio_RadioTVPresetList[Audio_RadioTVPresetList_Search_Pos(PresetList_Ref)-1].param5_length; i++)
        {
          Name[i] = (char)Audio_RadioTVPresetList[Audio_RadioTVPresetList_Search_Pos(PresetList_Ref)-1].param5[i]; 
        }
        Name[i] = 0;
      }
      
      if ((Audio_MediaBrowser_available == 1) && (ListType == 3)) // Media Browser
      {
        if (gFolder_Level > 0)
          offset = Audio_MediaBrowser_Search_Pos(gCurrentFolder[gFolder_Level -1]);
        else
          offset = 0;
        
        for (i = 0; i < Audio_MediaBrowser[Audio_MediaBrowser_Search_Pos(gFsgHandle)-1].param4_length; i++)
        {
          Name[i] = (char)Audio_MediaBrowser[Audio_MediaBrowser_Search_Pos(gFsgHandle)-1].param4[i]; 
        }
        Name[i] = 0;
      }
      
      if ((Audio_SiriusAlertList_available == 1) && (ListType == 5)) // Sirius Alert List
      {
        for (i = 0; i < Audio_SiriusAlertList[Audio_SiriusAlertList_Search_Pos(gFsgHandle)-1].param4_length; i++)
        {
          Name[i] = (char)Audio_SiriusAlertList[Audio_SiriusAlertList_Search_Pos(gFsgHandle)-1].param4[i]; 
        }
        Name[i] = 0;
      }
      
      if ((Audio_LastStationList_available == 1) && (ListType == 6)) // LastStationList
      {
        for (i = 0; i < Audio_LastStationList[Audio_LastStationList_Search_Pos(gFsgHandle)-1].param5_length; i++)
        {
          Name[i] = (char)Audio_LastStationList[Audio_LastStationList_Search_Pos(gFsgHandle)-1].param5[i]; 
        }
        Name[i] = 0;
        
        for (i = 0; i < Audio_LastStationList[Audio_LastStationList_Search_Pos(gFsgHandle)-1].param6_length; i++)
        {
          Frequenz[i] = (char)Audio_LastStationList[Audio_LastStationList_Search_Pos(gFsgHandle)-1].param6[i]; 
        }
        Frequenz[i] = 0;
      }
      
      if ((Audio_FavoriteList_available == 1) && (ListType == 7)) // Favorite List
      {
        for (i = 0; i < Audio_FavoriteList[Audio_FavoriteList_Search_Pos(gFsgHandle)-1].param5_length; i++)
        {
          Name[i] = (char)Audio_FavoriteList[Audio_FavoriteList_Search_Pos(gFsgHandle)-1].param5[i]; 
        }
        Name[i] = 0;
        
        for (i = 0; i < Audio_FavoriteList[Audio_FavoriteList_Search_Pos(gFsgHandle)-1].param6_length; i++)
        {
          Frequenz[i] = (char)Audio_FavoriteList[Audio_FavoriteList_Search_Pos(gFsgHandle)-1].param6[i]; 
        }
        Frequenz[i] = 0;
      }
    }
    
    switch (ControlType)
    {
      case 0x00: // select list entry

        if ((Audio_ReceptionList_available == 1) && (ListType == 1)) // ReceptionList
        {
          gFsgHandle = AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_ReceptionList_Search_Pos(AdditionalControlInformation);
          putValue(P_FSG_49_0_0_22_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_22_2_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle_Status(AdditionalControlInformation, gFsgHandle_absolutePosition, 0x00, 0x00, 0x00, 0x00);
        }
        else if ((Audio_RadioTV_PresetList_available == 1) && (ListType == 2)) // PresetList
        {
          PresetList_Ref = AdditionalControlInformation;
          PresetList_absolutePosition = Audio_RadioTVPresetList_Search_Pos( PresetList_Ref) +1;
          putValue(P_FSG_49_0_0_22_3_range, PresetList_Ref);
          putValue(P_FSG_49_0_0_22_4_range, PresetList_absolutePosition);
          Audio_CurrentStation_Handle_Status(0x00, 0x00, PresetList_Ref, PresetList_absolutePosition, 0x00, 0x00);
        }
        else if ((Audio_MediaBrowser_available == 1) && (ListType == 3)) // MediaBrowser
        {
          gFsgHandle = AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_MediaBrowser_Search_Pos( AdditionalControlInformation) - offset + 1;
          putValue(P_FSG_49_0_0_22_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_22_2_range, gFsgHandle_absolutePosition);
           Audio_CurrentStation_Handle_Status(AdditionalControlInformation, gFsgHandle_absolutePosition, 0x00, 0x00, 0x00, 0x00);
        }
        else if ((Audio_SiriusAlertList_available == 1) && (ListType == 5)) // SiriusAlertList
        {
          gFsgHandle = AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_SiriusAlertList_Search_Pos( AdditionalControlInformation) - offset + 1;
          putValue(P_FSG_49_0_0_51_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_51_2_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle2_Status(AdditionalControlInformation, gFsgHandle_absolutePosition, 0x00, 0x00);
        }
        else if ((Audio_LastStationList_available == 1) && (ListType == 6)) // LastStationList
        {
          gFsgHandle = AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_LastStationList_Search_Pos( AdditionalControlInformation) - offset + 1;
          putValue(P_FSG_49_0_0_51_3_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_51_4_range, gFsgHandle_absolutePosition);
           Audio_CurrentStation_Handle2_Status(0x00, 0x00, gFsgHandle, gFsgHandle_absolutePosition);
        }
        else if ((Audio_FavoriteList_available == 1) && (ListType == 7)) // FavoriteList
        {
          gFsgHandle = AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_FavoriteList_Search_Pos( AdditionalControlInformation) - offset + 1;
          putValue(P_FSG_49_0_0_55_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_55_2_range, gFsgHandle_absolutePosition);
           Audio_CurrentStation_Handle3_Status(AdditionalControlInformation, gFsgHandle_absolutePosition, 0x00, 0x00, 0x00, 0x00);
        }
        
        
      break;
                              
      case 0x01: // next
          
        if ((Audio_ReceptionList_available == 1) && (ListType == 1)) // ReceptionList
        {
          gFsgHandle = gFsgHandle + AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_ReceptionList_Search_Pos(gFsgHandle)+ 1;
          putValue(P_FSG_49_0_0_22_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_22_2_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle_Status(AdditionalControlInformation,  gFsgHandle_absolutePosition, 0x00, 0x00, 0x00, 0x00);
        }
        else if ((Audio_RadioTV_PresetList_available == 1) && (ListType == 2)) // PresetList
        {
          PresetList_Ref = PresetList_Ref + AdditionalControlInformation;
          PresetList_absolutePosition = Audio_RadioTVPresetList_Search_Pos( PresetList_Ref) + 1;
          putValue(P_FSG_49_0_0_22_3_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_22_4_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle_Status(0x00, 0x00, PresetList_Ref, PresetList_absolutePosition, 0x00, 0x00);
        }
        else if ((Audio_MediaBrowser_available == 1) && (ListType == 3)) // MediaBrowser
        {
          gFsgHandle = gFsgHandle + AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_MediaBrowser_Search_Pos( gFsgHandle) - offset + 1;
          putValue(P_FSG_49_0_0_22_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_22_2_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle_Status(AdditionalControlInformation,  gFsgHandle_absolutePosition, 0x00, 0x00, 0x00, 0x00);
        }
        else if ((Audio_SiriusAlertList_available == 1) && (ListType == 5)) // SiriusAlertList
        {
          gFsgHandle = gFsgHandle + AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_SiriusAlertList_Search_Pos( gFsgHandle) - offset + 1;
          putValue(P_FSG_49_0_0_51_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_51_2_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle2_Status(AdditionalControlInformation,  gFsgHandle_absolutePosition, 0x00, 0x00);
        }
        else if ((Audio_LastStationList_available == 1) && (ListType == 6)) // LastStationList
        {
          gFsgHandle = gFsgHandle + AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_LastStationList_Search_Pos( gFsgHandle) - offset + 1;
          putValue(P_FSG_49_0_0_51_3_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_51_4_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle2_Status(0x00, 0x00, AdditionalControlInformation,  gFsgHandle_absolutePosition);
        }
        else if ((Audio_FavoriteList_available == 1) && (ListType == 7)) // FavoriteList
        {
          gFsgHandle = gFsgHandle + AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_FavoriteList_Search_Pos( gFsgHandle) - offset +1;
          putValue(P_FSG_49_0_0_55_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_55_2_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle3_Status(AdditionalControlInformation,  gFsgHandle_absolutePosition, 0x00, 0x00, 0x00, 0x00);
        }
        
      break;

      case 0x02: // previous

        if ((Audio_ReceptionList_available == 1) && (ListType == 1)) // ReceptionList
        {
          gFsgHandle = gFsgHandle - AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_ReceptionList_Search_Pos(gFsgHandle)+1;
          putValue(P_FSG_49_0_0_22_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_22_2_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle_Status(AdditionalControlInformation, gFsgHandle_absolutePosition, 0x00, 0x00, 0x00, 0x00);
        }
        else if ((Audio_RadioTV_PresetList_available == 1) && (ListType == 2)) // PresetList
        {
          PresetList_Ref = PresetList_Ref - AdditionalControlInformation;
          PresetList_absolutePosition = Audio_RadioTVPresetList_Search_Pos( PresetList_Ref) +1;
          putValue(P_FSG_49_0_0_22_3_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_22_4_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle_Status(0x00, 0x00, PresetList_Ref, PresetList_absolutePosition, 0x00, 0x00);
        }
        else if ((Audio_MediaBrowser_available == 1) && (ListType == 3)) // MediaBrowser
        {
          gFsgHandle = gFsgHandle - AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_MediaBrowser_Search_Pos( gFsgHandle) - offset +1;
          putValue(P_FSG_49_0_0_22_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_22_2_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle_Status(AdditionalControlInformation, gFsgHandle_absolutePosition, 0x00, 0x00, 0x00, 0x00);
        }
        else if ((Audio_SiriusAlertList_available == 1) && (ListType == 5)) // SiriusAlertList
        {
          gFsgHandle = gFsgHandle - AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_SiriusAlertList_Search_Pos( gFsgHandle) - offset +1;
          putValue(P_FSG_49_0_0_51_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_51_2_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle2_Status(AdditionalControlInformation, gFsgHandle_absolutePosition, 0x00, 0x00);
        }
        else if ((Audio_LastStationList_available == 1) && (ListType == 6)) // LastStationList
        {
          gFsgHandle = gFsgHandle - AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_LastStationList_Search_Pos( gFsgHandle) - offset +1;
          putValue(P_FSG_49_0_0_51_3_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_51_4_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle2_Status(0x00, 0x00, AdditionalControlInformation, gFsgHandle_absolutePosition);
        }
        else if ((Audio_FavoriteList_available == 1) && (ListType == 7)) // FavoriteList
        {
          gFsgHandle = gFsgHandle - AdditionalControlInformation;
          gFsgHandle_absolutePosition = Audio_FavoriteList_Search_Pos( gFsgHandle) - offset +1;
          putValue(P_FSG_49_0_0_55_1_range, AdditionalControlInformation);
          putValue(P_FSG_49_0_0_55_2_range, gFsgHandle_absolutePosition);
          Audio_CurrentStation_Handle3_Status(AdditionalControlInformation, gFsgHandle_absolutePosition, 0x00, 0x00, 0x00, 0x00);
        }
        
        
      break;

      case 0x05: // update station list

        if ((gListType == 0x01) && (@P_FSG_49_0_0_16_1 == 0x01)) // ReceptionList FM
        {
          if (@P_FSG_49_0_0_14_3_0 == 1)
            Audio_DedicatedAudioControl_Result(0x01);
          else
            Audio_DedicatedAudioControl_Result(0x00);
        }
        
        if ((gListType == 0x01) && (@P_FSG_49_0_0_16_1 == 0x02)) // ReceptionList AM
        {
          if (@P_FSG_49_0_0_14_3_1 == 1)
            Audio_DedicatedAudioControl_Result(0x01);
          else
            Audio_DedicatedAudioControl_Result(0x00);
        }
        
        if ((gListType == 0x01) && (@P_FSG_49_0_0_16_1 == 0x03)) // ReceptionList DAB
        {
          if (@P_FSG_49_0_0_14_3_2 == 1)
            Audio_DedicatedAudioControl_Result(0x01);
          else
            Audio_DedicatedAudioControl_Result(0x00);
        }
        
        if ((gListType == 0x01) && ((@P_FSG_49_0_0_16_1 == 0x04) || (@P_FSG_49_0_0_16_1 == 0x05))) // ReceptionList SDARS
        {
          if (@P_FSG_49_0_0_14_3_3 == 1)
            Audio_DedicatedAudioControl_Result(0x01);
          else
            Audio_DedicatedAudioControl_Result(0x00);
        }
        
        if ((gListType == 0x01) && (@P_FSG_49_0_0_16_1 == 0x1A)) // ReceptionList AM-LW
        {
          if (@P_FSG_49_0_0_14_3_4 == 1)
            Audio_DedicatedAudioControl_Result(0x01);
          else
            Audio_DedicatedAudioControl_Result(0x00);
        }
        
        if ((gListType == 0x01) && (@P_FSG_49_0_0_16_1 == 0x19)) // ReceptionList AM-SW
        {
          if (@P_FSG_49_0_0_14_3_5 == 1)
            Audio_DedicatedAudioControl_Result(0x01);
          else
            Audio_DedicatedAudioControl_Result(0x00);
        }
        
        if ((gListType == 0x01) && ((@P_FSG_49_0_0_16_1 == 0x09) || (@P_FSG_49_0_0_16_1 == 0x17) || (@P_FSG_49_0_0_16_1 == 0x18))) // ReceptionList TV / DVB
        {
          if (@P_FSG_49_0_0_14_3_6 == 1)
            Audio_DedicatedAudioControl_Result(0x01);
          else
            Audio_DedicatedAudioControl_Result(0x00);
        }
        
        if ((gListType == 0x01) && (@P_FSG_49_0_0_16_1 == 0x23)) // ReceptionList Online Radio
        {
          if (@P_FSG_49_0_0_14_3_7 == 1)
            Audio_DedicatedAudioControl_Result(0x01);
          else
            Audio_DedicatedAudioControl_Result(0x00);
        }
        
      break;
        
      case 0x06: // cancel station list update
        
        Audio_DedicatedAudioControl_Result(@M_FSG_49_0_0_24_Result_1); 
                              
        bool_dedicatedAudioControl = TRUE;

      break;
    }
  }

  if ((opcode == 3) && (Audio_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    Result = @M_FSG_49_0_0_24_Result_1;
    sendRequest (LSGID_Audio, 0x18, Result_REQ, 1, Result);
  }
  
  if ((opcode == 4) && (Audio_Source == 2)) // FSG Result
  {
    dedicatedAudioControlResult = data[0];
    
    if (gFsgHandle > 0 && Audio_ReceptionList_available && ListType == 1) // ReceptionList
    {
      Audio_CurrentStationInfo_Status(Name,getPI_TypeReceptionList(gListType), 0,Frequenz,0x00,gCategory[Audio_ReceptionList[Audio_ReceptionList_Search_Pos(gFsgHandle)].Param6], 0x00,"",0) ;
      Audio_CurrentStationInfo2_Status(Name,getPI_TypeReceptionList(gListType), 0,Frequenz,0x00,gCategory[Audio_ReceptionList[Audio_ReceptionList_Search_Pos(gFsgHandle)].Param6], 0x00,"",0,"",0,"",0,"",0,"",0) ;
    }
        
    if (PresetList_Ref > 0 && Audio_RadioTV_PresetList_available && ListType == 2) // PresetList
    {
      Audio_CurrentStationInfo_Status(Name,Audio_RadioTVPresetList_getPI_Type(gWaveband[PresetList_Ref-1]), 0,"",0x00,"", 0x00,"",0) ;
      Audio_CurrentStationInfo2_Status(Name,Audio_RadioTVPresetList_getPI_Type(gWaveband[PresetList_Ref-1]), 0,"",0x00,"", 0x00,"",0,"",0,"",0,"",0,"",0) ;
    }
    
    if (gFsgHandle > 0 && Audio_MediaBrowser_available && ListType == 3) // MediaBrowser
    {
      Audio_CurrentStationInfo_Status(Name,gFileType[gFsgHandle-1], 0,"",0x00,"", 0x00,"",0) ;
      Audio_CurrentStationInfo2_Status(Name,gFileType[gFsgHandle-1], 0,"",0x00,"", 0x00,"",0,"",0,"",0,"",0,"",0) ;
    }
    
    if (gFsgHandle > 0 && Audio_SiriusAlertList_available && ListType == 5) // SiriusAlertList
    {
      Audio_CurrentStationInfo_Status(Name,gFileType[gFsgHandle-1], 0,"",0x00,"", 0x00,"",0) ;
      Audio_CurrentStationInfo2_Status(Name,gFileType[gFsgHandle-1], 0,"",0x00,"", 0x00,"",0,"",0,"",0,"",0,"",0) ;
    }
    
    if (gFsgHandle > 0 && Audio_LastStationList_available && ListType == 6) // LastStationList
    {
      Audio_CurrentStationInfo_Status(Name,gFileType[gFsgHandle-1], 0,"",0x00,"", 0x00,"",0) ;
      Audio_CurrentStationInfo2_Status(Name,gFileType[gFsgHandle-1], 0,"",0x00,"", 0x00,"",0,"",0,"",0,"",0,"",0) ;
    }
    
    if (gFsgHandle > 0 && Audio_FavoriteList_available && ListType == 7) // FavoriteList
    {
      Audio_CurrentStationInfo_Status(Name,gFileType[gFsgHandle-1], 0,"",0x00,"", 0x00,"",0) ;
      Audio_CurrentStationInfo2_Status(Name,gFileType[gFsgHandle-1], 0,"",0x00,"", 0x00,"",0,"",0,"",0,"",0,"",0) ;
    }
  }
}

Audio_DedicatedAudioControl_Result (byte data)
{
  dword result;
  
  result = data;
   
  sendRequest(LSGID_Audio, 0x18, Result_REQ, Bap_uint8, result);
}






// Audio - 0x1D AnnouncementEscape

Audio_AnnouncementEscape (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Audio_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Audio_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // AnnouncementEscape Result senden
    Result = @M_FSG_49_0_0_29_Result_1;
    
    sendRequest (LSGID_Audio, 0x1D, Result_REQ, 1, Result);
  }
}


// Audio 0x1F ReceptionListType

Audio_PreferredList (byte opcode, byte data[])
{
    byte listType = 0x44;
    
    switch(data[0])
    {
        case 0x01:
            Audio_ReceptionList_LoadArray();
            break;
        case 0x02:
            Audio_RadioTVPresetList_LoadArray();
            break;
        case 0x03:
            Audio_SiriusAlertList_LoadArray();
            break;
        case 0x04:
            Audio_LastStationList_LoadArray();
            break;
        case 0x05:
            Audio_FavoriteList_LoadArray();
            break;
        default:
            Audio_ReceptionList_LoadArray();
            break;
    }
    
    
    
    // GVBP-193
    Audio_CurrentStationInfo2_Status(cInfo1,listType, 0,cInfo2,0x00,"", 0x00,"",0,"",0,"",0,"",0,"",0) ;
}

Audio_ReceptionListType (byte opcode, byte data[])
{  
   byte listType = 0x44;
    
   if ((opcode == 4) && (Audio_Source == 2)) // FSG Status
  {
    // wenn entsprechende ReceptionList nicht momentan aktiv
    if (data[0]<=11)
    {
      if (gListType != data[0] - 1)
      {
        gListType = data[0]-1;
        Audio_ReceptionList_LoadArray();
        
        switch(gListType + 1)
        {
            case 0x01:
                listType = 0x44;
            break;
            case 0x02:
                listType = 0x44;
            break;
            case 0x03:
                listType = 0x46;
            break;
            case 0x04:
                listType = 0x45;
            break;
            case 0x05:
                listType = 0x47;
            break;
            case 0x06:
                listType = 0x47;
            break;
            case 0x07:
                listType = 0x44;
            break;
            case 0x08:
                listType = 0x44;
            break;
            case 0x09:
                listType = 0x60;
            break;
            case 0x0a:
                listType = 0x60;
            break;
            case 0x0b:
                listType = 0x4b;
            break;
            default:
                listType = 0x50;
            break;
        }
        
        // GVBP-193
        Audio_CurrentStationInfo2_Status(cInfo1,listType, 0,cInfo2,0x00,"", 0x00,"",0,"",0,"",0,"",0,"",0) ;
      }
    }
  }
}

Audio_ReceptionListType_Status(byte Type)
{
  dword ReceptionListType;

  ReceptionListType = Type;

  sendRequest(LSGID_Audio, 0x1F, Data_REQ, Bap_uint8, ReceptionListType);
}


// Audio 0x20 Source List

Audio_SourceList_LoadArray ()
{
  /********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
  byte empty=0;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;

	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Audio_SourceList[i].Param1 = 0;
		Audio_SourceList[i].Param2 = 0;
		Audio_SourceList[i].Param3 = 0;
		Audio_SourceList[i].Param4 = 0;
		Audio_SourceList[i].Param5 = 0;
		for (j=0; j<61; j++)
			Audio_SourceList[i].Param6[j] = 0;
		Audio_SourceList[i].Param6_Length = 0;
	}
  
	/********* Laden der CSV-Datei ***********/
  
  // Pos von letztem  / ermitteln
  for (i = 0; i < strlen(gAudio_SourceList_Path); i++)
  {
    if (gAudio_SourceList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gAudio_SourceList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gAudio_SourceList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)


	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "SourceList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in SourceList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 65535) //ignore first line in *.csv file
					{
						Audio_SourceList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Audio_SourceList[current_CSV_line-1].Param2 = atol(temp2); //SourceType
						Audio_SourceList[current_CSV_line-1].Param3 = atol(temp3); //Instance_ID
						Audio_SourceList[current_CSV_line-1].Param4 = atol(temp4); //MediaType
						Audio_SourceList[current_CSV_line-1].Param5 = atol(temp5); //Attributes
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 65535)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //SourceType
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Instance_ID
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //MediaType
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Attributes
								if ( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //Name
								if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_SourceList_ListFormat == 1) )
                  {
                    Audio_SourceList[current_CSV_line-1].Param6[paramPos++] = buffer_byte[filePos++];
                    Audio_SourceList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_SourceList_ListFormat == 0) )
                  {
                    Audio_SourceList[current_CSV_line-1].Param6[paramPos++] = 0xC2;
                    Audio_SourceList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_SourceList_ListFormat == 0) )
                  {
                    Audio_SourceList[current_CSV_line-1].Param6[paramPos++] = 0xC3;
                    Audio_SourceList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_SourceList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                  }
									Audio_SourceList[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}
    
		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  Audio_SourceList_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Audio_SourceList(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements;

  if ((opcode == 1) && (Audio_Source == 1)) // ASG GetArray
  {
    ASG_ID = (data[0] >> 4) & 0xF;
    TAID = data[0] & 0xF;
    mode = (data[1] >> 4) & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = (mode>>3) & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
    
    if (IndexSize == 0)
    {
      list_start = data[2] ;
      elements = data[3];               
    }
    else if (IndexSize == 1)
    {
      list_start = data[3] * 256 + data[2];
      elements = data[5] * 256 + data[4];
    }
            
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////
    
    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_49_0_0_32_1 = ASG_ID;  // Set to panel value
    else
      ASG_ID = @A_FSG_49_0_0_32_1; // Set from panel value
      
    if (@env_AutoGetArray_TAID == 0)  // TAID
      @A_FSG_49_0_0_32_2 = TAID;
    else
      TAID = @A_FSG_49_0_0_32_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
      @A_FSG_49_0_0_32_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_49_0_0_32_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
      @A_FSG_49_0_0_32_Shift = (mode>>0);
    else
      mode = ((@A_FSG_49_0_0_32_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
      @A_FSG_49_0_0_32_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_49_0_0_32_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start
      @A_FSG_49_0_0_32_Start = list_start;
    else
      list_start = @A_FSG_49_0_0_32_Start;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        
            
    if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
    {
      Audio_SourceList_Status(ASG_ID, TAID, mode, recordaddress, list_start, elements);
    }
  }
}

Audio_SourceList_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{   
  byte string[60];
  byte IndexSize, shift, direction;
  int startposition=0, endposition=0, elements ;
  byte sequenceNumber = 0;
  byte j_max = 0, j_temp;
  
  int i=0, k, strctr;
  int stringsize;

  j_max = 0;

  elements = received_elements;

  Data_Audio_SourceList[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Audio_SourceList[1] = (Audio_SourceList_TotalListNum & 0xFF);
  Data_Audio_SourceList[2] = (Audio_SourceList_TotalListNum >>  8) & 0xFF;
  Data_Audio_SourceList[3] = (mode|0x4)*16 + (recordaddress & 0xF);
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
    
  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift; 
        endposition = startposition + elements - 1; 
      }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Audio_SourceList_Search_Pos(list_start) != 0)
        {
          startposition = Audio_SourceList_Search_Pos(list_start) - 1 + shift;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
      
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Audio_SourceList_TotalListNum)
      {
        endposition = Audio_SourceList_TotalListNum - 1;
        elements = Audio_SourceList_TotalListNum - startposition;
      }
            
    break;
    
    case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Audio_SourceList_Search_Pos(list_start) != 0)
        {
          startposition = Audio_SourceList_Search_Pos(list_start) - 1 - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Audio_SourceList_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
    break;
  }
    
  // Start & Elemente in Abhängigkeit von IndexSize befüllen
  if (IndexSize == 0)
  {
    Data_Audio_SourceList[4] = list_start & 0xFF;
    Data_Audio_SourceList[5] = elements & 0xFF;

    j_Audio_SourceList = 6;
  }
  else
  {
    Data_Audio_SourceList[5] = (list_start >> 8) & 0xFF;
    Data_Audio_SourceList[4] = list_start & 0xFF;
    Data_Audio_SourceList[7] = (elements >> 8) & 0xFF;
    Data_Audio_SourceList[6] = elements & 0xFF;
    
    j_Audio_SourceList = 8;
  }

  switch(direction)
  {
    case 0:

      for (i = startposition ; i <= endposition && i >= 0 && j_max == 0 ; i++)
      {
        j_temp = j_Audio_SourceList; // aktuelle Länge zwischenspeichern
          
        if (list_start == 0)
        {
          switch(IndexSize) // Pos
          {
            case 0:
                Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param1;
                break;
              
            case 1:
                Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param1 &0xFF;
                Data_Audio_SourceList[j_Audio_SourceList++] = (Audio_SourceList[i].param1 >> 8)&0xFF;
                break;
          }
        }
        
        else
        {
          switch(IndexSize) // Pos
          {
            case 0:
                Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param1;
                break;
            case 1:
                Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param1 &0xFF;
                Data_Audio_SourceList[j_Audio_SourceList++] = (Audio_SourceList[i].param1 >> 8)&0xFF;
                break;
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // SourceType
            Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Instance_ID
            Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param3;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x4) // MediaType
            Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param4;
        
        if (recordaddress == 0x0 ||recordaddress == 0x1 || recordaddress == 0x3) // Attributes
            Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param5;
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // Name
        {
          Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param6_Length;
          stringsize = Audio_SourceList[i].param6_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param6[strctr];            
          }
        }
        
        if (j_Audio_SourceList > 200) // wenn Länge > 255 rücksetzen, da sonst Überlauf
        {
          j_max = 1;
          j_Audio_SourceList = j_temp;
          elements = i-startposition; // Elemente anpassen
        
        if (IndexSize == 0)
          Data_Audio_SourceList[5] = elements & 0xFF;
        
        if (IndexSize == 1)
        {
          Data_Audio_SourceList[7] = (elements >> 8) & 0xFF;
          Data_Audio_SourceList[6] = elements & 0xFF;}
        }
      }
      
    break;
            
    case 1:
              
      for (i = startposition ; i >= endposition && i >= 0 && j_max == 0 ; i--)
      {
        j_temp = j_Audio_SourceList; // aktuelle Länge zwischenspeichern
          
        switch(IndexSize) // Pos
        {
          case 0:
              Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param1;
              break;
          case 1:
              Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param1 &0xFF;
              Data_Audio_SourceList[j_Audio_SourceList++] = (Audio_SourceList[i].param1 >> 8)&0xFF;
              break;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // SourceType
            Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Instance_ID
            Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param3;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x4) // MediaType
            Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param4;
        
        if (recordaddress == 0x0 ||recordaddress == 0x1 || recordaddress == 0x3) // Attributes
            Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param5;
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // Name
        {
          Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param6_Length;
          stringsize = Audio_SourceList[i].param6_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_SourceList[j_Audio_SourceList++] = Audio_SourceList[i].param6[strctr];            
          }
        }
                
        if (j_Audio_SourceList > 200) // wenn Länge > 255 rücksetzen, da sonst Überlauf
        {
          j_max = 1;
          j_Audio_SourceList = j_temp;
          elements = i-startposition;  // Elemente anpassen
          
          if (IndexSize == 0)
            Data_Audio_SourceList[5] = elements & 0xFF;
          
          if (IndexSize == 1)
          {
            Data_Audio_SourceList[7] = (elements >> 8) & 0xFF;
            Data_Audio_SourceList[6] = elements & 0xFF;
          }
        }
      }
      
    break;
  }
  settimer(Delay_Audio_SouceList, @Env_Audio_SourceList_ListDelay);
}

Audio_SourceList_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
      data[1] = list_start;
      data[2] = elements;
      length = 3;
  }
  else if (IndexSize == 1)
  {
      data[1] = list_start & 0xFF;
      data[2] = (list_start >> 8) & 0xFF;
      data[3] = elements & 0xFF;
      data[4] = (elements >> 8) & 0xFF;
      
      length = 5;
  }
  SendRequestByteSequence(LSGID_Audio, 0x20, Changed_REQ, length, data);
}

on timer Delay_Audio_SouceList
{
  sendRequestByteSequence(LSGID_Audio, 0x20, Data_REQ, j_Audio_SourceList, Data_Audio_SourceList);
}

byte getListType(byte SourceType)  // Tabelle nach ILH_6132
{
  switch(SourceType)
  {
    case 0x01: return 0x01; break; //FM -> FM reception list
    case 0x02: return 0x02; break; //AM -> AM reception list
    case 0x03: return 0x03; break; //DAB -> DAB reception list
    case 0x04: return 0x04; break; //SDARS-XM -> SDARS reception list
    case 0x05: return 0x04; break; //SDARS-SIRIUS -> SDARS reception list
    case 0x09: return 0x06; break; //TV -> TV reception list
    case 0x0C: return 0x01; break; //TP-Memo / TIM -> FM reception list
    case 0x11: return 0x02; break; //AM-TI (Japan) -> AM reception list
    case 0x17: return 0x06; break; //TV -> TV reception list
    case 0x18: return 0x06; break; //TV -> TV reception list
    case 0x19: return 0x07; break; //AM-SW -> AM-SW reception list
    case 0x1A: return 0x08; break; //AM-LW -> AM-LW reception list
    case 0x23: return 0x09; break; //online radio -> online radio reception list
    case 0x24: return 0x0A; break; //CommonList -> CommonList
  }
  return 0x00;
}

dword Audio_SourceList_Search_Pos (dword position)
{
  dword i;
  
  for (i = 0; i<Audio_SourceList_TotalListNum; i++)
  {
    if (position == Audio_SourceList[i].param1)
    { 
      return i + 1;  // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}

byte getSourceType (dword SourceList_Reference)
{
  dword position;    

  position = Audio_SourceList_Search_Pos (SourceList_Reference);

  return Audio_SourceList[position].param2;

}

on envVar Env_Audio_SourceList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Audio_SourceList_Path,gAudio_SourceList_Path);
    Audio_SourceList_LoadArray();
  } 
}

on envVar Env_Audio_SourceList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Audio_SourceList_Path,gAudio_SourceList_Path);
    Audio_SourceList_LoadArray();
    Audio_SourceList_Changed(0x8,0x0, 0x0000, 0xFFFF);    
  } 
}


// Audio 0x21 RadioTV_PresetList

Audio_RadioTVPresetList_LoadArray()
{     
    /********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
    //putValue(A_FSG_49_0_0_33_fileSelector, Env_Audio_RadioTVPresetList_Path);
    //putValue(A_FSG_49_0_0_33_loadArray_Btn, TRUE);
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Audio_RadioTVPresetList[i].Param1 = 0;
		Audio_RadioTVPresetList[i].Param2 = 0;
		Audio_RadioTVPresetList[i].Param3 = 0;
		Audio_RadioTVPresetList[i].Param4 = 0;
		for (j=0; j<49; j++)
			Audio_RadioTVPresetList[i].Param5[j] = 0;
		Audio_RadioTVPresetList[i].Param5_Length = 0;
		
	}

	/********* Laden der CSV-Datei ***********/
  for (i = 0; i < strlen(gAudio_RadioTVPresetList_Path); i++)
  {
    if (gAudio_RadioTVPresetList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gAudio_RadioTVPresetList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gAudio_RadioTVPresetList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "PresetList"
		{
     if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
            
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in PresetList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{  
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Audio_RadioTVPresetList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Audio_RadioTVPresetList[current_CSV_line-1].Param2 = atol(temp2); //PresetIndex
						Audio_RadioTVPresetList[current_CSV_line-1].Param3 = atol(temp3); //Waveband
            gWaveband[current_CSV_line-1] = atol(temp3);
						Audio_RadioTVPresetList[current_CSV_line-1].Param4 = atol(temp4); //Attributes
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PresetIndex
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Waveband
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //Attributes
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Name
								if (paramPos < 48)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_RadioTVPresetList_ListFormat == 1) )
                  {
                    Audio_RadioTVPresetList[current_CSV_line-1].Param5[paramPos++] = buffer_byte[filePos++];
                    Audio_RadioTVPresetList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_RadioTVPresetList_ListFormat == 0) )
                  {
                    Audio_RadioTVPresetList[current_CSV_line-1].Param5[paramPos++] = 0xC2;
                    Audio_RadioTVPresetList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_RadioTVPresetList_ListFormat == 0) )
                  {
                    Audio_RadioTVPresetList[current_CSV_line-1].Param5[paramPos++] = 0xC3;
                    Audio_RadioTVPresetList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_RadioTVPresetList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                  }
									Audio_RadioTVPresetList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
    }
      
		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  Audio_RadioTVPresetList_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
  
  putValue(P_FSG_49_0_0_22_1_range, Audio_RadioTVPresetList[0].Param1);
  putValue(P_FSG_49_0_0_22_2_range, Audio_RadioTVPresetList[0].Param1);
  
  putValue(P_FSG_49_0_0_51_1_range, Audio_RadioTVPresetList[0].Param1);
  putValue(P_FSG_49_0_0_51_2_range, Audio_RadioTVPresetList[0].Param1);
  putValue(P_FSG_49_0_0_51_3_range, Audio_RadioTVPresetList[0].Param1);
  putValue(P_FSG_49_0_0_51_4_range, Audio_RadioTVPresetList[0].Param1);
  
  putValue(P_FSG_49_0_0_55_1_range, Audio_RadioTVPresetList[0].Param1);
  putValue(P_FSG_49_0_0_55_2_range, Audio_RadioTVPresetList[0].Param1);

  for(i=0;i<elcount(cInfo1); i++)
  {
  cInfo1[i] = 0;
  }
  
  for(i=0;i<elcount(cInfo2); i++)
  {
  cInfo2[i] = 0;
  }

  for(i=0;i<Audio_RadioTVPresetList[0].Param5_Length; i++)
  {
  u8Info1[i] = Audio_RadioTVPresetList[0].Param5[i];
  cInfo1[i] = Audio_RadioTVPresetList[0].Param5[i];
  }
  
  putValue(P_FSG_49_0_0_54_2, 0x44);
  putValue(P_FSG_49_0_0_54_1, u8Info1, Audio_RadioTVPresetList[0].Param5_Length);
}

Audio_RadioTVPresetList(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements;

  if ((opcode == 1) && (Audio_Source == 1)) // ASG GetArray
  {
    ASG_ID = (data[0] >> 4) & 0xF;
    TAID = data[0] & 0xF;
    mode = (data[1] >> 4) & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = (mode>>3) & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
    
    list_start = data[2] ;
    elements = data[3];               

    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////
    
    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_49_0_0_33_1 = ASG_ID;  // Set to panel value
    else
      ASG_ID = @A_FSG_49_0_0_33_1; // Set from panel value
      
    if (@env_AutoGetArray_TAID == 0)  // TAID
      @A_FSG_49_0_0_33_2 = TAID;
    else
      TAID = @A_FSG_49_0_0_33_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
      @A_FSG_49_0_0_33_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_49_0_0_33_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
      @A_FSG_49_0_0_33_Shift = (mode>>0);
    else
      mode = ((@A_FSG_49_0_0_33_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
      @A_FSG_49_0_0_33_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_49_0_0_33_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start
      @A_FSG_49_0_0_33_Start = list_start;
    else
      list_start = @A_FSG_49_0_0_33_Start;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
    {
      Audio_RadioTVPresetList_Status(ASG_ID, TAID, mode, recordaddress, list_start, elements);
    }
  }
}

Audio_RadioTVPresetList_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{   
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition=0, endposition=0, elements ;
  byte sequenceNumber = 0;
  byte j_max = 0, j_temp;
  
  int i, k , strctr; 
  int stringsize;
  
  j_max = 0;

  elements = received_elements;

  Data_Audio_RadioTVPresetList[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Audio_RadioTVPresetList[1] = (Audio_RadioTVPresetList_TotalListNum & 0xFF);
  Data_Audio_RadioTVPresetList[2] = (mode|0x4)*16 + (recordaddress & 0xF);
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift; 
        endposition = startposition + elements - 1; 
      }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Audio_RadioTVPresetList_Search_Pos(list_start) != 0)
        {
          startposition = Audio_RadioTVPresetList_Search_Pos(list_start) - 1 + shift;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Audio_RadioTVPresetList_TotalListNum)
      {
        endposition = Audio_RadioTVPresetList_TotalListNum - 1;
        elements = Audio_RadioTVPresetList_TotalListNum - startposition;
      }
      
    break;
    
    case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Audio_RadioTVPresetList_Search_Pos(list_start) != 0)
        {
          startposition = Audio_RadioTVPresetList_Search_Pos(list_start) - 1 - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Audio_RadioTVPresetList_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
    break;
  }
    
  // Start & Elemente befüllen
  Data_Audio_RadioTVPresetList[3] = list_start & 0xFF;
  Data_Audio_RadioTVPresetList[4] = elements & 0xFF;

  j_Audio_RadioTVPresetList = 5;
   
  switch(direction)
  {
    case 0:

      for (i = startposition ; i <= endposition && i >= 0 && j_max == 0; i++)
      {
        j_temp = j_Audio_RadioTVPresetList; // aktuelle Länge zwischenspeichern

        // Pos
        Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param1;

        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2) // PresetIndex
          Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Waveband
          Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param3;
        
        if (recordaddress == 0x0) // Attributes
        {
          Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param4 & 0xFF;
          Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = (Audio_RadioTVPresetList[i].param4 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2) // Name
        {
          Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param5_Length;
          stringsize = Audio_RadioTVPresetList[i].param5_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param5[strctr];            
          }
        }
          
        if (j_Audio_RadioTVPresetList > 200) // wenn Länge > 255 rücksetzen, da sonst Überlauf
        {
          j_max = 1;
          j_Audio_RadioTVPresetList = j_temp;
          elements = i-startposition;  // Elemente anpassen
          
          if (IndexSize == 0)
            Data_Audio_RadioTVPresetList[5] = elements & 0xFF;
          
          if (IndexSize == 1)
          {
            Data_Audio_RadioTVPresetList[7] = (elements >> 8) & 0xFF;
            Data_Audio_RadioTVPresetList[6] = elements & 0xFF;
          }
        }
      }
    break;
    
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0 && j_max == 0; i--)
      {
        j_temp = j_Audio_RadioTVPresetList; // aktuelle Länge zwischenspeichern

        // Pos
        Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param1;

        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2) // PresetIndex
          Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Waveband
          Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param3;
        
        if (recordaddress == 0x0) // Attributes
        {
          Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param4 & 0xFF;
          Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = (Audio_RadioTVPresetList[i].param4 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2) // Name
        {
          Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param5_Length;
          stringsize = Audio_RadioTVPresetList[i].param5_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_RadioTVPresetList[j_Audio_RadioTVPresetList++] = Audio_RadioTVPresetList[i].param5[strctr];            
          }
        }
                
        if (j_Audio_RadioTVPresetList > 200) // wenn Länge > 255 rücksetzen, da sonst Überlauf
        {
          j_max = 1;
          j_Audio_RadioTVPresetList = j_temp;
          elements = i-startposition;  // Elemente anpassen
          
          if (IndexSize == 0)
            Data_Audio_RadioTVPresetList[5] = elements & 0xFF;
          
          if (IndexSize == 1)
          {
            Data_Audio_RadioTVPresetList[7] = (elements >> 8) & 0xFF;
            Data_Audio_RadioTVPresetList[6] = elements & 0xFF;
          }
        }
      }
    break;
  }
  settimer(Delay_Audio_RadioTVPresetList, @Env_Audio_RadioTVPresetList_ListDelay);
}

Audio_RadioTVPresetList_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
    data[1] = list_start;
    data[2] = elements;
    length = 3;
  }
  else if (IndexSize == 1)
  {
    data[1] = list_start & 0xFF;
    data[2] = (list_start >> 8) & 0xFF;
    data[3] = elements & 0xFF;
    data[4] = (elements >> 8) & 0xFF;
    
    length = 5;
  }
  SendRequestByteSequence(LSGID_Audio, 0x21, Changed_REQ, length, data);
}

on timer Delay_Audio_RadioTVPresetList
{
  sendRequestByteSequence(LSGID_Audio, 0x21, Data_REQ, j_Audio_RadioTVPresetList, Data_Audio_RadioTVPresetList);
}

dword Audio_RadioTVPresetList_Search_Pos(dword position)
{
  int i;
  
  for (i = 0; i<Audio_RadioTVPresetList_TotalListNum; i++)
  {
    if (position == Audio_RadioTVPresetList[i].param1)
    {
       return i+1; // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}


byte Audio_RadioTVPresetList_getPI_Type(byte Waveband)
{
  switch(Waveband)
  {
    case 0x01: return 0x44; break; // FM
    case 0x02: return 0x44; break; // AM MW
    case 0x03: return 0x44; break; // AM SW
    case 0x04: return 0x44; break; // AM LW
    case 0x05: return 0x45; break; // SDARS XM
    case 0x06: return 0x45; break; // SDARS Sirius
    case 0x07: return 0x46; break; // DAB
    case 0x08: return 0x47; break; // DVB
    case 0x09: return 0x47; break; // TV
    case 0x0A: return 0x60; break; // online radio
    case 0x0B: return 0x44; break; // CommonList -> Zuorndung?
    default: return 0x00;
  }
  return 0x00;
}

on envVar Env_Audio_RadioTVPresetList_LoadBTN
{
  if (@this == 1)
  {
    getValue (Env_Audio_RadioTVPresetList_Path, gAudio_RadioTVPresetList_Path);
    Audio_RadioTVPresetList_LoadArray();   
  } 
}

on envVar Env_Audio_RadioTVPresetList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue (Env_Audio_RadioTVPresetList_Path, gAudio_RadioTVPresetList_Path);
    Audio_RadioTVPresetList_LoadArray();
    Audio_RadioTVPresetList_Changed (0x0,0x0, 0x0000, 0xFF);    
  } 
}


// Audio 0x22 SwitchSource

Audio_SwitchSource(byte opcode, byte data[])
{
  byte ListType, sourceType, TypeOfNumber, Number, List_State;
  byte ListAvailable, ListAvailable2;
  dword SourceList_Reference;
  byte Result;

  if ((opcode == 2) && (Audio_Source == 1)) // ASG StartResult
  {
    SourceList_Reference = data[1]*256 + data[0];
    previous_AudioSource = activeSource_Reference;
    activeSource_Reference = SourceList_Reference;
    ListType = getListType(Audio_SourceList[Audio_SourceList_Search_POS(SourceList_Reference)-1].param2);
    sourceType = getSourceType(SourceList_Reference);
    TypeOfNumber = Audio_SourceList[Audio_SourceList_Search_POS(SourceList_Reference)-1].param4;
    
    ListAvailable  = @P_FSG_49_0_0_16_4;
    List_State     = @P_FSG_49_0_0_16_5;
    ListAvailable2 = @P_FSG_49_0_0_16_6;
    Number         = @P_FSG_49_0_0_16_7;

    Audio_ActiveSource_Status(SourceList_Reference, TypeOfNumber, ListAvailable, List_State, ListAvailable2, Number);
  }
  
  if ((opcode == 3) && (Audio_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // SwitchSource Result senden
    Result = @M_FSG_49_0_0_34_Result_1;
    
    sendRequest (LSGID_Audio, 0x22, Result_REQ, 1, Result);
  }
}

// Audio 0x23 MediaBrowser_FolderLevel

Audio_MediaBrowser_FolderLevel_Status(byte FolderLevel,word Ref_MediaBrowser,word Ref_MediaBrowser_absolutePosition)
{
  byte data[5];
  
  data[0] = FolderLevel;
  data[1] = Ref_MediaBrowser & 0xFF;
  data[2] = (Ref_MediaBrowser >> 8) & 0xFF;
  data[3] = Ref_MediaBrowser_absolutePosition & 0xFF;
  data[4] = (Ref_MediaBrowser_absolutePosition >> 8) & 0xFF;

  SendRequestByteSequence(LSGID_Audio, 0x23, Data_REQ, 5, data);
}


// Audio 0x24 MediaBrowser

Audio_MediaBrowser_LoadArray ()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
    //putValue(A_FSG_49_0_0_36_fileSelector,  Env_Audio_MediaBrowser_Path);
    //putValue(A_FSG_49_0_0_36_loadArray_Btn, TRUE);
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Audio_MediaBrowser[i].Param1 = 0;
    Audio_MediaBrowser[i].Param2 = 0;
    Audio_MediaBrowser[i].Param3 = 0;
    
		for (j=0; j<33; j++)
			Audio_MediaBrowser[i].Param4[j] = 0;
		Audio_MediaBrowser[i].Param4_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gAudio_MediaBrowser_Path); i++)
  {
    if ( gAudio_MediaBrowser_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gAudio_MediaBrowser_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gAudio_MediaBrowser_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "MediaBrowser"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;

			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in MediaBrowser) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 65535) //ignore first line in *.csv file
					{
						Audio_MediaBrowser[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Audio_MediaBrowser[current_CSV_line-1].Param2 = atol(temp2); //FileType
            gFileType[current_CSV_line-1] = atol(temp2);
						Audio_MediaBrowser[current_CSV_line-1].Param3 = atol(temp3); //FileState
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 65535)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
                if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
            case 2: //FileType
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //FileState
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //FileName
								if (paramPos < 33)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_MediaBrowser_ListFormat == 1) )
                  {
                    Audio_MediaBrowser[current_CSV_line-1].Param4[paramPos++] = buffer_byte[filePos++];
                    Audio_MediaBrowser[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_MediaBrowser_ListFormat == 0) )
                  {
                    Audio_MediaBrowser[current_CSV_line-1].Param4[paramPos++] = 0xC2;
                    Audio_MediaBrowser[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_MediaBrowser_ListFormat == 0) )
                  {
                    Audio_MediaBrowser[current_CSV_line-1].Param4[paramPos++] = 0xC3;
                    Audio_MediaBrowser[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_MediaBrowser[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
                  }
									Audio_MediaBrowser[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  Audio_MediaBrowser_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Audio_MediaBrowser(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements, TotalListNum, activePosition;

  if ((opcode == 1) && (Audio_Source == 1)) // ASG GetArray
  {
    ASG_ID = (data[0] >> 4) & 0xF;
    TAID = data[0] & 0xF;
    mode = (data[1] >> 4) & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = (mode>>3) & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;

    if (IndexSize == 0)
    {
      list_start = data[2];
      elements = data[3];               
    }
    else if (IndexSize == 1)
    {
      list_start = data[3] * 256 + data[2];
      elements = data[5] * 256 + data[4];
    }
      
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_49_0_0_36_1 = ASG_ID;  // Set to panel value
    else
      ASG_ID = @A_FSG_49_0_0_36_1; // Set from panel value
      
    if (@env_AutoGetArray_TAID == 0)  // TAID
      @A_FSG_49_0_0_36_2 = TAID;
    else
      TAID = @A_FSG_49_0_0_36_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
      @A_FSG_49_0_0_36_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_49_0_0_36_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
      @A_FSG_49_0_0_36_Shift = (mode>>0);
    else
      mode = ((@A_FSG_49_0_0_36_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
      @A_FSG_49_0_0_36_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_49_0_0_36_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start
      @A_FSG_49_0_0_36_Start = list_start;
    else
      list_start = @A_FSG_49_0_0_36_Start;
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     
    if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
    {
      if (gFolder_Level >0)
        Audio_MediaBrowser_Status(ASG_ID, TAID, mode, recordaddress, list_start, elements, gActiveListPosition);        
      else
        Audio_MediaBrowser_Status(ASG_ID, TAID, mode, recordaddress, list_start, elements, 0xFFFF);
    }
  }
}

Audio_MediaBrowser_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements, dword activeListPosition)
{
  byte string[60];
  byte IndexSize, shift, direction;
  int startposition, endposition, elements, offset ;
  byte sequenceNumber = 0;  

  int i, k , strctr;
  int stringsize;
  
  mode = (mode|0x4);

  elements = received_elements;
  if (gFolder_Level > 0)
      offset = Audio_MediaBrowser_Search_Pos(gCurrentFolder[gFolder_Level-1] + 1);
  else
    offset = 0;
  
  Data_Audio_MediaBrowser[0] =  ASG_ID*16 + (TAID & 0xF);
  Data_Audio_MediaBrowser[1] =  Audio_MediaBrowser_TotalListNum & 0xFF;
  Data_Audio_MediaBrowser[2] = (Audio_MediaBrowser_TotalListNum >> 8) & 0xFF;
  Data_Audio_MediaBrowser[3] =  activeListPosition;
  Data_Audio_MediaBrowser[4] = (activeListPosition >> 8);
  Data_Audio_MediaBrowser[5] =  mode*16 + (recordaddress & 0xF);

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        if (shift == 1)
        {
          startposition = shift - 1; 
          endposition = startposition + elements - 1; 
        }
        else
        {
          startposition = shift; 
          endposition = startposition + elements - 1; 
        }
      }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Audio_MediaBrowser_Search_Pos(list_start) != 0)
        {
          startposition = Audio_MediaBrowser_Search_Pos(list_start) - 1 + shift;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
          
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Audio_MediaBrowser_TotalListNum)
      {
        endposition = Audio_MediaBrowser_TotalListNum - 1;
        elements = Audio_MediaBrowser_TotalListNum - startposition;
      }

    break;

    case 1: // Anfrage in neg. Richtung
  
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Audio_MediaBrowser_Search_Pos(list_start) != 0)
        {
          startposition = Audio_MediaBrowser_Search_Pos(list_start) - 1 - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Audio_MediaBrowser_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
    
    break;
  }
  
  if (IndexSize == 0)
  {
    Data_Audio_MediaBrowser[6] = list_start & 0xFF;
    Data_Audio_MediaBrowser[7] = elements & 0xFF;

    j_Audio_MediaBrowser = 8;
  }
  else
  {
    Data_Audio_MediaBrowser[7] = (list_start >> 8) & 0xFF;
    Data_Audio_MediaBrowser[6] = list_start & 0xFF;
    Data_Audio_MediaBrowser[9] = (elements >> 8) & 0xFF;
    Data_Audio_MediaBrowser[8] = elements & 0xFF;

    j_Audio_MediaBrowser = 10;
  }
  
  switch(direction)
  {
    case 0:
      
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        switch(IndexSize) // Pos
        {
          case 0: Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param1;
                  break;
          case 1: Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param1 & 0xFF;
                  Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = (Audio_MediaBrowser[i].param1 >> 8) & 0xFF;
                  break;
        }  
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // FileType
          Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // FileState
        {
          Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param3 & 0xFF;
          Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = (Audio_MediaBrowser[i].param3 >> 8) & 0xFF;
        }
        
          if (recordaddress == 0x0 || recordaddress == 0x2) // FileName
          {
            Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param4_Length;
            stringsize = Audio_MediaBrowser[i].param4_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param4[strctr];            
            }
          }
      }
      
    break;
      
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        switch(IndexSize) // Pos
        {
           case 0: Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param1;
                   break;
           case 1: Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param1 & 0xFF;
                   Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = (Audio_MediaBrowser[i].param1 >> 8) & 0xFF;
                   break;
        }  
      
        if (recordaddress == 0x0 || recordaddress == 0x1) // FileType
          Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // FileState
        {
          Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param3 & 0xFF;
          Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = (Audio_MediaBrowser[i].param3 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // FileName
        {
          Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param4_Length;
          stringsize = Audio_MediaBrowser[i].param4_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_MediaBrowser[j_Audio_MediaBrowser++] = Audio_MediaBrowser[i].param4[strctr];            
          }
        }
      }
      
    break;
  }
  settimer(Delay_Audio_MediaBrowser, @Env_Audio_MediaBrowser_ListDelay);
}

Audio_MediaBrowser_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
    data[1] = list_start;
    data[2] = elements;
    length = 3;
  }
  else if (IndexSize == 1)
  {
    data[1] = list_start & 0xFF;
    data[2] = (list_start >> 8) & 0xFF;
    data[3] = elements & 0xFF;
    data[4] = (elements >> 8) & 0xFF;
    length = 5;
  }
  SendRequestByteSequence(LSGID_Audio, 0x24, Changed_REQ, length, data);
}

on timer Delay_Audio_MediaBrowser
{
  sendRequestByteSequence(LSGID_Audio, 0x24, Data_REQ, j_Audio_MediaBrowser, Data_Audio_MediaBrowser);
}

dword Audio_MediaBrowser_Search_Pos(dword position)
{
  int i;     

  if (position == 0)
   return 0;

  for (i = 0; i< Max_Array_Size; i++)
  {
    if (position == Audio_MediaBrowser[i].param1)
    {
      return i+1; // +1, wegen Unterschied zu Fehlerwert
    }
  }
  return 0;
}


on envVar Env_Audio_MediaBrowser_LoadBTN
{
  if (@this == 1)
  {
    gFolder_Level = 0;
    getValue(Env_Audio_MediaBrowser_Path, gAudio_MediaBrowser_Path);
    Audio_MediaBrowser_LoadArray();
  } 
}

on envVar Env_Audio_MediaBrowser_LoadBTN_Full
{
  if (@this == 1)
  {
    gFolder_Level = 0;
    getValue(Env_Audio_MediaBrowser_Path, gAudio_MediaBrowser_Path);
    Audio_MediaBrowser_LoadArray();
    Audio_MediaBrowser_Changed(0x8,0x0, 0x0000, 0xFFFF);
  } 
}


// Audio 0x26 MediaBrowserControl

Audio_MediaBrowserControl (byte opcode, byte data[])
{
  byte Control;
  word Reference;
  byte Result;
  
  if ((opcode == 2) && (Audio_Source == 1)) // ASG StartResult
  {
    Control = data[0];
    Reference = data[1] + data[2] * 256;
                      
    switch(Control)
    {
      case 0x02: // go to parent directory
        
        gFolder_Level--;

        if (gFolder_Level > 0)
          gFsgHandle = gCurrentFolder[gFolder_Level-1] + 1;
        else
          gFsgHandle = 0;
        
        @P_FSG_49_0_0_35_1_range = gFolder_Level;
            
        Audio_MediaBrowser_FolderLevel_Status (@P_FSG_49_0_0_35_1_range, @P_FSG_49_0_0_35_2_range, @P_FSG_49_0_0_35_3_range);

      break;
                
      case 0x04: // open folder/playlist
        
        gCurrentFolder[gFolder_Level] = Reference;
        gFsgHandle = Reference;
        gActiveListPosition = 0xFFFF;
        gFolder_Level++;
        
        @P_FSG_49_0_0_35_1_range = gFolder_Level;
        
        Audio_MediaBrowser_FolderLevel_Status (@P_FSG_49_0_0_35_1_range, @P_FSG_49_0_0_35_2_range, @P_FSG_49_0_0_35_3_range);
        
      break;
    }
  }
  
  if ((opcode == 3) && (Audio_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // MediaBrowserControl Result senden
    Result = @M_FSG_49_0_0_38_Result_1;
    
    sendRequest (LSGID_Audio, 0x26, Result_REQ, 1, Result);
  }
}


// Audio 0x27 MediaFileInfo

Audio_MediaFileInfo (byte opcode, byte data[])
{
  byte Result;

  if ((opcode == 2) && (Audio_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Audio_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // MediaFileInfo Result senden
    Result = @M_FSG_49_0_0_39_Result_1;
    
    sendRequest (LSGID_Audio, 0x27, Result_REQ, 1, Result);
  }
}


// Audio 0x2C GetNextListPos

Audio_GetNextListPos(byte opcode, byte data[])
{
  long currentPos;
  long Offset;
  float fOffset;
  long nextPos;
  byte ListType;
  byte send_data_GNLP_Result[7];
  
  if ((opcode == 2) && (Audio_Source == 1)) // ASG StartResult
  {
    // Start Result auswerten
    currentPos = data[0] + data[1]*256;
    Offset = data[2] + data[3]*256;
    ListType = data[4];
    
    if (Offset > 0x0000 && Offset <= 0x7FFF)
      fOffset = Offset;
    if (Offset > 0x7FFF && Offset <= 0xFFFF)
      fOffset = Offset - 0xFFFF - 1;

    //writelineex(4,0,"GetNextListPos /// currentPos: %d / Offset: %x / fOffset: %f / ListType: %d",currentPos,Offset,fOffset,ListType);
  }
  
  if ((opcode == 3) && (Audio_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // GetNextListPos Result schicken
    
    // Result = successful
    send_data_GNLP_Result[0] = 0;
    
    // currentPos
    send_data_GNLP_Result[1] = currentPos & 0x00FF;
    send_data_GNLP_Result[2] = currentPos>>8 & 0x00FF;
    
    // nextPos
    switch (ListType)
    {
      case 0x00: // ReceptionList
        
        if (currentPos + fOffset > Audio_ReceptionList_TotalListNum)
          nextPos = Audio_ReceptionList_TotalListNum;
        if (currentPos + fOffset < 0)
          nextPos = 0;
        if ((currentPos + fOffset <= Audio_ReceptionList_TotalListNum) && (currentPos + fOffset >= 0))
          nextPos = currentPos + fOffset;
        
      break;
        
      case 0x01: // TpMemoList

      break;
        
      case 0x02: // SourceList
        
        if (currentPos + fOffset > Audio_SourceList_TotalListNum)
          nextPos = Audio_SourceList_TotalListNum;
        if (currentPos + fOffset < 0)
          nextPos = 0;
        if ((currentPos + fOffset <= Audio_SourceList_TotalListNum) && (currentPos + fOffset >= 0))
          nextPos = currentPos + fOffset;
        
      break;
        
      case 0x03: // RadioTV_PresetList
        
        if (currentPos + fOffset > Audio_RadioTVPresetList_TotalListNum)
          nextPos = Audio_RadioTVPresetList_TotalListNum;
        if (currentPos + fOffset < 0)
          nextPos = 0;
        if ((currentPos + fOffset <= Audio_RadioTVPresetList_TotalListNum) && (currentPos + fOffset >= 0))
          nextPos = currentPos + fOffset;
        
      break;
        
      case 0x04: // MediaBrowser
        
        if (currentPos + fOffset > Audio_MediaBrowser_TotalListNum)
          nextPos = Audio_MediaBrowser_TotalListNum;
        if (currentPos + fOffset < 0)
          nextPos = 0;
        if ((currentPos + fOffset <= Audio_MediaBrowser_TotalListNum) && (currentPos + fOffset >= 0))
          nextPos = currentPos + fOffset;
        
      break;
        
      case 0x05: // SiriusAlertList
        
        if (currentPos + fOffset > Audio_SiriusAlertList_TotalListNum)
          nextPos = Audio_SiriusAlertList_TotalListNum;
        if (currentPos + fOffset < 0)
          nextPos = 0;
        if ((currentPos + fOffset <= Audio_SiriusAlertList_TotalListNum) && (currentPos + fOffset >= 0))
          nextPos = currentPos + fOffset;
        
      break;
        
      case 0x06: // LastStationList
        
        if (currentPos + fOffset > Audio_LastStationList_TotalListNum)
          nextPos = Audio_LastStationList_TotalListNum;
        if (currentPos + fOffset < 0)
          nextPos = 0;
        if ((currentPos + fOffset <= Audio_LastStationList_TotalListNum) && (currentPos + fOffset >= 0))
          nextPos = currentPos + fOffset;
        
      break;
        
      case 0x07: // FavoriteList
        
        if (currentPos + fOffset > Audio_FavoriteList_TotalListNum)
          nextPos = Audio_FavoriteList_TotalListNum;
        if (currentPos + fOffset < 0)
          nextPos = 0;
        if ((currentPos + fOffset <= Audio_FavoriteList_TotalListNum) && (currentPos + fOffset >= 0))
          nextPos = currentPos + fOffset;
        
      break;
    }

    send_data_GNLP_Result[3] = nextPos & 0x00FF;
    send_data_GNLP_Result[4] = nextPos>>8 & 0x00FF;
    send_data_GNLP_Result[5] = nextPos & 0x00FF;
    send_data_GNLP_Result[6] = nextPos>>8 & 0x00FF;
    
    SendRequestByteSequence(LSGID_Audio, 0x2C, Result_REQ, 7, send_data_GNLP_Result);
  }
}


// Audio 0x2D MediaBrowser_SwitchRadioMedia

Audio_SwitchRadioMedia (byte opcode, byte data[])
{
  byte Result;
  
  if ((opcode == 2) && (Audio_Source == 1)) // ASG StartResult
  {
    // keine Uebernahme der Paramter noetig
  }
  
  if ((opcode == 3) && (Audio_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // SwitchRadioMedia Result senden
    Result = @M_FSG_49_0_0_45_Result_1;
    
    sendRequest (LSGID_Audio, 0x2D, Result_REQ, 1, Result);
  }
}


//// Audio 0x32 SiriusAlertList

on envVar Env_Audio_SiriusAlertList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Audio_SiriusAlertList_Path, gAudio_SiriusAlertList_Path);
    Audio_SiriusAlertList_LoadArray();
  } 
}

on envVar Env_Audio_SiriusAlertList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Audio_SiriusAlertList_Path, gAudio_SiriusAlertList_Path);
    Audio_SiriusAlertList_LoadArray();
    Audio_SiriusAlertList_Changed(0x8,0x0, 0x0000, 0xFFFF);
  } 
}

Audio_SiriusAlertList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp6[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
  
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */

		Audio_SiriusAlertList[i].Param1 = 0;
		Audio_SiriusAlertList[i].Param2 = 0;
		Audio_SiriusAlertList[i].Param3 = 0;
		for (j=0; j<49; j++)
			Audio_SiriusAlertList[i].Param4[j] = 0;
		Audio_SiriusAlertList[i].Param4_Length = 0;
		for (j=0; j<31; j++)
			Audio_SiriusAlertList[i].Param5[j] = 0;
		Audio_SiriusAlertList[i].Param5_Length = 0;
		Audio_SiriusAlertList[i].Param6 = 0;
		for (j=0; j<61; j++)
			Audio_SiriusAlertList[i].Param7[j] = 0;
		Audio_SiriusAlertList[i].Param7_Length = 0;
		for (j=0; j<2; j++)
			Audio_SiriusAlertList[i].Param8[j] = 0;
		Audio_SiriusAlertList[i].Param8_Length = 0;
	}
	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gAudio_SiriusAlertList_Path); i++)
  {
    if (gAudio_SiriusAlertList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gAudio_SiriusAlertList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gAudio_SiriusAlertList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
    //writelineEx(4, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "SiriusAlertList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
            
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in SiriusAlertList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 65535) //ignore first line in *.csv file
					{
						Audio_SiriusAlertList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Audio_SiriusAlertList[current_CSV_line-1].Param2 = atol(temp2); //Attributes
						Audio_SiriusAlertList[current_CSV_line-1].Param3 = atol(temp3); //PresetID
						Audio_SiriusAlertList[current_CSV_line-1].Param6 = atol(temp6); //AlertType
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp6[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 65535)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Attributes
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //PresetID
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //Name
								if (paramPos < 48)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_SiriusAlertList_ListFormat == 1) )
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param4[paramPos++] = buffer_byte[filePos++];
                    Audio_SiriusAlertList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_SiriusAlertList_ListFormat == 0) )
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param4[paramPos++] = 0xC2;
                    Audio_SiriusAlertList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_SiriusAlertList_ListFormat == 0) )
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param4[paramPos++] = 0xC3;
                    Audio_SiriusAlertList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
                  }
									Audio_SiriusAlertList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 5: //Frequency
								if (paramPos < 30)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_SiriusAlertList_ListFormat == 1) )
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param5[paramPos++] = buffer_byte[filePos++];
                    Audio_SiriusAlertList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_SiriusAlertList_ListFormat == 0) )
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param5[paramPos++] = 0xC2;
                    Audio_SiriusAlertList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_SiriusAlertList_ListFormat == 0) )
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param5[paramPos++] = 0xC3;
                    Audio_SiriusAlertList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                  }
									Audio_SiriusAlertList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 6: //AlertType
								if ( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //AlertName
								if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_SiriusAlertList_ListFormat == 1) )
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param7[paramPos++] = buffer_byte[filePos++];
                    Audio_SiriusAlertList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_SiriusAlertList_ListFormat == 0) )
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param7[paramPos++] = 0xC2;
                    Audio_SiriusAlertList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_SiriusAlertList_ListFormat == 0) )
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param7[paramPos++] = 0xC3;
                    Audio_SiriusAlertList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
                  }
									Audio_SiriusAlertList[current_CSV_line-1].Param7_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 8: //Extension
								if (paramPos < 1)
								{
									if ( buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3 ) 
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param8[paramPos++] = buffer_byte[filePos++];
                    Audio_SiriusAlertList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
                  }
                  else
                  {
                    Audio_SiriusAlertList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
                  }
                  
									Audio_SiriusAlertList[current_CSV_line-1].Param8_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}

  Audio_SiriusAlertList_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
  
  putValue(P_FSG_49_0_0_22_1_range, Audio_SiriusAlertList[0].Param1);
  putValue(P_FSG_49_0_0_22_2_range, Audio_SiriusAlertList[0].Param1);
  
  putValue(P_FSG_49_0_0_51_1_range, Audio_SiriusAlertList[0].Param1);
  putValue(P_FSG_49_0_0_51_2_range, Audio_SiriusAlertList[0].Param1);
  putValue(P_FSG_49_0_0_51_3_range, Audio_SiriusAlertList[0].Param1);
  putValue(P_FSG_49_0_0_51_4_range, Audio_SiriusAlertList[0].Param1);
  
  putValue(P_FSG_49_0_0_55_1_range, Audio_SiriusAlertList[0].Param1);
  putValue(P_FSG_49_0_0_55_2_range, Audio_SiriusAlertList[0].Param1);

  for(i=0;i<elcount(cInfo1); i++)
  {
  cInfo1[i] = 0;
  }
  
  for(i=0;i<elcount(cInfo2); i++)
  {
  cInfo2[i] = 0;
  }

  for(i=0;i<Audio_SiriusAlertList[0].Param4_Length; i++)
  {
  u8Info1[i] = Audio_SiriusAlertList[0].Param4[i];
  cInfo1[i] = Audio_SiriusAlertList[0].Param4[i];
  }
  
  for(i=0;i<Audio_SiriusAlertList[0].Param5_Length; i++)
  {
  u8Info2[i] = Audio_SiriusAlertList[0].Param5[i];
  cInfo2[i] = Audio_SiriusAlertList[0].Param5[i];
  }
  
  putValue(P_FSG_49_0_0_54_2, 0x44);
  putValue(P_FSG_49_0_0_54_1, u8Info1, Audio_SiriusAlertList[0].Param4_Length);
  putValue(P_FSG_49_0_0_54_4, u8Info2, Audio_SiriusAlertList[0].Param5_Length);
}

Audio_SiriusAlertList(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements;
  
  if ((opcode == 1) && (Audio_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
     
    if (IndexSize == 0)
    {
      list_start = data[2] ;
      elements = data[3];               
    }
   
    else if (IndexSize == 1)
    {
      list_start = data[3] * 256 + data[2];
      elements = data[5] * 256 + data[4];
    }
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_49_0_0_50_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_49_0_0_50_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_49_0_0_50_2 = TAID;
    else
      TAID = @A_FSG_49_0_0_50_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_49_0_0_50_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_49_0_0_50_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_49_0_0_50_Shift = (mode>>0);
    else
      mode = ((@A_FSG_49_0_0_50_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_49_0_0_50_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_49_0_0_50_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_49_0_0_50_Start = list_start;
    else
      list_start = @A_FSG_49_0_0_50_Start;
                    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    
    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      Audio_SiriusAlertList_Status(ASG_ID, TAID, mode, recordaddress,list_start, elements);
    }
  }
}

Audio_SiriusAlertList_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition, increment = 1, elements ;
  byte sequenceNumber = 0;
  
  int i, k , strctr; 
  int stringsize;   

  elements = received_elements;

  Data_Audio_SiriusAlertList[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Audio_SiriusAlertList[1] = (Audio_SiriusAlertList_TotalListNum & 0xFF);
  Data_Audio_SiriusAlertList[2] = (Audio_SiriusAlertList_TotalListNum<<8)& 0xFF;
  Data_Audio_SiriusAlertList[3] = (mode|0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction)
  {
    case 0:

      if (list_start == 0)
      {
        startposition =  shift; 
        endposition = startposition + elements-1; 
      }
      else if (list_start > 0)
      {
        startposition = Audio_SiriusAlertList_Search_Pos(list_start) - 1 + shift;
        endposition = startposition+ elements - 1;
      }

      if (endposition >= Audio_SiriusAlertList_TotalListNum)
      {
        elements = Audio_SiriusAlertList_TotalListNum - startposition;
        endposition = Audio_SiriusAlertList_TotalListNum -1;
      }

    break;
    
    case 1:
      
      if (list_start > 0)
      {
        startposition = Audio_SiriusAlertList_Search_Pos(list_start) - 1 - shift; 
        endposition = startposition - elements + 1; 
      }
      
      else if (list_start == 0)
      {
        startposition = Audio_SiriusAlertList_TotalListNum -1;
        endposition = startposition - elements + 1;
      }
      
      if (endposition < 0)
      {     
        elements = elements + endposition;
        endposition = 0;
      }
                
    break;
  }

  if (IndexSize == 0)
  {
    Data_Audio_SiriusAlertList[4] = list_start & 0xFF;
    Data_Audio_SiriusAlertList[5] = elements & 0xFF;

    j_Audio_SiriusAlertList = 6;
  }
  else
  {
    Data_Audio_SiriusAlertList[5] = (list_start >> 8) & 0xFF;
    Data_Audio_SiriusAlertList[4] = list_start & 0xFF;
    Data_Audio_SiriusAlertList[7] = (elements >> 8) & 0xFF;
    Data_Audio_SiriusAlertList[6] = elements & 0xFF;
  
    j_Audio_SiriusAlertList = 8;
  }

  switch(direction)
  {
    case 0:

      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        switch(IndexSize) // Pos
        {
          case 0: Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param1;
                  break;
          case 1: Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param1 &0xFF;
                  Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = (Audio_SiriusAlertList[i].param1 >> 8)&0xFF;
                  break;
        }
      
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x4 || recordaddress == 0x5)  //Attributes
        {
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param2 &0xFF;
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = (Audio_SiriusAlertList[i].param2 >> 8)&0xFF;
        }
                        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x5)  //PresetID
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param3;
        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x5) //Name
        {  
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param4_Length; 
          stringsize = Audio_SiriusAlertList[i].param4_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param4[strctr];
          }
        }
              
        if (recordaddress == 0x1 || recordaddress == 0x4 || recordaddress == 0x5) //Frquency
        {  
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param5_Length;
          stringsize = Audio_SiriusAlertList[i].param5_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param5[strctr]; 
          }
        }
        
        if (recordaddress == 0x5)  //AlertType
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param6;
        
        if (recordaddress == 0x5) //AlertName
        {  
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param7_Length;
          stringsize = Audio_SiriusAlertList[i].param7_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param7[strctr];
          } 
        }
              
        if (0==1) //Extension -> momentan nicht genutzt
        {
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param8_Length;
          stringsize = Audio_SiriusAlertList[i].param8_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param8[strctr]; 
          }
        }
      }
      
    break;   
                       
    case 1:
        
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        switch(IndexSize) // Pos
        {
          case 0: Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param1;  //Pos
                  break;
          case 1: Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param1 &0xFF;
                  Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = (Audio_SiriusAlertList[i].param1 >> 8)&0xFF;
                  break;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x4 || recordaddress == 0x5)  //Attributes
        {
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param2 &0xFF;
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = (Audio_SiriusAlertList[i].param2 >> 8)&0xFF;
        }
                        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x5)  //PresetID
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param3;
      
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3 || recordaddress == 0x5) //Name
        {  
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param4_Length;
          stringsize = Audio_SiriusAlertList[i].param4_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param4[strctr];
          } 
        }
              
        if (recordaddress == 0x1 || recordaddress == 0x4 || recordaddress == 0x5) //Frquency
        {  
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param5_Length;
          stringsize = Audio_SiriusAlertList[i].param5_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param5[strctr]; 
          } 
        }
        
        if (recordaddress == 0x5)  //AlertType
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param6;
        
        if (recordaddress == 0x5) //AlertName
        {  
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param7_Length;
          stringsize = Audio_SiriusAlertList[i].param7_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param7[strctr];
          } 
        }
        
        if (0==1) //Extension -> momentan nicht genutzt
        {  
          Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param8_Length;
          stringsize = Audio_SiriusAlertList[i].param8_Length;
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_SiriusAlertList[j_Audio_SiriusAlertList++] = Audio_SiriusAlertList[i].param8[strctr];
          }
        }
      }
      
    break;
  }
  settimer(Delay_Audio_SiriusAlertList, @Env_Audio_SiriusAlertList_ListDelay);
}

Audio_SiriusAlertList_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift;
  int startposition, endposition, increment = 1;
  byte sequenceNumber = 0;
  
  int i, strctr; 
  int stringsize;  

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  Data_Audio_SiriusAlertList[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
    Data_Audio_SiriusAlertList[1] = list_start;
    Data_Audio_SiriusAlertList[2] = elements;
    j_Audio_SiriusAlertList = 3;
  }
  else if (IndexSize == 1)
  {
    Data_Audio_SiriusAlertList[1] = list_start & 0xFF;
    Data_Audio_SiriusAlertList[2] = (list_start >> 8) & 0xFF;
    Data_Audio_SiriusAlertList[3] = elements & 0xFF;
    Data_Audio_SiriusAlertList[4] = (elements >> 8) & 0xFF;
    
    j_Audio_SiriusAlertList = 5;
  }
  
  SendRequestByteSequence(LSGID_Audio, 0x32, Changed_REQ, j_Audio_SiriusAlertList, Data_Audio_SiriusAlertList);
}

dword Audio_SiriusAlertList_Search_Pos (dword position)
{
  int i;
  
  for (i = 0; i < Audio_SiriusAlertList_TotalListNum; i++)
  {
    if (position == Audio_SiriusAlertList[i].param1)
    {
      return i+1; // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}

on timer Delay_Audio_SiriusAlertList
{
  sendRequestByteSequence(LSGID_Audio, 0x32, Data_REQ, j_Audio_SiriusAlertList, Data_Audio_SiriusAlertList);
}




// Audio 0x36 CurrentStationInfo2

Audio_CurrentStationInfo2_Status (char Information1[], byte Info_Type1, word Information1_ID, char Information2[], byte Info_Type2, char Information3[], byte Info_Type3, char Information4[], byte Info_Type4, char Information5[], byte Info_Type5, char Information6[], byte Info_Type6, char Information7[], byte Info_Type7, char Information8[], byte Info_Type8)
{
  byte Information1_length, Information2_length, Information3_length, Information4_length, Information5_length, Information6_length, Information7_length, Information8_length;
  byte data[BAP_BUFFERSIZE];
  byte StationInfoSwitches, StationProperties;
  int ChannelID;
  int i, j = 0;

  StationInfoSwitches = @P_FSG_49_0_0_21_10;
  StationProperties = @P_FSG_49_0_0_21_11;
  ChannelID = @P_FSG_49_0_0_21_12_range;
  
  Information1_length = strlen(Information1);
  Information2_length = strlen(Information2);
  Information3_length = strlen(Information3);
  Information4_length = strlen(Information4);
  
  j = 0;
  data[j++] = Information1_length; 

  for (i = 0; i < Information1_length; i++)
  {
    data[j++] = Information1[i];
  }
 
  data[j++] = Info_Type1;
  data[j++] = Information1_ID & 0xFF;
  data[j++] = (Information1_ID >> 8) & 0xFF;
  data[j++] = Information2_length;
   
  for (i = 0; i < Information2_length; i++)
  {
    data[j++] = Information2[i];
  }
  
  data[j++] = Info_Type2;
  data[j++] = Information3_length;

  for (i = 0; i < Information3_length; i++)
  {
    data[j++] = Information3[i];
  }
  
  data[j++] = Info_Type3;
  data[j++] = Information4_length;

  for (i = 0; i < Information4_length; i++)
  {
    data[j++] = Information4[i];
  }

  data[j++] = Info_Type4;
  data[j++] = Information5_length;

  for (i = 0; i < Information5_length; i++)
  {
    data[j++] = Information5[i];
  }

  data[j++] = Info_Type5;
  data[j++] = Information6_length;

  for (i = 0; i < Information6_length; i++)
  {
    data[j++] = Information6[i];
  }

  data[j++] = Info_Type6;
  data[j++] = Information7_length;

  for (i = 0; i < Information7_length; i++)
  {
    data[j++] = Information7[i];
  }

  data[j++] = Info_Type7;
  data[j++] = Information8_length;

  for (i = 0; i < Information8_length; i++)
  {
    data[j++] = Information8[i];
  }

  data[j++] = Info_Type8;
    
  data[j++] =  StationInfoSwitches;
  data[j++] = (StationInfoSwitches >> 8) & 0xFF;
  data[j++] =  StationProperties;
  data[j++] = (StationProperties >> 8) & 0xFF;
  data[j++] =  ChannelID;
  data[j++] = (ChannelID >> 8) & 0xFF;

  sendRequestByteSequence(LSGID_Audio, 0x36, Data_REQ, j, data);
}




// Audio 0x38 Last Station List

on envVar Env_Audio_LastStationList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Audio_LastStationList_Path, gAudio_LastStationList_Path);
    Audio_LastStationList_LoadArray();
  } 
}

on envVar Env_Audio_LastStationList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Audio_LastStationList_Path, gAudio_LastStationList_Path);
    Audio_LastStationList_LoadArray();
    Audio_LastStationList_Changed(0x0,0x0, 0x00, 0xFF);
  } 
}

Audio_LastStationList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
  
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Audio_LastStationList[i].Param1 = 0;
		Audio_LastStationList[i].Param2 = 0;
		Audio_LastStationList[i].Param3 = 0;
		Audio_LastStationList[i].Param4 = 0;
		for (j=0; j<49; j++)
			Audio_LastStationList[i].Param5[j] = 0;
		Audio_LastStationList[i].Param5_Length = 0;
		for (j=0; j<31; j++)
			Audio_LastStationList[i].Param6[j] = 0;
		Audio_LastStationList[i].Param6_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gAudio_LastStationList_Path); i++)
  {
    if (gAudio_LastStationList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gAudio_LastStationList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gAudio_LastStationList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
    //writelineEx(4, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "SiriusAlertList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
            
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in SiriusAlertList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Audio_LastStationList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Audio_LastStationList[current_CSV_line-1].Param2 = atol(temp2); //PresetIndex
						Audio_LastStationList[current_CSV_line-1].Param3 = atol(temp3); //Waveband
						Audio_LastStationList[current_CSV_line-1].Param4 = atol(temp4); //Attributes
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PresetIndex
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Waveband
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //Attributes
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Name
								if (paramPos < 48)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_LastStationList_ListFormat == 1) )
                  {
                    Audio_LastStationList[current_CSV_line-1].Param5[paramPos++] = buffer_byte[filePos++];
                    Audio_LastStationList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_LastStationList_ListFormat == 0) )
                  {
                    Audio_LastStationList[current_CSV_line-1].Param5[paramPos++] = 0xC2;
                    Audio_LastStationList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_LastStationList_ListFormat == 0) )
                  {
                    Audio_LastStationList[current_CSV_line-1].Param5[paramPos++] = 0xC3;
                    Audio_LastStationList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_LastStationList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                  }
									Audio_LastStationList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 6: //Frequency
								if (paramPos < 30)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_LastStationList_ListFormat == 1) )
                  {
                    Audio_LastStationList[current_CSV_line-1].Param6[paramPos++] = buffer_byte[filePos++];
                    Audio_LastStationList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_LastStationList_ListFormat == 0) )
                  {
                    Audio_LastStationList[current_CSV_line-1].Param6[paramPos++] = 0xC2;
                    Audio_LastStationList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_LastStationList_ListFormat == 0) )
                  {
                    Audio_LastStationList[current_CSV_line-1].Param6[paramPos++] = 0xC3;
                    Audio_LastStationList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_LastStationList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                  }
									Audio_LastStationList[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}

  Audio_LastStationList_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
  
  putValue(P_FSG_49_0_0_22_1_range, Audio_LastStationList[0].Param1);
  putValue(P_FSG_49_0_0_22_2_range, Audio_LastStationList[0].Param1);
  
  putValue(P_FSG_49_0_0_51_1_range, Audio_LastStationList[0].Param1);
  putValue(P_FSG_49_0_0_51_2_range, Audio_LastStationList[0].Param1);
  putValue(P_FSG_49_0_0_51_3_range, Audio_LastStationList[0].Param1);
  putValue(P_FSG_49_0_0_51_4_range, Audio_LastStationList[0].Param1);
  
  putValue(P_FSG_49_0_0_55_1_range, Audio_LastStationList[0].Param1);
  putValue(P_FSG_49_0_0_55_2_range, Audio_LastStationList[0].Param1);

  for(i=0;i<elcount(cInfo1); i++)
  {
  cInfo1[i] = 0;
  }
  
  for(i=0;i<elcount(cInfo2); i++)
  {
  cInfo2[i] = 0;
  }

  for(i=0;i<Audio_LastStationList[0].Param5_Length; i++)
  {
  u8Info1[i] = Audio_LastStationList[0].Param5[i];
  cInfo1[i] = Audio_LastStationList[0].Param5[i];
  }
  
  for(i=0;i<Audio_LastStationList[0].Param6_Length; i++)
  {
  u8Info2[i] = Audio_LastStationList[0].Param6[i];
  cInfo2[i] = Audio_LastStationList[0].Param6[i];
  }
  
  putValue(P_FSG_49_0_0_54_2, 0x44);
  putValue(P_FSG_49_0_0_54_1, u8Info1, Audio_LastStationList[0].Param5_Length);
  putValue(P_FSG_49_0_0_54_4, u8Info2, Audio_LastStationList[0].Param6_Length);
}

Audio_LastStationList(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte Shift, Direction, TransPos;
  dword list_start, elements;

  if ((opcode == 1) && (Audio_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;

    list_start = data[2] ;
    elements = data[3];
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_49_0_0_56_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_49_0_0_56_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_49_0_0_56_2 = TAID;
    else
      TAID = @A_FSG_49_0_0_56_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_49_0_0_56_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_49_0_0_56_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_49_0_0_56_Shift = (mode>>0);
    else
      mode = ((@A_FSG_49_0_0_56_Shift*1)+(Direction*2)+(TransPos*4));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_49_0_0_56_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_49_0_0_56_Direction*2)+(TransPos*4));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_49_0_0_56_Start = list_start;
    else
      list_start = @A_FSG_49_0_0_56_Start;
                      
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            
     if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
     {
       Audio_LastStationList_Status(ASG_ID, TAID, mode, recordaddress,list_start, elements);
     }
  }
}

Audio_LastStationList_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition, increment = 1, elements ;
  byte sequenceNumber = 0;
  
  int i, k , strctr; 
  int stringsize;   

  elements = received_elements;

  Data_Audio_LastStationList[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Audio_LastStationList[1] = Audio_LastStationList_TotalListNum & 0xFF;
  Data_Audio_LastStationList[2] = (mode|0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction)
  {
    case 0:
      
      if (list_start == 0)
      {
        startposition =  shift;
        endposition = startposition + elements-1;
      }
      else if (list_start > 0)
      {
        startposition = Audio_LastStationList_Search_Pos(list_start) - 1 + shift;
        endposition = startposition+ elements - 1;
      }
      
      if (endposition >= Audio_LastStationList_TotalListNum)
      {
        elements = Audio_LastStationList_TotalListNum - startposition;
        endposition = Audio_LastStationList_TotalListNum -1;
      }

    break;
    
    case 1:
      
      if (list_start > 0)
      {
        startposition = Audio_LastStationList_Search_Pos(list_start) - 1 - shift; 
        endposition = startposition - elements + 1; 
      }
      else if (list_start == 0)
      {
        startposition = Audio_LastStationList_TotalListNum -1;
        endposition = startposition - elements + 1;
      }
      
      if (endposition < 0)
      {
        elements = elements + endposition;
        endposition = 0;
      }
                
    break;
  }

  Data_Audio_LastStationList[3] = list_start & 0xFF;
  Data_Audio_LastStationList[4] = elements & 0xFF;

  j_Audio_LastStationList = 5;
    
  switch(direction)
  {
    case 0:

      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param1; //Pos (immer Index_Size = 0)
      
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3)  //PresetIndex
          Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param2;
        
        if (recordaddress == 0x1 || recordaddress == 0x2)  //Waveband
          Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param3;

        if (recordaddress == 0x1)  // Attributes
        {
          Data_Audio_LastStationList[j_Audio_LastStationList++] =  Audio_LastStationList[i].param4 &0xFF;
          Data_Audio_LastStationList[j_Audio_LastStationList++] = (Audio_LastStationList[i].param4 >> 8)&0xFF;
        }
                        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3) // Name
        {  
          Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param5_Length; 
          stringsize = Audio_LastStationList[i].param5_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param5[strctr];
          } 
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x3) // Frequency
        {  
          Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param6_Length; 
          stringsize = Audio_LastStationList[i].param6_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param6[strctr];
          } 
        }
      }
      
    break;   
                       
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param1; //Pos (immer Index_Size = 0)
      
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3)  //PresetIndex
          Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param2;
        
        if (recordaddress == 0x1 || recordaddress == 0x2)  //Waveband
          Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param3;

        if (recordaddress == 0x1)  // Attributes
        {
          Data_Audio_LastStationList[j_Audio_LastStationList++] =  Audio_LastStationList[i].param4 &0xFF;
          Data_Audio_LastStationList[j_Audio_LastStationList++] = (Audio_LastStationList[i].param4 >> 8)&0xFF;
        }
                        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3) // Name
        {  
          Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param5_Length; 
          stringsize = Audio_LastStationList[i].param5_Length;
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param5[strctr];
          } 
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x3) // Frequency
        {  
          Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param6_Length; 
          stringsize = Audio_LastStationList[i].param6_Length;
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_LastStationList[j_Audio_LastStationList++] = Audio_LastStationList[i].param6[strctr];
          } 
        }
      }
    break;
  }
  settimer(Delay_Audio_LastStationList, @Env_Audio_LastStationList_ListDelay);
}

Audio_LastStationList_Changed (byte mode, byte recordaddress, byte list_start, byte elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift;
  int startposition, endposition, increment = 1;
  byte sequenceNumber = 0;
  
  int i, strctr; 
  int stringsize;  

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  Data_Audio_LastStationList[0] = (mode & 0xF) *16 + (recordaddress & 0xF);
  Data_Audio_LastStationList[1] = list_start;
  Data_Audio_LastStationList[2] = elements;
  j_Audio_LastStationList = 3;
  
  SendRequestByteSequence(LSGID_Audio, 0x38, Changed_REQ, j_Audio_LastStationList, Data_Audio_LastStationList);
}

dword Audio_LastStationList_Search_Pos (dword position)
{
  int i;
  
  for (i = 0; i < Audio_LastStationList_TotalListNum; i++)
  {
    if (position == Audio_LastStationList[i].param1)
    {
      return i+1; // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}

on timer Delay_Audio_LastStationList
{
  sendRequestByteSequence(LSGID_Audio, 0x38, Data_REQ, j_Audio_LastStationList, Data_Audio_LastStationList);
}






// Audio 0x3A Picture

on envVar Env_Audio_Picture_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Audio_Picture_Path, gAudio_Picture_Path);
    Audio_Picture_LoadArray();
  } 
}

on envVar Env_Audio_Picture_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Audio_Picture_Path, gAudio_Picture_Path);
    Audio_Picture_LoadArray();
    Audio_Picture_Changed(0x0,0x0, 0x00, 0xFF);
  } 
}

Audio_Picture_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte  buffer_byte[0xFFFF];
	dword i;
	dword j;
	char  CSV_filename[255];
  char  CSV_filepath[255];
  byte  pos;
  byte  empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp5[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
  
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
    Audio_Picture[i].Param1 = 0;
		Audio_Picture[i].Param2 = 0;
		Audio_Picture[i].Param3 = 0;
		for(j=0; j<33; j++)
			Audio_Picture[i].Param4[j] = 0;
		Audio_Picture[i].Param4_Length = 0;
		Audio_Picture[i].Param5 = 0;
		for(j=0; j<602; j++)
			Audio_Picture[i].Param6[j] = 0;
		Audio_Picture[i].Param6_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gAudio_Picture_Path); i++)
  {
    if (gAudio_Picture_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gAudio_Picture_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gAudio_Picture_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
    //writelineEx(4, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "SiriusAlertList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
            
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in SiriusAlertList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Audio_Picture[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Audio_Picture[current_CSV_line-1].Param2 = atol(temp2); //PictureType
						Audio_Picture[current_CSV_line-1].Param3 = atol(temp3); //Handle
						Audio_Picture[current_CSV_line-1].Param5 = atol(temp5); //TCP_Port
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp5[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PictureType
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Handle
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++; 
								}
							break;
						case 4: //IPv6_Address
								if(paramPos < 16)
								{
                  // 0...9
                  if (buffer_byte[filePos] >= 0x30 && buffer_byte[filePos] <= 0x39)
                  {
                    if (buffer_byte[filePos+1] == 0x30)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] = (buffer_byte[filePos]-0x30)*16;
                      
                    if (buffer_byte[filePos+1] > 0x30 && buffer_byte[filePos+1] <= 0x39)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] = (buffer_byte[filePos]-0x30)*16 + (buffer_byte[filePos+1]-0x30);
                    
                    if (buffer_byte[filePos+1] >= 0x41 && buffer_byte[filePos+1] <= 0x46)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] = (buffer_byte[filePos]-0x30)*16 + (buffer_byte[filePos+1]-0x37);
                    
                    if (buffer_byte[filePos+1] >= 0x61 && buffer_byte[filePos+1] <= 0x66)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] = (buffer_byte[filePos]-0x30)*16 + (buffer_byte[filePos+1]-0x57);
                  }
                                
                  // A...F
                  if (buffer_byte[filePos] >= 0x41 && buffer_byte[filePos] <= 0x46)
                  {
                    if (buffer_byte[filePos+1] == 0x30)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] = ((buffer_byte[filePos]-0x37)*16);
                      
                    if (buffer_byte[filePos+1] > 0x30 && buffer_byte[filePos+1] <= 0x39)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] =  (buffer_byte[filePos]-0x37)*16 + (buffer_byte[filePos+1]-0x30);
                    
                    if (buffer_byte[filePos+1] >= 0x41 && buffer_byte[filePos+1] <= 0x46)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] =  (buffer_byte[filePos]-0x37)*16 + (buffer_byte[filePos+1]-0x37);
                    
                    if (buffer_byte[filePos+1] >= 0x61 && buffer_byte[filePos+1] <= 0x66)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] =  (buffer_byte[filePos]-0x37)*16 + (buffer_byte[filePos+1]-0x57);
                  }
                  
                  // a...f
                  if (buffer_byte[filePos] >= 0x61 && buffer_byte[filePos] <= 0x66)
                  {
                    if (buffer_byte[filePos+1] == 0x30)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] = ((buffer_byte[filePos]-0x57)*16);

                    if (buffer_byte[filePos+1] == 0x30)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] = ((buffer_byte[filePos]-0x57)*16);
                      
                    if (buffer_byte[filePos+1] > 0x30 && buffer_byte[filePos+1] <= 0x39)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] =  (buffer_byte[filePos]-0x57)*16 + (buffer_byte[filePos+1]-0x30);
                    
                    if (buffer_byte[filePos+1] >= 0x41 && buffer_byte[filePos+1] <= 0x46)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] =  (buffer_byte[filePos]-0x57)*16 + (buffer_byte[filePos+1]-0x37);
                    
                    if (buffer_byte[filePos+1] >= 0x61 && buffer_byte[filePos+1] <= 0x66)
                      Audio_Picture[current_CSV_line-1].Param4[paramPos++] =  (buffer_byte[filePos]-0x57)*16 + (buffer_byte[filePos+1]-0x57);
                  }
                }
              Audio_Picture[current_CSV_line-1].Param4_Length = 16;
              filePos++;
						break;
						case 5: //TCP_Port
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //URI
								if(paramPos < 600)
								{
									Audio_Picture[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
									Audio_Picture[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}

  Audio_Picture_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Audio_Picture(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte Shift, Direction, TransPos;
  dword list_start, elements;

  if ((opcode == 1) && (Audio_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;

    list_start = data[2];
    elements = data[3];
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_49_0_0_58_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_49_0_0_58_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_49_0_0_58_2 = TAID;
    else
      TAID = @A_FSG_49_0_0_58_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_49_0_0_58_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_49_0_0_58_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_49_0_0_58_Shift = (mode>>0);
    else
      mode = ((@A_FSG_49_0_0_58_Shift*1)+(Direction*2)+(TransPos*4));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_49_0_0_58_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_49_0_0_58_Direction*2)+(TransPos*4));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_49_0_0_58_Start = list_start;
    else
      list_start = @A_FSG_49_0_0_58_Start;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      Audio_Picture_Status(ASG_ID, TAID, mode, recordaddress,list_start, elements);
    }
  }
}

 Audio_Picture_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction;
  int startposition, endposition, increment = 1, elements ;
  byte sequenceNumber = 0;
  
  int i, k , strctr;
  int stringsize;

  elements = received_elements;

  Data_Audio_Picture[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Audio_Picture[1] = Audio_Picture_TotalListNum & 0xFF;
  Data_Audio_Picture[2] = (mode|0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung
      
      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift; 
        endposition   = startposition + elements - 1; 
      }
      
      // Start in Liste
      if ((float) Audio_Picture_Search_Pos(list_start) != 0)
      {
        startposition = Audio_Picture_Search_Pos(list_start) - 1 + shift;
        endposition = startposition + elements - 1;
      }
      else
        {
          startposition = list_start + shift;
          elements = 0;
        }

      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Audio_Picture_TotalListNum)
      {
        endposition = Audio_Picture_TotalListNum - 1;
        elements = Audio_Picture_TotalListNum - startposition;
      }

    break;
    
    case 1: // Anfrage in neg. Richtung
	
	// Start bei Listenbeginn
        if ((list_start == 0))
        {
          // Abfrage letzte Listenelemente
          if (shift == 1)
          {
            startposition = Audio_Picture_TotalListNum - 1;
            endposition = startposition - elements + 1;
          }
		  else
          elements = 0;
        }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Audio_Picture_Search_Pos(list_start) != 0)
        {
          startposition = Audio_Picture_Search_Pos(list_start) - 1 - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift;
        }
      }
      
    break;
  }

  Data_Audio_Picture[3] = list_start & 0xFF;
  Data_Audio_Picture[4] = elements & 0xFF;

  j_Audio_Picture = 5;
  
  switch(direction)
  {
    case 0:
      
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param1; // Pos
        
        if (recordaddress == 0x1 || recordaddress == 0x3)  //PictureType
        {
          Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param2;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x3)  //Handle
        {
          Data_Audio_Picture[j_Audio_Picture++] =  Audio_Picture[i].param3 & 0xFF;
          Data_Audio_Picture[j_Audio_Picture++] = (Audio_Picture[i].param3 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x1) //IPv6_Address
        {
          Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param4_Length;
          stringsize = Audio_Picture[i].param4_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param4[strctr];
          }
        }
        
        if (recordaddress == 0x1)  //TCP_Port
        {
          Data_Audio_Picture[j_Audio_Picture++] =  Audio_Picture[i].param5 & 0xFF;
          Data_Audio_Picture[j_Audio_Picture++] = (Audio_Picture[i].param5 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x3) //URI
        {
          //Data_Audio_Picture[j_Audio_Picture++] =  Audio_Picture[i].param6_Length+1 & 0xFF;
          //Data_Audio_Picture[j_Audio_Picture++] = (Audio_Picture[i].param6_Length >> 8) & 0xFF;
          Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param6_Length;
          stringsize = Audio_Picture[i].param6_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param6[strctr];
          }
        }
      }
      
    break;
          
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param1; // Pos
        
        if (recordaddress == 0x1 || recordaddress == 0x3)  //PictureType
        {
          Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param2;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x3)  //Handle
        {
          Data_Audio_Picture[j_Audio_Picture++] =  Audio_Picture[i].param3 & 0xFF;
          Data_Audio_Picture[j_Audio_Picture++] = (Audio_Picture[i].param3 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x1) //IPv6_Address
        {
          Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param4_Length;
          stringsize = Audio_Picture[i].param4_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param4[strctr];
          }
        }
        
        if (recordaddress == 0x1)  //TCP_Port
        {
          Data_Audio_Picture[j_Audio_Picture++] =  Audio_Picture[i].param5 & 0xFF;
          Data_Audio_Picture[j_Audio_Picture++] = (Audio_Picture[i].param5 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x3) //URI
        {
          //Data_Audio_Picture[j_Audio_Picture++] =  Audio_Picture[i].param6_Length+1 & 0xFF;
          //Data_Audio_Picture[j_Audio_Picture++] = (Audio_Picture[i].param6_Length >> 8) & 0xFF;
          Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param6_Length;
          stringsize = Audio_Picture[i].param6_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Audio_Picture[j_Audio_Picture++] = Audio_Picture[i].param6[strctr];
          }
        }
      }
    break;
  }
  settimer (Delay_Audio_Picture, @Env_Audio_Picture_ListDelay);
}

Audio_Picture_Changed (byte mode, byte recordaddress, byte list_start, byte elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift;
  int startposition, endposition, increment = 1;
  byte sequenceNumber = 0;
  
  int i, strctr; 
  int stringsize;  

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  Data_Audio_Picture[0] = (mode & 0xF) *16 + (recordaddress & 0xF);
  Data_Audio_Picture[1] = list_start;
  Data_Audio_Picture[2] = elements;
  j_Audio_Picture = 3;
  
  SendRequestByteSequence(LSGID_Audio, 0x3A, Changed_REQ, j_Audio_Picture, Data_Audio_Picture);
}

on timer Delay_Audio_Picture
{
  sendRequestByteSequence(LSGID_Audio, 0x3A, Data_REQ, j_Audio_Picture, Data_Audio_Picture);
}

dword Audio_Picture_Search_Pos (dword position)
{
  int i;
  
  for (i = 0; i < Audio_Picture_TotalListNum; i++)
  {
    if (position == Audio_Picture[i].param1)
    {
      return i+1; // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}






// Audio 0x3B Favorite List

on envVar Env_Audio_FavoriteList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Audio_FavoriteList_Path, gAudio_FavoriteList_Path);
    Audio_FavoriteList_LoadArray();
  } 
}

on envVar Env_Audio_FavoriteList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Audio_FavoriteList_Path, gAudio_FavoriteList_Path);
    Audio_FavoriteList_LoadArray();
    Audio_FavoriteList_Changed(0x0,0x0, 0x00, 0xFF);
  } 
}

Audio_FavoriteList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
  
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Audio_FavoriteList[i].Param1 = 0;
		Audio_FavoriteList[i].Param2 = 0;
		Audio_FavoriteList[i].Param3 = 0;
		Audio_FavoriteList[i].Param4 = 0;
		for (j=0; j<49; j++)
			Audio_FavoriteList[i].Param5[j] = 0;
		Audio_FavoriteList[i].Param5_Length = 0;
		for (j=0; j<31; j++)
			Audio_FavoriteList[i].Param6[j] = 0;
		Audio_FavoriteList[i].Param6_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gAudio_FavoriteList_Path); i++)
  {
    if (gAudio_FavoriteList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gAudio_FavoriteList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gAudio_FavoriteList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
    //writelineEx(4, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "SiriusAlertList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
            
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in SiriusAlertList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Audio_FavoriteList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Audio_FavoriteList[current_CSV_line-1].Param2 = atol(temp2); //PresetIndex
						Audio_FavoriteList[current_CSV_line-1].Param3 = atol(temp3); //Waveband
						Audio_FavoriteList[current_CSV_line-1].Param4 = atol(temp4); //Attributes
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PresetIndex
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Waveband
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //Attributes
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Name
								if (paramPos < 48)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_FavoriteList_ListFormat == 1) )
                  {
                    Audio_FavoriteList[current_CSV_line-1].Param5[paramPos++] = buffer_byte[filePos++];
                    Audio_FavoriteList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_FavoriteList_ListFormat == 0) )
                  {
                    Audio_FavoriteList[current_CSV_line-1].Param5[paramPos++] = 0xC2;
                    Audio_FavoriteList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_FavoriteList_ListFormat == 0) )
                  {
                    Audio_FavoriteList[current_CSV_line-1].Param5[paramPos++] = 0xC3;
                    Audio_FavoriteList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_FavoriteList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                  }
									Audio_FavoriteList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 6: //Frequency
								if (paramPos < 30)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Audio_FavoriteList_ListFormat == 1) )
                  {
                    Audio_FavoriteList[current_CSV_line-1].Param6[paramPos++] = buffer_byte[filePos++];
                    Audio_FavoriteList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Audio_FavoriteList_ListFormat == 0) )
                  {
                    Audio_FavoriteList[current_CSV_line-1].Param6[paramPos++] = 0xC2;
                    Audio_FavoriteList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Audio_FavoriteList_ListFormat == 0) )
                  {
                    Audio_FavoriteList[current_CSV_line-1].Param6[paramPos++] = 0xC3;
                    Audio_FavoriteList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Audio_FavoriteList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                  }
									Audio_FavoriteList[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}

  Audio_FavoriteList_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
  
  putValue(P_FSG_49_0_0_22_1_range, Audio_FavoriteList[0].Param1);
  putValue(P_FSG_49_0_0_22_2_range, Audio_FavoriteList[0].Param1);
  
  putValue(P_FSG_49_0_0_51_1_range, Audio_FavoriteList[0].Param1);
  putValue(P_FSG_49_0_0_51_2_range, Audio_FavoriteList[0].Param1);
  putValue(P_FSG_49_0_0_51_3_range, Audio_FavoriteList[0].Param1);
  putValue(P_FSG_49_0_0_51_4_range, Audio_FavoriteList[0].Param1);
  
  putValue(P_FSG_49_0_0_55_1_range, Audio_FavoriteList[0].Param1);
  putValue(P_FSG_49_0_0_55_2_range, Audio_FavoriteList[0].Param1);

  for(i=0;i<elcount(cInfo1); i++)
  {
  cInfo1[i] = 0;
  }
  
  for(i=0;i<elcount(cInfo2); i++)
  {
  cInfo2[i] = 0;
  }

  for(i=0;i<Audio_FavoriteList[0].Param5_Length; i++)
  {
  u8Info1[i] = Audio_FavoriteList[0].Param5[i];
  cInfo1[i] = Audio_FavoriteList[0].Param5[i];
  }
  
  for(i=0;i<Audio_FavoriteList[0].Param6_Length; i++)
  {
  u8Info2[i] = Audio_FavoriteList[0].Param6[i];
  cInfo2[i] = Audio_FavoriteList[0].Param6[i];
  }
  
  putValue(P_FSG_49_0_0_54_2, 0x44);
  putValue(P_FSG_49_0_0_54_1, u8Info1, Audio_FavoriteList[0].Param5_Length);
  putValue(P_FSG_49_0_0_54_4, u8Info2, Audio_FavoriteList[0].Param6_Length);
}

Audio_FavoriteList(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte Shift, Direction, TransPos;
  dword list_start, elements;

  if ((opcode == 1) && (Audio_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;

    list_start = data[2];
    elements = data[3];
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_49_0_0_59_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_49_0_0_59_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_49_0_0_59_2 = TAID;
    else
      TAID = @A_FSG_49_0_0_59_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_49_0_0_59_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_49_0_0_59_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_49_0_0_59_Shift = (mode>>0);
    else
      mode = ((@A_FSG_49_0_0_59_Shift*1)+(Direction*2)+(TransPos*4));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_49_0_0_59_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_49_0_0_59_Direction*2)+(TransPos*4));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_49_0_0_59_Start = list_start;
    else
      list_start = @A_FSG_49_0_0_59_Start;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      Audio_FavoriteList_Status(ASG_ID, TAID, mode, recordaddress,list_start, elements);
    }
  }
}

Audio_FavoriteList_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition, increment = 1, elements ;
  byte sequenceNumber = 0;
  
  int i, k , strctr; 
  int stringsize;   

  elements = received_elements;

  Data_Audio_FavoriteList[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Audio_FavoriteList[1] = Audio_FavoriteList_TotalListNum & 0xFF;
  Data_Audio_FavoriteList[2] = (mode|0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction)
  {
    case 0:

      if (list_start == 0)
      {
        startposition =  shift; 
        endposition = startposition + elements-1; 
      }
      else if (list_start > 0)
      {
        startposition = Audio_FavoriteList_Search_Pos(list_start) - 1 + shift;
        endposition = startposition+ elements - 1;
      }

      if (endposition >= Audio_FavoriteList_TotalListNum)
      {
        elements = Audio_FavoriteList_TotalListNum - startposition;
        endposition = Audio_FavoriteList_TotalListNum -1;
      }

    break;
    
    case 1:
      
      if (list_start > 0)
      {
        startposition = Audio_FavoriteList_Search_Pos(list_start) - 1 - shift; 
        endposition = startposition - elements + 1; 
      }
      
      else if (list_start == 0)
      {
        startposition = Audio_FavoriteList_TotalListNum -1;
        endposition = startposition - elements + 1;
      }
      
      if (endposition < 0)
      {
        elements = elements + endposition;
        endposition = 0;
      }
      
    break;
  }

  Data_Audio_FavoriteList[3] = list_start & 0xFF;
  Data_Audio_FavoriteList[4] = elements & 0xFF;

  j_Audio_FavoriteList = 5;
  
  switch(direction)
  {
    case 0:

      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param1; // Pos (immer Index_Size = 0)
      
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3)  // PresetIndex
            Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param2;
        
        if (recordaddress == 0x1 || recordaddress == 0x2)  // Waveband
            Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param3;

        if (recordaddress == 0x1)  // Attributes
        {
            Data_Audio_FavoriteList[j_Audio_FavoriteList++] =  Audio_FavoriteList[i].param4 &0xFF;
            Data_Audio_FavoriteList[j_Audio_FavoriteList++] = (Audio_FavoriteList[i].param4 >> 8)&0xFF;
        }

        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3) // Name
        {  
          Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param5_Length; 
          stringsize = Audio_FavoriteList[i].param5_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param5[strctr];
          } 
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x3) // Frequency
        {  
          Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param6_Length; 
          stringsize = Audio_FavoriteList[i].param6_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param6[strctr];
          } 
        }
      }
      
    break;   
                       
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param1; // Pos (immer Index_Size = 0)
      
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3)  // PresetIndex
            Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param2;
        
        if (recordaddress == 0x1 || recordaddress == 0x2)  // Waveband
            Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param3;

        if (recordaddress == 0x1)  // Attributes
        {
          Data_Audio_FavoriteList[j_Audio_FavoriteList++] =  Audio_FavoriteList[i].param4 &0xFF;
          Data_Audio_FavoriteList[j_Audio_FavoriteList++] = (Audio_FavoriteList[i].param4 >> 8)&0xFF;
        }
                        
        if (recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3) // Name
        {  
          Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param5_Length; 
          stringsize = Audio_FavoriteList[i].param5_Length;
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param5[strctr];
          } 
        }

        if (recordaddress == 0x1 || recordaddress == 0x3) // Frequency
        {  
          Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param6_Length; 
          stringsize = Audio_FavoriteList[i].param6_Length;
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Audio_FavoriteList[j_Audio_FavoriteList++] = Audio_FavoriteList[i].param6[strctr];
          }
        }
      }
    break;
  }
  settimer(Delay_Audio_FavoriteList, @Env_Audio_FavoriteList_ListDelay);
}

Audio_FavoriteList_Changed (byte mode, byte recordaddress, byte list_start, byte elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift;
  int startposition, endposition, increment = 1;
  byte sequenceNumber = 0;
  
  int i, strctr; 
  int stringsize;  

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  Data_Audio_FavoriteList[0] = (mode & 0xF) *16 + (recordaddress & 0xF);
  Data_Audio_FavoriteList[1] = list_start;
  Data_Audio_FavoriteList[2] = elements;
  j_Audio_FavoriteList = 3;
  
  SendRequestByteSequence(LSGID_Audio, 0x3B, Changed_REQ, j_Audio_FavoriteList, Data_Audio_FavoriteList);
}

dword Audio_FavoriteList_Search_Pos (dword position)
{
  int i;
  
  for (i = 0; i < Audio_FavoriteList_TotalListNum; i++)
  {
    if (position == Audio_FavoriteList[i].param1)
    {
      return i+1; // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}

on timer Delay_Audio_FavoriteList
{
  sendRequestByteSequence(LSGID_Audio, 0x3B, Data_REQ, j_Audio_FavoriteList, Data_Audio_FavoriteList);
}


//////// Mapping alter Variablen ////////

on envVar env_LoadBTN_RL
{ @Env_Audio_ReceptionList_LoadBTN = @this; }
on envVar env_LoadBTN_RL_Full
{ @Env_Audio_ReceptionList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Audio_RL
{ @Env_Audio_ReceptionList_ListDelay = @this; }
on envVar envReceptionList_FM_Path
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_ReceptionList_FM_Path, temp); }
on envVar envReceptionList_DAB_Path
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_ReceptionList_DAB_Path, temp); }
on envVar envReceptionList_SDARS_Path
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_ReceptionList_SDARS_Path, temp); }
on envVar envReceptionList_DVB_Path
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_ReceptionList_DVB_Path, temp); }
on envVar envReceptionList_TV_Path
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_ReceptionList_TV_Path, temp); }
on envVar envReceptionList_AM_SW_Path
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_ReceptionList_AM_SW_Path, temp); }
on envVar envReceptionList_AM_LW_Path
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_ReceptionList_AM_LW_Path, temp); }
on envVar envReceptionList_OR_Path
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_ReceptionList_OnlineRadio_Path, temp); }
on envVar envReceptionList_CL_Path
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_ReceptionList_CommonList_Path, temp); }

on envVar env_LoadBTN_SL
{ @Env_Audio_SourceList_LoadBTN = @this; }
on envVar env_LoadBTN_SL_Full
{ @Env_Audio_SourceList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Audio_SL
{ @Env_Audio_SourceList_ListDelay = @this; }
on envVar envSourceListPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_SourceList_Path, temp); }

on envVar env_LoadBTN_PL
{ @Env_Audio_RadioTVPresetList_LoadBTN = @this; }
on envVar env_LoadBTN_PL_Full
{ @Env_Audio_RadioTVPresetList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Audio_RTVPL
{ @Env_Audio_RadioTVPresetList_ListDelay = @this; }
on envVar envPresetListPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_RadioTVPresetList_Path, temp); }

on envVar env_LoadBTN_MB
{ @Env_Audio_MediaBrowser_LoadBTN = @this; }
on envVar env_LoadBTN_MB_Full
{ @Env_Audio_MediaBrowser_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Audio_MB
{ @Env_Audio_MediaBrowser_ListDelay = @this; }
on envVar envMediaBrowserPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_MediaBrowser_Path, temp); }

on envVar env_LoadBTN_SAL
{ @Env_Audio_SiriusAlertList_LoadBTN = @this; }
on envVar env_LoadBTN_SAL_Full
{ @Env_Audio_SiriusAlertList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Audio_SAL
{ @Env_Audio_SiriusAlertList_ListDelay = @this; }
on envVar envSiriusAlertListPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_SiriusAlertList_Path, temp); }

on envVar env_LoadBTN_LSL
{ @Env_Audio_LastStationList_LoadBTN = @this; }
on envVar env_LoadBTN_LSL_Full
{ @Env_Audio_LastStationList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Audio_LSL
{ @Env_Audio_LastStationList_ListDelay = @this; }
on envVar envLastStationListPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_LastStationList_Path, temp); }

on envVar env_LoadBTN_AFL
{ @Env_Audio_FavoriteList_LoadBTN = @this; }
on envVar env_LoadBTN_AFL_Full
{ @Env_Audio_FavoriteList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Audio_AFL
{ @Env_Audio_FavoriteList_ListDelay = @this; }
on envVar envAudioFavoriteListPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Audio_FavoriteList_Path, temp); }










///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////// Navigation //////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

on envVar Node_Index_FSG_50
{
  Node_Index_Navigation = @Node_Index_FSG_50;
}

on message BAP_Navigation_ASG_01
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  //Source: ASG
  Navigation_Source = 1;
  
  //nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG50_0 == 1)
  {
    //Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    //messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_ASG01[log_channel][i] = 0;

      // BAP Header auswerten
      Navigation_received_function_ASG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Navigation_received_function_ASG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Navigation_received_function_ASG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Navigation_app_data_ASG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG01[log_channel][2]);
      
      // an checkfunction übergeben
      if (Navigation_received_function_ASG01[log_channel][2] == 0x34) { Navigation_LaneGuidance_Log_Channel = log_channel; } // POI_List
      checkFunction (Navigation_received_function_ASG01[log_channel][0], Navigation_received_function_ASG01[log_channel][1], Navigation_received_function_ASG01[log_channel][2], Navigation_app_data_ASG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_ASG01[log_channel][i] = 0;        

      // BAP Header auswerten
      Navigation_received_function_ASG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Navigation_received_function_ASG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Navigation_received_function_ASG01[log_channel][2] = (data[3] & 0x3F); // FctID
      Navigation_data_length_ASG01[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Navigation_app_data_ASG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Navigation_data_length_ASG01[log_channel] = Navigation_data_length_ASG01[log_channel] - 4;
      Navigation_currentPosASG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Navigation_data_length_ASG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (Navigation_received_function_ASG01[log_channel][2] == 0x34) { Navigation_LaneGuidance_Log_Channel = log_channel; } // POI_List
        checkFunction (Navigation_received_function_ASG01[log_channel][0], Navigation_received_function_ASG01[log_channel][1], Navigation_received_function_ASG01[log_channel][2], Navigation_app_data_ASG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Navigation_sequenceNumberASG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_ASG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Navigation_app_data_ASG01[log_channel][Navigation_currentPosASG01[log_channel]] = data[i+1];
           Navigation_currentPosASG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Navigation_data_length_ASG01[log_channel] = Navigation_data_length_ASG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_ASG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Navigation_data_length_ASG01[log_channel]; i++)
        {
           Navigation_app_data_ASG01[log_channel][Navigation_currentPosASG01[log_channel]] = data[i+1];
           Navigation_currentPosASG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (Navigation_received_function_ASG01[log_channel][2] == 0x34) { Navigation_LaneGuidance_Log_Channel = log_channel; } // POI_List
        checkFunction (Navigation_received_function_ASG01[log_channel][0], Navigation_received_function_ASG01[log_channel][1], Navigation_received_function_ASG01[log_channel][2], Navigation_app_data_ASG01[log_channel]);
      }
    }
  }
}

on message BAP_Navigation_ASG_02
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  Navigation_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG50_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_ASG02[log_channel][i] = 0;

      // BAP Header auswerten
      Navigation_received_function_ASG02[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Navigation_received_function_ASG02[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Navigation_received_function_ASG02[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Navigation_app_data_ASG02[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG02[log_channel][2]);
      
      // an checkfunction übergeben
      if (Navigation_received_function_ASG02[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
      if (Navigation_received_function_ASG02[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
      if (Navigation_received_function_ASG02[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
      if (Navigation_received_function_ASG02[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
      checkFunction (Navigation_received_function_ASG02[log_channel][0], Navigation_received_function_ASG02[log_channel][1], Navigation_received_function_ASG02[log_channel][2], Navigation_app_data_ASG02[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_ASG02[log_channel][i] = 0;        

      // BAP Header auswerten
      Navigation_received_function_ASG02[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Navigation_received_function_ASG02[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Navigation_received_function_ASG02[log_channel][2] = (data[3] & 0x3F); // FctID
      Navigation_data_length_ASG02[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Navigation_app_data_ASG02[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Navigation_data_length_ASG02[log_channel] = Navigation_data_length_ASG02[log_channel] - 4;
      Navigation_currentPosASG02[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Navigation_data_length_ASG02[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Navigation_received_function_ASG02[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
        if (Navigation_received_function_ASG02[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
        if (Navigation_received_function_ASG02[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
        if (Navigation_received_function_ASG02[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
        checkFunction (Navigation_received_function_ASG02[log_channel][0], Navigation_received_function_ASG02[log_channel][1], Navigation_received_function_ASG02[log_channel][2], Navigation_app_data_ASG02[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Navigation_sequenceNumberASG02[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_ASG02[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Navigation_app_data_ASG02[log_channel][Navigation_currentPosASG02[log_channel]] = data[i+1];
           Navigation_currentPosASG02[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Navigation_data_length_ASG02[log_channel] = Navigation_data_length_ASG02[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_ASG02[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Navigation_data_length_ASG02[log_channel]; i++)
        {
           Navigation_app_data_ASG02[log_channel][Navigation_currentPosASG02[log_channel]] = data[i+1];
           Navigation_currentPosASG02[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Navigation_received_function_ASG02[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
        if (Navigation_received_function_ASG02[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
        if (Navigation_received_function_ASG02[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
        if (Navigation_received_function_ASG02[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
        checkFunction (Navigation_received_function_ASG02[log_channel][0], Navigation_received_function_ASG02[log_channel][1], Navigation_received_function_ASG02[log_channel][2], Navigation_app_data_ASG02[log_channel]);
      }
    }
  }
}

on message BAP_Navigation_ASG_03
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  Navigation_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG50_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_ASG03[log_channel][i] = 0;

      // BAP Header auswerten
      Navigation_received_function_ASG03[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Navigation_received_function_ASG03[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Navigation_received_function_ASG03[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Navigation_app_data_ASG03[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG03[log_channel][2]);
      
      // an checkfunction übergeben
      if (Navigation_received_function_ASG03[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
      if (Navigation_received_function_ASG03[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
      if (Navigation_received_function_ASG03[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
      if (Navigation_received_function_ASG03[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
      checkFunction (Navigation_received_function_ASG03[log_channel][0], Navigation_received_function_ASG03[log_channel][1], Navigation_received_function_ASG03[log_channel][2], Navigation_app_data_ASG03[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_ASG03[log_channel][i] = 0;        

      // BAP Header auswerten
      Navigation_received_function_ASG03[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Navigation_received_function_ASG03[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Navigation_received_function_ASG03[log_channel][2] = (data[3] & 0x3F); // FctID
      Navigation_data_length_ASG03[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Navigation_app_data_ASG03[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Navigation_data_length_ASG03[log_channel] = Navigation_data_length_ASG03[log_channel] - 4;
      Navigation_currentPosASG03[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Navigation_data_length_ASG03[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG03[log_channel][2]);
        
        // an checkfunction übergeben
        if (Navigation_received_function_ASG03[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
        if (Navigation_received_function_ASG03[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
        if (Navigation_received_function_ASG03[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
        if (Navigation_received_function_ASG03[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
        checkFunction (Navigation_received_function_ASG03[log_channel][0], Navigation_received_function_ASG03[log_channel][1], Navigation_received_function_ASG03[log_channel][2], Navigation_app_data_ASG03[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Navigation_sequenceNumberASG03[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_ASG03[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Navigation_app_data_ASG03[log_channel][Navigation_currentPosASG03[log_channel]] = data[i+1];
           Navigation_currentPosASG03[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Navigation_data_length_ASG03[log_channel] = Navigation_data_length_ASG03[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_ASG03[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Navigation_data_length_ASG03[log_channel]; i++)
        {
           Navigation_app_data_ASG03[log_channel][Navigation_currentPosASG03[log_channel]] = data[i+1];
           Navigation_currentPosASG03[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG03[log_channel][2]);
        
        // an checkfunction übergeben
        if (Navigation_received_function_ASG03[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
        if (Navigation_received_function_ASG03[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
        if (Navigation_received_function_ASG03[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
        if (Navigation_received_function_ASG03[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
        checkFunction (Navigation_received_function_ASG03[log_channel][0], Navigation_received_function_ASG03[log_channel][1], Navigation_received_function_ASG03[log_channel][2], Navigation_app_data_ASG03[log_channel]);
      }
    }
  }
}

on message BAP_Navigation_ASG_04
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  Navigation_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG50_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_ASG04[log_channel][i] = 0;

      // BAP Header auswerten
      Navigation_received_function_ASG04[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Navigation_received_function_ASG04[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Navigation_received_function_ASG04[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Navigation_app_data_ASG04[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG04[log_channel][2]);
      
      // an checkfunction übergeben
      if (Navigation_received_function_ASG04[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
      if (Navigation_received_function_ASG04[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
      if (Navigation_received_function_ASG04[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
      if (Navigation_received_function_ASG04[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
      checkFunction (Navigation_received_function_ASG04[log_channel][0], Navigation_received_function_ASG04[log_channel][1], Navigation_received_function_ASG04[log_channel][2], Navigation_app_data_ASG04[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_ASG04[log_channel][i] = 0;        

      // BAP Header auswerten
      Navigation_received_function_ASG04[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Navigation_received_function_ASG04[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Navigation_received_function_ASG04[log_channel][2] = (data[3] & 0x3F); // FctID
      Navigation_data_length_ASG04[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Navigation_app_data_ASG04[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Navigation_data_length_ASG04[log_channel] = Navigation_data_length_ASG04[log_channel] - 4;
      Navigation_currentPosASG04[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Navigation_data_length_ASG04[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG04[log_channel][2]);
        
        // an checkfunction übergeben
        if (Navigation_received_function_ASG04[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
        if (Navigation_received_function_ASG04[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
        if (Navigation_received_function_ASG04[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
        if (Navigation_received_function_ASG04[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
        checkFunction (Navigation_received_function_ASG04[log_channel][0], Navigation_received_function_ASG04[log_channel][1], Navigation_received_function_ASG04[log_channel][2], Navigation_app_data_ASG04[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Navigation_sequenceNumberASG04[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_ASG04[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Navigation_app_data_ASG04[log_channel][Navigation_currentPosASG04[log_channel]] = data[i+1];
           Navigation_currentPosASG04[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Navigation_data_length_ASG04[log_channel] = Navigation_data_length_ASG04[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_ASG04[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Navigation_data_length_ASG04[log_channel]; i++)
        {
           Navigation_app_data_ASG04[log_channel][Navigation_currentPosASG04[log_channel]] = data[i+1];
           Navigation_currentPosASG04[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_ASG04[log_channel][2]);
        
        // an checkfunction übergeben
        if (Navigation_received_function_ASG04[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
        if (Navigation_received_function_ASG04[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
        if (Navigation_received_function_ASG04[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
        if (Navigation_received_function_ASG04[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
        checkFunction (Navigation_received_function_ASG04[log_channel][0], Navigation_received_function_ASG04[log_channel][1], Navigation_received_function_ASG04[log_channel][2], Navigation_app_data_ASG04[log_channel]);
      }
    }
  }
}

on message BAP_Navigation_FSG_01
{
  byte data[8];
  byte FSG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: FSG
  Navigation_Source = 2;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG50_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_FSG01[log_channel][i] = 0;

      // BAP Header auswerten
      Navigation_received_function_FSG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Navigation_received_function_FSG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Navigation_received_function_FSG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Navigation_app_data_FSG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_FSG01[log_channel][2]);
      
      // an checkfunction übergeben
      checkFunction (Navigation_received_function_FSG01[log_channel][0], Navigation_received_function_FSG01[log_channel][1], Navigation_received_function_FSG01[log_channel][2], Navigation_app_data_FSG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_FSG01[log_channel][i] = 0;        

      // BAP Header auswerten
      Navigation_received_function_FSG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Navigation_received_function_FSG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Navigation_received_function_FSG01[log_channel][2] = (data[3] & 0x3F); // FctID
      Navigation_data_length_FSG01[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Navigation_app_data_FSG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Navigation_data_length_FSG01[log_channel] = Navigation_data_length_FSG01[log_channel] - 4;
      Navigation_currentPosFSG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Navigation_data_length_FSG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_FSG01[log_channel][2]);
        
        // an checkfunction übergeben
        checkFunction (Navigation_received_function_FSG01[log_channel][0], Navigation_received_function_FSG01[log_channel][1], Navigation_received_function_FSG01[log_channel][2], Navigation_app_data_FSG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Navigation_sequenceNumberFSG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_FSG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Navigation_app_data_FSG01[log_channel][Navigation_currentPosFSG01[log_channel]] = data[i+1];
           Navigation_currentPosFSG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Navigation_data_length_FSG01[log_channel] = Navigation_data_length_FSG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_FSG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Navigation_data_length_FSG01[log_channel]; i++)
        {
           Navigation_app_data_FSG01[log_channel][Navigation_currentPosFSG01[log_channel]] = data[i+1];
           Navigation_currentPosFSG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_FSG01[log_channel][2]);
        
        // an checkfunction übergeben
        checkFunction (Navigation_received_function_FSG01[log_channel][0], Navigation_received_function_FSG01[log_channel][1], Navigation_received_function_FSG01[log_channel][2], Navigation_app_data_FSG01[log_channel]);
      }
    }
  }
}

on message BAP_Navigation_FSG_02
{
  byte data[8];
  byte FSG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: FSG
  Navigation_Source = 2;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG50_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_FSG02[log_channel][i] = 0;

      // BAP Header auswerten
      Navigation_received_function_FSG02[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      Navigation_received_function_FSG02[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      Navigation_received_function_FSG02[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          Navigation_app_data_FSG02[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_FSG02[log_channel][2]);
      
      // an checkfunction übergeben
      if (Navigation_received_function_ASG02[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
      if (Navigation_received_function_ASG02[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
      if (Navigation_received_function_ASG02[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
      if (Navigation_received_function_ASG02[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
      checkFunction (Navigation_received_function_FSG02[log_channel][0], Navigation_received_function_FSG02[log_channel][1], Navigation_received_function_FSG02[log_channel][2], Navigation_app_data_FSG02[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          Navigation_app_data_FSG02[log_channel][i] = 0;        

      // BAP Header auswerten
      Navigation_received_function_FSG02[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      Navigation_received_function_FSG02[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      Navigation_received_function_FSG02[log_channel][2] = (data[3] & 0x3F); // FctID
      Navigation_data_length_FSG02[log_channel] = ((data[0] & 0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          Navigation_app_data_FSG02[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      Navigation_data_length_FSG02[log_channel] = Navigation_data_length_FSG02[log_channel] - 4;
      Navigation_currentPosFSG02[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (Navigation_data_length_FSG02[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_FSG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Navigation_received_function_ASG02[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
        if (Navigation_received_function_ASG02[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
        if (Navigation_received_function_ASG02[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
        if (Navigation_received_function_ASG02[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
        checkFunction (Navigation_received_function_FSG02[log_channel][0], Navigation_received_function_FSG02[log_channel][1], Navigation_received_function_FSG02[log_channel][2], Navigation_app_data_FSG02[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      Navigation_sequenceNumberFSG02[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_FSG02[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
           Navigation_app_data_FSG02[log_channel][Navigation_currentPosFSG02[log_channel]] = data[i+1];
           Navigation_currentPosFSG02[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        Navigation_data_length_FSG02[log_channel] = Navigation_data_length_FSG02[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (Navigation_data_length_FSG02[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < Navigation_data_length_FSG02[log_channel]; i++)
        {
           Navigation_app_data_FSG02[log_channel][Navigation_currentPosFSG02[log_channel]] = data[i+1];
           Navigation_currentPosFSG02[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,Navigation_received_function_FSG02[log_channel][2]);
        
        // an checkfunction übergeben
        if (Navigation_received_function_ASG02[log_channel][2] == 0x18) { Navigation_LaneGuidance_Log_Channel = log_channel; } // LaneGuidance
        if (Navigation_received_function_ASG02[log_channel][2] == 0x1D) { Navigation_LastDestList_Log_Channel = log_channel; } // LastDestList
        if (Navigation_received_function_ASG02[log_channel][2] == 0x1E) { Navigation_FavoriteDestList_Log_Channel = log_channel; } // FavoriteDestList
        if (Navigation_received_function_ASG02[log_channel][2] == 0x21) { Navigation_AddressList_Log_Channel = log_channel; } // AddressList
        checkFunction (Navigation_received_function_FSG02[log_channel][0], Navigation_received_function_FSG02[log_channel][1], Navigation_received_function_FSG02[log_channel][2], Navigation_app_data_FSG02[log_channel]);
      }
    }
  }
}


// Navigation 0x18 LaneGuidance

on envVar Env_Navigation_LaneGuidance_LoadBTN
{
  @Env_LG_Source = 0; // csv

  if (@this == 1)
  {
    getValue(Env_Navigation_LaneGuidance_Path, gNavigation_LaneGuidance_Path);
    Navigation_LaneGuidance_LoadArray();    
  } 
}

on envVar Env_Navigation_LaneGuidance_LoadBTN_Full
{
  @Env_LG_Source = 0; // csv
  
  if (@this == 1)
  {
    getValue(Env_Navigation_LaneGuidance_Path, gNavigation_LaneGuidance_Path);
    Navigation_LaneGuidance_LoadArray();
    Navigation_LaneGuidance_Changed(0x0,0x0, 0x0000, 0xFF);
  } 
}

Navigation_LaneGuidance_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
    //putValue(A_FSG_50_0_0_24_fileSelector, gLaneGuidancePath);
    //putValue(A_FSG_50_0_0_24_loadArray_Btn, TRUE);
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Navigation_LaneGuidance[i].Param1 = 0;
		Navigation_LaneGuidance[i].Param2 = 0;
		for (j=0; j<33; j++) // CG: verdoppelt zweck anderer Eingabe
			Navigation_LaneGuidance[i].Param3[j] = 0;
		Navigation_LaneGuidance[i].Param3_Length = 0;
		Navigation_LaneGuidance[i].Param4 = 0;
		Navigation_LaneGuidance[i].Param5 = 0;
		Navigation_LaneGuidance[i].Param6 = 0;
		Navigation_LaneGuidance[i].Param7 = 0;
		Navigation_LaneGuidance[i].Param8 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gNavigation_LaneGuidance_Path); i++)
  {
    if (gNavigation_LaneGuidance_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gNavigation_LaneGuidance_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gNavigation_LaneGuidance_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LaneGuidance"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LaneGuidance) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Navigation_LaneGuidance[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Navigation_LaneGuidance[current_CSV_line-1].Param2 = atol(temp2); //LaneDirection
						Navigation_LaneGuidance[current_CSV_line-1].Param4 = atol(temp4); //LaneType
						Navigation_LaneGuidance[current_CSV_line-1].Param5 = atol(temp5); //LaneMarking_left
						Navigation_LaneGuidance[current_CSV_line-1].Param6 = atol(temp6); //LaneMarking_right
						Navigation_LaneGuidance[current_CSV_line-1].Param7 = atol(temp7); //LaneDescription
						Navigation_LaneGuidance[current_CSV_line-1].Param8 = atol(temp8); //GuidanceInfo
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //LaneDirection
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //LaneSidestreets // CG: verdoppelt +2 zweck anderer Eingabe
								if (paramPos < 34)
								{
									Navigation_LaneGuidance[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
									Navigation_LaneGuidance[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 4: //LaneType
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //LaneMarking_left
								if ( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //LaneMarking_right
								if ( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //LaneDescription
								if ( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //GuidanceInfo
								if ( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
 
  Navigation_LaneGuidance_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Navigation_LaneGuidance(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos, OnOff = 0x01 ;
  dword list_start, elements;

  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
    {
      ASG_ID = (data[0] >> 4) & 0xF;
      TAID = data[0] & 0xF;
      mode = (data[1] >> 4) & 0xF;
      recordaddress = data[1] & 0xF;
      IndexSize = (mode>>3) & 0x1;
      Direction = (mode>>1) & 0x1;
      TransPos = (mode>>2) & 0x1;
      Shift = (mode>>0) & 0x1;
      
      @A_FSG_50_0_0_24_1 = ASG_ID;
      @A_FSG_50_0_0_24_2 = TAID;

      if (IndexSize == 0)
      {
        list_start = data[2];
        elements = data[3];
      }
      else if (IndexSize == 1)
      {
        list_start = data[3] * 256 + data[2];
        elements = data[5] * 256 + data[4];
      }
      
      ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

      if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
        @A_FSG_50_0_0_24_1 = ASG_ID;  // Set to panel value
      else
        ASG_ID = @A_FSG_50_0_0_24_1; // Set from panel value
        
      if (@env_AutoGetArray_TAID == 0)  // TAID
        @A_FSG_50_0_0_24_2_range = TAID;
      else
        TAID = @A_FSG_50_0_0_24_2_range;
      
      if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
        @A_FSG_50_0_0_24_RecAdr = recordaddress;
      else
        recordaddress = @A_FSG_50_0_0_24_RecAdr;
      
      if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
        @A_FSG_50_0_0_24_Shift = (mode>>0);
      else
        mode = ((@A_FSG_50_0_0_24_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
        @A_FSG_50_0_0_24_Direction = (mode>>1);
      else
        mode = ((Shift*1)+(@A_FSG_50_0_0_24_Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Start == 0)  // Start
        @A_FSG_50_0_0_24_Start = list_start;
      else
        list_start = @A_FSG_50_0_0_24_Start;
      
      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
      {
        if (@Env_LG_Source == 0) // csv
        {
          Navigation_LaneGuidance_Status(ASG_ID, TAID, mode, recordaddress, list_start, elements, OnOff);
        }
      }
    }
  }
  
  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
  {
    if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
    {
      ASG_ID = (data[0] >> 4) & 0xF;
      TAID = data[0] & 0xF;
      mode = (data[1] >> 4) & 0xF;
      recordaddress = data[1] & 0xF;
      IndexSize = (mode>>3) & 0x1;
      Direction = (mode>>1) & 0x1;
      TransPos = (mode>>2) & 0x1;
      Shift = (mode>>0) & 0x1;
      
      @A_FSG_50_0_0_28_1 = ASG_ID;
      @A_FSG_50_0_0_28_2 = TAID;
      
      if (IndexSize == 0)
      {
        list_start = data[2];
        elements = data[3];
      }
      else if (IndexSize == 1)
      {
        list_start = data[3] * 256 + data[2];
        elements = data[5] * 256 + data[4];
      }
      
      ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

      if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
        @A_FSG_50_0_0_28_1 = ASG_ID;  // Set to panel value
      else
        ASG_ID = @A_FSG_50_0_0_28_1; // Set from panel value
        
      if (@env_AutoGetArray_TAID == 0)  // TAID
        @A_FSG_50_0_0_28_2_range = TAID;
      else
        TAID = @A_FSG_50_0_0_28_2_range;
      
      if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
        @A_FSG_50_0_0_28_RecAdr = recordaddress;
      else
        recordaddress = @A_FSG_50_0_0_28_RecAdr;
      
      if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
        @A_FSG_50_0_0_28_Shift = (mode>>0);
      else
        mode = ((@A_FSG_50_0_0_28_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
        @A_FSG_50_0_0_28_Direction = (mode>>1);
      else
        mode = ((Shift*1)+(@A_FSG_50_0_0_28_Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Start == 0)  // Start
        @A_FSG_50_0_0_28_Start = list_start;
      else
        list_start = @A_FSG_50_0_0_28_Start;
      
      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
      {
        if (@Env_LG_Source == 0) // csv
        {
          Navigation_LaneGuidance_Status(ASG_ID, TAID, mode, recordaddress, list_start, elements, OnOff);
        }
      }
    }
  }
}

Navigation_LaneGuidance_Status (byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements, byte OnOff)
{   
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition, increment = 1, elements ;
  byte sequenceNumber = 0;
  byte length_temp;
  
  int i,j,k, strctr; 
  int stringsize;   
  
  elements = received_elements;

  Data_Navigation_LaneGuidance[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Navigation_LaneGuidance[1] = OnOff;
  Data_Navigation_LaneGuidance[2] = (mode|0x4)*16 + (recordaddress & 0xF);
  IndexSize  = (mode>>3) & 0x1;
  direction  = (mode>>1) & 0x1;
  shift      = mode & 0x1;

  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift;
        endposition = startposition + elements - 1;
      }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (list_start < Navigation_LaneGuidance_TotalListNum)
        {
          startposition = list_start + shift - 1;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Navigation_LaneGuidance_TotalListNum)
      {
        endposition = Navigation_LaneGuidance_TotalListNum - 1;
        elements = Navigation_LaneGuidance_TotalListNum - startposition;
      }
      break;
    
      case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (list_start <= Navigation_LaneGuidance_TotalListNum)
        {
          startposition = list_start - shift - 1;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift + 1;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Navigation_LaneGuidance_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
    break;
  }
  
  Data_Navigation_LaneGuidance[3] = list_start & 0xFF;
  Data_Navigation_LaneGuidance[4] = elements & 0xFF;

  j_Navigation_LaneGuidance = 5;

  switch(direction)
  {
    case 0:
      
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        // Pos
        Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param1;

        // LaneDirection
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2)
            Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param2;
        
        // LaneSidestreets
        if ((recordaddress == 0x0 || recordaddress == 0x1) && @Env_LG_Source == 0) //CSV
        {
          // Länge des Strings: '0x' vorn wegschneiden, durch 2 teilen = Anzahl der Datenbytes
          if (Navigation_LaneGuidance[i].param3_Length !=0)
            length_temp = ((Navigation_LaneGuidance[i].param3_Length-2)/2);
          else
            length_temp = 0;
         
          Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = length_temp;
          
          if (length_temp != 0)
          {
            // String auswerten
            for (j=2;j<=length_temp*2;j++)
            {
              // 0...9
              if (Navigation_LaneGuidance[i].param3[j] >= 0x30 && Navigation_LaneGuidance[i].param3[j] <= 0x39) 
              {
                if (Navigation_LaneGuidance[i].param3[j+1] == 0x30)
                {
                  Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = (Navigation_LaneGuidance[i].param3[j]-0x30)*16;
                }
                else
                {
                  Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = (Navigation_LaneGuidance[i].param3[j]-0x30)*16 + Navigation_LaneGuidance[i].param3[j+1]-0x30;
                }
                  
                j++;
              }
              
              // A...F
              if (Navigation_LaneGuidance[i].param3[j] >= 0x41 && Navigation_LaneGuidance[i].param3[j] <= 0x46)
              {
                if (Navigation_LaneGuidance[i].param3[j+1] == 0x30)
                {
                  Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = ((Navigation_LaneGuidance[i].param3[j]-55)*16);
                }
                else
                {
                  Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = ((Navigation_LaneGuidance[i].param3[j]-55)*16) + Navigation_LaneGuidance[i].param3[j+1]-0x30;
                }
                  
                j++;
              }
              
              // a...f
              if (Navigation_LaneGuidance[i].param3[j] >= 0x61 && Navigation_LaneGuidance[i].param3[j] <= 0x66)
              {
                if (Navigation_LaneGuidance[i].param3[j+1] == 0x30)
                {
                  Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = ((Navigation_LaneGuidance[i].param3[j]-87)*16);
                }
                else
                {
                  Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = ((Navigation_LaneGuidance[i].param3[j]-87)*16) + Navigation_LaneGuidance[i].param3[j+1]-0x30;
                }
                  
                j++;
              }
            }
          }
        }
        
        if ((recordaddress == 0x0 || recordaddress == 0x1) && @Env_LG_Source == 1) // Panel
        { 
          Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param3_Length;
          stringsize = Navigation_LaneGuidance[i].param3_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param3[strctr];            
          }
        }

        // LaneMarking_left
        if (recordaddress == 0x0 || recordaddress == 0x1 )
          Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param4;
        
        // LaneMarking_right
        if (recordaddress == 0x0 )
          Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = (Navigation_LaneGuidance[i].param5 & 0xF) *16 + (Navigation_LaneGuidance[i].param6 & 0xF);
        
        // LaneDescription
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3)
          Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = (Navigation_LaneGuidance[i].param7 & 0xF) *16 + (Navigation_LaneGuidance[i].param8 & 0xF);
 
      }
      
    break;
    
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        // Pos
        switch(IndexSize)
        {
          case 0: Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param1;
                  break;
          case 1: Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param1 &0xFF;
                  Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = (Navigation_LaneGuidance[i].param1 >> 8)&0xFF;
                  break;
        }
        
        // LaneDirection
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2)
          Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param2;
        
        // LaneSidestreets
        if (recordaddress == 0x0 || recordaddress == 0x1)
        {
          Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param3_Length;
          stringsize = Navigation_LaneGuidance[i].param3_Length;

          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param3[strctr];            
          }
        }
        
        // LaneMarking_left
        if (recordaddress == 0x0 || recordaddress == 0x1 )
          Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = Navigation_LaneGuidance[i].param4;
        
        // LaneMarking_right
        if (recordaddress == 0x0 )
          Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = (Navigation_LaneGuidance[i].param5 & 0xF) *16 + (Navigation_LaneGuidance[i].param6 & 0xF);
        
        // LaneDescription
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x3)
          Data_Navigation_LaneGuidance[j_Navigation_LaneGuidance++] = (Navigation_LaneGuidance[i].param7 & 0xF) *16 + (Navigation_LaneGuidance[i].param8 & 0xF);
      }
      
    break;
  }
  settimer (Delay_Navigation_LaneGuidance, @Env_Navigation_LaneGuidance_ListDelay);
}

Navigation_LaneGuidance_Changed (byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 

  data[0] = 1; ///LG an
  data[1] = mode && recordaddress<<4;
  data[2] = list_start;
  data[3] = elements;
  length = 4;

  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
    SendRequestByteSequence(LSGID_Navigation, 0x18, Changed_REQ, length, data);
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
    SendRequestByteSequence(LSGID_Navigation, 0x1C, Changed_REQ, length, data);
}

on timer Delay_Navigation_LaneGuidance
{
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
    sendRequestByteSequence(LSGID_Navigation, 0x18, Data_REQ, j_Navigation_LaneGuidance, Data_Navigation_LaneGuidance);
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
    sendRequestByteSequence(LSGID_Navigation, 0x1C, Data_REQ, j_Navigation_LaneGuidance, Data_Navigation_LaneGuidance);
}


// Navigation 0x3D LaneGuidance2

on envVar Env_Navigation_LaneGuidance2_LoadBTN
{
  @Env_LG2_Source = 0; // csv

  if (@this == 1)
  {
    getValue(Env_Navigation_LaneGuidance2_Path, gNavigation_LaneGuidance2_Path);
    Navigation_LaneGuidance2_LoadArray();    
  } 
}

on envVar Env_Navigation_LaneGuidance2_LoadBTN_Full
{
  @Env_LG2_Source = 0; // csv
  
  if (@this == 1)
  {
    getValue(Env_Navigation_LaneGuidance2_Path, gNavigation_LaneGuidance2_Path);
    Navigation_LaneGuidance2_LoadArray();
    Navigation_LaneGuidance2_Changed(0x0,0x0, 0x0000, 0xFF);
  } 
}

Navigation_LaneGuidance2_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
    char CSV_filepath[255];
    byte pos;
    byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];
	char temp11[25];
	char temp12[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
    //putValue(A_FSG_50_0_0_61_fileSelector, gLaneGuidance2Path);
    //putValue(A_FSG_50_0_0_61_loadArray_Btn, TRUE);
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Navigation_LaneGuidance2[i].Param1 = 0;
		Navigation_LaneGuidance2[i].Param2 = 0;	
		Navigation_LaneGuidance2[i].Param3 = 0;
		Navigation_LaneGuidance2[i].Param4 = 0;
		Navigation_LaneGuidance2[i].Param5 = 0;
		Navigation_LaneGuidance2[i].Param6 = 0;
		for (j=0; j<33; j++) // CG: verdoppelt zweck anderer Eingabe
			Navigation_LaneGuidance2[i].Param7[j] = 0;		
		Navigation_LaneGuidance2[i].Param8 = 0;
		Navigation_LaneGuidance2[i].Param9 = 0;
		Navigation_LaneGuidance2[i].Param10 = 0;
		Navigation_LaneGuidance2[i].Param11 = 0;
		Navigation_LaneGuidance2[i].Param12 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gNavigation_LaneGuidance2_Path); i++)
   {
      if (gNavigation_LaneGuidance2_Path[i] == '\\' )
      pos = i;
   }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gNavigation_LaneGuidance2_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gNavigation_LaneGuidance2_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LaneGuidance"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LaneGuidance2) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Navigation_LaneGuidance2[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Navigation_LaneGuidance2[current_CSV_line-1].Param2 = atol(temp2); //LaneFocus 
						Navigation_LaneGuidance2[current_CSV_line-1].Param3 = atol(temp3); //LaneDirection1 
						Navigation_LaneGuidance2[current_CSV_line-1].Param4 = atol(temp4); //LaneDirection2 
						Navigation_LaneGuidance2[current_CSV_line-1].Param5 = atol(temp5); //GuidanceInfo1 
						Navigation_LaneGuidance2[current_CSV_line-1].Param6 = atol(temp6); //GuidanceInfo2 
						Navigation_LaneGuidance2[current_CSV_line-1].Param8 = atol(temp8); //LaneType 
						Navigation_LaneGuidance2[current_CSV_line-1].Param9 = atol(temp9); //LaneMarking_left 
						Navigation_LaneGuidance2[current_CSV_line-1].Param10 = atol(temp10); //LaneMarking_right 
						Navigation_LaneGuidance2[current_CSV_line-1].Param11 = atol(temp11); //LaneAttributes 
						Navigation_LaneGuidance2[current_CSV_line-1].Param12 = atol(temp12); //LaneDescription 
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
							temp11[i]=0;
							temp12[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //LaneFocus
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //LaneDirection1
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
						break;
						case 4: //LaneDirection2
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //GuidanceInfo1
								if ( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //GuidanceInfo2
								if ( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //LaneSidestreets 
								if (paramPos < 34)
								{
									Navigation_LaneGuidance2[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
									Navigation_LaneGuidance2[current_CSV_line-1].Param7_Length = paramPos +1;
								}
								paramPos++;
							break;
						case 8: //LaneType
								if ( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //LaneMarking_left
								if ( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //LaneMarking_right
								if ( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 11: //LaneAttributes
								if ( paramPos >= elCount(temp11) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp11[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 12: //LaneDescription
								if ( paramPos >= elCount(temp12) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp12[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
 
  Navigation_LaneGuidance2_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Navigation_LaneGuidance2(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos, OnOff = 0x01, CurrentCarPosition = 0x0, RecommendedCarPosition = 0x0;
  dword list_start, elements;

  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
    {
      ASG_ID = (data[0] >> 4) & 0xF;
      TAID = data[0] & 0xF;
      mode = (data[1] >> 4) & 0xF;
      recordaddress = data[1] & 0xF;
      IndexSize = (mode>>3) & 0x1;
      Direction = (mode>>1) & 0x1;
      TransPos = (mode>>2) & 0x1;
      Shift = (mode>>0) & 0x1;
      
      @A_FSG_50_0_0_61_1 = ASG_ID;
      @A_FSG_50_0_0_61_2 = TAID;

      if (IndexSize == 0)
      {
        list_start = data[2];
        elements = data[3];
      }
      else if (IndexSize == 1)
      {
        list_start = data[3] * 256 + data[2];
        elements = data[5] * 256 + data[4];
      }
      
      ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

      if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
        @A_FSG_50_0_0_61_1 = ASG_ID;  // Set to panel value
      else
        ASG_ID = @A_FSG_50_0_0_61_1; // Set from panel value
        
      if (@env_AutoGetArray_TAID == 0)  // TAID
        @A_FSG_50_0_0_61_2_range = TAID;
      else
        TAID = @A_FSG_50_0_0_61_2_range;
      
      if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
        @A_FSG_50_0_0_61_RecAdr = recordaddress;
      else
        recordaddress = @A_FSG_50_0_0_61_RecAdr;
      
      if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
        @A_FSG_50_0_0_61_Shift = (mode>>0);
      else
        mode = ((@A_FSG_50_0_0_61_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
        @A_FSG_50_0_0_61_Direction = (mode>>1);
      else
        mode = ((Shift*1)+(@A_FSG_50_0_0_61_Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Start == 0)  // Start
        @A_FSG_50_0_0_61_Start = list_start;
      else
        list_start = @A_FSG_50_0_0_61_Start;
      
      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
      {
        if (@Env_LG2_Source == 0) // csv
        {
          Navigation_LaneGuidance2_Status(ASG_ID, TAID, mode, recordaddress, list_start, elements, OnOff, CurrentCarPosition, RecommendedCarPosition);
        }
      }
    }
  }
  
  
  
  /*if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
  {
    if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
    {
      ASG_ID = (data[0] >> 4) & 0xF;
      TAID = data[0] & 0xF;
      mode = (data[1] >> 4) & 0xF;
      recordaddress = data[1] & 0xF;
      IndexSize = (mode>>3) & 0x1;
      Direction = (mode>>1) & 0x1;
      TransPos = (mode>>2) & 0x1;
      Shift = (mode>>0) & 0x1;
      
      @A_FSG_50_0_0_28_1 = ASG_ID;
      @A_FSG_50_0_0_28_2 = TAID;
      
      if (IndexSize == 0)
      {
        list_start = data[2];
        elements = data[3];
      }
      else if (IndexSize == 1)
      {
        list_start = data[3] * 256 + data[2];
        elements = data[5] * 256 + data[4];
      }
      
      ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

      if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
        @A_FSG_50_0_0_28_1 = ASG_ID;  // Set to panel value
      else
        ASG_ID = @A_FSG_50_0_0_28_1; // Set from panel value
        
      if (@env_AutoGetArray_TAID == 0)  // TAID
        @A_FSG_50_0_0_28_2_range = TAID;
      else
        TAID = @A_FSG_50_0_0_28_2_range;
      
      if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
        @A_FSG_50_0_0_28_RecAdr = recordaddress;
      else
        recordaddress = @A_FSG_50_0_0_28_RecAdr;
      
      if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
        @A_FSG_50_0_0_28_Shift = (mode>>0);
      else
        mode = ((@A_FSG_50_0_0_28_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
        @A_FSG_50_0_0_28_Direction = (mode>>1);
      else
        mode = ((Shift*1)+(@A_FSG_50_0_0_28_Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Start == 0)  // Start
        @A_FSG_50_0_0_28_Start = list_start;
      else
        list_start = @A_FSG_50_0_0_28_Start;
      
      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
      {
        if (@Env_LG2_Source == 0) // csv
        {
          Navigation_LaneGuidance2_Status(ASG_ID, TAID, mode, recordaddress, list_start, elements, OnOff, CurrentCarPosition, RecommendedCarPosition);
        }
      }
    }
  }*/
}

Navigation_LaneGuidance2_Status (byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements, byte OnOff, byte CurrentCarPosition, byte RecommendedCarPosition)
{   
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition, increment = 1, elements ;
  byte sequenceNumber = 0;
  byte length_temp;
  
  int i,j,k, strctr; 
  int stringsize;   
  
  elements = received_elements;

  Data_Navigation_LaneGuidance2[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Navigation_LaneGuidance2[1] = OnOff;
  Data_Navigation_LaneGuidance2[2] = CurrentCarPosition;
  Data_Navigation_LaneGuidance2[3] = RecommendedCarPosition;
  Data_Navigation_LaneGuidance2[4] = (mode|0x4)*16 + (recordaddress & 0xF);
  IndexSize  = (mode>>3) & 0x1;
  direction  = (mode>>1) & 0x1;
  shift      = mode & 0x1;

  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift;
        endposition = startposition + elements - 1;
      }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (list_start < Navigation_LaneGuidance2_TotalListNum)
        {
          startposition = list_start + shift;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Navigation_LaneGuidance2_TotalListNum)
      {
        endposition = Navigation_LaneGuidance2_TotalListNum - 1;
        elements = Navigation_LaneGuidance2_TotalListNum - startposition;
      }
      break;
    
      case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (list_start <= Navigation_LaneGuidance2_TotalListNum)
        {
          startposition = list_start - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift + 1;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Navigation_LaneGuidance2_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
    break;
  }
  
  Data_Navigation_LaneGuidance2[5] = list_start & 0xFF;
  Data_Navigation_LaneGuidance2[6] = elements & 0xFF;

  j_Navigation_LaneGuidance2 = 7;

  switch(direction)
  {
    case 0:
      
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {	
		// Pos
        switch(IndexSize)
        {
          case 0: Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param1;
                  break;
          case 1: Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param1 &0xFF;
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = (Navigation_LaneGuidance2[i].param1 >> 8)&0xFF;
                  break;
        }

        // LaneFocus 
        if (recordaddress == 0x1)
            Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param2;
		
		// LaneDirection1  
		if (recordaddress == 0x1)
            Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param3;
			
		// LaneDirection2
		if (recordaddress == 0x1)
            Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param4;
		
		// GuidanceInfo1 & GuidanceInfo2
		if (recordaddress == 0x1)
            Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = (Navigation_LaneGuidance2[i].param5 & 0xF) *16 + (Navigation_LaneGuidance2[i].param6 & 0xF);
        
        // LaneSidestreets
        if ((recordaddress == 0x1) && @Env_LG2_Source == 0) //CSV
        {
          // Länge des Strings: '0x' vorn wegschneiden, durch 2 teilen = Anzahl der Datenbytes
          if (Navigation_LaneGuidance2[i].param7_Length !=0)
            length_temp = ((Navigation_LaneGuidance2[i].param7_Length-2)/2);
          else
            length_temp = 0;
         
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = length_temp;
          
          if (length_temp != 0)
          {
            // String auswerten
            for (j=2;j<=length_temp*2;j++)
            {
              // 0...9
              if (Navigation_LaneGuidance2[i].param7[j] >= 0x30 && Navigation_LaneGuidance2[i].param7[j] <= 0x39) 
              {
                if (Navigation_LaneGuidance2[i].param7[j+1] == 0x30)
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = (Navigation_LaneGuidance2[i].param7[j]-0x30)*16;
                }
                else
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = (Navigation_LaneGuidance2[i].param7[j]-0x30)*16 + Navigation_LaneGuidance2[i].param7[j+1]-0x30;
                }
                  
                j++;
              }
              
              // A...F
              if (Navigation_LaneGuidance2[i].param7[j] >= 0x41 && Navigation_LaneGuidance2[i].param7[j] <= 0x46)
              {
                if (Navigation_LaneGuidance2[i].param7[j+1] == 0x30)
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = ((Navigation_LaneGuidance2[i].param7[j]-55)*16);
                }
                else
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = ((Navigation_LaneGuidance2[i].param7[j]-55)*16) + Navigation_LaneGuidance2[i].param7[j+1]-0x30;
                }
                  
                j++;
              }
              
              // a...f
              if (Navigation_LaneGuidance2[i].param7[j] >= 0x61 && Navigation_LaneGuidance2[i].param7[j] <= 0x66)
              {
                if (Navigation_LaneGuidance2[i].param7[j+1] == 0x30)
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = ((Navigation_LaneGuidance2[i].param7[j]-87)*16);
                }
                else
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = ((Navigation_LaneGuidance2[i].param7[j]-87)*16) + Navigation_LaneGuidance2[i].param7[j+1]-0x30;
                }
                  
                j++;
              }
            }
          }
        }
        
        if ((recordaddress == 0x1) && @Env_LG2_Source == 1) // Panel
        { 
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param7_Length;
          stringsize = Navigation_LaneGuidance2[i].param7_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param7[strctr];            
          }
        }

        // LaneType 
        if (recordaddress == 0x1)
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param8;
        
        // LaneMarking_left &  LaneMarking_right 
        if (recordaddress == 0x1)
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = (Navigation_LaneGuidance2[i].param9 & 0xF) *16 + (Navigation_LaneGuidance2[i].param10 & 0xF);
        
        // LaneAttributes 
        if (recordaddress == 0x1)
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param11;
		 
		// LaneDescription 
        if (recordaddress == 0x1)
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param12;
      }
      
    break;
    
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        // Pos
        switch(IndexSize)
        {
          case 0: Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param1;
                  break;
          case 1: Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param1 &0xFF;
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = (Navigation_LaneGuidance2[i].param1 >> 8)&0xFF;
                  break;
        }
        
        // LaneFocus 
        if (recordaddress == 0x1)
            Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param2;
		
		// LaneDirection1  
		if (recordaddress == 0x1)
            Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param3;
			
		// LaneDirection2
		if (recordaddress == 0x1)
            Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param4;
		
		// GuidanceInfo1 & GuidanceInfo2
		if (recordaddress == 0x1)
            Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = (Navigation_LaneGuidance2[i].param5 & 0xF) *16 + (Navigation_LaneGuidance2[i].param6 & 0xF);
        
        // LaneSidestreets
        if ((recordaddress == 0x1) && @Env_LG2_Source == 0) //CSV
        {
          // Länge des Strings: '0x' vorn wegschneiden, durch 2 teilen = Anzahl der Datenbytes
          if (Navigation_LaneGuidance2[i].param7_Length !=0)
            length_temp = ((Navigation_LaneGuidance2[i].param7_Length-2)/2);
          else
            length_temp = 0;
         
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = length_temp;
          
          if (length_temp != 0)
          {
            // String auswerten
            for (j=2;j<=length_temp*2;j++)
            {
              // 0...9
              if (Navigation_LaneGuidance2[i].param7[j] >= 0x30 && Navigation_LaneGuidance2[i].param7[j] <= 0x39) 
              {
                if (Navigation_LaneGuidance2[i].param7[j+1] == 0x30)
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = (Navigation_LaneGuidance2[i].param7[j]-0x30)*16;
                }
                else
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = (Navigation_LaneGuidance2[i].param7[j]-0x30)*16 + Navigation_LaneGuidance2[i].param7[j+1]-0x30;
                }
                  
                j++;
              }
              
              // A...F
              if (Navigation_LaneGuidance2[i].param7[j] >= 0x41 && Navigation_LaneGuidance2[i].param7[j] <= 0x46)
              {
                if (Navigation_LaneGuidance2[i].param7[j+1] == 0x30)
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = ((Navigation_LaneGuidance2[i].param7[j]-55)*16);
                }
                else
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = ((Navigation_LaneGuidance2[i].param7[j]-55)*16) + Navigation_LaneGuidance2[i].param7[j+1]-0x30;
                }
                  
                j++;
              }
              
              // a...f
              if (Navigation_LaneGuidance2[i].param7[j] >= 0x61 && Navigation_LaneGuidance2[i].param7[j] <= 0x66)
              {
                if (Navigation_LaneGuidance2[i].param7[j+1] == 0x30)
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = ((Navigation_LaneGuidance2[i].param7[j]-87)*16);
                }
                else
                {
                  Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = ((Navigation_LaneGuidance2[i].param7[j]-87)*16) + Navigation_LaneGuidance2[i].param7[j+1]-0x30;
                }
                  
                j++;
              }
            }
          }
        }
        
        if ((recordaddress == 0x1) && @Env_LG2_Source == 1) // Panel
        { 
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param7_Length;
          stringsize = Navigation_LaneGuidance2[i].param7_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param7[strctr];            
          }
        }

        // LaneType 
        if (recordaddress == 0x1)
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param8;
        
        // LaneMarking_left &  LaneMarking_right 
        if (recordaddress == 0x1)
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = (Navigation_LaneGuidance2[i].param9 & 0xF) *16 + (Navigation_LaneGuidance2[i].param10 & 0xF);
        
        // LaneAttributes 
        if (recordaddress == 0x1)
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param11;
		 
		// LaneDescription 
        if (recordaddress == 0x1)
          Data_Navigation_LaneGuidance2[j_Navigation_LaneGuidance2++] = Navigation_LaneGuidance2[i].param12;
      }
      
    break;
  }
  settimer (Delay_Navigation_LaneGuidance2, @Env_Navigation_LaneGuidance2_ListDelay);
}

Navigation_LaneGuidance2_Changed (byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 

  data[0] = 1; ///LG an
  data[1] = 0; // CurrentCarPosition
  data[2] = 0; // RecommendedCarPosition
  data[3] = mode && recordaddress<<4;
  data[4] = list_start;
  data[5] = elements;
  length = 6;

  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
    SendRequestByteSequence(LSGID_Navigation, 0x3D, Changed_REQ, length, data);
  /*if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
    SendRequestByteSequence(LSGID_Navigation, 0x1C, Changed_REQ, length, data);*/
}

on timer Delay_Navigation_LaneGuidance2
{
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
    sendRequestByteSequence(LSGID_Navigation, 0x3D, Data_REQ, j_Navigation_LaneGuidance2, Data_Navigation_LaneGuidance2);
  /*if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
    sendRequestByteSequence(LSGID_Navigation, 0x1C, Data_REQ, j_Navigation_LaneGuidance, Data_Navigation_LaneGuidance);*/
}

// Navigation 0x3E Picture

on envVar Env_Navigation_Picture_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Navigation_Picture_Path, gNavigation_Picture_Path);
    Navigation_Picture_LoadArray();
  } 
}

on envVar Env_Navigation_Picture_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Navigation_Picture_Path, gNavigation_Picture_Path);
    Navigation_Picture_LoadArray();
    Navigation_Picture_Changed(0x0,0x0, 0x00, 0xFF);
  } 
}

Navigation_Picture_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte  buffer_byte[0xFFFF];
	dword i;
	dword j;
	char  CSV_filename[255];
  char  CSV_filepath[255];
  byte  pos;
  byte  empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
  
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Navigation_Picture[i].Param1 = 0;
		Navigation_Picture[i].Param2 = 0;
		for(j=0; j<33; j++)
			Navigation_Picture[i].Param3[j] = 0;
		Navigation_Picture[i].Param3_Length = 0;
		Navigation_Picture[i].Param4 = 0;
		for(j=0; j<602; j++)
			Navigation_Picture[i].Param5[j] = 0;
		Navigation_Picture[i].Param5_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gNavigation_Picture_Path); i++)
  {
    if (gNavigation_Picture_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gNavigation_Picture_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gNavigation_Picture_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
    //writelineEx(4, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "Navigation_Picture"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
            
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in Navigation_Picture) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Navigation_Picture[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Navigation_Picture[current_CSV_line-1].Param2 = atol(temp2); //PictureType 
						Navigation_Picture[current_CSV_line-1].Param4 = atol(temp4); //TCP_Port
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PictureType
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //IPv6_Address
								if(paramPos < 16)
								{
								  // 0...9
								  if (buffer_byte[filePos] >= 0x30 && buffer_byte[filePos] <= 0x39)
								  {
									if (buffer_byte[filePos+1] == 0x30)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] = (buffer_byte[filePos]-0x30)*16;
									  
									if (buffer_byte[filePos+1] > 0x30 && buffer_byte[filePos+1] <= 0x39)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] = (buffer_byte[filePos]-0x30)*16 + (buffer_byte[filePos+1]-0x30);
									
									if (buffer_byte[filePos+1] >= 0x41 && buffer_byte[filePos+1] <= 0x46)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] = (buffer_byte[filePos]-0x30)*16 + (buffer_byte[filePos+1]-0x37);
									
									if (buffer_byte[filePos+1] >= 0x61 && buffer_byte[filePos+1] <= 0x66)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] = (buffer_byte[filePos]-0x30)*16 + (buffer_byte[filePos+1]-0x57);
								  }
												
								  // A...F
								  if (buffer_byte[filePos] >= 0x41 && buffer_byte[filePos] <= 0x46)
								  {
									if (buffer_byte[filePos+1] == 0x30)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] = ((buffer_byte[filePos]-0x37)*16);
									  
									if (buffer_byte[filePos+1] > 0x30 && buffer_byte[filePos+1] <= 0x39)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x37)*16 + (buffer_byte[filePos+1]-0x30);
									
									if (buffer_byte[filePos+1] >= 0x41 && buffer_byte[filePos+1] <= 0x46)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x37)*16 + (buffer_byte[filePos+1]-0x37);
									
									if (buffer_byte[filePos+1] >= 0x61 && buffer_byte[filePos+1] <= 0x66)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x37)*16 + (buffer_byte[filePos+1]-0x57);
								  }
								  
								  // a...f
								  if (buffer_byte[filePos] >= 0x61 && buffer_byte[filePos] <= 0x66)
								  {
									if (buffer_byte[filePos+1] == 0x30)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] = ((buffer_byte[filePos]-0x57)*16);

									if (buffer_byte[filePos+1] == 0x30)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] = ((buffer_byte[filePos]-0x57)*16);
									  
									if (buffer_byte[filePos+1] > 0x30 && buffer_byte[filePos+1] <= 0x39)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x57)*16 + (buffer_byte[filePos+1]-0x30);
									
									if (buffer_byte[filePos+1] >= 0x41 && buffer_byte[filePos+1] <= 0x46)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x57)*16 + (buffer_byte[filePos+1]-0x37);
									
									if (buffer_byte[filePos+1] >= 0x61 && buffer_byte[filePos+1] <= 0x66)
									  Navigation_Picture[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x57)*16 + (buffer_byte[filePos+1]-0x57);
								  }
								}
							  Navigation_Picture[current_CSV_line-1].Param3_Length = 16;
							  filePos++;
							break;
						case 4: //TCP_Port
							if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //URI
								if(paramPos < 600)
								{
									Navigation_Picture[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									Navigation_Picture[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}

  Navigation_Picture_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Navigation_Picture(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte Shift, Direction, TransPos;
  dword list_start, elements;

  if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;

    list_start = data[2];
    elements = data[3];
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_50_0_0_62_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_50_0_0_62_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_50_0_0_62_2 = TAID;
    else
      TAID = @A_FSG_50_0_0_62_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_50_0_0_62_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_50_0_0_62_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_50_0_0_62_Shift = (mode>>0);
    else
      mode = ((@A_FSG_50_0_0_62_Shift*1)+(Direction*2)+(TransPos*4));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_50_0_0_62_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_50_0_0_62_Direction*2)+(TransPos*4));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_50_0_0_62_Start = list_start;
    else
      list_start = @A_FSG_50_0_0_62_Start;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      Navigation_Picture_Status(ASG_ID, TAID, mode, recordaddress,list_start, elements);
    }
  }
}

Navigation_Picture_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction;
  int startposition, endposition, increment = 1, elements ;
  byte sequenceNumber = 0;
  
  int i, k , strctr;
  int stringsize;

  elements = received_elements;

  Data_Navigation_Picture[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Navigation_Picture[1] = Navigation_Picture_TotalListNum & 0xFF;
  Data_Navigation_Picture[2] = (mode|0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung
      
      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift; 
        endposition   = startposition + elements - 1; 
      }
      
      // Start in Liste
      if ((float) Navigation_Picture_Search_Pos(list_start) != 0)
      {
        startposition = Navigation_Picture_Search_Pos(list_start) - 1 + shift;
        endposition = startposition + elements - 1;
      }
      else
        {
          startposition = list_start + shift;
          elements = 0;
        }

      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Navigation_Picture_TotalListNum)
      {
        endposition = Navigation_Picture_TotalListNum - 1;
        elements = Navigation_Picture_TotalListNum - startposition;
      }

    break;
    
    case 1: // Anfrage in neg. Richtung
	
	// Start bei Listenbeginn
        if ((list_start == 0))
        {
          // Abfrage letzte Listenelemente
          if (shift == 1)
          {
            startposition = Navigation_Picture_TotalListNum - 1;
            endposition = startposition - elements + 1;
          }
		  else
          elements = 0;
        }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Navigation_Picture_Search_Pos(list_start) != 0)
        {
          startposition = Navigation_Picture_Search_Pos(list_start) - 1 - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift;
        }
      }
      
    break;
  }

  Data_Navigation_Picture[3] = list_start & 0xFF;
  Data_Navigation_Picture[4] = elements & 0xFF;

  j_Navigation_Picture = 5;
  
  switch(direction)
  {
    case 0:
      
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param1; // Pos
        
        if (recordaddress == 0x1 )  //PictureType
        {
          Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param2;
        }
        
        if (recordaddress == 0x1) //IPv6_Address
        {
          Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param3_Length;
          stringsize = Navigation_Picture[i].param3_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param3[strctr];
          }
        }
        
        if (recordaddress == 0x1)  //TCP_Port
        {
          Data_Navigation_Picture[j_Navigation_Picture++] =  Navigation_Picture[i].param4 & 0xFF;
          Data_Navigation_Picture[j_Navigation_Picture++] = (Navigation_Picture[i].param4 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x1) //URI
        {
          Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param5_Length;
          stringsize = Navigation_Picture[i].param5_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param5[strctr];
          }
        }
      }
      
    break;
          
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param1; // Pos
        
        if (recordaddress == 0x1)  //PictureType
        {
          Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param2;
        }
        
        if (recordaddress == 0x1) //IPv6_Address
        {
          Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param3_Length;
          stringsize = Navigation_Picture[i].param3_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param3[strctr];
          }
        }
        
        if (recordaddress == 0x1)  //TCP_Port
        {
          Data_Navigation_Picture[j_Navigation_Picture++] =  Navigation_Picture[i].param4 & 0xFF;
          Data_Navigation_Picture[j_Navigation_Picture++] = (Navigation_Picture[i].param4 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x1) //URI
        {
          Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param5_Length;
          stringsize = Navigation_Picture[i].param5_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Navigation_Picture[j_Navigation_Picture++] = Navigation_Picture[i].param5[strctr];
          }
        }
      }
    break;
  }
  settimer (Delay_Navigation_Picture, @Env_Navigation_Picture_ListDelay);
}

dword Navigation_Picture_Search_Pos (dword position)
{
  int i;
  
  for (i = 0; i < Navigation_Picture_TotalListNum; i++)
  {
    if (position == Navigation_Picture[i].param1)
    {
      return i+1; // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}

Navigation_Picture_Changed (byte mode, byte recordaddress, byte list_start, byte elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift;
  int startposition, endposition, increment = 1;
  byte sequenceNumber = 0;
  
  int i, strctr; 
  int stringsize;  

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  Data_Navigation_Picture[0] = (mode & 0xF) *16 + (recordaddress & 0xF);
  Data_Navigation_Picture[1] = list_start;
  Data_Navigation_Picture[2] = elements;
  j_Navigation_Picture = 3;
  
  SendRequestByteSequence(LSGID_Navigation, 0x3E, Changed_REQ, j_Navigation_Picture, Data_Navigation_Picture);
}

on timer Delay_Navigation_Picture
{
  sendRequestByteSequence(LSGID_Navigation, 0x3E, Data_REQ, j_Navigation_Picture, Data_Navigation_Picture);
}

// Navigation 0x3A VideoStreams

on envVar Env_Navigation_VideoStreams_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Navigation_VideoStreams_Path, gNavigation_VideoStreams_Path);
    Navigation_VideoStreams_LoadArray();
  } 
}

on envVar Env_Navigation_VideoStreams_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Navigation_VideoStreams_Path, gNavigation_VideoStreams_Path);
    Navigation_VideoStreams_LoadArray();
    Navigation_VideoStreams_Changed(0x0,0x0, 0x00, 0xFF);
  } 
}

Navigation_VideoStreams_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte  buffer_byte[0xFFFF];
	dword i;
	dword j;
	char  CSV_filename[255];
  char  CSV_filepath[255];
  byte  pos;
  byte  empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
  
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Navigation_VideoStreams[i].Param1 = 0;
		Navigation_VideoStreams[i].Param2 = 0;
		for(j=0; j<33; j++)
			Navigation_VideoStreams[i].Param3[j] = 0;
		Navigation_VideoStreams[i].Param3_Length = 0;
		Navigation_VideoStreams[i].Param4 = 0;
		for(j=0; j<602; j++)
			Navigation_VideoStreams[i].Param5[j] = 0;
		Navigation_VideoStreams[i].Param5_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gNavigation_VideoStreams_Path); i++)
  {
    if (gNavigation_VideoStreams_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gNavigation_VideoStreams_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gNavigation_VideoStreams_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
    //writelineEx(4, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "Navigation_VideoStreams"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
            
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in Navigation_VideoStreams) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Navigation_VideoStreams[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Navigation_VideoStreams[current_CSV_line-1].Param2 = atol(temp2); //StreamType 
						Navigation_VideoStreams[current_CSV_line-1].Param4 = atol(temp4); //UDP_Port
		
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //StreamType
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //IPv6_Address
								if(paramPos < 16)
								{
								  // 0...9
								  if (buffer_byte[filePos] >= 0x30 && buffer_byte[filePos] <= 0x39)
								  {
									if (buffer_byte[filePos+1] == 0x30)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] = (buffer_byte[filePos]-0x30)*16;
									  
									if (buffer_byte[filePos+1] > 0x30 && buffer_byte[filePos+1] <= 0x39)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] = (buffer_byte[filePos]-0x30)*16 + (buffer_byte[filePos+1]-0x30);
									
									if (buffer_byte[filePos+1] >= 0x41 && buffer_byte[filePos+1] <= 0x46)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] = (buffer_byte[filePos]-0x30)*16 + (buffer_byte[filePos+1]-0x37);
									
									if (buffer_byte[filePos+1] >= 0x61 && buffer_byte[filePos+1] <= 0x66)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] = (buffer_byte[filePos]-0x30)*16 + (buffer_byte[filePos+1]-0x57);
								  }
												
								  // A...F
								  if (buffer_byte[filePos] >= 0x41 && buffer_byte[filePos] <= 0x46)
								  {
									if (buffer_byte[filePos+1] == 0x30)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] = ((buffer_byte[filePos]-0x37)*16);
									  
									if (buffer_byte[filePos+1] > 0x30 && buffer_byte[filePos+1] <= 0x39)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x37)*16 + (buffer_byte[filePos+1]-0x30);
									
									if (buffer_byte[filePos+1] >= 0x41 && buffer_byte[filePos+1] <= 0x46)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x37)*16 + (buffer_byte[filePos+1]-0x37);
									
									if (buffer_byte[filePos+1] >= 0x61 && buffer_byte[filePos+1] <= 0x66)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x37)*16 + (buffer_byte[filePos+1]-0x57);
								  }
								  
								  // a...f
								  if (buffer_byte[filePos] >= 0x61 && buffer_byte[filePos] <= 0x66)
								  {
									if (buffer_byte[filePos+1] == 0x30)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] = ((buffer_byte[filePos]-0x57)*16);

									if (buffer_byte[filePos+1] == 0x30)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] = ((buffer_byte[filePos]-0x57)*16);
									  
									if (buffer_byte[filePos+1] > 0x30 && buffer_byte[filePos+1] <= 0x39)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x57)*16 + (buffer_byte[filePos+1]-0x30);
									
									if (buffer_byte[filePos+1] >= 0x41 && buffer_byte[filePos+1] <= 0x46)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x57)*16 + (buffer_byte[filePos+1]-0x37);
									
									if (buffer_byte[filePos+1] >= 0x61 && buffer_byte[filePos+1] <= 0x66)
									  Navigation_VideoStreams[current_CSV_line-1].Param3[paramPos++] =  (buffer_byte[filePos]-0x57)*16 + (buffer_byte[filePos+1]-0x57);
								  }
								}
							  Navigation_VideoStreams[current_CSV_line-1].Param3_Length = 16;
							  filePos++;
							break;
						case 4: //UDP_Port
							if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //URI
								if(paramPos < 600)
								{
									Navigation_VideoStreams[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									Navigation_VideoStreams[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}

  Navigation_VideoStreams_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Navigation_VideoStreams(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte Shift, Direction, TransPos;
  dword list_start, elements;

  if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;

    list_start = data[2];
    elements = data[3];
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_50_0_0_58_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_50_0_0_58_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_50_0_0_58_2 = TAID;
    else
      TAID = @A_FSG_50_0_0_58_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_50_0_0_58_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_50_0_0_58_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_50_0_0_58_Shift = (mode>>0);
    else
      mode = ((@A_FSG_50_0_0_58_Shift*1)+(Direction*2)+(TransPos*4));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_50_0_0_58_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_50_0_0_58_Direction*2)+(TransPos*4));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_50_0_0_58_Start = list_start;
    else
      list_start = @A_FSG_50_0_0_58_Start;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      Navigation_VideoStreams_Status(ASG_ID, TAID, mode, recordaddress,list_start, elements);
    }
  }
}

Navigation_VideoStreams_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction;
  int startposition, endposition, increment = 1, elements ;
  byte sequenceNumber = 0;
  
  int i, k , strctr;
  int stringsize;

  elements = received_elements;

  Data_Navigation_VideoStreams[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Navigation_VideoStreams[1] = Navigation_VideoStreams_TotalListNum & 0xFF;
  Data_Navigation_VideoStreams[2] = (mode|0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung
      
      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift; 
        endposition   = startposition + elements - 1; 
      }
      
      // Start in Liste
      if ((float) Navigation_VideoStreams_Search_Pos(list_start) != 0)
      {
        startposition = Navigation_VideoStreams_Search_Pos(list_start) - 1 + shift;
        endposition = startposition + elements - 1;
      }
      else
        {
          startposition = list_start + shift;
          elements = 0;
        }

      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Navigation_VideoStreams_TotalListNum)
      {
        endposition = Navigation_VideoStreams_TotalListNum - 1;
        elements = Navigation_VideoStreams_TotalListNum - startposition;
      }

    break;
    
    case 1: // Anfrage in neg. Richtung
      
	  // Start bei Listenbeginn
        if ((list_start == 0))
        {
          // Abfrage letzte Listenelemente
          if (shift == 1)
          {
            startposition = Navigation_VideoStreams_TotalListNum - 1;
            endposition = startposition - elements + 1;
          }
		  else
          elements = 0;
        }
	  
      // Start in Liste
      if (list_start > 0)
      {
        

        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if ((float) Navigation_VideoStreams_Search_Pos(list_start) != 0)
        {
          startposition = Navigation_VideoStreams_Search_Pos(list_start) - 1 - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift;
        }
      }
      
    break;
  }

  Data_Navigation_VideoStreams[3] = list_start & 0xFF;
  Data_Navigation_VideoStreams[4] = elements & 0xFF;

  j_Navigation_VideoStreams = 5;
  
  switch(direction)
  {
    case 0:
      
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param1; // Pos
        
        if (recordaddress == 0x1 || recordaddress == 0x2)  //StreamType
        {
          Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param2;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2) //IPv6_Address
        {
          Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param3_Length;
          stringsize = Navigation_VideoStreams[i].param3_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param3[strctr];
          }
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2)  //UDP_Port
        {
          Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] =  Navigation_VideoStreams[i].param4 & 0xFF;
          Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = (Navigation_VideoStreams[i].param4 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x1) //URI
        {
          Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param5_Length;
          stringsize = Navigation_VideoStreams[i].param5_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param5[strctr];
          }
        }
      }
      
    break;
          
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param1; // Pos
        
        if (recordaddress == 0x1 || recordaddress == 0x2)  //StreamType
        {
          Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param2;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2) //IPv6_Address
        {
          Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param3_Length;
          stringsize = Navigation_VideoStreams[i].param3_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param3[strctr];
          }
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x2)  //UDP_Port
        {
          Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] =  Navigation_VideoStreams[i].param4 & 0xFF;
          Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = (Navigation_VideoStreams[i].param4 >> 8) & 0xFF;
        }
        
        if (recordaddress == 0x1) //URI
        {
          Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param5_Length;
          stringsize = Navigation_VideoStreams[i].param5_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Navigation_VideoStreams[j_Navigation_VideoStreams++] = Navigation_VideoStreams[i].param5[strctr];
          }
        }
      }
    break;
  }
  settimer (Delay_Navigation_VideoStreams, @Env_Navigation_VideoStreams_ListDelay);
}

Navigation_VideoStreams_Changed (byte mode, byte recordaddress, byte list_start, byte elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift;
  int startposition, endposition, increment = 1;
  byte sequenceNumber = 0;
  
  int i, strctr; 
  int stringsize;  

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  Data_Navigation_VideoStreams[0] = (mode & 0xF) *16 + (recordaddress & 0xF);
  Data_Navigation_VideoStreams[1] = list_start;
  Data_Navigation_VideoStreams[2] = elements;
  j_Navigation_VideoStreams = 3;
  
  SendRequestByteSequence(LSGID_Navigation, 0x3A, Changed_REQ, j_Navigation_VideoStreams, Data_Navigation_VideoStreams);
}

on timer Delay_Navigation_VideoStreams
{
  sendRequestByteSequence(LSGID_Navigation, 0x3A, Data_REQ, j_Navigation_VideoStreams, Data_Navigation_VideoStreams);
}

dword Navigation_VideoStreams_Search_Pos (dword position)
{
  int i;
  
  for (i = 0; i < Navigation_VideoStreams_TotalListNum; i++)
  {
    if (position == Navigation_VideoStreams[i].param1)
    {
      return i+1; // +1, wegen Unterschied zu Fehlerwert
    } 
  }
  return 0;
}

// Navigation 0x1D LastDestList

on envVar Env_Navigation_LastDestList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Navigation_LastDestList_Path, gNavigation_LastDestList_Path);
    Navigation_LastDestList_LoadArray();
  } 
}

on envVar Env_Navigation_LastDestList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Navigation_LastDestList_Path, gNavigation_LastDestList_Path);
    Navigation_LastDestList_LoadArray();
    Navigation_LastDestList_Changed(0x0,0x0, 0x0000, 0xFF);
  } 
}

Navigation_LastDestList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
  char temp3[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;

	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Navigation_LastDestList[i].Param1 = 0;
		Navigation_LastDestList[i].Param2 = 0;
		for (j=0; j<97; j++)
			Navigation_LastDestList[i].Param3[j] = 0;
		Navigation_LastDestList[i].Param3_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
  for (i = 0; i < strlen(gNavigation_LastDestList_Path); i++)
  {
    if (gNavigation_LastDestList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gNavigation_LastDestList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gNavigation_LastDestList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Navigation_LastDestList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Navigation_LastDestList[current_CSV_line-1].Param2 = atol(temp2); //POI_Type
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
              temp3[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //POI_Type
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Description
								if (paramPos < 96)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_LastDestList_ListFormat == 1) )
                  {
                    Navigation_LastDestList[current_CSV_line-1].Param3[paramPos++] = buffer_byte[filePos++];
                    Navigation_LastDestList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_LastDestList_ListFormat == 0) )
                  {
                    Navigation_LastDestList[current_CSV_line-1].Param3[paramPos++] = 0xC2;
                    Navigation_LastDestList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_LastDestList_ListFormat == 0) )
                  {
                    Navigation_LastDestList[current_CSV_line-1].Param3[paramPos++] = 0xC3;
                    Navigation_LastDestList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_LastDestList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
									Navigation_LastDestList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
                
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
 
  Navigation_LastDestList_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Navigation_LastDestList(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements;
  
  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
    {
      ASG_ID = data[0] >> 4 & 0xF;
      TAID = data[0] & 0xF;
      mode = data[1] >> 4 & 0xF;
      recordaddress = data[1] & 0xF;
      IndexSize = mode >> 3 & 0x1;
      Direction = (mode>>1) & 0x1;
      TransPos = (mode>>2) & 0x1;
      Shift = (mode>>0) & 0x1;

      list_start = data[2];
      elements = data[3];
                       
      ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

      if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
        @A_FSG_50_0_0_29_1 = ASG_ID;  // Set to panel value
      else
        ASG_ID = @A_FSG_50_0_0_29_1; // Set from panel value
        
      if (@env_AutoGetArray_TAID == 0)  // TAID
        @A_FSG_50_0_0_29_2 = TAID;
      else
        TAID = @A_FSG_50_0_0_29_2;
      
      if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
        @A_FSG_50_0_0_29_RecAdr = recordaddress;
      else
        recordaddress = @A_FSG_50_0_0_29_RecAdr;
      
      if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
        @A_FSG_50_0_0_29_Shift = (mode>>0);
      else
        mode = ((@A_FSG_50_0_0_29_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
        @A_FSG_50_0_0_29_Direction = (mode>>1);
      else
        mode = ((Shift*1)+(@A_FSG_50_0_0_29_Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Start == 0)  // Start
        @A_FSG_50_0_0_29_Start = list_start;
      else
        list_start = @A_FSG_50_0_0_29_Start;
                      
      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
      {
        Navigation_LastDestList_Status(ASG_ID, TAID, mode, recordaddress,list_start, elements);
      }
    }
  }
  
  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
  {
    if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
    {
      ASG_ID = data[0] >> 4 & 0xF;
      TAID = data[0] & 0xF;
      mode = data[1] >> 4 & 0xF;
      recordaddress = data[1] & 0xF;
      IndexSize = mode >> 3 & 0x1;
      Direction = (mode>>1) & 0x1;
      TransPos = (mode>>2) & 0x1;
      Shift = (mode>>0) & 0x1;

      list_start = data[2];
      elements = data[3];
                       
      ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

      if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
        @A_FSG_50_0_0_30_1 = ASG_ID;  // Set to panel value
      else
        ASG_ID = @A_FSG_50_0_0_30_1; // Set from panel value
        
      if (@env_AutoGetArray_TAID == 0)  // TAID
        @A_FSG_50_0_0_30_2 = TAID;
      else
        TAID = @A_FSG_50_0_0_30_2;
      
      if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
        @A_FSG_50_0_0_30_RecAdr = recordaddress;
      else
        recordaddress = @A_FSG_50_0_0_30_RecAdr;
      
      if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
        @A_FSG_50_0_0_30_Shift = (mode>>0);
      else
        mode = ((@A_FSG_50_0_0_30_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
        @A_FSG_50_0_0_30_Direction = (mode>>1);
      else
        mode = ((Shift*1)+(@A_FSG_50_0_0_30_Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Start == 0)  // Start
        @A_FSG_50_0_0_30_Start = list_start;
      else
        list_start = @A_FSG_50_0_0_30_Start;
                      
      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
      {
        Navigation_LastDestList_Status(ASG_ID, TAID, mode, recordaddress,list_start, elements);
      }
    }
  }
}

Navigation_LastDestList_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition, elements ;
  byte sequenceNumber = 0;
  
  int i, k , strctr; 
  int stringsize;   

  elements = received_elements;

  Data_Navigation_LastDestList[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Navigation_LastDestList[1] = (Navigation_LastDestList_TotalListNum & 0xFF);
  Data_Navigation_LastDestList[2] = (mode|0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
  
  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift;
        endposition = startposition + elements - 1;
      }
      
      // Start in Liste
      if (list_start > 0)
      {
	    startposition = Navigation_LastDestList_FindIndexByPos(list_start);
		
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (startposition < Navigation_LastDestList_TotalListNum)
        {	  
		  startposition = startposition + shift;
          //startposition = startposition + shift - 1;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = startposition + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Navigation_LastDestList_TotalListNum)
      {
        endposition = Navigation_LastDestList_TotalListNum - 1;
        elements = Navigation_LastDestList_TotalListNum - startposition;
      }
      
    break;
    
    case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
	    startposition = Navigation_LastDestList_FindIndexByPos(list_start);
		
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (startposition < Navigation_LastDestList_TotalListNum)
        {
          startposition = startposition - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift + 1;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Navigation_LastDestList_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
    break;
  }

  Data_Navigation_LastDestList[3] = list_start & 0xFF;
  Data_Navigation_LastDestList[4] = elements & 0xFF;

  j_Navigation_LastDestList = 5;
    
  switch(direction)
  {
    case 0:

      for (i = startposition ; i <= endposition && i >= 0; i++)
      {

        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0xF) // Pos
          Data_Navigation_LastDestList[j_Navigation_LastDestList++] = Navigation_LastDestList[i].param1;
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // POI_Type
          Data_Navigation_LastDestList[j_Navigation_LastDestList++] = Navigation_LastDestList[i].param2;
              
        if (recordaddress == 0x0 || recordaddress == 0x1) // Description
        { 
          Data_Navigation_LastDestList[j_Navigation_LastDestList++] = Navigation_LastDestList[i].param3_Length;
          stringsize = Navigation_LastDestList[i].param3_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_LastDestList[j_Navigation_LastDestList++] = Navigation_LastDestList[i].param3[strctr];           
          } 
        }
      }
      
    break;
          
    case 1:
  
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0xF) // Pos
          Data_Navigation_LastDestList[j_Navigation_LastDestList++] = Navigation_LastDestList[i].param1;
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // POI_Type
          Data_Navigation_LastDestList[j_Navigation_LastDestList++] = Navigation_LastDestList[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Description
        {
          Data_Navigation_LastDestList[j_Navigation_LastDestList++] = Navigation_LastDestList[i].param3_Length;
          stringsize = Navigation_LastDestList[i].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_LastDestList[j_Navigation_LastDestList++] = Navigation_LastDestList[i].param3[strctr];           
          } 
        }         
      }
    break;
  }
  settimer (Delay_Navigation_LastDestList, @Env_Navigation_LastDestList_ListDelay);
}

dword Navigation_LastDestList_FindIndexByPos(dword list_start)
{
  dword i;
  dword ResultIndex;

  ResultIndex = 0;

  for (i = 0 ; i < (Navigation_LastDestList_TotalListNum); i++)
  {
	if(Navigation_LastDestList[i].param1 == list_start)
	{
	  ResultIndex = i;
	  break;
    }
  }

  return ResultIndex;
}

Navigation_LastDestList_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;
  
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
    SendRequestByteSequence(LSGID_Navigation, 0x1D, Changed_REQ, length, data);
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
    SendRequestByteSequence(LSGID_Navigation, 0x1E, Changed_REQ, length, data);
}

on timer Delay_Navigation_LastDestList
{
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
    sendRequestByteSequence(LSGID_Navigation, 0x1D, Data_REQ, j_Navigation_LastDestList, Data_Navigation_LastDestList);
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
    sendRequestByteSequence(LSGID_Navigation, 0x1E, Data_REQ, j_Navigation_LastDestList, Data_Navigation_LastDestList);
}


// Navigation 0x1E FavoriteDest_List

on envVar Env_Navigation_FavoriteDestList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Navigation_FavoriteDestList_Path, gNavigation_FavoriteDestList_Path);
    Navigation_FavoriteDestList_LoadArray();
  } 
}

on envVar Env_Navigation_FavoriteDestList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Navigation_FavoriteDestList_Path, gNavigation_FavoriteDestList_Path);
    Navigation_FavoriteDestList_LoadArray();
    Navigation_FavoriteDestList_Changed(0x0,0x0, 0x0000, 0xFF);
  }
}

Navigation_FavoriteDestList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Navigation_FavoriteDestList[i].Param1 = 0;
		Navigation_FavoriteDestList[i].Param2 = 0;
		for (j=0; j<97; j++)
			Navigation_FavoriteDestList[i].Param3[j] = 0;
		Navigation_FavoriteDestList[i].Param3_Length = 0;

	}
    //putValue(A_FSG_50_0_0_30_fileSelector, Env_Navigation_FavoriteDestList_Path);
    //putValue(A_FSG_50_0_0_30_loadArray_Btn, TRUE);
	/********* Laden der CSV-Datei ***********/
  for (i = 0; i < strlen(gNavigation_FavoriteDestList_Path); i++)
  {
    if (gNavigation_FavoriteDestList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gNavigation_FavoriteDestList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gNavigation_FavoriteDestList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
      
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Navigation_FavoriteDestList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Navigation_FavoriteDestList[current_CSV_line-1].Param2 = atol(temp2); //POI_Type
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //POI_Type
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Description
								if (paramPos < 96)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_FavoriteDestList_ListFormat == 1) )
                  {
                    Navigation_FavoriteDestList[current_CSV_line-1].Param3[paramPos++] = buffer_byte[filePos++];
                    Navigation_FavoriteDestList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_FavoriteDestList_ListFormat == 0) )
                  {
                    Navigation_FavoriteDestList[current_CSV_line-1].Param3[paramPos++] = 0xC2;
                    Navigation_FavoriteDestList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_FavoriteDestList_ListFormat == 0) )
                  {
                    Navigation_FavoriteDestList[current_CSV_line-1].Param3[paramPos++] = 0xC3;
                    Navigation_FavoriteDestList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_FavoriteDestList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
									Navigation_FavoriteDestList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  Navigation_FavoriteDestList_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Navigation_FavoriteDestList(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements;

  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
    {
      ASG_ID = data[0] >> 4 & 0xF;
      TAID = data[0] & 0xF;
      mode = data[1] >> 4 & 0xF;
      recordaddress = data[1] & 0xF;
      IndexSize = mode >> 3 & 0x1;
      Direction = (mode>>1) & 0x1;
      TransPos = (mode>>2) & 0x1;
      Shift = (mode>>0) & 0x1;

      list_start = data[2];
      elements = data[3];
                
      ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

      if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
        @A_FSG_50_0_0_30_1 = ASG_ID;  // Set to panel value
      else
        ASG_ID = @A_FSG_50_0_0_30_1; // Set from panel value
       
      if (@env_AutoGetArray_TAID == 0)  // TAID
        @A_FSG_50_0_0_30_2 = TAID;
      else
        TAID = @A_FSG_50_0_0_30_2;
      
      if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
        @A_FSG_50_0_0_30_RecAdr = recordaddress;
      else
        recordaddress = @A_FSG_50_0_0_30_RecAdr;
      
      if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
        @A_FSG_50_0_0_30_Shift = (mode>>0);
      else
        mode = ((@A_FSG_50_0_0_30_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
        @A_FSG_50_0_0_30_Direction = (mode>>1);
      else
        mode = ((Shift*1)+(@A_FSG_50_0_0_30_Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Start == 0)  // Start
        @A_FSG_50_0_0_30_Start = list_start;
      else
        list_start = @A_FSG_50_0_0_30_Start;

      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
      {
        Navigation_FavoriteDestList_Status (ASG_ID, TAID, mode, recordaddress,list_start, elements);
      }
    }
  }
  
  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
  {
    if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
    {
      ASG_ID = data[0] >> 4 & 0xF;
      TAID = data[0] & 0xF;
      mode = data[1] >> 4 & 0xF;
      recordaddress = data[1] & 0xF;
      IndexSize = mode >> 3 & 0x1;
      Direction = (mode>>1) & 0x1;
      TransPos = (mode>>2) & 0x1;
      Shift = (mode>>0) & 0x1;

      list_start = data[2];
      elements = data[3];
                
      ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

      if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
        @A_FSG_50_0_0_31_1 = ASG_ID;  // Set to panel value
      else
        ASG_ID = @A_FSG_50_0_0_31_1; // Set from panel value
       
      if (@env_AutoGetArray_TAID == 0)  // TAID
        @A_FSG_50_0_0_31_2 = TAID;
      else
        TAID = @A_FSG_50_0_0_31_2;
      
      if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
        @A_FSG_50_0_0_31_RecAdr = recordaddress;
      else
        recordaddress = @A_FSG_50_0_0_31_RecAdr;
      
      if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
        @A_FSG_50_0_0_31_Shift = (mode>>0);
      else
        mode = ((@A_FSG_50_0_0_31_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
        @A_FSG_50_0_0_31_Direction = (mode>>1);
      else
        mode = ((Shift*1)+(@A_FSG_50_0_0_31_Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Start == 0)  // Start
        @A_FSG_50_0_0_31_Start = list_start;
      else
        list_start = @A_FSG_50_0_0_31_Start;

      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
      {
        Navigation_FavoriteDestList_Status (ASG_ID, TAID, mode, recordaddress,list_start, elements);
      }
    }
  }
}

dword Navigation_FavoriteDestList_FindIndexByPos(dword list_start)
{
  dword i;
  dword ResultIndex;

  ResultIndex = 0;

  for (i = 0 ; i < (Navigation_FavoriteDestList_TotalListNum); i++)
  {
	if(Navigation_FavoriteDestList[i].param1 == list_start)
	{
	  ResultIndex = i;
	  break;
    }
  }

  return ResultIndex;
}

Navigation_FavoriteDestList_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition, elements ;
  byte sequenceNumber = 0;
  
  int i, k , strctr; 
  int stringsize;   

  elements = received_elements;

  Data_Navigation_FavoriteDestList[0] =  ASG_ID*16 + (TAID & 0xF);
  Data_Navigation_FavoriteDestList[1] = (Navigation_FavoriteDestList_TotalListNum & 0xFF);
  Data_Navigation_FavoriteDestList[2] = (mode|0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
  
   switch(direction)
   {
      case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift;
        endposition = startposition + elements - 1;
      }
      
      // Start in Liste
      if (list_start > 0)
      {
	    startposition = Navigation_FavoriteDestList_FindIndexByPos(list_start);
		
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (startposition < Navigation_FavoriteDestList_TotalListNum)
        {
          startposition = startposition + shift;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = startposition + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Navigation_FavoriteDestList_TotalListNum)
      {
        endposition = Navigation_FavoriteDestList_TotalListNum - 1;
        elements = Navigation_FavoriteDestList_TotalListNum - startposition;
      }
      break;
    
      case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
	    startposition = Navigation_FavoriteDestList_FindIndexByPos(list_start);
		
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (startposition < Navigation_FavoriteDestList_TotalListNum)
        {
          startposition = startposition - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = startposition - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift + 1;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Navigation_FavoriteDestList_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
      
    break;
  }
   
  Data_Navigation_FavoriteDestList[3] = list_start & 0xFF;
  Data_Navigation_FavoriteDestList[4] = elements & 0xFF;

  j_Navigation_FavoriteDestList = 5;
   
  switch(direction)
  {
    case 0:
         
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0xF) // Pos
          Data_Navigation_FavoriteDestList[j_Navigation_FavoriteDestList++] = Navigation_FavoriteDestList[i].param1;
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // POI_Type
          Data_Navigation_FavoriteDestList[j_Navigation_FavoriteDestList++] = Navigation_FavoriteDestList[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Description
        {
          Data_Navigation_FavoriteDestList[j_Navigation_FavoriteDestList++] = Navigation_FavoriteDestList[i].param3_Length;
          stringsize = Navigation_FavoriteDestList[i].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_FavoriteDestList[j_Navigation_FavoriteDestList++] = Navigation_FavoriteDestList[i].param3[strctr];           
          } 
        }
      }
      
    break;
            
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0xF) // Pos
          Data_Navigation_FavoriteDestList[j_Navigation_FavoriteDestList++] = Navigation_FavoriteDestList[i].param1;
        
        if (recordaddress == 0x0 || recordaddress == 0x2) // POI_Type
          Data_Navigation_FavoriteDestList[j_Navigation_FavoriteDestList++] = Navigation_FavoriteDestList[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x1) // Description
        {
          Data_Navigation_FavoriteDestList[j_Navigation_FavoriteDestList++] = Navigation_FavoriteDestList[i].param3_Length;
          stringsize = Navigation_FavoriteDestList[i].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
              Data_Navigation_FavoriteDestList[j_Navigation_FavoriteDestList++] = Navigation_FavoriteDestList[i].param3[strctr];
          }
        }
      }
      
    break;
  }
  settimer (Delay_Navigation_FavoriteDestList, @Env_Navigation_FavoriteDestList_ListDelay);
}

Navigation_FavoriteDestList_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
    SendRequestByteSequence (LSGID_Navigation, 0x1E, Changed_REQ, length, data);
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
    SendRequestByteSequence (LSGID_Navigation, 0x1F, Changed_REQ, length, data);
}

on timer Delay_Navigation_FavoriteDestList
{
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
    sendRequestByteSequence(LSGID_Navigation, 0x1E, Data_REQ, j_Navigation_FavoriteDestList, Data_Navigation_FavoriteDestList);
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
    sendRequestByteSequence(LSGID_Navigation, 0x1F, Data_REQ, j_Navigation_FavoriteDestList, Data_Navigation_FavoriteDestList);
}






// Navigation 0x21 Address_List

on envVar Env_Navigation_AddressList_LoadBTN
{
  If (@this == 1)
  {
    getValue(Env_Navigation_AddressList_Path, gNavigation_AddressList_Path);
    Navigation_AddressList_LoadArray();
  } 
}

on envVar Env_Navigation_AddressList_LoadBTN_Full
{
  If (@this == 1)
  {
    getValue(Env_Navigation_AddressList_Path, gNavigation_AddressList_Path);
    Navigation_AddressList_LoadArray();
    Navigation_AddressList_Changed(0x0,0x0, 0x0000, 0xFF);
  } 
}

Navigation_AddressList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
  byte empty=0;
  int pos;
	char CSV_filename[255];
  char CSV_filepath[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp11[25];
	char temp12[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Navigation_AddressList[i].Param1 = 0;
		for (j=0; j<61; j++)
			Navigation_AddressList[i].Param2[j] = 0;
		Navigation_AddressList[i].Param2_Length = 0;
		for (j=0; j<61; j++)
			Navigation_AddressList[i].Param3[j] = 0;
		Navigation_AddressList[i].Param3_Length = 0;
		for (j=0; j<61; j++)
			Navigation_AddressList[i].Param4[j] = 0;
		Navigation_AddressList[i].Param4_Length = 0;
		for (j=0; j<61; j++)
			Navigation_AddressList[i].Param5[j] = 0;
		Navigation_AddressList[i].Param5_Length = 0;
		for (j=0; j<61; j++)
			Navigation_AddressList[i].Param6[j] = 0;
		Navigation_AddressList[i].Param6_Length = 0;
		for (j=0; j<22; j++)
			Navigation_AddressList[i].Param7[j] = 0;
		Navigation_AddressList[i].Param7_Length = 0;
		for (j=0; j<61; j++)
			Navigation_AddressList[i].Param8[j] = 0;
		Navigation_AddressList[i].Param8_Length = 0;
		for (j=0; j<61; j++)
			Navigation_AddressList[i].Param9[j] = 0;
		Navigation_AddressList[i].Param9_Length = 0;
		for (j=0; j<61; j++)
			Navigation_AddressList[i].Param10[j] = 0;
		Navigation_AddressList[i].Param11 = 0;
		Navigation_AddressList[i].Param12 = 0;
	}

	/********* Laden der CSV-Datei ***********/
  for (i = 0; i < strlen(gNavigation_AddressList_Path); i++)
  {
    if (gNavigation_AddressList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gNavigation_AddressList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gNavigation_AddressList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "AddressList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 65535) //ignore first line in *.csv file
					{
						Navigation_AddressList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Navigation_AddressList[current_CSV_line-1].Param11 = atol(temp11); //POI_Type
						Navigation_AddressList[current_CSV_line-1].Param12 = atol(temp12); //Address_Type
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp11[i]=0;
							temp12[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 65535)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //LastName
                if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_AddressList_ListFormat == 1) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param2[paramPos++] = buffer_byte[filePos++];
                    Navigation_AddressList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param2[paramPos++] = 0xC2;
                    Navigation_AddressList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param2[paramPos++] = 0xC3;
                    Navigation_AddressList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_AddressList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
									Navigation_AddressList[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //FirstName
								if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_AddressList_ListFormat == 1) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param3[paramPos++] = buffer_byte[filePos++];
                    Navigation_AddressList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param3[paramPos++] = 0xC2;
                    Navigation_AddressList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param3[paramPos++] = 0xC3;
                    Navigation_AddressList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_AddressList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
									Navigation_AddressList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 4: //Street
								if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_AddressList_ListFormat == 1) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param4[paramPos++] = buffer_byte[filePos++];
                    Navigation_AddressList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param4[paramPos++] = 0xC2;
                    Navigation_AddressList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param4[paramPos++] = 0xC3;
                    Navigation_AddressList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_AddressList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
                  }
									Navigation_AddressList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 5: //City
								if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_AddressList_ListFormat == 1) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param5[paramPos++] = buffer_byte[filePos++];
                    Navigation_AddressList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param5[paramPos++] = 0xC2;
                    Navigation_AddressList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param5[paramPos++] = 0xC3;
                    Navigation_AddressList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_AddressList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
                  }
									Navigation_AddressList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 6: //Region
								if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_AddressList_ListFormat == 1) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param6[paramPos++] = buffer_byte[filePos++];
                    Navigation_AddressList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param6[paramPos++] = 0xC2;
                    Navigation_AddressList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param6[paramPos++] = 0xC3;
                    Navigation_AddressList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_AddressList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
                  }
									Navigation_AddressList[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 7: //PostalCode
								if (paramPos < 21)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_AddressList_ListFormat == 1) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param7[paramPos++] = buffer_byte[filePos++];
                    Navigation_AddressList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param7[paramPos++] = 0xC2;
                    Navigation_AddressList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param7[paramPos++] = 0xC3;
                    Navigation_AddressList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_AddressList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
                  }
									Navigation_AddressList[current_CSV_line-1].Param7_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 8: //Country
								if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_AddressList_ListFormat == 1) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param8[paramPos++] = buffer_byte[filePos++];
                    Navigation_AddressList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param8[paramPos++] = 0xC2;
                    Navigation_AddressList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param8[paramPos++] = 0xC3;
                    Navigation_AddressList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_AddressList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
                  }
									Navigation_AddressList[current_CSV_line-1].Param8_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 9: //Coordinates
								if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_AddressList_ListFormat == 1) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param9[paramPos++] = buffer_byte[filePos++];
                    Navigation_AddressList[current_CSV_line-1].Param9[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param9[paramPos++] = 0xC2;
                    Navigation_AddressList[current_CSV_line-1].Param9[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param9[paramPos++] = 0xC3;
                    Navigation_AddressList[current_CSV_line-1].Param9[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_AddressList[current_CSV_line-1].Param9[paramPos] = buffer_byte[filePos];
                  }
									Navigation_AddressList[current_CSV_line-1].Param9_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 10: //POI_Description
								if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Navigation_AddressList_ListFormat == 1) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param10[paramPos++] = buffer_byte[filePos++];
                    Navigation_AddressList[current_CSV_line-1].Param10[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param10[paramPos++] = 0xC2;
                    Navigation_AddressList[current_CSV_line-1].Param10[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Navigation_AddressList_ListFormat == 0) )
                  {
                    Navigation_AddressList[current_CSV_line-1].Param10[paramPos++] = 0xC3;
                    Navigation_AddressList[current_CSV_line-1].Param10[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    Navigation_AddressList[current_CSV_line-1].Param10[paramPos] = buffer_byte[filePos];
                  }
									Navigation_AddressList[current_CSV_line-1].Param10_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 11: //POI_Type
								if ( paramPos >= elCount(temp11) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp11[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 12: //Address_Type
								if ( paramPos >= elCount(temp12) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp12[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  Navigation_AddressList_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
}

Navigation_AddressList(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  byte OtherListType;
  dword list_start, elements, OtherList_Reference;
  
  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
    {
      ASG_ID = (data[0] >> 4) & 0xF;
      TAID = data[0] & 0xF;
      OtherListType = data[1];
      OtherList_Reference = data[2]+ data[3]*256 ;
      mode = (data[4] >> 4) & 0xF;
      recordaddress = data[4] & 0xF;
      IndexSize = (mode >> 3) & 0x1;
      Direction = (mode>>1) & 0x1;
      TransPos = (mode>>2) & 0x1;
      Shift = (mode>>0) & 0x1;
          
      if (IndexSize == 0)
      {
        list_start = data[5];
        elements = data[6];
      }
      else
      {
        list_start = data[5] + data[6]*256;
        elements = data[7] + data[8]*256;
      }

      ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

      if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
        @A_FSG_50_0_0_33_1 = ASG_ID;
      else
        ASG_ID = @A_FSG_50_0_0_33_1;
        
      if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
        @A_FSG_50_0_0_33_2 = TAID;
      else
        TAID = @A_FSG_50_0_0_33_2;
      
      if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
        @A_FSG_50_0_0_33_RecAdr = recordaddress;
      else
        recordaddress = @A_FSG_50_0_0_33_RecAdr;
      
      if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
        @A_FSG_50_0_0_33_Shift = (mode>>0);
      else
        mode = ((@A_FSG_50_0_0_33_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
        @A_FSG_50_0_0_33_Direction = (mode>>1);
      else
        mode = ((Shift*1)+(@A_FSG_50_0_0_33_Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Start == 0)  // Start from GetArray
        @A_FSG_50_0_0_33_Start = list_start;
      else
        list_start = @A_FSG_50_0_0_33_Start;
          
      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
      {
        Navigation_AddressList_Status(ASG_ID, TAID, mode, recordaddress,list_start, elements, OtherListType, OtherList_Reference);
      }
    }
  }
}

dword Navigation_AddressList_FindIndexByPos(dword list_start)
{
  dword i;
  dword ResultIndex;

  ResultIndex = 0;

  for (i = 0 ; i < (Navigation_AddressList_TotalListNum); i++)
  {
	if(Navigation_AddressList[i].param1 == list_start)
	{
	  ResultIndex = i;
	  break;
    }
  }

  return ResultIndex;
}

Navigation_AddressList_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements, byte OtherListType, dword OtherList_Reference)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int  startposition, endposition, increment = 1, elements;
  byte sequenceNumber = 0;
  
  int i, k , strctr; 
  int stringsize;   

  elements = received_elements;

  Data_Navigation_AddressList[0] =  ASG_ID*16 + (TAID & 0xF);
  Data_Navigation_AddressList[1] =  OtherListType;
  Data_Navigation_AddressList[2] =  OtherList_Reference & 0xFF;
  Data_Navigation_AddressList[3] = (OtherList_Reference>>8) & 0xFF;
  Data_Navigation_AddressList[4] = (Navigation_AddressList_TotalListNum & 0xFF);
  Data_Navigation_AddressList[5] = (Navigation_AddressList_TotalListNum >>  8) & 0xFF;
  Data_Navigation_AddressList[6] = (mode|0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
  
  switch(direction)
  {
    case 0:
      
      startposition = Navigation_AddressList_FindIndexByPos(OtherList_Reference);
      
      if (startposition < Navigation_AddressList_TotalListNum)
        elements = 1;
      else
        elements = 0;
		
	  endposition = startposition + elements;
      
    break;
   
    case 1:
      
      startposition = Navigation_AddressList_FindIndexByPos(OtherList_Reference);
         
      if (OtherList_Reference <= Navigation_AddressList_TotalListNum)
        elements = 1;
      else
        elements = 0;
	  
	  endposition = startposition - elements;

    break;
  }
  
  if (IndexSize == 0)
  {
    Data_Navigation_AddressList[7] = list_start & 0xFF;
    Data_Navigation_AddressList[8] = elements & 0xFF;

    j_Navigation_AddressList = 9;
  }
  else
  {
    Data_Navigation_AddressList[7] = list_start & 0xFF;
    Data_Navigation_AddressList[8] = (list_start >> 8) & 0xFF;

    Data_Navigation_AddressList[9] = elements & 0xFF;
    Data_Navigation_AddressList[10] = (elements >> 8) & 0xFF;

    j_Navigation_AddressList = 11;
  }

  if ( (OtherListType == 0x00) || (OtherListType == 0x01) ) // LastDestination_List ODER FavoriteDestination_List
  {
    switch(direction)
    {
      case 0:
        
		
		//write("start pos = %d", startposition);
		//write("end pos = %d", endposition);
        //for (i = startposition ; i < endposition && i >= 0; i++)
		for (i = startposition ; i < endposition && i >= 0; i++)
        // +2, da die ersten beiden Zeilen fuer Heimatadresse & Geschäftsadresse verwendet werden
        {
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 ||recordaddress == 0x4 ||recordaddress == 0x5 || recordaddress == 0x6 || recordaddress == 0xF)  // Pos
          {
            if (IndexSize == 0)
			{
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param1 & 0xFF;
			}
            else
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param1 & 0xFF;
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param1>>8 & 0xFF;
            }
          }
                  
          if (recordaddress == 0x0) // LastName
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param2_Length;
            stringsize = Navigation_AddressList[i].param2_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param2[strctr];
            } 
          }
          
          if (recordaddress == 0x0) // FirstName
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param3_Length;
            stringsize = Navigation_AddressList[i].param3_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param3[strctr];
            } 
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // Street
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param4_Length;
            stringsize = Navigation_AddressList[i].param4_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param4[strctr];
            } 
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // City
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param5_Length;
            stringsize = Navigation_AddressList[i].param5_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param5[strctr];
            } 
          }

          if (recordaddress == 0x0 || recordaddress == 0x3) // Region
          {  
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param6_Length;
              stringsize = Navigation_AddressList[i].param6_Length;
            
              for (strctr = 0; strctr < stringsize; strctr++)
              {
                Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param6[strctr];
              }
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // PostalCode
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param7_Length;
            stringsize = Navigation_AddressList[i].param7_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param7[strctr];
            }
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3) // Country
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param8_Length;
            stringsize = Navigation_AddressList[i].param8_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param8[strctr];
            }
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Coordinates
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param9_Length;
            stringsize = Navigation_AddressList[i].param9_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param9[strctr];
            }
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Description
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param10_Length;
            stringsize = Navigation_AddressList[i].param10_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param10[strctr];
            }
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Type
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param11;
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Address Type
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param12;
        }
          
      break;
      
      case 1:
        
        for (i = endposition ; i > OtherList_Reference+elements+2 && i >= 0; i--)
        // +2, da die ersten beiden Zeilen fuer Heimatadresse & Geschäftsadresse verwendet werden
        {
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 ||recordaddress == 0x4 ||recordaddress == 0x5 || recordaddress == 0x6 || recordaddress == 0xF)  // Pos
          {
            if (IndexSize == 0)
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param1 & 0xFF;
            else
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param1 & 0xFF;
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param1>>8 & 0xFF;
            }
          }
          
          if (recordaddress == 0x0) // LastName
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param2_Length;
            stringsize = Navigation_AddressList[i].param2_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param2[strctr];
            } 
          }
          
          if (recordaddress == 0x0) // FirstName
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param3_Length;
            stringsize = Navigation_AddressList[i].param3_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param3[strctr];
            } 
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // Street
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param4_Length;
            stringsize = Navigation_AddressList[i].param4_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param4[strctr];
            } 
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // City
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param5_Length;
            stringsize = Navigation_AddressList[i].param5_Length;
            
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param5[strctr];
            } 
          }

          if (recordaddress == 0x0 || recordaddress == 0x3) // Region
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param6_Length;
            stringsize = Navigation_AddressList[i].param6_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param6[strctr];
            }
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // PostalCode
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param7_Length;
            stringsize = Navigation_AddressList[i].param7_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param7[strctr];
            }
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3) // Country
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param8_Length;
            stringsize = Navigation_AddressList[i].param8_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param8[strctr];
            }
          }
                  
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Coordinates
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param9_Length;
            stringsize = Navigation_AddressList[i].param9_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param9[strctr];
            } 
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Description
          {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param10_Length;
            stringsize = Navigation_AddressList[i].param10_Length;
            
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param10[strctr];
            } 
          }
          
          if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Type
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param11;
          
          if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Address Type
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[i].param12;
        }
        
      break;
    }
  }
    
  if (OtherListType == 0x04) // HomeAddress
  {
    switch(direction)
    {
      case 0:
      
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 ||recordaddress == 0x4 ||recordaddress == 0x5 || recordaddress == 0x6 || recordaddress == 0xF)  // Pos
        {
          if (IndexSize == 0)
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param1 & 0xFF;
          else
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param1 & 0xFF;
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param1>>8 & 0xFF;
          }
        }
                
        if (recordaddress == 0x0) // LastName
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param2_Length;
          stringsize = Navigation_AddressList[0].param2_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param2[strctr];
          } 
        }
        
        if (recordaddress == 0x0) // FirstName
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param3_Length;
          stringsize = Navigation_AddressList[0].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param3[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // Street
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param4_Length;
          stringsize = Navigation_AddressList[0].param4_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param4[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // City
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param5_Length;
          stringsize = Navigation_AddressList[0].param5_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param5[strctr];
          } 
        }

        if (recordaddress == 0x0 || recordaddress == 0x3) // Region
        {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param6_Length;
            stringsize = Navigation_AddressList[0].param6_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param6[strctr];
            }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // PostalCode
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param7_Length;
          stringsize = Navigation_AddressList[0].param7_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param7[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3) // Country
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param8_Length;
          stringsize = Navigation_AddressList[0].param8_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param8[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Coordinates
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param9_Length;
          stringsize = Navigation_AddressList[0].param9_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param9[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Description
        {
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param10_Length;
          stringsize = Navigation_AddressList[0].param10_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param10[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Type
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param11;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Address Type
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param12;
        
      break;
      
      case 1:
      
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 ||recordaddress == 0x4 ||recordaddress == 0x5 || recordaddress == 0x6 || recordaddress == 0xF)  // Pos
        {
          if (IndexSize == 0)
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param1 & 0xFF;
          else
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param1 & 0xFF;
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param1>>8 & 0xFF;
          }
        }
        
        if (recordaddress == 0x0) // LastName
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param2_Length;
          stringsize = Navigation_AddressList[0].param2_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param2[strctr];
          } 
        }
        
        if (recordaddress == 0x0) // FirstName
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param3_Length;
          stringsize = Navigation_AddressList[0].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param3[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // Street
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param4_Length;
          stringsize = Navigation_AddressList[0].param4_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param4[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // City
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param5_Length;
          stringsize = Navigation_AddressList[0].param5_Length;
          
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param5[strctr];
          } 
        }

        if (recordaddress == 0x0 || recordaddress == 0x3) // Region
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param6_Length;
          stringsize = Navigation_AddressList[0].param6_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param6[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // PostalCode
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param7_Length;
          stringsize = Navigation_AddressList[0].param7_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param7[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3) // Country
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param8_Length;
          stringsize = Navigation_AddressList[0].param8_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param8[strctr];
          }
        }
                
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Coordinates
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param9_Length;
          stringsize = Navigation_AddressList[0].param9_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param9[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Description
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param10_Length;
          stringsize = Navigation_AddressList[0].param10_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param10[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Type
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param11;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Address Type
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[0].param12;
      
      break;
    }
  }
    
  if (OtherListType == 0x05) // BusinessAddress
  {
    switch(direction)
    {
      case 0:
      
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 ||recordaddress == 0x4 ||recordaddress == 0x5 || recordaddress == 0x6 || recordaddress == 0xF)  // Pos
        {
          if (IndexSize == 0)
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param1 & 0xFF;
          else
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param1 & 0xFF;
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param1>>8 & 0xFF;
          }
        }
                
        if (recordaddress == 0x0) // LastName
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param2_Length;
          stringsize = Navigation_AddressList[1].param2_Length;
        
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param2[strctr];
          } 
        }
        
        if (recordaddress == 0x0) // FirstName
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param3_Length;
          stringsize = Navigation_AddressList[1].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param3[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // Street
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param4_Length;
          stringsize = Navigation_AddressList[1].param4_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param4[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // City
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param5_Length;
          stringsize = Navigation_AddressList[1].param5_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param5[strctr];
          } 
        }

        if (recordaddress == 0x0 || recordaddress == 0x3) // Region
        {  
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param6_Length;
            stringsize = Navigation_AddressList[1].param6_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param6[strctr];
            }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // PostalCode
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param7_Length;
          stringsize = Navigation_AddressList[1].param7_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param7[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3) // Country
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param8_Length;
          stringsize = Navigation_AddressList[1].param8_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param8[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Coordinates
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param9_Length;
          stringsize = Navigation_AddressList[1].param9_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param9[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Description
        {
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param10_Length;
          stringsize = Navigation_AddressList[1].param10_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param10[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Type
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param11;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Address Type
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param12;
        
      break;
      
      case 1:
      
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 ||recordaddress == 0x4 ||recordaddress == 0x5 || recordaddress == 0x6 || recordaddress == 0xF)  // Pos
        {
          if (IndexSize == 0)
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param1 & 0xFF;
          else
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param1 & 0xFF;
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param1>>8 & 0xFF;
          }
        }
        
        if (recordaddress == 0x0) // LastName
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param2_Length;
          stringsize = Navigation_AddressList[1].param2_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param2[strctr];
          } 
        }
        
        if (recordaddress == 0x0) // FirstName
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param3_Length;
          stringsize = Navigation_AddressList[1].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param3[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // Street
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param4_Length;
          stringsize = Navigation_AddressList[1].param4_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param4[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4 || recordaddress == 0x6) // City
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param5_Length;
          stringsize = Navigation_AddressList[1].param5_Length;
          
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param5[strctr];
          } 
        }

        if (recordaddress == 0x0 || recordaddress == 0x3) // Region
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param6_Length;
          stringsize = Navigation_AddressList[1].param6_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param6[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // PostalCode
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param7_Length;
          stringsize = Navigation_AddressList[1].param7_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param7[strctr];
          }
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3) // Country
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param8_Length;
          stringsize = Navigation_AddressList[1].param8_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param8[strctr];
          }
        }
                
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Coordinates
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param9_Length;
          stringsize = Navigation_AddressList[1].param9_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param9[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Description
        {  
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param10_Length;
          stringsize = Navigation_AddressList[1].param10_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param10[strctr];
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // POI Type
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param11;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x3 || recordaddress == 0x4) // Address Type
          Data_Navigation_AddressList[j_Navigation_AddressList++] = Navigation_AddressList[1].param12;
      
      break;
    }
  }
  settimer (Delay_Navigation_AddressList, @Env_Navigation_AddressList_ListDelay);
}

Navigation_AddressList_Changed (byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;
  
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
    data[1] = list_start;
    data[2] = elements;
  
    length = 3;
  }
  
  else if (IndexSize == 1)
  {
    data[1] = list_start & 0xFF;
    data[2] = (list_start >> 8) & 0xFF;
    data[3] = elements & 0xFF;
    data[4] = (elements >> 8) & 0xFF;
    
    length = 5;
  }
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
    SendRequestByteSequence(LSGID_Navigation, 0x21, Changed_REQ, length, data);
}

on timer Delay_Navigation_AddressList
{
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
    sendRequestByteSequence(LSGID_Navigation, 0x21, Data_REQ, j_Navigation_AddressList, Data_Navigation_AddressList);
}


// Navigation 0x22 RG_ActDeact

Navigation_RG_ActDeact (byte opcode, byte data[])
{
  byte Result;
  
  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 2) && (Navigation_Source == 1)) // ASG StartResult
    {
      // keine Uebernahme der Paramter noetig
    }
    
    if ((opcode == 3) && (Navigation_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
    {
      // RG_ActDeact Result senden
      Result = @M_FSG_50_0_0_34_Result_1;
      
      sendRequest (LSGID_Navigation, 0x22, Result_REQ, 1, Result);
    }
  }
  
  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
  {
    if ((opcode == 2) && (Navigation_Source == 1)) // ASG StartResult
    {
      // keine Uebernahme der Paramter noetig
    }
    
    if ((opcode == 3) && (Navigation_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
    {
      // RG_ActDeact Result senden
      Result = @M_FSG_50_0_0_33_Result_1;
      
      sendRequest (LSGID_Navigation, 0x21, Result_REQ, 1, Result);
    }
  }
}


// Navigation 0x23 RepeatLastNavAnnouncement

Navigation_RepeatLastNavAnnouncement (byte opcode, byte data[])
{
  byte Result;
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 2) && (Navigation_Source == 1)) // ASG StartResult
    {
      // keine Uebernahme der Paramter noetig
    }
    
    if ((opcode == 3) && (Navigation_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
    {
      // RepeatLastNavAnnouncement Result senden
      Result = @M_FSG_50_0_0_35_Result_1;
      
      sendRequest (LSGID_Navigation, 0x23, Result_REQ, 1, Result);
    }
  }
}


// Navigation - 0x29 GetNextListPos

Navigation_GetNextListPos(byte opcode, byte data[])
{
  long currentPos;
  long Offset;
  float fOffset;
  long nextPos;
  byte ListType;
  byte send_data_GNLP_Result[7];
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 2) && (Navigation_Source == 1)) // ASG StartResult
    {
      // Start Result auswerten
      currentPos = data[0] + data[1]*256;
      Offset = data[2] + data[3]*256;
      ListType = data[4];
      
      if (Offset > 0x0000 && Offset <= 0x7FFF)
        fOffset = Offset;
      if (Offset > 0x7FFF && Offset <= 0xFFFF)
        fOffset = Offset - 0xFFFF - 1;
    }
    
    if ((opcode == 3) && (Navigation_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
    {
      // GetNextListPos Result schicken
      
      // Result = successful
      send_data_GNLP_Result[0] = 0;
      
      // currentPos
      send_data_GNLP_Result[1] = currentPos & 0x00FF;
      send_data_GNLP_Result[2] = currentPos>>8 & 0x00FF;
      
      // nextPos
      switch (ListType)
      {
        case 0x00: // LastDestinationsList
          
          if (currentPos + fOffset > Navigation_LastDestList_TotalListNum)
            nextPos = Navigation_LastDestList_TotalListNum;
          if (currentPos + fOffset < 0)
            nextPos = 0;
          if ((currentPos + fOffset <= Navigation_LastDestList_TotalListNum) && (currentPos + fOffset >= 0))
            nextPos = currentPos + fOffset;
          
        break;
          
        case 0x01: // FavoriteDestinationsList
          
          if (currentPos + fOffset > Navigation_FavoriteDestList_TotalListNum)
            nextPos = Navigation_FavoriteDestList_TotalListNum;
          if (currentPos + fOffset < 0)
            nextPos = 0;
          if ((currentPos + fOffset <= Navigation_FavoriteDestList_TotalListNum) && (currentPos + fOffset >= 0))
            nextPos = currentPos + fOffset;
          
        break;
          
        case 0x02: // NavBook

        break;
          
        case 0x03: // AddressList
          
          if (currentPos + fOffset > Navigation_AddressList_TotalListNum)
            nextPos = Navigation_AddressList_TotalListNum;
          if (currentPos + fOffset < 0)
            nextPos = 0;
          if ((currentPos + fOffset <= Navigation_AddressList_TotalListNum) && (currentPos + fOffset >= 0))
            nextPos = currentPos + fOffset;
          
        break;
          
        case 0x04: // POI_List

        break;
      }

      send_data_GNLP_Result[3] = nextPos & 0x00FF;
      send_data_GNLP_Result[4] = nextPos>>8 & 0x00FF;
      send_data_GNLP_Result[5] = nextPos & 0x00FF;
      send_data_GNLP_Result[6] = nextPos>>8 & 0x00FF;
      
      SendRequestByteSequence(LSGID_Navigation, 0x29, Result_REQ, 7, send_data_GNLP_Result);
    }
  }
}


// Navigation 0x2A NbSpeller

Navigation_NbSpeller (byte opcode, byte data[])
{
  byte Result;
  int  MatchingEntries;
  int  Pos;
  byte send_data[5];
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 2) && (Navigation_Source == 1)) // ASG StartResult
    {
      // keine Uebernahme der Paramter noetig
    }
    
    if ((opcode == 3) && (Navigation_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
    {
      Result          = @M_FSG_50_0_0_42_Result_1;
      MatchingEntries = @M_FSG_50_0_0_42_Result_2;
      Pos             = @M_FSG_50_0_0_42_Result_3;
      
      // NbSpeller Result senden
      send_data[0] = Result;
      send_data[1] = MatchingEntries       & 0x00FF;
      send_data[2] = MatchingEntries  >>8  & 0x00FF;
      send_data[3] = Pos                   & 0x00FF;
      send_data[4] = Pos              >>8  & 0x00FF;
      
      sendRequestByteSequence(LSGID_Navigation, 0x2A, Result_REQ, 5, send_data);
    }
  }
}


// Navigation 0x33 POI_Search

Navigation_POI_Search (byte opcode, byte data[])
{
  byte AmountOfFoundEntries;
  byte Result;
  byte send_data[2];
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 2) && (Navigation_Source == 1)) // ASG StartResult
    {
      // keine Uebernahme der Paramter noetig
    }
    
    if ((opcode == 3) && (Navigation_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
    {
      AmountOfFoundEntries  = @M_FSG_50_0_0_51_Result_1;
      Result                = @M_FSG_50_0_0_51_Result_2;
      
      // POI_Search Result senden
      send_data[0] = AmountOfFoundEntries;
      send_data[1] = Result;
      
      sendRequestByteSequence(LSGID_Navigation, 0x33, Result_REQ, 2, send_data);
    }
  }
}





// Navigation 0x34 FavoriteDest_List

on envVar Env_Navigation_POI_List_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Navigation_POI_List_Path, gNavigation_POI_List_Path);
    Navigation_POI_List_LoadArray();
  } 
}

on envVar Env_Navigation_POI_List_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Navigation_POI_List_Path, gNavigation_POI_List_Path);
    Navigation_POI_List_LoadArray();
    Navigation_POI_List_Changed(0x0,0x0, 0x0000, 0xFF);
  }
}

Navigation_POI_List_LoadArray()
{
/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < Navigation_POI_List_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Navigation_POI_List[i].Param1 = 0;
		Navigation_POI_List[i].Param2 = 0;
		Navigation_POI_List[i].Param3 = 0;
		Navigation_POI_List[i].Param4 = 0;
		Navigation_POI_List[i].Param5 = 0;
		Navigation_POI_List[i].Param6 = 0;
		for(j=0; j<91; j++)
			Navigation_POI_List[i].Param7[j] = 0;
		Navigation_POI_List[i].Param7_Length = 0;
		for(j=0; j<91; j++)
			Navigation_POI_List[i].Param8[j] = 0;
		Navigation_POI_List[i].Param8_Length = 0;
		for(j=0; j<91; j++)
			Navigation_POI_List[i].Param9[j] = 0;
		Navigation_POI_List[i].Param9_Length = 0;
		for(j=0; j<22; j++)
			Navigation_POI_List[i].Param10[j] = 0;
		Navigation_POI_List[i].Param10_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gNavigation_POI_List_Path); i++)
  {
    if (gNavigation_POI_List_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gNavigation_POI_List_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gNavigation_POI_List_Path, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						Navigation_POI_List[current_CSV_line-1].Param1 = atol(temp1); //Pos
						Navigation_POI_List[current_CSV_line-1].Param2 = atol(temp2); //Direction_Symbolic
						Navigation_POI_List[current_CSV_line-1].Param3 = atol(temp3); //POI_Type
						Navigation_POI_List[current_CSV_line-1].Param4 = atol(temp4); //DistanceType
						Navigation_POI_List[current_CSV_line-1].Param5 = atol(temp5); //Distance
						Navigation_POI_List[current_CSV_line-1].Param6 = atol(temp6); //Unit
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Direction_Symbolic
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //POI_Type
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //DistanceType
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Distance
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //Unit
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //MainDescription
								if(paramPos < 90)
								{
									Navigation_POI_List[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
									Navigation_POI_List[current_CSV_line-1].Param7_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 8: //Street
								if(paramPos < 90)
								{
									Navigation_POI_List[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
									Navigation_POI_List[current_CSV_line-1].Param8_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 9: //City
								if(paramPos < 90)
								{
									Navigation_POI_List[current_CSV_line-1].Param9[paramPos] = buffer_byte[filePos];
									Navigation_POI_List[current_CSV_line-1].Param9_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 10: //PostalCode
								if(paramPos < 21)
								{
									Navigation_POI_List[current_CSV_line-1].Param10[paramPos] = buffer_byte[filePos];
									Navigation_POI_List[current_CSV_line-1].Param10_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  Navigation_POI_List_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
}

Navigation_POI_List(byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements;

  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 1) && (Navigation_Source == 1)) // ASG GetArray
    {
      ASG_ID = data[0] >> 4 & 0xF;
      TAID = data[0] & 0xF;
      mode = data[1] >> 4 & 0xF;
      recordaddress = data[1] & 0xF;
      IndexSize = mode >> 3 & 0x1;
      Direction = (mode>>1) & 0x1;
      TransPos = (mode>>2) & 0x1;
      Shift = (mode>>0) & 0x1;

      list_start = data[2];
      elements = data[3];
                
      ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

      if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
        @A_FSG_50_0_0_52_1 = ASG_ID;  // Set to panel value
      else
        ASG_ID = @A_FSG_50_0_0_52_1; // Set from panel value
       
      if (@env_AutoGetArray_TAID == 0)  // TAID
        @A_FSG_50_0_0_52_2 = TAID;
      else
        TAID = @A_FSG_50_0_0_52_2;
      
      if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
        @A_FSG_50_0_0_52_RecAdr = recordaddress;
      else
        recordaddress = @A_FSG_50_0_0_52_RecAdr;
      
      if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
        @A_FSG_50_0_0_52_Shift = (mode>>0);
      else
        mode = ((@A_FSG_50_0_0_52_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
        @A_FSG_50_0_0_52_Direction = (mode>>1);
      else
        mode = ((Shift*1)+(@A_FSG_50_0_0_52_Direction*2)+(TransPos*4)+(IndexSize*8));
      
      if (@env_AutoGetArray_Start == 0)  // Start
        @A_FSG_50_0_0_52_Start = list_start;
      else
        list_start = @A_FSG_50_0_0_52_Start;

      /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
      {
        Navigation_POI_List_Status (ASG_ID, TAID, mode, recordaddress,list_start, elements);
      }
    }
  }
}

Navigation_POI_List_Status(byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition, elements ;
  byte sequenceNumber = 0;
  
  int i, k , strctr; 
  int stringsize;   

  elements = received_elements;

  Data_Navigation_POI_List[0] =  ASG_ID*16 + (TAID & 0xF);
  Data_Navigation_POI_List[1] = (Navigation_POI_List_TotalListNum & 0xFF);
  Data_Navigation_POI_List[2] = (mode|0x4)*16 + (recordaddress & 0xF);
    
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
  
   switch(direction)
   {
      case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift;
        endposition = startposition + elements - 1;
      }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (list_start < Navigation_POI_List_TotalListNum)
        {
          startposition = list_start + shift - 1;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Navigation_POI_List_TotalListNum)
      {
        endposition = Navigation_POI_List_TotalListNum - 1;
        elements = Navigation_POI_List_TotalListNum - startposition;
      }
      break;
    
      case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (list_start <= Navigation_POI_List_TotalListNum)
        {
          startposition = list_start - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift + 1;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Navigation_POI_List_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
      
    break;
  }
   
  Data_Navigation_POI_List[3] = list_start & 0xFF;
  Data_Navigation_POI_List[4] = elements & 0xFF;

  j_Navigation_POI_List = 5;
   
  switch(direction)
  {
    case 0:
         
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        // Pos
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param1;
        
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // Direction_Symbolic
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x5) // POI_Type
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param3;
        
        if (recordaddress == 0x0 || recordaddress == 0x5) // DistanceType
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param4;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2) // Distance
          Data_Navigation_POI_List[j_Navigation_POI_List++] = (Navigation_POI_List[i].param5      ) & 0xFF;
          Data_Navigation_POI_List[j_Navigation_POI_List++] = (Navigation_POI_List[i].param5 >>  8) & 0xFF;
          Data_Navigation_POI_List[j_Navigation_POI_List++] = (Navigation_POI_List[i].param5 >> 16) & 0xFF;
          Data_Navigation_POI_List[j_Navigation_POI_List++] = (Navigation_POI_List[i].param5 >> 24) & 0xFF;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x5) // Unit
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param6;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x4 || recordaddress == 0x5) // MainDescription
        {
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param7_Length;
          stringsize = Navigation_POI_List[i].param7_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param7[strctr];           
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x4) // Street
        {
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param8_Length;
          stringsize = Navigation_POI_List[i].param8_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param8[strctr];           
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x4) // City
        {
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param9_Length;
          stringsize = Navigation_POI_List[i].param9_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param9[strctr];           
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x4) // PostalCode
        {
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param10_Length;
          stringsize = Navigation_POI_List[i].param10_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param10[strctr];           
          } 
        }
      }
      
    break;
            
    case 1:
      
      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        // Pos
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param1;
        
        if (recordaddress == 0x0 || recordaddress == 0x3 || recordaddress == 0x5) // Direction_Symbolic
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param2;
        
        if (recordaddress == 0x0 || recordaddress == 0x5) // POI_Type
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param3;
        
        if (recordaddress == 0x0 || recordaddress == 0x5) // DistanceType
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param4;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2) // Distance
          Data_Navigation_POI_List[j_Navigation_POI_List++] = (Navigation_POI_List[i].param5      ) & 0xFF;
          Data_Navigation_POI_List[j_Navigation_POI_List++] = (Navigation_POI_List[i].param5 >>  8) & 0xFF;
          Data_Navigation_POI_List[j_Navigation_POI_List++] = (Navigation_POI_List[i].param5 >> 16) & 0xFF;
          Data_Navigation_POI_List[j_Navigation_POI_List++] = (Navigation_POI_List[i].param5 >> 24) & 0xFF;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x2 || recordaddress == 0x5) // Unit
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param6;
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x4 || recordaddress == 0x5) // MainDescription
        {
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param7_Length;
          stringsize = Navigation_POI_List[i].param7_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param7[strctr];           
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x4) // Street
        {
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param8_Length;
          stringsize = Navigation_POI_List[i].param8_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param8[strctr];           
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x4) // City
        {
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param9_Length;
          stringsize = Navigation_POI_List[i].param9_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param9[strctr];           
          } 
        }
        
        if (recordaddress == 0x0 || recordaddress == 0x1 || recordaddress == 0x4) // PostalCode
        {
          Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param10_Length;
          stringsize = Navigation_POI_List[i].param10_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_Navigation_POI_List[j_Navigation_POI_List++] = Navigation_POI_List[i].param10[strctr];           
          } 
        }
      }
      
    break;
  }
  settimer (Delay_Navigation_POI_List, @Env_Navigation_POI_List_ListDelay);
}

Navigation_POI_List_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  SendRequestByteSequence (LSGID_Navigation, 0x34, Changed_REQ, length, data);
}

on timer Delay_Navigation_POI_List
{
  sendRequestByteSequence(LSGID_Navigation, 0x34, Data_REQ, j_Navigation_POI_List, Data_Navigation_POI_List);
}













// Navigation 0x3B RequestSync_Video

Navigation_RequestSync_Video (byte opcode, byte data[])
{
  byte ASG_ID;
  byte Result;
  byte send_data[2];

  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 4)
  {
    if ((opcode == 2) && (Navigation_Source == 1)) // ASG StartResult
    {
      ASG_ID                     = (data[0]>>4) & 0x0F;
      @M_FSG_50_0_0_59_Result_1  =  ASG_ID; 
    }
    
    if ((opcode == 3) && (Navigation_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
    {
      Result = @M_FSG_50_0_0_59_Result_3;
      
      // RequestSync_Video Result senden
      send_data[0] = @M_FSG_50_0_0_59_Result_1*16; // high nibble
      send_data[1] =  Result;
      
      sendRequestByteSequence(LSGID_Navigation, 0x3B, Result_REQ, 2, send_data);
    }
  }
  
  
  if (@BAPCFG_FSG_50_0_0_DFMajor == 5)
  {
    if ((opcode == 2) && (Navigation_Source == 1)) // ASG StartResult
    {
      ASG_ID                     = (data[0]>>4) & 0x0F;
      @M_FSG_50_0_0_37_Result_1  =  ASG_ID; 
    }
    
    if ((opcode == 3) && (Navigation_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
    {
      Result = @M_FSG_50_0_0_37_Result_3;
      
      // RequestSync_Video Result senden
      send_data[0] = @M_FSG_50_0_0_37_Result_1*16; // high nibble
      send_data[1] =  Result;
      
      sendRequestByteSequence(LSGID_Navigation, 0x25, Result_REQ, 2, send_data);
    }
  }
}

on envVar env_LoadBTN_LG
{ @Env_Navigation_LaneGuidance_LoadBTN = @this; }
on envVar env_LoadBTN_LG_Full
{ @Env_Navigation_LaneGuidance_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Nav_LG
{ @Env_Navigation_LaneGuidance_ListDelay = @this; }
on envVar envLaneGuidancePath
{ char temp[255]; getValue (this, temp); putvalue (Env_Navigation_LaneGuidance_Path, temp); }

on envVar env_LoadBTN_LDL
{ @Env_Navigation_LastDestList_LoadBTN = @this; }
on envVar env_LoadBTN_LDL_Full
{ @Env_Navigation_LastDestList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Nav_LDL
{ @Env_Navigation_LastDestList_ListDelay = @this; }
on envVar envLastDestListPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Navigation_LastDestList_Path, temp); }

on envVar env_LoadBTN_FDL
{ @Env_Navigation_FavoriteDestList_LoadBTN = @this; }
on envVar env_LoadBTN_FDL_Full
{ @Env_Navigation_FavoriteDestList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Nav_FDL
{ @Env_Navigation_FavoriteDestList_ListDelay = @this; }
on envVar envFavoriteDestListPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Navigation_FavoriteDestList_Path, temp); }

on envVar env_LoadBTN_AL
{ @Env_Navigation_AddressList_LoadBTN = @this; }
on envVar env_LoadBTN_AL_Full
{ @Env_Navigation_AddressList_LoadBTN_Full = @this; }
on envVar Env_ListDelay_Nav_AL
{ @Env_Navigation_AddressList_ListDelay = @this; }
on envVar envAddressListPath
{ char temp[255]; getValue (this, temp); putvalue (Env_Navigation_AddressList_Path, temp); }










/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////// SDS //////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

on envVar Node_Index_FSG_70
{
  Node_Index_SDS = @Node_Index_FSG_70;
}

on message BAP_SDS_ASG_01
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  SDS_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG70_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          SDS_app_data_ASG01[log_channel][i] = 0;

      // BAP Header auswerten
      SDS_received_function_ASG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      SDS_received_function_ASG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      SDS_received_function_ASG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          SDS_app_data_ASG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,SDS_received_function_ASG01[log_channel][2]);
      
      // an checkfunction übergeben
      if (SDS_received_function_ASG01[log_channel][2] == 0x12) { SDS_CommandList_Log_Channel = log_channel; } // CommandList
      if (SDS_received_function_ASG01[log_channel][2] == 0x13) { SDS_ResultList_Log_Channel = log_channel; } // ResultList
      checkFunction (SDS_received_function_ASG01[log_channel][0], SDS_received_function_ASG01[log_channel][1], SDS_received_function_ASG01[log_channel][2], SDS_app_data_ASG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          SDS_app_data_ASG01[log_channel][i] = 0;        

      // BAP Header auswerten
      SDS_received_function_ASG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      SDS_received_function_ASG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      SDS_received_function_ASG01[log_channel][2] = (data[3] & 0x3F); // FctID
      SDS_data_length_ASG01[log_channel] = ((data[0] &0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          SDS_app_data_ASG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      SDS_data_length_ASG01[log_channel] = SDS_data_length_ASG01[log_channel] - 4;
      SDS_currentPosASG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (SDS_data_length_ASG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,SDS_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (SDS_received_function_ASG01[log_channel][2] == 0x12) { SDS_CommandList_Log_Channel = log_channel; } // CommandList
        if (SDS_received_function_ASG01[log_channel][2] == 0x13) { SDS_ResultList_Log_Channel = log_channel; } // ResultList
        checkFunction (SDS_received_function_ASG01[log_channel][0], SDS_received_function_ASG01[log_channel][1], SDS_received_function_ASG01[log_channel][2], SDS_app_data_ASG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      SDS_sequenceNumberASG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (SDS_data_length_ASG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
            SDS_app_data_ASG01[log_channel][SDS_currentPosASG01[log_channel]] = data[i+1];
            SDS_currentPosASG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        SDS_data_length_ASG01[log_channel] = SDS_data_length_ASG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (SDS_data_length_ASG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < SDS_data_length_ASG01[log_channel]; i++)
        {
            SDS_app_data_ASG01[log_channel][SDS_currentPosASG01[log_channel]] = data[i+1];
            SDS_currentPosASG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,SDS_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (SDS_received_function_ASG01[log_channel][2] == 0x12) { SDS_CommandList_Log_Channel = log_channel; } // CommandList
        if (SDS_received_function_ASG01[log_channel][2] == 0x13) { SDS_ResultList_Log_Channel = log_channel; } // ResultList
        checkFunction (SDS_received_function_ASG01[log_channel][0], SDS_received_function_ASG01[log_channel][1], SDS_received_function_ASG01[log_channel][2], SDS_app_data_ASG01[log_channel]);
      }
    }
  }
}


// SDS 0x12 CommandList

on envVar Env_SDS_CommandList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_SDS_CommandList_Path, gSDS_CommandList_Path);
    SDS_CommandList_LoadArray();
  }
}

on envVar Env_SDS_CommandList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_SDS_CommandList_Path, gSDS_CommandList_Path);
    SDS_CommandList_LoadArray();
    SDS_CommandList_Changed(0x0,0x0, 0x00, 0xFF);    
  }
}

SDS_CommandList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;
  dword index;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for (i = 0; i < SDS_CommandList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		SDS_CommandList[i].Param1 = 0;
		SDS_CommandList[i].Param2 = 0;
		for (j=0; j<61; j++)
			SDS_CommandList[i].Param3[j] = 0;
		SDS_CommandList[i].Param3_Length = 0;
		for (j=0; j<2; j++)
			SDS_CommandList[i].Param4[j] = 0;
		SDS_CommandList[i].Param4_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gSDS_CommandList_Path); i++)
  {
    if (gSDS_CommandList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gSDS_CommandList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gSDS_CommandList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						SDS_CommandList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						SDS_CommandList[current_CSV_line-1].Param2 = atol(temp2); //CommandID
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //CommandID
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //CommandText
								if (paramPos < 60)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_SDS_CommandList_ListFormat == 1) )
                  {
                    SDS_CommandList[current_CSV_line-1].Param3[paramPos++] = buffer_byte[filePos++];
                    SDS_CommandList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_SDS_CommandList_ListFormat == 0) )
                  {
                    SDS_CommandList[current_CSV_line-1].Param3[paramPos++] = 0xC2;
                    SDS_CommandList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_SDS_CommandList_ListFormat == 0) )
                  {
                    SDS_CommandList[current_CSV_line-1].Param3[paramPos++] = 0xC3;
                    SDS_CommandList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    SDS_CommandList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
									SDS_CommandList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 4: //Extension
								if (paramPos < 1)
								{
									SDS_CommandList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									SDS_CommandList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  SDS_CommandList_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
}

SDS_CommandList(byte opcode, byte data[])
{
  byte TotalNumListElements;
  byte IndexSize, Shift, Direction, TransPos, mode, recordaddress;
  dword list_start, elements;
  byte ASG_ID, TAID;
  
  if ((opcode == 1) && (SDS_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    TotalNumListElements = SDS_CommandList_TotalListNum;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
 
    list_start = data[2];
    elements = data[3];
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_70_0_0_18_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_70_0_0_18_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_70_0_0_18_2 = TAID;
    else
      TAID = @A_FSG_70_0_0_18_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_70_0_0_18_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_70_0_0_18_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_70_0_0_18_Shift = (mode>>0);
    else
      mode = ((@A_FSG_70_0_0_18_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_70_0_0_18_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_70_0_0_18_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_70_0_0_18_Start = list_start;
    else
      list_start = @A_FSG_70_0_0_18_Start;
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      SDS_CommandList_Status(ASG_ID, TAID, TotalNumListElements, mode, recordaddress,list_start, elements);
    }
  }
}

SDS_CommandList_Status(byte ASG_ID, byte TAID, byte TotalNumListElements, byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition;
  byte sequenceNumber = 0;
  byte transmit_pos;

  int i, k , strctr; 
  int stringsize;

  Data_SDS_CommandList[0] = ASG_ID*16 + (TAID & 0xF);
  Data_SDS_CommandList[1] = TotalNumListElements;
  Data_SDS_CommandList[2] = (mode|0x4)*16 + recordaddress;
    
  IndexSize    = (mode>>3) & 0x1;
  transmit_pos = (mode>>2) & 0x1;
  direction    = (mode>>1) & 0x1;
  shift        =  mode     & 0x1;
  
  switch(direction)
  {
    case 0:
      
      if (list_start == 0)
      {
        startposition =  shift; 
        endposition = startposition - 1 + elements;
      }
      else if (list_start > 0)
      {
        startposition = list_start + shift - 1;
        endposition = startposition+ elements - 1;
      }
      
      if (endposition >= SDS_CommandList_TotalListNum)
      {
        elements = SDS_CommandList_TotalListNum - startposition;
        endposition = SDS_CommandList_TotalListNum - 1;
      }

      if (startposition >= SDS_CommandList_TotalListNum)
      {
        elements=0;
      }
  
    break;
   
    case 1:
      
      if (list_start > 0)
      {
        startposition = list_start - shift - 1; 
        endposition = startposition - elements + 1; 
      }
      else if ((list_start == 0) && (shift == 1))
      {
        startposition = SDS_CommandList_TotalListNum -1;
        endposition = startposition - elements + 1;
      }
          
      if (endposition < 0)
      {
        elements = elements + endposition;
        endposition = 0;
      }
      
      if ((startposition >= SDS_CommandList_TotalListNum) || ((list_start == 0) && (shift == 0)))
      {
        elements=0;
      }
                
    break;
  }
 
  Data_SDS_CommandList[3] = list_start & 0xFF;
  Data_SDS_CommandList[4] = elements & 0xFF;

  j_SDS_CommandList = 5;
   
  switch(direction)
  {
    case 0:
         
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_SDS_CommandList[j_SDS_CommandList++] = SDS_CommandList[i].param1; // Pos
          
        if (recordaddress == 0x1 || recordaddress == 0x2)  // CommandID
        {
          Data_SDS_CommandList[j_SDS_CommandList++] = SDS_CommandList[i].param2 & 0xFF;
          Data_SDS_CommandList[j_SDS_CommandList++] = (SDS_CommandList[i].param2>>8) & 0xFF;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x3) // CommandText
        {  
          Data_SDS_CommandList[j_SDS_CommandList++] = SDS_CommandList[i].param3_Length;
          stringsize = SDS_CommandList[i].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_SDS_CommandList[j_SDS_CommandList++] = SDS_CommandList[i].param3[strctr];
          } 
        }
      }

    break;
            
    case 1:
      
     for (i = startposition ; i >= endposition && i >= 0; i--)
     {
       Data_SDS_CommandList[j_SDS_CommandList++] = SDS_CommandList[i].param1; // Pos
      
       if (recordaddress == 0x1 || recordaddress == 0x2)  // CommandID
       {
         Data_SDS_CommandList[j_SDS_CommandList++] = SDS_CommandList[i].param2 & 0xFF;
         Data_SDS_CommandList[j_SDS_CommandList++] = (SDS_CommandList[i].param2>>8) & 0xFF;
       }
       
       if (recordaddress == 0x1 || recordaddress == 0x3) // CommandText
       {
         Data_SDS_CommandList[j_SDS_CommandList++] = SDS_CommandList[i].param3_Length;
         stringsize = SDS_CommandList[i].param3_Length;
        
         for (strctr = 0; strctr < stringsize; strctr++)
         {
           Data_SDS_CommandList[j_SDS_CommandList++] = SDS_CommandList[i].param3[strctr];
         }
       }
     }
   break;
 }
 settimer (Delay_SDS_CommandList, @Env_SDS_CommandList_ListDelay);
}

SDS_CommandList_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  SendRequestByteSequence(LSGID_SDS, 0x12, Changed_REQ, length, data);
}

on timer Delay_SDS_CommandList
{ 
  sendRequestByteSequence(LSGID_SDS, 0x12, Data_REQ, j_SDS_CommandList, Data_SDS_CommandList);
}


// SDS 0x12 ResultList

on envVar Env_SDS_ResultList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_SDS_ResultList_Path, gSDS_ResultList_Path);
    SDS_ResultList_LoadArray();
  } 
}

on envVar Env_SDS_ResultList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_SDS_ResultList_Path, gSDS_ResultList_Path);
    SDS_ResultList_LoadArray();
    SDS_ResultList_Changed(0x0,0x0, 0x00, 0xFF);    
  }
}

SDS_ResultList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;
  dword index;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for (i = 0; i < SDS_ResultList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		SDS_ResultList[i].Param1 = 0;
		SDS_ResultList[i].Param2 = 0;
		for (j=0; j<171; j++)
			SDS_ResultList[i].Param3[j] = 0;
		SDS_ResultList[i].Param3_Length = 0;
		for (j=0; j<2; j++)
			SDS_ResultList[i].Param4[j] = 0;
		SDS_ResultList[i].Param4_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gSDS_ResultList_Path); i++)
  {
    if (gSDS_ResultList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gSDS_ResultList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gSDS_ResultList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if (current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						SDS_ResultList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						SDS_ResultList[current_CSV_line-1].Param2 = atol(temp2); //ResultType
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //ResultType
								if ( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //ResultText
								if (paramPos < 169)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_SDS_ResultList_ListFormat == 1) )
                  {
                    SDS_ResultList[current_CSV_line-1].Param3[paramPos++] = buffer_byte[filePos++];
                    SDS_ResultList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_SDS_ResultList_ListFormat == 0) )
                  {
                    SDS_ResultList[current_CSV_line-1].Param3[paramPos++] = 0xC2;
                    SDS_ResultList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_SDS_ResultList_ListFormat == 0) )
                  {
                    SDS_ResultList[current_CSV_line-1].Param3[paramPos++] = 0xC3;
                    SDS_ResultList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    SDS_ResultList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
									SDS_ResultList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 4: //Extension
								if (paramPos < 1)
								{
									SDS_ResultList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									SDS_ResultList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  SDS_ResultList_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
}

SDS_ResultList(byte opcode, byte data[])
{
  byte TotalNumListElements;
  byte IndexSize, Shift, Direction, TransPos, mode, recordaddress;
  dword list_start, elements;
  byte ASG_ID, TAID;

  if ((opcode == 1) && (SDS_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    TotalNumListElements = SDS_ResultList_TotalListNum;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
                     
    list_start = data[2];
    elements = data[3];

    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_70_0_0_19_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_70_0_0_19_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_70_0_0_19_2 = TAID;
    else
      TAID = @A_FSG_70_0_0_19_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_70_0_0_19_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_70_0_0_19_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_70_0_0_19_Shift = (mode>>0);
    else
      mode = ((@A_FSG_70_0_0_19_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_70_0_0_19_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_70_0_0_19_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_70_0_0_19_Start = list_start;
    else
      list_start = @A_FSG_70_0_0_19_Start;
      
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      SDS_ResultList_Status(ASG_ID, TAID, TotalNumListElements, mode, recordaddress,list_start, elements);
    }
  }
}

SDS_ResultList_Status(byte ASG_ID, byte TAID, byte TotalNumListElements, byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte string[60];
  byte IndexSize, shift, direction; 
  int startposition, endposition;
  byte sequenceNumber = 0;
  byte transmit_pos;

  int i, k , strctr; 
  int stringsize;

  Data_SDS_ResultList[0] = ASG_ID*16 + (TAID & 0xF);
  Data_SDS_ResultList[1] = TotalNumListElements;
  Data_SDS_ResultList[2] = (mode|0x4)*16 + recordaddress;
   
  IndexSize = (mode>>3) & 0x1;
  transmit_pos = (mode>>2) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;

  switch(direction){
  
    case 0:
      
      if (list_start == 0)
      {
        startposition =  shift; 
        endposition = startposition - 1 + elements;
      }
      
      else if (list_start > 0)
      {
        startposition = list_start + shift - 1;
        endposition = startposition+ elements - 1;
      }
      if (endposition >= SDS_ResultList_TotalListNum)
      {
        elements = SDS_ResultList_TotalListNum - startposition;
        endposition = SDS_ResultList_TotalListNum - 1;
      }

      if (startposition >= SDS_ResultList_TotalListNum)
      {
        elements=0;
      }
  
    break;
   
    case 1:
      
      if (list_start > 0)
      {
        startposition = list_start - shift - 1; 
        endposition = startposition - elements + 1; 
      }
      else if ((list_start == 0) && (shift == 1))
      {
        startposition = SDS_ResultList_TotalListNum -1;
        endposition = startposition - elements + 1;
      }
        
      if (endposition < 0)
      {
        elements = elements + endposition;
        endposition = 0;
      }
      
      if ((startposition >= SDS_ResultList_TotalListNum) || ((list_start == 0) && (shift == 0)))
      {
        elements=0;
      }
                
    break;
  }
 
  Data_SDS_ResultList[3] = list_start & 0xFF;
  Data_SDS_ResultList[4] = elements & 0xFF;

  j_SDS_ResultList = 5;
   
  switch(direction)
  {
    case 0:
   
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_SDS_ResultList[j_SDS_ResultList++] = SDS_ResultList[i].param1;
        
        if (recordaddress == 0x1)  // ResultType
          Data_SDS_ResultList[j_SDS_ResultList++] = SDS_ResultList[i].param2;
        
        if (recordaddress == 0x1 || recordaddress == 0x2) // ResultText
        {  
            Data_SDS_ResultList[j_SDS_ResultList++] = SDS_ResultList[i].param3_Length;
            stringsize = SDS_ResultList[i].param3_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_SDS_ResultList[j_SDS_ResultList++] = SDS_ResultList[i].param3[strctr];
            } 
        }
      }
      
    break;
            
    case 1:

      for (i = startposition ; i >= endposition && i >= 0; i--)
      {
        Data_SDS_ResultList[j_SDS_ResultList++] = SDS_ResultList[i].param1;
        
        if (recordaddress == 0x1)  // ResultType
          Data_SDS_ResultList[j_SDS_ResultList++] = SDS_ResultList[i].param2;
        
        if (recordaddress == 0x1 || recordaddress == 0x2) // ResultText
        {  
          Data_SDS_ResultList[j_SDS_ResultList++] = SDS_ResultList[i].param3_Length;
          stringsize = SDS_ResultList[i].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_SDS_ResultList[j_SDS_ResultList++] = SDS_ResultList[i].param3[strctr];
          } 
        }
      }
    break;
  }
  settimer (Delay_SDS_ResultList, @Env_SDS_ResultList_ListDelay);
}

SDS_ResultList_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 

  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  SendRequestByteSequence(LSGID_SDS, 0x13, Changed_REQ, length, data);
}

on timer Delay_SDS_ResultList
{ 
  sendRequestByteSequence(LSGID_SDS, 0x13, Data_REQ, j_SDS_ResultList, Data_SDS_ResultList);
}






/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////// InfoSettings //////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

on envVar Node_Index_FSG_80
{
  Node_Index_InfoSettings = @Node_Index_FSG_80;
}

on message BAP_InfoSettings_ASG_01
{
  byte data[8];
  byte ASG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: ASG
  InfoSettings_Source = 1;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG80_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          InfoSettings_app_data_ASG01[log_channel][i] = 0;

      // BAP Header auswerten
      InfoSettings_received_function_ASG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      InfoSettings_received_function_ASG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      InfoSettings_received_function_ASG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          InfoSettings_app_data_ASG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,InfoSettings_received_function_ASG01[log_channel][2]);
      
      // an checkfunction übergeben
      if (InfoSettings_received_function_ASG01[log_channel][2] == 0x16) { InfoSettings_BTDeviceList_Log_Channel = log_channel; } // BTDeviceList
      if (InfoSettings_received_function_ASG01[log_channel][2] == 0x18) { InfoSettings_LicenseInformation_Log_Channel = log_channel; } // LicenseInformation
      checkFunction (InfoSettings_received_function_ASG01[log_channel][0], InfoSettings_received_function_ASG01[log_channel][1], InfoSettings_received_function_ASG01[log_channel][2], InfoSettings_app_data_ASG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          InfoSettings_app_data_ASG01[log_channel][i] = 0;        

      // BAP Header auswerten
      InfoSettings_received_function_ASG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      InfoSettings_received_function_ASG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      InfoSettings_received_function_ASG01[log_channel][2] = (data[3] & 0x3F); // FctID
      InfoSettings_data_length_ASG01[log_channel] = ((data[0] &0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          InfoSettings_app_data_ASG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      InfoSettings_data_length_ASG01[log_channel] = InfoSettings_data_length_ASG01[log_channel] - 4;
      InfoSettings_currentPosASG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (InfoSettings_data_length_ASG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,InfoSettings_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (InfoSettings_received_function_ASG01[log_channel][2] == 0x16) { InfoSettings_BTDeviceList_Log_Channel = log_channel; } // BTDeviceList
      if (InfoSettings_received_function_ASG01[log_channel][2] == 0x18) { InfoSettings_LicenseInformation_Log_Channel = log_channel; } // LicenseInformation
        checkFunction (InfoSettings_received_function_ASG01[log_channel][0], InfoSettings_received_function_ASG01[log_channel][1], InfoSettings_received_function_ASG01[log_channel][2], InfoSettings_app_data_ASG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      InfoSettings_sequenceNumberASG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (InfoSettings_data_length_ASG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
            InfoSettings_app_data_ASG01[log_channel][InfoSettings_currentPosASG01[log_channel]] = data[i+1];
            InfoSettings_currentPosASG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        InfoSettings_data_length_ASG01[log_channel] = InfoSettings_data_length_ASG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (InfoSettings_data_length_ASG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < InfoSettings_data_length_ASG01[log_channel]; i++)
        {
            InfoSettings_app_data_ASG01[log_channel][InfoSettings_currentPosASG01[log_channel]] = data[i+1];
            InfoSettings_currentPosASG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,InfoSettings_received_function_ASG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (InfoSettings_received_function_ASG01[log_channel][2] == 0x16) { InfoSettings_BTDeviceList_Log_Channel = log_channel; } // BTDeviceList
      if (InfoSettings_received_function_ASG01[log_channel][2] == 0x18) { InfoSettings_LicenseInformation_Log_Channel = log_channel; } // LicenseInformation
        checkFunction (InfoSettings_received_function_ASG01[log_channel][0], InfoSettings_received_function_ASG01[log_channel][1], InfoSettings_received_function_ASG01[log_channel][2], InfoSettings_app_data_ASG01[log_channel]);
      }
    }
  }
}


on message BAP_InfoSettings_FSG_01
{
  byte data[8];
  byte FSG_TAID[8];
  int  i,  length, messageType, log_channel;
  
  // Source: FSG
  InfoSettings_Source = 2;
  
  // nur wenn BAP-Strecke aktiv
  if (@ON_OFF_FSG80_0 == 1)
  {
    // Array mit Daten aus Nachricht befüllen
    for (i = 0; i<8; i++)
      data[i] = this.byte(i);

    // messageType ermitteln
    if (((data[0]>>7) & 0x01) == 0) // unsegmentiert
      messageType = 0; // Single Frame
    else // segmentiert
    {
      if (((data[0]>>6) & 0x01) == 0)
        messageType=2; // First Frame

      if (((data[0]>>6) & 0x01) == 1)
        messageType=3; // Follow-Up Frame
    }
    
    // wenn Nachricht segmentiert ist, dann den logischen Kanal ermitteln
    if (messageType != 0)
      log_channel = ((data[0]>>4) & 0x03);
    
    /* --------------------------------------------------------------------- */
    
    // Single Frame
    if (messageType == 0)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          InfoSettings_app_data_FSG01[log_channel][i] = 0;

      // BAP Header auswerten
      InfoSettings_received_function_FSG01[log_channel][0] = ((data[0] >> 4) & 0x07); // Opcode
      InfoSettings_received_function_FSG01[log_channel][1] = ((data[0] & 0x0F) * 4) + (((data[1] >> 6) & 0x03)); // LSG-ID
      InfoSettings_received_function_FSG01[log_channel][2] = (data[1] & 0x3F); // FctID
      
      // Array mit Daten befüllen (- 2 Headerbits)
      for (i = 0; i<6; i++)
          InfoSettings_app_data_FSG01[log_channel][i] = data[i+2];
     
      // Debugausgabe
      //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,InfoSettings_received_function_FSG01[log_channel][2]);
      
      // an checkfunction übergeben
      if (InfoSettings_received_function_FSG01[log_channel][2] == 0x16) { InfoSettings_BTDeviceList_Log_Channel = log_channel; } // BTDeviceList
      if (InfoSettings_received_function_FSG01[log_channel][2] == 0x18) { InfoSettings_LicenseInformation_Log_Channel = log_channel; } // LicenseInformation
      checkFunction (InfoSettings_received_function_FSG01[log_channel][0], InfoSettings_received_function_FSG01[log_channel][1], InfoSettings_received_function_FSG01[log_channel][2], InfoSettings_app_data_FSG01[log_channel]);
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, First Frame
    if (messageType == 2)
    {
      // Array leeren
      for (i = 0; i<BAP_BUFFERSIZE; i++)
          InfoSettings_app_data_FSG01[log_channel][i] = 0;        

      // BAP Header auswerten
      InfoSettings_received_function_FSG01[log_channel][0] = ((data[2] >> 4) & 0x07); // Opcode
      InfoSettings_received_function_FSG01[log_channel][1] = ((data[2] & 0x0F) * 4) + ((data[3] >> 6) & 0x03); // LSG-ID
      InfoSettings_received_function_FSG01[log_channel][2] = (data[3] & 0x3F); // FctID
      InfoSettings_data_length_FSG01[log_channel] = ((data[0] &0x0F) * 256) + data[1]; // Länge
      
      // Array mit Daten befüllen (- 4 Headerbits)
      for (i = 0; i < 4; i++)
          InfoSettings_app_data_FSG01[log_channel][i] = data[i+4];
      
      // neue Restlänge berechnen und Posiition merken
      InfoSettings_data_length_FSG01[log_channel] = InfoSettings_data_length_FSG01[log_channel] - 4;
      InfoSettings_currentPosFSG01[log_channel] = 4;
      
      // wenn Länge <= 4, also keine Datenbytes mehr übrig: Nachricht an checkFunction übergeben
      if (InfoSettings_data_length_FSG01[log_channel] <= 0)
      {
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,InfoSettings_received_function_FSG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (InfoSettings_received_function_FSG01[log_channel][2] == 0x16) { InfoSettings_BTDeviceList_Log_Channel = log_channel; } // BTDeviceList
      if (InfoSettings_received_function_FSG01[log_channel][2] == 0x18) { InfoSettings_LicenseInformation_Log_Channel = log_channel; } // LicenseInformation
        checkFunction (InfoSettings_received_function_FSG01[log_channel][0], InfoSettings_received_function_FSG01[log_channel][1], InfoSettings_received_function_FSG01[log_channel][2], InfoSettings_app_data_FSG01[log_channel]);
      }
    }
    
    /* --------------------------------------------------------------------- */
    
    // Segmentiert, Follow-Up Frame
    if (messageType == 3)
    {
      // Sequenznummer aus Header auslesen
      InfoSettings_sequenceNumberFSG01[log_channel] = (data[0] & 0x0F);
      
      // wenn der aktuelle Frame != letzter Frame, also noch mehr 7 Datenbyte zu übertragen sind
      if (InfoSettings_data_length_FSG01[log_channel] > 7)
      {
        
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < 7; i++)
        {
            InfoSettings_app_data_FSG01[log_channel][InfoSettings_currentPosFSG01[log_channel]] = data[i+1];
            InfoSettings_currentPosFSG01[log_channel]++; 
        }
        
        // neue Restlänge berechnen
        InfoSettings_data_length_FSG01[log_channel] = InfoSettings_data_length_FSG01[log_channel] - 7;                
      }
      
      // wenn der aktuelle Frame == letzter Frame, also noch <= 7 Datenbyte zu übertragen sind
      if (InfoSettings_data_length_FSG01[log_channel] <= 7)
      {
        // Daten aus Nachricht an Array anhängen und Position inkrementieren
        for (i = 0; i < InfoSettings_data_length_FSG01[log_channel]; i++)
        {
            InfoSettings_app_data_FSG01[log_channel][InfoSettings_currentPosFSG01[log_channel]] = data[i+1];
            InfoSettings_currentPosFSG01[log_channel]++; 
        }
        
        // Debugausgabe
        //writelineex(4,0,"messageType: %d / log_channel: %d / fct-id: 0x%x", messageType,log_channel,InfoSettings_received_function_FSG01[log_channel][2]);
        
        // an checkfunction übergeben
        if (InfoSettings_received_function_FSG01[log_channel][2] == 0x16) { InfoSettings_BTDeviceList_Log_Channel = log_channel; } // BTDeviceList
      if (InfoSettings_received_function_FSG01[log_channel][2] == 0x18) { InfoSettings_LicenseInformation_Log_Channel = log_channel; } // LicenseInformation
        checkFunction (InfoSettings_received_function_FSG01[log_channel][0], InfoSettings_received_function_FSG01[log_channel][1], InfoSettings_received_function_FSG01[log_channel][2], InfoSettings_app_data_FSG01[log_channel]);
      }
    }
  }
}



// InfoSettings 0x10 ResetFactorySettings

InfoSettings_ResetFactorySettings (byte opcode, byte data[])
{
  byte ASG_ID;
  byte CommandType;
  byte send_data[2];
    
  if ((opcode == 2) && (InfoSettings_Source == 1)) // ASG StartResult
  {
    // StartResult auswerten
    ASG_ID      = (data[0]>>4) & 0x0F;
    CommandType =  data[0]     & 0x0F;
    @M_FSG_80_0_0_16_Processing_1 = ASG_ID;
    @M_FSG_80_0_0_16_Processing_2 = CommandType;
  }
  
  if ((opcode == 3) && (InfoSettings_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // Result schicken
    send_data[0] = ASG_ID*16 + CommandType;
    send_data[1] = @M_FSG_80_0_0_16_Result_3;
    sendRequestByteSequence(LSGID_InfoSettings, 0x10, Result_REQ, 2, send_data);
  }
} 




// InfoSettings 0x14 RadioFavoriteCommands

InfoSettings_RadioFavoriteCommands (byte opcode, byte data[])
{
  byte ASG_ID;
  byte CommandType;
  byte send_data[2];
  
  if ((opcode == 2) && (InfoSettings_Source == 1)) // ASG StartResult
  {
    // StartResult auswerten
    ASG_ID      = (data[0]>>4) & 0x0F;
    CommandType =  data[0]     & 0x0F;
    @M_FSG_80_0_0_20_Processing_1 = ASG_ID;
    @M_FSG_80_0_0_20_Processing_2 = CommandType;
  }
  
  if ((opcode == 3) && (InfoSettings_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // Result schicken
    send_data[0] = ASG_ID*16 + CommandType;
    send_data[1] = @M_FSG_80_0_0_20_Result_3;
    sendRequestByteSequence(LSGID_InfoSettings, 0x14, Result_REQ, 2, send_data);
  }
} 




// InfoSettings 0x16 BTDeviceList

on envVar Env_InfoSettings_BTDeviceList_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_InfoSettings_BTDeviceList_Path, gInfoSettings_BTDeviceList_Path);
    InfoSettings_BTDeviceList_LoadArray();
  }
}

on envVar Env_InfoSettings_BTDeviceList_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_InfoSettings_BTDeviceList_Path, gInfoSettings_BTDeviceList_Path);
    InfoSettings_BTDeviceList_LoadArray();
    InfoSettings_BTDeviceList_Changed(0x0,0x0, 0x00, 0xFF);    
  }
}

InfoSettings_BTDeviceList_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;
  dword index;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < InfoSettings_BTDeviceList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		InfoSettings_BTDeviceList[i].Param1 = 0;
		InfoSettings_BTDeviceList[i].Param2 = 0;
		for(j=0; j<100; j++)
			InfoSettings_BTDeviceList[i].Param3[j] = 0;
		InfoSettings_BTDeviceList[i].Param3_Length = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gInfoSettings_BTDeviceList_Path); i++)
  {
    if (gInfoSettings_BTDeviceList_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gInfoSettings_BTDeviceList_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gInfoSettings_BTDeviceList_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "BTDeviceList"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
					{
						InfoSettings_BTDeviceList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						InfoSettings_BTDeviceList[current_CSV_line-1].Param2 = atol(temp2); //BTProfiles
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 256)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //BTProfiles
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //DeviceName
								if(paramPos < 99)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_InfoSettings_BTDeviceList_ListFormat == 1) )
                  {
                    InfoSettings_BTDeviceList[current_CSV_line-1].Param3[paramPos++] = buffer_byte[filePos++];
                    InfoSettings_BTDeviceList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_InfoSettings_BTDeviceList_ListFormat == 0) )
                  {
                    InfoSettings_BTDeviceList[current_CSV_line-1].Param3[paramPos++] = 0xC2;
                    InfoSettings_BTDeviceList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_InfoSettings_BTDeviceList_ListFormat == 0) )
                  {
                    InfoSettings_BTDeviceList[current_CSV_line-1].Param3[paramPos++] = 0xC3;
                    InfoSettings_BTDeviceList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    InfoSettings_BTDeviceList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                  }
									InfoSettings_BTDeviceList[current_CSV_line-1].Param3_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  InfoSettings_BTDeviceList_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
}

InfoSettings_BTDeviceList(byte opcode, byte data[])
{
  byte TotalNumListElements;
  byte IndexSize, Shift, Direction, TransPos, mode, recordaddress;
  dword list_start, elements;
  byte ASG_ID, TAID;
  
  if ((opcode == 1) && (InfoSettings_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    TotalNumListElements = InfoSettings_BTDeviceList_TotalListNum;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
 
    list_start = data[2];
    elements = data[3];
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_80_0_0_22_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_80_0_0_22_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_80_0_0_22_2 = TAID;
    else
      TAID = @A_FSG_80_0_0_22_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_80_0_0_22_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_80_0_0_22_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_80_0_0_22_Shift = (mode>>0);
    else
      mode = ((@A_FSG_80_0_0_22_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_80_0_0_22_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_80_0_0_22_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_80_0_0_22_Start = list_start;
    else
      list_start = @A_FSG_80_0_0_22_Start;
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      InfoSettings_BTDeviceList_Status(ASG_ID, TAID, TotalNumListElements, mode, recordaddress,list_start, elements);
    }
  }
}

InfoSettings_BTDeviceList_Status(byte ASG_ID, byte TAID, byte TotalNumListElements, byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte string[100];
  byte IndexSize, shift, direction; 
  int startposition, endposition;
  byte sequenceNumber = 0;
  byte transmit_pos;

  int i, k , strctr; 
  int stringsize;

  Data_InfoSettings_BTDeviceList[0] = ASG_ID*16 + (TAID & 0xF);
  Data_InfoSettings_BTDeviceList[1] = TotalNumListElements;
  Data_InfoSettings_BTDeviceList[2] = (mode|0x4)*16 + recordaddress;
    
  IndexSize    = (mode>>3) & 0x1;
  transmit_pos = (mode>>2) & 0x1;
  direction    = (mode>>1) & 0x1;
  shift        =  mode     & 0x1;
  
  switch(direction)
  {
    case 0:
      
      if (list_start == 0)
      {
        startposition =  shift; 
        endposition = startposition - 1 + elements;
      }
      else if (list_start > 0)
      {
        startposition = list_start + shift - 1;
        endposition = startposition+ elements - 1;
      }
      
      if (endposition >= InfoSettings_BTDeviceList_TotalListNum)
      {
        elements = InfoSettings_BTDeviceList_TotalListNum - startposition;
        endposition = InfoSettings_BTDeviceList_TotalListNum - 1;
      }

      if (startposition >= InfoSettings_BTDeviceList_TotalListNum)
      {
        elements=0;
      }
  
    break;
   
    case 1:
      
      if (list_start > 0)
      {
        startposition = list_start - shift - 1; 
        endposition = startposition - elements + 1; 
      }
      else if ((list_start == 0) && (shift == 1))
      {
        startposition = InfoSettings_BTDeviceList_TotalListNum -1;
        endposition = startposition - elements + 1;
      }
          
      if (endposition < 0)
      {
        elements = elements + endposition;
        endposition = 0;
      }
      
      if ((startposition >= InfoSettings_BTDeviceList_TotalListNum) || ((list_start == 0) && (shift == 0)))
      {
        elements=0;
      }
                
    break;
  }
 
  Data_InfoSettings_BTDeviceList[3] = list_start & 0xFF;
  Data_InfoSettings_BTDeviceList[4] = elements & 0xFF;

  j_InfoSettings_BTDeviceList = 5;
   
  switch(direction)
  {
    case 0:
         
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_InfoSettings_BTDeviceList[j_InfoSettings_BTDeviceList++] = InfoSettings_BTDeviceList[i].param1; // Pos
          
        if (recordaddress == 0x1 || recordaddress == 0x2)  // BTProfiles
        {
          Data_InfoSettings_BTDeviceList[j_InfoSettings_BTDeviceList++] = InfoSettings_BTDeviceList[i].param2 & 0xFF;
        }
        
        if (recordaddress == 0x1 || recordaddress == 0x3) // DeviceName
        {  
          Data_InfoSettings_BTDeviceList[j_InfoSettings_BTDeviceList++] = InfoSettings_BTDeviceList[i].param3_Length;
          stringsize = InfoSettings_BTDeviceList[i].param3_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_InfoSettings_BTDeviceList[j_InfoSettings_BTDeviceList++] = InfoSettings_BTDeviceList[i].param3[strctr];
          } 
        }
      }

    break;
            
    case 1:
      
     for (i = startposition ; i >= endposition && i >= 0; i--)
     {
       Data_InfoSettings_BTDeviceList[j_InfoSettings_BTDeviceList++] = InfoSettings_BTDeviceList[i].param1; // Pos
      
       if (recordaddress == 0x1 || recordaddress == 0x2)  // BTProfiles
       {
         Data_InfoSettings_BTDeviceList[j_InfoSettings_BTDeviceList++] = InfoSettings_BTDeviceList[i].param2 & 0xFF;
         Data_InfoSettings_BTDeviceList[j_InfoSettings_BTDeviceList++] = (InfoSettings_BTDeviceList[i].param2>>8) & 0xFF;
       }
       
       if (recordaddress == 0x1 || recordaddress == 0x3) // DeviceName
       {
         Data_InfoSettings_BTDeviceList[j_InfoSettings_BTDeviceList++] = InfoSettings_BTDeviceList[i].param3_Length;
         stringsize = InfoSettings_BTDeviceList[i].param3_Length;
        
         for (strctr = 0; strctr < stringsize; strctr++)
         {
           Data_InfoSettings_BTDeviceList[j_InfoSettings_BTDeviceList++] = InfoSettings_BTDeviceList[i].param3[strctr];
         }
       }
     }
   break;
 }
 settimer (Delay_InfoSettings_BTDeviceList, @Env_InfoSettings_BTDeviceList_ListDelay);
}

InfoSettings_BTDeviceList_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  data[1] = list_start;
  data[2] = elements;
  
  length = 3;

  SendRequestByteSequence(LSGID_InfoSettings, 0x16, Changed_REQ, length, data);
}

on timer Delay_InfoSettings_BTDeviceList
{ 
  sendRequestByteSequence(LSGID_InfoSettings, 0x16, Data_REQ, j_InfoSettings_BTDeviceList, Data_InfoSettings_BTDeviceList);
}






// InfoSettings 0x17 BTPairingCommands

InfoSettings_BTPairingCommands (byte opcode, byte data[])
{
  byte ASG_ID;
  byte CommandType;
  byte send_data[2];
    
  if ((opcode == 2) && (InfoSettings_Source == 1)) // ASG StartResult
  {
    // StartResult auswerten
    ASG_ID      = (data[0]>>4) & 0x0F;
    CommandType =  data[0]     & 0x0F;
    @M_FSG_80_0_0_23_Processing_1 = ASG_ID;
    @M_FSG_80_0_0_23_Processing_2 = CommandType;
  }
  
  if ((opcode == 3) && (InfoSettings_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // Result schicken
    send_data[0] = ASG_ID*16 + CommandType;
    send_data[1] = @M_FSG_80_0_0_23_Result_3;
    sendRequestByteSequence(LSGID_InfoSettings, 0x17, Result_REQ, 2, send_data);
  }
} 





// InfoSettings 0x18 LicenseInformation

on envVar Env_InfoSettings_LicenseInformation_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_InfoSettings_LicenseInformation_Path, gInfoSettings_LicenseInformation_Path);
    InfoSettings_LicenseInformation_LoadArray();
  }
}

on envVar Env_InfoSettings_LicenseInformation_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_InfoSettings_LicenseInformation_Path, gInfoSettings_LicenseInformation_Path);
    InfoSettings_LicenseInformation_LoadArray();
    InfoSettings_LicenseInformation_Changed(0x0,0x0, 0x00, 0xFF);    
  }
}

InfoSettings_LicenseInformation_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;
  dword index;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < InfoSettings_LicenseInformation_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		InfoSettings_LicenseInformation[i].Param1 = 0;
		for(j=0; j<1202; j++)
			InfoSettings_LicenseInformation[i].Param2[j] = 0;
		InfoSettings_LicenseInformation[i].Param2_Length = 0;
		//InfoSettings_LicenseInformation_Data_2_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gInfoSettings_LicenseInformation_Path); i++)
  {
    if (gInfoSettings_LicenseInformation_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gInfoSettings_LicenseInformation_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gInfoSettings_LicenseInformation_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LicenseInformation"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 11) //ignore first line in *.csv file
					{
						InfoSettings_LicenseInformation[current_CSV_line-1].Param1 = atol(temp1); //Pos
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 11)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //LicenseText
								if(paramPos < 1200)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_InfoSettings_LicenseInformation_ListFormat == 1) )
                  {
                    InfoSettings_LicenseInformation[current_CSV_line-1].Param2[paramPos++] = buffer_byte[filePos++];
                    InfoSettings_LicenseInformation[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_InfoSettings_LicenseInformation_ListFormat == 0) )
                  {
                    InfoSettings_LicenseInformation[current_CSV_line-1].Param2[paramPos++] = 0xC2;
                    InfoSettings_LicenseInformation[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_InfoSettings_LicenseInformation_ListFormat == 0) )
                  {
                    InfoSettings_LicenseInformation[current_CSV_line-1].Param2[paramPos++] = 0xC3;
                    InfoSettings_LicenseInformation[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos] - 0x40;
                  }
                  // keine Sonderzeichen
                  else
                  {
                    InfoSettings_LicenseInformation[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
                  }
									InfoSettings_LicenseInformation[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  InfoSettings_LicenseInformation_TotalListNum = current_CSV_line - 1 - empty;
  empty=0;
}


InfoSettings_LicenseInformation(byte opcode, byte data[])
{
  int TotalNumListElements;
  byte IndexSize, Shift, Direction, TransPos, mode, recordaddress;
  dword list_start, elements;
  byte ASG_ID, TAID;
  
  if ((opcode == 1) && (InfoSettings_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    TotalNumListElements = InfoSettings_LicenseInformation_TotalListNum;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;
    
    if (IndexSize == 0)
    {
      list_start = data[2];
      elements = data[3];               
    }
    else if (IndexSize == 1)
    {
      list_start = data[3] * 256 + data[2];
      elements = data[5] * 256 + data[4];
    }
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////

    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_80_0_0_24_1 = ASG_ID;
    else
      ASG_ID = @A_FSG_80_0_0_24_1;
      
    if (@env_AutoGetArray_TAID == 0)  // TAID from GetArray
      @A_FSG_80_0_0_24_2 = TAID;
    else
      TAID = @A_FSG_80_0_0_24_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress from GetArray
      @A_FSG_80_0_0_24_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_80_0_0_24_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift from GetArray
      @A_FSG_80_0_0_24_Shift = (mode>>0);
    else
      mode = ((@A_FSG_80_0_0_24_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction from GetArray
      @A_FSG_80_0_0_24_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_80_0_0_24_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start from GetArray
      @A_FSG_80_0_0_24_Start = list_start;
    else
      list_start = @A_FSG_80_0_0_24_Start;
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    if ((@env_AutoGetArray_AutoStatus == 0) && (@Env_BAPList_Source == 0))  // csv
    {
      InfoSettings_LicenseInformation_Status(ASG_ID, TAID, TotalNumListElements, mode, recordaddress,list_start, elements);
    }
  }
}

InfoSettings_LicenseInformation_Status(byte ASG_ID, byte TAID, int TotalNumListElements, byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte string[1202];
  byte IndexSize, shift, direction; 
  int startposition, endposition;
  byte sequenceNumber = 0;
  byte transmit_pos;

  int i, k , strctr; 
  int stringsize;

  Data_InfoSettings_LicenseInformation[0] = ASG_ID*16 + (TAID & 0xF);
  Data_InfoSettings_LicenseInformation[1] =  TotalNumListElements & 0xFF;
  Data_InfoSettings_LicenseInformation[2] = (TotalNumListElements >> 8) & 0xFF;
  Data_InfoSettings_LicenseInformation[3] = (mode|0x4)*16 + recordaddress;
    
  IndexSize    = (mode>>3) & 0x1;
  transmit_pos = (mode>>2) & 0x1;
  direction    = (mode>>1) & 0x1;
  shift        =  mode     & 0x1;
  
  switch(direction)
  {
    case 0:
      
      if (list_start == 0)
      {
        startposition =  shift; 
        endposition = startposition - 1 + elements;
      }
      else if (list_start > 0)
      {
        startposition = list_start + shift - 1;
        endposition = startposition+ elements - 1;
      }
      
      if (endposition >= InfoSettings_LicenseInformation_TotalListNum)
      {
        elements = InfoSettings_LicenseInformation_TotalListNum - startposition;
        endposition = InfoSettings_LicenseInformation_TotalListNum - 1;
      }

      if (startposition >= InfoSettings_LicenseInformation_TotalListNum)
      {
        elements=0;
      }
  
    break;
   
    case 1:
      
      if (list_start > 0)
      {
        startposition = list_start - shift - 1; 
        endposition = startposition - elements + 1; 
      }
      else if ((list_start == 0) && (shift == 1))
      {
        startposition = InfoSettings_LicenseInformation_TotalListNum -1;
        endposition = startposition - elements + 1;
      }
          
      if (endposition < 0)
      {
        elements = elements + endposition;
        endposition = 0;
      }
      
      if ((startposition >= InfoSettings_LicenseInformation_TotalListNum) || ((list_start == 0) && (shift == 0)))
      {
        elements=0;
      }
                
    break;
  }

  if (IndexSize == 0)
  {
    Data_InfoSettings_LicenseInformation[4] = list_start & 0xFF;
    Data_InfoSettings_LicenseInformation[5] = elements & 0xFF;

    j_InfoSettings_LicenseInformation = 6;
  }
  else
  {
    Data_InfoSettings_LicenseInformation[5] = (list_start >> 8) & 0xFF;
    Data_InfoSettings_LicenseInformation[4] = list_start & 0xFF;
    Data_InfoSettings_LicenseInformation[7] = (elements >> 8) & 0xFF;
    Data_InfoSettings_LicenseInformation[6] = elements & 0xFF;

    j_InfoSettings_LicenseInformation = 8;
  }
   
  switch(direction)
  {
    case 0:
         
      for (i = startposition ; i <= endposition && i >= 0; i++)
      {
        Data_InfoSettings_LicenseInformation[j_InfoSettings_LicenseInformation++] = InfoSettings_LicenseInformation[i].param1; // Pos
          
        if (recordaddress == 0x1) // LicenseText
        {  
          Data_InfoSettings_LicenseInformation[j_InfoSettings_LicenseInformation++] = InfoSettings_LicenseInformation[i].param2_Length;
          stringsize = InfoSettings_LicenseInformation[i].param2_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_InfoSettings_LicenseInformation[j_InfoSettings_LicenseInformation++] = InfoSettings_LicenseInformation[i].param2[strctr];
          } 
        }
      }

    break;
            
    case 1:
      
     for (i = startposition ; i >= endposition && i >= 0; i--)
     {
       Data_InfoSettings_LicenseInformation[j_InfoSettings_LicenseInformation++] = InfoSettings_LicenseInformation[i].param1; // Pos
      
       if (recordaddress == 0x1) // LicenseText
        {  
          Data_InfoSettings_LicenseInformation[j_InfoSettings_LicenseInformation++] = InfoSettings_LicenseInformation[i].param2_Length;
          stringsize = InfoSettings_LicenseInformation[i].param2_Length;
          
          for (strctr = 0; strctr < stringsize; strctr++)
          {
            Data_InfoSettings_LicenseInformation[j_InfoSettings_LicenseInformation++] = InfoSettings_LicenseInformation[i].param2[strctr];
          } 
        }
     }
   break;
 }
 settimer (Delay_InfoSettings_LicenseInformation, @Env_InfoSettings_LicenseInformation_ListDelay);
}

InfoSettings_LicenseInformation_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;

  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
    data[1] = list_start;
    data[2] = elements;
    length = 3;
  }
  else if (IndexSize == 1)
  {
    data[1] = list_start & 0xFF;
    data[2] = (list_start >> 8) & 0xFF;
    data[3] = elements & 0xFF;
    data[4] = (elements >> 8) & 0xFF;
    length = 5;
  }
  SendRequestByteSequence(LSGID_InfoSettings, 0x18, Changed_REQ, length, data);
}

on timer Delay_InfoSettings_LicenseInformation
{ 
  sendRequestByteSequence(LSGID_InfoSettings, 0x18, Data_REQ, j_InfoSettings_LicenseInformation, Data_InfoSettings_LicenseInformation);
}





// InfoSettings 0x1B UpdateCommands

InfoSettings_UpdateCommands (byte opcode, byte data[])
{
  byte ASG_ID;
  byte CommandType;
  byte send_data[2];
    
  if ((opcode == 2) && (InfoSettings_Source == 1)) // ASG StartResult
  {
    // StartResult auswerten
    ASG_ID      = (data[0]>>4) & 0x0F;
    CommandType =  data[0]     & 0x0F;
    @M_FSG_80_0_0_27_Processing_1 = ASG_ID;
    @M_FSG_80_0_0_27_Processing_2 = CommandType;
  }
  
  if ((opcode == 3) && (InfoSettings_Source == 2) && (@Env_BAP_Pro_Res == 1)) // FSG Processing
  {
    // Result schicken
    send_data[0] = ASG_ID*16 + CommandType;
    send_data[1] = @M_FSG_80_0_0_27_Result_3;
    sendRequestByteSequence(LSGID_InfoSettings, 0x1B, Result_REQ, 2, send_data);
  }
} 






//////////// Display Config Panel ////////////

on envVar Env_DisCon_Start // DisplayConfig + UnitMaster + DoorLocking
{
  @ON_OFF_ASG69_0 = @this;
  @ON_OFF_ASG19_1 = @this;
  @ON_OFF_FSG13_0 = @this;
  
  if (@this == 1)
    settimer (set, 100);
  
  else
  {
    DeleteControlContent("Display_Config", "Display1_fcts");
    DeleteControlContent("Display_Config", "Display2_fcts");
    DeleteControlContent("Display_Config", "Display3_fcts");
  }
}
    
on timer set
{
  @C_ASG_69_0_0_1GetAll_BTN = 1;
  @P_ASG_69_0_0_3Get_BTN    = 1;
  @P_ASG_69_0_0_19Get_BTN   = 1;
  @P_ASG_69_0_0_21Get_BTN   = 1;
  @P_ASG_69_0_0_23Get_BTN   = 1;
  
  @C_ASG_19_1_0_1GetAll_BTN = 1;
  
  settimer (reset, 100);
  setTimer (check_display_fcts, 2000);
}

on timer reset
{
  @C_ASG_69_0_0_1GetAll_BTN = 0;
  @P_ASG_69_0_0_3Get_BTN    = 0;
  @P_ASG_69_0_0_19Get_BTN   = 0;
  @P_ASG_69_0_0_21Get_BTN   = 0;
  @P_ASG_69_0_0_23Get_BTN   = 0;
  
  @C_ASG_19_1_0_1GetAll_BTN = 0;
}

on envVar Env_DisCon_Skin
{
  check_DisCon_Panel();
}
  
check_DisCon_Panel()
{
  if ( (@Env_DisCon_Skin == 0) || (@Env_DisCon_Skin == 2) || (@Env_DisCon_Skin == 3) || (@Env_DisCon_Skin == 4) )
  {
    setControlVisibility("Display_Config","Nebenanzeige",1);
    setControlVisibility("Display_Config","linkes_Rundelement",1);
    setControlVisibility("Display_Config","Nebenanzeige_Sport",0);
    @Env_DisCon_ElementContentSelection_NebenanzeigeSport = 0;
  }
  if ( (@Env_DisCon_Skin == 1) || (@Env_DisCon_Skin == 5) || (@Env_DisCon_Skin == 6) )
  {
    setControlVisibility("Display_Config","Nebenanzeige",1);
    setControlVisibility("Display_Config","linkes_Rundelement",1);
    setControlVisibility("Display_Config","Nebenanzeige_Sport",1);
    @Env_DisCon_ElementContentSelection_NebenanzeigeSport = 1;
  }
}

on envVar Env_DisCon_ElementContentSelection_SetGet
{
  if (@this == 1)
  {
    ////// Listenparameter setzen
    
    // ASG_ID: HeadUnit
    @A_ASG_69_0_0_18_1_SetGet = 1;
    
    // TAID
    @A_ASG_69_0_0_18_2_SetGet = DisCon_TAID++;
    
    if (DisCon_TAID > 15)
      DisCon_TAID = 1; // TAID ruecksetzen
    
    // TransPos
    @A_ASG_69_0_0_18_SetGet_TransPos = 0;
    
    // Record Adresse
    @A_ASG_69_0_0_18_SetGet_RecAdr = 2;
    
    // Elemente
    if ( (@Env_DisCon_Skin == 0) || (@Env_DisCon_Skin == 2) || (@Env_DisCon_Skin == 3) || (@Env_DisCon_Skin == 4) )
      @A_ASG_69_0_0_18_SetGet_Elements = @Env_DisCon_ElementContentSelection_Nebenanzeige + @Env_DisCon_ElementContentSelection_linkesRundelement;
    if ( (@Env_DisCon_Skin == 1) || (@Env_DisCon_Skin == 5) || (@Env_DisCon_Skin == 6) )
      @A_ASG_69_0_0_18_SetGet_Elements = @Env_DisCon_ElementContentSelection_Nebenanzeige + @Env_DisCon_ElementContentSelection_linkesRundelement + @Env_DisCon_ElementContentSelection_NebenanzeigeSport;
    
    // Start
    if ( (@Env_DisCon_Skin == 0) || (@Env_DisCon_Skin == 3) || (@Env_DisCon_Skin == 4) )
    {
      if (@Env_DisCon_ElementContentSelection_Nebenanzeige == 1)
        @A_ASG_69_0_0_18_SetGet_Start = 0;
      else if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1)
        @A_ASG_69_0_0_18_SetGet_Start = 1;
    }
    if ( (@Env_DisCon_Skin == 1) || (@Env_DisCon_Skin == 5) || (@Env_DisCon_Skin == 6) )
    {
      if (@Env_DisCon_ElementContentSelection_Nebenanzeige == 1)
        @A_ASG_69_0_0_18_SetGet_Start = 0;//2; -> nur MEB
      else if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1)
        @A_ASG_69_0_0_18_SetGet_Start = 1;//3; -> nur MEB
      else if (@Env_DisCon_ElementContentSelection_NebenanzeigeSport == 1)
        @A_ASG_69_0_0_18_SetGet_Start = 2;//4; -> nur MEB
    }
    if ( @Env_DisCon_Skin == 2 )
    {
      if (@Env_DisCon_ElementContentSelection_Nebenanzeige == 1)
        @A_ASG_69_0_0_18_SetGet_Start = 0;//5; -> nur MEB
      else if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1)
        @A_ASG_69_0_0_18_SetGet_Start = 1;//6; -> nur MEB
    }
    
    // locks fuer Data ruecksetzen
    ElementContentSelection_lock1_1 = 0;
    ElementContentSelection_lock2_1 = 0;
    ElementContentSelection_lock3_1 = 0;
    ElementContentSelection_lock1_2 = 0;
    ElementContentSelection_lock2_2 = 0;
    ElementContentSelection_lock3_2 = 0;
    
    // ElementContent (muss leider ueber timer geloest werden, da setzen ohne Verzoegerung nicht funktioniert)
    settimer (ElementContent01_SetGet, ElementContent_timer_delay);
  }
}

on timer ElementContent01_SetGet
{
  if ( (@Env_DisCon_Skin == 0) || (@Env_DisCon_Skin == 3) || (@Env_DisCon_Skin == 4) )
  {
    if (@Env_DisCon_ElementContentSelection_Nebenanzeige == 1 && ElementContentSelection_lock1_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 0;
      ElementContentSelection_lock1_1 = 1;
    }
    else if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1 && ElementContentSelection_lock2_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 1;
      ElementContentSelection_lock2_1 = 1;
    }
  }

  if ( (@Env_DisCon_Skin == 1) || (@Env_DisCon_Skin == 5) || (@Env_DisCon_Skin == 6) )
  {
    if (@Env_DisCon_ElementContentSelection_Nebenanzeige == 1 && ElementContentSelection_lock1_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 0;//2;
      ElementContentSelection_lock1_1 = 1;
    }
    else if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1 && ElementContentSelection_lock2_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 1;//3;
      ElementContentSelection_lock2_1 = 1;
    }
    else if (@Env_DisCon_ElementContentSelection_NebenanzeigeSport == 1 && ElementContentSelection_lock3_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 2;//4;
      ElementContentSelection_lock3_1 = 1;
    }
  }
    
  if ( @Env_DisCon_Skin == 2 )
  {
    if (@Env_DisCon_ElementContentSelection_Nebenanzeige == 1 && ElementContentSelection_lock1_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 0;//5;
      ElementContentSelection_lock1_1 = 1;
    }
    else if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1 && ElementContentSelection_lock2_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 1;//6;
      ElementContentSelection_lock1_2 = 1;
    }
  }

  settimer (ElementContent02_SetGet, ElementContent_timer_delay);
}

on timer ElementContent02_SetGet
{
  if (@Env_DisCon_ElementContentSelection_Nebenanzeige == 1 && ElementContentSelection_lock1_2 == 0)
  {
    @A_ASG_69_0_0_18_Data_5_SetGet = @Env_DisCon_ElementContent1;
    ElementContentSelection_lock1_2 = 1;
  }
  else if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1 && ElementContentSelection_lock2_2 == 0)
  {
    @A_ASG_69_0_0_18_Data_5_SetGet = @Env_DisCon_ElementContent2;
    ElementContentSelection_lock2_2 = 1;
  }
  else if (@Env_DisCon_ElementContentSelection_NebenanzeigeSport == 1 && ElementContentSelection_lock3_2 == 0)
  {
    @A_ASG_69_0_0_18_Data_5_SetGet = @Env_DisCon_ElementContent3;
    ElementContentSelection_lock3_2 = 1;
  }

  settimer (ElementContent03_SetGet, ElementContent_timer_delay);
}

on timer ElementContent03_SetGet
{
  if ( (@Env_DisCon_Skin == 0) || (@Env_DisCon_Skin == 3) || (@Env_DisCon_Skin == 4) )
  {
    if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1 && ElementContentSelection_lock2_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 1;
      ElementContentSelection_lock2_1 = 1;
    }
  }

  if ( (@Env_DisCon_Skin == 1) || (@Env_DisCon_Skin == 5) || (@Env_DisCon_Skin == 6) )
  {
    if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1 && ElementContentSelection_lock2_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 1;//3;
      ElementContentSelection_lock2_1 = 1;
    }
    else if (@Env_DisCon_ElementContentSelection_NebenanzeigeSport == 1 && ElementContentSelection_lock3_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 2;//4;
      ElementContentSelection_lock3_1 = 1;
    }
  }
    
  if ( @Env_DisCon_Skin == 2 )
  {
    if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1 && ElementContentSelection_lock2_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 1;//6;
      ElementContentSelection_lock1_2 = 1;
    }
  }

  settimer (ElementContent04_SetGet, ElementContent_timer_delay);
}

on timer ElementContent04_SetGet
{
  if (@Env_DisCon_ElementContentSelection_linkesRundelement == 1 && ElementContentSelection_lock2_2 == 0)
  {
    @A_ASG_69_0_0_18_Data_5_SetGet = @Env_DisCon_ElementContent2;
    ElementContentSelection_lock2_2 = 1;
  }
  else if (@Env_DisCon_ElementContentSelection_NebenanzeigeSport == 1 && ElementContentSelection_lock3_2 == 0)
  {
    @A_ASG_69_0_0_18_Data_5_SetGet = @Env_DisCon_ElementContent3;
    ElementContentSelection_lock3_2 = 1;
  }

  settimer (ElementContent05_SetGet, 100);
}

on timer ElementContent05_SetGet
{

  if ( (@Env_DisCon_Skin == 1) || (@Env_DisCon_Skin == 5) || (@Env_DisCon_Skin == 6) )
  {
    if (@Env_DisCon_ElementContentSelection_NebenanzeigeSport == 1 && ElementContentSelection_lock3_1 == 0)
    {
      @A_ASG_69_0_0_18_DataIndex_SetGet = 2;//4;
      ElementContentSelection_lock3_1 = 1;
    }
  }

  settimer (ElementContent06_SetGet, ElementContent_timer_delay);
}

on timer ElementContent06_SetGet
{
  if (@Env_DisCon_ElementContentSelection_NebenanzeigeSport == 1 && ElementContentSelection_lock3_2 == 0)
  {
    @A_ASG_69_0_0_18_Data_5_SetGet = @Env_DisCon_ElementContent3;
    ElementContentSelection_lock3_2 = 1;
  }

  settimer (ElementContent07_SetGet, ElementContent_timer_delay);
}

on timer ElementContent07_SetGet
{
  // Button druecken
  @A_ASG_69_0_0_18SetGet_BTN = 1;
  
  settimer (reset2, 500);
}

on envVar Env_DisCon_Skin_SetGet
{
  if (@this == 1)
  {
    @P_ASG_19_1_0_26_1 = @Env_DisCon_Skin;
    @P_ASG_19_1_0_26SetGet_BTN = 1;

    settimer (reset2, 500);
  }
}

on timer reset2
{
  @A_ASG_69_0_0_18SetGet_BTN = 0;
  @P_ASG_19_1_0_26SetGet_BTN = 0;
}

on message BAP_Einheiten_FSG_01
{
  //UnitMaster.Skin
  if ((this.byte(0) == 0x44) & (this.byte(1) == 0xDA))
  {
    @P_ASG_19_1_0_26_1 = this.byte(2);
    @Env_DisCon_Skin = this.byte(2);
  }
}

on timer check_display_fcts
{
  DeleteControlContent("Display_Config", "Display1_fcts");
  DeleteControlContent("Display_Config", "Display2_fcts");
  DeleteControlContent("Display_Config", "Display3_fcts");

  if (@P_ASG_69_0_0_19_3_0  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x00 blank line \n");
  if (@P_ASG_69_0_0_19_3_1  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x01 boost pressure \n");
  if (@P_ASG_69_0_0_19_3_2  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x02 oil pressure \n");
  if (@P_ASG_69_0_0_19_3_3  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x03 oil temperature \n");
  if (@P_ASG_69_0_0_19_3_4  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x04 coolant temperature \n");
  if (@P_ASG_69_0_0_19_3_5  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x05 fuel range \n");
  if (@P_ASG_69_0_0_19_3_6  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x06 destination arrival time \n");
  if (@P_ASG_69_0_0_19_3_7  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x07 intermediate arrival time \n");
  if (@P_ASG_69_0_0_19_3_8  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x08 destination trip time \n");
  if (@P_ASG_69_0_0_19_3_9  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x09 intermediate trip time \n");
  if (@P_ASG_69_0_0_19_3_10 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x0A compass \n");
  if (@P_ASG_69_0_0_19_3_11 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x0B GPS height \n");
  if (@P_ASG_69_0_0_19_3_12 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x0C time \n");
  if (@P_ASG_69_0_0_19_3_13 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x0D date \n");
  if (@P_ASG_69_0_0_19_3_14 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x0E hybrid battery \n");
  if (@P_ASG_69_0_0_19_3_15 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x0F station / track \n");
  if (@P_ASG_69_0_0_19_3_16 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x10 phone info \n");
  if (@P_ASG_69_0_0_19_3_17 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x11 lateral acceleration \n");
  if (@P_ASG_69_0_0_19_3_18 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x12 acceleration \n");
  if (@P_ASG_69_0_0_19_3_19 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x13 deceleration \n");
  if (@P_ASG_69_0_0_19_3_20 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x14 electric range \n");
  if (@P_ASG_69_0_0_19_3_21 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x15 battery state of charge \n");
  if (@P_ASG_69_0_0_19_3_22 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x16 charging time left \n");
  if (@P_ASG_69_0_0_19_3_23 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x17 battery temperature \n");
  if (@P_ASG_69_0_0_19_3_24 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x18 battery level & range \n");
  if (@P_ASG_69_0_0_19_3_25 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x19 coolant \n");
  if (@P_ASG_69_0_0_19_3_26 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x1A boost level & value \n");
  if (@P_ASG_69_0_0_19_3_27 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x1B battery & coolant \n");
  if (@P_ASG_69_0_0_19_3_28 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x1C battery & boost \n");
  if (@P_ASG_69_0_0_19_3_29 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x1D boost & coolant \n");
  if (@P_ASG_69_0_0_19_3_30 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x1E vehicle voltage \n");
  if (@P_ASG_69_0_0_19_3_31 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x1F average consumption \n");
  if (@P_ASG_69_0_0_19_4_0  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x20 distance \n");
  if (@P_ASG_69_0_0_19_4_1  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x21 driving time \n");
  if (@P_ASG_69_0_0_19_4_2  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x22 current consumption \n");
  if (@P_ASG_69_0_0_19_4_3  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x23 zero emission \n");
  if (@P_ASG_69_0_0_19_4_4  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x24 driving profile \n");
  if (@P_ASG_69_0_0_19_4_5  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x25 secondary speed \n");
  if (@P_ASG_69_0_0_19_4_6  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x26 digital speed \n");
  if (@P_ASG_69_0_0_19_4_7  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x27 energy flow \n");
  if (@P_ASG_69_0_0_19_4_8  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x28 ACC \n");
  if (@P_ASG_69_0_0_19_4_9  == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x29 route guidance \n");
  if (@P_ASG_69_0_0_19_4_10 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x2A traffic sign detection \n");
  if (@P_ASG_69_0_0_19_4_11 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x2B shift up indication \n");
  if (@P_ASG_69_0_0_19_4_12 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x2C performance \n");
  if (@P_ASG_69_0_0_19_4_13 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x2D predictive efficiency assistant \n");
  if (@P_ASG_69_0_0_19_4_14 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x2E wildcard \n");
  if (@P_ASG_69_0_0_19_4_15 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x2F steering angle \n");
  if (@P_ASG_69_0_0_19_4_16 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x30 slope \n");
  if (@P_ASG_69_0_0_19_4_17 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x31 consumption data \n");
  if (@P_ASG_69_0_0_19_4_18 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x32 combustor consumption \n");
  if (@P_ASG_69_0_0_19_4_19 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x33 electrical consumption \n");
  if (@P_ASG_69_0_0_19_4_20 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x34 average speed \n");
  if (@P_ASG_69_0_0_19_4_21 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x35 powermeter \n");
  if (@P_ASG_69_0_0_19_4_22 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x36 tachometer \n");
  if (@P_ASG_69_0_0_19_4_23 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x37 powermeter and tachometer \n");
  if (@P_ASG_69_0_0_19_4_24 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x38 hybrid \n");
  if (@P_ASG_69_0_0_19_4_25 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x39 engine data \n");
  if (@P_ASG_69_0_0_19_4_26 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x3A short term data \n");
  if (@P_ASG_69_0_0_19_4_27 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x3B long term data \n");
  if (@P_ASG_69_0_0_19_4_28 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x3C g-meter \n");
  if (@P_ASG_69_0_0_19_4_29 == 1)  putValueToControl("Display_Config", "Display1_fcts", "0x3D tyre pressure monitor \n");
  
  if (@P_ASG_69_0_0_21_3_0  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x00 blank line \n");
  if (@P_ASG_69_0_0_21_3_1  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x01 boost pressure \n");
  if (@P_ASG_69_0_0_21_3_2  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x02 oil pressure \n");
  if (@P_ASG_69_0_0_21_3_3  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x03 oil temperature \n");
  if (@P_ASG_69_0_0_21_3_4  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x04 coolant temperature \n");
  if (@P_ASG_69_0_0_21_3_5  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x05 fuel range \n");
  if (@P_ASG_69_0_0_21_3_6  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x06 destination arrival time \n");
  if (@P_ASG_69_0_0_21_3_7  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x07 intermediate arrival time \n");
  if (@P_ASG_69_0_0_21_3_8  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x08 destination trip time \n");
  if (@P_ASG_69_0_0_21_3_9  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x09 intermediate trip time \n");
  if (@P_ASG_69_0_0_21_3_10 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x0A compass \n");
  if (@P_ASG_69_0_0_21_3_11 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x0B GPS height \n");
  if (@P_ASG_69_0_0_21_3_12 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x0C time \n");
  if (@P_ASG_69_0_0_21_3_13 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x0D date \n");
  if (@P_ASG_69_0_0_21_3_14 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x0E hybrid battery \n");
  if (@P_ASG_69_0_0_21_3_15 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x0F station / track \n");
  if (@P_ASG_69_0_0_21_3_16 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x10 phone info \n");
  if (@P_ASG_69_0_0_21_3_17 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x11 lateral acceleration \n");
  if (@P_ASG_69_0_0_21_3_18 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x12 acceleration \n");
  if (@P_ASG_69_0_0_21_3_19 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x13 deceleration \n");
  if (@P_ASG_69_0_0_21_3_20 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x14 electric range \n");
  if (@P_ASG_69_0_0_21_3_21 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x15 battery state of charge \n");
  if (@P_ASG_69_0_0_21_3_22 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x16 charging time left \n");
  if (@P_ASG_69_0_0_21_3_23 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x17 battery temperature \n");
  if (@P_ASG_69_0_0_21_3_24 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x18 battery level & range \n");
  if (@P_ASG_69_0_0_21_3_25 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x19 coolant \n");
  if (@P_ASG_69_0_0_21_3_26 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x1A boost level & value \n");
  if (@P_ASG_69_0_0_21_3_27 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x1B battery & coolant \n");
  if (@P_ASG_69_0_0_21_3_28 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x1C battery & boost \n");
  if (@P_ASG_69_0_0_21_3_29 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x1D boost & coolant \n");
  if (@P_ASG_69_0_0_21_3_30 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x1E vehicle voltage \n");
  if (@P_ASG_69_0_0_21_3_31 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x1F average consumption \n");
  if (@P_ASG_69_0_0_21_4_0  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x20 distance \n");
  if (@P_ASG_69_0_0_21_4_1  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x21 driving time \n");
  if (@P_ASG_69_0_0_21_4_2  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x22 current consumption \n");
  if (@P_ASG_69_0_0_21_4_3  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x23 zero emission \n");
  if (@P_ASG_69_0_0_21_4_4  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x24 driving profile \n");
  if (@P_ASG_69_0_0_21_4_5  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x25 secondary speed \n");
  if (@P_ASG_69_0_0_21_4_6  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x26 digital speed \n");
  if (@P_ASG_69_0_0_21_4_7  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x27 energy flow \n");
  if (@P_ASG_69_0_0_21_4_8  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x28 ACC \n");
  if (@P_ASG_69_0_0_21_4_9  == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x29 route guidance \n");
  if (@P_ASG_69_0_0_21_4_10 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x2A traffic sign detection \n");
  if (@P_ASG_69_0_0_21_4_11 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x2B shift up indication \n");
  if (@P_ASG_69_0_0_21_4_12 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x2C performance \n");
  if (@P_ASG_69_0_0_21_4_13 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x2D predictive efficiency assistant \n");
  if (@P_ASG_69_0_0_21_4_14 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x2E wildcard \n");
  if (@P_ASG_69_0_0_21_4_15 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x2F steering angle \n");
  if (@P_ASG_69_0_0_21_4_16 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x30 slope \n");
  if (@P_ASG_69_0_0_21_4_17 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x31 consumption data \n");
  if (@P_ASG_69_0_0_21_4_18 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x32 combustor consumption \n");
  if (@P_ASG_69_0_0_21_4_19 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x33 electrical consumption \n");
  if (@P_ASG_69_0_0_21_4_20 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x34 average speed \n");
  if (@P_ASG_69_0_0_21_4_21 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x35 powermeter \n");
  if (@P_ASG_69_0_0_21_4_22 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x36 tachometer \n");
  if (@P_ASG_69_0_0_21_4_23 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x37 powermeter and tachometer \n");
  if (@P_ASG_69_0_0_21_4_24 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x38 hybrid \n");
  if (@P_ASG_69_0_0_21_4_25 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x39 engine data \n");
  if (@P_ASG_69_0_0_21_4_26 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x3A short term data \n");
  if (@P_ASG_69_0_0_21_4_27 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x3B long term data \n");
  if (@P_ASG_69_0_0_21_4_28 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x3C g-meter \n");
  if (@P_ASG_69_0_0_21_4_29 == 1)  putValueToControl("Display_Config", "Display2_fcts", "0x3D tyre pressure monitor \n");
  
  if (@P_ASG_69_0_0_23_3_0  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x00 blank line \n");
  if (@P_ASG_69_0_0_23_3_1  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x01 boost pressure \n");
  if (@P_ASG_69_0_0_23_3_2  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x02 oil pressure \n");
  if (@P_ASG_69_0_0_23_3_3  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x03 oil temperature \n");
  if (@P_ASG_69_0_0_23_3_4  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x04 coolant temperature \n");
  if (@P_ASG_69_0_0_23_3_5  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x05 fuel range \n");
  if (@P_ASG_69_0_0_23_3_6  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x06 destination arrival time \n");
  if (@P_ASG_69_0_0_23_3_7  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x07 intermediate arrival time \n");
  if (@P_ASG_69_0_0_23_3_8  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x08 destination trip time \n");
  if (@P_ASG_69_0_0_23_3_9  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x09 intermediate trip time \n");
  if (@P_ASG_69_0_0_23_3_10 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x0A compass \n");
  if (@P_ASG_69_0_0_23_3_11 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x0B GPS height \n");
  if (@P_ASG_69_0_0_23_3_12 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x0C time \n");
  if (@P_ASG_69_0_0_23_3_13 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x0D date \n");
  if (@P_ASG_69_0_0_23_3_14 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x0E hybrid battery \n");
  if (@P_ASG_69_0_0_23_3_15 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x0F station / track \n");
  if (@P_ASG_69_0_0_23_3_16 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x10 phone info \n");
  if (@P_ASG_69_0_0_23_3_17 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x11 lateral acceleration \n");
  if (@P_ASG_69_0_0_23_3_18 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x12 acceleration \n");
  if (@P_ASG_69_0_0_23_3_19 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x13 deceleration \n");
  if (@P_ASG_69_0_0_23_3_20 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x14 electric range \n");
  if (@P_ASG_69_0_0_23_3_21 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x15 battery state of charge \n");
  if (@P_ASG_69_0_0_23_3_22 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x16 charging time left \n");
  if (@P_ASG_69_0_0_23_3_23 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x17 battery temperature \n");
  if (@P_ASG_69_0_0_23_3_24 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x18 battery level & range \n");
  if (@P_ASG_69_0_0_23_3_25 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x19 coolant \n");
  if (@P_ASG_69_0_0_23_3_26 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x1A boost level & value \n");
  if (@P_ASG_69_0_0_23_3_27 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x1B battery & coolant \n");
  if (@P_ASG_69_0_0_23_3_28 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x1C battery & boost \n");
  if (@P_ASG_69_0_0_23_3_29 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x1D boost & coolant \n");
  if (@P_ASG_69_0_0_23_3_30 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x1E vehicle voltage \n");
  if (@P_ASG_69_0_0_23_3_31 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x1F average consumption \n");
  if (@P_ASG_69_0_0_23_4_0  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x20 distance \n");
  if (@P_ASG_69_0_0_23_4_1  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x21 driving time \n");
  if (@P_ASG_69_0_0_23_4_2  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x22 current consumption \n");
  if (@P_ASG_69_0_0_23_4_3  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x23 zero emission \n");
  if (@P_ASG_69_0_0_23_4_4  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x24 driving profile \n");
  if (@P_ASG_69_0_0_23_4_5  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x25 secondary speed \n");
  if (@P_ASG_69_0_0_23_4_6  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x26 digital speed \n");
  if (@P_ASG_69_0_0_23_4_7  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x27 energy flow \n");
  if (@P_ASG_69_0_0_23_4_8  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x28 ACC \n");
  if (@P_ASG_69_0_0_23_4_9  == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x29 route guidance \n");
  if (@P_ASG_69_0_0_23_4_10 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x2A traffic sign detection \n");
  if (@P_ASG_69_0_0_23_4_11 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x2B shift up indication \n");
  if (@P_ASG_69_0_0_23_4_12 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x2C performance \n");
  if (@P_ASG_69_0_0_23_4_13 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x2D predictive efficiency assistant \n");
  if (@P_ASG_69_0_0_23_4_14 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x2E wildcard \n");
  if (@P_ASG_69_0_0_23_4_15 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x2F steering angle \n");
  if (@P_ASG_69_0_0_23_4_16 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x30 slope \n");
  if (@P_ASG_69_0_0_23_4_17 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x31 consumption data \n");
  if (@P_ASG_69_0_0_23_4_18 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x32 combustor consumption \n");
  if (@P_ASG_69_0_0_23_4_19 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x33 electrical consumption \n");
  if (@P_ASG_69_0_0_23_4_20 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x34 average speed \n");
  if (@P_ASG_69_0_0_23_4_21 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x35 powermeter \n");
  if (@P_ASG_69_0_0_23_4_22 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x36 tachometer \n");
  if (@P_ASG_69_0_0_23_4_23 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x37 powermeter and tachometer \n");
  if (@P_ASG_69_0_0_23_4_24 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x38 hybrid \n");
  if (@P_ASG_69_0_0_23_4_25 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x39 engine data \n");
  if (@P_ASG_69_0_0_23_4_26 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x3A short term data \n");
  if (@P_ASG_69_0_0_23_4_27 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x3B long term data \n");
  if (@P_ASG_69_0_0_23_4_28 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x3C g-meter \n");
  if (@P_ASG_69_0_0_23_4_29 == 1)  putValueToControl("Display_Config", "Display3_fcts", "0x3D tyre pressure monitor \n");
  
  check_DisCon_Panel();
}

on envVar P_ASG_69_0_0_19
{
  setTimer (check_display_fcts, 0);
}

on envVar P_ASG_69_0_0_21
{
  setTimer (check_display_fcts, 0);
}

on envVar P_ASG_69_0_0_23
{
  setTimer (check_display_fcts, 0);
}


on envVar Env_DisCon_ActiveUser_SetGet
{
  if (@this == 1)
    sendRequest(LSGID_DoorLocking, 0x25, Data_REQ, 1, @Env_DisCon_ActiveUser);
}