/*@!Encoding:1252*/
includes
{
    #include "..\..\..\_DLL\latest_BAP_DLL.cin"
}

variables
{
	char  dbcan_path[255] = "BAP\\_DBC\\BAP_V9.04F.dbc";
	char  xml_path[255]   = "BAP\\PaCo_FSG85\\FSG85\\bapxml\\BAP_SW18_PaCo_P31DF32_V1.20_FSG.xml";

	//@BAPSIMGEN_VAR_SECTION_BEGIN

	/***************************************************/
	/*            BapSimGen FSG template               */
	/***************************************************/

	/************** Ausgabe Konsole (Traces) ***********/
	dword gBAP_Trace;
	dword gError_Trace;

	/************** Node Verwaltung ***************/
	//Power on/off
	byte gSG_PowerOnOff=0x01;     // wird mit Power_off/on gesetzt
	byte gBAP_Init=0;             // schon mal initialisiert?

	const Power_off = 0x00;	
	const Power_on	= 0x01;

	mstimer TaskTimer;				//real communication timer

	/************** Request **************/
	const Requestbuffer_lines = 18;
	const dword BAP_buffer_size = 122;

	/************ Speichern von Requests im "Ringbuffer" ***********/
	int   gBAP_Requestbuffer_status	[Requestbuffer_lines];		             // 0: kein Eintrag, 1: pending
	dword gBAP_Request_header		[Requestbuffer_lines] [6];				 // beinhaltet auch skalare Daten
	dword gBAP_Request_data         [Requestbuffer_lines] [BAP_buffer_size]; // Ringbuffer fuer BAP-Request


	/************** Indication **************/
	// enthaelt die derzeitige Indication
	dword gBAP_Indication_header[6];	
	byte  gBAP_Indication_data[BAP_buffer_size];		

	/************** Konstanten ****************/

	//BAP Data Type 
	const Bap_void				=0;
	const Bap_uint8				=1;
	const Bap_uint16			=2;
	const Bap_uint32			=3;
	const Bap_byteSequence		=4;
    const Bap_fixedByteSequence =4;
    const Bap_error				=5;
    const Bap_acknowledge		=6;

	char Datatype_Text[7][20] =
	{
		"void", "uint8", "uint16", "uint32", "byteSequence", "error", "acknowledge"
	};
	
	//BAP request types
	const DataSetGet_REQ	= 0x00;
	const DataSet_REQ		= 0x01;
	const DataGet_REQ		= 0x02;
	const Data_REQ			= 0x03;
	const Changed_REQ		= 0x04;
	const Start_REQ			= 0x05;
	const StartResult_REQ	= 0x06;
	const AbortResult_REQ	= 0x07;
	const Processing_REQ	= 0x08;
	const Result_REQ		= 0x09;
	const DataAck_REQ       = 0x0A;
	const Ack_REQ           = 0x0B;
	const Invalid_REQ    	= 0x1F; // Kennzeichnung fuer einen ungueltigen Request
	const Error_REQ         = 0x20;

	char Requesttype_Text[33][30] =
	{
		"DataSetGet_REQ", "DataSet_REQ", "DataGet_REQ", "Data_REQ",			/* 00 .. 03 */
		"Changed_REQ", "Start_REQ", "StartResult_REQ", "AbortResult_REQ",   /* 04 .. 07 */
		"Processing_REQ", "Result_REQ", "DataAck_REQ", "Ack_REQ", 		/* 08 .. 0b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 0c .. 0f */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 10 .. 13 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 14 .. 17 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", 		/* 18 .. 1b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 1c .. 1f */
		"Error_REQ"	  														/* 20 */
	};
	
	//BAP indication types
	const Data_IND				= 0x00;
	const Reset_IND				= 0x01;
	const DataAck_IND			= 0x02;
	const Result_IND			= 0x03;
	const Processing_IND	    = 0x04;
	const Changed_IND			= 0x05;
	const DataSetGet_IND	    = 0x06;
	const DataSet_IND			= 0x07;
	const DataGet_IND			= 0x08;
	const Ack_IND				= 0x09;
	const Processing_CNF_IND	= 0x0A;
	const Start_IND				= 0x0B;
	const StartResult_IND		= 0x0C;
	const AbortResult_IND		= 0x0D;
	const Invalid_IND			= 0x1F; // Kennzeichnung fuer eine ungueltige Indication
	const Error_IND             = 0x20;

	char Indicationtype_Text[33][30] =
	{
		"Data_IND", "Reset_IND", "DataAck_IND", "Result_IND",				/* 00 .. 03 */
		"Processing_IND", "Changed_IND", "DataSetGet_IND", "DataSet_IND",	/* 04 .. 07 */
		"DataGet_IND", "Ack_IND", "Processing_CNF_IND", "Start_REQ",		/* 08 .. 0b */
		"StartResult_REQ", "AbortResult_REQ", "Invalid_REQ", "Invalid_REQ", /* 0c .. 0f */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 10 .. 13 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 14 .. 17 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 18 .. 1b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 1c .. 1f */
		"Error_REQ"	  														/* 20 */
	};	
	
	char Acknowledgetype_Text[24][30] =
	{
		"Property_SetGet_ACK", "Array_SetGet_ACK", "Property_Set_ACK", "Array_Set_ACK",				/* 00 .. 03 */
		"Method_Start_ACK", "Method_StartResult_ACK", "Method_AbortResult_ACK", "Property_Get_ACK",	/* 04 .. 07 */
		"Array_Get_ACK", "Cache_GetAll_ACK", "Property_Ack_ACK", "Property_Status_ACK",	   			/* 08 .. 0b */
		"Property_StatusAck_ACK", "Property_Error_ACK", "Array_Status_ACK", "Array_Changed_ACK",	/* 0c .. 0f */
		"Array_Error_ACK", "Method_Processing_ACK", "Method_Result_ACK", "Method_Error_ACK",  		/* 10 .. 13 */
		"Unknown_ACK", "Unknown_ACK", "Unknown_ACK", "Unknown_ACK"									/* 14 .. 17 */
	};

	/**************************** Global Function-ID's ******************************/

	byte already_pressed = 0;

	const FctID_GetAll									= 0x01;
	const FctID_BAP_Config								= 0x02;
	const FctID_FunctionList							= 0x03;
	const FctID_HeartBeat								= 0x04;
    
  char SGtype[4]="FSG";
  
  _align(1) struct CommConfigStruct{
    char  Name[100];
    dword Number;
    dword Channel;
    dword Reserved;
  };

  byte isSelectedCAN;
  byte isSelectedEth;
  byte isSelectedFr; 
  
	//// Begin: konfigurationsabhýngige Variablen, die als BAPCONFIG_VARS in Template definiert sind
	
	dword NODE_INDEX                =  0;
	char  NODE_NAME[100]            = "PaCo";
	const LSGID                     = 85;
	char  panel_name[100]           = "FSG85_0";
	char  bapconfig_panel_name[100]    = "panel1";
	char  common_panel_name[100]    = "panel2";
	const TaskTime                  = 10;
	 const C_FSG_85_0_0_1_ID = 1;
	 char gCheckbox1[100] = "checkbox_C_FSG_85_0_0_1";
	 char gErrField1[100] = "errfield_C_FSG_85_0_0_1";
	 byte gC_FSG_85_0_0_1_ErrCode = 1;
	 const P_FSG_85_0_0_2_ID = 2;
	 byte P_FSG_85_0_0_2Reset_BTN_already_pressed = 0;
	 char gCheckbox2[100] = "checkbox_P_FSG_85_0_0_2";
	 char gErrField2[100] = "errfield_P_FSG_85_0_0_2";
	 byte gP_FSG_85_0_0_2_ErrCode = 1;
	 const P_FSG_85_0_0_3_ID = 3;
	 byte P_FSG_85_0_0_3Status_BTN_already_pressed = 0;
	 char gCheckbox3[100] = "checkbox_P_FSG_85_0_0_3";
	 char gErrField3[100] = "errfield_P_FSG_85_0_0_3";
	 byte gP_FSG_85_0_0_3_ErrCode = 1;
	 const P_FSG_85_0_0_4_ID = 4;
	 byte P_FSG_85_0_0_4Status_BTN_already_pressed = 0;
	 char gCheckbox4[100] = "checkbox_P_FSG_85_0_0_4";
	 char gErrField4[100] = "errfield_P_FSG_85_0_0_4";
	 byte gP_FSG_85_0_0_4_ErrCode = 1;
	 const P_FSG_85_0_0_13_ID = 13;
	 byte P_FSG_85_0_0_13Status_BTN_already_pressed = 0;
	 char gCheckbox13[100] = "checkbox_P_FSG_85_0_0_13";
	 char gErrField13[100] = "errfield_P_FSG_85_0_0_13";
	 byte gP_FSG_85_0_0_13_ErrCode = 1;
	 char gPanel13[100] = "panel_P_FSG_85_0_0_13";
	 const P_FSG_85_0_0_14_ID = 14;
	 byte P_FSG_85_0_0_14Status_BTN_already_pressed = 0;
	 char gCheckbox14[100] = "checkbox_P_FSG_85_0_0_14";
	 char gErrField14[100] = "errfield_P_FSG_85_0_0_14";
	 byte gP_FSG_85_0_0_14_ErrCode = 1;
	 char gPanel14[100] = "panel_P_FSG_85_0_0_14";
	 const P_FSG_85_0_0_15_ID = 15;
	 byte P_FSG_85_0_0_15Status_BTN_already_pressed = 0;
	 char gCheckbox15[100] = "checkbox_P_FSG_85_0_0_15";
	 char gErrField15[100] = "errfield_P_FSG_85_0_0_15";
	 byte gP_FSG_85_0_0_15_ErrCode = 1;
	 char gPanel15[100] = "panel_P_FSG_85_0_0_15";
	 const P_FSG_85_0_0_16_ID = 16;
	 byte P_FSG_85_0_0_16Status_BTN_already_pressed = 0;
	 char gCheckbox16[100] = "checkbox_P_FSG_85_0_0_16";
	 char gErrField16[100] = "errfield_P_FSG_85_0_0_16";
	 byte gP_FSG_85_0_0_16_ErrCode = 1;
	 char gPanel16[100] = "panel_P_FSG_85_0_0_16";
	 const P_FSG_85_0_0_17_ID = 17;
	 byte P_FSG_85_0_0_17Status_BTN_already_pressed = 0;
	 char gCheckbox17[100] = "checkbox_P_FSG_85_0_0_17";
	 char gErrField17[100] = "errfield_P_FSG_85_0_0_17";
	 byte gP_FSG_85_0_0_17_ErrCode = 1;
	 char gPanel17[100] = "panel_P_FSG_85_0_0_17";
	 const P_FSG_85_0_0_18_ID = 18;
	 byte P_FSG_85_0_0_18Status_BTN_already_pressed = 0;
	 char gCheckbox18[100] = "checkbox_P_FSG_85_0_0_18";
	 char gErrField18[100] = "errfield_P_FSG_85_0_0_18";
	 byte gP_FSG_85_0_0_18_ErrCode = 1;
	 char gPanel18[100] = "panel_P_FSG_85_0_0_18";
	 const P_FSG_85_0_0_19_ID = 19;
	 byte P_FSG_85_0_0_19Status_BTN_already_pressed = 0;
	 char gCheckbox19[100] = "checkbox_P_FSG_85_0_0_19";
	 char gErrField19[100] = "errfield_P_FSG_85_0_0_19";
	 byte gP_FSG_85_0_0_19_ErrCode = 1;
	 char gPanel19[100] = "panel_P_FSG_85_0_0_19";
	 const P_FSG_85_0_0_20_ID = 20;
	 byte P_FSG_85_0_0_20Status_BTN_already_pressed = 0;
	 char gCheckbox20[100] = "checkbox_P_FSG_85_0_0_20";
	 char gErrField20[100] = "errfield_P_FSG_85_0_0_20";
	 byte gP_FSG_85_0_0_20_ErrCode = 1;
	 char gPanel20[100] = "panel_P_FSG_85_0_0_20";
	 const P_FSG_85_0_0_21_ID = 21;
	 char gCheckbox21[100] = "checkbox_P_FSG_85_0_0_21";
	 char gErrField21[100] = "errfield_P_FSG_85_0_0_21";
	 byte gP_FSG_85_0_0_21_ErrCode = 1;
	 char gPanel21[100] = "panel_P_FSG_85_0_0_21";
	 const P_FSG_85_0_0_22_ID = 22;
	 char gCheckbox22[100] = "checkbox_P_FSG_85_0_0_22";
	 char gErrField22[100] = "errfield_P_FSG_85_0_0_22";
	 byte gP_FSG_85_0_0_22_ErrCode = 1;
	 char gPanel22[100] = "panel_P_FSG_85_0_0_22";
	 const P_FSG_85_0_0_23_ID = 23;
	 byte P_FSG_85_0_0_23Status_BTN_already_pressed = 0;
	 char gCheckbox23[100] = "checkbox_P_FSG_85_0_0_23";
	 char gErrField23[100] = "errfield_P_FSG_85_0_0_23";
	 byte gP_FSG_85_0_0_23_ErrCode = 1;
	 char gPanel23[100] = "panel_P_FSG_85_0_0_23";
	 const P_FSG_85_0_0_24_ID = 24;
	 byte P_FSG_85_0_0_24Status_BTN_already_pressed = 0;
	 byte P_FSG_85_0_0_24StatusAck_BTN_already_pressed = 0;
	 char gCheckbox24[100] = "checkbox_P_FSG_85_0_0_24";
	 char gErrField24[100] = "errfield_P_FSG_85_0_0_24";
	 byte gP_FSG_85_0_0_24_ErrCode = 1;
	 char gPanel24[100] = "panel_P_FSG_85_0_0_24";
	 const P_FSG_85_0_0_25_ID = 25;
	 byte P_FSG_85_0_0_25Status_BTN_already_pressed = 0;
	 char gCheckbox25[100] = "checkbox_P_FSG_85_0_0_25";
	 char gErrField25[100] = "errfield_P_FSG_85_0_0_25";
	 byte gP_FSG_85_0_0_25_ErrCode = 1;
	 char gPanel25[100] = "panel_P_FSG_85_0_0_25";
	 const A_FSG_85_0_0_26_ID = 26;
	 byte A_FSG_85_0_0_26Changed_BTN_already_pressed = 0;
	 byte A_FSG_85_0_0_26Status_BTN_already_pressed = 0;
	 char gCheckbox26[100] = "checkbox_A_FSG_85_0_0_26";
	 char gErrField26[100] = "errfield_A_FSG_85_0_0_26";
	 byte gA_FSG_85_0_0_26_ErrCode = 1;
	 char gPanel26[100] = "panel_A_FSG_85_0_0_26";
	 byte A_FSG_85_0_0_26_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_85_0_0_26_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_85_0_0_26_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_85_0_0_26_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_85_0_0_26_generateData_Btn_already_pressed = 0;
	 byte A_FSG_85_0_0_26_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_85_0_0_26_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3;
		 byte Param4;
		 byte Param5;
		 byte Param6;
		 byte Param7;
		 byte Param8;
		 byte Param9;
		 byte Param10;
	 };
	 struct A_FSG_85_0_0_26_ArrayDataStruct A_FSG_85_0_0_26_ArrayDataList[20];
	 const A_FSG_85_0_0_26_ArrayDataList_Length = 20;
	 const A_FSG_85_0_0_27_ID = 27;
	 byte A_FSG_85_0_0_27Changed_BTN_already_pressed = 0;
	 byte A_FSG_85_0_0_27Status_BTN_already_pressed = 0;
	 char gCheckbox27[100] = "checkbox_A_FSG_85_0_0_27";
	 char gErrField27[100] = "errfield_A_FSG_85_0_0_27";
	 byte gA_FSG_85_0_0_27_ErrCode = 1;
	 char gPanel27[100] = "panel_A_FSG_85_0_0_27";
	 byte A_FSG_85_0_0_27_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_85_0_0_27_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_85_0_0_27_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_85_0_0_27_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_85_0_0_27_generateData_Btn_already_pressed = 0;
	 byte A_FSG_85_0_0_27_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_85_0_0_27_ArrayDataStruct {
		 dword Param1;
		 byte Param2;
		 byte Param3;
		 byte Param4[5];
		 dword Param4_Length;
	 };
	 struct A_FSG_85_0_0_27_ArrayDataStruct A_FSG_85_0_0_27_ArrayDataList[5];
	 const A_FSG_85_0_0_27_ArrayDataList_Length = 5;
	 long A_FSG_85_0_0_27_Data_4_LenList[5];
	 byte A_FSG_85_0_0_27_Data_4_CntList[5];
	 long A_FSG_85_0_0_27_Data_4_SetGet_LenList[5];
	 byte A_FSG_85_0_0_27_Data_4_SetGet_CntList[5];
	 const P_FSG_85_0_0_28_ID = 28;
	 byte P_FSG_85_0_0_28Status_BTN_already_pressed = 0;
	 char gCheckbox28[100] = "checkbox_P_FSG_85_0_0_28";
	 char gErrField28[100] = "errfield_P_FSG_85_0_0_28";
	 byte gP_FSG_85_0_0_28_ErrCode = 1;
	 char gPanel28[100] = "panel_P_FSG_85_0_0_28";


	//// End konfigurationsabhýngige Variablen 
	
	/// Begin: Definition der BUS-Schnittstellen
	
// FLEXRAY NOT ENABLED!
	
	// ETHERNET NOT ENABLED! 
	
	//// End Bus Schnittstellen

}

on preStart
{
    char Version[200];
    
    /***** Erzeugen der Ausgabeconsolen *****/  
    gBAP_Trace=writecreate("BAP-Trace");        //write-window for BAP-cummunication
    writeclear(gBAP_Trace);                     //clear BAP-window in write-window
    
    gError_Trace=writecreate("Error");          //error-window for BAP-cummunication
    writeclear(gError_Trace);                   //clear error-window in write-window
    
    writeclear(1);                              //clear CAPL-window in write-window
    
    /**** Versionsstring von DLL holen und auf Bildschirm ausgeben ***/ 
    BAP150_GetVersions(Version, 200);
    writelineEx(gBAP_Trace, 0, "Versionx:%s", Version);
                                            
    NODE_INDEX = BAP150_CreateNode();
    writelineEx(gBAP_Trace, 0, "FSG %d Nodeindex:%d", LSGID, Version);
    
    ReadCommCfgIni();
// FLEXRAY NOT ENABLED!
}

on preStop
{
  WriteCommCfgIni();
}

Split(char bufin[], char delimiter, char bufout1[], char bufout2[])
{
  dword i,j;
  byte found;
  
  i=j=0;
  found = 0;
  while(bufin[i] != '\0')    
  {
    if(found == 0)
    {  
      if(bufin[i] != delimiter)
      {
        bufout1[i] = bufin[i];
      }
      else
      {
        found = 1;
        bufout1[i] = '\0';
      }
    }
    else
    {
      bufout2[j] = bufin[i];
      j++;
    }
    i++;
  }
}

ReadCommCfgIni()
{
  dword fHandle;
  char buff1[10];
  char buff2[10];
  char buff3[10];
  dword i;

  setFilePath ("\\fsg85\\panel", 0);
  fHandle = OpenFileRead ("CommCfg.ini",0);  
  
  if(fHandle !=0)
  {
    i=0;
    while (fileGetString(buff1,elcount(buff1),fHandle)!=0 ) 
    {
      Split(buff1,';',buff2, buff3);
      
      switch(i)
      {
        case 0 :
          putValue(FSG85_0_0_BusType, atol(buff2));
          putValue(FSG85_0_0_Channel, atol(buff3));
          break;
        case 1 :
          putValue(FSG85_0_1_BusType, atol(buff2));
          putValue(FSG85_0_1_Channel, atol(buff3));
          break;
        case 2 :
          putValue(FSG85_0_2_BusType, atol(buff2));
          putValue(FSG85_0_2_Channel, atol(buff3));
          break;
        case 3 :
          putValue(FSG85_0_3_BusType, atol(buff2));
          putValue(FSG85_0_3_Channel, atol(buff3));
          break;
      }
      i++;
    } 
    fileClose (fHandle);    
  }
}

WriteCommCfgIni()
{
  dword fHandle;  
  char buff[10];
  
  setWritePath ("\\fsg85\\panel");
  fHandle = OpenFileWrite ("CommCfg.ini",0); 
  
  if(fHandle !=0)
  {
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG85_0_0_BusType), getValue(FSG85_0_0_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG85_0_1_BusType), getValue(FSG85_0_1_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG85_0_2_BusType), getValue(FSG85_0_2_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG85_0_3_BusType), getValue(FSG85_0_3_Channel));
    filePutString(buff, elCount(buff), fHandle);
    fileClose (fHandle);
  }
}

DisableFctCtrl ()
{
  	EnableControl(panel_name, common_panel_name, 0);
	EnableControl(panel_name,gErrField1,0);
	EnableControl(panel_name,gErrField2,0);
	EnableControl(panel_name,gErrField3,0);
	EnableControl(panel_name,gErrField4,0);
	EnableControl(panel_name,gErrField13,0);
	EnableControl(panel_name,gPanel13,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_13",0);
	EnableControl(panel_name,gErrField14,0);
	EnableControl(panel_name,gPanel14,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_14",0);
	EnableControl(panel_name,gErrField15,0);
	EnableControl(panel_name,gPanel15,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_15",0);
	EnableControl(panel_name,gErrField16,0);
	EnableControl(panel_name,gPanel16,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_16",0);
	EnableControl(panel_name,gErrField17,0);
	EnableControl(panel_name,gPanel17,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_17",0);
	EnableControl(panel_name,gErrField18,0);
	EnableControl(panel_name,gPanel18,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_18",0);
	EnableControl(panel_name,gErrField19,0);
	EnableControl(panel_name,gPanel19,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_19",0);
	EnableControl(panel_name,gErrField20,0);
	EnableControl(panel_name,gPanel20,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_20",0);
	EnableControl(panel_name,gErrField21,0);
	EnableControl(panel_name,gPanel21,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_21",0);
	EnableControl(panel_name,gErrField22,0);
	EnableControl(panel_name,gPanel22,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_22",0);
	EnableControl(panel_name,gErrField23,0);
	EnableControl(panel_name,gPanel23,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_23",0);
	EnableControl(panel_name,gErrField24,0);
	EnableControl(panel_name,gPanel24,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_24",0);
	EnableControl(panel_name,gErrField25,0);
	EnableControl(panel_name,gPanel25,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_25",0);
	EnableControl(panel_name,gErrField26,0);
	EnableControl(panel_name,gPanel26,0);
	EnableControl(panel_name,"panel_A_FSG_85_0_0_26",0);
	EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Status",0);
	EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_85_0_0_26_SetGet",0);
	EnableControl(panel_name,gErrField27,0);
	EnableControl(panel_name,gPanel27,0);
	EnableControl(panel_name,"panel_A_FSG_85_0_0_27",0);
	EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Status",0);
	EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_85_0_0_27_SetGet",0);
	EnableControl(panel_name,gErrField28,0);
	EnableControl(panel_name,gPanel28,0);
	EnableControl(panel_name,"panel_P_FSG_85_0_0_28",0);

}

EnableFctCtrl ()
{
  	EnableControl(panel_name, common_panel_name, 1);
	if(getValue(P_FSG_85_0_0_13_FctLstItemEn)){
		 EnableControl(panel_name,gPanel13,1);
		 EnableControl(panel_name,gErrField13,1);
	}
	if(getValue(P_FSG_85_0_0_14_FctLstItemEn)){
		 EnableControl(panel_name,gPanel14,1);
		 EnableControl(panel_name,gErrField14,1);
	}
	if(getValue(P_FSG_85_0_0_15_FctLstItemEn)){
		 EnableControl(panel_name,gPanel15,1);
		 EnableControl(panel_name,gErrField15,1);
	}
	if(getValue(P_FSG_85_0_0_16_FctLstItemEn)){
		 EnableControl(panel_name,gPanel16,1);
		 EnableControl(panel_name,gErrField16,1);
	}
	if(getValue(P_FSG_85_0_0_17_FctLstItemEn)){
		 EnableControl(panel_name,gPanel17,1);
		 EnableControl(panel_name,gErrField17,1);
	}
	if(getValue(P_FSG_85_0_0_18_FctLstItemEn)){
		 EnableControl(panel_name,gPanel18,1);
		 EnableControl(panel_name,gErrField18,1);
	}
	if(getValue(P_FSG_85_0_0_19_FctLstItemEn)){
		 EnableControl(panel_name,gPanel19,1);
		 EnableControl(panel_name,gErrField19,1);
	}
	if(getValue(P_FSG_85_0_0_20_FctLstItemEn)){
		 EnableControl(panel_name,gPanel20,1);
		 EnableControl(panel_name,gErrField20,1);
	}
	if(getValue(P_FSG_85_0_0_21_FctLstItemEn)){
		 EnableControl(panel_name,gPanel21,1);
		 EnableControl(panel_name,gErrField21,1);
	}
	if(getValue(P_FSG_85_0_0_22_FctLstItemEn)){
		 EnableControl(panel_name,gPanel22,1);
		 EnableControl(panel_name,gErrField22,1);
	}
	if(getValue(P_FSG_85_0_0_23_FctLstItemEn)){
		 EnableControl(panel_name,gPanel23,1);
		 EnableControl(panel_name,gErrField23,1);
	}
	if(getValue(P_FSG_85_0_0_24_FctLstItemEn)){
		 EnableControl(panel_name,gPanel24,1);
		 EnableControl(panel_name,gErrField24,1);
	}
	if(getValue(P_FSG_85_0_0_25_FctLstItemEn)){
		 EnableControl(panel_name,gPanel25,1);
		 EnableControl(panel_name,gErrField25,1);
	}
	if(getValue(A_FSG_85_0_0_26_FctLstItemEn)){
		 EnableControl(panel_name,gPanel26,1);
	EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Status",1);
		 EnableControl(panel_name,gErrField26,1);
	}
	if(getValue(A_FSG_85_0_0_27_FctLstItemEn)){
		 EnableControl(panel_name,gPanel27,1);
	EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Status",1);
		 EnableControl(panel_name,gErrField27,1);
	}
	if(getValue(P_FSG_85_0_0_28_FctLstItemEn)){
		 EnableControl(panel_name,gPanel28,1);
		 EnableControl(panel_name,gErrField28,1);
	}

}

DisableConfigCtrl ()
{
  	EnableControl(panel_name, bapconfig_panel_name, 0);
	EnableControl(panel_name, bapconfig_panel_name, 0);
	EnableControl(panel_name, "panel1_edit", 0);
//	EnableControl(panel_name,gCheckbox1,0);
//	if(!getValue(C_FSG_85_0_0_1_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox1,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox2,0);
//	if(!getValue(P_FSG_85_0_0_2_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox2,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox3,0);
//	if(!getValue(P_FSG_85_0_0_3_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox3,MakeRGB(200,200,200));
//	}
	EnableControl(panel_name, "panel_P_FSG_85_0_0_4", 0);
//	EnableControl(panel_name,gCheckbox4,0);
//	if(!getValue(P_FSG_85_0_0_4_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox4,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox13,0);
//	if(!getValue(P_FSG_85_0_0_13_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox13,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox14,0);
//	if(!getValue(P_FSG_85_0_0_14_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox14,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox15,0);
//	if(!getValue(P_FSG_85_0_0_15_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox15,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox16,0);
//	if(!getValue(P_FSG_85_0_0_16_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox16,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox17,0);
//	if(!getValue(P_FSG_85_0_0_17_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox17,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox18,0);
//	if(!getValue(P_FSG_85_0_0_18_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox18,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox19,0);
//	if(!getValue(P_FSG_85_0_0_19_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox19,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox20,0);
//	if(!getValue(P_FSG_85_0_0_20_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox20,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox21,0);
//	if(!getValue(P_FSG_85_0_0_21_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox21,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox22,0);
//	if(!getValue(P_FSG_85_0_0_22_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox22,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox23,0);
//	if(!getValue(P_FSG_85_0_0_23_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox23,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox24,0);
//	if(!getValue(P_FSG_85_0_0_24_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox24,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox25,0);
//	if(!getValue(P_FSG_85_0_0_25_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox25,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox26,0);
//	if(!getValue(A_FSG_85_0_0_26_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox26,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox27,0);
//	if(!getValue(A_FSG_85_0_0_27_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox27,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox28,0);
//	if(!getValue(P_FSG_85_0_0_28_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox28,MakeRGB(200,200,200));
//	}

}

EnableConfigCtrl ()
{
  	EnableControl(panel_name, bapconfig_panel_name, 1);
	EnableControl(panel_name, "panel1_edit", 1);
	if(getValue(C_FSG_85_0_0_1_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox1, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox1, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_2_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox2, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox2, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_3_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox3, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox3, MakeRGB(250,0,0));
	}
	EnableControl(panel_name, "panel_P_FSG_85_0_0_4", 1);
	if(getValue(P_FSG_85_0_0_4_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox4, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox4, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_13_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_13",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_13",1);
		setControlForeColor(panel_name, gCheckbox13, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_13",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_13",0);
		setControlForeColor(panel_name, gCheckbox13, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_14_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_14",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_14",1);
		setControlForeColor(panel_name, gCheckbox14, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_14",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_14",0);
		setControlForeColor(panel_name, gCheckbox14, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_15_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_15",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_15",1);
		setControlForeColor(panel_name, gCheckbox15, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_15",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_15",0);
		setControlForeColor(panel_name, gCheckbox15, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_16_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_16",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_16",1);
		setControlForeColor(panel_name, gCheckbox16, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_16",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_16",0);
		setControlForeColor(panel_name, gCheckbox16, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_17_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_17",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_17",1);
		setControlForeColor(panel_name, gCheckbox17, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_17",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_17",0);
		setControlForeColor(panel_name, gCheckbox17, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_18_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_18",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_18",1);
		setControlForeColor(panel_name, gCheckbox18, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_18",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_18",0);
		setControlForeColor(panel_name, gCheckbox18, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_19_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_19",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_19",1);
		setControlForeColor(panel_name, gCheckbox19, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_19",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_19",0);
		setControlForeColor(panel_name, gCheckbox19, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_20_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_20",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_20",1);
		setControlForeColor(panel_name, gCheckbox20, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_20",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_20",0);
		setControlForeColor(panel_name, gCheckbox20, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_21_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_21",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_21",1);
		setControlForeColor(panel_name, gCheckbox21, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_21",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_21",0);
		setControlForeColor(panel_name, gCheckbox21, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_22_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_22",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_22",1);
		setControlForeColor(panel_name, gCheckbox22, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_22",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_22",0);
		setControlForeColor(panel_name, gCheckbox22, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_23_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_23",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_23",1);
		setControlForeColor(panel_name, gCheckbox23, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_23",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_23",0);
		setControlForeColor(panel_name, gCheckbox23, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_24_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_24",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_24",1);
		setControlForeColor(panel_name, gCheckbox24, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_24",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_24",0);
		setControlForeColor(panel_name, gCheckbox24, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_25_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_25",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_25",1);
		setControlForeColor(panel_name, gCheckbox25, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_25",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_25",0);
		setControlForeColor(panel_name, gCheckbox25, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_85_0_0_26_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_85_0_0_26",1);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_85_0_0_26",1);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_26_SetGet",1);
		setControlForeColor(panel_name, gCheckbox26, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_85_0_0_26",0);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_85_0_0_26",0);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_26_SetGet",0);
		setControlForeColor(panel_name, gCheckbox26, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_85_0_0_27_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_85_0_0_27",1);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_85_0_0_27",1);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_27_SetGet",1);
		setControlForeColor(panel_name, gCheckbox27, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_85_0_0_27",0);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_85_0_0_27",0);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_85_0_0_27_SetGet",0);
		setControlForeColor(panel_name, gCheckbox27, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_85_0_0_28_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_28",1);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_28",1);
		setControlForeColor(panel_name, gCheckbox28, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_85_0_0_28",0);
		EnableControl(panel_name,"errfield_P_FSG_85_0_0_28",0);
		setControlForeColor(panel_name, gCheckbox28, MakeRGB(250,0,0));
	}

}

resetErrfieldColor()
{
  	setControlBackColor(panel_name, "errfield_C_FSG_85_0_0_1", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_2", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_3", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_4", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_13", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_14", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_15", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_16", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_17", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_18", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_19", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_20", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_21", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_22", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_23", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_24", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_25", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_85_0_0_26", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_85_0_0_27", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_28", MakeRGB(255,255,255));

}

CANoe_Shutdown ()
{
	// Timer: cancel real CAN-communication timer
	canceltimer(TaskTimer);
	// Ruecksetzen der Hintergrundfarbe der Error-Felder
	resetErrfieldColor();
	// Deaktivierung aller Panel Elemente 
	EnableConfigCtrl();
}

on timer TaskTimer
{
	/*** Aufruf des BAP Task in DLL fuer NODE_INDEX ***/
	BAP150_Task(NODE_INDEX);	

	/*** Pollen ueber die anstehenden Indications (Lesen aus DLL, Auslesen eines Puffers der DLL) ***/
	BAP_DLL_Indication();	
	
	/*** Pollen ueber die anstehenden Requests (Schreiben in DLL, dort werden evt. Sendeauftraege gesetzt) ***/
	BAP_DLL_Request();
	
	/*** Abarbeiten der ausstehenden Sendeauftraege innerhalb der BAP DLL und Versenden ueber CANoe ***/
    if (getValue(eSendEnabled))
    {
        BAP_CAN_TX_Request();
    }

	BAP_DLL_SetRxData();

	/*** Retriggern des Timers mit 10 ms ***/
	setTimer(TaskTimer, TaskTime); // @TODO bei anderer Taskzeit muss hier modifiziert werden
}


BAP_DLL_SetRxData()
{
}


BAP_DLL_Indication()	//function to get received BAP-data from DLL (at BAL-interface)
{
	int length, datalength, temp;
  dword i;
	dword Indication_header[6];					// indication header from DLL
	byte BAP_data_type;

	// init local variables
	length=0;
	datalength=0;
	temp=0;
	BAP_data_type=0;

	for(i = 0; i < 6; i++)
		Indication_header[i]=0;

  // BAP-Stack needs this information for successful BAP150_GetIndication 
	Indication_header[4]=BAP_buffer_size;

	while (BAP150_GetInd(NODE_INDEX, Indication_header, gBAP_Indication_data) == 0)
	{		
		//read header and write in global variable
		for (i = 0; i < 6; i++) {
			gBAP_Indication_header[i]=Indication_header[i];	
		}
		// Verarbeiten der Indication
		Process_Current_Indication();

		// Vorbereiten fuer naechsten Durchlauf 
		Indication_header[4]=BAP_buffer_size;
	} 
}

setBitInFctList(word fctid, byte fctList[])
{
    byte byteNo ;
    byte bitno ;
    byte fctValue ;

    byteNo = fctid / 8;
    bitno = fctid % 8;
    fctValue = 0x80 >> bitno;
    fctList[byteNo] |= fctValue;
}

float round (float value, float step)
{
	return _floor(value / step + 0.5) * step;
}

ChangeConfig(long paramIndex,long config[])
{

        byte temp ;
        temp = BAP150_ChangeConfig(NODE_INDEX, paramIndex, config);
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP150_ChangeConfig for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP150_ChangeConfig error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        
}

PrintIndicationError(char reason[])
{
	writelineEx(gError_Trace, 0, "%s - %s lsgId:%d fctid:%d indType:%d dataType:%s",
		reason, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]]);
}

initBapConfig()
{
        long config[3];
    config[0] = LSGID;
    config[1] = 0;
    config[2] = getValue(BAPCFG_FSG_85_0_0_ProtocolMajor);
    ChangeConfig(0x0012,config);
    config[2] = getValue(BAPCFG_FSG_85_0_0_ProtocolMinor);
    ChangeConfig(0x0013,config);
    config[2] = getValue(BAPCFG_FSG_85_0_0_LsgClassMajor);
    ChangeConfig(0x0010,config);
    config[2] = getValue(BAPCFG_FSG_85_0_0_LsgClassMinor);
    ChangeConfig(0x0011,config);
    config[2] = getValue(BAPCFG_FSG_85_0_0_DFMajor);
    ChangeConfig(0x0014,config);
    config[2] = getValue(BAPCFG_FSG_85_0_0_DFMinor);
    ChangeConfig(0x0015,config);
    
}

initFctList()
{
    byte fctList[8]={0,0,0,0,0,0,0,0};
    int i;
    dword request[6];
    byte errorCode;

    fctList[0]=0;
    fctList[1]=0;
    fctList[2]=0;
    fctList[3]=0;
    fctList[4]=0;
    fctList[5]=0;
    fctList[6]=0;
    fctList[7]=0;

    /*if(getValue(P_FSG_44_0_13_FunctionListId))
    {
        setBitInFctList(P_FSG_44_0_13_ID, fctList);
    }*/
           if(getValue(P_FSG_85_0_0_19_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_19_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_18_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_18_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_17_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_17_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_16_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_16_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_15_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_15_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_14_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_14_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_13_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_13_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_28_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_28_ID, fctList);
       }
       if(getValue(A_FSG_85_0_0_27_FctLstItemEn))
       {
           setBitInFctList(A_FSG_85_0_0_27_ID, fctList);
       }
       if(getValue(A_FSG_85_0_0_26_FctLstItemEn))
       {
           setBitInFctList(A_FSG_85_0_0_26_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_4_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_4_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_25_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_25_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_3_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_3_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_24_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_24_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_2_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_2_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_23_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_23_ID, fctList);
       }
       if(getValue(C_FSG_85_0_0_1_FctLstItemEn))
       {
           setBitInFctList(C_FSG_85_0_0_1_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_22_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_22_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_21_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_21_ID, fctList);
       }
       if(getValue(P_FSG_85_0_0_20_FctLstItemEn))
       {
           setBitInFctList(P_FSG_85_0_0_20_ID, fctList);
       }


    for(i=0;i<8;i++){
        writelineEx(gBAP_Trace, 0, "fctList[%d]: 0x%02x ",i,fctList[i]);
    }

    request [0]=LSGID;
    request [1]=3;
    request [3]= Bap_byteSequence;
    request [4]= 8;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,fctList);
    if(errorCode)
        writelineEx(gError_Trace, 0, "BAP150_InitSendBuf(Functionlist) returns 0x%02x ",errorCode);
}

initHeartbeat()
{
       long data[2];
   data[0]=LSGID;
   if( getValue(P_FSG_85_0_0_4_FctLstItemEn) )
      data[1]=getValue(P_FSG_85_0_0_4);
   else
      data[1]=0;
   ChangeConfig(0x00,data);
   InitSendBuf_int8(P_FSG_85_0_0_4_ID, data[1]);

}

void GetGenCommNumber(struct CommConfigStruct CommConfig, dword Number, dword Channel)
{
  switch(Number)
  {
    case 0: // XML
      CommConfig.Number = 0;
      break;
    case 1: // CAN
    case 2: // CAN-FD
      CommConfig.Number = 1 + (Channel-1);
      isSelectedCAN = 1;
      break;
    case 3: // Flexray
      CommConfig.Number = 10 + (Channel-1);
      isSelectedFr = 1;
      break;
    case 4: // Ethernet
      CommConfig.Number = 20 + (Channel-1);
      isSelectedEth = 1;
      break;
  }
}

void GetCommConfig(byte data[])
{
  dword Index;
  struct CommConfigStruct CommConfig;

  Index = 0;
  strncpy(CommConfig.Name,"BAP_PaCo_FSG_01", 100);
  CommConfig.Channel = getValue(FSG85_0_0_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG85_0_0_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_PaCo_ASG_03", 100);
  CommConfig.Channel = getValue(FSG85_0_1_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG85_0_1_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_PaCo_ASG_02", 100);
  CommConfig.Channel = getValue(FSG85_0_2_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG85_0_2_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_PaCo_ASG_01", 100);
  CommConfig.Channel = getValue(FSG85_0_3_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG85_0_3_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

}

  
BapOnOff(byte _on)
{
  int i, length, temp;
  char Path[255];
  const dword CommConfigSize = 4 * __size_of(struct CommConfigStruct);
  byte CommConfigs[CommConfigSize];
  
  dword DB_ALL_CAN_INTERFACES = 0x80000000;
  dword DB_ALL_ETH_INTERFACES = 0x40000000;
  dword DB_ALL_FR_INTERFACES  = 0x20000000;
  
  isSelectedCAN = 0;
  isSelectedEth = 0;
  isSelectedFr = 0;
  
  /***** Einschalten ******/
  if(_on==1){
    if(BAP180_RemoveDBs(NODE_INDEX) != 0){
      writelineEx(gError_Trace, 0, "Fehler beim Entfernen der Datanbasen!");
    } 
     
    GetCommConfig(CommConfigs);
    
    if(isSelectedCAN){ 
      getAbsFilePath(dbcan_path, Path, 255);
      if(BAP180_LoadDB(NODE_INDEX, DB_ALL_CAN_INTERFACES, 0, Path) != 0){
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
      }
    }
     
    /**** Laden des BAP XML Files ****/
    getAbsFilePath(xml_path, Path, 255);
    writelineEx(gBAP_Trace, 0, "Load BAP-XML-File: %s", Path);
    
    if (BAP1101_LoadConfig(NODE_INDEX, Path, "", CommConfigs, CommConfigSize) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
    }
    
    
    // soll der BAP Stack wieder initlialisiert werden?                                 
    if(gBAP_Init==0){
        //gBAP_Init=1;
        temp=BAP150_Init(NODE_INDEX, LSGID);
        if(temp==0)
            writelineEx(gBAP_Trace, 0, "BAP_Init for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP_Init error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);         
    }

    // Initialisierung aller Variablen
    Initialize_Variables();                     

    // Aktivierung aller Panelelemente
    EnableFctCtrl();
    //EnableControl(panel_name, bapconfig_panel_name, 0); // @TODO
    DisableConfigCtrl();


    //BAP-Shutdown
    temp = BAP150_Shutdown(NODE_INDEX, LSGID);
    if(temp==0)
        writelineEx(gBAP_Trace, 0, "BAP_Shutdown for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
    else
        writelineEx(gError_Trace, 0, "BAP_Shutdown error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX); 

    initBapConfig();
    initFctList();
    initHeartbeat();

    temp = BAP150_Start(NODE_INDEX, LSGID);             
    if(temp == 0)
        writelineEx(gBAP_Trace, 0, "BAP_Start for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
    else
        writelineEx(gError_Trace, 0, "BAP_Start error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        

    // setze den Timer fuer den zyklischen Aufruf des CANoe-"Tasks"
    setTimer(TaskTimer, 10);                
    //  BAPFsg_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID, DEBUG_SWITCH_ON);    
  }
  else{ /***** Ausschalten ****/
      
    BAP150_Shutdown(NODE_INDEX,LSGID);
    CANoe_Shutdown();
      
  }

}

Initialize_Variables()	//initialize/reset all global variables
{
	int temp;
  dword i;
	byte  InitSend_data[BAP_buffer_size];	// InitSend data for DLL
	dword InitSend_header[6];	// InitSend header for DLL

	/**** Request Buffer Geschichten initialisieren ****/
	for (i = 0; i < Requestbuffer_lines; i++)
	{
		gBAP_Requestbuffer_status[i] = 0;
	}	
	for (i = 0; i < BAP_buffer_size; i++)
	{
		InitSend_data[i] = 0;
	}	

	// @TODO nur FSG relevant
	/**** Es ist notwendig mittels InitSendbuffer alle Properties im FSG zu initialisieren ****/
           InitSend_header[0] = LSGID;       
       InitSend_header[1] = 13; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_85_0_0_13);
	 putValue(P_FSG_85_0_0_13, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 14; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 18;
       InitSend_header[5] = 0;
       getValue(P_FSG_85_0_0_14,InitSend_data);
       putValue(P_FSG_85_0_0_14,InitSend_data, 18);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_85_0_0_14)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 15; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_85_0_0_15);
	 putValue(P_FSG_85_0_0_15, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 16; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 11;
       InitSend_header[5] = 0;
       getValue(P_FSG_85_0_0_16,InitSend_data);
       putValue(P_FSG_85_0_0_16,InitSend_data, 11);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_85_0_0_16)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 17; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_85_0_0_17,InitSend_data);
       putValue(P_FSG_85_0_0_17,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_85_0_0_17)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 18; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 11;
       InitSend_header[5] = 0;
       getValue(P_FSG_85_0_0_18,InitSend_data);
       putValue(P_FSG_85_0_0_18,InitSend_data, 11);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_85_0_0_18)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 19; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 11;
       InitSend_header[5] = 0;
       getValue(P_FSG_85_0_0_19,InitSend_data);
       putValue(P_FSG_85_0_0_19,InitSend_data, 11);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_85_0_0_19)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 20; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 11;
       InitSend_header[5] = 0;
       getValue(P_FSG_85_0_0_20,InitSend_data);
       putValue(P_FSG_85_0_0_20,InitSend_data, 11);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_85_0_0_20)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 23; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 5;
       InitSend_header[5] = 0;
       getValue(P_FSG_85_0_0_23,InitSend_data);
       putValue(P_FSG_85_0_0_23,InitSend_data, 5);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_85_0_0_23)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 24; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_85_0_0_24);
	 putValue(P_FSG_85_0_0_24, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 25; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_85_0_0_25,InitSend_data);
       putValue(P_FSG_85_0_0_25,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_85_0_0_25)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 28; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 11;
       InitSend_header[5] = 0;
       getValue(P_FSG_85_0_0_28,InitSend_data);
       putValue(P_FSG_85_0_0_28,InitSend_data, 11);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_85_0_0_28)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);

}

on start
{
	// noch nicht eingeschaltet
	gSG_PowerOnOff=0;
	// noch nicht initialisiert
	gBAP_Init=0;
	// open the panel, nur fuer CANoe-Version >= 5.1 erlaubt
	//openPanel(panel_name);
	// deaktiviere alle aktiven Panel Elemente, ausser AN/AUSS
  CANoe_Shutdown();
        
}


BAP_CAN_TX_Request()	//Function to send BAP-data over CAN
{
   int i;
   byte DestIp[16];
   byte TX_Data[1500];			// Data
   dword TX_Header[13];			// Header
   message 0x100 TX_Message;	// dummy-message, Adresse wird noch modifiziert
   
   byte send_result;

    TX_Header[2] = 1500; // max-Length of TX_Data

		// Pollen ueber die Queue, die von der DLL zur Verfuegung gestellt wird
		// Diese Daten muessen ueber den CAN Bus gesendet werden
    while (BAP180_GetTxData(NODE_INDEX,TX_Header,TX_Data) == 0) {
      if(TX_Header[0] == 1)
      {
        TX_Message.CAN = TX_Header[1]; 		//CAN channel
        TX_Message.ID = TX_Header[3]; 	  //Can ID
        TX_Message.DataLength = TX_Header[2]; 		// received length
      
        for (i=0; i<TX_Message.DataLength; i++) {	//CAN data-bytes
          TX_Message.byte(i) = TX_Data[i];
        }
        
        TX_Message.EDL = 0;
        TX_Message.BRS = 0;
        if(TX_Header[4] & 2) 
          TX_Message.EDL = 1;
        if(TX_Header[4] & 4) 
          TX_Message.BRS = 1;
        
        output(TX_Message);					//send CAN message
        
        //Versions Output
        if(TX_Data[0] == 0x40 && TX_Data[1] == 0x00 && TX_Header[2] == 4)
        {
          writelineEx(gBAP_Trace, 0,"Major Version: %i, Minor Version: %i", TX_Data[2], TX_Data[3]);
        }       
      }
      TX_Header[2] = 1500; 
    } 
}


ringbuffer_write (byte lsgID, byte fctID, byte request, byte dataType, dword singleData)
{
  byte data[1];
  ringbuffer_write(lsgID, fctID, request, dataType, 0, singleData, data);
}

ringbuffer_write (byte lsgID, byte fctID, byte request, byte dataType, dword length, dword singleData, byte data[])
{
	int bufferline;
  dword i;
  
	bufferline = getNextWriteIndex();	//get next free position in ring-buffer

	if (bufferline == -1) 
	{
		writelineEx(gError_Trace, 0, "Crititcal Error: No free buffer found!");
		return;
	}
		
	gBAP_Request_header[bufferline][0] = lsgID;	// LSG
	gBAP_Request_header[bufferline][1] = fctID;	// FCT
	gBAP_Request_header[bufferline][3] = dataType; // dataType
    //writelineEx(gBAP_Trace, 0, "Write request in buffer FSG NODEINDEX:%d lsgid:%d fctid:%d requesttype:%d datatype:%d length:%d", 
    //        NODE_INDEX,lsgID,fctID,request,dataType,length);


	switch (dataType)
	{
		case Bap_void:
			gBAP_Request_header[bufferline][2] = request;	// request
			gBAP_Request_header[bufferline][4] = 0;	// length
				// Void
			// @TODO?		
			break;
		case Bap_uint8:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten		
			break;
		case Bap_uint16:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten
			break;			
		case Bap_uint32:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten		
			break;	
		case Bap_byteSequence:
			gBAP_Request_header[bufferline][2] = request;	// request
			gBAP_Request_header[bufferline][4] = length;	// length
			// Daten der ByteSequence kopieren
      for(i = 0; i < length; i++)									
				gBAP_Request_data[bufferline][i] = data[i];
		case Bap_error:
			gBAP_Request_header[bufferline][5] = singleData;	// Errorcode						
			break;
		default:
			break;
	}
}

Request_void (byte lsgID, byte fctID, byte request)
{
  ringbuffer_write (lsgID, fctID, request, Bap_void, 0);	
}

Request_int8 (byte lsgID, byte fctID, byte request, dword data)
{
  ringbuffer_write (lsgID, fctID, request, Bap_uint8, data);
}

Request_int16 (byte lsgID, byte fctID, byte request, dword data)
{
  ringbuffer_write (lsgID, fctID, request, Bap_uint16, data);
}

Request_int32 (byte lsgID, byte fctID, byte request, dword data)
{
  ringbuffer_write (lsgID, fctID, request, Bap_uint32, data);
}

Request_byteSequence (byte lsgID, byte fctID, byte request, byte data[], dword length)
{
  ringbuffer_write (lsgID, fctID, request, Bap_byteSequence, length, 0, data);
}

Request_error (byte lsgID, byte fctID, byte errorCode)
{
  ringbuffer_write (lsgID, fctID, Error_REQ, Bap_error, errorCode);
}

InitSendBuf_int8 (byte fctID, dword data)
{
    dword request[6];
    int errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint8;
    request [5]= data;

    errorCode=
    BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int8 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
    
}

InitSendBuf_int16 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint16;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int16 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_int32 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int32 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_byteSequence (byte fctID, byte data[], word length)
{
    dword request[6];
    byte errorCode;

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [4]= length;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_byteSequence error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

DisplayRequestErrorCode(dword fctID, dword errCode)
{
       switch(fctID)
   {
       case C_FSG_85_0_0_1_ID:
           gC_FSG_85_0_0_1_ErrCode = 0;
           putValue(C_FSG_85_0_0_1_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_C_FSG_85_0_0_1", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_2_ID:
           gP_FSG_85_0_0_2_ErrCode = 0;
           putValue(P_FSG_85_0_0_2_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_2", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_3_ID:
           gP_FSG_85_0_0_3_ErrCode = 0;
           putValue(P_FSG_85_0_0_3_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_3", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_4_ID:
           gP_FSG_85_0_0_4_ErrCode = 0;
           putValue(P_FSG_85_0_0_4_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_4", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_13_ID:
           gP_FSG_85_0_0_13_ErrCode = 0;
           putValue(P_FSG_85_0_0_13_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_13", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_14_ID:
           gP_FSG_85_0_0_14_ErrCode = 0;
           putValue(P_FSG_85_0_0_14_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_14", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_15_ID:
           gP_FSG_85_0_0_15_ErrCode = 0;
           putValue(P_FSG_85_0_0_15_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_15", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_16_ID:
           gP_FSG_85_0_0_16_ErrCode = 0;
           putValue(P_FSG_85_0_0_16_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_16", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_17_ID:
           gP_FSG_85_0_0_17_ErrCode = 0;
           putValue(P_FSG_85_0_0_17_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_17", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_18_ID:
           gP_FSG_85_0_0_18_ErrCode = 0;
           putValue(P_FSG_85_0_0_18_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_18", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_19_ID:
           gP_FSG_85_0_0_19_ErrCode = 0;
           putValue(P_FSG_85_0_0_19_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_19", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_20_ID:
           gP_FSG_85_0_0_20_ErrCode = 0;
           putValue(P_FSG_85_0_0_20_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_20", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_21_ID:
           gP_FSG_85_0_0_21_ErrCode = 0;
           putValue(P_FSG_85_0_0_21_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_21", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_22_ID:
           gP_FSG_85_0_0_22_ErrCode = 0;
           putValue(P_FSG_85_0_0_22_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_22", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_23_ID:
           gP_FSG_85_0_0_23_ErrCode = 0;
           putValue(P_FSG_85_0_0_23_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_23", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_24_ID:
           gP_FSG_85_0_0_24_ErrCode = 0;
           putValue(P_FSG_85_0_0_24_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_24", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_25_ID:
           gP_FSG_85_0_0_25_ErrCode = 0;
           putValue(P_FSG_85_0_0_25_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_25", MakeRGB(255,79,79));
       break;
       case A_FSG_85_0_0_26_ID:
           gA_FSG_85_0_0_26_ErrCode = 0;
           putValue(A_FSG_85_0_0_26_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_85_0_0_26", MakeRGB(255,79,79));
       break;
       case A_FSG_85_0_0_27_ID:
           gA_FSG_85_0_0_27_ErrCode = 0;
           putValue(A_FSG_85_0_0_27_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_85_0_0_27", MakeRGB(255,79,79));
       break;
       case P_FSG_85_0_0_28_ID:
           gP_FSG_85_0_0_28_ErrCode = 0;
           putValue(P_FSG_85_0_0_28_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_28", MakeRGB(255,79,79));
       break;
       default:
           writelineEx(gError_Trace, 0, "%s%d/%d Unknown Functionid in  displayErrorCode", SGtype, LSGID,fctID);
   }

}

BAP_DLL_Request ()
{
    dword i;
    int l=0;
    byte temp;
    byte Request_data[BAP_buffer_size];    //Request data for DLL
    dword Request_header[6];    //Request header for DLL
    byte dataValid;
    int nextElementToRead;
    
    // defaultmaessig ist senden OK
    dataValid = 1;

    // loeschen der Daten "Container"
    for(i=0;i<6;i++)
        Request_header[i]=0;
    //for(i=0;i<BAP_buffer_size;i++)
    //    Request_data[i]=0;

    
    // Verarbeiten aller noch offenen Requests  
    while ((nextElementToRead = getNextReadIndex()) != -1) 
    {
        // Fuer alle Datentypen gleich
        Request_header[0]=gBAP_Request_header [nextElementToRead][0];       //LSG-ID
        Request_header[1]=gBAP_Request_header [nextElementToRead][1];       //Function-ID
        Request_header[2]=gBAP_Request_header [nextElementToRead][2];       //request type
        Request_header[3]=gBAP_Request_header [nextElementToRead][3];       //BAP data type

        switch(gBAP_Request_header[nextElementToRead][3]){
            case Bap_uint32:
                l=2;
            case Bap_uint16:
                l++;
            case Bap_uint8:
            case Bap_error: // Request (2) wird dabei ignoriert
                l++;
            case Bap_void:  // Datenfeld (5) wird dabei ignoriert
                Request_header[4]=l;                                                //  not used
                Request_header[5]=gBAP_Request_header [nextElementToRead][5];       // Daten
            break;
            case Bap_byteSequence:                                  
                Request_header[4]=gBAP_Request_header [nextElementToRead][4];       // length
                Request_header[5]=0;                                                // not used

                // data-array for BAP-DLL funcion 'BAP_Request'
                for(i=0;i<Request_header[4]/*BAP_buffer_size*/;i++)
                    Request_data[i]=gBAP_Request_data [nextElementToRead][i];
                break;          
            default:
                writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Request_header[nextElementToRead][3]);
                dataValid = 0;
            break;          
        }
        
        if(dataValid){
            // wie heisst der Request?
            writelineEx(gBAP_Trace, 0, "%s%d/%d BAP_Request %s datatype:%s length:%d", SGtype, Request_header[0],Request_header[1],Requesttype_Text[Request_header[2]],Datatype_Text[Request_header[3]],Request_header[4]);
            temp = BAP150_Request(NODE_INDEX, Request_header, Request_data);    //send data to BAP-DLL  
            // BAP-Request failed
            if(temp != 0){
                // Fehlercode: Request failed
                writelineEx(gError_Trace, 0, "%s%d/%d Error during BAP_Request errorcode: 0x%X", SGtype, Request_header[0],Request_header[1],temp);
                DisplayRequestErrorCode(Request_header[1],temp);
            } 
        }

    }
} 

int getNextReadIndex ()
{
	int i, ret;
	// der Puffer wird nach dem naechsten zu lesenden Eintrag durchsucht
	// Existiert keiner wird -1 zurueckgegeben
	ret = -1;

	for (i = 0; i < Requestbuffer_lines; i++)
	{
		if (gBAP_Requestbuffer_status[i] == 1)
		{
			// zum verschicken
			ret = i;
			// und wieder freigeben
			gBAP_Requestbuffer_status[i] = 0;
			break;
		}
	}

	return (ret);
}

int getNextWriteIndex ()
{
	int i, ret;
	// der Puffer wird nach dem naechsten freien Eintrag durchsucht
	// Existiert keiner wird -1 zurueckgegeben
	ret = -1;

	for (i = 0; i < Requestbuffer_lines; i++)
	{
		if (gBAP_Requestbuffer_status[i] == 0)
		{
			// zum schreiben
			ret = i;
			// belegen
			gBAP_Requestbuffer_status[i] = 1;
			break;
		}
	}

	return (ret);
}

//gBAP_Indication_header[0])  // LSGID
//gBAP_Indication_header[1]) // FCTID
//gBAP_Indication_header[2]) // IndType
//gBAP_Indication_header[3]) // Datentyp



Process_Current_Indication ()
{
   int rxsize;
   int txsize;
   byte temp[BAP_buffer_size];
   char buffer[BAP_buffer_size];
   if(strncmp(Datatype_Text[gBAP_Indication_header[3]], "acknowledge", 4)!=0) 
       writelineEx(gBAP_Trace, 0, "NodeIndex: %d: CurrentIndication %s lsgid:%d fctid:%d indType:%s dataType=%s length=%d",
               NODE_INDEX, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   else 
       writelineEx(gBAP_Trace, 0, "Internal acknowledge %s-%d fctid:%d indType:%s dataType=%s length=%d",
               SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Acknowledgetype_Text[gBAP_Indication_header[5]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   switch(gBAP_Indication_header[0])  // LSGID
   {
   case LSGID:
       switch(gBAP_Indication_header[1]) // FCTID
       {
    case P_FSG_85_0_0_13_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_85_0_0_13_ErrEn)) { 
                               Request_error(LSGID,P_FSG_85_0_0_13_ID,getValue(P_FSG_85_0_0_13_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_85_0_0_13, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_13", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_85_0_0_13_ErrEn)) { 
                               Request_error(LSGID,P_FSG_85_0_0_13_ID,getValue(P_FSG_85_0_0_13_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_85_0_0_13, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_13", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_85_0_0_13_ID, Data_REQ, getValue(P_FSG_85_0_0_13));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_85_0_0_13_ErrCode = 0;
                putValue(P_FSG_85_0_0_13_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_13", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_13_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_85_0_0_14_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_85_0_0_14_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_14", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_14_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_15_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_85_0_0_15_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_15", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_15_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_16_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_16_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_16_ID,getValue(P_FSG_85_0_0_16_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_85_0_0_16, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_16", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_16_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_16_ID,getValue(P_FSG_85_0_0_16_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_85_0_0_16, temp);
						gBAP_Indication_data[0]= gBAP_Indication_data[0]&0x0f;
						gBAP_Indication_data[0]= gBAP_Indication_data[0]|(temp[0]&0xf0);
						gBAP_Indication_data[1]=temp[1];
						gBAP_Indication_data[3]= gBAP_Indication_data[3]&0x0f;
						gBAP_Indication_data[3]= gBAP_Indication_data[3]|(temp[3]&0xf0);
						gBAP_Indication_data[4]= gBAP_Indication_data[4]&0x0f;
						gBAP_Indication_data[4]= gBAP_Indication_data[4]|(temp[4]&0xf0);
						gBAP_Indication_data[6]= gBAP_Indication_data[6]&0x0f;
						gBAP_Indication_data[6]= gBAP_Indication_data[6]|(temp[6]&0xf0);
						gBAP_Indication_data[6]= gBAP_Indication_data[6]&0xf0;
						gBAP_Indication_data[6]= gBAP_Indication_data[6]|(temp[6]&0x0f);
						gBAP_Indication_data[7]= gBAP_Indication_data[7]&0x0f;
						gBAP_Indication_data[7]= gBAP_Indication_data[7]|(temp[7]&0xf0);
						gBAP_Indication_data[8]=temp[8];
						gBAP_Indication_data[10]= gBAP_Indication_data[10]&0x0f;
						gBAP_Indication_data[10]= gBAP_Indication_data[10]|(temp[10]&0xf0);
                        putValue(P_FSG_85_0_0_16, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_16", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_85_0_0_16, temp);
                        Request_byteSequence(LSGID, P_FSG_85_0_0_16_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_85_0_0_16_ErrCode = 0;
                putValue(P_FSG_85_0_0_16_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_16", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_16_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_17_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_17_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_17_ID,getValue(P_FSG_85_0_0_17_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_85_0_0_17, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_17", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_17_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_17_ID,getValue(P_FSG_85_0_0_17_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_85_0_0_17, temp);
						gBAP_Indication_data[0]= gBAP_Indication_data[0]&0x0f;
						gBAP_Indication_data[0]= gBAP_Indication_data[0]|(temp[0]&0xf0);
                        putValue(P_FSG_85_0_0_17, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_17", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_85_0_0_17, temp);
                        Request_byteSequence(LSGID, P_FSG_85_0_0_17_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_85_0_0_17_ErrCode = 0;
                putValue(P_FSG_85_0_0_17_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_17", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_17_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_18_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_18_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_18_ID,getValue(P_FSG_85_0_0_18_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_85_0_0_18, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_18", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_18_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_18_ID,getValue(P_FSG_85_0_0_18_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_85_0_0_18, temp);
						gBAP_Indication_data[0]= gBAP_Indication_data[0]&0x0f;
						gBAP_Indication_data[0]= gBAP_Indication_data[0]|(temp[0]&0xf0);
						gBAP_Indication_data[1]= gBAP_Indication_data[1]&0x0f;
						gBAP_Indication_data[1]= gBAP_Indication_data[1]|(temp[1]&0xf0);
						gBAP_Indication_data[2]= gBAP_Indication_data[2]&0x0f;
						gBAP_Indication_data[2]= gBAP_Indication_data[2]|(temp[2]&0xf0);
						gBAP_Indication_data[3]= gBAP_Indication_data[3]&0x0f;
						gBAP_Indication_data[3]= gBAP_Indication_data[3]|(temp[3]&0xf0);
						gBAP_Indication_data[4]= gBAP_Indication_data[4]&0x0f;
						gBAP_Indication_data[4]= gBAP_Indication_data[4]|(temp[4]&0xf0);
						gBAP_Indication_data[5]= gBAP_Indication_data[5]&0x0f;
						gBAP_Indication_data[5]= gBAP_Indication_data[5]|(temp[5]&0xf0);
						gBAP_Indication_data[6]= gBAP_Indication_data[6]&0x0f;
						gBAP_Indication_data[6]= gBAP_Indication_data[6]|(temp[6]&0xf0);
                        putValue(P_FSG_85_0_0_18, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_18", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_85_0_0_18, temp);
                        Request_byteSequence(LSGID, P_FSG_85_0_0_18_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_85_0_0_18_ErrCode = 0;
                putValue(P_FSG_85_0_0_18_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_18", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_18_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_19_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_85_0_0_19_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_19", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_19_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_20_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_85_0_0_20_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_20", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_20_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_21_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_21_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_21_ID,getValue(P_FSG_85_0_0_21_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_85_0_0_21, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_21", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_21_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_21_ID,getValue(P_FSG_85_0_0_21_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_85_0_0_21, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_21", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_85_0_0_21, temp);
                        Request_byteSequence(LSGID, P_FSG_85_0_0_21_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_85_0_0_21_ErrCode = 0;
                putValue(P_FSG_85_0_0_21_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_21", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_21_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_22_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_22_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_22_ID,getValue(P_FSG_85_0_0_22_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_85_0_0_22, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_22", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_22_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_22_ID,getValue(P_FSG_85_0_0_22_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_85_0_0_22, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_22", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_85_0_0_22, temp);
                        Request_byteSequence(LSGID, P_FSG_85_0_0_22_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_85_0_0_22_ErrCode = 0;
                putValue(P_FSG_85_0_0_22_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_22", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_22_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_23_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_85_0_0_23_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_23", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_23_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_24_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_85_0_0_24_ErrEn)) { 
                               Request_error(LSGID,P_FSG_85_0_0_24_ID,getValue(P_FSG_85_0_0_24_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_85_0_0_24, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_24", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_85_0_0_24_ErrEn)) { 
                               Request_error(LSGID,P_FSG_85_0_0_24_ID,getValue(P_FSG_85_0_0_24_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_85_0_0_24, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_24", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_85_0_0_24_ID, Data_REQ, getValue(P_FSG_85_0_0_24));
                            break;
                        case Ack_IND: // Indication pruefen
                            putValue(P_FSG_85_0_0_24_Ack, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_24", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_85_0_0_24_ErrCode = 0;
                putValue(P_FSG_85_0_0_24_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_24", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_24_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_85_0_0_25_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_85_0_0_25_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_25", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_25_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_85_0_0_26_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_85_0_0_26_ErrEn)) { 
                               Request_error(LSGID,A_FSG_85_0_0_26_ID,getValue(A_FSG_85_0_0_26_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_85_0_0_26_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_85_0_0_26_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_85_0_0_26", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_85_0_0_26_ErrEn)) { 
                               Request_error(LSGID,A_FSG_85_0_0_26_ID,getValue(A_FSG_85_0_0_26_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_85_0_0_26_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_85_0_0_26_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_85_0_0_26", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_85_0_0_26, temp);
                    //Request_byteSequence(LSGID, A_FSG_85_0_0_26_ID, Data_REQ, temp, getValueSize(A_FSG_85_0_0_26));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_85_0_0_26Status_BTN, 1);
                    //putValue(A_FSG_85_0_0_26Status_BTN, 0);
                    A_FSG_85_0_0_26_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_85_0_0_26_ErrEn)) { 
                               Request_error(LSGID,A_FSG_85_0_0_26_ID,getValue(A_FSG_85_0_0_26_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_85_0_0_26_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_85_0_0_26_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_85_0_0_26", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_85_0_0_26, temp);
                    //Request_byteSequence(LSGID, A_FSG_85_0_0_26_ID, Data_REQ, temp, getValueSize(A_FSG_85_0_0_26));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_85_0_0_26Status_BTN, 1);
                    //putValue(A_FSG_85_0_0_26Status_BTN, 0);
                    A_FSG_85_0_0_26_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_85_0_0_26_ErrCode = 0;
                putValue(A_FSG_85_0_0_26_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_85_0_0_26", MakeRGB(255,79,79));  
                gA_FSG_85_0_0_26_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_85_0_0_27_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_85_0_0_27_ErrEn)) { 
                               Request_error(LSGID,A_FSG_85_0_0_27_ID,getValue(A_FSG_85_0_0_27_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_85_0_0_27_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_85_0_0_27_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_85_0_0_27", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_85_0_0_27_ErrEn)) { 
                               Request_error(LSGID,A_FSG_85_0_0_27_ID,getValue(A_FSG_85_0_0_27_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_85_0_0_27_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_85_0_0_27_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_85_0_0_27", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_85_0_0_27, temp);
                    //Request_byteSequence(LSGID, A_FSG_85_0_0_27_ID, Data_REQ, temp, getValueSize(A_FSG_85_0_0_27));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_85_0_0_27Status_BTN, 1);
                    //putValue(A_FSG_85_0_0_27Status_BTN, 0);
                    A_FSG_85_0_0_27_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_85_0_0_27_ErrEn)) { 
                               Request_error(LSGID,A_FSG_85_0_0_27_ID,getValue(A_FSG_85_0_0_27_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_85_0_0_27_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_85_0_0_27_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_85_0_0_27", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_85_0_0_27, temp);
                    //Request_byteSequence(LSGID, A_FSG_85_0_0_27_ID, Data_REQ, temp, getValueSize(A_FSG_85_0_0_27));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_85_0_0_27Status_BTN, 1);
                    //putValue(A_FSG_85_0_0_27Status_BTN, 0);
                    A_FSG_85_0_0_27_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_85_0_0_27_ErrCode = 0;
                putValue(A_FSG_85_0_0_27_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_85_0_0_27", MakeRGB(255,79,79));  
                gA_FSG_85_0_0_27_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_85_0_0_28_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_28_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_28_ID,getValue(P_FSG_85_0_0_28_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_85_0_0_28, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_28", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_85_0_0_28_ErrEn)) { 
                           Request_error(LSGID,P_FSG_85_0_0_28_ID,getValue(P_FSG_85_0_0_28_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_85_0_0_28, temp);
						gBAP_Indication_data[0]= gBAP_Indication_data[0]&0x0f;
						gBAP_Indication_data[0]= gBAP_Indication_data[0]|(temp[0]&0xf0);
                        putValue(P_FSG_85_0_0_28, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_28", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_85_0_0_28, temp);
                        Request_byteSequence(LSGID, P_FSG_85_0_0_28_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_85_0_0_28_ErrCode = 0;
                putValue(P_FSG_85_0_0_28_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_85_0_0_28", MakeRGB(255,79,79));  
                gP_FSG_85_0_0_28_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
       default:
           writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal Fct: lsgid:%d fctid:%d indType:%d",
           NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], gBAP_Indication_header[2]);
           break;
       }
       break;
   default:
       writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal LSGID: lsgid:%d fctid:%d indType:%s", NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]]);
       break;
   }
}


on message *
{
  int i, temp;;
  byte RX_Data[64];           // received CAN-DATA";
  dword RX_Header[4];         // received CAN-Header";
  if(gSG_PowerOnOff==Power_on){
    if((this.dir == rx) && ((this.ID & 0xFFFF0000) == 0x97330000)){
      RX_Header[0]=1; /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
      RX_Header[1]=this.msgChannel;
      RX_Header[2]=this.DataLength; // received length
      RX_Header[3]=this.ID;
      for (i=0; i<this.DataLength; i++) {
        RX_Data[i]=this.byte(i);
      }
      temp=BAP180_SetRxData(NODE_INDEX, RX_Header, RX_Data);
    }
  }
}


intertelegram_err(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=1;
    data[3]=940;
    ChangeConfig(0x0020,data);
}

sequence_err(long fctId, long size)
{
    long data[5];
    long lastSeg;

    lastSeg = size-5;

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=lastSeg/7+1;
    data[3]=1;
    data[4]=(lastSeg/7+4) & 15;
    ChangeConfig(0x0021,data);
}

intertelegram_err_off(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    ChangeConfig(0x0020,data);
}

sequence_err_off(long fctId)
{
    long data[5];

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    data[4]=0;
    ChangeConfig(0x0021,data);
}

// ETHERNET NOT ENABLED! (ON_UDP_RECEIVE_FROM_TOKEN)

// ETHERNET NOT ENABLED!

on envVar ON_OFF_FSG85_0
{
   BapOnOff(getvalue(this));
   gSG_PowerOnOff=getvalue(ON_OFF_FSG85_0);
}
on envVar BAPCFG_FSG_85_0_0_DFMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 9, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_85_0_0_DFMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 10, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_85_0_0_LsgClassMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 5, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_85_0_0_LsgClassMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 6, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_85_0_0_ProtocolMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 7, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_85_0_0_ProtocolMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 8, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID C_FSG_85_0_0_1_ID
on envVar C_FSG_85_0_0_1_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_C_FSG_85_0_0_1", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_C_FSG_85_0_0_1", MakeRGB(250,0,0));
       }
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_85_0_0_2_ID
on envVar P_FSG_85_0_0_2_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_2", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_2", MakeRGB(250,0,0));
       }
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_2_ErrCode
{
       if(gP_FSG_85_0_0_2_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_2", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_2_ErrCode = 1;
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_85_0_0_3_ID
on envVar P_FSG_85_0_0_3_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_3", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_3", MakeRGB(250,0,0));
       }
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_3_ErrCode
{
       if(gP_FSG_85_0_0_3_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_3", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_3_ErrCode = 1;
}
// De-Aktivierung der Eingabefelder der HB-FCT P_FSG_85_0_0_4
on envVar P_FSG_85_0_0_4_FctLstItemEn
{
       if(getValue(this)) 
       {
//           EnableControl(panel_name,"panel_FSG_85_0_0_4",1);
//           EnableControl(panel_name,"${ERRFIELD}",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_4_HBEn",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_4", MakeRGB(0,240,0));
       }
       else
       {
//           EnableControl(panel_name,"panel_FSG_85_0_0_4",0);
//           EnableControl(panel_name,"${ERRFIELD}",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_4_HBEn",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_4", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_85_0_0_4_FctEn
{
	long data[2];
	if(getValue(P_FSG_85_0_0_4_FctEn)>0)
	{
		data[0] = 85;
		data[1] = getValue(P_FSG_85_0_0_4);
		write("enable HB");
	}
	else
	{
		data[0] = 85;
		data[1] = 0;
		write("disable HB");
	}
	Bap150_ChangeConfig(NODE_INDEX, 0x00, data);
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_4_ErrCode
{
       if(gP_FSG_85_0_0_4_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_4", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_4_ErrCode = 1;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_13_ErrCode
{
       if(gP_FSG_85_0_0_13_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_13", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_13_ErrCode = 1;
}
on envVar P_FSG_85_0_0_13Status_BTN
{
    if (P_FSG_85_0_0_13Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_85_0_0_13_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_13",MakeRGB(255,255,255));
       P_FSG_85_0_0_13Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_85_0_0_13_ID, Data_REQ, getValue(P_FSG_85_0_0_13));
      P_FSG_85_0_0_13Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_85_0_0_13_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_13_ID;
    data[2]=getValue(P_FSG_85_0_0_13_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_13
on envVar P_FSG_85_0_0_13_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_13",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_13",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_13",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_13", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_13",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_13",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_13",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_13", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_85_0_0_13 // bus value of FSG_Control (13).
{
	// opcodes: Error-Status
	byte param1; // Controlcode
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_85_0_0_13);
	putValue(P_FSG_85_0_0_13_1, param1);
}

on envVar P_FSG_85_0_0_13_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Controlcode
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_13_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_13_1,thisval);
}

on envVar P_FSG_85_0_0_13_1 // FSG_Control.Controlcode
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Controlcode
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_85_0_0_13_1_0, 1);
	else
		putValue(P_FSG_85_0_0_13_1_0, 0);

    // Update superval
	superval = getValue(P_FSG_85_0_0_13);
	superval = thisval;
	putValue(P_FSG_85_0_0_13,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_14_ErrCode
{
       if(gP_FSG_85_0_0_14_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_14", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_14_ErrCode = 1;
}
on envVar P_FSG_85_0_0_14Status_BTN
{
	byte BAPTemp[18];
    if (P_FSG_85_0_0_14Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_85_0_0_14_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_14",MakeRGB(255,255,255));
        P_FSG_85_0_0_14Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_85_0_0_14_BuildFct();
        getValue(P_FSG_85_0_0_14, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_85_0_0_14_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_85_0_0_14));
        if(getValue(P_FSG_85_0_0_14_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_85_0_0_14_ID);
        }
        if(getValue(P_FSG_85_0_0_14_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_85_0_0_14_ID,elCount(BAPTemp));
        }
       P_FSG_85_0_0_14Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_85_0_0_14_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_14_ID;
    data[2]=getValue(P_FSG_85_0_0_14_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_14
on envVar P_FSG_85_0_0_14_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_14",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_14",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_14",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_14", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_14",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_14",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_14",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_14", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_14_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_14_SegmEn,0);
           intertelegram_err(P_FSG_85_0_0_14_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_85_0_0_14_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_14_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_14_IntTlgEn,0);
           sequence_err(P_FSG_85_0_0_14_ID,getValueSize(P_FSG_85_0_0_14_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_85_0_0_14_ID);
       }
}
on envVar P_FSG_85_0_0_14 // bus value of FSG_Setup (14).
{
	// opcodes: Error-Status
	byte param1; // featureInstallationVPS
	byte param2; // featureInstallationParking
	byte param3; // parkingAssistSetup
	byte param4; // systemStateSetup
	byte param5; // supportedViews1
	byte param6; // supportedRV_Modes1
	byte param7; // supportedFV_Modes1
	byte param8; // supportedSV_Modes1
	byte param9; // supportedBirdViews
	byte param10; // maneuverAssistSetup
	byte param11; // parkingIndications_Installation
	byte param12; // Extension2
	byte param13; // Extension3
	byte param14; // Extension4
	byte param15; // Extension5
	byte param16; // Extension6
	byte param17; // Extension7
	byte param18; // Extension8
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[18];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 18; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_14, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_4, param4);
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_5, param5);
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_6, param6);
	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_7, param7);
	///////// Start param8 - UINT8 /////////
	param8 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_8, param8);
	///////// Start param9 - UINT8 /////////
	param9 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_9, param9);
	///////// Start param10 - UINT8 /////////
	param10 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_10, param10);
	///////// Start param11 - UINT8 /////////
	param11 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_11, param11);
	///////// Start param12 - UINT8 /////////
	param12 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_12, round((param12 * 1.0) - (0) + (0), 1.0));
	///////// Start param13 - UINT8 /////////
	param13 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_13, round((param13 * 1.0) - (0) + (0), 1.0));
	///////// Start param14 - UINT8 /////////
	param14 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_14, round((param14 * 1.0) - (0) + (0), 1.0));
	///////// Start param15 - UINT8 /////////
	param15 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_15, round((param15 * 1.0) - (0) + (0), 1.0));
	///////// Start param16 - UINT8 /////////
	param16 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_16, round((param16 * 1.0) - (0) + (0), 1.0));
	///////// Start param17 - UINT8 /////////
	param17 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_17, round((param17 * 1.0) - (0) + (0), 1.0));
	///////// Start param18 - UINT8 /////////
	param18 = superval[currentPos++];
	putValue(P_FSG_85_0_0_14_18, round((param18 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_FSG_85_0_0_14_BuildFct()
{
	byte param1; // featureInstallationVPS
	byte param2; // featureInstallationParking
	byte param3; // parkingAssistSetup
	byte param4; // systemStateSetup
	byte param5; // supportedViews1
	byte param6; // supportedRV_Modes1
	byte param7; // supportedFV_Modes1
	byte param8; // supportedSV_Modes1
	byte param9; // supportedBirdViews
	byte param10; // maneuverAssistSetup
	byte param11; // parkingIndications_Installation
	byte param12; // Extension2
	byte param13; // Extension3
	byte param14; // Extension4
	byte param15; // Extension5
	byte param16; // Extension6
	byte param17; // Extension7
	byte param18; // Extension8

	dword i;
	byte superval[18];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_FSG_85_0_0_14_1);
	@P_FSG_85_0_0_14_1_0 = (param1 & 1) > 0;
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_85_0_0_14_2);
	@P_FSG_85_0_0_14_2_0 = (param2 & 1) > 0;
	@P_FSG_85_0_0_14_2_1 = (param2 & 2) > 0;
	@P_FSG_85_0_0_14_2_2 = (param2 & 4) > 0;
	@P_FSG_85_0_0_14_2_3 = (param2 & 8) > 0;
	@P_FSG_85_0_0_14_2_4 = (param2 & 16) > 0;
	@P_FSG_85_0_0_14_2_5 = (param2 & 32) > 0;
	@P_FSG_85_0_0_14_2_6 = (param2 & 64) > 0;
	superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_85_0_0_14_3);
	@P_FSG_85_0_0_14_3_0 = (param3 & 1) > 0;
	@P_FSG_85_0_0_14_3_1 = (param3 & 2) > 0;
	@P_FSG_85_0_0_14_3_2 = (param3 & 4) > 0;
	@P_FSG_85_0_0_14_3_3 = (param3 & 8) > 0;
	@P_FSG_85_0_0_14_3_4 = (param3 & 16) > 0;
	@P_FSG_85_0_0_14_3_5 = (param3 & 32) > 0;
	@P_FSG_85_0_0_14_3_6 = (param3 & 64) > 0;
	@P_FSG_85_0_0_14_3_7 = (param3 & 128) > 0;
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_85_0_0_14_4);
	@P_FSG_85_0_0_14_4_0 = (param4 & 1) > 0;
	@P_FSG_85_0_0_14_4_1 = (param4 & 2) > 0;
	@P_FSG_85_0_0_14_4_2 = (param4 & 4) > 0;
	@P_FSG_85_0_0_14_4_3 = (param4 & 8) > 0;
	@P_FSG_85_0_0_14_4_4 = (param4 & 16) > 0;
	@P_FSG_85_0_0_14_4_5 = (param4 & 32) > 0;
	@P_FSG_85_0_0_14_4_6 = (param4 & 64) > 0;
	@P_FSG_85_0_0_14_4_7 = (param4 & 128) > 0;
	superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_FSG_85_0_0_14_5);
	@P_FSG_85_0_0_14_5_0 = (param5 & 1) > 0;
	@P_FSG_85_0_0_14_5_1 = (param5 & 2) > 0;
	@P_FSG_85_0_0_14_5_2 = (param5 & 4) > 0;
	@P_FSG_85_0_0_14_5_3 = (param5 & 8) > 0;
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	param6 = getValue(P_FSG_85_0_0_14_6);
	@P_FSG_85_0_0_14_6_0 = (param6 & 1) > 0;
	@P_FSG_85_0_0_14_6_1 = (param6 & 2) > 0;
	@P_FSG_85_0_0_14_6_2 = (param6 & 4) > 0;
	@P_FSG_85_0_0_14_6_3 = (param6 & 8) > 0;
	@P_FSG_85_0_0_14_6_4 = (param6 & 16) > 0;
	@P_FSG_85_0_0_14_6_5 = (param6 & 32) > 0;
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_FSG_85_0_0_14_7);
	@P_FSG_85_0_0_14_7_0 = (param7 & 1) > 0;
	@P_FSG_85_0_0_14_7_1 = (param7 & 2) > 0;
	@P_FSG_85_0_0_14_7_2 = (param7 & 4) > 0;
	@P_FSG_85_0_0_14_7_3 = (param7 & 8) > 0;
	superval[currentPos++]=param7;
// gen_BuildFunc_SetSuperVals 
	param8 = getValue(P_FSG_85_0_0_14_8);
	@P_FSG_85_0_0_14_8_0 = (param8 & 1) > 0;
	@P_FSG_85_0_0_14_8_1 = (param8 & 2) > 0;
	@P_FSG_85_0_0_14_8_2 = (param8 & 4) > 0;
	superval[currentPos++]=param8;
// gen_BuildFunc_SetSuperVals 
	param9 = getValue(P_FSG_85_0_0_14_9);
	@P_FSG_85_0_0_14_9_0 = (param9 & 1) > 0;
	@P_FSG_85_0_0_14_9_1 = (param9 & 2) > 0;
	superval[currentPos++]=param9;
// gen_BuildFunc_SetSuperVals 
	param10 = getValue(P_FSG_85_0_0_14_10);
	@P_FSG_85_0_0_14_10_0 = (param10 & 1) > 0;
	@P_FSG_85_0_0_14_10_1 = (param10 & 2) > 0;
	superval[currentPos++]=param10;
// gen_BuildFunc_SetSuperVals 
	param11 = getValue(P_FSG_85_0_0_14_11);
	@P_FSG_85_0_0_14_11_0 = (param11 & 1) > 0;
	superval[currentPos++]=param11;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_14_12_range = round(@P_FSG_85_0_0_14_12 + (0), 1.0); // slider value + min = real value
	param12 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param12;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_14_13_range = round(@P_FSG_85_0_0_14_13 + (0), 1.0); // slider value + min = real value
	param13 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param13;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_14_14_range = round(@P_FSG_85_0_0_14_14 + (0), 1.0); // slider value + min = real value
	param14 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param14;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_14_15_range = round(@P_FSG_85_0_0_14_15 + (0), 1.0); // slider value + min = real value
	param15 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param15;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_14_16_range = round(@P_FSG_85_0_0_14_16 + (0), 1.0); // slider value + min = real value
	param16 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param16;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_14_17_range = round(@P_FSG_85_0_0_14_17 + (0), 1.0); // slider value + min = real value
	param17 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param17;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_14_18_range = round(@P_FSG_85_0_0_14_18 + (0), 1.0); // slider value + min = real value
	param18 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param18;
	putValue(P_FSG_85_0_0_14, superval, currentPos);
}


on envVar P_FSG_85_0_0_14_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // featureInstallationVPS
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_1,thisval);
}

on envVar P_FSG_85_0_0_14_1 // FSG_Setup.featureInstallationVPS
{
	P_FSG_85_0_0_14_BuildFct();
}

on envVar P_FSG_85_0_0_14_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // featureInstallationParking
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_2,thisval);
}

on envVar P_FSG_85_0_0_14_2_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // featureInstallationParking
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_2);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_14_2,thisval);
}

on envVar P_FSG_85_0_0_14_2_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // featureInstallationParking
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_2);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_14_2,thisval);
}

on envVar P_FSG_85_0_0_14_2_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // featureInstallationParking
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_2);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_85_0_0_14_2,thisval);
}

on envVar P_FSG_85_0_0_14_2_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // featureInstallationParking
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_2);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_85_0_0_14_2,thisval);
}

on envVar P_FSG_85_0_0_14_2_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // featureInstallationParking
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_2);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_85_0_0_14_2,thisval);
}

on envVar P_FSG_85_0_0_14_2_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // featureInstallationParking
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_2);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_85_0_0_14_2,thisval);
}

on envVar P_FSG_85_0_0_14_2 // FSG_Setup.featureInstallationParking
{
	P_FSG_85_0_0_14_BuildFct();
}

on envVar P_FSG_85_0_0_14_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // parkingAssistSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_3,thisval);
}

on envVar P_FSG_85_0_0_14_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // parkingAssistSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_14_3,thisval);
}

on envVar P_FSG_85_0_0_14_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // parkingAssistSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_14_3,thisval);
}

on envVar P_FSG_85_0_0_14_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // parkingAssistSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_3);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_85_0_0_14_3,thisval);
}

on envVar P_FSG_85_0_0_14_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // parkingAssistSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_85_0_0_14_3,thisval);
}

on envVar P_FSG_85_0_0_14_3_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // parkingAssistSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_3);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_85_0_0_14_3,thisval);
}

on envVar P_FSG_85_0_0_14_3_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // parkingAssistSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_3);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_85_0_0_14_3,thisval);
}

on envVar P_FSG_85_0_0_14_3_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // parkingAssistSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_3);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_85_0_0_14_3,thisval);
}

on envVar P_FSG_85_0_0_14_3 // FSG_Setup.parkingAssistSetup
{
	P_FSG_85_0_0_14_BuildFct();
}

on envVar P_FSG_85_0_0_14_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // systemStateSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_4,thisval);
}

on envVar P_FSG_85_0_0_14_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // systemStateSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_14_4,thisval);
}

on envVar P_FSG_85_0_0_14_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // systemStateSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_14_4,thisval);
}

on envVar P_FSG_85_0_0_14_4_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // systemStateSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_4);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_85_0_0_14_4,thisval);
}

on envVar P_FSG_85_0_0_14_4_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // systemStateSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_4);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_85_0_0_14_4,thisval);
}

on envVar P_FSG_85_0_0_14_4_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // systemStateSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_4);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_85_0_0_14_4,thisval);
}

on envVar P_FSG_85_0_0_14_4_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // systemStateSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_4);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_85_0_0_14_4,thisval);
}

on envVar P_FSG_85_0_0_14_4_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // systemStateSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_4);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_85_0_0_14_4,thisval);
}

on envVar P_FSG_85_0_0_14_4 // FSG_Setup.systemStateSetup
{
	P_FSG_85_0_0_14_BuildFct();
}

on envVar P_FSG_85_0_0_14_5_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedViews1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_5);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_5,thisval);
}

on envVar P_FSG_85_0_0_14_5_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedViews1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_5);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_14_5,thisval);
}

on envVar P_FSG_85_0_0_14_5_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedViews1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_5);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_14_5,thisval);
}

on envVar P_FSG_85_0_0_14_5_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedViews1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_5);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_85_0_0_14_5,thisval);
}

on envVar P_FSG_85_0_0_14_5 // FSG_Setup.supportedViews1
{
	P_FSG_85_0_0_14_BuildFct();
}

on envVar P_FSG_85_0_0_14_6_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedRV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_6);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_6,thisval);
}

on envVar P_FSG_85_0_0_14_6_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedRV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_6);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_14_6,thisval);
}

on envVar P_FSG_85_0_0_14_6_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedRV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_6);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_14_6,thisval);
}

on envVar P_FSG_85_0_0_14_6_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedRV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_6);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_85_0_0_14_6,thisval);
}

on envVar P_FSG_85_0_0_14_6_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedRV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_6);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_85_0_0_14_6,thisval);
}

on envVar P_FSG_85_0_0_14_6_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedRV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_6);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_85_0_0_14_6,thisval);
}

on envVar P_FSG_85_0_0_14_6 // FSG_Setup.supportedRV_Modes1
{
	P_FSG_85_0_0_14_BuildFct();
}

on envVar P_FSG_85_0_0_14_7_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedFV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_7);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_7,thisval);
}

on envVar P_FSG_85_0_0_14_7_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedFV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_7);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_14_7,thisval);
}

on envVar P_FSG_85_0_0_14_7_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedFV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_7);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_14_7,thisval);
}

on envVar P_FSG_85_0_0_14_7_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedFV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_7);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_85_0_0_14_7,thisval);
}

on envVar P_FSG_85_0_0_14_7 // FSG_Setup.supportedFV_Modes1
{
	P_FSG_85_0_0_14_BuildFct();
}

on envVar P_FSG_85_0_0_14_8_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedSV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_8);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_8,thisval);
}

on envVar P_FSG_85_0_0_14_8_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedSV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_8);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_14_8,thisval);
}

on envVar P_FSG_85_0_0_14_8_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedSV_Modes1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_8);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_14_8,thisval);
}

on envVar P_FSG_85_0_0_14_8 // FSG_Setup.supportedSV_Modes1
{
	P_FSG_85_0_0_14_BuildFct();
}

on envVar P_FSG_85_0_0_14_9_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedBirdViews
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_9);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_9,thisval);
}

on envVar P_FSG_85_0_0_14_9_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedBirdViews
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_9);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_14_9,thisval);
}

on envVar P_FSG_85_0_0_14_9 // FSG_Setup.supportedBirdViews
{
	P_FSG_85_0_0_14_BuildFct();
}

on envVar P_FSG_85_0_0_14_10_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // maneuverAssistSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_10);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_10,thisval);
}

on envVar P_FSG_85_0_0_14_10_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // maneuverAssistSetup
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_10);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_14_10,thisval);
}

on envVar P_FSG_85_0_0_14_10 // FSG_Setup.maneuverAssistSetup
{
	P_FSG_85_0_0_14_BuildFct();
}

on envVar P_FSG_85_0_0_14_11_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // parkingIndications_Installation
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_14_11);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_14_11,thisval);
}

on envVar P_FSG_85_0_0_14_11 // FSG_Setup.parkingIndications_Installation
{
	P_FSG_85_0_0_14_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_14_12_range // FSG_Setup.Extension2 
{
	@P_FSG_85_0_0_14_12 = @P_FSG_85_0_0_14_12_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_14_12 // FSG_Setup.Extension2
{
	P_FSG_85_0_0_14_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_14_13_range // FSG_Setup.Extension3 
{
	@P_FSG_85_0_0_14_13 = @P_FSG_85_0_0_14_13_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_14_13 // FSG_Setup.Extension3
{
	P_FSG_85_0_0_14_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_14_14_range // FSG_Setup.Extension4 
{
	@P_FSG_85_0_0_14_14 = @P_FSG_85_0_0_14_14_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_14_14 // FSG_Setup.Extension4
{
	P_FSG_85_0_0_14_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_14_15_range // FSG_Setup.Extension5 
{
	@P_FSG_85_0_0_14_15 = @P_FSG_85_0_0_14_15_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_14_15 // FSG_Setup.Extension5
{
	P_FSG_85_0_0_14_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_14_16_range // FSG_Setup.Extension6 
{
	@P_FSG_85_0_0_14_16 = @P_FSG_85_0_0_14_16_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_14_16 // FSG_Setup.Extension6
{
	P_FSG_85_0_0_14_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_14_17_range // FSG_Setup.Extension7 
{
	@P_FSG_85_0_0_14_17 = @P_FSG_85_0_0_14_17_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_14_17 // FSG_Setup.Extension7
{
	P_FSG_85_0_0_14_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_14_18_range // FSG_Setup.Extension8 
{
	@P_FSG_85_0_0_14_18 = @P_FSG_85_0_0_14_18_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_14_18 // FSG_Setup.Extension8
{
	P_FSG_85_0_0_14_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_15_ErrCode
{
       if(gP_FSG_85_0_0_15_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_15", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_15_ErrCode = 1;
}
on envVar P_FSG_85_0_0_15Status_BTN
{
    if (P_FSG_85_0_0_15Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_85_0_0_15_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_15",MakeRGB(255,255,255));
       P_FSG_85_0_0_15Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_85_0_0_15_ID, Data_REQ, getValue(P_FSG_85_0_0_15));
      P_FSG_85_0_0_15Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_85_0_0_15_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_15_ID;
    data[2]=getValue(P_FSG_85_0_0_15_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_15
on envVar P_FSG_85_0_0_15_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_15",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_15",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_15",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_15", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_15",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_15",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_15",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_15", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_85_0_0_15 // bus value of FSG_OperationState (15).
{
	// opcodes: Error-Status
	byte param1; // OP_State
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_85_0_0_15);
	putValue(P_FSG_85_0_0_15_1, param1);
}

on envVar P_FSG_85_0_0_15_1 // FSG_OperationState.OP_State
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // OP_State
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_85_0_0_15);
	superval = thisval;
	putValue(P_FSG_85_0_0_15,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_16_ErrCode
{
       if(gP_FSG_85_0_0_16_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_16", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_16_ErrCode = 1;
}
on envVar P_FSG_85_0_0_16Status_BTN
{
	byte BAPTemp[11];
    if (P_FSG_85_0_0_16Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_85_0_0_16_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_16",MakeRGB(255,255,255));
        P_FSG_85_0_0_16Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_85_0_0_16_BuildFct();
        getValue(P_FSG_85_0_0_16, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_85_0_0_16_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_85_0_0_16));
        if(getValue(P_FSG_85_0_0_16_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_85_0_0_16_ID);
        }
        if(getValue(P_FSG_85_0_0_16_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_85_0_0_16_ID,elCount(BAPTemp));
        }
       P_FSG_85_0_0_16Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_85_0_0_16_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_16_ID;
    data[2]=getValue(P_FSG_85_0_0_16_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_16
on envVar P_FSG_85_0_0_16_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_16",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_16",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_16",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_16", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_16",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_16",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_16",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_16", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_16_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_16_SegmEn,0);
           intertelegram_err(P_FSG_85_0_0_16_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_85_0_0_16_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_16_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_16_IntTlgEn,0);
           sequence_err(P_FSG_85_0_0_16_ID,getValueSize(P_FSG_85_0_0_16_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_85_0_0_16_ID);
       }
}
on envVar P_FSG_85_0_0_16 // bus value of SystemState (16).
{
	// opcodes: Error-Status
	byte param1; // stateParkingModification
	byte param2; // stateParking
	byte param3; // statePLA_IPAModification
	byte param4; // statePLA_IPA
	byte param5; // stateARAModification
	byte param6; // stateARA
	byte param7; // stateAssistanceModification
	byte param8; // stateAssistance
	byte param9; // favoriteListReferenceID
	byte param10; // functionType
	byte param11; // SpotCount
	byte param12; // stateTHAModification
	byte param13; // stateTHA
	byte param14; // stateAPAModification
	byte param15; // stateAPA
	byte param16; // stateRemoteParking_Modification
	byte param17; // stateRemoteParking
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 11; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_16, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_16_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_16_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_85_0_0_16_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_85_0_0_16_4, param4);
	///////// Start param5 - NIBBLE /////////
	param5 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_16_5, param5);
	///////// Start param6 - NIBBLE /////////
	param6 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_16_6, param6);
	///////// Start param7 - NIBBLE /////////
	param7 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_16_7, param7);
	///////// Start param8 - NIBBLE /////////
	param8 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_16_8, param8);
	///////// Start param9 - UINT8 /////////
	param9 = superval[currentPos++];
	putValue(P_FSG_85_0_0_16_9, round((param9 * 1.0) - (1) + (1), 1.0));
	///////// Start param10 - NIBBLE /////////
	param10 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_16_10, param10);
	///////// Start param11 - NIBBLE /////////
	param11 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_16_11, round((param11 * 1.0) - (0) + (0), 1.0));
	///////// Start param12 - NIBBLE /////////
	param12 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_16_12, param12);
	///////// Start param13 - NIBBLE /////////
	param13 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_16_13, param13);
	///////// Start param14 - UINT8 /////////
	param14 = superval[currentPos++];
	putValue(P_FSG_85_0_0_16_14, param14);
	///////// Start param15 - UINT8 /////////
	param15 = superval[currentPos++];
	putValue(P_FSG_85_0_0_16_15, param15);
	///////// Start param16 - NIBBLE /////////
	param16 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_16_16, param16);
	///////// Start param17 - NIBBLE /////////
	param17 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_16_17, param17);
}

// Updates the bus value field and other dependencies.
P_FSG_85_0_0_16_BuildFct()
{
	byte param1; // stateParkingModification
	byte param2; // stateParking
	byte param3; // statePLA_IPAModification
	byte param4; // statePLA_IPA
	byte param5; // stateARAModification
	byte param6; // stateARA
	byte param7; // stateAssistanceModification
	byte param8; // stateAssistance
	byte param9; // favoriteListReferenceID
	byte param10; // functionType
	byte param11; // SpotCount
	byte param12; // stateTHAModification
	byte param13; // stateTHA
	byte param14; // stateAPAModification
	byte param15; // stateAPA
	byte param16; // stateRemoteParking_Modification
	byte param17; // stateRemoteParking

	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_FSG_85_0_0_16_1);
	param1 = param1 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_85_0_0_16_2);
	param2 = param2 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param2;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_85_0_0_16_3);
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_85_0_0_16_4);
	superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_FSG_85_0_0_16_5);
	param5 = param5 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param5<<4);
// gen_BuildFunc_SetSuperVals 
	param6 = getValue(P_FSG_85_0_0_16_6);
	param6 = param6 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param6;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_FSG_85_0_0_16_7);
	param7 = param7 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param7<<4);
// gen_BuildFunc_SetSuperVals 
	param8 = getValue(P_FSG_85_0_0_16_8);
	param8 = param8 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param8;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_16_9_range = round(@P_FSG_85_0_0_16_9 + (1), 1.0); // slider value + min = real value
	param9 = round( (@P_FSG_85_0_0_16_9 + (1) - (1)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param9;
// gen_BuildFunc_SetSuperVals 
	param10 = getValue(P_FSG_85_0_0_16_10);
	param10 = param10 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param10<<4);
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_16_11_range = round(@P_FSG_85_0_0_16_11 + (0), 1.0); // slider value + min = real value
	param11 = round( (@P_FSG_85_0_0_16_11 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	param11 = param11 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param11;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param12 = getValue(P_FSG_85_0_0_16_12);
	param12 = param12 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param12<<4);
// gen_BuildFunc_SetSuperVals 
	param13 = getValue(P_FSG_85_0_0_16_13);
	param13 = param13 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param13;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param14 = getValue(P_FSG_85_0_0_16_14);
	superval[currentPos++]=param14;
// gen_BuildFunc_SetSuperVals 
	param15 = getValue(P_FSG_85_0_0_16_15);
	superval[currentPos++]=param15;
// gen_BuildFunc_SetSuperVals 
	param16 = getValue(P_FSG_85_0_0_16_16);
	param16 = param16 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param16<<4);
// gen_BuildFunc_SetSuperVals 
	param17 = getValue(P_FSG_85_0_0_16_17);
	param17 = param17 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param17;
	currentPos++;
	putValue(P_FSG_85_0_0_16, superval, currentPos);
}


on envVar P_FSG_85_0_0_16_1 // SystemState.stateParkingModification
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_2 // SystemState.stateParking
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_3 // SystemState.statePLA_IPAModification
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_4 // SystemState.statePLA_IPA
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_5 // SystemState.stateARAModification
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_6 // SystemState.stateARA
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_7 // SystemState.stateAssistanceModification
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_8 // SystemState.stateAssistance
{
	P_FSG_85_0_0_16_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_16_9_range // SystemState.favoriteListReferenceID 
{
	@P_FSG_85_0_0_16_9 = @P_FSG_85_0_0_16_9_range - (1); // slider = range - min
}

on envVar P_FSG_85_0_0_16_9 // SystemState.favoriteListReferenceID
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_10 // SystemState.functionType
{
	P_FSG_85_0_0_16_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_16_11_range // SystemState.SpotCount 
{
	@P_FSG_85_0_0_16_11 = @P_FSG_85_0_0_16_11_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_16_11 // SystemState.SpotCount
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_12 // SystemState.stateTHAModification
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_13 // SystemState.stateTHA
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_14 // SystemState.stateAPAModification
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_15 // SystemState.stateAPA
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_16 // SystemState.stateRemoteParking_Modification
{
	P_FSG_85_0_0_16_BuildFct();
}

on envVar P_FSG_85_0_0_16_17 // SystemState.stateRemoteParking
{
	P_FSG_85_0_0_16_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_17_ErrCode
{
       if(gP_FSG_85_0_0_17_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_17", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_17_ErrCode = 1;
}
on envVar P_FSG_85_0_0_17Status_BTN
{
	byte BAPTemp[6];
   if (P_FSG_85_0_0_17Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_85_0_0_17_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_17",MakeRGB(255,255,255));
      P_FSG_85_0_0_17Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_85_0_0_17, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_85_0_0_17_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_85_0_0_17));
      P_FSG_85_0_0_17Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_85_0_0_17_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_17_ID;
    data[2]=getValue(P_FSG_85_0_0_17_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_17
on envVar P_FSG_85_0_0_17_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_17",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_17",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_17",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_17", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_17",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_17",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_17",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_17", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_85_0_0_17 // bus value of FeatureStateVPS (17).
{
	// opcodes: Error-Status
	byte param1; // parkingSpotVisualisationModification
	byte param2; // parkingSpotVisualisation
	byte param3; // Extension1
	byte param4; // Extension2
	byte param5; // Extension3
	byte param6; // Extension4
	byte param7; // Extension5
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[6];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_17, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_17_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_17_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_85_0_0_17_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_85_0_0_17_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_85_0_0_17_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_85_0_0_17_6, round((param6 * 1.0) - (0) + (0), 1.0));
	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_FSG_85_0_0_17_7, round((param7 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_85_0_0_17_1 // FeatureStateVPS.parkingSpotVisualisationModification
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // parkingSpotVisualisationModification
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_FSG_85_0_0_17, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(P_FSG_85_0_0_17,superval);
}

on envVar P_FSG_85_0_0_17_2 // FeatureStateVPS.parkingSpotVisualisation
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // parkingSpotVisualisation
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_FSG_85_0_0_17, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(P_FSG_85_0_0_17,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_17_3_range // FeatureStateVPS.Extension1 
{
	@P_FSG_85_0_0_17_3 = @P_FSG_85_0_0_17_3_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_17_3 // FeatureStateVPS.Extension1
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_17_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_17, superval);
	superval[1]=thisval;
	putValue(P_FSG_85_0_0_17,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_17_4_range // FeatureStateVPS.Extension2 
{
	@P_FSG_85_0_0_17_4 = @P_FSG_85_0_0_17_4_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_17_4 // FeatureStateVPS.Extension2
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_17_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_17, superval);
	superval[2]=thisval;
	putValue(P_FSG_85_0_0_17,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_17_5_range // FeatureStateVPS.Extension3 
{
	@P_FSG_85_0_0_17_5 = @P_FSG_85_0_0_17_5_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_17_5 // FeatureStateVPS.Extension3
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension3
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_17_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_17, superval);
	superval[3]=thisval;
	putValue(P_FSG_85_0_0_17,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_17_6_range // FeatureStateVPS.Extension4 
{
	@P_FSG_85_0_0_17_6 = @P_FSG_85_0_0_17_6_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_17_6 // FeatureStateVPS.Extension4
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension4
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_17_6_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_17, superval);
	superval[4]=thisval;
	putValue(P_FSG_85_0_0_17,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_17_7_range // FeatureStateVPS.Extension5 
{
	@P_FSG_85_0_0_17_7 = @P_FSG_85_0_0_17_7_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_17_7 // FeatureStateVPS.Extension5
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension5
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_17_7_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_17, superval);
	superval[5]=thisval;
	putValue(P_FSG_85_0_0_17,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_18_ErrCode
{
       if(gP_FSG_85_0_0_18_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_18", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_18_ErrCode = 1;
}
on envVar P_FSG_85_0_0_18Status_BTN
{
	byte BAPTemp[11];
    if (P_FSG_85_0_0_18Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_85_0_0_18_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_18",MakeRGB(255,255,255));
        P_FSG_85_0_0_18Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_85_0_0_18_BuildFct();
        getValue(P_FSG_85_0_0_18, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_85_0_0_18_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_85_0_0_18));
        if(getValue(P_FSG_85_0_0_18_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_85_0_0_18_ID);
        }
        if(getValue(P_FSG_85_0_0_18_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_85_0_0_18_ID,elCount(BAPTemp));
        }
       P_FSG_85_0_0_18Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_85_0_0_18_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_18_ID;
    data[2]=getValue(P_FSG_85_0_0_18_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_18
on envVar P_FSG_85_0_0_18_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_18",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_18",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_18",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_18", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_18",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_18",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_18",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_18", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_18_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_18_SegmEn,0);
           intertelegram_err(P_FSG_85_0_0_18_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_85_0_0_18_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_18_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_18_IntTlgEn,0);
           sequence_err(P_FSG_85_0_0_18_ID,getValueSize(P_FSG_85_0_0_18_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_85_0_0_18_ID);
       }
}
on envVar P_FSG_85_0_0_18 // bus value of FeatureStateParking (18).
{
	// opcodes: Error-Status
	byte param1; // offroadModification
	byte param2; // offroad
	byte param3; // APSMuteModification
	byte param4; // APSMute
	byte param5; // autoActivationModification
	byte param6; // autoActivation
	byte param7; // maneuverAssistModification
	byte param8; // maneuverAssist
	byte param9; // RCTA_Modification
	byte param10; // RCTA
	byte param11; // RCTA_BrakingModification
	byte param12; // RCTA_Braking
	byte param13; // PLA_IPATakeOverControl_Modification
	byte param14; // PLA_IPATakeOverControl
	byte param15; // Extension1
	byte param16; // Extension2
	byte param17; // Extension3
	byte param18; // Extension4
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 11; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_18, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_18_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_18_2, param2);
	///////// Start param3 - NIBBLE /////////
	param3 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_18_3, param3);
	///////// Start param4 - NIBBLE /////////
	param4 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_18_4, param4);
	///////// Start param5 - NIBBLE /////////
	param5 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_18_5, param5);
	///////// Start param6 - NIBBLE /////////
	param6 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_18_6, param6);
	///////// Start param7 - NIBBLE /////////
	param7 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_18_7, param7);
	///////// Start param8 - NIBBLE /////////
	param8 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_18_8, param8);
	///////// Start param9 - NIBBLE /////////
	param9 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_18_9, param9);
	///////// Start param10 - NIBBLE /////////
	param10 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_18_10, param10);
	///////// Start param11 - NIBBLE /////////
	param11 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_18_11, param11);
	///////// Start param12 - NIBBLE /////////
	param12 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_18_12, param12);
	///////// Start param13 - NIBBLE /////////
	param13 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_18_13, param13);
	///////// Start param14 - NIBBLE /////////
	param14 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_18_14, param14);
	///////// Start param15 - UINT8 /////////
	param15 = superval[currentPos++];
	putValue(P_FSG_85_0_0_18_15, round((param15 * 1.0) - (0) + (0), 1.0));
	///////// Start param16 - UINT8 /////////
	param16 = superval[currentPos++];
	putValue(P_FSG_85_0_0_18_16, round((param16 * 1.0) - (0) + (0), 1.0));
	///////// Start param17 - UINT8 /////////
	param17 = superval[currentPos++];
	putValue(P_FSG_85_0_0_18_17, round((param17 * 1.0) - (0) + (0), 1.0));
	///////// Start param18 - UINT8 /////////
	param18 = superval[currentPos++];
	putValue(P_FSG_85_0_0_18_18, round((param18 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_FSG_85_0_0_18_BuildFct()
{
	byte param1; // offroadModification
	byte param2; // offroad
	byte param3; // APSMuteModification
	byte param4; // APSMute
	byte param5; // autoActivationModification
	byte param6; // autoActivation
	byte param7; // maneuverAssistModification
	byte param8; // maneuverAssist
	byte param9; // RCTA_Modification
	byte param10; // RCTA
	byte param11; // RCTA_BrakingModification
	byte param12; // RCTA_Braking
	byte param13; // PLA_IPATakeOverControl_Modification
	byte param14; // PLA_IPATakeOverControl
	byte param15; // Extension1
	byte param16; // Extension2
	byte param17; // Extension3
	byte param18; // Extension4

	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_FSG_85_0_0_18_1);
	param1 = param1 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_85_0_0_18_2);
	param2 = param2 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param2;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_85_0_0_18_3);
	param3 = param3 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param3<<4);
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_85_0_0_18_4);
	param4 = param4 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param4;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_FSG_85_0_0_18_5);
	param5 = param5 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param5<<4);
// gen_BuildFunc_SetSuperVals 
	param6 = getValue(P_FSG_85_0_0_18_6);
	param6 = param6 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param6;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_FSG_85_0_0_18_7);
	param7 = param7 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param7<<4);
// gen_BuildFunc_SetSuperVals 
	param8 = getValue(P_FSG_85_0_0_18_8);
	param8 = param8 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param8;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param9 = getValue(P_FSG_85_0_0_18_9);
	param9 = param9 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param9<<4);
// gen_BuildFunc_SetSuperVals 
	param10 = getValue(P_FSG_85_0_0_18_10);
	param10 = param10 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param10;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param11 = getValue(P_FSG_85_0_0_18_11);
	param11 = param11 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param11<<4);
// gen_BuildFunc_SetSuperVals 
	param12 = getValue(P_FSG_85_0_0_18_12);
	param12 = param12 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param12;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param13 = getValue(P_FSG_85_0_0_18_13);
	param13 = param13 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param13<<4);
// gen_BuildFunc_SetSuperVals 
	param14 = getValue(P_FSG_85_0_0_18_14);
	param14 = param14 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param14;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_18_15_range = round(@P_FSG_85_0_0_18_15 + (0), 1.0); // slider value + min = real value
	param15 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param15;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_18_16_range = round(@P_FSG_85_0_0_18_16 + (0), 1.0); // slider value + min = real value
	param16 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param16;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_18_17_range = round(@P_FSG_85_0_0_18_17 + (0), 1.0); // slider value + min = real value
	param17 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param17;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_18_18_range = round(@P_FSG_85_0_0_18_18 + (0), 1.0); // slider value + min = real value
	param18 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param18;
	putValue(P_FSG_85_0_0_18, superval, currentPos);
}


on envVar P_FSG_85_0_0_18_1 // FeatureStateParking.offroadModification
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_2 // FeatureStateParking.offroad
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_3 // FeatureStateParking.APSMuteModification
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_4 // FeatureStateParking.APSMute
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_5 // FeatureStateParking.autoActivationModification
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_6 // FeatureStateParking.autoActivation
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_7 // FeatureStateParking.maneuverAssistModification
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_8 // FeatureStateParking.maneuverAssist
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_9 // FeatureStateParking.RCTA_Modification
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_10 // FeatureStateParking.RCTA
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_11 // FeatureStateParking.RCTA_BrakingModification
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_12 // FeatureStateParking.RCTA_Braking
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_13 // FeatureStateParking.PLA_IPATakeOverControl_Modification
{
	P_FSG_85_0_0_18_BuildFct();
}

on envVar P_FSG_85_0_0_18_14 // FeatureStateParking.PLA_IPATakeOverControl
{
	P_FSG_85_0_0_18_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_18_15_range // FeatureStateParking.Extension1 
{
	@P_FSG_85_0_0_18_15 = @P_FSG_85_0_0_18_15_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_18_15 // FeatureStateParking.Extension1
{
	P_FSG_85_0_0_18_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_18_16_range // FeatureStateParking.Extension2 
{
	@P_FSG_85_0_0_18_16 = @P_FSG_85_0_0_18_16_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_18_16 // FeatureStateParking.Extension2
{
	P_FSG_85_0_0_18_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_18_17_range // FeatureStateParking.Extension3 
{
	@P_FSG_85_0_0_18_17 = @P_FSG_85_0_0_18_17_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_18_17 // FeatureStateParking.Extension3
{
	P_FSG_85_0_0_18_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_18_18_range // FeatureStateParking.Extension4 
{
	@P_FSG_85_0_0_18_18 = @P_FSG_85_0_0_18_18_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_18_18 // FeatureStateParking.Extension4
{
	P_FSG_85_0_0_18_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_19_ErrCode
{
       if(gP_FSG_85_0_0_19_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_19", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_19_ErrCode = 1;
}
on envVar P_FSG_85_0_0_19Status_BTN
{
	byte BAPTemp[11];
    if (P_FSG_85_0_0_19Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_85_0_0_19_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_19",MakeRGB(255,255,255));
        P_FSG_85_0_0_19Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_85_0_0_19_BuildFct();
        getValue(P_FSG_85_0_0_19, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_85_0_0_19_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_85_0_0_19));
        if(getValue(P_FSG_85_0_0_19_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_85_0_0_19_ID);
        }
        if(getValue(P_FSG_85_0_0_19_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_85_0_0_19_ID,elCount(BAPTemp));
        }
       P_FSG_85_0_0_19Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_85_0_0_19_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_19_ID;
    data[2]=getValue(P_FSG_85_0_0_19_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_19
on envVar P_FSG_85_0_0_19_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_19",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_19",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_19",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_19", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_19",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_19",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_19",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_19", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_19_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_19_SegmEn,0);
           intertelegram_err(P_FSG_85_0_0_19_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_85_0_0_19_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_19_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_19_IntTlgEn,0);
           sequence_err(P_FSG_85_0_0_19_ID,getValueSize(P_FSG_85_0_0_19_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_85_0_0_19_ID);
       }
}
on envVar P_FSG_85_0_0_19 // bus value of ViewRequest (19).
{
	// opcodes: Error-Status
	byte param1; // TAID
	byte param2; // OPS
	byte param3; // VPS
	byte param4; // VPSBirdView
	byte param5; // VPSMode
	byte param6; // PLA_IPA
	byte param7; // ARA
	byte param8; // CTA
	byte param9; // Assistance
	byte param10; // TPA
	byte param11; // Extension2
	byte param12; // Extension3
	byte param13; // Extension4
	byte param14; // Extension5
	byte param15; // Extension6
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 11; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_19, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_19_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_19_2, param2);
	///////// Start param3 - NIBBLE /////////
	param3 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_19_3, param3);
	///////// Start param4 - NIBBLE /////////
	param4 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_19_4, param4);
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_85_0_0_19_5, param5);
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_85_0_0_19_6, param6);
	///////// Start param7 - NIBBLE /////////
	param7 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_19_7, param7);
	///////// Start param8 - NIBBLE /////////
	param8 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_19_8, param8);
	///////// Start param9 - NIBBLE /////////
	param9 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_19_9, param9);
	///////// Start param10 - NIBBLE /////////
	param10 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_19_10, param10);
	///////// Start param11 - UINT8 /////////
	param11 = superval[currentPos++];
	putValue(P_FSG_85_0_0_19_11, round((param11 * 1.0) - (0) + (0), 1.0));
	///////// Start param12 - UINT8 /////////
	param12 = superval[currentPos++];
	putValue(P_FSG_85_0_0_19_12, round((param12 * 1.0) - (0) + (0), 1.0));
	///////// Start param13 - UINT8 /////////
	param13 = superval[currentPos++];
	putValue(P_FSG_85_0_0_19_13, round((param13 * 1.0) - (0) + (0), 1.0));
	///////// Start param14 - UINT8 /////////
	param14 = superval[currentPos++];
	putValue(P_FSG_85_0_0_19_14, round((param14 * 1.0) - (0) + (0), 1.0));
	///////// Start param15 - UINT8 /////////
	param15 = superval[currentPos++];
	putValue(P_FSG_85_0_0_19_15, round((param15 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_FSG_85_0_0_19_BuildFct()
{
	byte param1; // TAID
	byte param2; // OPS
	byte param3; // VPS
	byte param4; // VPSBirdView
	byte param5; // VPSMode
	byte param6; // PLA_IPA
	byte param7; // ARA
	byte param8; // CTA
	byte param9; // Assistance
	byte param10; // TPA
	byte param11; // Extension2
	byte param12; // Extension3
	byte param13; // Extension4
	byte param14; // Extension5
	byte param15; // Extension6

	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_19_1_range = round(@P_FSG_85_0_0_19_1 + (0), 1.0); // slider value + min = real value
	param1 = round( (@P_FSG_85_0_0_19_1 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	param1 = param1 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_85_0_0_19_2);
	param2 = param2 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param2;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_85_0_0_19_3);
	param3 = param3 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param3<<4);
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_85_0_0_19_4);
	param4 = param4 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param4;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_FSG_85_0_0_19_5);
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	param6 = getValue(P_FSG_85_0_0_19_6);
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_FSG_85_0_0_19_7);
	param7 = param7 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param7<<4);
// gen_BuildFunc_SetSuperVals 
	param8 = getValue(P_FSG_85_0_0_19_8);
	param8 = param8 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param8;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param9 = getValue(P_FSG_85_0_0_19_9);
	param9 = param9 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param9<<4);
// gen_BuildFunc_SetSuperVals 
	param10 = getValue(P_FSG_85_0_0_19_10);
	param10 = param10 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param10;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_19_11_range = round(@P_FSG_85_0_0_19_11 + (0), 1.0); // slider value + min = real value
	param11 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param11;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_19_12_range = round(@P_FSG_85_0_0_19_12 + (0), 1.0); // slider value + min = real value
	param12 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param12;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_19_13_range = round(@P_FSG_85_0_0_19_13 + (0), 1.0); // slider value + min = real value
	param13 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param13;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_19_14_range = round(@P_FSG_85_0_0_19_14 + (0), 1.0); // slider value + min = real value
	param14 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param14;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_19_15_range = round(@P_FSG_85_0_0_19_15 + (0), 1.0); // slider value + min = real value
	param15 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param15;
	putValue(P_FSG_85_0_0_19, superval, currentPos);
}


// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_19_1_range // ViewRequest.TAID 
{
	@P_FSG_85_0_0_19_1 = @P_FSG_85_0_0_19_1_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_19_1 // ViewRequest.TAID
{
	P_FSG_85_0_0_19_BuildFct();
}

on envVar P_FSG_85_0_0_19_2 // ViewRequest.OPS
{
	P_FSG_85_0_0_19_BuildFct();
}

on envVar P_FSG_85_0_0_19_3 // ViewRequest.VPS
{
	P_FSG_85_0_0_19_BuildFct();
}

on envVar P_FSG_85_0_0_19_4 // ViewRequest.VPSBirdView
{
	P_FSG_85_0_0_19_BuildFct();
}

on envVar P_FSG_85_0_0_19_5 // ViewRequest.VPSMode
{
	P_FSG_85_0_0_19_BuildFct();
}

on envVar P_FSG_85_0_0_19_6 // ViewRequest.PLA_IPA
{
	P_FSG_85_0_0_19_BuildFct();
}

on envVar P_FSG_85_0_0_19_7 // ViewRequest.ARA
{
	P_FSG_85_0_0_19_BuildFct();
}

on envVar P_FSG_85_0_0_19_8 // ViewRequest.CTA
{
	P_FSG_85_0_0_19_BuildFct();
}

on envVar P_FSG_85_0_0_19_9 // ViewRequest.Assistance
{
	P_FSG_85_0_0_19_BuildFct();
}

on envVar P_FSG_85_0_0_19_10 // ViewRequest.TPA
{
	P_FSG_85_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_19_11_range // ViewRequest.Extension2 
{
	@P_FSG_85_0_0_19_11 = @P_FSG_85_0_0_19_11_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_19_11 // ViewRequest.Extension2
{
	P_FSG_85_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_19_12_range // ViewRequest.Extension3 
{
	@P_FSG_85_0_0_19_12 = @P_FSG_85_0_0_19_12_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_19_12 // ViewRequest.Extension3
{
	P_FSG_85_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_19_13_range // ViewRequest.Extension4 
{
	@P_FSG_85_0_0_19_13 = @P_FSG_85_0_0_19_13_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_19_13 // ViewRequest.Extension4
{
	P_FSG_85_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_19_14_range // ViewRequest.Extension5 
{
	@P_FSG_85_0_0_19_14 = @P_FSG_85_0_0_19_14_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_19_14 // ViewRequest.Extension5
{
	P_FSG_85_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_19_15_range // ViewRequest.Extension6 
{
	@P_FSG_85_0_0_19_15 = @P_FSG_85_0_0_19_15_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_19_15 // ViewRequest.Extension6
{
	P_FSG_85_0_0_19_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_20_ErrCode
{
       if(gP_FSG_85_0_0_20_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_20", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_20_ErrCode = 1;
}
on envVar P_FSG_85_0_0_20Status_BTN
{
	byte BAPTemp[11];
    if (P_FSG_85_0_0_20Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_85_0_0_20_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_20",MakeRGB(255,255,255));
        P_FSG_85_0_0_20Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_85_0_0_20_BuildFct();
        getValue(P_FSG_85_0_0_20, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_85_0_0_20_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_85_0_0_20));
        if(getValue(P_FSG_85_0_0_20_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_85_0_0_20_ID);
        }
        if(getValue(P_FSG_85_0_0_20_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_85_0_0_20_ID,elCount(BAPTemp));
        }
       P_FSG_85_0_0_20Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_85_0_0_20_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_20_ID;
    data[2]=getValue(P_FSG_85_0_0_20_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_20
on envVar P_FSG_85_0_0_20_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_20",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_20",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_20",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_20", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_20",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_20",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_20",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_20", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_20_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_20_SegmEn,0);
           intertelegram_err(P_FSG_85_0_0_20_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_85_0_0_20_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_20_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_20_IntTlgEn,0);
           sequence_err(P_FSG_85_0_0_20_ID,getValueSize(P_FSG_85_0_0_20_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_85_0_0_20_ID);
       }
}
on envVar P_FSG_85_0_0_20 // bus value of ViewAvailability (20).
{
	// opcodes: Error-Status
	byte param1; // Extension1
	byte param2; // availableOPS
	byte param3; // availableVPS
	byte param4; // availableVPSMode1
	byte param5; // availableVPSMode2
	byte param6; // availableCTA
	byte param7; // availableVPSBirdView
	byte param8; // availableAssistance
	byte param9; // Extension2
	byte param10; // Extension3
	byte param11; // Extension4
	byte param12; // Extension5
	byte param13; // Extension6
	byte param14; // Extension7
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 11; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_20, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_20_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_20_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_85_0_0_20_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_85_0_0_20_4, param4);
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_85_0_0_20_5, param5);
	///////// Start param6 - NIBBLE /////////
	param6 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_20_6, param6);
	///////// Start param7 - NIBBLE /////////
	param7 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_20_7, param7);
	///////// Start param8 - NIBBLE /////////
	param8 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_20_8, param8);
	///////// Start param9 - NIBBLE /////////
	param9 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_20_9, round((param9 * 1.0) - (0) + (0), 1.0));
	///////// Start param10 - UINT8 /////////
	param10 = superval[currentPos++];
	putValue(P_FSG_85_0_0_20_10, round((param10 * 1.0) - (0) + (0), 1.0));
	///////// Start param11 - UINT8 /////////
	param11 = superval[currentPos++];
	putValue(P_FSG_85_0_0_20_11, round((param11 * 1.0) - (0) + (0), 1.0));
	///////// Start param12 - UINT8 /////////
	param12 = superval[currentPos++];
	putValue(P_FSG_85_0_0_20_12, round((param12 * 1.0) - (0) + (0), 1.0));
	///////// Start param13 - UINT8 /////////
	param13 = superval[currentPos++];
	putValue(P_FSG_85_0_0_20_13, round((param13 * 1.0) - (0) + (0), 1.0));
	///////// Start param14 - UINT8 /////////
	param14 = superval[currentPos++];
	putValue(P_FSG_85_0_0_20_14, round((param14 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_FSG_85_0_0_20_BuildFct()
{
	byte param1; // Extension1
	byte param2; // availableOPS
	byte param3; // availableVPS
	byte param4; // availableVPSMode1
	byte param5; // availableVPSMode2
	byte param6; // availableCTA
	byte param7; // availableVPSBirdView
	byte param8; // availableAssistance
	byte param9; // Extension2
	byte param10; // Extension3
	byte param11; // Extension4
	byte param12; // Extension5
	byte param13; // Extension6
	byte param14; // Extension7

	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_20_1_range = round(@P_FSG_85_0_0_20_1 + (0), 1.0); // slider value + min = real value
	param1 = 0; // underlying parameter has constant value 0.0.
	param1 = param1 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_85_0_0_20_2);
	param2=param2& 0x0f;
	@P_FSG_85_0_0_20_2_0 = (param2 & 1) > 0;
	param2 = param2 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param2;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_85_0_0_20_3);
	@P_FSG_85_0_0_20_3_0 = (param3 & 1) > 0;
	@P_FSG_85_0_0_20_3_1 = (param3 & 2) > 0;
	@P_FSG_85_0_0_20_3_2 = (param3 & 4) > 0;
	@P_FSG_85_0_0_20_3_3 = (param3 & 8) > 0;
	@P_FSG_85_0_0_20_3_4 = (param3 & 16) > 0;
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_85_0_0_20_4);
	@P_FSG_85_0_0_20_4_0 = (param4 & 1) > 0;
	@P_FSG_85_0_0_20_4_1 = (param4 & 2) > 0;
	@P_FSG_85_0_0_20_4_2 = (param4 & 4) > 0;
	@P_FSG_85_0_0_20_4_3 = (param4 & 8) > 0;
	@P_FSG_85_0_0_20_4_4 = (param4 & 16) > 0;
	@P_FSG_85_0_0_20_4_5 = (param4 & 32) > 0;
	@P_FSG_85_0_0_20_4_6 = (param4 & 64) > 0;
	@P_FSG_85_0_0_20_4_7 = (param4 & 128) > 0;
	superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_FSG_85_0_0_20_5);
	@P_FSG_85_0_0_20_5_0 = (param5 & 1) > 0;
	@P_FSG_85_0_0_20_5_1 = (param5 & 2) > 0;
	@P_FSG_85_0_0_20_5_2 = (param5 & 4) > 0;
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	param6 = getValue(P_FSG_85_0_0_20_6);
	param6=param6& 0x0f;
	@P_FSG_85_0_0_20_6_0 = (param6 & 1) > 0;
	@P_FSG_85_0_0_20_6_1 = (param6 & 2) > 0;
	param6 = param6 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param6<<4);
// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_FSG_85_0_0_20_7);
	param7=param7& 0x0f;
	@P_FSG_85_0_0_20_7_0 = (param7 & 1) > 0;
	@P_FSG_85_0_0_20_7_1 = (param7 & 2) > 0;
	param7 = param7 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param7;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param8 = getValue(P_FSG_85_0_0_20_8);
	param8=param8& 0x0f;
	@P_FSG_85_0_0_20_8_0 = (param8 & 1) > 0;
	param8 = param8 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param8<<4);
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_20_9_range = round(@P_FSG_85_0_0_20_9 + (0), 1.0); // slider value + min = real value
	param9 = 0; // underlying parameter has constant value 0.0.
	param9 = param9 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param9;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_20_10_range = round(@P_FSG_85_0_0_20_10 + (0), 1.0); // slider value + min = real value
	param10 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param10;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_20_11_range = round(@P_FSG_85_0_0_20_11 + (0), 1.0); // slider value + min = real value
	param11 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param11;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_20_12_range = round(@P_FSG_85_0_0_20_12 + (0), 1.0); // slider value + min = real value
	param12 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param12;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_20_13_range = round(@P_FSG_85_0_0_20_13 + (0), 1.0); // slider value + min = real value
	param13 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param13;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_20_14_range = round(@P_FSG_85_0_0_20_14 + (0), 1.0); // slider value + min = real value
	param14 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param14;
	putValue(P_FSG_85_0_0_20, superval, currentPos);
}


// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_20_1_range // ViewAvailability.Extension1 
{
	@P_FSG_85_0_0_20_1 = @P_FSG_85_0_0_20_1_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_20_1 // ViewAvailability.Extension1
{
	P_FSG_85_0_0_20_BuildFct();
}

on envVar P_FSG_85_0_0_20_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableOPS
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_20_2,thisval);
}

on envVar P_FSG_85_0_0_20_2 // ViewAvailability.availableOPS
{
	P_FSG_85_0_0_20_BuildFct();
}

on envVar P_FSG_85_0_0_20_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPS
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_20_3,thisval);
}

on envVar P_FSG_85_0_0_20_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPS
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_20_3,thisval);
}

on envVar P_FSG_85_0_0_20_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPS
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_20_3,thisval);
}

on envVar P_FSG_85_0_0_20_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPS
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_3);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_85_0_0_20_3,thisval);
}

on envVar P_FSG_85_0_0_20_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPS
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_85_0_0_20_3,thisval);
}

on envVar P_FSG_85_0_0_20_3 // ViewAvailability.availableVPS
{
	P_FSG_85_0_0_20_BuildFct();
}

on envVar P_FSG_85_0_0_20_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_20_4,thisval);
}

on envVar P_FSG_85_0_0_20_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_20_4,thisval);
}

on envVar P_FSG_85_0_0_20_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_20_4,thisval);
}

on envVar P_FSG_85_0_0_20_4_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_4);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_85_0_0_20_4,thisval);
}

on envVar P_FSG_85_0_0_20_4_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_4);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_85_0_0_20_4,thisval);
}

on envVar P_FSG_85_0_0_20_4_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_4);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_85_0_0_20_4,thisval);
}

on envVar P_FSG_85_0_0_20_4_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_4);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_85_0_0_20_4,thisval);
}

on envVar P_FSG_85_0_0_20_4_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_4);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_85_0_0_20_4,thisval);
}

on envVar P_FSG_85_0_0_20_4 // ViewAvailability.availableVPSMode1
{
	P_FSG_85_0_0_20_BuildFct();
}

on envVar P_FSG_85_0_0_20_5_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode2
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_5);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_20_5,thisval);
}

on envVar P_FSG_85_0_0_20_5_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode2
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_5);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_20_5,thisval);
}

on envVar P_FSG_85_0_0_20_5_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSMode2
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_5);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_20_5,thisval);
}

on envVar P_FSG_85_0_0_20_5 // ViewAvailability.availableVPSMode2
{
	P_FSG_85_0_0_20_BuildFct();
}

on envVar P_FSG_85_0_0_20_6_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableCTA
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_6);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_20_6,thisval);
}

on envVar P_FSG_85_0_0_20_6_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableCTA
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_6);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_20_6,thisval);
}

on envVar P_FSG_85_0_0_20_6 // ViewAvailability.availableCTA
{
	P_FSG_85_0_0_20_BuildFct();
}

on envVar P_FSG_85_0_0_20_7_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSBirdView
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_7);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_20_7,thisval);
}

on envVar P_FSG_85_0_0_20_7_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableVPSBirdView
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_7);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_20_7,thisval);
}

on envVar P_FSG_85_0_0_20_7 // ViewAvailability.availableVPSBirdView
{
	P_FSG_85_0_0_20_BuildFct();
}

on envVar P_FSG_85_0_0_20_8_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // availableAssistance
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_20_8);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_20_8,thisval);
}

on envVar P_FSG_85_0_0_20_8 // ViewAvailability.availableAssistance
{
	P_FSG_85_0_0_20_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_20_9_range // ViewAvailability.Extension2 
{
	@P_FSG_85_0_0_20_9 = @P_FSG_85_0_0_20_9_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_20_9 // ViewAvailability.Extension2
{
	P_FSG_85_0_0_20_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_20_10_range // ViewAvailability.Extension3 
{
	@P_FSG_85_0_0_20_10 = @P_FSG_85_0_0_20_10_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_20_10 // ViewAvailability.Extension3
{
	P_FSG_85_0_0_20_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_20_11_range // ViewAvailability.Extension4 
{
	@P_FSG_85_0_0_20_11 = @P_FSG_85_0_0_20_11_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_20_11 // ViewAvailability.Extension4
{
	P_FSG_85_0_0_20_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_20_12_range // ViewAvailability.Extension5 
{
	@P_FSG_85_0_0_20_12 = @P_FSG_85_0_0_20_12_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_20_12 // ViewAvailability.Extension5
{
	P_FSG_85_0_0_20_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_20_13_range // ViewAvailability.Extension6 
{
	@P_FSG_85_0_0_20_13 = @P_FSG_85_0_0_20_13_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_20_13 // ViewAvailability.Extension6
{
	P_FSG_85_0_0_20_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_20_14_range // ViewAvailability.Extension7 
{
	@P_FSG_85_0_0_20_14 = @P_FSG_85_0_0_20_14_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_20_14 // ViewAvailability.Extension7
{
	P_FSG_85_0_0_20_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_21_ErrCode
{
       if(gP_FSG_85_0_0_21_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_21", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_21_ErrCode = 1;
}
on envVar P_FSG_85_0_0_21_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_21_ID;
    data[2]=getValue(P_FSG_85_0_0_21_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_21
on envVar P_FSG_85_0_0_21_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_21",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_21",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_21",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_21", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_21",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_21",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_21",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_21", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_85_0_0_21 // bus value of ViewSwitch (21).
{
	// opcodes: Set
	byte param1; // Extension1
	byte param2; // OPS
	byte param3; // VPS
	byte param4; // VPSBirdView
	byte param5; // VPSMode
	byte param6; // PLA_IPA
	byte param7; // ARA
	byte param8; // CTA
	byte param9; // Assistance
	byte param10; // TPA
	byte param11; // Extension3
	byte param12; // Extension4
	byte param13; // Extension5
	byte param14; // Extension6
	byte param15; // Extension7
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 11; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_21, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_21_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_21_2, param2);
	///////// Start param3 - NIBBLE /////////
	param3 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_21_3, param3);
	///////// Start param4 - NIBBLE /////////
	param4 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_21_4, param4);
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_85_0_0_21_5, param5);
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_85_0_0_21_6, param6);
	///////// Start param7 - NIBBLE /////////
	param7 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_21_7, param7);
	///////// Start param8 - NIBBLE /////////
	param8 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_21_8, param8);
	///////// Start param9 - NIBBLE /////////
	param9 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_21_9, param9);
	///////// Start param10 - NIBBLE /////////
	param10 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_21_10, param10);
	///////// Start param11 - UINT8 /////////
	param11 = superval[currentPos++];
	putValue(P_FSG_85_0_0_21_11, round((param11 * 1.0) - (0) + (0), 1.0));
	///////// Start param12 - UINT8 /////////
	param12 = superval[currentPos++];
	putValue(P_FSG_85_0_0_21_12, round((param12 * 1.0) - (0) + (0), 1.0));
	///////// Start param13 - UINT8 /////////
	param13 = superval[currentPos++];
	putValue(P_FSG_85_0_0_21_13, round((param13 * 1.0) - (0) + (0), 1.0));
	///////// Start param14 - UINT8 /////////
	param14 = superval[currentPos++];
	putValue(P_FSG_85_0_0_21_14, round((param14 * 1.0) - (0) + (0), 1.0));
	///////// Start param15 - UINT8 /////////
	param15 = superval[currentPos++];
	putValue(P_FSG_85_0_0_21_15, round((param15 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_FSG_85_0_0_21_BuildFct()
{
	byte param1; // Extension1
	byte param2; // OPS
	byte param3; // VPS
	byte param4; // VPSBirdView
	byte param5; // VPSMode
	byte param6; // PLA_IPA
	byte param7; // ARA
	byte param8; // CTA
	byte param9; // Assistance
	byte param10; // TPA
	byte param11; // Extension3
	byte param12; // Extension4
	byte param13; // Extension5
	byte param14; // Extension6
	byte param15; // Extension7

	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_21_1_range = round(@P_FSG_85_0_0_21_1 + (0), 1.0); // slider value + min = real value
	param1 = 0; // underlying parameter has constant value 0.0.
	param1 = param1 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_85_0_0_21_2);
	param2 = param2 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param2;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_85_0_0_21_3);
	param3 = param3 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param3<<4);
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_85_0_0_21_4);
	param4 = param4 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param4;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_FSG_85_0_0_21_5);
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	param6 = getValue(P_FSG_85_0_0_21_6);
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_FSG_85_0_0_21_7);
	param7 = param7 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param7<<4);
// gen_BuildFunc_SetSuperVals 
	param8 = getValue(P_FSG_85_0_0_21_8);
	param8 = param8 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param8;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param9 = getValue(P_FSG_85_0_0_21_9);
	param9 = param9 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param9<<4);
// gen_BuildFunc_SetSuperVals 
	param10 = getValue(P_FSG_85_0_0_21_10);
	param10 = param10 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param10;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_21_11_range = round(@P_FSG_85_0_0_21_11 + (0), 1.0); // slider value + min = real value
	param11 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param11;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_21_12_range = round(@P_FSG_85_0_0_21_12 + (0), 1.0); // slider value + min = real value
	param12 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param12;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_21_13_range = round(@P_FSG_85_0_0_21_13 + (0), 1.0); // slider value + min = real value
	param13 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param13;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_21_14_range = round(@P_FSG_85_0_0_21_14 + (0), 1.0); // slider value + min = real value
	param14 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param14;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_21_15_range = round(@P_FSG_85_0_0_21_15 + (0), 1.0); // slider value + min = real value
	param15 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param15;
	putValue(P_FSG_85_0_0_21, superval, currentPos);
}


// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_21_1_range // ViewSwitch.Extension1 
{
	@P_FSG_85_0_0_21_1 = @P_FSG_85_0_0_21_1_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_21_1 // ViewSwitch.Extension1
{
	P_FSG_85_0_0_21_BuildFct();
}

on envVar P_FSG_85_0_0_21_2 // ViewSwitch.OPS
{
	P_FSG_85_0_0_21_BuildFct();
}

on envVar P_FSG_85_0_0_21_3 // ViewSwitch.VPS
{
	P_FSG_85_0_0_21_BuildFct();
}

on envVar P_FSG_85_0_0_21_4 // ViewSwitch.VPSBirdView
{
	P_FSG_85_0_0_21_BuildFct();
}

on envVar P_FSG_85_0_0_21_5 // ViewSwitch.VPSMode
{
	P_FSG_85_0_0_21_BuildFct();
}

on envVar P_FSG_85_0_0_21_6 // ViewSwitch.PLA_IPA
{
	P_FSG_85_0_0_21_BuildFct();
}

on envVar P_FSG_85_0_0_21_7 // ViewSwitch.ARA
{
	P_FSG_85_0_0_21_BuildFct();
}

on envVar P_FSG_85_0_0_21_8 // ViewSwitch.CTA
{
	P_FSG_85_0_0_21_BuildFct();
}

on envVar P_FSG_85_0_0_21_9 // ViewSwitch.Assistance
{
	P_FSG_85_0_0_21_BuildFct();
}

on envVar P_FSG_85_0_0_21_10 // ViewSwitch.TPA
{
	P_FSG_85_0_0_21_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_21_11_range // ViewSwitch.Extension3 
{
	@P_FSG_85_0_0_21_11 = @P_FSG_85_0_0_21_11_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_21_11 // ViewSwitch.Extension3
{
	P_FSG_85_0_0_21_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_21_12_range // ViewSwitch.Extension4 
{
	@P_FSG_85_0_0_21_12 = @P_FSG_85_0_0_21_12_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_21_12 // ViewSwitch.Extension4
{
	P_FSG_85_0_0_21_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_21_13_range // ViewSwitch.Extension5 
{
	@P_FSG_85_0_0_21_13 = @P_FSG_85_0_0_21_13_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_21_13 // ViewSwitch.Extension5
{
	P_FSG_85_0_0_21_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_21_14_range // ViewSwitch.Extension6 
{
	@P_FSG_85_0_0_21_14 = @P_FSG_85_0_0_21_14_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_21_14 // ViewSwitch.Extension6
{
	P_FSG_85_0_0_21_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_21_15_range // ViewSwitch.Extension7 
{
	@P_FSG_85_0_0_21_15 = @P_FSG_85_0_0_21_15_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_21_15 // ViewSwitch.Extension7
{
	P_FSG_85_0_0_21_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_22_ErrCode
{
       if(gP_FSG_85_0_0_22_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_22", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_22_ErrCode = 1;
}
on envVar P_FSG_85_0_0_22_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_22_ID;
    data[2]=getValue(P_FSG_85_0_0_22_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_22
on envVar P_FSG_85_0_0_22_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_22",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_22",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_22",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_22", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_22",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_22",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_22",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_22", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_85_0_0_22 // bus value of ViewState (22).
{
	// opcodes: Set
	byte param1; // TAID
	byte param2; // visibility
	byte param3; // Extension1
	byte param4; // Extension2
	byte param5; // Extension3
	byte param6; // Extension4
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[5];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_22, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_22_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_22_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_85_0_0_22_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_85_0_0_22_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_85_0_0_22_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_85_0_0_22_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_22_1_range // ViewState.TAID 
{
	@P_FSG_85_0_0_22_1 = @P_FSG_85_0_0_22_1_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_22_1 // ViewState.TAID
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@P_FSG_85_0_0_22_1, 1.0);
	@P_FSG_85_0_0_22_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_22, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(P_FSG_85_0_0_22,superval);
}

on envVar P_FSG_85_0_0_22_2 // ViewState.visibility
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // visibility
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_FSG_85_0_0_22, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(P_FSG_85_0_0_22,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_22_3_range // ViewState.Extension1 
{
	@P_FSG_85_0_0_22_3 = @P_FSG_85_0_0_22_3_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_22_3 // ViewState.Extension1
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_22_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_22, superval);
	superval[1]=thisval;
	putValue(P_FSG_85_0_0_22,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_22_4_range // ViewState.Extension2 
{
	@P_FSG_85_0_0_22_4 = @P_FSG_85_0_0_22_4_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_22_4 // ViewState.Extension2
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // Extension2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_22_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_22, superval);
	superval[2]=thisval;
	putValue(P_FSG_85_0_0_22,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_22_5_range // ViewState.Extension3 
{
	@P_FSG_85_0_0_22_5 = @P_FSG_85_0_0_22_5_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_22_5 // ViewState.Extension3
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // Extension3
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_22_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_22, superval);
	superval[3]=thisval;
	putValue(P_FSG_85_0_0_22,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_22_6_range // ViewState.Extension4 
{
	@P_FSG_85_0_0_22_6 = @P_FSG_85_0_0_22_6_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_22_6 // ViewState.Extension4
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // Extension4
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_22_6_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_22, superval);
	superval[4]=thisval;
	putValue(P_FSG_85_0_0_22,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_23_ErrCode
{
       if(gP_FSG_85_0_0_23_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_23", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_23_ErrCode = 1;
}
on envVar P_FSG_85_0_0_23Status_BTN
{
	byte BAPTemp[5];
   if (P_FSG_85_0_0_23Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_85_0_0_23_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_23",MakeRGB(255,255,255));
      P_FSG_85_0_0_23Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_85_0_0_23, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_85_0_0_23_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_85_0_0_23));
      P_FSG_85_0_0_23Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_85_0_0_23_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_23_ID;
    data[2]=getValue(P_FSG_85_0_0_23_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_23
on envVar P_FSG_85_0_0_23_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_23",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_23",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_23",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_23", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_23",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_23",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_23",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_23", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_85_0_0_23 // bus value of ParkingIndications (23).
{
	// opcodes: Error-Status
	byte param1; // disclaimer
	byte param2; // legalIndications
	byte param3; // THA_Messages
	byte param4; // functionState
	byte param5; // TPASpotAvailability
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[5];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_23, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_85_0_0_23_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_85_0_0_23_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_85_0_0_23_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_85_0_0_23_4, param4);
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_85_0_0_23_5, param5);
}

on envVar P_FSG_85_0_0_23_1 // ParkingIndications.disclaimer
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // disclaimer
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_85_0_0_23, superval);
	superval[0]=thisval;
	putValue(P_FSG_85_0_0_23,superval);
}

on envVar P_FSG_85_0_0_23_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // legalIndications
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_23_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_23_2,thisval);
}

on envVar P_FSG_85_0_0_23_2 // ParkingIndications.legalIndications
{
	byte superval[5];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // legalIndications
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_85_0_0_23_2_0, 1);
	else
		putValue(P_FSG_85_0_0_23_2_0, 0);

    // Update superval
	getValue(P_FSG_85_0_0_23, superval);
	superval[1]=thisval;
	putValue(P_FSG_85_0_0_23,superval);
}

on envVar P_FSG_85_0_0_23_3 // ParkingIndications.THA_Messages
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // THA_Messages
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_85_0_0_23, superval);
	superval[2]=thisval;
	putValue(P_FSG_85_0_0_23,superval);
}

on envVar P_FSG_85_0_0_23_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // functionState
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_23_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_23_4,thisval);
}

on envVar P_FSG_85_0_0_23_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // functionState
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_23_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_23_4,thisval);
}

on envVar P_FSG_85_0_0_23_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // functionState
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_23_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_23_4,thisval);
}

on envVar P_FSG_85_0_0_23_4 // ParkingIndications.functionState
{
	byte superval[5];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // functionState
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_85_0_0_23_4_0, 1);
	else
		putValue(P_FSG_85_0_0_23_4_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_85_0_0_23_4_1, 1);
	else
		putValue(P_FSG_85_0_0_23_4_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_85_0_0_23_4_2, 1);
	else
		putValue(P_FSG_85_0_0_23_4_2, 0);

    // Update superval
	getValue(P_FSG_85_0_0_23, superval);
	superval[3]=thisval;
	putValue(P_FSG_85_0_0_23,superval);
}

on envVar P_FSG_85_0_0_23_5 // ParkingIndications.TPASpotAvailability
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // TPASpotAvailability
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_85_0_0_23, superval);
	superval[4]=thisval;
	putValue(P_FSG_85_0_0_23,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_24_ErrCode
{
       if(gP_FSG_85_0_0_24_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_24", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_24_ErrCode = 1;
}
on envVar P_FSG_85_0_0_24Status_BTN
{
    if (P_FSG_85_0_0_24Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_85_0_0_24_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_24",MakeRGB(255,255,255));
       P_FSG_85_0_0_24Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_85_0_0_24_ID, Data_REQ, getValue(P_FSG_85_0_0_24));
      P_FSG_85_0_0_24Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_85_0_0_24StatusAck_BTN
{
    if (P_FSG_85_0_0_24StatusAck_BTN_already_pressed == 0)
    {
       putValue(P_FSG_85_0_0_24_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_24",MakeRGB(255,255,255));
       P_FSG_85_0_0_24StatusAck_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_85_0_0_24_ID, DataAck_REQ, getValue(P_FSG_85_0_0_24));
      P_FSG_85_0_0_24StatusAck_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_85_0_0_24_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_24_ID;
    data[2]=getValue(P_FSG_85_0_0_24_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_24
on envVar P_FSG_85_0_0_24_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_24",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_24",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_24",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_24", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_24",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_24",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_24",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_24", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_85_0_0_24 // bus value of LifeMonitoring (24).
{
	// opcodes: Status-StatusAck
	byte param1; // TAID
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_85_0_0_24);
	putValue(P_FSG_85_0_0_24_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_24_1_range // LifeMonitoring.TAID 
{
	@P_FSG_85_0_0_24_1 = @P_FSG_85_0_0_24_1_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_24_1 // LifeMonitoring.TAID
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@P_FSG_85_0_0_24_1, 1.0);
	@P_FSG_85_0_0_24_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(P_FSG_85_0_0_24);
	superval = thisval;
	putValue(P_FSG_85_0_0_24,superval);
}

on envVar P_FSG_85_0_0_24_Ack // bus value of LifeMonitoring (24).
{
	// opcodes: Get-Ack
	byte param1; // TAID
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_85_0_0_24_Ack);
	putValue(P_FSG_85_0_0_24_Ack_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_24_Ack_1_range // LifeMonitoring.TAID 
{
	@P_FSG_85_0_0_24_Ack_1 = @P_FSG_85_0_0_24_Ack_1_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_24_Ack_1 // LifeMonitoring.TAID
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@P_FSG_85_0_0_24_Ack_1, 1.0);
	@P_FSG_85_0_0_24_Ack_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(P_FSG_85_0_0_24_Ack);
	superval = thisval;
	putValue(P_FSG_85_0_0_24_Ack,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_25_ErrCode
{
       if(gP_FSG_85_0_0_25_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_25", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_25_ErrCode = 1;
}
on envVar P_FSG_85_0_0_25Status_BTN
{
	byte BAPTemp[6];
   if (P_FSG_85_0_0_25Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_85_0_0_25_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_25",MakeRGB(255,255,255));
      P_FSG_85_0_0_25Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_85_0_0_25, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_85_0_0_25_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_85_0_0_25));
      P_FSG_85_0_0_25Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_85_0_0_25_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_25_ID;
    data[2]=getValue(P_FSG_85_0_0_25_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_25
on envVar P_FSG_85_0_0_25_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_25",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_25",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_25",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_25", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_25",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_25",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_25",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_25", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_85_0_0_25 // bus value of IC_Messages (25).
{
	// opcodes: Error-Status
	byte param1; // warning1
	byte param2; // warning2
	byte param3; // acousticWarning1
	byte param4; // acousticWarning2
	byte param5; // Extension1
	byte param6; // Extension2
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[6];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_25, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_85_0_0_25_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_85_0_0_25_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_85_0_0_25_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_85_0_0_25_4, param4);
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_85_0_0_25_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_85_0_0_25_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_85_0_0_25_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // warning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_25_1,thisval);
}

on envVar P_FSG_85_0_0_25_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // warning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_25_1,thisval);
}

on envVar P_FSG_85_0_0_25_1_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // warning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_1);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_25_1,thisval);
}

on envVar P_FSG_85_0_0_25_1_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // warning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_1);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_85_0_0_25_1,thisval);
}

on envVar P_FSG_85_0_0_25_1_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // warning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_1);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_85_0_0_25_1,thisval);
}

on envVar P_FSG_85_0_0_25_1_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // warning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_1);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_85_0_0_25_1,thisval);
}

on envVar P_FSG_85_0_0_25_1_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // warning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_1);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_85_0_0_25_1,thisval);
}

on envVar P_FSG_85_0_0_25_1_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // warning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_1);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_85_0_0_25_1,thisval);
}

on envVar P_FSG_85_0_0_25_1 // IC_Messages.warning1
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // warning1
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_85_0_0_25_1_0, 1);
	else
		putValue(P_FSG_85_0_0_25_1_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_85_0_0_25_1_1, 1);
	else
		putValue(P_FSG_85_0_0_25_1_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_85_0_0_25_1_2, 1);
	else
		putValue(P_FSG_85_0_0_25_1_2, 0);
	if(thisval&(mask<<3))
		putValue(P_FSG_85_0_0_25_1_3, 1);
	else
		putValue(P_FSG_85_0_0_25_1_3, 0);
	if(thisval&(mask<<4))
		putValue(P_FSG_85_0_0_25_1_4, 1);
	else
		putValue(P_FSG_85_0_0_25_1_4, 0);
	if(thisval&(mask<<5))
		putValue(P_FSG_85_0_0_25_1_5, 1);
	else
		putValue(P_FSG_85_0_0_25_1_5, 0);
	if(thisval&(mask<<6))
		putValue(P_FSG_85_0_0_25_1_6, 1);
	else
		putValue(P_FSG_85_0_0_25_1_6, 0);
	if(thisval&(mask<<7))
		putValue(P_FSG_85_0_0_25_1_7, 1);
	else
		putValue(P_FSG_85_0_0_25_1_7, 0);

    // Update superval
	getValue(P_FSG_85_0_0_25, superval);
	superval[0]=thisval;
	putValue(P_FSG_85_0_0_25,superval);
}

on envVar P_FSG_85_0_0_25_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // warning2
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_25_2,thisval);
}

on envVar P_FSG_85_0_0_25_2 // IC_Messages.warning2
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // warning2
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_85_0_0_25_2_0, 1);
	else
		putValue(P_FSG_85_0_0_25_2_0, 0);

    // Update superval
	getValue(P_FSG_85_0_0_25, superval);
	superval[1]=thisval;
	putValue(P_FSG_85_0_0_25,superval);
}

on envVar P_FSG_85_0_0_25_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // acousticWarning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_25_3,thisval);
}

on envVar P_FSG_85_0_0_25_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // acousticWarning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_85_0_0_25_3,thisval);
}

on envVar P_FSG_85_0_0_25_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // acousticWarning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_85_0_0_25_3,thisval);
}

on envVar P_FSG_85_0_0_25_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // acousticWarning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_3);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_85_0_0_25_3,thisval);
}

on envVar P_FSG_85_0_0_25_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // acousticWarning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_85_0_0_25_3,thisval);
}

on envVar P_FSG_85_0_0_25_3_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // acousticWarning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_3);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_85_0_0_25_3,thisval);
}

on envVar P_FSG_85_0_0_25_3_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // acousticWarning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_3);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_85_0_0_25_3,thisval);
}

on envVar P_FSG_85_0_0_25_3_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // acousticWarning1
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_3);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_85_0_0_25_3,thisval);
}

on envVar P_FSG_85_0_0_25_3 // IC_Messages.acousticWarning1
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // acousticWarning1
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_85_0_0_25_3_0, 1);
	else
		putValue(P_FSG_85_0_0_25_3_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_85_0_0_25_3_1, 1);
	else
		putValue(P_FSG_85_0_0_25_3_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_85_0_0_25_3_2, 1);
	else
		putValue(P_FSG_85_0_0_25_3_2, 0);
	if(thisval&(mask<<3))
		putValue(P_FSG_85_0_0_25_3_3, 1);
	else
		putValue(P_FSG_85_0_0_25_3_3, 0);
	if(thisval&(mask<<4))
		putValue(P_FSG_85_0_0_25_3_4, 1);
	else
		putValue(P_FSG_85_0_0_25_3_4, 0);
	if(thisval&(mask<<5))
		putValue(P_FSG_85_0_0_25_3_5, 1);
	else
		putValue(P_FSG_85_0_0_25_3_5, 0);
	if(thisval&(mask<<6))
		putValue(P_FSG_85_0_0_25_3_6, 1);
	else
		putValue(P_FSG_85_0_0_25_3_6, 0);
	if(thisval&(mask<<7))
		putValue(P_FSG_85_0_0_25_3_7, 1);
	else
		putValue(P_FSG_85_0_0_25_3_7, 0);

    // Update superval
	getValue(P_FSG_85_0_0_25, superval);
	superval[2]=thisval;
	putValue(P_FSG_85_0_0_25,superval);
}

on envVar P_FSG_85_0_0_25_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // acousticWarning2
	bitval= getValue(this);
	thisval = getValue(P_FSG_85_0_0_25_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_85_0_0_25_4,thisval);
}

on envVar P_FSG_85_0_0_25_4 // IC_Messages.acousticWarning2
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // acousticWarning2
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_85_0_0_25_4_0, 1);
	else
		putValue(P_FSG_85_0_0_25_4_0, 0);

    // Update superval
	getValue(P_FSG_85_0_0_25, superval);
	superval[3]=thisval;
	putValue(P_FSG_85_0_0_25,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_25_5_range // IC_Messages.Extension1 
{
	@P_FSG_85_0_0_25_5 = @P_FSG_85_0_0_25_5_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_25_5 // IC_Messages.Extension1
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_25_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_25, superval);
	superval[4]=thisval;
	putValue(P_FSG_85_0_0_25,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_25_6_range // IC_Messages.Extension2 
{
	@P_FSG_85_0_0_25_6 = @P_FSG_85_0_0_25_6_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_25_6 // IC_Messages.Extension2
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_85_0_0_25_6_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_85_0_0_25, superval);
	superval[5]=thisval;
	putValue(P_FSG_85_0_0_25,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_85_0_0_26_ErrCode
{
       if(gA_FSG_85_0_0_26_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_85_0_0_26", MakeRGB(255,255,255));
       }
       gA_FSG_85_0_0_26_ErrCode = 1;
}
on envVar A_FSG_85_0_0_26Changed_BTN
{
    byte data[40]; 
    byte stringValue[40];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_85_0_0_26Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_85_0_0_26_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_85_0_0_26",MakeRGB(255,255,255));
        A_FSG_85_0_0_26Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_85_0_0_26_Changed);
        getValue(A_FSG_85_0_0_26_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_85_0_0_26_Changed_Start);
     elementsVal = getValue(A_FSG_85_0_0_26_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_85_0_0_26_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 26");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_85_0_0_26_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_85_0_0_26_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 26");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_85_0_0_26_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_85_0_0_26_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_85_0_0_26_ID);
       }
       if(getValue(A_FSG_85_0_0_26_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_85_0_0_26_ID,getValueSize(A_FSG_85_0_0_26_Changed));
       }
        A_FSG_85_0_0_26Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_85_0_0_26Status_BTN
{
    byte data[40 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[40];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_85_0_0_26Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_85_0_0_26_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_85_0_0_26",MakeRGB(255,255,255));
        A_FSG_85_0_0_26Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_85_0_0_26_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_85_0_0_26_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_85_0_0_26_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_85_0_0_26);
        getValue(A_FSG_85_0_0_26,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_85_0_0_26_Start);
     elementsVal = getValue(A_FSG_85_0_0_26_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_85_0_0_26_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 26");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_85_0_0_26_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_85_0_0_26_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ReferenceID:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable State:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param3) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param3 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Type:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Modification:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable OPS:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable VPS:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable VPSMode:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable VPSBirdView:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param9) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param9 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Extension1:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param10) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param10 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_85_0_0_26_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_85_0_0_26_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 26");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_85_0_0_26_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_85_0_0_26_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ReferenceID:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable State:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param3) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param3 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Type:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Modification:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable OPS:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable VPS:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable VPSMode:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable VPSBirdView:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param9) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param9 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Extension1:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param10) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param10 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_85_0_0_26, data);
        Request_ByteSequence(LSGID, A_FSG_85_0_0_26_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_85_0_0_26_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_85_0_0_26_ID);
        }
        if(getValue(A_FSG_85_0_0_26_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_85_0_0_26_ID,getValueSize(A_FSG_85_0_0_26));
        }
        A_FSG_85_0_0_26Status_BTN_already_pressed = 0;
    }
}
A_FSG_85_0_0_26_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[40];
    byte stringValue[40];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_85_0_0_26_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_85_0_0_26_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_85_0_0_26_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_85_0_0_26);
        getValue(A_FSG_85_0_0_26,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_85_0_0_26_Start);
     elementsVal = getValue(A_FSG_85_0_0_26_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_85_0_0_26_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 26");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_85_0_0_26_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_85_0_0_26_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ReferenceID:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable State:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param3) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param3 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Type:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Modification:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable OPS:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable VPS:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable VPSMode:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable VPSBirdView:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param9) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param9 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Extension1:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param10) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param10 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_85_0_0_26_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_85_0_0_26_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 26");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_85_0_0_26_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_85_0_0_26_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable ReferenceID:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable State:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param3) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param3 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Type:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Modification:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable OPS:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param6) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param6 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable VPS:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable VPSMode:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_26_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable VPSBirdView:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 2 == getValue( A_FSG_85_0_0_26_RecAdr ) || 3 == getValue( A_FSG_85_0_0_26_RecAdr ) || 4 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) || 6 == getValue( A_FSG_85_0_0_26_RecAdr ) || 7 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param9) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param9 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Extension1:
      if( 0 || 1 == getValue( A_FSG_85_0_0_26_RecAdr ) || 5 == getValue( A_FSG_85_0_0_26_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param10) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_85_0_0_26_ArrayDataList[i].Param10 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_85_0_0_26_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_85_0_0_26
{
    byte temp[40];
    getValue(A_FSG_85_0_0_26, temp);
    putValue(A_FSG_85_0_0_26_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_85_0_0_26_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_85_0_0_26_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_85_0_0_26_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_85_0_0_26_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_85_0_0_26_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_85_0_0_26_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_85_0_0_26_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_85_0_0_26_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_85_0_0_26_IndexSize))
    {
        putValue(A_FSG_85_0_0_26_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_85_0_0_26_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_85_0_0_26_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_85_0_0_26_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_85_0_0_26_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_85_0_0_26_RecAdr) > 0x0F)
        putValue(A_FSG_85_0_0_26_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_85_0_0_26_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_85_0_0_26_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_85_0_0_26_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_85_0_0_26_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_85_0_0_26_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_85_0_0_26_Start) & 0xFF;
        head[2] = (getValue(A_FSG_85_0_0_26_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_85_0_0_26_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_85_0_0_26_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_85_0_0_26_Start) & 0xFF;
        head[2] = getValue(A_FSG_85_0_0_26_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_85_0_0_26, head, headLength); 
}

on envVar A_FSG_85_0_0_26_RecAdr
{
    A_FSG_85_0_0_26_GenerateStatus();
}

on envVar A_FSG_85_0_0_26_Shift
{
    A_FSG_85_0_0_26_GenerateStatus();
}

on envVar A_FSG_85_0_0_26_Direction
{
    A_FSG_85_0_0_26_GenerateStatus();
}

on envVar A_FSG_85_0_0_26_Start
{
    A_FSG_85_0_0_26_GenerateStatus();
}

on envVar A_FSG_85_0_0_26_Elements
{
    A_FSG_85_0_0_26_GenerateStatus();
}

on envVar A_FSG_85_0_0_26_IndexSize
{
    A_FSG_85_0_0_26_GenerateStatus();
}
on envVar A_FSG_85_0_0_26_TransPos
{
    A_FSG_85_0_0_26_GenerateStatus();
}
A_FSG_85_0_0_26_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_85_0_0_26_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_85_0_0_26_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_85_0_0_26_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_85_0_0_26_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_85_0_0_26_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_85_0_0_26_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_85_0_0_26_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_85_0_0_26_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_85_0_0_26_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_85_0_0_26_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_85_0_0_26_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_85_0_0_26_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_85_0_0_26_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_85_0_0_26_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_85_0_0_26_Changed, head, 3); 
    }
}

on envVar A_FSG_85_0_0_26_Changed_RecAdr
{
    A_FSG_85_0_0_26_Changed_GenerateChanged();
}

on envVar A_FSG_85_0_0_26_Changed_Shift
{
    A_FSG_85_0_0_26_Changed_GenerateChanged();
}

on envVar A_FSG_85_0_0_26_Changed_Direction
{
    A_FSG_85_0_0_26_Changed_GenerateChanged();
}

on envVar A_FSG_85_0_0_26_Changed_Start
{
    A_FSG_85_0_0_26_Changed_GenerateChanged();
}

on envVar A_FSG_85_0_0_26_Changed_Elements
{
    A_FSG_85_0_0_26_Changed_GenerateChanged();
}

on envVar A_FSG_85_0_0_26_Changed_IndexSize
{
    A_FSG_85_0_0_26_Changed_GenerateChanged();
}
on envVar A_FSG_85_0_0_26_Changed_TransPos
{
    A_FSG_85_0_0_26_Changed_GenerateChanged();
}
on envVar A_FSG_85_0_0_26_SetGet
{
    byte temp[40];
    getValue(A_FSG_85_0_0_26_SetGet, temp);
    putValue(A_FSG_85_0_0_26_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_85_0_0_26_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_85_0_0_26_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_85_0_0_26_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_85_0_0_26_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_85_0_0_26_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_85_0_0_26_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_85_0_0_26_SetGet_IndexSize))
    {
        putValue(A_FSG_85_0_0_26_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_85_0_0_26_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_85_0_0_26_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_85_0_0_26_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_85_0_0_26_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_85_0_0_26_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_85_0_0_26_ArrayDataList[i].Param1 = 0;
		A_FSG_85_0_0_26_ArrayDataList[i].Param2 = 0;
		A_FSG_85_0_0_26_ArrayDataList[i].Param3 = 0;
		A_FSG_85_0_0_26_ArrayDataList[i].Param4 = 0;
		A_FSG_85_0_0_26_ArrayDataList[i].Param5 = 0;
		A_FSG_85_0_0_26_ArrayDataList[i].Param6 = 0;
		A_FSG_85_0_0_26_ArrayDataList[i].Param7 = 0;
		A_FSG_85_0_0_26_ArrayDataList[i].Param8 = 0;
		A_FSG_85_0_0_26_ArrayDataList[i].Param9 = 0;
		A_FSG_85_0_0_26_ArrayDataList[i].Param10 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_85_0_0_26_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 21) //ignore first line in *.csv file
					{
						A_FSG_85_0_0_26_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_85_0_0_26_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //ReferenceID
						A_FSG_85_0_0_26_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //State
						A_FSG_85_0_0_26_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //Type
						A_FSG_85_0_0_26_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //Modification
						A_FSG_85_0_0_26_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //OPS
						A_FSG_85_0_0_26_ArrayDataList[current_CSV_line-1].Param7 = atol(temp7); //VPS
						A_FSG_85_0_0_26_ArrayDataList[current_CSV_line-1].Param8 = atol(temp8); //VPSMode
						A_FSG_85_0_0_26_ArrayDataList[current_CSV_line-1].Param9 = atol(temp9); //VPSBirdView
						A_FSG_85_0_0_26_ArrayDataList[current_CSV_line-1].Param10 = atol(temp10); //Extension1
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 21)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //ReferenceID
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //State
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //Type
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Modification
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //OPS
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //VPS
								if( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //VPSMode
								if( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //VPSBirdView
								if( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //Extension1
								if( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_85_0_0_26_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_85_0_0_26_generateData_Btn_already_pressed == 0)
	{
		A_FSG_85_0_0_26_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_85_0_0_26_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_85_0_0_26_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_85_0_0_26_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
		putValue(A_FSG_85_0_0_26_Data_1, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param1);
	putValue(A_FSG_85_0_0_26_Data_2, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param2);
	putValue(A_FSG_85_0_0_26_Data_3, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param3);
	putValue(A_FSG_85_0_0_26_Data_4, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param4);
	putValue(A_FSG_85_0_0_26_Data_5, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param5);
	putValue(A_FSG_85_0_0_26_Data_6, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param6);
	putValue(A_FSG_85_0_0_26_Data_7, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param7);
	putValue(A_FSG_85_0_0_26_Data_8, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param8);
	putValue(A_FSG_85_0_0_26_Data_9, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param9);
	putValue(A_FSG_85_0_0_26_Data_10, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param10);
	}
}


on envVar A_FSG_85_0_0_26_generateData_Btn
{
	word i;
	dword elementsArray[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
	byte elementsTypeArray[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	dword elementsMaxSizeArray[10] = {255, 254, 0xF, 0xF, 0xFF, 0xF, 0xF, 0xFF, 0xF, 0};
	byte tempArray[200];
	if (A_FSG_85_0_0_26_generateData_Btn_already_pressed == 0)
	{
		A_FSG_85_0_0_26_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 26, 20 );
		for(i = 0; i < 20; i++)
		{
			memcpy(A_FSG_85_0_0_26_ArrayDataList[i], tempArray, (i * 10) );
		}
		A_FSG_85_0_0_26_generateData_Btn_already_pressed = 0;
	putValue(A_FSG_85_0_0_26_Data_1, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param1);
	putValue(A_FSG_85_0_0_26_Data_2, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param2);
	putValue(A_FSG_85_0_0_26_Data_3, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param3);
	putValue(A_FSG_85_0_0_26_Data_4, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param4);
	putValue(A_FSG_85_0_0_26_Data_5, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param5);
	putValue(A_FSG_85_0_0_26_Data_6, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param6);
	putValue(A_FSG_85_0_0_26_Data_7, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param7);
	putValue(A_FSG_85_0_0_26_Data_8, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param8);
	putValue(A_FSG_85_0_0_26_Data_9, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param9);
	putValue(A_FSG_85_0_0_26_Data_10, A_FSG_85_0_0_26_ArrayDataList[ getValue( A_FSG_85_0_0_26_DataIndex) ].Param10);
	}
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_85_0_0_26_DataIndex
{
    long index;
    long maxIndex = 20-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_85_0_0_26_Data_1, A_FSG_85_0_0_26_ArrayDataList[index].Param1*(1.0)-(0.0));
    putValue(A_FSG_85_0_0_26_Data_2, A_FSG_85_0_0_26_ArrayDataList[index].Param2*(1.0)-(1.0));
    putValue(A_FSG_85_0_0_26_Data_3, A_FSG_85_0_0_26_ArrayDataList[index].Param3);
    putValue(A_FSG_85_0_0_26_Data_4, A_FSG_85_0_0_26_ArrayDataList[index].Param4);
    putValue(A_FSG_85_0_0_26_Data_5, A_FSG_85_0_0_26_ArrayDataList[index].Param5);
    putValue(A_FSG_85_0_0_26_Data_6, A_FSG_85_0_0_26_ArrayDataList[index].Param6);
    putValue(A_FSG_85_0_0_26_Data_7, A_FSG_85_0_0_26_ArrayDataList[index].Param7);
    putValue(A_FSG_85_0_0_26_Data_8, A_FSG_85_0_0_26_ArrayDataList[index].Param8);
    putValue(A_FSG_85_0_0_26_Data_9, A_FSG_85_0_0_26_ArrayDataList[index].Param9);
    putValue(A_FSG_85_0_0_26_Data_10, A_FSG_85_0_0_26_ArrayDataList[index].Param10*(1.0)-(0.0));

}
on envVar A_FSG_85_0_0_26_DataIndex_Incr
{
    long index;
    if(A_FSG_85_0_0_26_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_85_0_0_26_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_85_0_0_26_DataIndex);
        index++;
        putValue(A_FSG_85_0_0_26_DataIndex, index);
        A_FSG_85_0_0_26_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_85_0_0_26_DataIndex_Decr
{
    long index;
    if(A_FSG_85_0_0_26_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_85_0_0_26_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_85_0_0_26_DataIndex);
        index--;
        putValue(A_FSG_85_0_0_26_DataIndex, index);
        A_FSG_85_0_0_26_DataIndex_Decr_already_pressed = 0;
    }
}
// HME generateCaplOnEnv (3160)
on envVar A_FSG_85_0_0_26_DataIndex_SetGet
{
    long index;
    long maxIndex = 20-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_85_0_0_26_Data_1_SetGet, A_FSG_85_0_0_26_ArrayDataList[index].Param1*(1.0)-(0.0));
    putValue(A_FSG_85_0_0_26_Data_2_SetGet, A_FSG_85_0_0_26_ArrayDataList[index].Param2*(1.0)-(1.0));
    putValue(A_FSG_85_0_0_26_Data_3_SetGet, A_FSG_85_0_0_26_ArrayDataList[index].Param3);
    putValue(A_FSG_85_0_0_26_Data_4_SetGet, A_FSG_85_0_0_26_ArrayDataList[index].Param4);
    putValue(A_FSG_85_0_0_26_Data_5_SetGet, A_FSG_85_0_0_26_ArrayDataList[index].Param5);
    putValue(A_FSG_85_0_0_26_Data_6_SetGet, A_FSG_85_0_0_26_ArrayDataList[index].Param6);
    putValue(A_FSG_85_0_0_26_Data_7_SetGet, A_FSG_85_0_0_26_ArrayDataList[index].Param7);
    putValue(A_FSG_85_0_0_26_Data_8_SetGet, A_FSG_85_0_0_26_ArrayDataList[index].Param8);
    putValue(A_FSG_85_0_0_26_Data_9_SetGet, A_FSG_85_0_0_26_ArrayDataList[index].Param9);
    putValue(A_FSG_85_0_0_26_Data_10_SetGet, A_FSG_85_0_0_26_ArrayDataList[index].Param10*(1.0)-(0.0));

}
on envVar A_FSG_85_0_0_26_DataIndex_SetGet_Incr
{
    long index;
    if(A_FSG_85_0_0_26_DataIndex_SetGet_Incr_already_pressed == 0)
    {
        A_FSG_85_0_0_26_DataIndex_SetGet_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_85_0_0_26_DataIndex_SetGet);
        index++;
        putValue(A_FSG_85_0_0_26_DataIndex_SetGet, index);
        A_FSG_85_0_0_26_DataIndex_SetGet_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_85_0_0_26_DataIndex_SetGet_Decr
{
    long index;
    if(A_FSG_85_0_0_26_DataIndex_SetGet_Decr_already_pressed == 0)
    {
        A_FSG_85_0_0_26_DataIndex_SetGet_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_85_0_0_26_DataIndex_SetGet);
        index--;
        putValue(A_FSG_85_0_0_26_DataIndex_SetGet, index);
        A_FSG_85_0_0_26_DataIndex_SetGet_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_85_0_0_26_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_85_0_0_26_ID;
    data[2]=getValue(A_FSG_85_0_0_26_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_85_0_0_26
on envVar A_FSG_85_0_0_26_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_26",1);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_85_0_0_26",1);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_26",1);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_26_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_85_0_0_26", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_26",0);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_85_0_0_26",0);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_26",0);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_26_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_85_0_0_26", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_85_0_0_26_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_85_0_0_26_SegmEn,0);
           intertelegram_err(A_FSG_85_0_0_26_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_85_0_0_26_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_85_0_0_26_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_85_0_0_26_IntTlgEn,0);
           sequence_err(A_FSG_85_0_0_26_ID,getValueSize(A_FSG_85_0_0_26_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_85_0_0_26_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_85_0_0_26_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_85_0_0_26_Status",1);
 	}
}



A_FSG_85_0_0_26_SetInd () { /* leere Function*/ }

A_FSG_85_0_0_26_SetGetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[40];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_85_0_0_26_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_85_0_0_26_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_85_0_0_26_SetGet, head, 5);
                if(getValue(A_FSG_85_0_0_26_AT))
                {
                    putValue(A_FSG_85_0_0_26,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_85_0_0_26_SetGet, head, 3);
            if(getValue(A_FSG_85_0_0_26_AT))
            {
                putValue(A_FSG_85_0_0_26,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_85_0_0_26_AT))
        {
            putValue(A_FSG_85_0_0_26_RecAdr,recordAddressVal);
            putValue(A_FSG_85_0_0_26_Start, startVal);
            putValue(A_FSG_85_0_0_26_Elements, elementsVal);
            putValue(A_FSG_85_0_0_26_TransPos, transmitPosVal);
        }
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_FSG_85_0_0_26_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 26");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_85_0_0_26_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_85_0_0_26_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_26_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param3= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param4= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_26_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param6= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param7= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_26_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param9= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 5 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param10= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_FSG_85_0_0_26_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_FSG_85_0_0_26_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 26");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_85_0_0_26_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_85_0_0_26_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_26_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param3= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param4= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_26_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param6= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param7= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_26_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal || 6 == recordAddressVal || 7 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param9= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 5 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_85_0_0_26_ArrayDataList[i].Param10= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_85_0_0_26_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_FSG_85_0_0_26_DataIndex);
    putValue(A_FSG_85_0_0_26_Data_1, A_FSG_85_0_0_26_ArrayDataList[index].Param1*(1.0)-(0.0));
    putValue(A_FSG_85_0_0_26_Data_2, A_FSG_85_0_0_26_ArrayDataList[index].Param2*(1.0)-(1.0));
    putValue(A_FSG_85_0_0_26_Data_3, A_FSG_85_0_0_26_ArrayDataList[index].Param3);
    putValue(A_FSG_85_0_0_26_Data_4, A_FSG_85_0_0_26_ArrayDataList[index].Param4);
    putValue(A_FSG_85_0_0_26_Data_5, A_FSG_85_0_0_26_ArrayDataList[index].Param5);
    putValue(A_FSG_85_0_0_26_Data_6, A_FSG_85_0_0_26_ArrayDataList[index].Param6);
    putValue(A_FSG_85_0_0_26_Data_7, A_FSG_85_0_0_26_ArrayDataList[index].Param7);
    putValue(A_FSG_85_0_0_26_Data_8, A_FSG_85_0_0_26_ArrayDataList[index].Param8);
    putValue(A_FSG_85_0_0_26_Data_9, A_FSG_85_0_0_26_ArrayDataList[index].Param9);
    putValue(A_FSG_85_0_0_26_Data_10, A_FSG_85_0_0_26_ArrayDataList[index].Param10*(1.0)-(0.0));
}

A_FSG_85_0_0_26_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[40];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_85_0_0_26_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_85_0_0_26_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_85_0_0_26_SetGet, head, 5);
                if(getValue(A_FSG_85_0_0_26_AT))
                {
                    putValue(A_FSG_85_0_0_26,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_85_0_0_26_SetGet, head, 3);
            if(getValue(A_FSG_85_0_0_26_AT))
            {
                putValue(A_FSG_85_0_0_26,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_85_0_0_26_AT))
        {
            putValue(A_FSG_85_0_0_26_RecAdr,recordAddressVal);
            putValue(A_FSG_85_0_0_26_Start, startVal);
            putValue(A_FSG_85_0_0_26_Elements, elementsVal);
            putValue(A_FSG_85_0_0_26_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_85_0_0_26_1
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_26_2_range // FavoriteList.TAID 
{
	@A_FSG_85_0_0_26_2 = @A_FSG_85_0_0_26_2_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_26_2
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_26_2, 1.0);
	@A_FSG_85_0_0_26_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_26_3_range // FavoriteList.TotalNumListElements 
{
	@A_FSG_85_0_0_26_3 = @A_FSG_85_0_0_26_3_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_26_3
{

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_26_3, 1.0);
	@A_FSG_85_0_0_26_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_26_Data_1_range // FavoriteList.Pos 
{
	@A_FSG_85_0_0_26_Data_1 = @A_FSG_85_0_0_26_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_26_Data_1
{

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_26_Data_1, 1.0);
	@A_FSG_85_0_0_26_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex)].Param1 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_26_Data_2_range // FavoriteList.ReferenceID 
{
	@A_FSG_85_0_0_26_Data_2 = @A_FSG_85_0_0_26_Data_2_range - (1); // slider = range - min
}

on envVar A_FSG_85_0_0_26_Data_2
{

	//Update Childvalue (Number)
	byte thisval; // ReferenceID
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_26_Data_2, 1.0);
	@A_FSG_85_0_0_26_Data_2_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex)].Param2 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_3
{

	//Update Childvalue (Enum)
	byte thisval; // State
	thisval = 0x0f & getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex)].Param3 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_4
{

	//Update Childvalue (Enum)
	byte thisval; // Type
	thisval = 0x0f & getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex)].Param4 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_5
{

	//Update Childvalue (Enum)
	byte thisval; // Modification
	thisval = getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex)].Param5 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_6
{

	//Update Childvalue (Enum)
	byte thisval; // OPS
	thisval = 0x0f & getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex)].Param6 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_7
{

	//Update Childvalue (Enum)
	byte thisval; // VPS
	thisval = 0x0f & getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex)].Param7 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_8
{

	//Update Childvalue (Enum)
	byte thisval; // VPSMode
	thisval = getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex)].Param8 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_9
{

	//Update Childvalue (Enum)
	byte thisval; // VPSBirdView
	thisval = 0x0f & getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex)].Param9 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_26_Data_10_range // FavoriteList.Extension1 
{
	@A_FSG_85_0_0_26_Data_10 = @A_FSG_85_0_0_26_Data_10_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_26_Data_10
{

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@A_FSG_85_0_0_26_Data_10_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex)].Param10 = thisval;
}
on envVar A_FSG_85_0_0_26_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_26_2_SetGet_range // FavoriteList.TAID 
{
	@A_FSG_85_0_0_26_2_SetGet = @A_FSG_85_0_0_26_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_26_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_26_2_SetGet, 1.0);
	@A_FSG_85_0_0_26_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_26_Data_1_SetGet_range // FavoriteList.Pos 
{
	@A_FSG_85_0_0_26_Data_1_SetGet = @A_FSG_85_0_0_26_Data_1_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_26_Data_1_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_26_Data_1_SetGet, 1.0);
	@A_FSG_85_0_0_26_Data_1_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex_SetGet)].Param1 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_26_Data_2_SetGet_range // FavoriteList.ReferenceID 
{
	@A_FSG_85_0_0_26_Data_2_SetGet = @A_FSG_85_0_0_26_Data_2_SetGet_range - (1); // slider = range - min
}

on envVar A_FSG_85_0_0_26_Data_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // ReferenceID
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_26_Data_2_SetGet, 1.0);
	@A_FSG_85_0_0_26_Data_2_SetGet_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex_SetGet)].Param2 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_3_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // State
	thisval = 0x0f & getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex_SetGet)].Param3 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_4_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // Type
	thisval = 0x0f & getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex_SetGet)].Param4 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_5_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // Modification
	thisval = getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex_SetGet)].Param5 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_6_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // OPS
	thisval = 0x0f & getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex_SetGet)].Param6 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_7_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // VPS
	thisval = 0x0f & getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex_SetGet)].Param7 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_8_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // VPSMode
	thisval = getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex_SetGet)].Param8 = thisval;
}
on envVar A_FSG_85_0_0_26_Data_9_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // VPSBirdView
	thisval = 0x0f & getValue(this);
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex_SetGet)].Param9 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_26_Data_10_SetGet_range // FavoriteList.Extension1 
{
	@A_FSG_85_0_0_26_Data_10_SetGet = @A_FSG_85_0_0_26_Data_10_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_26_Data_10_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@A_FSG_85_0_0_26_Data_10_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_85_0_0_26_ArrayDataList[getValue(A_FSG_85_0_0_26_DataIndex_SetGet)].Param10 = thisval;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_85_0_0_27_ErrCode
{
       if(gA_FSG_85_0_0_27_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_85_0_0_27", MakeRGB(255,255,255));
       }
       gA_FSG_85_0_0_27_ErrCode = 1;
}
on envVar A_FSG_85_0_0_27Changed_BTN
{
    byte data[23]; 
    byte stringValue[23];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_85_0_0_27Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_85_0_0_27_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_85_0_0_27",MakeRGB(255,255,255));
        A_FSG_85_0_0_27Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //Einzelparameter: Operation
        tempValue = getValue(A_FSG_85_0_0_27_1_Changed);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: Type
        tempValue = getValue(A_FSG_85_0_0_27_2_Changed);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: Slot
        tempValue = getValue(A_FSG_85_0_0_27_3_Changed);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_85_0_0_27_Changed);
        getValue(A_FSG_85_0_0_27_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }

       Request_ByteSequence(LSGID, A_FSG_85_0_0_27_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_85_0_0_27_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_85_0_0_27_ID);
       }
       if(getValue(A_FSG_85_0_0_27_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_85_0_0_27_ID,getValueSize(A_FSG_85_0_0_27_Changed));
       }
        A_FSG_85_0_0_27Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_85_0_0_27Status_BTN
{
    byte data[23 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[23];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_85_0_0_27Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_85_0_0_27_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_85_0_0_27",MakeRGB(255,255,255));
        A_FSG_85_0_0_27Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: Operation
        tempValue = getValue(A_FSG_85_0_0_27_1);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: Type
        tempValue = getValue(A_FSG_85_0_0_27_2);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: Slot
        tempValue = getValue(A_FSG_85_0_0_27_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: State
        tempValue = getValue(A_FSG_85_0_0_27_4);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_85_0_0_27_5);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_85_0_0_27_6);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_85_0_0_27_7);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //head Parameter
        headLength = getValueSize(A_FSG_85_0_0_27);
        getValue(A_FSG_85_0_0_27,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_85_0_0_27_Start);
     elementsVal = getValue(A_FSG_85_0_0_27_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_85_0_0_27_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 27");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           //Kein POS definiert
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           //Kein POS definiert
        }
     }
      // Check if the current value of RecAdr enables the variable Parameter_ID:
      if( 0 || 1 == getValue( A_FSG_85_0_0_27_RecAdr ) || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 4 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1      ) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >>  8) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >> 16) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >> 24) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DataDescription:
      if( 0 || 1 == getValue( A_FSG_85_0_0_27_RecAdr ) || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DataTag:
      if( 0 || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Data:
      if( 0 || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length;
		data[currentPos++] = (StringLength )& 0xFF;
		data[currentPos++] = (StringLength >> 8)& 0xFF;
		data[currentPos++] = (StringLength >> 16) & 0xFF;
		data[currentPos++] = (StringLength >> 24)& 0xFF;
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_85_0_0_27_ArrayDataList[i].Param4[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_85_0_0_27_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_85_0_0_27_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 27");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           //Kein POS definiert
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           //Kein POS definiert
        }
     }
      // Check if the current value of RecAdr enables the variable Parameter_ID:
      if( 0 || 1 == getValue( A_FSG_85_0_0_27_RecAdr ) || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 4 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1      ) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >>  8) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >> 16) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >> 24) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DataDescription:
      if( 0 || 1 == getValue( A_FSG_85_0_0_27_RecAdr ) || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DataTag:
      if( 0 || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Data:
      if( 0 || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length;
		data[currentPos++] = (StringLength )& 0xFF;
		data[currentPos++] = (StringLength >> 8)& 0xFF;
		data[currentPos++] = (StringLength >> 16) & 0xFF;
		data[currentPos++] = (StringLength >> 24)& 0xFF;
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_85_0_0_27_ArrayDataList[i].Param4[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_85_0_0_27, data);
        Request_ByteSequence(LSGID, A_FSG_85_0_0_27_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_85_0_0_27_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_85_0_0_27_ID);
        }
        if(getValue(A_FSG_85_0_0_27_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_85_0_0_27_ID,getValueSize(A_FSG_85_0_0_27));
        }
        A_FSG_85_0_0_27Status_BTN_already_pressed = 0;
    }
}
A_FSG_85_0_0_27_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[23];
    byte stringValue[23];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: Operation
        tempValue = getValue(A_FSG_85_0_0_27_1);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: Type
        tempValue = getValue(A_FSG_85_0_0_27_2);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: Slot
        tempValue = getValue(A_FSG_85_0_0_27_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: State
        tempValue = getValue(A_FSG_85_0_0_27_4);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_85_0_0_27_5);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_85_0_0_27_6);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_85_0_0_27_7);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //head Parameter
        headLength = getValueSize(A_FSG_85_0_0_27);
        getValue(A_FSG_85_0_0_27,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_85_0_0_27_Start);
     elementsVal = getValue(A_FSG_85_0_0_27_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_85_0_0_27_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 27");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           //Kein POS definiert
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           //Kein POS definiert
        }
     }
      // Check if the current value of RecAdr enables the variable Parameter_ID:
      if( 0 || 1 == getValue( A_FSG_85_0_0_27_RecAdr ) || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 4 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1      ) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >>  8) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >> 16) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >> 24) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DataDescription:
      if( 0 || 1 == getValue( A_FSG_85_0_0_27_RecAdr ) || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DataTag:
      if( 0 || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Data:
      if( 0 || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length;
		data[currentPos++] = (StringLength )& 0xFF;
		data[currentPos++] = (StringLength >> 8)& 0xFF;
		data[currentPos++] = (StringLength >> 16) & 0xFF;
		data[currentPos++] = (StringLength >> 24)& 0xFF;
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_85_0_0_27_ArrayDataList[i].Param4[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_85_0_0_27_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_85_0_0_27_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 27");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           //Kein POS definiert
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           //Kein POS definiert
        }
     }
      // Check if the current value of RecAdr enables the variable Parameter_ID:
      if( 0 || 1 == getValue( A_FSG_85_0_0_27_RecAdr ) || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 4 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1      ) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >>  8) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >> 16) & 0xFF;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param1 >> 24) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DataDescription:
      if( 0 || 1 == getValue( A_FSG_85_0_0_27_RecAdr ) || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DataTag:
      if( 0 || 2 == getValue( A_FSG_85_0_0_27_RecAdr ) || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_85_0_0_27_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Data:
      if( 0 || 3 == getValue( A_FSG_85_0_0_27_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length;
		data[currentPos++] = (StringLength )& 0xFF;
		data[currentPos++] = (StringLength >> 8)& 0xFF;
		data[currentPos++] = (StringLength >> 16) & 0xFF;
		data[currentPos++] = (StringLength >> 24)& 0xFF;
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_85_0_0_27_ArrayDataList[i].Param4[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_85_0_0_27_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_85_0_0_27
{
    byte temp[23];
    getValue(A_FSG_85_0_0_27, temp);
    putValue(A_FSG_85_0_0_27_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_85_0_0_27_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_85_0_0_27_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_85_0_0_27_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_85_0_0_27_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_85_0_0_27_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_85_0_0_27_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_85_0_0_27_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_85_0_0_27_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_85_0_0_27_IndexSize))
    {
        putValue(A_FSG_85_0_0_27_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_85_0_0_27_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_85_0_0_27_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_85_0_0_27_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_85_0_0_27_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_85_0_0_27_RecAdr) > 0x0F)
        putValue(A_FSG_85_0_0_27_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_85_0_0_27_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_85_0_0_27_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_85_0_0_27_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_85_0_0_27_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_85_0_0_27_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_85_0_0_27_Start) & 0xFF;
        head[2] = (getValue(A_FSG_85_0_0_27_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_85_0_0_27_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_85_0_0_27_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_85_0_0_27_Start) & 0xFF;
        head[2] = getValue(A_FSG_85_0_0_27_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_85_0_0_27, head, headLength); 
}

on envVar A_FSG_85_0_0_27_RecAdr
{
    A_FSG_85_0_0_27_GenerateStatus();
}

on envVar A_FSG_85_0_0_27_Shift
{
    A_FSG_85_0_0_27_GenerateStatus();
}

on envVar A_FSG_85_0_0_27_Direction
{
    A_FSG_85_0_0_27_GenerateStatus();
}

on envVar A_FSG_85_0_0_27_Start
{
    A_FSG_85_0_0_27_GenerateStatus();
}

on envVar A_FSG_85_0_0_27_Elements
{
    A_FSG_85_0_0_27_GenerateStatus();
}

on envVar A_FSG_85_0_0_27_IndexSize
{
    A_FSG_85_0_0_27_GenerateStatus();
}
on envVar A_FSG_85_0_0_27_TransPos
{
    A_FSG_85_0_0_27_GenerateStatus();
}
A_FSG_85_0_0_27_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_85_0_0_27_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_85_0_0_27_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_85_0_0_27_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_85_0_0_27_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_85_0_0_27_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_85_0_0_27_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_85_0_0_27_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_85_0_0_27_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_85_0_0_27_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_85_0_0_27_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_85_0_0_27_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_85_0_0_27_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_85_0_0_27_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_85_0_0_27_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_85_0_0_27_Changed, head, 3); 
    }
}

on envVar A_FSG_85_0_0_27_Changed_RecAdr
{
    A_FSG_85_0_0_27_Changed_GenerateChanged();
}

on envVar A_FSG_85_0_0_27_Changed_Shift
{
    A_FSG_85_0_0_27_Changed_GenerateChanged();
}

on envVar A_FSG_85_0_0_27_Changed_Direction
{
    A_FSG_85_0_0_27_Changed_GenerateChanged();
}

on envVar A_FSG_85_0_0_27_Changed_Start
{
    A_FSG_85_0_0_27_Changed_GenerateChanged();
}

on envVar A_FSG_85_0_0_27_Changed_Elements
{
    A_FSG_85_0_0_27_Changed_GenerateChanged();
}

on envVar A_FSG_85_0_0_27_Changed_IndexSize
{
    A_FSG_85_0_0_27_Changed_GenerateChanged();
}
on envVar A_FSG_85_0_0_27_Changed_TransPos
{
    A_FSG_85_0_0_27_Changed_GenerateChanged();
}
on envVar A_FSG_85_0_0_27_SetGet
{
    byte temp[23];
    getValue(A_FSG_85_0_0_27_SetGet, temp);
    putValue(A_FSG_85_0_0_27_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_85_0_0_27_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_85_0_0_27_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_85_0_0_27_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_85_0_0_27_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_85_0_0_27_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_85_0_0_27_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_85_0_0_27_SetGet_IndexSize))
    {
        putValue(A_FSG_85_0_0_27_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_85_0_0_27_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_85_0_0_27_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_85_0_0_27_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_85_0_0_27_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_85_0_0_27_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_85_0_0_27_ArrayDataList[i].Param1 = 0;
		A_FSG_85_0_0_27_ArrayDataList[i].Param2 = 0;
		A_FSG_85_0_0_27_ArrayDataList[i].Param3 = 0;
		for(j=0; j<5; j++)
			A_FSG_85_0_0_27_ArrayDataList[i].Param4[j] = 0;
		A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length = 0;
		A_FSG_85_0_0_27_Data_4_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_85_0_0_27_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 6) //ignore first line in *.csv file
					{
						A_FSG_85_0_0_27_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Parameter_ID
						A_FSG_85_0_0_27_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //DataDescription
						A_FSG_85_0_0_27_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //DataTag
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 6)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Parameter_ID
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //DataDescription
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //DataTag
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //Data
								if(paramPos < 1)
								{
									A_FSG_85_0_0_27_ArrayDataList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									A_FSG_85_0_0_27_ArrayDataList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_85_0_0_27_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_85_0_0_27_generateData_Btn_already_pressed == 0)
	{
		A_FSG_85_0_0_27_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_85_0_0_27_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_85_0_0_27_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_85_0_0_27_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
		putValue(A_FSG_85_0_0_27_Data_1, A_FSG_85_0_0_27_ArrayDataList[ getValue( A_FSG_85_0_0_27_DataIndex) ].Param1);
	putValue(A_FSG_85_0_0_27_Data_2, A_FSG_85_0_0_27_ArrayDataList[ getValue( A_FSG_85_0_0_27_DataIndex) ].Param2);
	putValue(A_FSG_85_0_0_27_Data_3, A_FSG_85_0_0_27_ArrayDataList[ getValue( A_FSG_85_0_0_27_DataIndex) ].Param3);
	putValue(A_FSG_85_0_0_27_Data_4, A_FSG_85_0_0_27_ArrayDataList[ getValue( A_FSG_85_0_0_27_DataIndex) ].Param4, A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex)].Param4_Length);
	}
}


on envVar A_FSG_85_0_0_27_generateData_Btn
{
	word i;
	dword elementsArray[5] = {4, 1, 1, 5, 2};
	byte elementsTypeArray[5] = {0, 0, 0, 0xC, 0xD};
	dword elementsMaxSizeArray[5] = {4294967295LL, 255, 0xFF, 0, 0};
	byte tempArray[75];
	if (A_FSG_85_0_0_27_generateData_Btn_already_pressed == 0)
	{
		A_FSG_85_0_0_27_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 27, 5 );
		for(i = 0; i < 5; i++)
		{
			memcpy(A_FSG_85_0_0_27_ArrayDataList[i], tempArray, (i * 15) );
			if(A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length > 127 )
				A_FSG_85_0_0_27_Data_4_CntList[i] = 1;
		}
		A_FSG_85_0_0_27_generateData_Btn_already_pressed = 0;
	putValue(A_FSG_85_0_0_27_Data_1, A_FSG_85_0_0_27_ArrayDataList[ getValue( A_FSG_85_0_0_27_DataIndex) ].Param1);
	putValue(A_FSG_85_0_0_27_Data_2, A_FSG_85_0_0_27_ArrayDataList[ getValue( A_FSG_85_0_0_27_DataIndex) ].Param2);
	putValue(A_FSG_85_0_0_27_Data_3, A_FSG_85_0_0_27_ArrayDataList[ getValue( A_FSG_85_0_0_27_DataIndex) ].Param3);
	putValue(A_FSG_85_0_0_27_Data_4, A_FSG_85_0_0_27_ArrayDataList[ getValue( A_FSG_85_0_0_27_DataIndex) ].Param4, A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex)].Param4_Length);
	}
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_85_0_0_27_DataIndex
{
    long index;
    long maxIndex = 5-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_85_0_0_27_Data_1, A_FSG_85_0_0_27_ArrayDataList[index].Param1*(1.0)-(0.0));
    putValue(A_FSG_85_0_0_27_Data_2, A_FSG_85_0_0_27_ArrayDataList[index].Param2*(1.0)-(0.0));
    putValue(A_FSG_85_0_0_27_Data_3, A_FSG_85_0_0_27_ArrayDataList[index].Param3);
    putValue(A_FSG_85_0_0_27_Data_4_len, A_FSG_85_0_0_27_Data_4_LenList[index]);
    putValue(A_FSG_85_0_0_27_Data_4, A_FSG_85_0_0_27_ArrayDataList[index].Param4, A_FSG_85_0_0_27_ArrayDataList[index].Param4_Length);

}
on envVar A_FSG_85_0_0_27_DataIndex_Incr
{
    long index;
    if(A_FSG_85_0_0_27_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_85_0_0_27_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_85_0_0_27_DataIndex);
        index++;
        putValue(A_FSG_85_0_0_27_DataIndex, index);
        A_FSG_85_0_0_27_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_85_0_0_27_DataIndex_Decr
{
    long index;
    if(A_FSG_85_0_0_27_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_85_0_0_27_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_85_0_0_27_DataIndex);
        index--;
        putValue(A_FSG_85_0_0_27_DataIndex, index);
        A_FSG_85_0_0_27_DataIndex_Decr_already_pressed = 0;
    }
}
// HME generateCaplOnEnv (3160)
on envVar A_FSG_85_0_0_27_DataIndex_SetGet
{
    long index;
    long maxIndex = 5-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_85_0_0_27_Data_1_SetGet, A_FSG_85_0_0_27_ArrayDataList[index].Param1*(1.0)-(0.0));
    putValue(A_FSG_85_0_0_27_Data_2_SetGet, A_FSG_85_0_0_27_ArrayDataList[index].Param2*(1.0)-(0.0));
    putValue(A_FSG_85_0_0_27_Data_3_SetGet, A_FSG_85_0_0_27_ArrayDataList[index].Param3);
    putValue(A_FSG_85_0_0_27_Data_4_SetGet_len, A_FSG_85_0_0_27_Data_4_SetGet_LenList[index]);
    putValue(A_FSG_85_0_0_27_Data_4_SetGet, A_FSG_85_0_0_27_ArrayDataList[index].Param4, A_FSG_85_0_0_27_ArrayDataList[index].Param4_Length);

}
on envVar A_FSG_85_0_0_27_DataIndex_SetGet_Incr
{
    long index;
    if(A_FSG_85_0_0_27_DataIndex_SetGet_Incr_already_pressed == 0)
    {
        A_FSG_85_0_0_27_DataIndex_SetGet_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_85_0_0_27_DataIndex_SetGet);
        index++;
        putValue(A_FSG_85_0_0_27_DataIndex_SetGet, index);
        A_FSG_85_0_0_27_DataIndex_SetGet_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_85_0_0_27_DataIndex_SetGet_Decr
{
    long index;
    if(A_FSG_85_0_0_27_DataIndex_SetGet_Decr_already_pressed == 0)
    {
        A_FSG_85_0_0_27_DataIndex_SetGet_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_85_0_0_27_DataIndex_SetGet);
        index--;
        putValue(A_FSG_85_0_0_27_DataIndex_SetGet, index);
        A_FSG_85_0_0_27_DataIndex_SetGet_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_85_0_0_27_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_85_0_0_27_ID;
    data[2]=getValue(A_FSG_85_0_0_27_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_85_0_0_27
on envVar A_FSG_85_0_0_27_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_27",1);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_85_0_0_27",1);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_27",1);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_27_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_85_0_0_27", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_27",0);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_85_0_0_27",0);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_27",0);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_85_0_0_27_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_85_0_0_27", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_85_0_0_27_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_85_0_0_27_SegmEn,0);
           intertelegram_err(A_FSG_85_0_0_27_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_85_0_0_27_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_85_0_0_27_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_85_0_0_27_IntTlgEn,0);
           sequence_err(A_FSG_85_0_0_27_ID,getValueSize(A_FSG_85_0_0_27_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_85_0_0_27_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_85_0_0_27_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_85_0_0_27_Status",1);
 	}
}



A_FSG_85_0_0_27_SetInd () { /* leere Function*/ }

A_FSG_85_0_0_27_SetGetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[23];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: Operation
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_FSG_85_0_0_27_1_SetGet, tempValue);
    //Einzelparameter: Type
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_FSG_85_0_0_27_2_SetGet, tempValue);
    //Einzelparameter: Slot
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_FSG_85_0_0_27_3_SetGet, tempValue);
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_85_0_0_27_4_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_85_0_0_27_5_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_85_0_0_27_SetGet, head, 5);
                if(getValue(A_FSG_85_0_0_27_AT))
                {
                    putValue(A_FSG_85_0_0_27,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_85_0_0_27_SetGet, head, 3);
            if(getValue(A_FSG_85_0_0_27_AT))
            {
                putValue(A_FSG_85_0_0_27,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_85_0_0_27_AT))
        {
            putValue(A_FSG_85_0_0_27_RecAdr,recordAddressVal);
            putValue(A_FSG_85_0_0_27_Start, startVal);
            putValue(A_FSG_85_0_0_27_Elements, elementsVal);
            putValue(A_FSG_85_0_0_27_TransPos, transmitPosVal);
        }
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_FSG_85_0_0_27_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 27");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           //Kein POS definiert
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           //Kein POS definiert
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 4 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_27_ArrayDataList[i].Param1 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<16) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<24);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_27_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_27_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 3 == recordAddressVal )
      {
        //voriger Parameter war ein first nibble, bei String Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length =  ((dword)(gBAP_Indication_data[currentPos++]) & 0xFF);
        A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length += ((dword)(gBAP_Indication_data[currentPos++]) & 0xFF) << 8;
        A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length += ((dword)(gBAP_Indication_data[currentPos++]) & 0xFF) << 16;
        A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length += ((dword)(gBAP_Indication_data[currentPos++]) & 0xFF) <<24;
        for(j = 0; j < A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length; j++)
        {
            A_FSG_85_0_0_27_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_FSG_85_0_0_27_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_FSG_85_0_0_27_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 27");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           //Kein POS definiert
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           //Kein POS definiert
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 4 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_27_ArrayDataList[i].Param1 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<16) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<24);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_27_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_27_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 3 == recordAddressVal )
      {
        //voriger Parameter war ein first nibble, bei String Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length =  ((dword)(gBAP_Indication_data[currentPos++]) & 0xFF);
        A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length += ((dword)(gBAP_Indication_data[currentPos++]) & 0xFF) << 8;
        A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length += ((dword)(gBAP_Indication_data[currentPos++]) & 0xFF) << 16;
        A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length += ((dword)(gBAP_Indication_data[currentPos++]) & 0xFF) <<24;
        for(j = 0; j < A_FSG_85_0_0_27_ArrayDataList[i].Param4_Length; j++)
        {
            A_FSG_85_0_0_27_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_FSG_85_0_0_27_DataIndex);
    putValue(A_FSG_85_0_0_27_Data_1, A_FSG_85_0_0_27_ArrayDataList[index].Param1*(1.0)-(0.0));
    putValue(A_FSG_85_0_0_27_Data_2, A_FSG_85_0_0_27_ArrayDataList[index].Param2*(1.0)-(0.0));
    putValue(A_FSG_85_0_0_27_Data_3, A_FSG_85_0_0_27_ArrayDataList[index].Param3);
    putValue(A_FSG_85_0_0_27_Data_4_len, A_FSG_85_0_0_27_Data_4_LenList[index]);
    putValue(A_FSG_85_0_0_27_Data_4, A_FSG_85_0_0_27_ArrayDataList[index].Param4, A_FSG_85_0_0_27_ArrayDataList[index].Param4_Length);
}

A_FSG_85_0_0_27_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[23];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: Operation
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_FSG_85_0_0_27_1_SetGet, tempValue);
    //Einzelparameter: Type
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_FSG_85_0_0_27_2_SetGet, tempValue);
    //Einzelparameter: Slot
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_FSG_85_0_0_27_3_SetGet, tempValue);
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_85_0_0_27_4_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_85_0_0_27_5_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_85_0_0_27_SetGet, head, 5);
                if(getValue(A_FSG_85_0_0_27_AT))
                {
                    putValue(A_FSG_85_0_0_27,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_85_0_0_27_SetGet, head, 3);
            if(getValue(A_FSG_85_0_0_27_AT))
            {
                putValue(A_FSG_85_0_0_27,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_85_0_0_27_AT))
        {
            putValue(A_FSG_85_0_0_27_RecAdr,recordAddressVal);
            putValue(A_FSG_85_0_0_27_Start, startVal);
            putValue(A_FSG_85_0_0_27_Elements, elementsVal);
            putValue(A_FSG_85_0_0_27_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_85_0_0_27_1
{

	//Update Childvalue (Enum)
	byte thisval; // Operation
	thisval = getValue(this);
}
on envVar A_FSG_85_0_0_27_2
{

	//Update Childvalue (Enum)
	byte thisval; // Type
	thisval = getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_27_3_range // PSO_ImExport.Slot 
{
	@A_FSG_85_0_0_27_3 = @A_FSG_85_0_0_27_3_range - (1); // slider = range - min
}

on envVar A_FSG_85_0_0_27_3
{

	//Update Childvalue (Number)
	byte thisval; // Slot
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_27_3, 1.0);
	@A_FSG_85_0_0_27_3_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_FSG_85_0_0_27_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // State
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_FSG_85_0_0_27_4,thisval);
}

on envVar A_FSG_85_0_0_27_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // State
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_FSG_85_0_0_27_4,thisval);
}

on envVar A_FSG_85_0_0_27_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // State
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(A_FSG_85_0_0_27_4,thisval);
}

on envVar A_FSG_85_0_0_27_4
{

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // State
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_FSG_85_0_0_27_4_0, 1);
	else
		putValue(A_FSG_85_0_0_27_4_0, 0);
	if(thisval&(mask<<1))
		putValue(A_FSG_85_0_0_27_4_1, 1);
	else
		putValue(A_FSG_85_0_0_27_4_1, 0);
	if(thisval&(mask<<2))
		putValue(A_FSG_85_0_0_27_4_2, 1);
	else
		putValue(A_FSG_85_0_0_27_4_2, 0);
}
on envVar A_FSG_85_0_0_27_5
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_27_6_range // PSO_ImExport.TAID 
{
	@A_FSG_85_0_0_27_6 = @A_FSG_85_0_0_27_6_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_27_6
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_27_6, 1.0);
	@A_FSG_85_0_0_27_6_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_27_7_range // PSO_ImExport.TotalNumListElements 
{
	@A_FSG_85_0_0_27_7 = @A_FSG_85_0_0_27_7_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_27_7
{

	//Update Childvalue (Number)
	word thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_27_7, 1.0);
	@A_FSG_85_0_0_27_7_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_27_Data_1_range // PSO_ImExport.Parameter_ID 
{
	@A_FSG_85_0_0_27_Data_1 = @A_FSG_85_0_0_27_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_27_Data_1
{

	//Update Childvalue (Number)
	dword thisval; // Parameter_ID
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_27_Data_1, 1.0);
	@A_FSG_85_0_0_27_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (dword)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex)].Param1 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_27_Data_2_range // PSO_ImExport.DataDescription 
{
	@A_FSG_85_0_0_27_Data_2 = @A_FSG_85_0_0_27_Data_2_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_27_Data_2
{

	//Update Childvalue (Number)
	byte thisval; // DataDescription
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_27_Data_2, 1.0);
	@A_FSG_85_0_0_27_Data_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex)].Param2 = thisval;
}
on envVar A_FSG_85_0_0_27_Data_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_FSG_85_0_0_27_Data_3,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_FSG_85_0_0_27_Data_3,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(A_FSG_85_0_0_27_Data_3,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(A_FSG_85_0_0_27_Data_3,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(A_FSG_85_0_0_27_Data_3,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(A_FSG_85_0_0_27_Data_3,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3
{

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // DataTag
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_FSG_85_0_0_27_Data_3_0, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_0, 0);
	if(thisval&(mask<<1))
		putValue(A_FSG_85_0_0_27_Data_3_1, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_1, 0);
	if(thisval&(mask<<4))
		putValue(A_FSG_85_0_0_27_Data_3_4, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_4, 0);
	if(thisval&(mask<<5))
		putValue(A_FSG_85_0_0_27_Data_3_5, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_5, 0);
	if(thisval&(mask<<6))
		putValue(A_FSG_85_0_0_27_Data_3_6, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_6, 0);
	if(thisval&(mask<<7))
		putValue(A_FSG_85_0_0_27_Data_3_7, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_7, 0);
    A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex)].Param3 = thisval;
}
on envVar A_FSG_85_0_0_27_Data_4_len
{
	long thisval;
	thisval = getValue(this);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 1 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_85_0_0_27_Data_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 1);
		thisval = 1;
	}

	A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex)].Param4_Length = thisval;
	A_FSG_85_0_0_27_Data_4_LenList[ getValue(A_FSG_85_0_0_27_DataIndex) ] = thisval;
	putValue(A_FSG_85_0_0_27_Data_4_len, thisval);

}

on envVar A_FSG_85_0_0_27_Data_4
{

	//Update Childvalue (Large String)
	dword i;
	byte thisval[5];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex)].Param4[i] = thisval[i];
    A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex)].Param4_Length = getValueSize(this);
    A_FSG_85_0_0_27_Data_4_LenList[getValue(A_FSG_85_0_0_27_DataIndex)]= getValueSize(this);
    putValue(A_FSG_85_0_0_27_Data_4_len, getValueSize(this));
}
on envVar A_FSG_85_0_0_27_1_Changed
{

	//Update Childvalue (Enum)
	byte thisval; // Operation
	thisval = getValue(this);
}
on envVar A_FSG_85_0_0_27_2_Changed
{

	//Update Childvalue (Enum)
	byte thisval; // Type
	thisval = getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_27_3_Changed_range // PSO_ImExport.Slot 
{
	@A_FSG_85_0_0_27_3_Changed = @A_FSG_85_0_0_27_3_Changed_range - (1); // slider = range - min
}

on envVar A_FSG_85_0_0_27_3_Changed
{

	//Update Childvalue (Number)
	byte thisval; // Slot
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_27_3_Changed, 1.0);
	@A_FSG_85_0_0_27_3_Changed_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_FSG_85_0_0_27_1_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // Operation
	thisval = getValue(this);
}
on envVar A_FSG_85_0_0_27_2_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // Type
	thisval = getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_27_3_SetGet_range // PSO_ImExport.Slot 
{
	@A_FSG_85_0_0_27_3_SetGet = @A_FSG_85_0_0_27_3_SetGet_range - (1); // slider = range - min
}

on envVar A_FSG_85_0_0_27_3_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // Slot
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_27_3_SetGet, 1.0);
	@A_FSG_85_0_0_27_3_SetGet_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_FSG_85_0_0_27_4_SetGet
{

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_27_5_SetGet_range // PSO_ImExport.TAID 
{
	@A_FSG_85_0_0_27_5_SetGet = @A_FSG_85_0_0_27_5_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_27_5_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_27_5_SetGet, 1.0);
	@A_FSG_85_0_0_27_5_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_27_Data_1_SetGet_range // PSO_ImExport.Parameter_ID 
{
	@A_FSG_85_0_0_27_Data_1_SetGet = @A_FSG_85_0_0_27_Data_1_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_27_Data_1_SetGet
{

	//Update Childvalue (Number)
	dword thisval; // Parameter_ID
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_27_Data_1_SetGet, 1.0);
	@A_FSG_85_0_0_27_Data_1_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (dword)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex_SetGet)].Param1 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_85_0_0_27_Data_2_SetGet_range // PSO_ImExport.DataDescription 
{
	@A_FSG_85_0_0_27_Data_2_SetGet = @A_FSG_85_0_0_27_Data_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_85_0_0_27_Data_2_SetGet
{

	//Update Childvalue (Number)
	byte thisval; // DataDescription
	float slider_value;

	slider_value = round(@A_FSG_85_0_0_27_Data_2_SetGet, 1.0);
	@A_FSG_85_0_0_27_Data_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex_SetGet)].Param2 = thisval;
}
on envVar A_FSG_85_0_0_27_Data_3_SetGet_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3_SetGet);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_FSG_85_0_0_27_Data_3_SetGet,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_SetGet_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3_SetGet);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_FSG_85_0_0_27_Data_3_SetGet,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_SetGet_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3_SetGet);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(A_FSG_85_0_0_27_Data_3_SetGet,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_SetGet_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3_SetGet);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(A_FSG_85_0_0_27_Data_3_SetGet,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_SetGet_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3_SetGet);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(A_FSG_85_0_0_27_Data_3_SetGet,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_SetGet_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // DataTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_85_0_0_27_Data_3_SetGet);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(A_FSG_85_0_0_27_Data_3_SetGet,thisval);
}

on envVar A_FSG_85_0_0_27_Data_3_SetGet
{

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // DataTag
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_0, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_0, 0);
	if(thisval&(mask<<1))
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_1, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_1, 0);
	if(thisval&(mask<<4))
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_4, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_4, 0);
	if(thisval&(mask<<5))
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_5, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_5, 0);
	if(thisval&(mask<<6))
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_6, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_6, 0);
	if(thisval&(mask<<7))
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_7, 1);
	else
		putValue(A_FSG_85_0_0_27_Data_3_SetGet_7, 0);
    A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex_SetGet)].Param3 = thisval;
}
on envVar A_FSG_85_0_0_27_Data_4_SetGet_len
{
	long thisval;
	thisval = getValue(this);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 1 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_85_0_0_27_Data_4_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 1);
		thisval = 1;
	}

	A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex_SetGet)].Param4_Length = thisval;
	A_FSG_85_0_0_27_Data_4_SetGet_LenList[ getValue(A_FSG_85_0_0_27_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_85_0_0_27_Data_4_SetGet_len, thisval);

}

on envVar A_FSG_85_0_0_27_Data_4_SetGet
{

	//Update Childvalue (Large String)
	dword i;
	byte thisval[5];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex_SetGet)].Param4[i] = thisval[i];
    A_FSG_85_0_0_27_ArrayDataList[getValue(A_FSG_85_0_0_27_DataIndex_SetGet)].Param4_Length = getValueSize(this);
    A_FSG_85_0_0_27_Data_4_SetGet_LenList[getValue(A_FSG_85_0_0_27_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_85_0_0_27_Data_4_SetGet_len, getValueSize(this));
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_85_0_0_28_ErrCode
{
       if(gP_FSG_85_0_0_28_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_85_0_0_28", MakeRGB(255,255,255));
       }
       gP_FSG_85_0_0_28_ErrCode = 1;
}
on envVar P_FSG_85_0_0_28Status_BTN
{
	byte BAPTemp[11];
    if (P_FSG_85_0_0_28Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_85_0_0_28_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_85_0_0_28",MakeRGB(255,255,255));
        P_FSG_85_0_0_28Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_85_0_0_28_BuildFct();
        getValue(P_FSG_85_0_0_28, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_85_0_0_28_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_85_0_0_28));
        if(getValue(P_FSG_85_0_0_28_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_85_0_0_28_ID);
        }
        if(getValue(P_FSG_85_0_0_28_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_85_0_0_28_ID,elCount(BAPTemp));
        }
       P_FSG_85_0_0_28Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_85_0_0_28_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_85_0_0_28_ID;
    data[2]=getValue(P_FSG_85_0_0_28_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_85_0_0_28
on envVar P_FSG_85_0_0_28_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_28",1);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_28",1);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_28",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_28", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_85_0_0_28",0);
           EnableControl(panel_name,"errfield_P_FSG_85_0_0_28",0);
           EnableControl(panel_name,"panel_P_FSG_85_0_0_28",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_85_0_0_28", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_28_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_28_SegmEn,0);
           intertelegram_err(P_FSG_85_0_0_28_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_85_0_0_28_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_85_0_0_28_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_85_0_0_28_IntTlgEn,0);
           sequence_err(P_FSG_85_0_0_28_ID,getValueSize(P_FSG_85_0_0_28_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_85_0_0_28_ID);
       }
}
on envVar P_FSG_85_0_0_28 // bus value of SystemState2 (28).
{
	// opcodes: Error-Status
	byte param1; // stateGarageParking_Modification
	byte param2; // stateGarageParking
	byte param3; // Extension1
	byte param4; // Extension2
	byte param5; // Extension3
	byte param6; // Extension4
	byte param7; // Extension5
	byte param8; // Extension6
	byte param9; // Extension7
	byte param10; // Extension8
	byte param11; // Extension9
	byte param12; // Extension10
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
	for( i = 0; i < 11; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_85_0_0_28, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_85_0_0_28_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_85_0_0_28_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_85_0_0_28_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_85_0_0_28_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_85_0_0_28_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_85_0_0_28_6, round((param6 * 1.0) - (0) + (0), 1.0));
	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_FSG_85_0_0_28_7, round((param7 * 1.0) - (0) + (0), 1.0));
	///////// Start param8 - UINT8 /////////
	param8 = superval[currentPos++];
	putValue(P_FSG_85_0_0_28_8, round((param8 * 1.0) - (0) + (0), 1.0));
	///////// Start param9 - UINT8 /////////
	param9 = superval[currentPos++];
	putValue(P_FSG_85_0_0_28_9, round((param9 * 1.0) - (0) + (0), 1.0));
	///////// Start param10 - UINT8 /////////
	param10 = superval[currentPos++];
	putValue(P_FSG_85_0_0_28_10, round((param10 * 1.0) - (0) + (0), 1.0));
	///////// Start param11 - UINT8 /////////
	param11 = superval[currentPos++];
	putValue(P_FSG_85_0_0_28_11, round((param11 * 1.0) - (0) + (0), 1.0));
	///////// Start param12 - UINT8 /////////
	param12 = superval[currentPos++];
	putValue(P_FSG_85_0_0_28_12, round((param12 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_FSG_85_0_0_28_BuildFct()
{
	byte param1; // stateGarageParking_Modification
	byte param2; // stateGarageParking
	byte param3; // Extension1
	byte param4; // Extension2
	byte param5; // Extension3
	byte param6; // Extension4
	byte param7; // Extension5
	byte param8; // Extension6
	byte param9; // Extension7
	byte param10; // Extension8
	byte param11; // Extension9
	byte param12; // Extension10

	dword i;
	byte superval[11];
	dword currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_FSG_85_0_0_28_1);
	param1 = param1 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_85_0_0_28_2);
	param2 = param2 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param2;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_28_3_range = round(@P_FSG_85_0_0_28_3 + (0), 1.0); // slider value + min = real value
	param3 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_28_4_range = round(@P_FSG_85_0_0_28_4 + (0), 1.0); // slider value + min = real value
	param4 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_28_5_range = round(@P_FSG_85_0_0_28_5 + (0), 1.0); // slider value + min = real value
	param5 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_28_6_range = round(@P_FSG_85_0_0_28_6 + (0), 1.0); // slider value + min = real value
	param6 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_28_7_range = round(@P_FSG_85_0_0_28_7 + (0), 1.0); // slider value + min = real value
	param7 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param7;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_28_8_range = round(@P_FSG_85_0_0_28_8 + (0), 1.0); // slider value + min = real value
	param8 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param8;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_28_9_range = round(@P_FSG_85_0_0_28_9 + (0), 1.0); // slider value + min = real value
	param9 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param9;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_28_10_range = round(@P_FSG_85_0_0_28_10 + (0), 1.0); // slider value + min = real value
	param10 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param10;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_28_11_range = round(@P_FSG_85_0_0_28_11 + (0), 1.0); // slider value + min = real value
	param11 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param11;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_85_0_0_28_12_range = round(@P_FSG_85_0_0_28_12 + (0), 1.0); // slider value + min = real value
	param12 = 0; // underlying parameter has constant value 0.0.
	superval[currentPos++]=param12;
	putValue(P_FSG_85_0_0_28, superval, currentPos);
}


on envVar P_FSG_85_0_0_28_1 // SystemState2.stateGarageParking_Modification
{
	P_FSG_85_0_0_28_BuildFct();
}

on envVar P_FSG_85_0_0_28_2 // SystemState2.stateGarageParking
{
	P_FSG_85_0_0_28_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_28_3_range // SystemState2.Extension1 
{
	@P_FSG_85_0_0_28_3 = @P_FSG_85_0_0_28_3_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_28_3 // SystemState2.Extension1
{
	P_FSG_85_0_0_28_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_28_4_range // SystemState2.Extension2 
{
	@P_FSG_85_0_0_28_4 = @P_FSG_85_0_0_28_4_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_28_4 // SystemState2.Extension2
{
	P_FSG_85_0_0_28_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_28_5_range // SystemState2.Extension3 
{
	@P_FSG_85_0_0_28_5 = @P_FSG_85_0_0_28_5_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_28_5 // SystemState2.Extension3
{
	P_FSG_85_0_0_28_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_28_6_range // SystemState2.Extension4 
{
	@P_FSG_85_0_0_28_6 = @P_FSG_85_0_0_28_6_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_28_6 // SystemState2.Extension4
{
	P_FSG_85_0_0_28_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_28_7_range // SystemState2.Extension5 
{
	@P_FSG_85_0_0_28_7 = @P_FSG_85_0_0_28_7_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_28_7 // SystemState2.Extension5
{
	P_FSG_85_0_0_28_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_28_8_range // SystemState2.Extension6 
{
	@P_FSG_85_0_0_28_8 = @P_FSG_85_0_0_28_8_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_28_8 // SystemState2.Extension6
{
	P_FSG_85_0_0_28_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_28_9_range // SystemState2.Extension7 
{
	@P_FSG_85_0_0_28_9 = @P_FSG_85_0_0_28_9_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_28_9 // SystemState2.Extension7
{
	P_FSG_85_0_0_28_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_28_10_range // SystemState2.Extension8 
{
	@P_FSG_85_0_0_28_10 = @P_FSG_85_0_0_28_10_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_28_10 // SystemState2.Extension8
{
	P_FSG_85_0_0_28_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_28_11_range // SystemState2.Extension9 
{
	@P_FSG_85_0_0_28_11 = @P_FSG_85_0_0_28_11_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_28_11 // SystemState2.Extension9
{
	P_FSG_85_0_0_28_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_85_0_0_28_12_range // SystemState2.Extension10 
{
	@P_FSG_85_0_0_28_12 = @P_FSG_85_0_0_28_12_range - (0); // slider = range - min
}

on envVar P_FSG_85_0_0_28_12 // SystemState2.Extension10
{
	P_FSG_85_0_0_28_BuildFct();
}



/**
*
* Template-Funktion zum automatischen befuellen der Array-Daten, die in einer Arrayfunktion genutzt werden.
* Die Funktion wird durch den von BAPSimGen generierten Code aufgerufen.
*
* Parameter:
* - structArray: Muss mindestens nMax * Arraygroesse Bytes Platz haben, wird vom BAPSimGen automatisch generiert
* - structElementsSizeArray: Enthaelt die Groesseangabe jedes Array-Elements. Die Arraygroesse entspricht der Elementanzahl im Array.
*       Byte & Nibble = 1; Word = 2; usw. Bei Strings wird die maximale Stringlaenge angegeben.
* - structElementsTypeArray: Gibt den Datentyp eines Array-Elements zurueck. Die Arraygroesse entspricht der Elmentanzahl im Array.
*                               0x0 = Zahlenwert, also ein Slider, Enum, Bitfield,...
*                               0xE = String (darauf folgt immer eine 2, mit der Angabe der benutzen Bytes im String)
*                               0xF = Laenge der Nutzdaten des Strings, nur return Wert
* - fctID: Kann zur Fallunterscheidung der Funktions-IDs verwendet werden.
* - nMax: Array-Index
*
* Die Funktion kann im Switch-Case beliebig erweitert werden. Der Switch-Case wertet den Parameter fctID aus.
*           
*                    
**/
initStruct(byte structArray[], dword structElementsSizeArray[], byte structElementsTypeArray[], dword structElementsMaxSizeArray[], word fctID, word nMax )
{
    byte rand8;
    word rand16;
    dword randSize;
    word index;           //indexNr die an die String Parameter angehaengt wird.
    dword destArraySize;   //groesse von structArray
    dword destStructSize;  //groesse eines "Structs" also destArraySize / Anzahl Elemente (nMax))
    dword rand32;    
    dword i;
    dword pos;    //aktuelle Position im structArray
    dword elpos;  //aktuelle Position in den structElementsXXXArray's
    
    destArraySize = elCount(structArray);
    destStructSize = destArraySize / nMax;    

    Switch(fctID){

        //Idee ist, die Arrays je nach Funcion-ID speziell initalisieren zu koennen.
        //hierbei koennten die Daten z.B. aus einer Datei eingelesen werden,
        //oder auch ueber spezielle init Funktionen mit festen Werten initialisiert werden.
        //Der Default-Fall befuellt das Array mit Random-Werten und Strings mit einem vordefinierten Wort (hier test,)

        default :
        {
            pos = 0; 
            for(i = 1; i <= nMax; i++)
            {
                //walk through the array
                elpos = 0;
                while(pos < (destStructSize * i) )
                {   
                    //check Element type
                    if( structElementsTypeArray[elpos] == 0x0)          
                    { //Params like int, word, etc.
                        //check element length
                        
                        Switch(structElementsSizeArray[elpos])
                        {
                            case(1) : //byte / nibble
                                rand8 = random(structElementsMaxSizeArray[elpos]);
                                structArray[pos] = rand8;
                                pos++;
                                break;

                            case(2) : //word / int
                                rand16 = random(structElementsMaxSizeArray[elpos]);
                                int2byte(structArray, pos, rand16);
                                pos += 2;
                                break;

                            case (4) : //dword / long
                                rand32 = random(structElementsMaxSizeArray[elpos]);
                                long2byte(structArray, pos, rand32);
                                pos += 4;
                                break;                        
                         }

                    }
                    else if(structElementsTypeArray[elpos] == 0xC)          
                    { //String Params like byte[]
                        randSize = random(structElementsSizeArray[elpos]);
                        if(randSize < 4) randSize = 4; 
                        index = i-1;
                        setRandomString(structArray ,pos ,structElementsSizeArray[elpos], randSize, index);
                        pos += structElementsSizeArray[elpos];
                    }
                    else if(structElementsTypeArray[elpos] == 0xD)          
                    { 
                        structArray[pos++] = randSize & 0xFF;
                        structArray[pos++] = (randSize >> 8) & 0xFF;
                        structArray[pos++] = (randSize >> 16) & 0xFF;
                        structArray[pos++] = (randSize >> 24) & 0xFF;
                    }
                    else if(structElementsTypeArray[elpos] == 0xE)          
                    { //String Params like byte[]
                        randSize = random(structElementsSizeArray[elpos]);
                        
                        if(randSize < 2) randSize = 2; 
                        index = i-1;
                        setRandomString(structArray ,pos ,structElementsSizeArray[elpos], randSize, index);
                        pos += structElementsSizeArray[elpos];
                    }
                    else if(structElementsTypeArray[elpos] == 0xF)          
                    {
                        int2byte(structArray, pos, randSize);
                        pos += 2;
                        //write("Pos: %d Strlth: %d Type: %d ",pos-1,randSize,structElementsTypeArray[elpos]);
                    }
                    elpos++;
                }
            }   
        break;
        }            
    }
}

long2Byte(byte in[], dword pos, dword value)
{
    if( (elCount(in)-pos) < 4)
        write("Array out ouf bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);
    in[++pos] = (value >> 16);
    in[++pos] = (value >> 24);
}

int2byte (byte in[],dword pos,word value)
{
    if( (elCount(in)-pos) < 2 )
        write("Array out of bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);        
}

setRandomString (byte in[], dword pos, word strSize, dword randSize, dword count)
{
    dword endPos, endString, j;
    byte testString[4]={'t','e','s','t'};
    
    endPos = pos + strSize;
    endString = pos + randSize;
    j=0;
    
    int2ascii(in, pos, count);
    pos += 2;
    
    for(pos; pos < endPos ;pos ++)
    {
        if(j > 3 )
            j = 0;
        if(pos < endString)
            in[pos] = testString[j++];
        else
            in[pos] = 0x0;
    }
}

int2ascii (byte in[], dword pos, word value)
{
    //Konvertiert nur die erste und zweite Dezimalstelle, also Zahlen zw. 0 und 99.
    
    //auf 2 Stellen kuerzen
    value = value%100;
    //10er schreiben
    in[pos] = (value/10) + 48;    //  0x30 hex = 48 dez = ascii null
    //1er schreiben
    in[pos+1] = (value%10) + 48;  //  0x30 hex = 48 dez = ascii null
}

