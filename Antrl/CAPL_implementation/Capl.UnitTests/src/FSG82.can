/*@!Encoding:1252*/
includes
{
    #include "..\..\..\_DLL\latest_BAP_DLL.cin"
}

variables
{
	char  dbcan_path[255] = "BAP\\IAA_PSO_FSG82\\db\\BAP_only_MQB_MLBevo_v2.40_FD.dbc";
	char  dbeth_path[255] = "BAP\\IAA_PSO_FSG82\\db\\E3_1_1_MEB_V10.05.04F_AR421_20181130_ICAS1_Sys_Java_02.arxml";
    char  xml_path[255]   = "BAP\\IAA_PSO_FSG82\\fsg82\\bapxml\\BAP_SW18_IAA_PSO_P31DF43_V2.33_FSG.xml";

    //@BAPSIMGEN_VAR_SECTION_BEGIN

    /***************************************************/
    /*            BapSimGen FSG template               */
    /***************************************************/

    /************** Ausgabe Konsole (Traces) ***********/
    dword gBAP_Trace;
    dword gError_Trace;

    /************** Node Verwaltung ***************/
    //Power on/off
    byte gSG_PowerOnOff=0x01;     // wird mit Power_off/on gesetzt
    byte gBAP_Init=0;             // schon mal initialisiert?

    const Power_off   = 0x00;
    const Power_on    = 0x01;

    mstimer TaskTimer;                //real communication timer

    /************** Request **************/
    const Requestbuffer_lines = 18;
    const dword BAP_buffer_size = 1167;

    /************ Speichern von Requests im "Ringbuffer" ***********/
    int   gBAP_Requestbuffer_status    [Requestbuffer_lines];                     // 0: kein Eintrag, 1: pending
    dword gBAP_Request_header        [Requestbuffer_lines] [6];                 // beinhaltet auch skalare Daten
    dword gBAP_Request_data         [Requestbuffer_lines] [BAP_buffer_size]; // Ringbuffer fuer BAP-Request


    /************** Indication **************/
    // enthaelt die derzeitige Indication
    dword gBAP_Indication_header[6];
    byte  gBAP_Indication_data[BAP_buffer_size];

    /************** Konstanten ****************/

    //BAP Data Type
    const Bap_void                =0;
    const Bap_uint8                =1;
    const Bap_uint16            =2;
    const Bap_uint32            =3;
    const Bap_byteSequence        =4;
    const Bap_fixedByteSequence =4;
    const Bap_error                =5;
    const Bap_acknowledge        =6;

    char Datatype_Text[7][20] =
    {
        "void", "uint8", "uint16", "uint32", "byteSequence", "error", "acknowledge"
    };

    //BAP request types
    const DataSetGet_REQ    = 0x00;
    const DataSet_REQ        = 0x01;
    const DataGet_REQ        = 0x02;
    const Data_REQ            = 0x03;
    const Changed_REQ        = 0x04;
    const Start_REQ            = 0x05;
    const StartResult_REQ    = 0x06;
    const AbortResult_REQ    = 0x07;
    const Processing_REQ    = 0x08;
    const Result_REQ        = 0x09;
    const DataAck_REQ       = 0x0A;
    const Ack_REQ           = 0x0B;
    const Invalid_REQ        = 0x1F; // Kennzeichnung fuer einen ungueltigen Request
    const Error_REQ         = 0x20;

    char Requesttype_Text[33][30] =
    {
        "DataSetGet_REQ", "DataSet_REQ", "DataGet_REQ", "Data_REQ",            /* 00 .. 03 */
        "Changed_REQ", "Start_REQ", "StartResult_REQ", "AbortResult_REQ",   /* 04 .. 07 */
        "Processing_REQ", "Result_REQ", "DataAck_REQ", "Ack_REQ",         /* 08 .. 0b */
        "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",          /* 0c .. 0f */
        "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",          /* 10 .. 13 */
        "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",          /* 14 .. 17 */
        "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",         /* 18 .. 1b */
        "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",          /* 1c .. 1f */
        "Error_REQ"                                                              /* 20 */
    };

    //BAP indication types
    const Data_IND                = 0x00;
    const Reset_IND                = 0x01;
    const DataAck_IND            = 0x02;
    const Result_IND            = 0x03;
    const Processing_IND        = 0x04;
    const Changed_IND            = 0x05;
    const DataSetGet_IND        = 0x06;
    const DataSet_IND            = 0x07;
    const DataGet_IND            = 0x08;
    const Ack_IND                = 0x09;
    const Processing_CNF_IND    = 0x0A;
    const Start_IND                = 0x0B;
    const StartResult_IND        = 0x0C;
    const AbortResult_IND        = 0x0D;
    const Invalid_IND            = 0x1F; // Kennzeichnung fuer eine ungueltige Indication
    const Error_IND             = 0x20;

    char Indicationtype_Text[33][30] =
    {
        "Data_IND", "Reset_IND", "DataAck_IND", "Result_IND",                /* 00 .. 03 */
        "Processing_IND", "Changed_IND", "DataSetGet_IND", "DataSet_IND",    /* 04 .. 07 */
        "DataGet_IND", "Ack_IND", "Processing_CNF_IND", "Start_REQ",        /* 08 .. 0b */
        "StartResult_REQ", "AbortResult_REQ", "Invalid_REQ", "Invalid_REQ", /* 0c .. 0f */
        "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",            /* 10 .. 13 */
        "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",            /* 14 .. 17 */
        "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",            /* 18 .. 1b */
        "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",            /* 1c .. 1f */
        "Error_REQ"                                                              /* 20 */
    };

    char Acknowledgetype_Text[24][30] =
    {
        "Property_SetGet_ACK", "Array_SetGet_ACK", "Property_Set_ACK", "Array_Set_ACK",                /* 00 .. 03 */
        "Method_Start_ACK", "Method_StartResult_ACK", "Method_AbortResult_ACK", "Property_Get_ACK",    /* 04 .. 07 */
        "Array_Get_ACK", "Cache_GetAll_ACK", "Property_Ack_ACK", "Property_Status_ACK",                   /* 08 .. 0b */
        "Property_StatusAck_ACK", "Property_Error_ACK", "Array_Status_ACK", "Array_Changed_ACK",    /* 0c .. 0f */
        "Array_Error_ACK", "Method_Processing_ACK", "Method_Result_ACK", "Method_Error_ACK",          /* 10 .. 13 */
        "Unknown_ACK", "Unknown_ACK", "Unknown_ACK", "Unknown_ACK"                                    /* 14 .. 17 */
    };

    /**************************** Global Function-ID's ******************************/

    byte already_pressed = 0;

    const FctID_GetAll                                    = 0x01;
    const FctID_BAP_Config                                = 0x02;
    const FctID_FunctionList                            = 0x03;
    const FctID_HeartBeat                                = 0x04;

    char SGtype[4] = "FSG";

  _align(1) struct CommConfigStruct{
    char  Name[100];
    dword Number;
    dword Channel;
    dword Reserved;
  };

  byte isSelectedCAN;
  byte isSelectedEth;
  byte isSelectedFr;

    //// Begin: konfigurationsabhýngige Variablen, die als BAPCONFIG_VARS in Template definiert sind

    dword NODE_INDEX                =  0;
    char  NODE_NAME[100]            = "IAA_PSO";
    const LSGID                     = 82;
    char  panel_name[100]           = "FSG82_0";
    char  bapconfig_panel_name[100]    = "panel1";
    char  common_panel_name[100]    = "panel2";
    const TaskTime                  = 10;
     const C_FSG_82_0_0_1_ID = 1;
     char gCheckbox1[100] = "checkbox_C_FSG_82_0_0_1";
     char gErrField1[100] = "errfield_C_FSG_82_0_0_1";
     byte gC_FSG_82_0_0_1_ErrCode = 1;
     const P_FSG_82_0_0_2_ID = 2;
     byte P_FSG_82_0_0_2Reset_BTN_already_pressed = 0;
     char gCheckbox2[100] = "checkbox_P_FSG_82_0_0_2";
     char gErrField2[100] = "errfield_P_FSG_82_0_0_2";
     byte gP_FSG_82_0_0_2_ErrCode = 1;
     const P_FSG_82_0_0_3_ID = 3;
     byte P_FSG_82_0_0_3Status_BTN_already_pressed = 0;
     char gCheckbox3[100] = "checkbox_P_FSG_82_0_0_3";
     char gErrField3[100] = "errfield_P_FSG_82_0_0_3";
     byte gP_FSG_82_0_0_3_ErrCode = 1;
     const P_FSG_82_0_0_4_ID = 4;
     byte P_FSG_82_0_0_4Status_BTN_already_pressed = 0;
     char gCheckbox4[100] = "checkbox_P_FSG_82_0_0_4";
     char gErrField4[100] = "errfield_P_FSG_82_0_0_4";
     byte gP_FSG_82_0_0_4_ErrCode = 1;
     const P_FSG_82_0_0_13_ID = 13;
     byte P_FSG_82_0_0_13Status_BTN_already_pressed = 0;
     char gCheckbox13[100] = "checkbox_P_FSG_82_0_0_13";
     char gErrField13[100] = "errfield_P_FSG_82_0_0_13";
     byte gP_FSG_82_0_0_13_ErrCode = 1;
     char gPanel13[100] = "panel_P_FSG_82_0_0_13";
     const P_FSG_82_0_0_15_ID = 15;
     byte P_FSG_82_0_0_15Status_BTN_already_pressed = 0;
     char gCheckbox15[100] = "checkbox_P_FSG_82_0_0_15";
     char gErrField15[100] = "errfield_P_FSG_82_0_0_15";
     byte gP_FSG_82_0_0_15_ErrCode = 1;
     char gPanel15[100] = "panel_P_FSG_82_0_0_15";
     const P_FSG_82_0_0_16_ID = 16;
     byte P_FSG_82_0_0_16Status_BTN_already_pressed = 0;
     byte P_FSG_82_0_0_16StatusAck_BTN_already_pressed = 0;
     char gCheckbox16[100] = "checkbox_P_FSG_82_0_0_16";
     char gErrField16[100] = "errfield_P_FSG_82_0_0_16";
     byte gP_FSG_82_0_0_16_ErrCode = 1;
     char gPanel16[100] = "panel_P_FSG_82_0_0_16";
     const P_FSG_82_0_0_17_ID = 17;
     byte P_FSG_82_0_0_17Status_BTN_already_pressed = 0;
     byte P_FSG_82_0_0_17StatusAck_BTN_already_pressed = 0;
     char gCheckbox17[100] = "checkbox_P_FSG_82_0_0_17";
     char gErrField17[100] = "errfield_P_FSG_82_0_0_17";
     byte gP_FSG_82_0_0_17_ErrCode = 1;
     char gPanel17[100] = "panel_P_FSG_82_0_0_17";
     const P_FSG_82_0_0_18_ID = 18;
     byte P_FSG_82_0_0_18Status_BTN_already_pressed = 0;
     char gCheckbox18[100] = "checkbox_P_FSG_82_0_0_18";
     char gErrField18[100] = "errfield_P_FSG_82_0_0_18";
     byte gP_FSG_82_0_0_18_ErrCode = 1;
     char gPanel18[100] = "panel_P_FSG_82_0_0_18";
     const P_FSG_82_0_0_19_ID = 19;
     byte P_FSG_82_0_0_19Status_BTN_already_pressed = 0;
     char gCheckbox19[100] = "checkbox_P_FSG_82_0_0_19";
     char gErrField19[100] = "errfield_P_FSG_82_0_0_19";
     byte gP_FSG_82_0_0_19_ErrCode = 1;
     char gPanel19[100] = "panel_P_FSG_82_0_0_19";
     const A_FSG_82_0_0_20_ID = 20;
     byte A_FSG_82_0_0_20Changed_BTN_already_pressed = 0;
     byte A_FSG_82_0_0_20Status_BTN_already_pressed = 0;
     char gCheckbox20[100] = "checkbox_A_FSG_82_0_0_20";
     char gErrField20[100] = "errfield_A_FSG_82_0_0_20";
     byte gA_FSG_82_0_0_20_ErrCode = 1;
     char gPanel20[100] = "panel_A_FSG_82_0_0_20";
     byte A_FSG_82_0_0_20_DataIndex_Decr_already_pressed = 0;
     byte A_FSG_82_0_0_20_DataIndex_Incr_already_pressed = 0;
     byte A_FSG_82_0_0_20_DataIndex_SetGet_Decr_already_pressed = 0;
     byte A_FSG_82_0_0_20_DataIndex_SetGet_Incr_already_pressed = 0;
     byte A_FSG_82_0_0_20_generateData_Btn_already_pressed = 0;
     byte A_FSG_82_0_0_20_loadArray_Btn_already_pressed = 0;
     _align(1) struct A_FSG_82_0_0_20_ArrayDataStruct {
         byte Param1;
         byte Param2;
         byte Param3[67];
         word Param3_Length;
         byte Param4;
         byte Param5;
         byte Param6;
         byte Param7;
         byte Param8;
         byte Param9;
         byte Param10;
         word Param11;
         byte Param12[25];
         word Param12_Length;
         byte Param13[31];
         word Param13_Length;
         byte Param14;
         byte Param15[18];
         word Param15_Length;
         byte Param16[18];
         word Param16_Length;
         byte Param17[167];
         word Param17_Length;
     };
     struct A_FSG_82_0_0_20_ArrayDataStruct A_FSG_82_0_0_20_ArrayDataList[255];
     const A_FSG_82_0_0_20_ArrayDataList_Length = 255;
     long A_FSG_82_0_0_20_Data_3_LenList[255];
     byte A_FSG_82_0_0_20_Data_3_CntList[255];
     long A_FSG_82_0_0_20_Data_3_SetGet_LenList[255];
     byte A_FSG_82_0_0_20_Data_3_SetGet_CntList[255];
     long A_FSG_82_0_0_20_Data_12_LenList[255];
     byte A_FSG_82_0_0_20_Data_12_CntList[255];
     long A_FSG_82_0_0_20_Data_12_SetGet_LenList[255];
     byte A_FSG_82_0_0_20_Data_12_SetGet_CntList[255];
     long A_FSG_82_0_0_20_Data_13_LenList[255];
     byte A_FSG_82_0_0_20_Data_13_CntList[255];
     long A_FSG_82_0_0_20_Data_13_SetGet_LenList[255];
     byte A_FSG_82_0_0_20_Data_13_SetGet_CntList[255];
     long A_FSG_82_0_0_20_Data_15_LenList[255];
     byte A_FSG_82_0_0_20_Data_15_CntList[255];
     long A_FSG_82_0_0_20_Data_15_SetGet_LenList[255];
     byte A_FSG_82_0_0_20_Data_15_SetGet_CntList[255];
     long A_FSG_82_0_0_20_Data_16_LenList[255];
     byte A_FSG_82_0_0_20_Data_16_CntList[255];
     long A_FSG_82_0_0_20_Data_16_SetGet_LenList[255];
     byte A_FSG_82_0_0_20_Data_16_SetGet_CntList[255];
     long A_FSG_82_0_0_20_Data_17_LenList[255];
     byte A_FSG_82_0_0_20_Data_17_CntList[255];
     long A_FSG_82_0_0_20_Data_17_SetGet_LenList[255];
     byte A_FSG_82_0_0_20_Data_17_SetGet_CntList[255];
     const M_FSG_82_0_0_21_ID = 21;
     byte M_FSG_82_0_0_21Result_BTN_already_pressed = 0;
     char gCheckbox21[100] = "checkbox_M_FSG_82_0_0_21";
     char gErrField21[100] = "errfield_M_FSG_82_0_0_21";
     byte gM_FSG_82_0_0_21_ErrCode = 1;
     char gPanel21[100] = "panel_M_FSG_82_0_0_21";
     const P_FSG_82_0_0_22_ID = 22;
     byte P_FSG_82_0_0_22Status_BTN_already_pressed = 0;
     char gCheckbox22[100] = "checkbox_P_FSG_82_0_0_22";
     char gErrField22[100] = "errfield_P_FSG_82_0_0_22";
     byte gP_FSG_82_0_0_22_ErrCode = 1;
     char gPanel22[100] = "panel_P_FSG_82_0_0_22";
     const P_FSG_82_0_0_23_ID = 23;
     byte P_FSG_82_0_0_23Status_BTN_already_pressed = 0;
     char gCheckbox23[100] = "checkbox_P_FSG_82_0_0_23";
     char gErrField23[100] = "errfield_P_FSG_82_0_0_23";
     byte gP_FSG_82_0_0_23_ErrCode = 1;
     char gPanel23[100] = "panel_P_FSG_82_0_0_23";
     const P_FSG_82_0_0_24_ID = 24;
     byte P_FSG_82_0_0_24Status_BTN_already_pressed = 0;
     char gCheckbox24[100] = "checkbox_P_FSG_82_0_0_24";
     char gErrField24[100] = "errfield_P_FSG_82_0_0_24";
     byte gP_FSG_82_0_0_24_ErrCode = 1;
     char gPanel24[100] = "panel_P_FSG_82_0_0_24";
     const P_FSG_82_0_0_25_ID = 25;
     byte P_FSG_82_0_0_25Status_BTN_already_pressed = 0;
     char gCheckbox25[100] = "checkbox_P_FSG_82_0_0_25";
     char gErrField25[100] = "errfield_P_FSG_82_0_0_25";
     byte gP_FSG_82_0_0_25_ErrCode = 1;
     char gPanel25[100] = "panel_P_FSG_82_0_0_25";
     const P_FSG_82_0_0_26_ID = 26;
     byte P_FSG_82_0_0_26Status_BTN_already_pressed = 0;
     char gCheckbox26[100] = "checkbox_P_FSG_82_0_0_26";
     char gErrField26[100] = "errfield_P_FSG_82_0_0_26";
     byte gP_FSG_82_0_0_26_ErrCode = 1;
     char gPanel26[100] = "panel_P_FSG_82_0_0_26";
     const P_FSG_82_0_0_27_ID = 27;
     byte P_FSG_82_0_0_27Status_BTN_already_pressed = 0;
     char gCheckbox27[100] = "checkbox_P_FSG_82_0_0_27";
     char gErrField27[100] = "errfield_P_FSG_82_0_0_27";
     byte gP_FSG_82_0_0_27_ErrCode = 1;
     char gPanel27[100] = "panel_P_FSG_82_0_0_27";
     const A_FSG_82_0_0_28_ID = 28;
     byte A_FSG_82_0_0_28Changed_BTN_already_pressed = 0;
     byte A_FSG_82_0_0_28Status_BTN_already_pressed = 0;
     char gCheckbox28[100] = "checkbox_A_FSG_82_0_0_28";
     char gErrField28[100] = "errfield_A_FSG_82_0_0_28";
     byte gA_FSG_82_0_0_28_ErrCode = 1;
     char gPanel28[100] = "panel_A_FSG_82_0_0_28";
     byte A_FSG_82_0_0_28_DataIndex_Decr_already_pressed = 0;
     byte A_FSG_82_0_0_28_DataIndex_Incr_already_pressed = 0;
     byte A_FSG_82_0_0_28_DataIndex_SetGet_Decr_already_pressed = 0;
     byte A_FSG_82_0_0_28_DataIndex_SetGet_Incr_already_pressed = 0;
     byte A_FSG_82_0_0_28_generateData_Btn_already_pressed = 0;
     byte A_FSG_82_0_0_28_loadArray_Btn_already_pressed = 0;
     _align(1) struct A_FSG_82_0_0_28_ArrayDataStruct {
         byte Param1;
         byte Param2;
         byte Param3[17];
         word Param3_Length;
         byte Param4;
     };
     struct A_FSG_82_0_0_28_ArrayDataStruct A_FSG_82_0_0_28_ArrayDataList[255];
     const A_FSG_82_0_0_28_ArrayDataList_Length = 255;
     long A_FSG_82_0_0_28_Data_3_LenList[255];
     byte A_FSG_82_0_0_28_Data_3_CntList[255];
     long A_FSG_82_0_0_28_Data_3_SetGet_LenList[255];
     byte A_FSG_82_0_0_28_Data_3_SetGet_CntList[255];
     const M_FSG_82_0_0_29_ID = 29;
     byte M_FSG_82_0_0_29Result_BTN_already_pressed = 0;
     char gCheckbox29[100] = "checkbox_M_FSG_82_0_0_29";
     char gErrField29[100] = "errfield_M_FSG_82_0_0_29";
     byte gM_FSG_82_0_0_29_ErrCode = 1;
     char gPanel29[100] = "panel_M_FSG_82_0_0_29";
     const P_FSG_82_0_0_30_ID = 30;
     byte P_FSG_82_0_0_30Status_BTN_already_pressed = 0;
     char gCheckbox30[100] = "checkbox_P_FSG_82_0_0_30";
     char gErrField30[100] = "errfield_P_FSG_82_0_0_30";
     byte gP_FSG_82_0_0_30_ErrCode = 1;
     char gPanel30[100] = "panel_P_FSG_82_0_0_30";
     const P_FSG_82_0_0_31_ID = 31;
     byte P_FSG_82_0_0_31Status_BTN_already_pressed = 0;
     char gCheckbox31[100] = "checkbox_P_FSG_82_0_0_31";
     char gErrField31[100] = "errfield_P_FSG_82_0_0_31";
     byte gP_FSG_82_0_0_31_ErrCode = 1;
     char gPanel31[100] = "panel_P_FSG_82_0_0_31";


    //// End konfigurationsabhýngige Variablen

    /// Begin: Definition der BUS-Schnittstellen

    // ETHERNET VARIABLES
    struct UdpSocket
    {
        dword Handle;
        dword Id;
        dword Channel;
    };
    struct UdpSocket gUdpSockets[5];
    dword gUdpSocketCnt;
}

on preStart
{
    char Version[200];

    /***** Erzeugen der Ausgabeconsolen *****/
    gBAP_Trace=writecreate("BAP-Trace");        //write-window for BAP-cummunication
    writeclear(gBAP_Trace);                     //clear BAP-window in write-window

    gError_Trace=writecreate("Error");          //error-window for BAP-cummunication
    writeclear(gError_Trace);                   //clear error-window in write-window

    writeclear(1);                              //clear CAPL-window in write-window

    /**** Versionsstring von DLL holen und auf Bildschirm ausgeben ***/
    BAP150_GetVersions(Version, 200);
    writelineEx(gBAP_Trace, 0, "Versionx:%s", Version);

    NODE_INDEX = BAP150_CreateNode();
    writelineEx(gBAP_Trace, 0, "FSG %d Nodeindex:%d", LSGID, Version);

    ReadCommCfgIni();
}

on preStop
{
  WriteCommCfgIni();
}

Split(char bufin[], char delimiter, char bufout1[], char bufout2[])
{
  dword i,j;
  byte found;

  i=j=0;
  found = 0;
  while(bufin[i] != '\0' &&
        bufin[i] != '\r' &&
        bufin[i] != '\n')
  {
    if(found == 0)
    {
      if(bufin[i] != delimiter)
      {
        bufout1[i] = bufin[i];
      }
      else
      {
        found = 1;
        bufout1[i] = '\0';
      }
    }
    else
    {
      bufout2[j] = bufin[i];
      j++;
    }
    i++;
  }
  bufout1[i] = '\0';
  bufout2[j] = '\0';
}

ReadCommCfgIni()
{
#if 1
    putValue(FSG82_0_0_BusType, 4);
    putValue(FSG82_0_0_Channel, 1);
    putValue(FSG82_0_1_BusType, 1);
    putValue(FSG82_0_1_Channel, 1);
    putValue(FSG82_0_2_BusType, 4);
    putValue(FSG82_0_2_Channel, 1);
    putValue(FSG82_0_3_BusType, 4);
    putValue(FSG82_0_3_Channel, 1);
    putValue(FSG82_1_fileSelectorDbCan, ""); // force usage of dbcan_path
    putValue(FSG82_1_fileSelectorDbEth, ""); // force usage of dbeth_path
    putValue(FSG82_1_VlanID, "4");
#else
  dword fHandle;
  char buff1[255];
  char buff2[255];
  char buff3[255];
  dword i;

  setFilePath ("\\fsg82\\panel", 0);
  fHandle = OpenFileRead ("CommCfg.ini",0);

  if(fHandle !=0)
  {
    i=0;
    while (fileGetString(buff1,elcount(buff1),fHandle)!=0 )
    {
      Split(buff1,';',buff2, buff3);

      switch(i)
      {
        case 0 :
          putValue(FSG82_0_0_BusType, atol(buff2));
          putValue(FSG82_0_0_Channel, atol(buff3));
          break;
        case 1 :
          putValue(FSG82_0_1_BusType, atol(buff2));
          putValue(FSG82_0_1_Channel, atol(buff3));
          break;
        case 2 :
          putValue(FSG82_0_2_BusType, atol(buff2));
          putValue(FSG82_0_2_Channel, atol(buff3));
          break;
        case 3 :
          putValue(FSG82_0_3_BusType, atol(buff2));
          putValue(FSG82_0_3_Channel, atol(buff3));
          break;
        case 4 :
          putValue(FSG82_1_fileSelectorDbCan, buff2);
          break;
        case 5 :
          putValue(FSG82_1_fileSelectorDbEth, buff2);
          break;
        case 6 :
          putValue(FSG82_1_VlanID, buff2);
          break;
      }
      i++;
    }
    fileClose (fHandle);
  }
#endif
}

WriteCommCfgIni()
{
#if 0
  dword fHandle;
  char buff[255];

  setWritePath ("\\fsg82\\panel");
  fHandle = OpenFileWrite ("CommCfg.ini",0);

  if(fHandle !=0)
  {
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG82_0_0_BusType), getValue(FSG82_0_0_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG82_0_1_BusType), getValue(FSG82_0_1_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG82_0_2_BusType), getValue(FSG82_0_2_Channel));
    filePutString(buff, elCount(buff), fHandle);
    snprintf (buff,elcount(buff),"%d;%d\n",getValue(FSG82_0_3_BusType), getValue(FSG82_0_3_Channel));
    filePutString(buff, elCount(buff), fHandle);
    getValue(FSG82_1_fileSelectorDbCan, buff);
    snprintf (buff,elcount(buff),"%s\n",buff);
    filePutString(buff, elCount(buff), fHandle);
    getValue(FSG82_1_fileSelectorDbEth, buff);
    snprintf (buff,elcount(buff),"%s\n",buff);
    filePutString(buff, elCount(buff), fHandle);
    getValue(FSG82_1_VlanID, buff);
    filePutString(buff, elCount(buff), fHandle);
    fileClose (fHandle);
  }
#endif
}

DisableFctCtrl ()
{
      EnableControl(panel_name, common_panel_name, 0);
    EnableControl(panel_name,gErrField1,0);
    EnableControl(panel_name,gErrField2,0);
    EnableControl(panel_name,gErrField3,0);
    EnableControl(panel_name,gErrField4,0);
    EnableControl(panel_name,gErrField13,0);
    EnableControl(panel_name,gPanel13,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_13",0);
    EnableControl(panel_name,gErrField15,0);
    EnableControl(panel_name,gPanel15,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_15",0);
    EnableControl(panel_name,gErrField16,0);
    EnableControl(panel_name,gPanel16,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_16",0);
    EnableControl(panel_name,gErrField17,0);
    EnableControl(panel_name,gPanel17,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_17",0);
    EnableControl(panel_name,gErrField18,0);
    EnableControl(panel_name,gPanel18,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_18",0);
    EnableControl(panel_name,gErrField19,0);
    EnableControl(panel_name,gPanel19,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_19",0);
    EnableControl(panel_name,gErrField20,0);
    EnableControl(panel_name,gPanel20,0);
    EnableControl(panel_name,"panel_A_FSG_82_0_0_20",0);
    EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Status",0);
    EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Changed",0);
    EnableControl(panel_name,"panel_A_FSG_82_0_0_20_SetGet",0);
    EnableControl(panel_name,gErrField21,0);
    EnableControl(panel_name,gPanel21,0);
    EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Result",0);
    EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Processing",0);
    EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Start",0);
    EnableControl(panel_name,gErrField22,0);
    EnableControl(panel_name,gPanel22,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_22",0);
    EnableControl(panel_name,gErrField23,0);
    EnableControl(panel_name,gPanel23,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_23",0);
    EnableControl(panel_name,gErrField24,0);
    EnableControl(panel_name,gPanel24,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_24",0);
    EnableControl(panel_name,gErrField25,0);
    EnableControl(panel_name,gPanel25,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_25",0);
    EnableControl(panel_name,gErrField26,0);
    EnableControl(panel_name,gPanel26,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_26",0);
    EnableControl(panel_name,gErrField27,0);
    EnableControl(panel_name,gPanel27,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_27",0);
    EnableControl(panel_name,gErrField28,0);
    EnableControl(panel_name,gPanel28,0);
    EnableControl(panel_name,"panel_A_FSG_82_0_0_28",0);
    EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Status",0);
    EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Changed",0);
    EnableControl(panel_name,"panel_A_FSG_82_0_0_28_SetGet",0);
    EnableControl(panel_name,gErrField29,0);
    EnableControl(panel_name,gPanel29,0);
    EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Result",0);
    EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Processing",0);
    EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Start",0);
    EnableControl(panel_name,gErrField30,0);
    EnableControl(panel_name,gPanel30,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_30",0);
    EnableControl(panel_name,gErrField31,0);
    EnableControl(panel_name,gPanel31,0);
    EnableControl(panel_name,"panel_P_FSG_82_0_0_31",0);

}

EnableFctCtrl ()
{
      EnableControl(panel_name, common_panel_name, 1);
    if(getValue(P_FSG_82_0_0_13_FctLstItemEn)){
         EnableControl(panel_name,gPanel13,1);
         EnableControl(panel_name,gErrField13,1);
    }
    if(getValue(P_FSG_82_0_0_15_FctLstItemEn)){
         EnableControl(panel_name,gPanel15,1);
         EnableControl(panel_name,gErrField15,1);
    }
    if(getValue(P_FSG_82_0_0_16_FctLstItemEn)){
         EnableControl(panel_name,gPanel16,1);
         EnableControl(panel_name,gErrField16,1);
    }
    if(getValue(P_FSG_82_0_0_17_FctLstItemEn)){
         EnableControl(panel_name,gPanel17,1);
         EnableControl(panel_name,gErrField17,1);
    }
    if(getValue(P_FSG_82_0_0_18_FctLstItemEn)){
         EnableControl(panel_name,gPanel18,1);
         EnableControl(panel_name,gErrField18,1);
    }
    if(getValue(P_FSG_82_0_0_19_FctLstItemEn)){
         EnableControl(panel_name,gPanel19,1);
         EnableControl(panel_name,gErrField19,1);
    }
    if(getValue(A_FSG_82_0_0_20_FctLstItemEn)){
         EnableControl(panel_name,gPanel20,1);
    EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Status",1);
         EnableControl(panel_name,gErrField20,1);
    }
    if(getValue(M_FSG_82_0_0_21_FctLstItemEn)){
         EnableControl(panel_name,gPanel21,1);
         EnableControl(panel_name,gErrField21,1);
    }
    if(getValue(P_FSG_82_0_0_22_FctLstItemEn)){
         EnableControl(panel_name,gPanel22,1);
         EnableControl(panel_name,gErrField22,1);
    }
    if(getValue(P_FSG_82_0_0_23_FctLstItemEn)){
         EnableControl(panel_name,gPanel23,1);
         EnableControl(panel_name,gErrField23,1);
    }
    if(getValue(P_FSG_82_0_0_24_FctLstItemEn)){
         EnableControl(panel_name,gPanel24,1);
         EnableControl(panel_name,gErrField24,1);
    }
    if(getValue(P_FSG_82_0_0_25_FctLstItemEn)){
         EnableControl(panel_name,gPanel25,1);
         EnableControl(panel_name,gErrField25,1);
    }
    if(getValue(P_FSG_82_0_0_26_FctLstItemEn)){
         EnableControl(panel_name,gPanel26,1);
         EnableControl(panel_name,gErrField26,1);
    }
    if(getValue(P_FSG_82_0_0_27_FctLstItemEn)){
         EnableControl(panel_name,gPanel27,1);
         EnableControl(panel_name,gErrField27,1);
    }
    if(getValue(A_FSG_82_0_0_28_FctLstItemEn)){
         EnableControl(panel_name,gPanel28,1);
    EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Status",1);
         EnableControl(panel_name,gErrField28,1);
    }
    if(getValue(M_FSG_82_0_0_29_FctLstItemEn)){
         EnableControl(panel_name,gPanel29,1);
         EnableControl(panel_name,gErrField29,1);
    }
    if(getValue(P_FSG_82_0_0_30_FctLstItemEn)){
         EnableControl(panel_name,gPanel30,1);
         EnableControl(panel_name,gErrField30,1);
    }
    if(getValue(P_FSG_82_0_0_31_FctLstItemEn)){
         EnableControl(panel_name,gPanel31,1);
         EnableControl(panel_name,gErrField31,1);
    }

}

DisableConfigCtrl ()
{
      EnableControl(panel_name, bapconfig_panel_name, 0);
    EnableControl(panel_name, bapconfig_panel_name, 0);
    EnableControl(panel_name, "panel1_edit", 0);
//    EnableControl(panel_name,gCheckbox1,0);
//    if(!getValue(C_FSG_82_0_0_1_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox1,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox2,0);
//    if(!getValue(P_FSG_82_0_0_2_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox2,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox3,0);
//    if(!getValue(P_FSG_82_0_0_3_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox3,MakeRGB(200,200,200));
//    }
    EnableControl(panel_name, "panel_P_FSG_82_0_0_4", 0);
//    EnableControl(panel_name,gCheckbox4,0);
//    if(!getValue(P_FSG_82_0_0_4_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox4,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox13,0);
//    if(!getValue(P_FSG_82_0_0_13_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox13,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox15,0);
//    if(!getValue(P_FSG_82_0_0_15_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox15,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox16,0);
//    if(!getValue(P_FSG_82_0_0_16_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox16,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox17,0);
//    if(!getValue(P_FSG_82_0_0_17_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox17,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox18,0);
//    if(!getValue(P_FSG_82_0_0_18_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox18,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox19,0);
//    if(!getValue(P_FSG_82_0_0_19_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox19,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox20,0);
//    if(!getValue(A_FSG_82_0_0_20_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox20,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox21,0);
//    if(!getValue(M_FSG_82_0_0_21_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox21,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox22,0);
//    if(!getValue(P_FSG_82_0_0_22_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox22,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox23,0);
//    if(!getValue(P_FSG_82_0_0_23_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox23,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox24,0);
//    if(!getValue(P_FSG_82_0_0_24_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox24,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox25,0);
//    if(!getValue(P_FSG_82_0_0_25_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox25,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox26,0);
//    if(!getValue(P_FSG_82_0_0_26_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox26,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox27,0);
//    if(!getValue(P_FSG_82_0_0_27_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox27,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox28,0);
//    if(!getValue(A_FSG_82_0_0_28_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox28,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox29,0);
//    if(!getValue(M_FSG_82_0_0_29_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox29,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox30,0);
//    if(!getValue(P_FSG_82_0_0_30_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox30,MakeRGB(200,200,200));
//    }
//    EnableControl(panel_name,gCheckbox31,0);
//    if(!getValue(P_FSG_82_0_0_31_FctLstItemEn)){
//         SetControlBackColor(panel_name,gCheckbox31,MakeRGB(200,200,200));
//    }

}

EnableConfigCtrl ()
{
      EnableControl(panel_name, bapconfig_panel_name, 1);
    EnableControl(panel_name, "panel1_edit", 1);
    if(getValue(C_FSG_82_0_0_1_FctLstItemEn))
    {
        setControlForeColor(panel_name, gCheckbox1, MakeRGB(0,240,0));
    }
    else
    {
        setControlForeColor(panel_name, gCheckbox1, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_2_FctLstItemEn))
    {
        setControlForeColor(panel_name, gCheckbox2, MakeRGB(0,240,0));
    }
    else
    {
        setControlForeColor(panel_name, gCheckbox2, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_3_FctLstItemEn))
    {
        setControlForeColor(panel_name, gCheckbox3, MakeRGB(0,240,0));
    }
    else
    {
        setControlForeColor(panel_name, gCheckbox3, MakeRGB(250,0,0));
    }
    EnableControl(panel_name, "panel_P_FSG_82_0_0_4", 1);
    if(getValue(P_FSG_82_0_0_4_FctLstItemEn))
    {
        setControlForeColor(panel_name, gCheckbox4, MakeRGB(0,240,0));
    }
    else
    {
        setControlForeColor(panel_name, gCheckbox4, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_13_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_13",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_13",1);
        setControlForeColor(panel_name, gCheckbox13, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_13",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_13",0);
        setControlForeColor(panel_name, gCheckbox13, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_15_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_15",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_15",1);
        setControlForeColor(panel_name, gCheckbox15, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_15",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_15",0);
        setControlForeColor(panel_name, gCheckbox15, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_16_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_16",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_16",1);
        setControlForeColor(panel_name, gCheckbox16, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_16",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_16",0);
        setControlForeColor(panel_name, gCheckbox16, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_17_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_17",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_17",1);
        setControlForeColor(panel_name, gCheckbox17, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_17",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_17",0);
        setControlForeColor(panel_name, gCheckbox17, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_18_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_18",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_18",1);
        setControlForeColor(panel_name, gCheckbox18, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_18",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_18",0);
        setControlForeColor(panel_name, gCheckbox18, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_19_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_19",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_19",1);
        setControlForeColor(panel_name, gCheckbox19, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_19",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_19",0);
        setControlForeColor(panel_name, gCheckbox19, MakeRGB(250,0,0));
    }
    if(getValue(A_FSG_82_0_0_20_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_A_FSG_82_0_0_20",1);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Status",1);
        EnableControl(panel_name,"errfield_A_FSG_82_0_0_20",1);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Changed",1);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_20_SetGet",1);
        setControlForeColor(panel_name, gCheckbox20, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_A_FSG_82_0_0_20",0);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Status",0);
        EnableControl(panel_name,"errfield_A_FSG_82_0_0_20",0);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Changed",0);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_20_SetGet",0);
        setControlForeColor(panel_name, gCheckbox20, MakeRGB(250,0,0));
    }
    if(getValue(M_FSG_82_0_0_21_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_M_FSG_82_0_0_21",1);
        EnableControl(panel_name,"errfield_M_FSG_82_0_0_21",1);
        EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Processing",1);
        EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Start",1);
        setControlForeColor(panel_name, gCheckbox21, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_M_FSG_82_0_0_21",0);
        EnableControl(panel_name,"errfield_M_FSG_82_0_0_21",0);
        EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Processing",0);
        EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Start",0);
        setControlForeColor(panel_name, gCheckbox21, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_22_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_22",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_22",1);
        setControlForeColor(panel_name, gCheckbox22, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_22",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_22",0);
        setControlForeColor(panel_name, gCheckbox22, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_23_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_23",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_23",1);
        setControlForeColor(panel_name, gCheckbox23, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_23",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_23",0);
        setControlForeColor(panel_name, gCheckbox23, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_24_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_24",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_24",1);
        setControlForeColor(panel_name, gCheckbox24, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_24",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_24",0);
        setControlForeColor(panel_name, gCheckbox24, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_25_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_25",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_25",1);
        setControlForeColor(panel_name, gCheckbox25, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_25",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_25",0);
        setControlForeColor(panel_name, gCheckbox25, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_26_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_26",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_26",1);
        setControlForeColor(panel_name, gCheckbox26, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_26",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_26",0);
        setControlForeColor(panel_name, gCheckbox26, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_27_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_27",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_27",1);
        setControlForeColor(panel_name, gCheckbox27, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_27",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_27",0);
        setControlForeColor(panel_name, gCheckbox27, MakeRGB(250,0,0));
    }
    if(getValue(A_FSG_82_0_0_28_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_A_FSG_82_0_0_28",1);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Status",1);
        EnableControl(panel_name,"errfield_A_FSG_82_0_0_28",1);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Changed",1);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_28_SetGet",1);
        setControlForeColor(panel_name, gCheckbox28, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_A_FSG_82_0_0_28",0);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Status",0);
        EnableControl(panel_name,"errfield_A_FSG_82_0_0_28",0);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Changed",0);
        EnableControl(panel_name,"panel_A_FSG_82_0_0_28_SetGet",0);
        setControlForeColor(panel_name, gCheckbox28, MakeRGB(250,0,0));
    }
    if(getValue(M_FSG_82_0_0_29_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_M_FSG_82_0_0_29",1);
        EnableControl(panel_name,"errfield_M_FSG_82_0_0_29",1);
        EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Processing",1);
        EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Start",1);
        setControlForeColor(panel_name, gCheckbox29, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_M_FSG_82_0_0_29",0);
        EnableControl(panel_name,"errfield_M_FSG_82_0_0_29",0);
        EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Processing",0);
        EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Start",0);
        setControlForeColor(panel_name, gCheckbox29, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_30_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_30",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_30",1);
        setControlForeColor(panel_name, gCheckbox30, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_30",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_30",0);
        setControlForeColor(panel_name, gCheckbox30, MakeRGB(250,0,0));
    }
    if(getValue(P_FSG_82_0_0_31_FctLstItemEn))
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_31",1);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_31",1);
        setControlForeColor(panel_name, gCheckbox31, MakeRGB(0,240,0));
    }
    else
    {
        EnableControl(panel_name, "panel_P_FSG_82_0_0_31",0);
        EnableControl(panel_name,"errfield_P_FSG_82_0_0_31",0);
        setControlForeColor(panel_name, gCheckbox31, MakeRGB(250,0,0));
    }

}

resetErrfieldColor()
{
      setControlBackColor(panel_name, "errfield_C_FSG_82_0_0_1", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_2", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_3", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_4", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_13", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_15", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_16", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_17", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_18", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_19", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_A_FSG_82_0_0_20", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_M_FSG_82_0_0_21", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_22", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_23", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_24", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_25", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_26", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_27", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_A_FSG_82_0_0_28", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_M_FSG_82_0_0_29", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_30", MakeRGB(255,255,255));
    setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_31", MakeRGB(255,255,255));

}

CANoe_Shutdown ()
{
    // Timer: cancel real CAN-communication timer
    canceltimer(TaskTimer);
    // Ruecksetzen der Hintergrundfarbe der Error-Felder
    resetErrfieldColor();
    // Deaktivierung aller Panel Elemente
    EnableConfigCtrl();
}

on timer TaskTimer
{
    /*** Aufruf des BAP Task in DLL fuer NODE_INDEX ***/
    BAP150_Task(NODE_INDEX);

    /*** Pollen ueber die anstehenden Indications (Lesen aus DLL, Auslesen eines Puffers der DLL) ***/
    BAP_DLL_Indication();

    /*** Pollen ueber die anstehenden Requests (Schreiben in DLL, dort werden evt. Sendeauftraege gesetzt) ***/
    BAP_DLL_Request();

    /*** Abarbeiten der ausstehenden Sendeauftraege innerhalb der BAP DLL und Versenden ueber CANoe ***/
    if (getValue(eSendEnabled))
    {
        BAP_CAN_TX_Request();
    }

    BAP_DLL_SetRxData();

    /*** Retriggern des Timers mit 10 ms ***/
    setTimer(TaskTimer, TaskTime); // @TODO bei anderer Taskzeit muss hier modifiziert werden
}


BAP_DLL_SetRxData()
{
    int i;
    byte gRxBuffer[1500];

    for( i = 0; i < gUdpSocketCnt; i++ )
        UdpReceiveFrom( gUdpSockets[i].Handle, gRxBuffer, 0);
}


BAP_DLL_Indication()    //function to get received BAP-data from DLL (at BAL-interface)
{
    int length, datalength, temp;
  dword i;
    dword Indication_header[6];                    // indication header from DLL
    byte BAP_data_type;

    // init local variables
    length=0;
    datalength=0;
    temp=0;
    BAP_data_type=0;

    for(i = 0; i < 6; i++)
        Indication_header[i]=0;

  // BAP-Stack needs this information for successful BAP150_GetIndication
    Indication_header[4]=BAP_buffer_size;

    while (BAP150_GetInd(NODE_INDEX, Indication_header, gBAP_Indication_data) == 0)
    {
        //read header and write in global variable
        for (i = 0; i < 6; i++) {
            gBAP_Indication_header[i]=Indication_header[i];
        }
        // Verarbeiten der Indication
        Process_Current_Indication();

        // Vorbereiten fuer naechsten Durchlauf
        Indication_header[4]=BAP_buffer_size;
    }
}

setBitInFctList(word fctid, byte fctList[])
{
    byte byteNo ;
    byte bitno ;
    byte fctValue ;

    byteNo = fctid / 8;
    bitno = fctid % 8;
    fctValue = 0x80 >> bitno;
    fctList[byteNo] |= fctValue;
}

float round (float value, float step)
{
    return _floor(value / step + 0.5) * step;
}

ChangeConfig(long paramIndex,long config[])
{

        byte temp ;
        temp = BAP150_ChangeConfig(NODE_INDEX, paramIndex, config);
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP150_ChangeConfig for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP150_ChangeConfig error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);
}

PrintIndicationError(char reason[])
{
    writelineEx(gError_Trace, 0, "%s - %s lsgId:%d fctid:%d indType:%d dataType:%s",
        reason, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]]);
}

initBapConfig()
{
        long config[3];
    config[0] = LSGID;
    config[1] = 0;
    config[2] = getValue(BAPCFG_FSG_82_0_0_ProtocolMajor);
    ChangeConfig(0x0012,config);
    config[2] = getValue(BAPCFG_FSG_82_0_0_ProtocolMinor);
    ChangeConfig(0x0013,config);
    config[2] = getValue(BAPCFG_FSG_82_0_0_LsgClassMajor);
    ChangeConfig(0x0010,config);
    config[2] = getValue(BAPCFG_FSG_82_0_0_LsgClassMinor);
    ChangeConfig(0x0011,config);
    config[2] = getValue(BAPCFG_FSG_82_0_0_DFMajor);
    ChangeConfig(0x0014,config);
    config[2] = getValue(BAPCFG_FSG_82_0_0_DFMinor);
    ChangeConfig(0x0015,config);

}

initFctList()
{
    byte fctList[8]={0,0,0,0,0,0,0,0};
    int i;
    dword request[6];
    byte errorCode;

    fctList[0]=0;
    fctList[1]=0;
    fctList[2]=0;
    fctList[3]=0;
    fctList[4]=0;
    fctList[5]=0;
    fctList[6]=0;
    fctList[7]=0;

    /*if(getValue(P_FSG_44_0_13_FunctionListId))
    {
        setBitInFctList(P_FSG_44_0_13_ID, fctList);
    }*/
           if(getValue(P_FSG_82_0_0_31_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_31_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_30_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_30_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_19_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_19_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_18_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_18_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_17_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_17_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_16_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_16_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_15_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_15_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_13_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_13_ID, fctList);
       }
       if(getValue(M_FSG_82_0_0_29_FctLstItemEn))
       {
           setBitInFctList(M_FSG_82_0_0_29_ID, fctList);
       }
       if(getValue(A_FSG_82_0_0_28_FctLstItemEn))
       {
           setBitInFctList(A_FSG_82_0_0_28_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_27_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_27_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_26_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_26_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_4_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_4_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_25_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_25_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_3_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_3_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_24_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_24_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_2_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_2_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_23_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_23_ID, fctList);
       }
       if(getValue(C_FSG_82_0_0_1_FctLstItemEn))
       {
           setBitInFctList(C_FSG_82_0_0_1_ID, fctList);
       }
       if(getValue(P_FSG_82_0_0_22_FctLstItemEn))
       {
           setBitInFctList(P_FSG_82_0_0_22_ID, fctList);
       }
       if(getValue(M_FSG_82_0_0_21_FctLstItemEn))
       {
           setBitInFctList(M_FSG_82_0_0_21_ID, fctList);
       }
       if(getValue(A_FSG_82_0_0_20_FctLstItemEn))
       {
           setBitInFctList(A_FSG_82_0_0_20_ID, fctList);
       }


    for(i=0;i<8;i++){
        writelineEx(gBAP_Trace, 0, "fctList[%d]: 0x%02x ",i,fctList[i]);
    }

    request [0]=LSGID;
    request [1]=3;
    request [3]= Bap_byteSequence;
    request [4]= 8;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,fctList);
    if(errorCode)
        writelineEx(gError_Trace, 0, "BAP150_InitSendBuf(Functionlist) returns 0x%02x ",errorCode);
}

initHeartbeat()
{
       long data[2];
   data[0]=LSGID;
   if( getValue(P_FSG_82_0_0_4_FctLstItemEn) )
      data[1]=getValue(P_FSG_82_0_0_4);
   else
      data[1]=0;
   ChangeConfig(0x00,data);
   InitSendBuf_int8(P_FSG_82_0_0_4_ID, data[1]);

}

void GetGenCommNumber(struct CommConfigStruct CommConfig, dword Number, dword Channel)
{
  switch(Number)
  {
    case 0: // XML
      CommConfig.Number = 0;
      break;
    case 1: // CAN
    case 2: // CAN-FD
      CommConfig.Number = 1 + (Channel-1);
      isSelectedCAN = 1;
      break;
    case 3: // Flexray
      CommConfig.Number = 10 + (Channel-1);
      isSelectedFr = 1;
      break;
    case 4: // Ethernet
      CommConfig.Number = 20 + (Channel-1);
      isSelectedEth = 1;
      break;
  }
}

void GetCommConfig(byte data[])
{
  dword Index;
  struct CommConfigStruct CommConfig;

  Index = 0;
  strncpy(CommConfig.Name,"BAP_IAA_PSO_FSG_01", 100);
  CommConfig.Channel = getValue(FSG82_0_0_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG82_0_0_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_IAA_PSO_ASG_03", 100);
  CommConfig.Channel = getValue(FSG82_0_1_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG82_0_1_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_IAA_PSO_ASG_02", 100);
  CommConfig.Channel = getValue(FSG82_0_2_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG82_0_2_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

  Index += __size_of(struct CommConfigStruct);
  strncpy(CommConfig.Name,"BAP_IAA_PSO_ASG_01", 100);
  CommConfig.Channel = getValue(FSG82_0_3_Channel);
  GetGenCommNumber(CommConfig, getValue(FSG82_0_3_BusType), CommConfig.Channel);
  memcpy(data, Index, CommConfig);

}


/*@@caplFunc:Name:*/
BapOnOff(byte _on)
{
  int i, length, temp;
  char Path[255];
  const dword CommConfigSize = 4 * __size_of(struct CommConfigStruct);
  byte CommConfigs[CommConfigSize];

  dword DB_ALL_CAN_INTERFACES = 0x80000000;
  dword DB_ALL_ETH_INTERFACES = 0x40000000;
  dword DB_ALL_FR_INTERFACES  = 0x20000000;

  isSelectedCAN = 0;
  isSelectedEth = 0;
  isSelectedFr = 0;

  /***** Einschalten ******/
  if(_on==1){
    if(BAP180_RemoveDBs(NODE_INDEX) != 0){
      writelineEx(gError_Trace, 0, "Fehler beim Entfernen der Datanbasen!");
    }

    GetCommConfig(CommConfigs);

    if(isSelectedCAN){
      getValue(FSG82_1_fileSelectorDbCan, Path);
      if(Path[0] != '\0'){
        getValue(FSG82_1_fileSelectorDbCan, dbcan_path);
      }else{
        putValue(FSG82_1_fileSelectorDbCan, dbcan_path);
      }
      getAbsFilePath(dbcan_path, Path, 255);
      if(BAP180_LoadDB(NODE_INDEX, DB_ALL_CAN_INTERFACES, 0, Path) != 0){
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
      }
    }
    if(isSelectedEth){
      getValue(FSG82_1_fileSelectorDbEth, Path);
      if(Path[0] != '\0'){
        getValue(FSG82_1_fileSelectorDbEth, dbeth_path);
      }else{
        putValue(FSG82_1_fileSelectorDbEth, dbeth_path);
      }
      getAbsFilePath(dbeth_path, Path, 255);
      if(BAP180_LoadDB(NODE_INDEX, DB_ALL_ETH_INTERFACES, 2, Path) != 0){
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
      }
    }


    /**** Laden des BAP XML Files ****/
    getAbsFilePath(xml_path, Path, 255);
    writelineEx(gBAP_Trace, 0, "Load BAP-XML-File: %s", Path);

    if (BAP1101_LoadConfig(NODE_INDEX, Path, "", CommConfigs, CommConfigSize) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
    }


    // soll der BAP Stack wieder initlialisiert werden?
    if(gBAP_Init==0){
        //gBAP_Init=1;
        temp=BAP150_Init(NODE_INDEX, LSGID);
        if(temp==0)
            writelineEx(gBAP_Trace, 0, "BAP_Init for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP_Init error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);
    }

    // Initialisierung aller Variablen
    Initialize_Variables();

    // Aktivierung aller Panelelemente
    EnableFctCtrl();
    //EnableControl(panel_name, bapconfig_panel_name, 0); // @TODO
    DisableConfigCtrl();

    if(isSelectedEth){
      EthernetCreateSocket();
    }


    //BAP-Shutdown
    temp = BAP150_Shutdown(NODE_INDEX, LSGID);
    if(temp==0)
        writelineEx(gBAP_Trace, 0, "BAP_Shutdown for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
    else
        writelineEx(gError_Trace, 0, "BAP_Shutdown error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);

    initBapConfig();
    initFctList();
    initHeartbeat();

    temp = BAP150_Start(NODE_INDEX, LSGID);
    if(temp == 0)
        writelineEx(gBAP_Trace, 0, "BAP_Start for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
    else
        writelineEx(gError_Trace, 0, "BAP_Start error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);

    // setze den Timer fuer den zyklischen Aufruf des CANoe-"Tasks"
    setTimer(TaskTimer, 10);
    //  BAPFsg_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID, DEBUG_SWITCH_ON);
  }
  else{ /***** Ausschalten ****/

    BAP150_Shutdown(NODE_INDEX,LSGID);
    CANoe_Shutdown();

    if (isSelectedEth) { // Uses Ethernet
      CloseUdpSocket();
    }

  }

}
/*@@end*/

/*@@caplFunc:Name:*/
Initialize_Variables()    //initialize/reset all global variables
{
    int temp;
  dword i;
    byte  InitSend_data[BAP_buffer_size];    // InitSend data for DLL
    dword InitSend_header[6];    // InitSend header for DLL

    /**** Request Buffer Geschichten initialisieren ****/
    for (i = 0; i < Requestbuffer_lines; i++)
    {
        gBAP_Requestbuffer_status[i] = 0;
    }
    for (i = 0; i < BAP_buffer_size; i++)
    {
        InitSend_data[i] = 0;
    }

    // @TODO nur FSG relevant
    /**** Es ist notwendig mittels InitSendbuffer alle Properties im FSG zu initialisieren ****/
           InitSend_header[0] = LSGID;
       InitSend_header[1] = 13;
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_82_0_0_13);
     putValue(P_FSG_82_0_0_13, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 15;
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_15,InitSend_data);
       putValue(P_FSG_82_0_0_15,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_15)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 16;
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 9;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_16,InitSend_data);
       putValue(P_FSG_82_0_0_16,InitSend_data, 9);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_16)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 17;
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 7;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_17,InitSend_data);
       putValue(P_FSG_82_0_0_17,InitSend_data, 7);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_17)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 18;
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_18,InitSend_data);
       putValue(P_FSG_82_0_0_18,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_18)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 19;
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 10;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_19,InitSend_data);
       putValue(P_FSG_82_0_0_19,InitSend_data, 10);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_19)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 22;
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_22,InitSend_data);
       putValue(P_FSG_82_0_0_22,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_22)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 23;
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_23,InitSend_data);
       putValue(P_FSG_82_0_0_23,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_23)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 24;
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_24,InitSend_data);
       putValue(P_FSG_82_0_0_24,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_24)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 25;
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_25,InitSend_data);
       putValue(P_FSG_82_0_0_25,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_25)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 26;
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 13;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_26,InitSend_data);
       putValue(P_FSG_82_0_0_26,InitSend_data, 13);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_26)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 27;
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 2;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_27,InitSend_data);
       putValue(P_FSG_82_0_0_27,InitSend_data, 2);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_27)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 30;
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 6;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_30,InitSend_data);
       putValue(P_FSG_82_0_0_30,InitSend_data, 6);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_30)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;
       InitSend_header[1] = 31;
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 7;
       InitSend_header[5] = 0;
       getValue(P_FSG_82_0_0_31,InitSend_data);
       putValue(P_FSG_82_0_0_31,InitSend_data, 7);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_82_0_0_31)); i++)
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);

}
/*@@end*/

/*@@startStart:Start:*/
on start
{
    // noch nicht eingeschaltet
    gSG_PowerOnOff=0;
    // noch nicht initialisiert
    gBAP_Init=0;
    // open the panel, nur fuer CANoe-Version >= 5.1 erlaubt
    //openPanel(panel_name);
    // deaktiviere alle aktiven Panel Elemente, ausser AN/AUSS
  CANoe_Shutdown();

}
/*@@end*/


/*@@caplFunc:Name:*/
BAP_CAN_TX_Request()    //Function to send BAP-data over CAN
{
   int i;
   byte DestIp[16];
   byte TX_Data[1500];            // Data
   dword TX_Header[13];            // Header
   message 0x100 TX_Message;    // dummy-message, Adresse wird noch modifiziert

   byte send_result;

    TX_Header[2] = 1500; // max-Length of TX_Data

        // Pollen ueber die Queue, die von der DLL zur Verfuegung gestellt wird
        // Diese Daten muessen ueber den CAN Bus gesendet werden
    while (BAP180_GetTxData(NODE_INDEX,TX_Header,TX_Data) == 0) {
      if(TX_Header[0] == 1)
      {
        TX_Message.CAN = TX_Header[1];         //CAN channel
        TX_Message.ID = TX_Header[3];       //Can ID
        TX_Message.DataLength = TX_Header[2];         // received length

        for (i=0; i<TX_Message.DataLength; i++) {    //CAN data-bytes
          TX_Message.byte(i) = TX_Data[i];
        }

        TX_Message.EDL = 0;
        TX_Message.BRS = 0;
        if(TX_Header[4] & 2)
          TX_Message.EDL = 1;
        if(TX_Header[4] & 4)
          TX_Message.BRS = 1;

        output(TX_Message);                    //send CAN message

        //Versions Output
        if(TX_Data[0] == 0x40 && TX_Data[1] == 0x00 && TX_Header[2] == 4)
        {
          writelineEx(gBAP_Trace, 0,"Major Version: %i, Minor Version: %i", TX_Data[2], TX_Data[3]);
        }
      }
      else if(TX_Header[0] == 4)
      {
        for(i=0; i<8;i++)
        {
           DestIp[2*i]   = (byte)(TX_Header[i+4]>>8);
           DestIp[2*i+1] = (byte)(TX_Header[i+4]&0xFF);
        }

        for (i=0; i<TX_Header[2]; i++) {
         TX_Data.byte(i) = TX_Data[i];
        }

        send_result = UdpSendTo(gUdpSockets[TX_Header[3]-1].Handle, DestIp, TX_Header[12], TX_Data, TX_Header[2]);
        if (0 == send_result){

        }else{
          writeLineEx(0,3, "UdpSendTo failed, error code %d, last error %d", send_result, IpGetLastError());
        }
      }

      TX_Header[2] = 1500;
    }
}
/*@@end*/

/*@@caplFunc:Name:*/
EthernetCreateSocket()
{
  int index;
  dword i, j, Header[200], val, VlanId, VlanPrio, ifIndex, Channel;
  byte ipv6_adapter_adresses[5][16];
  byte ipv6_temp[16];
  byte ipv6_zero[16] = {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0};

  char ifDescr[255]={0};
  char ReplaceStr[255]={0};
  char SearchStr[25];

  const dword HeaderFormat = 2; // Ab BAP180Dll > V7600

  gUdpSocketCnt = 0;
  Header[0] = HeaderFormat;
  if(BAP180_GetEthConfig(NODE_INDEX, Header) == 0)
  {
    for(i=1;i<=3;i++)
    {
      if(IpGetAdapterAddress(i, ipv6_adapter_adresses, 5) == 0)
      {
        val = IpGetAdapterAddressCount(i, 28);
        for(j=0;j<val;j++)
        {
          IpRemoveAdapterAddress(i, ipv6_adapter_adresses[j], 64);
        }
      }
      else
      {
        break;
      }
    }

    index=0;
    gUdpSocketCnt = Header[index++];
    for(i=0; i<gUdpSocketCnt;i++)
    {
      VlanId = Header[index++];
      VlanPrio = Header[index++];
      writelineex(0, 1, "VLAN-Config: ID: %d, Prio: %d", VlanId, VlanPrio);

      ltoa(VlanId, SearchStr,10);

      putValue(FSG82_1_VlanID, SearchStr);

      ifIndex = 0;
      Channel = Header[index++];
      snprintf(SearchStr, elcount(SearchStr), "VLAN%d.%d", Channel, VlanId);
      for(j=1;j<=IpGetAdapterCount();j++)
      {
        IpGetAdapterDescription(j, ifDescr, 255);
        memcpy(ReplaceStr, ifDescr, 255);
        str_replace(ReplaceStr, SearchStr, "");
        if(strncmp(ifDescr, ReplaceStr,strlen(ifDescr))!=0)
        {
          ifIndex = j;
          break;
        }
      }

      if(ifIndex == 0)
      {
        writelineex(0, 3, "The CANoe TCP/IP-Stack Configuration is not valid!");
      }

      gUdpSockets[i].Id = Header[index++];
      gUdpSockets[i].Channel = Channel;
      for(j=0;j<8;j++)
      {
        ipv6_temp[j*2]   = Header[index]>>8;
        ipv6_temp[j*2+1] = Header[index++]&0xFF;
      }

      IpAddAdapterAddress(ifIndex, ipv6_temp, 64);

      if(ipv6_temp[0] == 0xFF)
        gUdpSockets[i].Handle = UdpOpen( ipv6_zero, Header[index++]);
      else
        gUdpSockets[i].Handle = UdpOpen( ipv6_temp, Header[index++]);

      if (gUdpSockets[i].Handle == ~0){
        writelineex(0, 3, "Error: could not create Udp socket! %d", IpGetLastError());
      }else{

        writelineex(0, 1, "Udp socket is opened successfully.");

        if(ipv6_temp[0] == 0xFF)
        {
          if(IpJoinMulticastGroup(gUdpSockets[i].Handle, ifIndex, ipv6_temp) != 0)
           writelineex(0, 3, "IpJoinMulticastGroup failed.");
        }

        if(IpSetMulticastInterface ( gUdpSockets[i].Handle, ifIndex) != 0)
          writelineex(0, 3, "IpSetMulticastInterface failed");
      }
    }
  }
  else{
    writelineex(0, 3, "Error: BAP180_GetEthConfig failed!");
  }
}

/*@@end*/

/*@@caplFunc:Name:*/
ringbuffer_write (byte lsgID, byte fctID, byte request, byte dataType, dword singleData)
{
  byte data[1];
  ringbuffer_write(lsgID, fctID, request, dataType, 0, singleData, data);
}
/*@@end*/

/*@@caplFunc:Name:*/
ringbuffer_write (byte lsgID, byte fctID, byte request, byte dataType, dword length, dword singleData, byte data[])
{
    int bufferline;
  dword i;

    bufferline = getNextWriteIndex();    //get next free position in ring-buffer

    if (bufferline == -1)
    {
        writelineEx(gError_Trace, 0, "Crititcal Error: No free buffer found!");
        return;
    }

    gBAP_Request_header[bufferline][0] = lsgID;    // LSG
    gBAP_Request_header[bufferline][1] = fctID;    // FCT
    gBAP_Request_header[bufferline][3] = dataType; // dataType
    //writelineEx(gBAP_Trace, 0, "Write request in buffer FSG NODEINDEX:%d lsgid:%d fctid:%d requesttype:%d datatype:%d length:%d",
    //        NODE_INDEX,lsgID,fctID,request,dataType,length);


    switch (dataType)
    {
        case Bap_void:
            gBAP_Request_header[bufferline][2] = request;    // request
            gBAP_Request_header[bufferline][4] = 0;    // length
                // Void
            // @TODO?
            break;
        case Bap_uint8:
            gBAP_Request_header[bufferline][2] = request;        // request
            gBAP_Request_header[bufferline][5] = singleData;    // Daten
            break;
        case Bap_uint16:
            gBAP_Request_header[bufferline][2] = request;        // request
            gBAP_Request_header[bufferline][5] = singleData;    // Daten
            break;
        case Bap_uint32:
            gBAP_Request_header[bufferline][2] = request;        // request
            gBAP_Request_header[bufferline][5] = singleData;    // Daten
            break;
        case Bap_byteSequence:
            gBAP_Request_header[bufferline][2] = request;    // request
            gBAP_Request_header[bufferline][4] = length;    // length
            // Daten der ByteSequence kopieren
      for(i = 0; i < length; i++)
                gBAP_Request_data[bufferline][i] = data[i];
        case Bap_error:
            gBAP_Request_header[bufferline][5] = singleData;    // Errorcode
            break;
        default:
            break;
    }
}
/*@@end*/

/*@@caplFunc:Name:*/
Request_void (byte lsgID, byte fctID, byte request)
{
  ringbuffer_write (lsgID, fctID, request, Bap_void, 0);
}
/*@@end*/

/*@@caplFunc:Name:*/
Request_int8 (byte lsgID, byte fctID, byte request, dword data)
{
  ringbuffer_write (lsgID, fctID, request, Bap_uint8, data);
}
/*@@end*/

/*@@caplFunc:Name:*/
Request_int16 (byte lsgID, byte fctID, byte request, dword data)
{
  ringbuffer_write (lsgID, fctID, request, Bap_uint16, data);
}
/*@@end*/

/*@@caplFunc:Name:*/
Request_int32 (byte lsgID, byte fctID, byte request, dword data)
{
  ringbuffer_write (lsgID, fctID, request, Bap_uint32, data);
}
/*@@end*/

/*@@caplFunc:Name:*/
Request_byteSequence (byte lsgID, byte fctID, byte request, byte data[], dword length)
{
  ringbuffer_write (lsgID, fctID, request, Bap_byteSequence, length, 0, data);
}

Request_error( byte lsgID, byte fctID, byte errorCode )
{
  ringbuffer_write (lsgID, fctID, Error_REQ, Bap_error, errorCode);
}

InitSendBuf_int8( byte fctID, dword data )
{
    dword request[6];
    int errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint8;
    request [5]= data;

    errorCode=
    BAP150_InitSendBuf( NODE_INDEX,request, InitSend_data );

    if( errorCode )
        writelineEx( gError_Trace, 0, "InitSendBuf_int8 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_int16 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint16;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);

    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int16 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_int32 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);

    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int32 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_byteSequence (byte fctID, byte data[], word length)
{
    dword request[6];
    byte errorCode;

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [4]= length;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,data);

    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_byteSequence error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

DisplayRequestErrorCode(dword fctID, dword errCode)
{
       switch(fctID)
   {
       case C_FSG_82_0_0_1_ID:
           gC_FSG_82_0_0_1_ErrCode = 0;
           putValue(C_FSG_82_0_0_1_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_C_FSG_82_0_0_1", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_2_ID:
           gP_FSG_82_0_0_2_ErrCode = 0;
           putValue(P_FSG_82_0_0_2_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_2", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_3_ID:
           gP_FSG_82_0_0_3_ErrCode = 0;
           putValue(P_FSG_82_0_0_3_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_3", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_4_ID:
           gP_FSG_82_0_0_4_ErrCode = 0;
           putValue(P_FSG_82_0_0_4_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_4", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_13_ID:
           gP_FSG_82_0_0_13_ErrCode = 0;
           putValue(P_FSG_82_0_0_13_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_13", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_15_ID:
           gP_FSG_82_0_0_15_ErrCode = 0;
           putValue(P_FSG_82_0_0_15_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_15", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_16_ID:
           gP_FSG_82_0_0_16_ErrCode = 0;
           putValue(P_FSG_82_0_0_16_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_16", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_17_ID:
           gP_FSG_82_0_0_17_ErrCode = 0;
           putValue(P_FSG_82_0_0_17_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_17", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_18_ID:
           gP_FSG_82_0_0_18_ErrCode = 0;
           putValue(P_FSG_82_0_0_18_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_18", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_19_ID:
           gP_FSG_82_0_0_19_ErrCode = 0;
           putValue(P_FSG_82_0_0_19_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_19", MakeRGB(255,79,79));
       break;
       case A_FSG_82_0_0_20_ID:
           gA_FSG_82_0_0_20_ErrCode = 0;
           putValue(A_FSG_82_0_0_20_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_82_0_0_20", MakeRGB(255,79,79));
       break;
       case M_FSG_82_0_0_21_ID:
           gM_FSG_82_0_0_21_ErrCode = 0;
           putValue(M_FSG_82_0_0_21_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_82_0_0_21", MakeRGB(255,79,79));
           putValue(M_FSG_82_0_0_21_State,  "ReqErr");
       break;
       case P_FSG_82_0_0_22_ID:
           gP_FSG_82_0_0_22_ErrCode = 0;
           putValue(P_FSG_82_0_0_22_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_22", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_23_ID:
           gP_FSG_82_0_0_23_ErrCode = 0;
           putValue(P_FSG_82_0_0_23_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_23", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_24_ID:
           gP_FSG_82_0_0_24_ErrCode = 0;
           putValue(P_FSG_82_0_0_24_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_24", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_25_ID:
           gP_FSG_82_0_0_25_ErrCode = 0;
           putValue(P_FSG_82_0_0_25_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_25", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_26_ID:
           gP_FSG_82_0_0_26_ErrCode = 0;
           putValue(P_FSG_82_0_0_26_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_26", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_27_ID:
           gP_FSG_82_0_0_27_ErrCode = 0;
           putValue(P_FSG_82_0_0_27_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_27", MakeRGB(255,79,79));
       break;
       case A_FSG_82_0_0_28_ID:
           gA_FSG_82_0_0_28_ErrCode = 0;
           putValue(A_FSG_82_0_0_28_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_82_0_0_28", MakeRGB(255,79,79));
       break;
       case M_FSG_82_0_0_29_ID:
           gM_FSG_82_0_0_29_ErrCode = 0;
           putValue(M_FSG_82_0_0_29_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_82_0_0_29", MakeRGB(255,79,79));
           putValue(M_FSG_82_0_0_29_State,  "ReqErr");
       break;
       case P_FSG_82_0_0_30_ID:
           gP_FSG_82_0_0_30_ErrCode = 0;
           putValue(P_FSG_82_0_0_30_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_30", MakeRGB(255,79,79));
       break;
       case P_FSG_82_0_0_31_ID:
           gP_FSG_82_0_0_31_ErrCode = 0;
           putValue(P_FSG_82_0_0_31_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_31", MakeRGB(255,79,79));
       break;
       default:
           writelineEx(gError_Trace, 0, "%s%d/%d Unknown Functionid in  displayErrorCode", SGtype, LSGID,fctID);
   }

}

BAP_DLL_Request ()
{
    dword i;
    int l=0;
    byte temp;
    byte Request_data[BAP_buffer_size];    //Request data for DLL
    dword Request_header[6];    //Request header for DLL
    byte dataValid;
    int nextElementToRead;

    // defaultmaessig ist senden OK
    dataValid = 1;

    // loeschen der Daten "Container"
    for(i=0;i<6;i++)
        Request_header[i]=0;
    //for(i=0;i<BAP_buffer_size;i++)
    //    Request_data[i]=0;


    // Verarbeiten aller noch offenen Requests
    while ((nextElementToRead = getNextReadIndex()) != -1)
    {
        // Fuer alle Datentypen gleich
        Request_header[0]=gBAP_Request_header [nextElementToRead][0];       //LSG-ID
        Request_header[1]=gBAP_Request_header [nextElementToRead][1];       //Function-ID
        Request_header[2]=gBAP_Request_header [nextElementToRead][2];       //request type
        Request_header[3]=gBAP_Request_header [nextElementToRead][3];       //BAP data type

        switch(gBAP_Request_header[nextElementToRead][3]){
            case Bap_uint32:
                l=2;
            case Bap_uint16:
                l++;
            case Bap_uint8:
            case Bap_error: // Request (2) wird dabei ignoriert
                l++;
            case Bap_void:  // Datenfeld (5) wird dabei ignoriert
                Request_header[4]=l;                                                //  not used
                Request_header[5]=gBAP_Request_header [nextElementToRead][5];       // Daten
            break;
            case Bap_byteSequence:
                Request_header[4]=gBAP_Request_header [nextElementToRead][4];       // length
                Request_header[5]=0;                                                // not used

                // data-array for BAP-DLL funcion 'BAP_Request'
                for(i=0;i<Request_header[4]/*BAP_buffer_size*/;i++)
                    Request_data[i]=gBAP_Request_data [nextElementToRead][i];
                break;
            default:
                writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Request_header[nextElementToRead][3]);
                dataValid = 0;
            break;
        }

        if(dataValid){
            // wie heisst der Request?
            writelineEx(gBAP_Trace, 0, "%s%d/%d BAP_Request %s datatype:%s length:%d", SGtype, Request_header[0],Request_header[1],Requesttype_Text[Request_header[2]],Datatype_Text[Request_header[3]],Request_header[4]);
            temp = BAP150_Request(NODE_INDEX, Request_header, Request_data);    //send data to BAP-DLL
            // BAP-Request failed
            if(temp != 0){
                // Fehlercode: Request failed
                writelineEx(gError_Trace, 0, "%s%d/%d Error during BAP_Request errorcode: 0x%X", SGtype, Request_header[0],Request_header[1],temp);
                DisplayRequestErrorCode(Request_header[1],temp);
            }
        }

    }
}

int getNextReadIndex ()
{
    int i, ret;
    // der Puffer wird nach dem naechsten zu lesenden Eintrag durchsucht
    // Existiert keiner wird -1 zurueckgegeben
    ret = -1;

    for (i = 0; i < Requestbuffer_lines; i++)
    {
        if (gBAP_Requestbuffer_status[i] == 1)
        {
            // zum verschicken
            ret = i;
            // und wieder freigeben
            gBAP_Requestbuffer_status[i] = 0;
            break;
        }
    }

    return (ret);
}

int getNextWriteIndex ()
{
    int i, ret;
    // der Puffer wird nach dem naechsten freien Eintrag durchsucht
    // Existiert keiner wird -1 zurueckgegeben
    ret = -1;

    for (i = 0; i < Requestbuffer_lines; i++)
    {
        if (gBAP_Requestbuffer_status[i] == 0)
        {
            // zum schreiben
            ret = i;
            // belegen
            gBAP_Requestbuffer_status[i] = 1;
            break;
        }
    }

    return (ret);
}

//gBAP_Indication_header[0])  // LSGID
//gBAP_Indication_header[1]) // FCTID
//gBAP_Indication_header[2]) // IndType
//gBAP_Indication_header[3]) // Datentyp

M_FSG_82_0_0_29_ProcessingRequest ()
{
   byte temp[BAP_buffer_size];
   getValue(M_FSG_82_0_0_29_Processing, temp);
   Request_byteSequence(LSGID, M_FSG_82_0_0_29_ID, Processing_REQ, temp, getValueSize(M_FSG_82_0_0_29_Processing));
}
M_FSG_82_0_0_21_ProcessingRequest ()
{
   byte temp[BAP_buffer_size];
   getValue(M_FSG_82_0_0_21_Processing, temp);
   Request_byteSequence(LSGID, M_FSG_82_0_0_21_ID, Processing_REQ, temp, getValueSize(M_FSG_82_0_0_21_Processing));
}


Process_Current_Indication ()
{
   int rxsize;
   int txsize;
   byte temp[BAP_buffer_size];
   char buffer[BAP_buffer_size];
   if(strncmp(Datatype_Text[gBAP_Indication_header[3]], "acknowledge", 4)!=0)
       writelineEx(gBAP_Trace, 0, "NodeIndex: %d: CurrentIndication %s lsgid:%d fctid:%d indType:%s dataType=%s length=%d",
               NODE_INDEX, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   else
       writelineEx(gBAP_Trace, 0, "Internal acknowledge %s-%d fctid:%d indType:%s dataType=%s length=%d",
               SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Acknowledgetype_Text[gBAP_Indication_header[5]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   switch(gBAP_Indication_header[0])  // LSGID
   {
   case LSGID:
       switch(gBAP_Indication_header[1]) // FCTID
       {
    case P_FSG_82_0_0_13_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_82_0_0_13_ErrEn)) {
                               Request_error(LSGID,P_FSG_82_0_0_13_ID,getValue(P_FSG_82_0_0_13_ErrCode));
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_82_0_0_13, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_13", MakeRGB(255,255,255));
                            break;
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_82_0_0_13_ErrEn)) {
                               Request_error(LSGID,P_FSG_82_0_0_13_ID,getValue(P_FSG_82_0_0_13_ErrCode));
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_82_0_0_13, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_13", MakeRGB(255,255,255));
                            // und antworten
                            Request_Int8(LSGID, P_FSG_82_0_0_13_ID, Data_REQ, getValue(P_FSG_82_0_0_13));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_82_0_0_13_ErrCode = 0;
                putValue(P_FSG_82_0_0_13_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_13", MakeRGB(255,79,79));
                gP_FSG_82_0_0_13_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_82_0_0_15_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_error:
                gP_FSG_82_0_0_15_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_15", MakeRGB(255,79,79));
                gP_FSG_82_0_0_15_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_82_0_0_16_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_16_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_16_ID,getValue(P_FSG_82_0_0_16_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_16, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_16", MakeRGB(255,255,255));
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_16_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_16_ID,getValue(P_FSG_82_0_0_16_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_16, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_16", MakeRGB(255,255,255));
                        // und antworten
                        getValue(P_FSG_82_0_0_16, temp);
                        Request_byteSequence(LSGID, P_FSG_82_0_0_16_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                     case Ack_IND: // Indication pruefen
                         //write("ASG hat Ack geschickt (BYTESEQUENCE)");
                        putValue(P_FSG_82_0_0_16_Ack, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_16", MakeRGB(255,255,255));
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_82_0_0_16_ErrCode = 0;
                putValue(P_FSG_82_0_0_16_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_16", MakeRGB(255,79,79));
                gP_FSG_82_0_0_16_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_82_0_0_17_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_17_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_17_ID,getValue(P_FSG_82_0_0_17_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_17, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_17", MakeRGB(255,255,255));
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_17_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_17_ID,getValue(P_FSG_82_0_0_17_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_17, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_17", MakeRGB(255,255,255));
                        // und antworten
                        getValue(P_FSG_82_0_0_17, temp);
                        Request_byteSequence(LSGID, P_FSG_82_0_0_17_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                     case Ack_IND: // Indication pruefen
                         //write("ASG hat Ack geschickt (BYTESEQUENCE)");
                        putValue(P_FSG_82_0_0_17_Ack, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_17", MakeRGB(255,255,255));
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_82_0_0_17_ErrCode = 0;
                putValue(P_FSG_82_0_0_17_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_17", MakeRGB(255,79,79));
                gP_FSG_82_0_0_17_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_82_0_0_18_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_error:
                gP_FSG_82_0_0_18_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_18", MakeRGB(255,79,79));
                gP_FSG_82_0_0_18_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_82_0_0_19_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_19_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_19_ID,getValue(P_FSG_82_0_0_19_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_19, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_19", MakeRGB(255,255,255));
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_19_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_19_ID,getValue(P_FSG_82_0_0_19_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_19, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_19", MakeRGB(255,255,255));
                        // und antworten
                        getValue(P_FSG_82_0_0_19, temp);
                        Request_byteSequence(LSGID, P_FSG_82_0_0_19_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_82_0_0_19_ErrCode = 0;
                putValue(P_FSG_82_0_0_19_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_19", MakeRGB(255,79,79));
                gP_FSG_82_0_0_19_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_82_0_0_20_ID:
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_82_0_0_20_ErrEn)) {
                               Request_error(LSGID,A_FSG_82_0_0_20_ID,getValue(A_FSG_82_0_0_20_ErrCode));
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_82_0_0_20_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_82_0_0_20_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_82_0_0_20", MakeRGB(255,255,255));
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_82_0_0_20_ErrEn)) {
                               Request_error(LSGID,A_FSG_82_0_0_20_ID,getValue(A_FSG_82_0_0_20_ErrCode));
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_82_0_0_20_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_82_0_0_20_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_82_0_0_20", MakeRGB(255,255,255));
                    // und antworten
                    //getValue(A_FSG_82_0_0_20, temp);
                    //Request_byteSequence(LSGID, A_FSG_82_0_0_20_ID, Data_REQ, temp, getValueSize(A_FSG_82_0_0_20));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_82_0_0_20Status_BTN, 1);
                    //putValue(A_FSG_82_0_0_20Status_BTN, 0);
                    A_FSG_82_0_0_20_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_82_0_0_20_ErrEn)) {
                               Request_error(LSGID,A_FSG_82_0_0_20_ID,getValue(A_FSG_82_0_0_20_ErrCode));
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_82_0_0_20_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_82_0_0_20_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_82_0_0_20", MakeRGB(255,255,255));
                    // und antworten
                    //getValue(A_FSG_82_0_0_20, temp);
                    //Request_byteSequence(LSGID, A_FSG_82_0_0_20_ID, Data_REQ, temp, getValueSize(A_FSG_82_0_0_20));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_82_0_0_20Status_BTN, 1);
                    //putValue(A_FSG_82_0_0_20Status_BTN, 0);
                    A_FSG_82_0_0_20_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_82_0_0_20_ErrCode = 0;
                putValue(A_FSG_82_0_0_20_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_82_0_0_20", MakeRGB(255,79,79));
                gA_FSG_82_0_0_20_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_FSG_82_0_0_21_ID:
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND:
                            if (getValue(M_FSG_82_0_0_21_ErrEn)) {
                               Request_error(LSGID,M_FSG_82_0_0_21_ID,getValue(M_FSG_82_0_0_21_ErrCode));
                               break;
                            }
                           // running
                            putValue(M_FSG_82_0_0_21_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_82_0_0_21_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_82_0_0_21", MakeRGB(255,255,255));
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_82_0_0_21_ErrEn)) {
                               Request_error(LSGID,M_FSG_82_0_0_21_ID,getValue(M_FSG_82_0_0_21_ErrCode));
                               break;
                            }
                            putValue(M_FSG_82_0_0_21_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_82_0_0_21_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_82_0_0_21", MakeRGB(255,255,255));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_82_0_0_21_State, "Aborted");
                            //if (getValue(M_FSG_82_0_0_21_ErrEn))
                            {
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_82_0_0_21_ID, getValue(M_FSG_82_0_0_21_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:
                            if (getValue(M_FSG_82_0_0_21_ErrEn)) {
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_82_0_0_21_ID, getValue(M_FSG_82_0_0_21_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_82_0_0_21_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_82_0_0_21_ID, Processing_REQ, temp, getValueSize(M_FSG_82_0_0_21_Processing));
                            M_FSG_82_0_0_21_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_82_0_0_21", MakeRGB(255,255,255));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_82_0_0_21_ErrCode = 0;
                putValue(M_FSG_82_0_0_21_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_82_0_0_21", MakeRGB(255,79,79));
                gM_FSG_82_0_0_21_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_FSG_82_0_0_22_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_error:
                gP_FSG_82_0_0_22_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_22", MakeRGB(255,79,79));
                gP_FSG_82_0_0_22_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_82_0_0_23_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_error:
                gP_FSG_82_0_0_23_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_23", MakeRGB(255,79,79));
                gP_FSG_82_0_0_23_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_82_0_0_24_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_24_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_24_ID,getValue(P_FSG_82_0_0_24_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_24, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_24", MakeRGB(255,255,255));
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_24_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_24_ID,getValue(P_FSG_82_0_0_24_ErrCode));
                           break;
                        }
                        // Daten setzen
                        getValue(P_FSG_82_0_0_24, temp);
                        gBAP_Indication_data[2]=temp[2];
                        gBAP_Indication_data[3]=temp[3];
                        putValue(P_FSG_82_0_0_24, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_24", MakeRGB(255,255,255));
                        // und antworten
                        getValue(P_FSG_82_0_0_24, temp);
                        Request_byteSequence(LSGID, P_FSG_82_0_0_24_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_82_0_0_24_ErrCode = 0;
                putValue(P_FSG_82_0_0_24_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_24", MakeRGB(255,79,79));
                gP_FSG_82_0_0_24_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_82_0_0_25_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_25_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_25_ID,getValue(P_FSG_82_0_0_25_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_25, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_25", MakeRGB(255,255,255));
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_25_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_25_ID,getValue(P_FSG_82_0_0_25_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_25, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_25", MakeRGB(255,255,255));
                        // und antworten
                        getValue(P_FSG_82_0_0_25, temp);
                        Request_byteSequence(LSGID, P_FSG_82_0_0_25_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_82_0_0_25_ErrCode = 0;
                putValue(P_FSG_82_0_0_25_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_25", MakeRGB(255,79,79));
                gP_FSG_82_0_0_25_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_82_0_0_26_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_26_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_26_ID,getValue(P_FSG_82_0_0_26_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_26, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_26", MakeRGB(255,255,255));
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_26_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_26_ID,getValue(P_FSG_82_0_0_26_ErrCode));
                           break;
                        }
                        // Daten setzen
                        getValue(P_FSG_82_0_0_26, temp);
                        gBAP_Indication_data[4]=temp[4];
                        gBAP_Indication_data[7]=temp[7];
                        gBAP_Indication_data[8]=temp[8];
                        gBAP_Indication_data[9]=temp[9];
                        gBAP_Indication_data[10]=temp[10];
                        gBAP_Indication_data[11]=temp[11];
                        gBAP_Indication_data[12]=temp[12];
                        gBAP_Indication_data[13]=temp[13];
                        gBAP_Indication_data[14]=temp[14];
                        gBAP_Indication_data[15]=temp[15];
                        gBAP_Indication_data[16]=temp[16];
                        gBAP_Indication_data[17]=temp[17];
                        gBAP_Indication_data[18]=temp[18];
                        gBAP_Indication_data[19]=temp[19];
                        gBAP_Indication_data[20]=temp[20];
                        gBAP_Indication_data[21]=temp[21];
                        gBAP_Indication_data[22]=temp[22];
                        gBAP_Indication_data[23]=temp[23];
                        gBAP_Indication_data[24]=temp[24];
                        gBAP_Indication_data[25]=temp[25];
                        gBAP_Indication_data[26]=temp[26];
                        gBAP_Indication_data[27]=temp[27];
                        gBAP_Indication_data[28]=temp[28];
                        gBAP_Indication_data[29]=temp[29];
                        gBAP_Indication_data[30]=temp[30];
                        gBAP_Indication_data[31]=temp[31];
                        gBAP_Indication_data[32]=temp[32];
                        gBAP_Indication_data[33]=temp[33];
                        gBAP_Indication_data[34]=temp[34];
                        gBAP_Indication_data[35]=temp[35];
                        gBAP_Indication_data[36]=temp[36];
                        gBAP_Indication_data[37]=temp[37];
                        gBAP_Indication_data[38]=temp[38];
                        gBAP_Indication_data[39]=temp[39];
                        gBAP_Indication_data[40]=temp[40];
                        gBAP_Indication_data[41]=temp[41];
                        gBAP_Indication_data[42]=temp[42];
                        gBAP_Indication_data[43]=temp[43];
                        gBAP_Indication_data[44]=temp[44];
                        gBAP_Indication_data[45]=temp[45];
                        gBAP_Indication_data[46]=temp[46];
                        gBAP_Indication_data[47]=temp[47];
                        gBAP_Indication_data[48]=temp[48];
                        gBAP_Indication_data[49]=temp[49];
                        gBAP_Indication_data[50]=temp[50];
                        gBAP_Indication_data[51]=temp[51];
                        gBAP_Indication_data[52]=temp[52];
                        gBAP_Indication_data[53]=temp[53];
                        gBAP_Indication_data[54]=temp[54];
                        gBAP_Indication_data[55]=temp[55];
                        gBAP_Indication_data[56]=temp[56];
                        gBAP_Indication_data[57]=temp[57];
                        gBAP_Indication_data[58]=temp[58];
                        gBAP_Indication_data[59]=temp[59];
                        gBAP_Indication_data[60]=temp[60];
                        gBAP_Indication_data[61]=temp[61];
                        gBAP_Indication_data[62]=temp[62];
                        gBAP_Indication_data[63]=temp[63];
                        gBAP_Indication_data[64]=temp[64];
                        gBAP_Indication_data[65]=temp[65];
                        gBAP_Indication_data[66]=temp[66];
                        gBAP_Indication_data[67]=temp[67];
                        gBAP_Indication_data[68]=temp[68];
                        gBAP_Indication_data[69]=temp[69];
                        gBAP_Indication_data[70]=temp[70];
                        gBAP_Indication_data[71]=temp[71];
                        gBAP_Indication_data[72]=temp[72];
                        gBAP_Indication_data[73]=temp[73];
                        gBAP_Indication_data[74]=temp[74];
                        gBAP_Indication_data[75]=temp[75];
                        gBAP_Indication_data[76]=temp[76];
                        gBAP_Indication_data[77]=temp[77];
                        gBAP_Indication_data[78]=temp[78];
                        gBAP_Indication_data[79]=temp[79];
                        gBAP_Indication_data[80]=temp[80];
                        gBAP_Indication_data[81]=temp[81];
                        gBAP_Indication_data[82]=temp[82];
                        gBAP_Indication_data[83]=temp[83];
                        gBAP_Indication_data[84]=temp[84];
                        gBAP_Indication_data[85]=temp[85];
                        gBAP_Indication_data[86]=temp[86];
                        gBAP_Indication_data[87]=temp[87];
                        gBAP_Indication_data[88]=temp[88];
                        gBAP_Indication_data[89]=temp[89];
                        gBAP_Indication_data[90]=temp[90];
                        gBAP_Indication_data[91]=temp[91];
                        gBAP_Indication_data[92]=temp[92];
                        gBAP_Indication_data[93]=temp[93];
                        gBAP_Indication_data[94]=temp[94];
                        gBAP_Indication_data[95]=temp[95];
                        gBAP_Indication_data[96]=temp[96];
                        gBAP_Indication_data[97]=temp[97];
                        gBAP_Indication_data[98]=temp[98];
                        gBAP_Indication_data[99]=temp[99];
                        gBAP_Indication_data[100]=temp[100];
                        gBAP_Indication_data[101]=temp[101];
                        gBAP_Indication_data[102]=temp[102];
                        gBAP_Indication_data[103]=temp[103];
                        gBAP_Indication_data[104]=temp[104];
                        gBAP_Indication_data[105]=temp[105];
                        gBAP_Indication_data[106]=temp[106];
                        gBAP_Indication_data[107]=temp[107];
                        gBAP_Indication_data[108]=temp[108];
                        gBAP_Indication_data[109]=temp[109];
                        gBAP_Indication_data[110]=temp[110];
                        gBAP_Indication_data[111]=temp[111];
                        gBAP_Indication_data[112]=temp[112];
                        gBAP_Indication_data[113]=temp[113];
                        gBAP_Indication_data[114]=temp[114];
                        gBAP_Indication_data[115]=temp[115];
                        gBAP_Indication_data[116]=temp[116];
                        gBAP_Indication_data[117]=temp[117];
                        gBAP_Indication_data[118]=temp[118];
                        gBAP_Indication_data[119]=temp[119];
                        gBAP_Indication_data[120]=temp[120];
                        gBAP_Indication_data[121]=temp[121];
                        gBAP_Indication_data[122]=temp[122];
                        gBAP_Indication_data[123]=temp[123];
                        gBAP_Indication_data[124]=temp[124];
                        gBAP_Indication_data[125]=temp[125];
                        gBAP_Indication_data[126]=temp[126];
                        gBAP_Indication_data[127]=temp[127];
                        gBAP_Indication_data[128]=temp[128];
                        gBAP_Indication_data[129]=temp[129];
                        gBAP_Indication_data[130]=temp[130];
                        gBAP_Indication_data[131]=temp[131];
                        gBAP_Indication_data[132]=temp[132];
                        gBAP_Indication_data[133]=temp[133];
                        gBAP_Indication_data[134]=temp[134];
                        gBAP_Indication_data[135]=temp[135];
                        gBAP_Indication_data[136]=temp[136];
                        gBAP_Indication_data[137]=temp[137];
                        putValue(P_FSG_82_0_0_26, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_26", MakeRGB(255,255,255));
                        // und antworten
                        getValue(P_FSG_82_0_0_26, temp);
                        Request_byteSequence(LSGID, P_FSG_82_0_0_26_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_82_0_0_26_ErrCode = 0;
                putValue(P_FSG_82_0_0_26_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_26", MakeRGB(255,79,79));
                gP_FSG_82_0_0_26_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_82_0_0_27_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_27_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_27_ID,getValue(P_FSG_82_0_0_27_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_27, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_27", MakeRGB(255,255,255));
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_82_0_0_27_ErrEn)) {
                           Request_error(LSGID,P_FSG_82_0_0_27_ID,getValue(P_FSG_82_0_0_27_ErrCode));
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_82_0_0_27, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_27", MakeRGB(255,255,255));
                        // und antworten
                        getValue(P_FSG_82_0_0_27, temp);
                        Request_byteSequence(LSGID, P_FSG_82_0_0_27_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_82_0_0_27_ErrCode = 0;
                putValue(P_FSG_82_0_0_27_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_27", MakeRGB(255,79,79));
                gP_FSG_82_0_0_27_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_82_0_0_28_ID:
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_82_0_0_28_ErrEn)) {
                               Request_error(LSGID,A_FSG_82_0_0_28_ID,getValue(A_FSG_82_0_0_28_ErrCode));
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_82_0_0_28_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_82_0_0_28_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_82_0_0_28", MakeRGB(255,255,255));
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_82_0_0_28_ErrEn)) {
                               Request_error(LSGID,A_FSG_82_0_0_28_ID,getValue(A_FSG_82_0_0_28_ErrCode));
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_82_0_0_28_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_82_0_0_28_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_82_0_0_28", MakeRGB(255,255,255));
                    // und antworten
                    //getValue(A_FSG_82_0_0_28, temp);
                    //Request_byteSequence(LSGID, A_FSG_82_0_0_28_ID, Data_REQ, temp, getValueSize(A_FSG_82_0_0_28));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_82_0_0_28Status_BTN, 1);
                    //putValue(A_FSG_82_0_0_28Status_BTN, 0);
                    A_FSG_82_0_0_28_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_82_0_0_28_ErrEn)) {
                               Request_error(LSGID,A_FSG_82_0_0_28_ID,getValue(A_FSG_82_0_0_28_ErrCode));
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_82_0_0_28_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_82_0_0_28_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_82_0_0_28", MakeRGB(255,255,255));
                    // und antworten
                    //getValue(A_FSG_82_0_0_28, temp);
                    //Request_byteSequence(LSGID, A_FSG_82_0_0_28_ID, Data_REQ, temp, getValueSize(A_FSG_82_0_0_28));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_82_0_0_28Status_BTN, 1);
                    //putValue(A_FSG_82_0_0_28Status_BTN, 0);
                    A_FSG_82_0_0_28_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_82_0_0_28_ErrCode = 0;
                putValue(A_FSG_82_0_0_28_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_82_0_0_28", MakeRGB(255,79,79));
                gA_FSG_82_0_0_28_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_FSG_82_0_0_29_ID:
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND:
                            if (getValue(M_FSG_82_0_0_29_ErrEn)) {
                               Request_error(LSGID,M_FSG_82_0_0_29_ID,getValue(M_FSG_82_0_0_29_ErrCode));
                               break;
                            }
                           // running
                            putValue(M_FSG_82_0_0_29_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_82_0_0_29_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_82_0_0_29", MakeRGB(255,255,255));
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_82_0_0_29_ErrEn)) {
                               Request_error(LSGID,M_FSG_82_0_0_29_ID,getValue(M_FSG_82_0_0_29_ErrCode));
                               break;
                            }
                            putValue(M_FSG_82_0_0_29_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_82_0_0_29_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_82_0_0_29", MakeRGB(255,255,255));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_82_0_0_29_State, "Aborted");
                            //if (getValue(M_FSG_82_0_0_29_ErrEn))
                            {
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_82_0_0_29_ID, getValue(M_FSG_82_0_0_29_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:
                            if (getValue(M_FSG_82_0_0_29_ErrEn)) {
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_82_0_0_29_ID, getValue(M_FSG_82_0_0_29_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_82_0_0_29_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_82_0_0_29_ID, Processing_REQ, temp, getValueSize(M_FSG_82_0_0_29_Processing));
                            M_FSG_82_0_0_29_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_82_0_0_29", MakeRGB(255,255,255));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_82_0_0_29_ErrCode = 0;
                putValue(M_FSG_82_0_0_29_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_82_0_0_29", MakeRGB(255,79,79));
                gM_FSG_82_0_0_29_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_FSG_82_0_0_30_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_error:
                gP_FSG_82_0_0_30_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_30", MakeRGB(255,79,79));
                gP_FSG_82_0_0_30_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_82_0_0_31_ID:
        switch(gBAP_Indication_header[3]) // Datentyp
        {
            case Bap_error:
                gP_FSG_82_0_0_31_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_82_0_0_31", MakeRGB(255,79,79));
                gP_FSG_82_0_0_31_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
       default:
           writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal Fct: lsgid:%d fctid:%d indType:%d",
           NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], gBAP_Indication_header[2]);
           break;
       }
       break;
   default:
       writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal LSGID: lsgid:%d fctid:%d indType:%s", NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]]);
       break;
   }
}

on message *
{
   int i, temp;
   byte RX_Data[64];            // received CAN-DATA
   dword RX_Header[4];         // received CAN-Header
   if( gSG_PowerOnOff==Power_on )
   {
       if(( this.dir == rx ) && (( this.ID & 0xFFFF0000) == 0x97330000 ))
       {
           RX_Header[0] = 1; //BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet
           RX_Header[1] = this.msgChannel;
           RX_Header[2] = this.DataLength; // received length
           RX_Header[3] = this.ID;
           for( i = 0; i < this.DataLength; i++ )
           {
               RX_Data[i] = this.byte(i);
           }
           temp=BAP180_SetRxData( NODE_INDEX, RX_Header, RX_Data );
       }
    }
}

intertelegram_err(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=1;
    data[3]=940;
    ChangeConfig(0x0020,data);
}

sequence_err(long fctId, long size)
{
    long data[5];
    long lastSeg;

    lastSeg = size-5;

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=lastSeg/7+1;
    data[3]=1;
    data[4]=(lastSeg/7+4) & 15;
    ChangeConfig(0x0021,data);
}

intertelegram_err_off(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    ChangeConfig(0x0020,data);
}

sequence_err_off(long fctId)
{
    long data[5];

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    data[4]=0;
    ChangeConfig(0x0021,data);
}

OnUdpReceiveFrom( dword socket, long result, byte ipv6Address[], dword port, byte buffer[], dword size)
{
  int i;
  dword Header[13];
  byte Ipv6_temp[16];
  const long  INVALID_SOCKET = ~0;

  if(socket != INVALID_SOCKET)
  {
    if(result == 0)
    {
      Header[0] = 4; // /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
      Header[2] = size;

     for(i=0;i<gUdpSocketCnt;i++)
      {
        if(gUdpSockets[i].Handle == socket)
        {
          Header[1] = gUdpSockets[i].Channel;
          Header[3] = gUdpSockets[i].Id;
          for(i=0; i<8; i++)
          {
            Header[i+4] = ((dword)ipv6Address[2*i]) << 8;
            Header[i+4] |= ((dword)ipv6Address[2*i+1]) ;
          }
          Header[12] = port;
          BAP180_SetRxData(NODE_INDEX, Header, buffer);
          break;
        }
      }
    }
  }
}

void CloseUdpSocket()
{
  int i;
  const long  INVALID_SOCKET =    ~0;
  for(i=0;i<gUdpSocketCnt;i++)
  {
    if(gUdpSockets[i].Handle != INVALID_SOCKET)
    {
      UdpClose(gUdpSockets[i].Handle);
      gUdpSockets[i].Handle = INVALID_SOCKET;
    }
  }
}

on envVar ON_OFF_FSG82_0
{
   BapOnOff(getvalue(this));
   gSG_PowerOnOff=getvalue(ON_OFF_FSG82_0);
}
on envVar BAPCFG_FSG_82_0_0_DFMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 9, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}

on envVar BAPCFG_FSG_82_0_0_DFMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 10, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}

on envVar BAPCFG_FSG_82_0_0_LsgClassMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 5, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}

on envVar BAPCFG_FSG_82_0_0_LsgClassMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 6, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}

on envVar BAPCFG_FSG_82_0_0_ProtocolMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 7, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}

on envVar BAPCFG_FSG_82_0_0_ProtocolMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 8, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}

// Setzen der Schriftfarbe bei Zustandswechsel der FCTID C_FSG_82_0_0_1_ID
on envVar C_FSG_82_0_0_1_FctLstItemEn
{
    if(getValue(this))
    {
        setControlForeColor( panel_name, "checkbox_C_FSG_82_0_0_1", MakeRGB(0,240,0));
    }
    else
    {
        setControlForeColor( panel_name, "checkbox_C_FSG_82_0_0_1", MakeRGB(250,0,0));
    }
}

// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_82_0_0_2_ID
on envVar P_FSG_82_0_0_2_FctLstItemEn
{
       if(getValue(this))
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_2", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_2", MakeRGB(250,0,0));
       }
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_2_ErrCode
{
       if(gP_FSG_82_0_0_2_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_2", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_2_ErrCode = 1;
}

// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_82_0_0_3_ID
on envVar P_FSG_82_0_0_3_FctLstItemEn
{
       if(getValue(this))
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_3", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_3", MakeRGB(250,0,0));
       }
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_3_ErrCode
{
       if(gP_FSG_82_0_0_3_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_3", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_3_ErrCode = 1;
}
// De-Aktivierung der Eingabefelder der HB-FCT P_FSG_82_0_0_4
on envVar P_FSG_82_0_0_4_FctLstItemEn
{
       if(getValue(this))
       {
//           EnableControl(panel_name,"panel_FSG_82_0_0_4",1);
//           EnableControl(panel_name,"${ERRFIELD}",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_4_HBEn",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_4", MakeRGB(0,240,0));
       }
       else
       {
//           EnableControl(panel_name,"panel_FSG_82_0_0_4",0);
//           EnableControl(panel_name,"${ERRFIELD}",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_4_HBEn",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_4", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_82_0_0_4_FctEn
{
    long data[2];
    if(getValue(P_FSG_82_0_0_4_FctEn)>0)
    {
        data[0] = 82;
        data[1] = getValue(P_FSG_82_0_0_4);
        write("enable HB");
    }
    else
    {
        data[0] = 82;
        data[1] = 0;
        write("disable HB");
    }
    Bap150_ChangeConfig(NODE_INDEX, 0x00, data);
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_4_ErrCode
{
       if(gP_FSG_82_0_0_4_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_4", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_4_ErrCode = 1;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_13_ErrCode
{
       if(gP_FSG_82_0_0_13_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_13", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_13_ErrCode = 1;
}
on envVar P_FSG_82_0_0_13Status_BTN
{
    if (P_FSG_82_0_0_13Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_82_0_0_13_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_13",MakeRGB(255,255,255));
       P_FSG_82_0_0_13Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_82_0_0_13_ID, Data_REQ, getValue(P_FSG_82_0_0_13));
      P_FSG_82_0_0_13Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_82_0_0_13_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_13_ID;
    data[2]=getValue(P_FSG_82_0_0_13_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_13
on envVar P_FSG_82_0_0_13_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_13",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_13",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_13",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_13", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_13",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_13",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_13",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_13", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_82_0_0_13 // bus value of FSG_Control (13).
{
    // opcodes: Error-Status
    byte param1; // Controlcode
    // DATATYPE_UINTXX
    param1 = getValue(P_FSG_82_0_0_13);
    putValue(P_FSG_82_0_0_13_1, param1);
}

on envVar P_FSG_82_0_0_13_1_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Controlcode
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_13_1);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_13_1,thisval);
}

on envVar P_FSG_82_0_0_13_1_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Controlcode
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_13_1);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_13_1,thisval);
}

on envVar P_FSG_82_0_0_13_1 // FSG_Control.Controlcode
{
    byte superval;

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // Controlcode
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_13_1_0, 1);
    else
        putValue(P_FSG_82_0_0_13_1_0, 0);
    if(thisval&(mask<<4))
        putValue(P_FSG_82_0_0_13_1_4, 1);
    else
        putValue(P_FSG_82_0_0_13_1_4, 0);

    // Update superval
    superval = getValue(P_FSG_82_0_0_13);
    superval = thisval;
    putValue(P_FSG_82_0_0_13,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_15_ErrCode
{
       if(gP_FSG_82_0_0_15_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_15", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_15_ErrCode = 1;
}
on envVar P_FSG_82_0_0_15Status_BTN
{
    byte BAPTemp[6];
   if (P_FSG_82_0_0_15Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_82_0_0_15_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_15",MakeRGB(255,255,255));
      P_FSG_82_0_0_15Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_82_0_0_15, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_82_0_0_15_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_15));
      P_FSG_82_0_0_15Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_82_0_0_15_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_15_ID;
    data[2]=getValue(P_FSG_82_0_0_15_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_15
on envVar P_FSG_82_0_0_15_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_15",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_15",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_15",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_15", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_15",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_15",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_15",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_15", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_82_0_0_15 // bus value of FSG_OperationState (15).
{
    // opcodes: Error-Status
    byte param1; // OP_State
    byte param2; // ServiceAvailability
    byte param3; // Extension1
    byte param4; // Extension2
    byte param5; // Extension3
    byte param6; // Extension4
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[6];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 6; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_15, superval);
    ///////// Start param1 - UINT8 /////////
    param1 = superval[currentPos++];
    putValue(P_FSG_82_0_0_15_1, param1);
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_82_0_0_15_2, param2);
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_15_3, round((param3 * 1.0) - (0) + (0), 1.0));
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_82_0_0_15_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_15_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_82_0_0_15_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_82_0_0_15_1 // FSG_OperationState.OP_State
{
    byte superval[6];

    //Update Childvalue (Enum)
    byte thisval; // OP_State
    thisval = getValue(this);

    // Update superval
    getValue(P_FSG_82_0_0_15, superval);
    superval[0]=thisval;
    putValue(P_FSG_82_0_0_15,superval);
}

on envVar P_FSG_82_0_0_15_2_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // ServiceAvailability
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_15_2);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_15_2,thisval);
}

on envVar P_FSG_82_0_0_15_2_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // ServiceAvailability
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_15_2);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_15_2,thisval);
}

on envVar P_FSG_82_0_0_15_2_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // ServiceAvailability
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_15_2);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_15_2,thisval);
}

on envVar P_FSG_82_0_0_15_2_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // ServiceAvailability
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_15_2);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_15_2,thisval);
}

on envVar P_FSG_82_0_0_15_2 // FSG_OperationState.ServiceAvailability
{
    byte superval[6];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // ServiceAvailability
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_15_2_0, 1);
    else
        putValue(P_FSG_82_0_0_15_2_0, 0);
    if(thisval&(mask<<1))
        putValue(P_FSG_82_0_0_15_2_1, 1);
    else
        putValue(P_FSG_82_0_0_15_2_1, 0);
    if(thisval&(mask<<2))
        putValue(P_FSG_82_0_0_15_2_2, 1);
    else
        putValue(P_FSG_82_0_0_15_2_2, 0);
    if(thisval&(mask<<3))
        putValue(P_FSG_82_0_0_15_2_3, 1);
    else
        putValue(P_FSG_82_0_0_15_2_3, 0);

    // Update superval
    getValue(P_FSG_82_0_0_15, superval);
    superval[1]=thisval;
    putValue(P_FSG_82_0_0_15,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_15_3_range // FSG_OperationState.Extension1
{
    @P_FSG_82_0_0_15_3 = @P_FSG_82_0_0_15_3_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_15_3 // FSG_OperationState.Extension1
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension1
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_15_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_15, superval);
    superval[2]=thisval;
    putValue(P_FSG_82_0_0_15,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_15_4_range // FSG_OperationState.Extension2
{
    @P_FSG_82_0_0_15_4 = @P_FSG_82_0_0_15_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_15_4 // FSG_OperationState.Extension2
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension2
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_15_4_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_15, superval);
    superval[3]=thisval;
    putValue(P_FSG_82_0_0_15,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_15_5_range // FSG_OperationState.Extension3
{
    @P_FSG_82_0_0_15_5 = @P_FSG_82_0_0_15_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_15_5 // FSG_OperationState.Extension3
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension3
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_15_5_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_15, superval);
    superval[4]=thisval;
    putValue(P_FSG_82_0_0_15,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_15_6_range // FSG_OperationState.Extension4
{
    @P_FSG_82_0_0_15_6 = @P_FSG_82_0_0_15_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_15_6 // FSG_OperationState.Extension4
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension4
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_15_6_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_15, superval);
    superval[5]=thisval;
    putValue(P_FSG_82_0_0_15,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_16_ErrCode
{
       if(gP_FSG_82_0_0_16_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_16", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_16_ErrCode = 1;
}
on envVar P_FSG_82_0_0_16Status_BTN
{
    byte BAPTemp[9];
    if (P_FSG_82_0_0_16Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_82_0_0_16_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_16",MakeRGB(255,255,255));
        P_FSG_82_0_0_16Status_BTN_already_pressed = 1;
    }
    else
    {
        P_FSG_82_0_0_16_BuildFct();
        getValue(P_FSG_82_0_0_16, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_82_0_0_16_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_16));
        if(getValue(P_FSG_82_0_0_16_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_82_0_0_16_ID);
        }
        if(getValue(P_FSG_82_0_0_16_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_82_0_0_16_ID,elCount(BAPTemp));
        }
       P_FSG_82_0_0_16Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_82_0_0_16StatusAck_BTN
{
    byte BAPTemp[9];
    if (P_FSG_82_0_0_16StatusAck_BTN_already_pressed == 0)
    {
        putValue(P_FSG_82_0_0_16_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_16",MakeRGB(255,255,255));
        P_FSG_82_0_0_16StatusAck_BTN_already_pressed = 1;
    }
    else
    {
        P_FSG_82_0_0_16_BuildFct();
        getValue(P_FSG_82_0_0_16, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_82_0_0_16_ID, DataAck_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_16));
        if(getValue(P_FSG_82_0_0_16_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_82_0_0_16_ID);
        }
        if(getValue(P_FSG_82_0_0_16_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_82_0_0_16_ID,elCount(BAPTemp));
        }
       P_FSG_82_0_0_16StatusAck_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_82_0_0_16_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_16_ID;
    data[2]=getValue(P_FSG_82_0_0_16_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_16
on envVar P_FSG_82_0_0_16_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_16",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_16",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_16",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_16", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_16",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_16",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_16",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_16", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_16_IntTlgEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_16_SegmEn,0);
           intertelegram_err(P_FSG_82_0_0_16_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_82_0_0_16_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_16_SegmEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_16_IntTlgEn,0);
           sequence_err(P_FSG_82_0_0_16_ID,getValueSize(P_FSG_82_0_0_16_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_82_0_0_16_ID);
       }
}
on envVar P_FSG_82_0_0_16 // bus value of PSO_Prompt (16).
{
    // opcodes: Error-Status-StatusAck
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // Control1
    word param4; // Extension2
    word param5; // Extension3
    word param6; // Extension4
    byte param7; // Response
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[9];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 9; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_16, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(P_FSG_82_0_0_16_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(P_FSG_82_0_0_16_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_16_3, param3);
    ///////// Start param4 - UINT16 /////////
    param4 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_82_0_0_16_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT16 /////////
    param5 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_82_0_0_16_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT16 /////////
    param6 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_82_0_0_16_6, round((param6 * 1.0) - (0) + (0), 1.0));
    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(P_FSG_82_0_0_16_7, param7);
}

// Updates the bus value field and other dependencies.
P_FSG_82_0_0_16_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // Control1
    word param4; // Extension2
    word param5; // Extension3
    word param6; // Extension4
    byte param7; // Response

    dword i;
    byte superval[9];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(P_FSG_82_0_0_16_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_16_2_range = round(@P_FSG_82_0_0_16_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    param3 = getValue(P_FSG_82_0_0_16_3);
    @P_FSG_82_0_0_16_3_0 = (param3 & 1) > 0;
    @P_FSG_82_0_0_16_3_1 = (param3 & 2) > 0;
    @P_FSG_82_0_0_16_3_2 = (param3 & 4) > 0;
    @P_FSG_82_0_0_16_3_3 = (param3 & 8) > 0;
    @P_FSG_82_0_0_16_3_4 = (param3 & 16) > 0;
    @P_FSG_82_0_0_16_3_5 = (param3 & 32) > 0;
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_16_4_range = round(@P_FSG_82_0_0_16_4 + (0), 1.0); // slider value + min = real value
    param4 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param4&0x00ff;
    superval[currentPos++]=(param4&0xff00)>>8;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_16_5_range = round(@P_FSG_82_0_0_16_5 + (0), 1.0); // slider value + min = real value
    param5 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param5&0x00ff;
    superval[currentPos++]=(param5&0xff00)>>8;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_16_6_range = round(@P_FSG_82_0_0_16_6 + (0), 1.0); // slider value + min = real value
    param6 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param6&0x00ff;
    superval[currentPos++]=(param6&0xff00)>>8;
// gen_BuildFunc_SetSuperVals
    param7 = getValue(P_FSG_82_0_0_16_7);
    @P_FSG_82_0_0_16_7_1 = (param7 & 2) > 0;
    @P_FSG_82_0_0_16_7_3 = (param7 & 8) > 0;
    @P_FSG_82_0_0_16_7_4 = (param7 & 16) > 0;
    superval[currentPos++]=param7;
    putValue(P_FSG_82_0_0_16, superval, currentPos);
}


on envVar P_FSG_82_0_0_16_1 // PSO_Prompt.ASG_ID
{
    P_FSG_82_0_0_16_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_16_2_range // PSO_Prompt.Extension1
{
    @P_FSG_82_0_0_16_2 = @P_FSG_82_0_0_16_2_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_16_2 // PSO_Prompt.Extension1
{
    P_FSG_82_0_0_16_BuildFct();
}

on envVar P_FSG_82_0_0_16_3_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_3);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_16_3,thisval);
}

on envVar P_FSG_82_0_0_16_3_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_3);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_16_3,thisval);
}

on envVar P_FSG_82_0_0_16_3_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_3);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_16_3,thisval);
}

on envVar P_FSG_82_0_0_16_3_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_3);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_16_3,thisval);
}

on envVar P_FSG_82_0_0_16_3_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_3);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_16_3,thisval);
}

on envVar P_FSG_82_0_0_16_3_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_3);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_16_3,thisval);
}

on envVar P_FSG_82_0_0_16_3 // PSO_Prompt.Control1
{
    P_FSG_82_0_0_16_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_16_4_range // PSO_Prompt.Extension2
{
    @P_FSG_82_0_0_16_4 = @P_FSG_82_0_0_16_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_16_4 // PSO_Prompt.Extension2
{
    P_FSG_82_0_0_16_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_16_5_range // PSO_Prompt.Extension3
{
    @P_FSG_82_0_0_16_5 = @P_FSG_82_0_0_16_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_16_5 // PSO_Prompt.Extension3
{
    P_FSG_82_0_0_16_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_16_6_range // PSO_Prompt.Extension4
{
    @P_FSG_82_0_0_16_6 = @P_FSG_82_0_0_16_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_16_6 // PSO_Prompt.Extension4
{
    P_FSG_82_0_0_16_BuildFct();
}

on envVar P_FSG_82_0_0_16_7_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_7);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_16_7,thisval);
}

on envVar P_FSG_82_0_0_16_7_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_7);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_16_7,thisval);
}

on envVar P_FSG_82_0_0_16_7_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_7);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_16_7,thisval);
}

on envVar P_FSG_82_0_0_16_7 // PSO_Prompt.Response
{
    P_FSG_82_0_0_16_BuildFct();
}

on envVar P_FSG_82_0_0_16_Ack // bus value of PSO_Prompt (16).
{
    // opcodes: Get-SetGet-Ack
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // Control1
    word param4; // Extension2
    word param5; // Extension3
    word param6; // Extension4
    byte param7; // Response
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[9];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 9; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_16_Ack, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(P_FSG_82_0_0_16_Ack_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(P_FSG_82_0_0_16_Ack_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_16_Ack_3, param3);
    ///////// Start param4 - UINT16 /////////
    param4 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_82_0_0_16_Ack_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT16 /////////
    param5 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_82_0_0_16_Ack_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT16 /////////
    param6 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_82_0_0_16_Ack_6, round((param6 * 1.0) - (0) + (0), 1.0));
    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(P_FSG_82_0_0_16_Ack_7, param7);
}

// Updates the bus value field and other dependencies.
P_FSG_82_0_0_16_Ack_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // Control1
    word param4; // Extension2
    word param5; // Extension3
    word param6; // Extension4
    byte param7; // Response

    dword i;
    byte superval[9];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(P_FSG_82_0_0_16_Ack_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_16_Ack_2_range = round(@P_FSG_82_0_0_16_Ack_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    param3 = getValue(P_FSG_82_0_0_16_Ack_3);
    @P_FSG_82_0_0_16_Ack_3_0 = (param3 & 1) > 0;
    @P_FSG_82_0_0_16_Ack_3_1 = (param3 & 2) > 0;
    @P_FSG_82_0_0_16_Ack_3_2 = (param3 & 4) > 0;
    @P_FSG_82_0_0_16_Ack_3_3 = (param3 & 8) > 0;
    @P_FSG_82_0_0_16_Ack_3_4 = (param3 & 16) > 0;
    @P_FSG_82_0_0_16_Ack_3_5 = (param3 & 32) > 0;
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_16_Ack_4_range = round(@P_FSG_82_0_0_16_Ack_4 + (0), 1.0); // slider value + min = real value
    param4 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param4&0x00ff;
    superval[currentPos++]=(param4&0xff00)>>8;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_16_Ack_5_range = round(@P_FSG_82_0_0_16_Ack_5 + (0), 1.0); // slider value + min = real value
    param5 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param5&0x00ff;
    superval[currentPos++]=(param5&0xff00)>>8;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_16_Ack_6_range = round(@P_FSG_82_0_0_16_Ack_6 + (0), 1.0); // slider value + min = real value
    param6 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param6&0x00ff;
    superval[currentPos++]=(param6&0xff00)>>8;
// gen_BuildFunc_SetSuperVals
    param7 = getValue(P_FSG_82_0_0_16_Ack_7);
    @P_FSG_82_0_0_16_Ack_7_1 = (param7 & 2) > 0;
    @P_FSG_82_0_0_16_Ack_7_3 = (param7 & 8) > 0;
    @P_FSG_82_0_0_16_Ack_7_4 = (param7 & 16) > 0;
    superval[currentPos++]=param7;
    putValue(P_FSG_82_0_0_16_Ack, superval, currentPos);
}


on envVar P_FSG_82_0_0_16_Ack_1 // PSO_Prompt.ASG_ID
{
    P_FSG_82_0_0_16_Ack_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_16_Ack_2_range // PSO_Prompt.Extension1
{
    @P_FSG_82_0_0_16_Ack_2 = @P_FSG_82_0_0_16_Ack_2_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_16_Ack_2 // PSO_Prompt.Extension1
{
    P_FSG_82_0_0_16_Ack_BuildFct();
}

on envVar P_FSG_82_0_0_16_Ack_3_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_Ack_3);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_16_Ack_3,thisval);
}

on envVar P_FSG_82_0_0_16_Ack_3_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_Ack_3);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_16_Ack_3,thisval);
}

on envVar P_FSG_82_0_0_16_Ack_3_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_Ack_3);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_16_Ack_3,thisval);
}

on envVar P_FSG_82_0_0_16_Ack_3_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_Ack_3);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_16_Ack_3,thisval);
}

on envVar P_FSG_82_0_0_16_Ack_3_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_Ack_3);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_16_Ack_3,thisval);
}

on envVar P_FSG_82_0_0_16_Ack_3_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Control1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_Ack_3);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_16_Ack_3,thisval);
}

on envVar P_FSG_82_0_0_16_Ack_3 // PSO_Prompt.Control1
{
    P_FSG_82_0_0_16_Ack_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_16_Ack_4_range // PSO_Prompt.Extension2
{
    @P_FSG_82_0_0_16_Ack_4 = @P_FSG_82_0_0_16_Ack_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_16_Ack_4 // PSO_Prompt.Extension2
{
    P_FSG_82_0_0_16_Ack_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_16_Ack_5_range // PSO_Prompt.Extension3
{
    @P_FSG_82_0_0_16_Ack_5 = @P_FSG_82_0_0_16_Ack_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_16_Ack_5 // PSO_Prompt.Extension3
{
    P_FSG_82_0_0_16_Ack_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_16_Ack_6_range // PSO_Prompt.Extension4
{
    @P_FSG_82_0_0_16_Ack_6 = @P_FSG_82_0_0_16_Ack_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_16_Ack_6 // PSO_Prompt.Extension4
{
    P_FSG_82_0_0_16_Ack_BuildFct();
}

on envVar P_FSG_82_0_0_16_Ack_7_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_Ack_7);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_16_Ack_7,thisval);
}

on envVar P_FSG_82_0_0_16_Ack_7_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_Ack_7);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_16_Ack_7,thisval);
}

on envVar P_FSG_82_0_0_16_Ack_7_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_16_Ack_7);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_16_Ack_7,thisval);
}

on envVar P_FSG_82_0_0_16_Ack_7 // PSO_Prompt.Response
{
    P_FSG_82_0_0_16_Ack_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_17_ErrCode
{
       if(gP_FSG_82_0_0_17_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_17", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_17_ErrCode = 1;
}
on envVar P_FSG_82_0_0_17Status_BTN
{
    byte BAPTemp[7];
    if (P_FSG_82_0_0_17Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_82_0_0_17_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_17",MakeRGB(255,255,255));
        P_FSG_82_0_0_17Status_BTN_already_pressed = 1;
    }
    else
    {
        P_FSG_82_0_0_17_BuildFct();
        getValue(P_FSG_82_0_0_17, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_82_0_0_17_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_17));
        if(getValue(P_FSG_82_0_0_17_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_82_0_0_17_ID);
        }
        if(getValue(P_FSG_82_0_0_17_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_82_0_0_17_ID,elCount(BAPTemp));
        }
       P_FSG_82_0_0_17Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_82_0_0_17StatusAck_BTN
{
    byte BAPTemp[7];
    if (P_FSG_82_0_0_17StatusAck_BTN_already_pressed == 0)
    {
        putValue(P_FSG_82_0_0_17_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_17",MakeRGB(255,255,255));
        P_FSG_82_0_0_17StatusAck_BTN_already_pressed = 1;
    }
    else
    {
        P_FSG_82_0_0_17_BuildFct();
        getValue(P_FSG_82_0_0_17, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_82_0_0_17_ID, DataAck_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_17));
        if(getValue(P_FSG_82_0_0_17_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_82_0_0_17_ID);
        }
        if(getValue(P_FSG_82_0_0_17_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_82_0_0_17_ID,elCount(BAPTemp));
        }
       P_FSG_82_0_0_17StatusAck_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_82_0_0_17_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_17_ID;
    data[2]=getValue(P_FSG_82_0_0_17_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_17
on envVar P_FSG_82_0_0_17_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_17",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_17",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_17",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_17", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_17",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_17",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_17",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_17", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_17_IntTlgEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_17_SegmEn,0);
           intertelegram_err(P_FSG_82_0_0_17_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_82_0_0_17_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_17_SegmEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_17_IntTlgEn,0);
           sequence_err(P_FSG_82_0_0_17_ID,getValueSize(P_FSG_82_0_0_17_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_82_0_0_17_ID);
       }
}
on envVar P_FSG_82_0_0_17 // bus value of PSO_Control (17).
{
    // opcodes: Error-Status-StatusAck
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // UserSlot
    word param4; // Extension2
    byte param5; // Extension3
    byte param6; // Extension4
    byte param7; // Response
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[7];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 7; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_17, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(P_FSG_82_0_0_17_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(P_FSG_82_0_0_17_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_17_3, round((param3 * 1.0) - (1) + (1), 1.0));
    ///////// Start param4 - UINT16 /////////
    param4 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_82_0_0_17_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_17_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_82_0_0_17_6, round((param6 * 1.0) - (0) + (0), 1.0));
    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(P_FSG_82_0_0_17_7, param7);
}

// Updates the bus value field and other dependencies.
P_FSG_82_0_0_17_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // UserSlot
    word param4; // Extension2
    byte param5; // Extension3
    byte param6; // Extension4
    byte param7; // Response

    dword i;
    byte superval[7];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(P_FSG_82_0_0_17_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_17_2_range = round(@P_FSG_82_0_0_17_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_17_3_range = round(@P_FSG_82_0_0_17_3 + (1), 1.0); // slider value + min = real value
    param3 = (@P_FSG_82_0_0_17_3 + (1) - (1)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_17_4_range = round(@P_FSG_82_0_0_17_4 + (0), 1.0); // slider value + min = real value
    param4 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param4&0x00ff;
    superval[currentPos++]=(param4&0xff00)>>8;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_17_5_range = round(@P_FSG_82_0_0_17_5 + (0), 1.0); // slider value + min = real value
    param5 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_17_6_range = round(@P_FSG_82_0_0_17_6 + (0), 1.0); // slider value + min = real value
    param6 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals
    param7 = getValue(P_FSG_82_0_0_17_7);
    @P_FSG_82_0_0_17_7_1 = (param7 & 2) > 0;
    @P_FSG_82_0_0_17_7_2 = (param7 & 4) > 0;
    @P_FSG_82_0_0_17_7_3 = (param7 & 8) > 0;
    @P_FSG_82_0_0_17_7_4 = (param7 & 16) > 0;
    @P_FSG_82_0_0_17_7_5 = (param7 & 32) > 0;
    @P_FSG_82_0_0_17_7_6 = (param7 & 64) > 0;
    superval[currentPos++]=param7;
    putValue(P_FSG_82_0_0_17, superval, currentPos);
}


on envVar P_FSG_82_0_0_17_1 // PSO_Control.ASG_ID
{
    P_FSG_82_0_0_17_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_17_2_range // PSO_Control.Extension1
{
    @P_FSG_82_0_0_17_2 = @P_FSG_82_0_0_17_2_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_17_2 // PSO_Control.Extension1
{
    P_FSG_82_0_0_17_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_17_3_range // PSO_Control.UserSlot
{
    @P_FSG_82_0_0_17_3 = @P_FSG_82_0_0_17_3_range - (1); // slider = range - min
}

on envVar P_FSG_82_0_0_17_3 // PSO_Control.UserSlot
{
    P_FSG_82_0_0_17_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_17_4_range // PSO_Control.Extension2
{
    @P_FSG_82_0_0_17_4 = @P_FSG_82_0_0_17_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_17_4 // PSO_Control.Extension2
{
    P_FSG_82_0_0_17_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_17_5_range // PSO_Control.Extension3
{
    @P_FSG_82_0_0_17_5 = @P_FSG_82_0_0_17_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_17_5 // PSO_Control.Extension3
{
    P_FSG_82_0_0_17_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_17_6_range // PSO_Control.Extension4
{
    @P_FSG_82_0_0_17_6 = @P_FSG_82_0_0_17_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_17_6 // PSO_Control.Extension4
{
    P_FSG_82_0_0_17_BuildFct();
}

on envVar P_FSG_82_0_0_17_7_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_7);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_17_7,thisval);
}

on envVar P_FSG_82_0_0_17_7_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_7);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_17_7,thisval);
}

on envVar P_FSG_82_0_0_17_7_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_7);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_17_7,thisval);
}

on envVar P_FSG_82_0_0_17_7_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_7);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_17_7,thisval);
}

on envVar P_FSG_82_0_0_17_7_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_7);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_17_7,thisval);
}

on envVar P_FSG_82_0_0_17_7_6
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_7);
    thisval = thisval&~(1<<6)|(bitval<<6);
    putValue(P_FSG_82_0_0_17_7,thisval);
}

on envVar P_FSG_82_0_0_17_7 // PSO_Control.Response
{
    P_FSG_82_0_0_17_BuildFct();
}

on envVar P_FSG_82_0_0_17_Ack // bus value of PSO_Control (17).
{
    // opcodes: Get-SetGet-Ack
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // UserSlot
    word param4; // Extension2
    byte param5; // Extension3
    byte param6; // Extension4
    byte param7; // Response
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[7];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 7; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_17_Ack, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(P_FSG_82_0_0_17_Ack_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(P_FSG_82_0_0_17_Ack_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_17_Ack_3, round((param3 * 1.0) - (1) + (1), 1.0));
    ///////// Start param4 - UINT16 /////////
    param4 = superval[currentPos++]|(superval[currentPos++]<<8);
    putValue(P_FSG_82_0_0_17_Ack_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_17_Ack_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_82_0_0_17_Ack_6, round((param6 * 1.0) - (0) + (0), 1.0));
    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(P_FSG_82_0_0_17_Ack_7, param7);
}

// Updates the bus value field and other dependencies.
P_FSG_82_0_0_17_Ack_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // UserSlot
    word param4; // Extension2
    byte param5; // Extension3
    byte param6; // Extension4
    byte param7; // Response

    dword i;
    byte superval[7];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(P_FSG_82_0_0_17_Ack_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_17_Ack_2_range = round(@P_FSG_82_0_0_17_Ack_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_17_Ack_3_range = round(@P_FSG_82_0_0_17_Ack_3 + (1), 1.0); // slider value + min = real value
    param3 = (@P_FSG_82_0_0_17_Ack_3 + (1) - (1)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_17_Ack_4_range = round(@P_FSG_82_0_0_17_Ack_4 + (0), 1.0); // slider value + min = real value
    param4 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param4&0x00ff;
    superval[currentPos++]=(param4&0xff00)>>8;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_17_Ack_5_range = round(@P_FSG_82_0_0_17_Ack_5 + (0), 1.0); // slider value + min = real value
    param5 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_17_Ack_6_range = round(@P_FSG_82_0_0_17_Ack_6 + (0), 1.0); // slider value + min = real value
    param6 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals
    param7 = getValue(P_FSG_82_0_0_17_Ack_7);
    @P_FSG_82_0_0_17_Ack_7_1 = (param7 & 2) > 0;
    @P_FSG_82_0_0_17_Ack_7_2 = (param7 & 4) > 0;
    @P_FSG_82_0_0_17_Ack_7_3 = (param7 & 8) > 0;
    @P_FSG_82_0_0_17_Ack_7_4 = (param7 & 16) > 0;
    @P_FSG_82_0_0_17_Ack_7_5 = (param7 & 32) > 0;
    @P_FSG_82_0_0_17_Ack_7_6 = (param7 & 64) > 0;
    superval[currentPos++]=param7;
    putValue(P_FSG_82_0_0_17_Ack, superval, currentPos);
}


on envVar P_FSG_82_0_0_17_Ack_1 // PSO_Control.ASG_ID
{
    P_FSG_82_0_0_17_Ack_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_17_Ack_2_range // PSO_Control.Extension1
{
    @P_FSG_82_0_0_17_Ack_2 = @P_FSG_82_0_0_17_Ack_2_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_17_Ack_2 // PSO_Control.Extension1
{
    P_FSG_82_0_0_17_Ack_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_17_Ack_3_range // PSO_Control.UserSlot
{
    @P_FSG_82_0_0_17_Ack_3 = @P_FSG_82_0_0_17_Ack_3_range - (1); // slider = range - min
}

on envVar P_FSG_82_0_0_17_Ack_3 // PSO_Control.UserSlot
{
    P_FSG_82_0_0_17_Ack_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_17_Ack_4_range // PSO_Control.Extension2
{
    @P_FSG_82_0_0_17_Ack_4 = @P_FSG_82_0_0_17_Ack_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_17_Ack_4 // PSO_Control.Extension2
{
    P_FSG_82_0_0_17_Ack_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_17_Ack_5_range // PSO_Control.Extension3
{
    @P_FSG_82_0_0_17_Ack_5 = @P_FSG_82_0_0_17_Ack_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_17_Ack_5 // PSO_Control.Extension3
{
    P_FSG_82_0_0_17_Ack_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_17_Ack_6_range // PSO_Control.Extension4
{
    @P_FSG_82_0_0_17_Ack_6 = @P_FSG_82_0_0_17_Ack_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_17_Ack_6 // PSO_Control.Extension4
{
    P_FSG_82_0_0_17_Ack_BuildFct();
}

on envVar P_FSG_82_0_0_17_Ack_7_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_Ack_7);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_17_Ack_7,thisval);
}

on envVar P_FSG_82_0_0_17_Ack_7_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_Ack_7);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_17_Ack_7,thisval);
}

on envVar P_FSG_82_0_0_17_Ack_7_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_Ack_7);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_17_Ack_7,thisval);
}

on envVar P_FSG_82_0_0_17_Ack_7_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_Ack_7);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_17_Ack_7,thisval);
}

on envVar P_FSG_82_0_0_17_Ack_7_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_Ack_7);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_17_Ack_7,thisval);
}

on envVar P_FSG_82_0_0_17_Ack_7_6
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Response
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_17_Ack_7);
    thisval = thisval&~(1<<6)|(bitval<<6);
    putValue(P_FSG_82_0_0_17_Ack_7,thisval);
}

on envVar P_FSG_82_0_0_17_Ack_7 // PSO_Control.Response
{
    P_FSG_82_0_0_17_Ack_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_18_ErrCode
{
       if(gP_FSG_82_0_0_18_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_18", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_18_ErrCode = 1;
}
on envVar P_FSG_82_0_0_18Status_BTN
{
    byte BAPTemp[6];
   if (P_FSG_82_0_0_18Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_82_0_0_18_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_18",MakeRGB(255,255,255));
      P_FSG_82_0_0_18Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_82_0_0_18, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_82_0_0_18_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_18));
      P_FSG_82_0_0_18Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_82_0_0_18_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_18_ID;
    data[2]=getValue(P_FSG_82_0_0_18_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_18
on envVar P_FSG_82_0_0_18_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_18",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_18",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_18",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_18", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_18",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_18",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_18",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_18", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_82_0_0_18 // bus value of PSO_FSG_Setup (18).
{
    // opcodes: Error-Status
    byte param1; // Installation1
    byte param2; // Extension1
    byte param3; // Extension2
    byte param4; // Extension3
    byte param5; // Extension4
    byte param6; // Extension5
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[6];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 6; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_18, superval);
    ///////// Start param1 - UINT8 /////////
    param1 = superval[currentPos++];
    putValue(P_FSG_82_0_0_18_1, param1);
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_82_0_0_18_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_18_3, round((param3 * 1.0) - (0) + (0), 1.0));
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_82_0_0_18_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_18_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_82_0_0_18_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_82_0_0_18_1_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Installation1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_18_1);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_18_1,thisval);
}

on envVar P_FSG_82_0_0_18_1_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Installation1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_18_1);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_18_1,thisval);
}

on envVar P_FSG_82_0_0_18_1_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Installation1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_18_1);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_18_1,thisval);
}

on envVar P_FSG_82_0_0_18_1 // PSO_FSG_Setup.Installation1
{
    byte superval[6];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // Installation1
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_18_1_0, 1);
    else
        putValue(P_FSG_82_0_0_18_1_0, 0);
    if(thisval&(mask<<1))
        putValue(P_FSG_82_0_0_18_1_1, 1);
    else
        putValue(P_FSG_82_0_0_18_1_1, 0);
    if(thisval&(mask<<2))
        putValue(P_FSG_82_0_0_18_1_2, 1);
    else
        putValue(P_FSG_82_0_0_18_1_2, 0);

    // Update superval
    getValue(P_FSG_82_0_0_18, superval);
    superval[0]=thisval;
    putValue(P_FSG_82_0_0_18,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_18_2_range // PSO_FSG_Setup.Extension1
{
    @P_FSG_82_0_0_18_2 = @P_FSG_82_0_0_18_2_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_18_2 // PSO_FSG_Setup.Extension1
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension1
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_18_2_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_18, superval);
    superval[1]=thisval;
    putValue(P_FSG_82_0_0_18,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_18_3_range // PSO_FSG_Setup.Extension2
{
    @P_FSG_82_0_0_18_3 = @P_FSG_82_0_0_18_3_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_18_3 // PSO_FSG_Setup.Extension2
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension2
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_18_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_18, superval);
    superval[2]=thisval;
    putValue(P_FSG_82_0_0_18,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_18_4_range // PSO_FSG_Setup.Extension3
{
    @P_FSG_82_0_0_18_4 = @P_FSG_82_0_0_18_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_18_4 // PSO_FSG_Setup.Extension3
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension3
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_18_4_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_18, superval);
    superval[3]=thisval;
    putValue(P_FSG_82_0_0_18,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_18_5_range // PSO_FSG_Setup.Extension4
{
    @P_FSG_82_0_0_18_5 = @P_FSG_82_0_0_18_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_18_5 // PSO_FSG_Setup.Extension4
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension4
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_18_5_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_18, superval);
    superval[4]=thisval;
    putValue(P_FSG_82_0_0_18,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_18_6_range // PSO_FSG_Setup.Extension5
{
    @P_FSG_82_0_0_18_6 = @P_FSG_82_0_0_18_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_18_6 // PSO_FSG_Setup.Extension5
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension5
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_18_6_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_18, superval);
    superval[5]=thisval;
    putValue(P_FSG_82_0_0_18,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_19_ErrCode
{
       if(gP_FSG_82_0_0_19_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_19", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_19_ErrCode = 1;
}
on envVar P_FSG_82_0_0_19Status_BTN
{
    byte BAPTemp[76];
    if (P_FSG_82_0_0_19Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_82_0_0_19_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_19",MakeRGB(255,255,255));
        P_FSG_82_0_0_19Status_BTN_already_pressed = 1;
    }
    else
    {
        P_FSG_82_0_0_19_BuildFct();
        getValue(P_FSG_82_0_0_19, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_82_0_0_19_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_19));
        if(getValue(P_FSG_82_0_0_19_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_82_0_0_19_ID);
        }
        if(getValue(P_FSG_82_0_0_19_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_82_0_0_19_ID,elCount(BAPTemp));
        }
       P_FSG_82_0_0_19Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_82_0_0_19_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_19_ID;
    data[2]=getValue(P_FSG_82_0_0_19_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_19
on envVar P_FSG_82_0_0_19_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_19",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_19",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_19",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_19", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_19",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_19",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_19",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_19", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_19_IntTlgEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_19_SegmEn,0);
           intertelegram_err(P_FSG_82_0_0_19_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_82_0_0_19_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_19_SegmEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_19_IntTlgEn,0);
           sequence_err(P_FSG_82_0_0_19_ID,getValueSize(P_FSG_82_0_0_19_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_82_0_0_19_ID);
       }
}
on envVar P_FSG_82_0_0_19 // bus value of IAA_ActiveUserAndProfile (19).
{
    // opcodes: Error-Status
    byte param1; // IAA_Active_UserID
    byte param2; // Active_User_Status
    byte param3; // userChangePhase
    byte param4; // IAA_Identified_UserID
    byte param5; // IAA_Identified_User_POS
    byte param6[67]; // IdentifiedUser_NickName
    word len6;
    byte cnt6;
    byte param7; // Extension1
    byte param8; // Extension2
    byte param9; // Extension3
    byte param10; // Extension4
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[76];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 76; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_19, superval);
    ///////// Start param1 - UINT8 /////////
    param1 = superval[currentPos++];
    putValue(P_FSG_82_0_0_19_1, round((param1 * 1.0) - (0) + (0), 1.0));
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_82_0_0_19_2, param2);
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_19_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_82_0_0_19_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_19_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - STRING /////////
    getValue(P_FSG_82_0_0_19_6, param6);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(66>127) /* Max Fct-Katalog Laenge: 66*/
        {
            len6 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt6 = 1;
        }
        else
        {
            len6 = 66;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_82_0_0_19 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len6 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt6 = 0;
    }

    if(len6 > 66)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len6, currentPos);
        len6 = 66;

        if(len6 < 128) cnt6 = 0;
        else cnt6 = 1;
    }

    for(i = 0; i < len6; i++)
    {
        param6[i] = superval[currentPos++];
    }

    putValue(P_FSG_82_0_0_19_6_len, len6);
    putValue(P_FSG_82_0_0_19_6_cnt, cnt6);

    putValue(P_FSG_82_0_0_19_6, param6, len6);

    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(P_FSG_82_0_0_19_7, round((param7 * 1.0) - (0) + (0), 1.0));
    ///////// Start param8 - UINT8 /////////
    param8 = superval[currentPos++];
    putValue(P_FSG_82_0_0_19_8, round((param8 * 1.0) - (0) + (0), 1.0));
    ///////// Start param9 - UINT8 /////////
    param9 = superval[currentPos++];
    putValue(P_FSG_82_0_0_19_9, round((param9 * 1.0) - (0) + (0), 1.0));
    ///////// Start param10 - UINT8 /////////
    param10 = superval[currentPos++];
    putValue(P_FSG_82_0_0_19_10, round((param10 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_FSG_82_0_0_19_BuildFct()
{
    byte param1; // IAA_Active_UserID
    byte param2; // Active_User_Status
    byte param3; // userChangePhase
    byte param4; // IAA_Identified_UserID
    byte param5; // IAA_Identified_User_POS
    byte param6[67]; // IdentifiedUser_NickName
    word len6;
    byte cnt6;
    byte param7; // Extension1
    byte param8; // Extension2
    byte param9; // Extension3
    byte param10; // Extension4

    dword i;
    byte superval[76];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_19_1_range = round(@P_FSG_82_0_0_19_1 + (0), 1.0); // slider value + min = real value
    param1 = (@P_FSG_82_0_0_19_1 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals
    param2 = getValue(P_FSG_82_0_0_19_2);
    @P_FSG_82_0_0_19_2_0 = (param2 & 1) > 0;
    @P_FSG_82_0_0_19_2_1 = (param2 & 2) > 0;
    @P_FSG_82_0_0_19_2_2 = (param2 & 4) > 0;
    @P_FSG_82_0_0_19_2_3 = (param2 & 8) > 0;
    @P_FSG_82_0_0_19_2_4 = (param2 & 16) > 0;
    @P_FSG_82_0_0_19_2_5 = (param2 & 32) > 0;
    @P_FSG_82_0_0_19_2_6 = (param2 & 64) > 0;
    superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals
    param3 = getValue(P_FSG_82_0_0_19_3);
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_19_4_range = round(@P_FSG_82_0_0_19_4 + (0), 1.0); // slider value + min = real value
    param4 = (@P_FSG_82_0_0_19_4 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_19_5_range = round(@P_FSG_82_0_0_19_5 + (0), 1.0); // slider value + min = real value
    param5 = (@P_FSG_82_0_0_19_5 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals
    getValue(P_FSG_82_0_0_19_6, param6);
    len6 = getValue(P_FSG_82_0_0_19_6_len);
    cnt6= getValue(P_FSG_82_0_0_19_6_cnt);

    /* check box aktiviert*/
    if (cnt6 == 1)
    {
        /* 0 bis 66 (MaxString - 1B oder 2B) */
        if(len6 >= 0 && len6 <= 66)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
            superval[currentPos] = ((len6>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len6 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_19_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 66);
            return;
        }
    }
    else if(cnt6 == 0) /*check box deaktiviert*/
    {
        if(len6 >= 0 && len6 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
            superval[currentPos]= len6 & 0x00ff;
            putValue(P_FSG_82_0_0_19_6_len, len6);
        }
        else if(len6 > 127 && len6 <= 66)
        {
            superval[currentPos] = ((len6>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len6 & 0x00ff;
            putValue(P_FSG_82_0_0_19_6_len, len6);
            putValue(P_FSG_82_0_0_19_6_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_19_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 66);
            return;
        }
    }
    currentPos += cnt6+1;
    for(i = 0; i < len6; i++)
    {
        superval[currentPos++]= param6[i];
    }

// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_19_7_range = round(@P_FSG_82_0_0_19_7 + (0), 1.0); // slider value + min = real value
    param7 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param7;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_19_8_range = round(@P_FSG_82_0_0_19_8 + (0), 1.0); // slider value + min = real value
    param8 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param8;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_19_9_range = round(@P_FSG_82_0_0_19_9 + (0), 1.0); // slider value + min = real value
    param9 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param9;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_19_10_range = round(@P_FSG_82_0_0_19_10 + (0), 1.0); // slider value + min = real value
    param10 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param10;
    putValue(P_FSG_82_0_0_19, superval, currentPos);
}


// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_19_1_range // IAA_ActiveUserAndProfile.IAA_Active_UserID
{
    @P_FSG_82_0_0_19_1 = @P_FSG_82_0_0_19_1_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_19_1 // IAA_ActiveUserAndProfile.IAA_Active_UserID
{
    P_FSG_82_0_0_19_BuildFct();
}

on envVar P_FSG_82_0_0_19_2_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Active_User_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_19_2);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_19_2,thisval);
}

on envVar P_FSG_82_0_0_19_2_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Active_User_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_19_2);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_19_2,thisval);
}

on envVar P_FSG_82_0_0_19_2_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Active_User_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_19_2);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_19_2,thisval);
}

on envVar P_FSG_82_0_0_19_2_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Active_User_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_19_2);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_19_2,thisval);
}

on envVar P_FSG_82_0_0_19_2_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Active_User_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_19_2);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_19_2,thisval);
}

on envVar P_FSG_82_0_0_19_2_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Active_User_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_19_2);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_19_2,thisval);
}

on envVar P_FSG_82_0_0_19_2_6
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // Active_User_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_19_2);
    thisval = thisval&~(1<<6)|(bitval<<6);
    putValue(P_FSG_82_0_0_19_2,thisval);
}

on envVar P_FSG_82_0_0_19_2 // IAA_ActiveUserAndProfile.Active_User_Status
{
    P_FSG_82_0_0_19_BuildFct();
}

on envVar P_FSG_82_0_0_19_3 // IAA_ActiveUserAndProfile.userChangePhase
{
    P_FSG_82_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_19_4_range // IAA_ActiveUserAndProfile.IAA_Identified_UserID
{
    @P_FSG_82_0_0_19_4 = @P_FSG_82_0_0_19_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_19_4 // IAA_ActiveUserAndProfile.IAA_Identified_UserID
{
    P_FSG_82_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_19_5_range // IAA_ActiveUserAndProfile.IAA_Identified_User_POS
{
    @P_FSG_82_0_0_19_5 = @P_FSG_82_0_0_19_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_19_5 // IAA_ActiveUserAndProfile.IAA_Identified_User_POS
{
    P_FSG_82_0_0_19_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_82_0_0_19_6_cnt
{
    word len;
    byte cnt;
    len = getValue(P_FSG_82_0_0_19_6_len);
    cnt = getValue(P_FSG_82_0_0_19_6_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(P_FSG_82_0_0_19_6_len, 127);
        }
    }

    P_FSG_82_0_0_19_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_82_0_0_19_6_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 66)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_19_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 66);
        putValue(this, 66);
    }
    P_FSG_82_0_0_19_BuildFct();
}


on envVar P_FSG_82_0_0_19_6 // IAA_ActiveUserAndProfile.IdentifiedUser_NickName
{
    putValue(P_FSG_82_0_0_19_6_len, getValueSize(this));
    P_FSG_82_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_19_7_range // IAA_ActiveUserAndProfile.Extension1
{
    @P_FSG_82_0_0_19_7 = @P_FSG_82_0_0_19_7_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_19_7 // IAA_ActiveUserAndProfile.Extension1
{
    P_FSG_82_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_19_8_range // IAA_ActiveUserAndProfile.Extension2
{
    @P_FSG_82_0_0_19_8 = @P_FSG_82_0_0_19_8_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_19_8 // IAA_ActiveUserAndProfile.Extension2
{
    P_FSG_82_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_19_9_range // IAA_ActiveUserAndProfile.Extension3
{
    @P_FSG_82_0_0_19_9 = @P_FSG_82_0_0_19_9_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_19_9 // IAA_ActiveUserAndProfile.Extension3
{
    P_FSG_82_0_0_19_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_19_10_range // IAA_ActiveUserAndProfile.Extension4
{
    @P_FSG_82_0_0_19_10 = @P_FSG_82_0_0_19_10_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_19_10 // IAA_ActiveUserAndProfile.Extension4
{
    P_FSG_82_0_0_19_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_82_0_0_20_ErrCode
{
       if(gA_FSG_82_0_0_20_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_A_FSG_82_0_0_20", MakeRGB(255,255,255));
       }
       gA_FSG_82_0_0_20_ErrCode = 1;
}
on envVar A_FSG_82_0_0_20Changed_BTN
{
    byte data[343];
    byte stringValue[343];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_82_0_0_20Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_82_0_0_20_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_82_0_0_20",MakeRGB(255,255,255));
        A_FSG_82_0_0_20Changed_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_82_0_0_20_Changed);
        getValue(A_FSG_82_0_0_20_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_82_0_0_20_Changed_Start);
     elementsVal = getValue(A_FSG_82_0_0_20_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_82_0_0_20_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 20");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_82_0_0_20_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_82_0_0_20_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 20");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_82_0_0_20_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_82_0_0_20_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_82_0_0_20_ID);
       }
       if(getValue(A_FSG_82_0_0_20_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_82_0_0_20_ID,getValueSize(A_FSG_82_0_0_20_Changed));
       }
        A_FSG_82_0_0_20Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_82_0_0_20Status_BTN
{
    byte data[343 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[343];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_82_0_0_20Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_82_0_0_20_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_82_0_0_20",MakeRGB(255,255,255));
        A_FSG_82_0_0_20Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_82_0_0_20_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_82_0_0_20_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_82_0_0_20_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_82_0_0_20);
        getValue(A_FSG_82_0_0_20,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_82_0_0_20_Start);
     elementsVal = getValue(A_FSG_82_0_0_20_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_82_0_0_20_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 20");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable IAA_UserID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) || 4 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Nickname:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_3_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 67-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 67-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_3_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 67-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 67-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FunctionalStatus1:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable FunctionalStatus2:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TokenStatus:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable StorageLocation:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable SPIN_Status:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable PassengerType:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable UserRole:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param10 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Picture_etag:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param11     ) & 0xFF;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param11 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IDP_User_ID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_12_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 25-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_12 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 25-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_12_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 25-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_12 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 25-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param12[j];
        }
       }
      // Check if the current value of RecAdr enables the variable MBB_ID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_13_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 31-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_13 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 31-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_13_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 31-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_13 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 31-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param13[j];
        }
       }
      // Check if the current value of RecAdr enables the variable SlotControllD:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param14 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DateOfLastSync:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_15_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 18-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_15 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 18-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_15_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 18-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_15 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 18-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param15[j];
        }
       }
      // Check if the current value of RecAdr enables the variable DateOfLastUsage:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_16_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 18-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_16 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 18-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_16_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 18-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_16 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 18-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param16[j];
        }
       }
      // Check if the current value of RecAdr enables the variable IDP_User_ID_v2:
      if( 0 || 4 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_17_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 167-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_17 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 167-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_17_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 167-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_17 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 167-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param17[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_82_0_0_20_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_82_0_0_20_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 20");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable IAA_UserID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) || 4 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Nickname:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_3_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 67-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 67-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_3_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 67-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 67-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FunctionalStatus1:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable FunctionalStatus2:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TokenStatus:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable StorageLocation:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable SPIN_Status:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable PassengerType:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable UserRole:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param10 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Picture_etag:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param11     ) & 0xFF;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param11 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IDP_User_ID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_12_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 25-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_12 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 25-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_12_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 25-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_12 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 25-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param12[j];
        }
       }
      // Check if the current value of RecAdr enables the variable MBB_ID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_13_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 31-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_13 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 31-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_13_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 31-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_13 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 31-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param13[j];
        }
       }
      // Check if the current value of RecAdr enables the variable SlotControllD:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param14 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DateOfLastSync:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_15_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 18-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_15 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 18-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_15_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 18-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_15 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 18-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param15[j];
        }
       }
      // Check if the current value of RecAdr enables the variable DateOfLastUsage:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_16_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 18-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_16 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 18-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_16_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 18-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_16 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 18-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param16[j];
        }
       }
      // Check if the current value of RecAdr enables the variable IDP_User_ID_v2:
      if( 0 || 4 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_17_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 167-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_17 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 167-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_17_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 167-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_17 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 167-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param17[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_82_0_0_20, data);
        Request_ByteSequence(LSGID, A_FSG_82_0_0_20_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_82_0_0_20_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_82_0_0_20_ID);
        }
        if(getValue(A_FSG_82_0_0_20_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_82_0_0_20_ID,getValueSize(A_FSG_82_0_0_20));
        }
        A_FSG_82_0_0_20Status_BTN_already_pressed = 0;
    }
}
A_FSG_82_0_0_20_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[343];
    byte stringValue[343];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_82_0_0_20_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_82_0_0_20_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_82_0_0_20_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_82_0_0_20);
        getValue(A_FSG_82_0_0_20,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_82_0_0_20_Start);
     elementsVal = getValue(A_FSG_82_0_0_20_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_82_0_0_20_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 20");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable IAA_UserID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) || 4 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Nickname:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_3_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 67-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 67-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_3_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 67-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 67-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FunctionalStatus1:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable FunctionalStatus2:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TokenStatus:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable StorageLocation:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable SPIN_Status:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable PassengerType:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable UserRole:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param10 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Picture_etag:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param11     ) & 0xFF;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param11 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IDP_User_ID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_12_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 25-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_12 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 25-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_12_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 25-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_12 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 25-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param12[j];
        }
       }
      // Check if the current value of RecAdr enables the variable MBB_ID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_13_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 31-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_13 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 31-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_13_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 31-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_13 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 31-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param13[j];
        }
       }
      // Check if the current value of RecAdr enables the variable SlotControllD:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param14 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DateOfLastSync:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_15_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 18-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_15 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 18-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_15_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 18-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_15 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 18-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param15[j];
        }
       }
      // Check if the current value of RecAdr enables the variable DateOfLastUsage:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_16_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 18-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_16 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 18-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_16_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 18-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_16 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 18-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param16[j];
        }
       }
      // Check if the current value of RecAdr enables the variable IDP_User_ID_v2:
      if( 0 || 4 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_17_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 167-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_17 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 167-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_17_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 167-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_17 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 167-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param17[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_82_0_0_20_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_82_0_0_20_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 20");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable IAA_UserID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) || 4 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Nickname:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_3_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 67-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 67-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_3_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 67-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 67-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable FunctionalStatus1:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param4 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable FunctionalStatus2:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TokenStatus:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable StorageLocation:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable SPIN_Status:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable PassengerType:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable UserRole:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param10 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Picture_etag:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param11     ) & 0xFF;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param11 >> 8) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable IDP_User_ID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_12_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 25-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_12 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 25-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_12_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 25-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_12 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 25-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param12[j];
        }
       }
      // Check if the current value of RecAdr enables the variable MBB_ID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_13_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 31-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_13 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 31-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_13_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 31-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_13 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 31-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param13[j];
        }
       }
      // Check if the current value of RecAdr enables the variable SlotControllD:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) || 2 == getValue( A_FSG_82_0_0_20_RecAdr ) || 3 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_20_ArrayDataList[i].Param14 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable DateOfLastSync:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_15_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 18-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_15 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 18-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_15_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 18-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_15 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 18-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param15[j];
        }
       }
      // Check if the current value of RecAdr enables the variable DateOfLastUsage:
      if( 0 || 1 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_16_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 18-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_16 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 18-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_16_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 18-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_16 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 18-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param16[j];
        }
       }
      // Check if the current value of RecAdr enables the variable IDP_User_ID_v2:
      if( 0 || 4 == getValue( A_FSG_82_0_0_20_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_20_Data_17_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 167-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_17 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 167-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_20_Data_17_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 167-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_17 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 167-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_20_ArrayDataList[i].Param17[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_82_0_0_20_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_82_0_0_20
{
    byte temp[343];
    getValue(A_FSG_82_0_0_20, temp);
    putValue(A_FSG_82_0_0_20_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_82_0_0_20_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_82_0_0_20_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_82_0_0_20_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_82_0_0_20_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_82_0_0_20_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_82_0_0_20_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_82_0_0_20_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_82_0_0_20_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_82_0_0_20_IndexSize))
    {
        putValue(A_FSG_82_0_0_20_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_82_0_0_20_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_82_0_0_20_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_82_0_0_20_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_82_0_0_20_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_82_0_0_20_RecAdr) > 0x0F)
        putValue(A_FSG_82_0_0_20_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_82_0_0_20_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_82_0_0_20_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_82_0_0_20_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_82_0_0_20_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_82_0_0_20_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_82_0_0_20_Start) & 0xFF;
        head[2] = (getValue(A_FSG_82_0_0_20_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_82_0_0_20_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_82_0_0_20_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_82_0_0_20_Start) & 0xFF;
        head[2] = getValue(A_FSG_82_0_0_20_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_82_0_0_20, head, headLength);
}

on envVar A_FSG_82_0_0_20_RecAdr
{
    A_FSG_82_0_0_20_GenerateStatus();
}

on envVar A_FSG_82_0_0_20_Shift
{
    A_FSG_82_0_0_20_GenerateStatus();
}

on envVar A_FSG_82_0_0_20_Direction
{
    A_FSG_82_0_0_20_GenerateStatus();
}

on envVar A_FSG_82_0_0_20_Start
{
    A_FSG_82_0_0_20_GenerateStatus();
}

on envVar A_FSG_82_0_0_20_Elements
{
    A_FSG_82_0_0_20_GenerateStatus();
}

on envVar A_FSG_82_0_0_20_IndexSize
{
    A_FSG_82_0_0_20_GenerateStatus();
}
on envVar A_FSG_82_0_0_20_TransPos
{
    A_FSG_82_0_0_20_GenerateStatus();
}
A_FSG_82_0_0_20_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_82_0_0_20_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_82_0_0_20_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_82_0_0_20_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_82_0_0_20_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_82_0_0_20_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_82_0_0_20_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_82_0_0_20_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_82_0_0_20_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_82_0_0_20_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_82_0_0_20_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_82_0_0_20_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_82_0_0_20_Changed, head, 5);
    }
    else
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_82_0_0_20_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_82_0_0_20_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_82_0_0_20_Changed, head, 3);
    }
}

on envVar A_FSG_82_0_0_20_Changed_RecAdr
{
    A_FSG_82_0_0_20_Changed_GenerateChanged();
}

on envVar A_FSG_82_0_0_20_Changed_Shift
{
    A_FSG_82_0_0_20_Changed_GenerateChanged();
}

on envVar A_FSG_82_0_0_20_Changed_Direction
{
    A_FSG_82_0_0_20_Changed_GenerateChanged();
}

on envVar A_FSG_82_0_0_20_Changed_Start
{
    A_FSG_82_0_0_20_Changed_GenerateChanged();
}

on envVar A_FSG_82_0_0_20_Changed_Elements
{
    A_FSG_82_0_0_20_Changed_GenerateChanged();
}

on envVar A_FSG_82_0_0_20_Changed_IndexSize
{
    A_FSG_82_0_0_20_Changed_GenerateChanged();
}
on envVar A_FSG_82_0_0_20_Changed_TransPos
{
    A_FSG_82_0_0_20_Changed_GenerateChanged();
}
on envVar A_FSG_82_0_0_20_SetGet
{
    byte temp[343];
    getValue(A_FSG_82_0_0_20_SetGet, temp);
    putValue(A_FSG_82_0_0_20_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_82_0_0_20_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_82_0_0_20_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_82_0_0_20_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_82_0_0_20_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_82_0_0_20_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_82_0_0_20_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_82_0_0_20_SetGet_IndexSize))
    {
        putValue(A_FSG_82_0_0_20_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_82_0_0_20_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_82_0_0_20_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_82_0_0_20_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_82_0_0_20_LoadArray()
{
    /********* Statische Deklarationen ***********/
    dword CSVfileHandle;
    dword filePos;
    dword paramPos;
    dword Num_of_csv_byte;
    dword element;
    dword current_CSV_line;
    byte buffer_byte[0xFFFF];
    dword i;
    dword j;
    char CSV_filename[255];
    char CSV_path[255];
    char CSV_file[255];

    /********* Param Puffer Deklarationen ***********/
    char temp1[25];
    char temp2[25];
    char temp4[25];
    char temp5[25];
    char temp6[25];
    char temp7[25];
    char temp8[25];
    char temp9[25];
    char temp10[25];
    char temp11[25];
    char temp14[25];

    /********* Initialisierungen ***********/
    CSVfileHandle = 0;
    filePos = 0;
    paramPos = 0;
    Num_of_csv_byte = 0;
    element = 1;
    current_CSV_line = 0;
    for(i = 0; i < A_FSG_82_0_0_20_ArrayDataList_Length; i++)
    { /* Initialisierung von den Ziel-Strukturen */
        A_FSG_82_0_0_20_ArrayDataList[i].Param1 = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param2 = 0;
        for(j=0; j<67; j++)
            A_FSG_82_0_0_20_ArrayDataList[i].Param3[j] = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length = 0;
        A_FSG_82_0_0_20_Data_3_LenList[i] = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param4 = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param5 = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param6 = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param7 = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param8 = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param9 = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param10 = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param11 = 0;
        for(j=0; j<25; j++)
            A_FSG_82_0_0_20_ArrayDataList[i].Param12[j] = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length = 0;
        A_FSG_82_0_0_20_Data_12_LenList[i] = 0;
        for(j=0; j<31; j++)
            A_FSG_82_0_0_20_ArrayDataList[i].Param13[j] = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length = 0;
        A_FSG_82_0_0_20_Data_13_LenList[i] = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param14 = 0;
        for(j=0; j<18; j++)
            A_FSG_82_0_0_20_ArrayDataList[i].Param15[j] = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length = 0;
        A_FSG_82_0_0_20_Data_15_LenList[i] = 0;
        for(j=0; j<18; j++)
            A_FSG_82_0_0_20_ArrayDataList[i].Param16[j] = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length = 0;
        A_FSG_82_0_0_20_Data_16_LenList[i] = 0;
        for(j=0; j<167; j++)
            A_FSG_82_0_0_20_ArrayDataList[i].Param17[j] = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length = 0;
        A_FSG_82_0_0_20_Data_17_LenList[i] = 0;
    }

    /********* Laden der CSV-Datei ***********/
    getValue(A_FSG_82_0_0_20_fileSelector, CSV_filename);
    SplitFullFileName(CSV_filename, CSV_path, CSV_file );
    setFilePath(CSV_path, 0);
    CSVfileHandle = openFileRead(CSV_file, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

    if (CSVfileHandle!=0) //*.csv file access successful
    {
        writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
        //get data from *.csv and store the total number of byte in *.csv-file
        Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

        for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
        {
            if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
            {
                //nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
                {
                    if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
                    {
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //IAA_UserID
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //FunctionalStatus1
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //FunctionalStatus2
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //TokenStatus
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param7 = atol(temp7); //StorageLocation
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param8 = atol(temp8); //SPIN_Status
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param9 = atol(temp9); //PassengerType
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param10 = atol(temp10); //UserRole
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param11 = atol(temp11); //Picture_etag
                        A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param14 = atol(temp14); //SlotControllD
                        for(i = 0; i < 25; i++)
                        { /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
                            temp1[i]=0;
                            temp2[i]=0;
                            temp4[i]=0;
                            temp5[i]=0;
                            temp6[i]=0;
                            temp7[i]=0;
                            temp8[i]=0;
                            temp9[i]=0;
                            temp10[i]=0;
                            temp11[i]=0;
                            temp14[i]=0;
                        }
                    }
                    current_CSV_line++; //next line in *.csv file
                    element = 1; //start at 'POS' (first record element of "array data")
                    paramPos = 0; //reset value
                }
                 //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                else if(current_CSV_line > 0 && current_CSV_line < 256)
                {
                    //writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
                    switch (element)
                    {
                        case 1: //Pos
                                if( paramPos >= elCount(temp1) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp1[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 2: //IAA_UserID
                                if( paramPos >= elCount(temp2) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp2[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 3: //Nickname
                                if(paramPos < 66)
                                {
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param3_Length = paramPos +1;
                                }
                                paramPos++;
                        break;
                        case 4: //FunctionalStatus1
                                if( paramPos >= elCount(temp4) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp4[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 5: //FunctionalStatus2
                                if( paramPos >= elCount(temp5) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp5[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 6: //TokenStatus
                                if( paramPos >= elCount(temp6) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp6[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 7: //StorageLocation
                                if( paramPos >= elCount(temp7) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp7[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 8: //SPIN_Status
                                if( paramPos >= elCount(temp8) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp8[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 9: //PassengerType
                                if( paramPos >= elCount(temp9) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp9[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 10: //UserRole
                                if( paramPos >= elCount(temp10) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp10[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 11: //Picture_etag
                                if( paramPos >= elCount(temp11) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp11[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 12: //IDP_User_ID
                                if(paramPos < 24)
                                {
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param12[paramPos] = buffer_byte[filePos];
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param12_Length = paramPos +1;
                                }
                                paramPos++;
                        break;
                        case 13: //MBB_ID
                                if(paramPos < 30)
                                {
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param13[paramPos] = buffer_byte[filePos];
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param13_Length = paramPos +1;
                                }
                                paramPos++;
                        break;
                        case 14: //SlotControllD
                                if( paramPos >= elCount(temp14) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp14[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 15: //DateOfLastSync
                                if(paramPos < 17)
                                {
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param15[paramPos] = buffer_byte[filePos];
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param15_Length = paramPos +1;
                                }
                                paramPos++;
                        break;
                        case 16: //DateOfLastUsage
                                if(paramPos < 17)
                                {
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param16[paramPos] = buffer_byte[filePos];
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param16_Length = paramPos +1;
                                }
                                paramPos++;
                        break;
                        case 17: //IDP_User_ID_v2
                                if(paramPos < 165)
                                {
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param17[paramPos] = buffer_byte[filePos];
                                    A_FSG_82_0_0_20_ArrayDataList[current_CSV_line-1].Param17_Length = paramPos +1;
                                }
                                paramPos++;
                        break;
                        default:
                        break;
                    }
                }
            }
            else  // ";" is detected ->next record element of "array data"
            {
                //writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
                element++;
                paramPos=0; //reset value
            }
        }

        if(fileClose (CSVfileHandle) !=0) //close *.csv file
            writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
        else
            writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
        writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
    }
}

on envVar A_FSG_82_0_0_20_loadArray_Btn
{
    char filePath[255];
    if (A_FSG_82_0_0_20_generateData_Btn_already_pressed == 0)
    {
        A_FSG_82_0_0_20_generateData_Btn_already_pressed = 1;
    }
    else
    {
        A_FSG_82_0_0_20_generateData_Btn_already_pressed = 0;
        getValue(A_FSG_82_0_0_20_fileSelector, filePath);
        if(0 == strlen(filePath))
        {
            writelineEx(gBAP_Trace, 0, "Invalid file path!");
        }
        else
        {
            A_FSG_82_0_0_20_LoadArray();
            writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
        }
        putValue(A_FSG_82_0_0_20_Data_1, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param1);
    putValue(A_FSG_82_0_0_20_Data_2, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param2);
    putValue(A_FSG_82_0_0_20_Data_3, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param3, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param3_Length);
    putValue(A_FSG_82_0_0_20_Data_4, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param4);
    putValue(A_FSG_82_0_0_20_Data_5, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param5);
    putValue(A_FSG_82_0_0_20_Data_6, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param6);
    putValue(A_FSG_82_0_0_20_Data_7, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param7);
    putValue(A_FSG_82_0_0_20_Data_8, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param8);
    putValue(A_FSG_82_0_0_20_Data_9, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param9);
    putValue(A_FSG_82_0_0_20_Data_10, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param10);
    putValue(A_FSG_82_0_0_20_Data_11, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param11);
    putValue(A_FSG_82_0_0_20_Data_12, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param12, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param12_Length);
    putValue(A_FSG_82_0_0_20_Data_13, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param13, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param13_Length);
    putValue(A_FSG_82_0_0_20_Data_14, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param14);
    putValue(A_FSG_82_0_0_20_Data_15, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param15, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param15_Length);
    putValue(A_FSG_82_0_0_20_Data_16, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param16, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param16_Length);
    putValue(A_FSG_82_0_0_20_Data_17, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param17, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param17_Length);
    }
}


on envVar A_FSG_82_0_0_20_generateData_Btn
{
    word i;
    dword elementsArray[23] = {1, 1, 67, 2, 1, 1, 1, 1, 1, 1, 1, 2, 25, 2, 31, 2, 1, 18, 2, 18, 2, 167, 2};
    byte elementsTypeArray[23] = {0, 0, 0xE, 0xF, 0, 0, 0, 0, 0, 0, 0, 0, 0xE, 0xF, 0xE, 0xF, 0, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF};
    dword elementsMaxSizeArray[23] = {255, 255, 0, 0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 65535, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0};
    byte tempArray[89250];
    if (A_FSG_82_0_0_20_generateData_Btn_already_pressed == 0)
    {
        A_FSG_82_0_0_20_generateData_Btn_already_pressed = 1;
    }
    else
    {
        initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 20, 255 );
        for(i = 0; i < 255; i++)
        {
            memcpy(A_FSG_82_0_0_20_ArrayDataList[i], tempArray, (i * 350) );
            if(A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length > 127 )
                A_FSG_82_0_0_20_Data_3_CntList[i] = 1;
            if(A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length > 127 )
                A_FSG_82_0_0_20_Data_12_CntList[i] = 1;
            if(A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length > 127 )
                A_FSG_82_0_0_20_Data_13_CntList[i] = 1;
            if(A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length > 127 )
                A_FSG_82_0_0_20_Data_15_CntList[i] = 1;
            if(A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length > 127 )
                A_FSG_82_0_0_20_Data_16_CntList[i] = 1;
            if(A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length > 127 )
                A_FSG_82_0_0_20_Data_17_CntList[i] = 1;
        }
        A_FSG_82_0_0_20_generateData_Btn_already_pressed = 0;
    putValue(A_FSG_82_0_0_20_Data_1, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param1);
    putValue(A_FSG_82_0_0_20_Data_2, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param2);
    putValue(A_FSG_82_0_0_20_Data_3, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param3, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param3_Length);
    putValue(A_FSG_82_0_0_20_Data_4, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param4);
    putValue(A_FSG_82_0_0_20_Data_5, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param5);
    putValue(A_FSG_82_0_0_20_Data_6, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param6);
    putValue(A_FSG_82_0_0_20_Data_7, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param7);
    putValue(A_FSG_82_0_0_20_Data_8, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param8);
    putValue(A_FSG_82_0_0_20_Data_9, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param9);
    putValue(A_FSG_82_0_0_20_Data_10, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param10);
    putValue(A_FSG_82_0_0_20_Data_11, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param11);
    putValue(A_FSG_82_0_0_20_Data_12, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param12, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param12_Length);
    putValue(A_FSG_82_0_0_20_Data_13, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param13, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param13_Length);
    putValue(A_FSG_82_0_0_20_Data_14, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param14);
    putValue(A_FSG_82_0_0_20_Data_15, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param15, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param15_Length);
    putValue(A_FSG_82_0_0_20_Data_16, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param16, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param16_Length);
    putValue(A_FSG_82_0_0_20_Data_17, A_FSG_82_0_0_20_ArrayDataList[ getValue( A_FSG_82_0_0_20_DataIndex) ].Param17, A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param17_Length);
    }
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_82_0_0_20_DataIndex
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_82_0_0_20_Data_1, A_FSG_82_0_0_20_ArrayDataList[index].Param1*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_2, A_FSG_82_0_0_20_ArrayDataList[index].Param2*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_3_len, A_FSG_82_0_0_20_Data_3_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_3_cnt, A_FSG_82_0_0_20_Data_3_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_3, A_FSG_82_0_0_20_ArrayDataList[index].Param3, A_FSG_82_0_0_20_ArrayDataList[index].Param3_Length);
    putValue(A_FSG_82_0_0_20_Data_4, A_FSG_82_0_0_20_ArrayDataList[index].Param4);
    putValue(A_FSG_82_0_0_20_Data_5, A_FSG_82_0_0_20_ArrayDataList[index].Param5);
    putValue(A_FSG_82_0_0_20_Data_6, A_FSG_82_0_0_20_ArrayDataList[index].Param6);
    putValue(A_FSG_82_0_0_20_Data_7, A_FSG_82_0_0_20_ArrayDataList[index].Param7);
    putValue(A_FSG_82_0_0_20_Data_8, A_FSG_82_0_0_20_ArrayDataList[index].Param8);
    putValue(A_FSG_82_0_0_20_Data_9, A_FSG_82_0_0_20_ArrayDataList[index].Param9);
    putValue(A_FSG_82_0_0_20_Data_10, A_FSG_82_0_0_20_ArrayDataList[index].Param10);
    putValue(A_FSG_82_0_0_20_Data_11, A_FSG_82_0_0_20_ArrayDataList[index].Param11*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_12_len, A_FSG_82_0_0_20_Data_12_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_12_cnt, A_FSG_82_0_0_20_Data_12_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_12, A_FSG_82_0_0_20_ArrayDataList[index].Param12, A_FSG_82_0_0_20_ArrayDataList[index].Param12_Length);
    putValue(A_FSG_82_0_0_20_Data_13_len, A_FSG_82_0_0_20_Data_13_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_13_cnt, A_FSG_82_0_0_20_Data_13_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_13, A_FSG_82_0_0_20_ArrayDataList[index].Param13, A_FSG_82_0_0_20_ArrayDataList[index].Param13_Length);
    putValue(A_FSG_82_0_0_20_Data_14, A_FSG_82_0_0_20_ArrayDataList[index].Param14*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_15_len, A_FSG_82_0_0_20_Data_15_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_15_cnt, A_FSG_82_0_0_20_Data_15_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_15, A_FSG_82_0_0_20_ArrayDataList[index].Param15, A_FSG_82_0_0_20_ArrayDataList[index].Param15_Length);
    putValue(A_FSG_82_0_0_20_Data_16_len, A_FSG_82_0_0_20_Data_16_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_16_cnt, A_FSG_82_0_0_20_Data_16_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_16, A_FSG_82_0_0_20_ArrayDataList[index].Param16, A_FSG_82_0_0_20_ArrayDataList[index].Param16_Length);
    putValue(A_FSG_82_0_0_20_Data_17_len, A_FSG_82_0_0_20_Data_17_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_17_cnt, A_FSG_82_0_0_20_Data_17_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_17, A_FSG_82_0_0_20_ArrayDataList[index].Param17, A_FSG_82_0_0_20_ArrayDataList[index].Param17_Length);

}
on envVar A_FSG_82_0_0_20_DataIndex_Incr
{
    long index;
    if(A_FSG_82_0_0_20_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_82_0_0_20_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_82_0_0_20_DataIndex);
        index++;
        putValue(A_FSG_82_0_0_20_DataIndex, index);
        A_FSG_82_0_0_20_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_82_0_0_20_DataIndex_Decr
{
    long index;
    if(A_FSG_82_0_0_20_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_82_0_0_20_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_82_0_0_20_DataIndex);
        index--;
        putValue(A_FSG_82_0_0_20_DataIndex, index);
        A_FSG_82_0_0_20_DataIndex_Decr_already_pressed = 0;
    }
}
// HME generateCaplOnEnv (3160)
on envVar A_FSG_82_0_0_20_DataIndex_SetGet
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_82_0_0_20_Data_1_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param1*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_2_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param2*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_3_SetGet_len, A_FSG_82_0_0_20_Data_3_SetGet_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_3_SetGet_cnt, A_FSG_82_0_0_20_Data_3_SetGet_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_3_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param3, A_FSG_82_0_0_20_ArrayDataList[index].Param3_Length);
    putValue(A_FSG_82_0_0_20_Data_4_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param4);
    putValue(A_FSG_82_0_0_20_Data_5_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param5);
    putValue(A_FSG_82_0_0_20_Data_6_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param6);
    putValue(A_FSG_82_0_0_20_Data_7_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param7);
    putValue(A_FSG_82_0_0_20_Data_8_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param8);
    putValue(A_FSG_82_0_0_20_Data_9_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param9);
    putValue(A_FSG_82_0_0_20_Data_10_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param10);
    putValue(A_FSG_82_0_0_20_Data_11_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param11*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_12_SetGet_len, A_FSG_82_0_0_20_Data_12_SetGet_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_12_SetGet_cnt, A_FSG_82_0_0_20_Data_12_SetGet_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_12_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param12, A_FSG_82_0_0_20_ArrayDataList[index].Param12_Length);
    putValue(A_FSG_82_0_0_20_Data_13_SetGet_len, A_FSG_82_0_0_20_Data_13_SetGet_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_13_SetGet_cnt, A_FSG_82_0_0_20_Data_13_SetGet_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_13_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param13, A_FSG_82_0_0_20_ArrayDataList[index].Param13_Length);
    putValue(A_FSG_82_0_0_20_Data_14_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param14*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_15_SetGet_len, A_FSG_82_0_0_20_Data_15_SetGet_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_15_SetGet_cnt, A_FSG_82_0_0_20_Data_15_SetGet_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_15_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param15, A_FSG_82_0_0_20_ArrayDataList[index].Param15_Length);
    putValue(A_FSG_82_0_0_20_Data_16_SetGet_len, A_FSG_82_0_0_20_Data_16_SetGet_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_16_SetGet_cnt, A_FSG_82_0_0_20_Data_16_SetGet_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_16_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param16, A_FSG_82_0_0_20_ArrayDataList[index].Param16_Length);
    putValue(A_FSG_82_0_0_20_Data_17_SetGet_len, A_FSG_82_0_0_20_Data_17_SetGet_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_17_SetGet_cnt, A_FSG_82_0_0_20_Data_17_SetGet_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_17_SetGet, A_FSG_82_0_0_20_ArrayDataList[index].Param17, A_FSG_82_0_0_20_ArrayDataList[index].Param17_Length);

}
on envVar A_FSG_82_0_0_20_DataIndex_SetGet_Incr
{
    long index;
    if(A_FSG_82_0_0_20_DataIndex_SetGet_Incr_already_pressed == 0)
    {
        A_FSG_82_0_0_20_DataIndex_SetGet_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_82_0_0_20_DataIndex_SetGet);
        index++;
        putValue(A_FSG_82_0_0_20_DataIndex_SetGet, index);
        A_FSG_82_0_0_20_DataIndex_SetGet_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_82_0_0_20_DataIndex_SetGet_Decr
{
    long index;
    if(A_FSG_82_0_0_20_DataIndex_SetGet_Decr_already_pressed == 0)
    {
        A_FSG_82_0_0_20_DataIndex_SetGet_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_82_0_0_20_DataIndex_SetGet);
        index--;
        putValue(A_FSG_82_0_0_20_DataIndex_SetGet, index);
        A_FSG_82_0_0_20_DataIndex_SetGet_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_82_0_0_20_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_82_0_0_20_ID;
    data[2]=getValue(A_FSG_82_0_0_20_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_82_0_0_20
on envVar A_FSG_82_0_0_20_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_20",1);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_82_0_0_20",1);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_20",1);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_20_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_82_0_0_20", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_20",0);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_82_0_0_20",0);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_20",0);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_20_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_82_0_0_20", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_82_0_0_20_IntTlgEn
{
       if(getValue(this))
       {
           putValue(A_FSG_82_0_0_20_SegmEn,0);
           intertelegram_err(A_FSG_82_0_0_20_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_82_0_0_20_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_82_0_0_20_SegmEn
{
       if(getValue(this))
       {
           putValue(A_FSG_82_0_0_20_IntTlgEn,0);
           sequence_err(A_FSG_82_0_0_20_ID,getValueSize(A_FSG_82_0_0_20_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_82_0_0_20_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_82_0_0_20_AT
{
    if(getValue(this))
    {
        EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Status",0);
    }
    else
    {
       EnableControl(panel_name,"panel_A_FSG_82_0_0_20_Status",1);
     }
}



A_FSG_82_0_0_20_SetInd () { /* leere Function*/ }

A_FSG_82_0_0_20_SetGetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[343];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_82_0_0_20_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_82_0_0_20_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_82_0_0_20_SetGet, head, 5);
                if(getValue(A_FSG_82_0_0_20_AT))
                {
                    putValue(A_FSG_82_0_0_20,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_82_0_0_20_SetGet, head, 3);
            if(getValue(A_FSG_82_0_0_20_AT))
            {
                putValue(A_FSG_82_0_0_20,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_82_0_0_20_AT))
        {
            putValue(A_FSG_82_0_0_20_RecAdr,recordAddressVal);
            putValue(A_FSG_82_0_0_20_Start, startVal);
            putValue(A_FSG_82_0_0_20_Elements, elementsVal);
            putValue(A_FSG_82_0_0_20_TransPos, transmitPosVal);
        }
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_FSG_82_0_0_20_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 20");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_82_0_0_20_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_82_0_0_20_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_3_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_3_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param3[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param11 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_12_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_12_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param12[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_13_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_13_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param13[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param14 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_15_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_15_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param15[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_16_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_16_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param16[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 4 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_17_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_17_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param17[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_FSG_82_0_0_20_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_FSG_82_0_0_20_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 20");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_82_0_0_20_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_82_0_0_20_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_3_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_3_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param3_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param3[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param11 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_12_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_12_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param12_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param12[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_13_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_13_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param13_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param13[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_82_0_0_20_ArrayDataList[i].Param14 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_15_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_15_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param15_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param15[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_16_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_16_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param16_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param16[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 4 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
             A_FSG_82_0_0_20_Data_17_SetGet_CntList[i] = 1;
            A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
             A_FSG_82_0_0_20_Data_17_SetGet_CntList[i] = 0;
            A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_82_0_0_20_ArrayDataList[i].Param17_Length; j++)
        {
            A_FSG_82_0_0_20_ArrayDataList[i].Param17[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_FSG_82_0_0_20_DataIndex);
    putValue(A_FSG_82_0_0_20_Data_1, A_FSG_82_0_0_20_ArrayDataList[index].Param1*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_2, A_FSG_82_0_0_20_ArrayDataList[index].Param2*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_3_len, A_FSG_82_0_0_20_Data_3_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_3_cnt, A_FSG_82_0_0_20_Data_3_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_3, A_FSG_82_0_0_20_ArrayDataList[index].Param3, A_FSG_82_0_0_20_ArrayDataList[index].Param3_Length);
    putValue(A_FSG_82_0_0_20_Data_4, A_FSG_82_0_0_20_ArrayDataList[index].Param4);
    putValue(A_FSG_82_0_0_20_Data_5, A_FSG_82_0_0_20_ArrayDataList[index].Param5);
    putValue(A_FSG_82_0_0_20_Data_6, A_FSG_82_0_0_20_ArrayDataList[index].Param6);
    putValue(A_FSG_82_0_0_20_Data_7, A_FSG_82_0_0_20_ArrayDataList[index].Param7);
    putValue(A_FSG_82_0_0_20_Data_8, A_FSG_82_0_0_20_ArrayDataList[index].Param8);
    putValue(A_FSG_82_0_0_20_Data_9, A_FSG_82_0_0_20_ArrayDataList[index].Param9);
    putValue(A_FSG_82_0_0_20_Data_10, A_FSG_82_0_0_20_ArrayDataList[index].Param10);
    putValue(A_FSG_82_0_0_20_Data_11, A_FSG_82_0_0_20_ArrayDataList[index].Param11*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_12_len, A_FSG_82_0_0_20_Data_12_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_12_cnt, A_FSG_82_0_0_20_Data_12_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_12, A_FSG_82_0_0_20_ArrayDataList[index].Param12, A_FSG_82_0_0_20_ArrayDataList[index].Param12_Length);
    putValue(A_FSG_82_0_0_20_Data_13_len, A_FSG_82_0_0_20_Data_13_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_13_cnt, A_FSG_82_0_0_20_Data_13_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_13, A_FSG_82_0_0_20_ArrayDataList[index].Param13, A_FSG_82_0_0_20_ArrayDataList[index].Param13_Length);
    putValue(A_FSG_82_0_0_20_Data_14, A_FSG_82_0_0_20_ArrayDataList[index].Param14*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_20_Data_15_len, A_FSG_82_0_0_20_Data_15_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_15_cnt, A_FSG_82_0_0_20_Data_15_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_15, A_FSG_82_0_0_20_ArrayDataList[index].Param15, A_FSG_82_0_0_20_ArrayDataList[index].Param15_Length);
    putValue(A_FSG_82_0_0_20_Data_16_len, A_FSG_82_0_0_20_Data_16_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_16_cnt, A_FSG_82_0_0_20_Data_16_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_16, A_FSG_82_0_0_20_ArrayDataList[index].Param16, A_FSG_82_0_0_20_ArrayDataList[index].Param16_Length);
    putValue(A_FSG_82_0_0_20_Data_17_len, A_FSG_82_0_0_20_Data_17_LenList[index]);
    putValue(A_FSG_82_0_0_20_Data_17_cnt, A_FSG_82_0_0_20_Data_17_CntList[index]);
    putValue(A_FSG_82_0_0_20_Data_17, A_FSG_82_0_0_20_ArrayDataList[index].Param17, A_FSG_82_0_0_20_ArrayDataList[index].Param17_Length);
}

A_FSG_82_0_0_20_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[343];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_82_0_0_20_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_82_0_0_20_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_82_0_0_20_SetGet, head, 5);
                if(getValue(A_FSG_82_0_0_20_AT))
                {
                    putValue(A_FSG_82_0_0_20,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_82_0_0_20_SetGet, head, 3);
            if(getValue(A_FSG_82_0_0_20_AT))
            {
                putValue(A_FSG_82_0_0_20,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_82_0_0_20_AT))
        {
            putValue(A_FSG_82_0_0_20_RecAdr,recordAddressVal);
            putValue(A_FSG_82_0_0_20_Start, startVal);
            putValue(A_FSG_82_0_0_20_Elements, elementsVal);
            putValue(A_FSG_82_0_0_20_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_82_0_0_20_1
{

    //Update Childvalue (Enum)
    byte thisval; // ASG_ID
    thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_2_range // IAA_VehicleUserList.TAID
{
    @A_FSG_82_0_0_20_2 = @A_FSG_82_0_0_20_2_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_2
{

    //Update Childvalue (Number)
    byte thisval; // TAID
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_2, 1.0);
    @A_FSG_82_0_0_20_2_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_3_range // IAA_VehicleUserList.TotalNumListElements
{
    @A_FSG_82_0_0_20_3 = @A_FSG_82_0_0_20_3_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_3
{

    //Update Childvalue (Number)
    byte thisval; // TotalNumListElements
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_3, 1.0);
    @A_FSG_82_0_0_20_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_Data_1_range // IAA_VehicleUserList.Pos
{
    @A_FSG_82_0_0_20_Data_1 = @A_FSG_82_0_0_20_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_Data_1
{

    //Update Childvalue (Number)
    byte thisval; // Pos
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_Data_1, 1.0);
    @A_FSG_82_0_0_20_Data_1_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param1 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_Data_2_range // IAA_VehicleUserList.IAA_UserID
{
    @A_FSG_82_0_0_20_Data_2 = @A_FSG_82_0_0_20_Data_2_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_Data_2
{

    //Update Childvalue (Number)
    byte thisval; // IAA_UserID
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_Data_2, 1.0);
    @A_FSG_82_0_0_20_Data_2_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param2 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_3_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_3_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_3_CntList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_3_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_3_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_3_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 66 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 66);
        thisval = 66;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_3_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param3_Length = thisval;
    A_FSG_82_0_0_20_Data_3_LenList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_3_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_3
{

    //Update Childvalue (String)
    word i;
    byte thisval[67];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param3[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param3_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_3_LenList[getValue(A_FSG_82_0_0_20_DataIndex)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_3_len, getValueSize(this));
}
on envVar A_FSG_82_0_0_20_Data_4_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(A_FSG_82_0_0_20_Data_4,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(A_FSG_82_0_0_20_Data_4,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(A_FSG_82_0_0_20_Data_4,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(A_FSG_82_0_0_20_Data_4,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(A_FSG_82_0_0_20_Data_4,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_6
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4);
    thisval = thisval&~(1<<6)|(bitval<<6);
    putValue(A_FSG_82_0_0_20_Data_4,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_7
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4);
    thisval = thisval&~(1<<7)|(bitval<<7);
    putValue(A_FSG_82_0_0_20_Data_4,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4
{

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // FunctionalStatus1
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(A_FSG_82_0_0_20_Data_4_0, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_0, 0);
    if(thisval&(mask<<1))
        putValue(A_FSG_82_0_0_20_Data_4_1, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_1, 0);
    if(thisval&(mask<<3))
        putValue(A_FSG_82_0_0_20_Data_4_3, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_3, 0);
    if(thisval&(mask<<4))
        putValue(A_FSG_82_0_0_20_Data_4_4, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_4, 0);
    if(thisval&(mask<<5))
        putValue(A_FSG_82_0_0_20_Data_4_5, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_5, 0);
    if(thisval&(mask<<6))
        putValue(A_FSG_82_0_0_20_Data_4_6, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_6, 0);
    if(thisval&(mask<<7))
        putValue(A_FSG_82_0_0_20_Data_4_7, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_7, 0);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param4 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_5_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus2
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_5);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(A_FSG_82_0_0_20_Data_5,thisval);
}

on envVar A_FSG_82_0_0_20_Data_5
{

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // FunctionalStatus2
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(A_FSG_82_0_0_20_Data_5_0, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_5_0, 0);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param5 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_6_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // TokenStatus
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_6);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(A_FSG_82_0_0_20_Data_6,thisval);
}

on envVar A_FSG_82_0_0_20_Data_6_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // TokenStatus
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_6);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(A_FSG_82_0_0_20_Data_6,thisval);
}

on envVar A_FSG_82_0_0_20_Data_6
{

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // TokenStatus
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(A_FSG_82_0_0_20_Data_6_0, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_6_0, 0);
    if(thisval&(mask<<1))
        putValue(A_FSG_82_0_0_20_Data_6_1, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_6_1, 0);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param6 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_7_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // StorageLocation
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_7);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(A_FSG_82_0_0_20_Data_7,thisval);
}

on envVar A_FSG_82_0_0_20_Data_7
{

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // StorageLocation
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(A_FSG_82_0_0_20_Data_7_0, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_7_0, 0);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param7 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_8
{

    //Update Childvalue (Enum)
    byte thisval; // SPIN_Status
    thisval = getValue(this);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param8 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_9
{

    //Update Childvalue (Enum)
    byte thisval; // PassengerType
    thisval = getValue(this);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param9 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_10
{

    //Update Childvalue (Enum)
    byte thisval; // UserRole
    thisval = getValue(this);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param10 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_Data_11_range // IAA_VehicleUserList.Picture_etag
{
    @A_FSG_82_0_0_20_Data_11 = @A_FSG_82_0_0_20_Data_11_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_Data_11
{

    //Update Childvalue (Number)
    word thisval; // Picture_etag
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_Data_11, 1.0);
    @A_FSG_82_0_0_20_Data_11_range = slider_value + (0); // real value := slider value + range min.
    thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param11 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_12_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_12_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_12_CntList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_12_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_12_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_12_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 24 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_12 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 24);
        thisval = 24;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_12_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param12_Length = thisval;
    A_FSG_82_0_0_20_Data_12_LenList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_12_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_12
{

    //Update Childvalue (String)
    word i;
    byte thisval[25];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param12[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param12_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_12_LenList[getValue(A_FSG_82_0_0_20_DataIndex)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_12_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_13_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_13_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_13_CntList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_13_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_13_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_13_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 30 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_13 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 30);
        thisval = 30;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_13_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param13_Length = thisval;
    A_FSG_82_0_0_20_Data_13_LenList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_13_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_13
{

    //Update Childvalue (String)
    word i;
    byte thisval[31];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param13[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param13_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_13_LenList[getValue(A_FSG_82_0_0_20_DataIndex)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_13_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_Data_14_range // IAA_VehicleUserList.SlotControllD
{
    @A_FSG_82_0_0_20_Data_14 = @A_FSG_82_0_0_20_Data_14_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_Data_14
{

    //Update Childvalue (Number)
    byte thisval; // SlotControllD
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_Data_14, 1.0);
    @A_FSG_82_0_0_20_Data_14_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param14 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_15_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_15_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_15_CntList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_15_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_15_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_15_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 17 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_15 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 17);
        thisval = 17;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_15_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param15_Length = thisval;
    A_FSG_82_0_0_20_Data_15_LenList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_15_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_15
{

    //Update Childvalue (String)
    word i;
    byte thisval[18];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param15[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param15_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_15_LenList[getValue(A_FSG_82_0_0_20_DataIndex)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_15_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_16_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_16_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_16_CntList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_16_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_16_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_16_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 17 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_16 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 17);
        thisval = 17;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_16_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param16_Length = thisval;
    A_FSG_82_0_0_20_Data_16_LenList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_16_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_16
{

    //Update Childvalue (String)
    word i;
    byte thisval[18];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param16[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param16_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_16_LenList[getValue(A_FSG_82_0_0_20_DataIndex)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_16_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_17_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_17_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_17_CntList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_17_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_17_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_17_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 165 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_17 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 165);
        thisval = 165;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_17_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param17_Length = thisval;
    A_FSG_82_0_0_20_Data_17_LenList[ getValue(A_FSG_82_0_0_20_DataIndex) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_17_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_17
{

    //Update Childvalue (String)
    word i;
    byte thisval[167];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param17[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex)].Param17_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_17_LenList[getValue(A_FSG_82_0_0_20_DataIndex)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_17_len, getValueSize(this));
}
on envVar A_FSG_82_0_0_20_1_SetGet
{

    //Update Childvalue (Enum)
    byte thisval; // ASG_ID
    thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_2_SetGet_range // IAA_VehicleUserList.TAID
{
    @A_FSG_82_0_0_20_2_SetGet = @A_FSG_82_0_0_20_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_2_SetGet
{

    //Update Childvalue (Number)
    byte thisval; // TAID
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_2_SetGet, 1.0);
    @A_FSG_82_0_0_20_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_Data_1_SetGet_range // IAA_VehicleUserList.Pos
{
    @A_FSG_82_0_0_20_Data_1_SetGet = @A_FSG_82_0_0_20_Data_1_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_Data_1_SetGet
{

    //Update Childvalue (Number)
    byte thisval; // Pos
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_Data_1_SetGet, 1.0);
    @A_FSG_82_0_0_20_Data_1_SetGet_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param1 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_Data_2_SetGet_range // IAA_VehicleUserList.IAA_UserID
{
    @A_FSG_82_0_0_20_Data_2_SetGet = @A_FSG_82_0_0_20_Data_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_Data_2_SetGet
{

    //Update Childvalue (Number)
    byte thisval; // IAA_UserID
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_Data_2_SetGet, 1.0);
    @A_FSG_82_0_0_20_Data_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param2 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_3_SetGet_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_3_SetGet_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_3_SetGet_CntList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_3_SetGet_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_3_SetGet_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_3_SetGet_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 66 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_3_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 66);
        thisval = 66;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_3_SetGet_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param3_Length = thisval;
    A_FSG_82_0_0_20_Data_3_SetGet_LenList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_3_SetGet_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_3_SetGet
{

    //Update Childvalue (String)
    word i;
    byte thisval[67];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param3[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param3_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_3_SetGet_LenList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_3_SetGet_len, getValueSize(this));
}
on envVar A_FSG_82_0_0_20_Data_4_SetGet_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4_SetGet);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(A_FSG_82_0_0_20_Data_4_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_SetGet_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4_SetGet);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(A_FSG_82_0_0_20_Data_4_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_SetGet_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4_SetGet);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(A_FSG_82_0_0_20_Data_4_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_SetGet_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4_SetGet);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(A_FSG_82_0_0_20_Data_4_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_SetGet_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4_SetGet);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(A_FSG_82_0_0_20_Data_4_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_SetGet_6
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4_SetGet);
    thisval = thisval&~(1<<6)|(bitval<<6);
    putValue(A_FSG_82_0_0_20_Data_4_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_SetGet_7
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus1
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_4_SetGet);
    thisval = thisval&~(1<<7)|(bitval<<7);
    putValue(A_FSG_82_0_0_20_Data_4_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_4_SetGet
{

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // FunctionalStatus1
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_0, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_0, 0);
    if(thisval&(mask<<1))
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_1, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_1, 0);
    if(thisval&(mask<<3))
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_3, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_3, 0);
    if(thisval&(mask<<4))
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_4, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_4, 0);
    if(thisval&(mask<<5))
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_5, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_5, 0);
    if(thisval&(mask<<6))
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_6, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_6, 0);
    if(thisval&(mask<<7))
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_7, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_4_SetGet_7, 0);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param4 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_5_SetGet_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FunctionalStatus2
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_5_SetGet);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(A_FSG_82_0_0_20_Data_5_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_5_SetGet
{

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // FunctionalStatus2
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(A_FSG_82_0_0_20_Data_5_SetGet_0, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_5_SetGet_0, 0);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param5 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_6_SetGet_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // TokenStatus
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_6_SetGet);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(A_FSG_82_0_0_20_Data_6_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_6_SetGet_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // TokenStatus
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_6_SetGet);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(A_FSG_82_0_0_20_Data_6_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_6_SetGet
{

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // TokenStatus
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(A_FSG_82_0_0_20_Data_6_SetGet_0, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_6_SetGet_0, 0);
    if(thisval&(mask<<1))
        putValue(A_FSG_82_0_0_20_Data_6_SetGet_1, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_6_SetGet_1, 0);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param6 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_7_SetGet_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // StorageLocation
    bitval= getValue(this);
    thisval = getValue(A_FSG_82_0_0_20_Data_7_SetGet);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(A_FSG_82_0_0_20_Data_7_SetGet,thisval);
}

on envVar A_FSG_82_0_0_20_Data_7_SetGet
{

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // StorageLocation
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(A_FSG_82_0_0_20_Data_7_SetGet_0, 1);
    else
        putValue(A_FSG_82_0_0_20_Data_7_SetGet_0, 0);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param7 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_8_SetGet
{

    //Update Childvalue (Enum)
    byte thisval; // SPIN_Status
    thisval = getValue(this);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param8 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_9_SetGet
{

    //Update Childvalue (Enum)
    byte thisval; // PassengerType
    thisval = getValue(this);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param9 = thisval;
}
on envVar A_FSG_82_0_0_20_Data_10_SetGet
{

    //Update Childvalue (Enum)
    byte thisval; // UserRole
    thisval = getValue(this);
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param10 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_Data_11_SetGet_range // IAA_VehicleUserList.Picture_etag
{
    @A_FSG_82_0_0_20_Data_11_SetGet = @A_FSG_82_0_0_20_Data_11_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_Data_11_SetGet
{

    //Update Childvalue (Number)
    word thisval; // Picture_etag
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_Data_11_SetGet, 1.0);
    @A_FSG_82_0_0_20_Data_11_SetGet_range = slider_value + (0); // real value := slider value + range min.
    thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param11 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_12_SetGet_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_12_SetGet_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_12_SetGet_CntList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_12_SetGet_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_12_SetGet_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_12_SetGet_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 24 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_12_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 24);
        thisval = 24;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_12_SetGet_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param12_Length = thisval;
    A_FSG_82_0_0_20_Data_12_SetGet_LenList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_12_SetGet_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_12_SetGet
{

    //Update Childvalue (String)
    word i;
    byte thisval[25];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param12[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param12_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_12_SetGet_LenList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_12_SetGet_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_13_SetGet_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_13_SetGet_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_13_SetGet_CntList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_13_SetGet_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_13_SetGet_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_13_SetGet_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 30 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_13_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 30);
        thisval = 30;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_13_SetGet_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param13_Length = thisval;
    A_FSG_82_0_0_20_Data_13_SetGet_LenList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_13_SetGet_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_13_SetGet
{

    //Update Childvalue (String)
    word i;
    byte thisval[31];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param13[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param13_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_13_SetGet_LenList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_13_SetGet_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_20_Data_14_SetGet_range // IAA_VehicleUserList.SlotControllD
{
    @A_FSG_82_0_0_20_Data_14_SetGet = @A_FSG_82_0_0_20_Data_14_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_20_Data_14_SetGet
{

    //Update Childvalue (Number)
    byte thisval; // SlotControllD
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_20_Data_14_SetGet, 1.0);
    @A_FSG_82_0_0_20_Data_14_SetGet_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param14 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_15_SetGet_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_15_SetGet_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_15_SetGet_CntList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_15_SetGet_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_15_SetGet_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_15_SetGet_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 17 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_15_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 17);
        thisval = 17;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_15_SetGet_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param15_Length = thisval;
    A_FSG_82_0_0_20_Data_15_SetGet_LenList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_15_SetGet_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_15_SetGet
{

    //Update Childvalue (String)
    word i;
    byte thisval[18];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param15[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param15_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_15_SetGet_LenList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_15_SetGet_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_16_SetGet_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_16_SetGet_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_16_SetGet_CntList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_16_SetGet_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_16_SetGet_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_16_SetGet_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 17 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_16_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 17);
        thisval = 17;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_16_SetGet_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param16_Length = thisval;
    A_FSG_82_0_0_20_Data_16_SetGet_LenList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_16_SetGet_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_16_SetGet
{

    //Update Childvalue (String)
    word i;
    byte thisval[18];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param16[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param16_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_16_SetGet_LenList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_16_SetGet_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_20_Data_17_SetGet_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_20_Data_17_SetGet_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_20_Data_17_SetGet_CntList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_20_Data_17_SetGet_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_20_Data_17_SetGet_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_20_Data_17_SetGet_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 165 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_20_Data_17_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 165);
        thisval = 165;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_20_Data_17_SetGet_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param17_Length = thisval;
    A_FSG_82_0_0_20_Data_17_SetGet_LenList[ getValue(A_FSG_82_0_0_20_DataIndex_SetGet) ] = thisval;
    putValue(A_FSG_82_0_0_20_Data_17_SetGet_len, thisval);

}

on envVar A_FSG_82_0_0_20_Data_17_SetGet
{

    //Update Childvalue (String)
    word i;
    byte thisval[167];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param17[i] = thisval[i];
    A_FSG_82_0_0_20_ArrayDataList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)].Param17_Length = getValueSize(this);
    A_FSG_82_0_0_20_Data_17_SetGet_LenList[getValue(A_FSG_82_0_0_20_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_82_0_0_20_Data_17_SetGet_len, getValueSize(this));
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_82_0_0_21_ErrCode
{
       if(gM_FSG_82_0_0_21_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_M_FSG_82_0_0_21", MakeRGB(255,255,255));
       }
       gM_FSG_82_0_0_21_ErrCode = 1;
}
on envVar M_FSG_82_0_0_21Result_BTN
{
    byte temp[135];
    if (M_FSG_82_0_0_21Result_BTN_already_pressed == 0)
    {
        putValue(M_FSG_82_0_0_21_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_FSG_82_0_0_21",MakeRGB(255,255,255));
        M_FSG_82_0_0_21Result_BTN_already_pressed = 1;
    }
    else
    {
         M_FSG_82_0_0_21_Result_BuildFct();
        putValue(M_FSG_82_0_0_21_State, "Result");
        getValue(M_FSG_82_0_0_21_Result, temp);
        Request_ByteSequence(LSGID, M_FSG_82_0_0_21_ID, Result_REQ, temp, getValueSize(M_FSG_82_0_0_21_Result));
        if(getValue(M_FSG_82_0_0_21_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(M_FSG_82_0_0_21_ID);
        }
        if(getValue(M_FSG_82_0_0_21_SegmEn))   //getvalue(SG)
        {
            sequence_err(M_FSG_82_0_0_21_ID,getValueSize(M_FSG_82_0_0_21_SegmEn));
        }
        M_FSG_82_0_0_21Result_BTN_already_pressed = 0;
    }
}
on envVar M_FSG_82_0_0_21_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_82_0_0_21_ID;
    data[2]=getValue(M_FSG_82_0_0_21_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_82_0_0_21
on envVar M_FSG_82_0_0_21_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_21",1);
           EnableControl(panel_name,"errfield_M_FSG_82_0_0_21",1);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_21",1);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_82_0_0_21", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_21",0);
           EnableControl(panel_name,"errfield_M_FSG_82_0_0_21",0);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_21",0);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_21_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_82_0_0_21", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar M_FSG_82_0_0_21_IntTlgEn
{
       if(getValue(this))
       {
           putValue(M_FSG_82_0_0_21_SegmEn,0);
           intertelegram_err(M_FSG_82_0_0_21_ID);
       }
       else
       {
           intertelegram_err_off(M_FSG_82_0_0_21_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar M_FSG_82_0_0_21_SegmEn
{
       if(getValue(this))
       {
           putValue(M_FSG_82_0_0_21_IntTlgEn,0);
           sequence_err(M_FSG_82_0_0_21_ID,getValueSize(M_FSG_82_0_0_21_SegmEn));
       }
       else
       {
              sequence_err_off(M_FSG_82_0_0_21_ID);
       }
}
on envVar M_FSG_82_0_0_21_Result // bus value of IAA_TriggerRemoteProcess (21).
{
    // opcodes: Error-Processing-Result
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Triggerresult
    byte param5; // ResultParam1
    byte param6; // ResultParam2
    byte param7[130]; // ResultParam3
    word len7;
    byte cnt7;
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[135];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 135; i++ ) {
        superval[i] = 0;
    }
    getValue(M_FSG_82_0_0_21_Result, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(M_FSG_82_0_0_21_Result_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(M_FSG_82_0_0_21_Result_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Result_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Result_4, param4);
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Result_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Result_6, round((param6 * 1.0) - (0) + (0), 1.0));
    ///////// Start param7 - STRING /////////
    getValue(M_FSG_82_0_0_21_Result_7, param7);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(128>127) /* Max Fct-Katalog Laenge: 128*/
        {
            len7 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt7 = 1;
        }
        else
        {
            len7 = 128;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_82_0_0_21_Result ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len7 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt7 = 0;
    }

    if(len7 > 128)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len7, currentPos);
        len7 = 128;

        if(len7 < 128) cnt7 = 0;
        else cnt7 = 1;
    }

    for(i = 0; i < len7; i++)
    {
        param7[i] = superval[currentPos++];
    }

    putValue(M_FSG_82_0_0_21_Result_7_len, len7);
    putValue(M_FSG_82_0_0_21_Result_7_cnt, cnt7);

    putValue(M_FSG_82_0_0_21_Result_7, param7, len7);

}

// Updates the bus value field and other dependencies.
M_FSG_82_0_0_21_Result_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Triggerresult
    byte param5; // ResultParam1
    byte param6; // ResultParam2
    byte param7[130]; // ResultParam3
    word len7;
    byte cnt7;

    dword i;
    byte superval[135];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(M_FSG_82_0_0_21_Result_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Result_2_range = round(@M_FSG_82_0_0_21_Result_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    param3 = getValue(M_FSG_82_0_0_21_Result_3);
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    param4 = getValue(M_FSG_82_0_0_21_Result_4);
    superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Result_5_range = round(@M_FSG_82_0_0_21_Result_5 + (0), 1.0); // slider value + min = real value
    param5 = (@M_FSG_82_0_0_21_Result_5 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Result_6_range = round(@M_FSG_82_0_0_21_Result_6 + (0), 1.0); // slider value + min = real value
    param6 = (@M_FSG_82_0_0_21_Result_6 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals
    getValue(M_FSG_82_0_0_21_Result_7, param7);
    len7 = getValue(M_FSG_82_0_0_21_Result_7_len);
    cnt7= getValue(M_FSG_82_0_0_21_Result_7_cnt);

    /* check box aktiviert*/
    if (cnt7 == 1)
    {
        /* 0 bis 128 (MaxString - 1B oder 2B) */
        if(len7 >= 0 && len7 <= 128)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
            superval[currentPos] = ((len7>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len7 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Result_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 128);
            return;
        }
    }
    else if(cnt7 == 0) /*check box deaktiviert*/
    {
        if(len7 >= 0 && len7 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
            superval[currentPos]= len7 & 0x00ff;
            putValue(M_FSG_82_0_0_21_Result_7_len, len7);
        }
        else if(len7 > 127 && len7 <= 128)
        {
            superval[currentPos] = ((len7>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len7 & 0x00ff;
            putValue(M_FSG_82_0_0_21_Result_7_len, len7);
            putValue(M_FSG_82_0_0_21_Result_7_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Result_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 128);
            return;
        }
    }
    currentPos += cnt7+1;
    for(i = 0; i < len7; i++)
    {
        superval[currentPos++]= param7[i];
    }

    putValue(M_FSG_82_0_0_21_Result, superval, currentPos);
}


on envVar M_FSG_82_0_0_21_Result_1 // IAA_TriggerRemoteProcess.ASG_ID
{
    M_FSG_82_0_0_21_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Result_2_range // IAA_TriggerRemoteProcess.Extension1
{
    @M_FSG_82_0_0_21_Result_2 = @M_FSG_82_0_0_21_Result_2_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Result_2 // IAA_TriggerRemoteProcess.Extension1
{
    M_FSG_82_0_0_21_Result_BuildFct();
}

on envVar M_FSG_82_0_0_21_Result_3 // IAA_TriggerRemoteProcess.CommandType
{
    M_FSG_82_0_0_21_Result_BuildFct();
}

on envVar M_FSG_82_0_0_21_Result_4 // IAA_TriggerRemoteProcess.Triggerresult
{
    M_FSG_82_0_0_21_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Result_5_range // IAA_TriggerRemoteProcess.ResultParam1
{
    @M_FSG_82_0_0_21_Result_5 = @M_FSG_82_0_0_21_Result_5_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Result_5 // IAA_TriggerRemoteProcess.ResultParam1
{
    M_FSG_82_0_0_21_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Result_6_range // IAA_TriggerRemoteProcess.ResultParam2
{
    @M_FSG_82_0_0_21_Result_6 = @M_FSG_82_0_0_21_Result_6_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Result_6 // IAA_TriggerRemoteProcess.ResultParam2
{
    M_FSG_82_0_0_21_Result_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_82_0_0_21_Result_7_cnt
{
    word len;
    byte cnt;
    len = getValue(M_FSG_82_0_0_21_Result_7_len);
    cnt = getValue(M_FSG_82_0_0_21_Result_7_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(M_FSG_82_0_0_21_Result_7_len, 127);
        }
    }

    M_FSG_82_0_0_21_Result_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_82_0_0_21_Result_7_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 128)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Result_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 128);
        putValue(this, 128);
    }
    M_FSG_82_0_0_21_Result_BuildFct();
}


on envVar M_FSG_82_0_0_21_Result_7 // IAA_TriggerRemoteProcess.ResultParam3
{
    putValue(M_FSG_82_0_0_21_Result_7_len, getValueSize(this));
    M_FSG_82_0_0_21_Result_BuildFct();
}

on envVar M_FSG_82_0_0_21_Processing // bus value of IAA_TriggerRemoteProcess (21).
{
    // opcodes: Error-Processing-Result
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Reserve1
    byte param5; // Reserve2
    byte param6; // Reserve3
    byte param7; // Reserve4
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[135];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 135; i++ ) {
        superval[i] = 0;
    }
    getValue(M_FSG_82_0_0_21_Processing, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(M_FSG_82_0_0_21_Processing_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(M_FSG_82_0_0_21_Processing_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Processing_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Processing_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Processing_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Processing_6, round((param6 * 1.0) - (0) + (0), 1.0));
    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Processing_7, round((param7 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
M_FSG_82_0_0_21_Processing_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Reserve1
    byte param5; // Reserve2
    byte param6; // Reserve3
    byte param7; // Reserve4

    dword i;
    byte superval[135];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(M_FSG_82_0_0_21_Processing_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Processing_2_range = round(@M_FSG_82_0_0_21_Processing_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    param3 = getValue(M_FSG_82_0_0_21_Processing_3);
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Processing_4_range = round(@M_FSG_82_0_0_21_Processing_4 + (0), 1.0); // slider value + min = real value
    param4 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Processing_5_range = round(@M_FSG_82_0_0_21_Processing_5 + (0), 1.0); // slider value + min = real value
    param5 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Processing_6_range = round(@M_FSG_82_0_0_21_Processing_6 + (0), 1.0); // slider value + min = real value
    param6 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Processing_7_range = round(@M_FSG_82_0_0_21_Processing_7 + (0), 1.0); // slider value + min = real value
    param7 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param7;
    putValue(M_FSG_82_0_0_21_Processing, superval, currentPos);
}


on envVar M_FSG_82_0_0_21_Processing_1 // IAA_TriggerRemoteProcess.ASG_ID
{
    M_FSG_82_0_0_21_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Processing_2_range // IAA_TriggerRemoteProcess.Extension1
{
    @M_FSG_82_0_0_21_Processing_2 = @M_FSG_82_0_0_21_Processing_2_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Processing_2 // IAA_TriggerRemoteProcess.Extension1
{
    M_FSG_82_0_0_21_Processing_BuildFct();
}

on envVar M_FSG_82_0_0_21_Processing_3 // IAA_TriggerRemoteProcess.CommandType
{
    M_FSG_82_0_0_21_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Processing_4_range // IAA_TriggerRemoteProcess.Reserve1
{
    @M_FSG_82_0_0_21_Processing_4 = @M_FSG_82_0_0_21_Processing_4_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Processing_4 // IAA_TriggerRemoteProcess.Reserve1
{
    M_FSG_82_0_0_21_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Processing_5_range // IAA_TriggerRemoteProcess.Reserve2
{
    @M_FSG_82_0_0_21_Processing_5 = @M_FSG_82_0_0_21_Processing_5_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Processing_5 // IAA_TriggerRemoteProcess.Reserve2
{
    M_FSG_82_0_0_21_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Processing_6_range // IAA_TriggerRemoteProcess.Reserve3
{
    @M_FSG_82_0_0_21_Processing_6 = @M_FSG_82_0_0_21_Processing_6_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Processing_6 // IAA_TriggerRemoteProcess.Reserve3
{
    M_FSG_82_0_0_21_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Processing_7_range // IAA_TriggerRemoteProcess.Reserve4
{
    @M_FSG_82_0_0_21_Processing_7 = @M_FSG_82_0_0_21_Processing_7_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Processing_7 // IAA_TriggerRemoteProcess.Reserve4
{
    M_FSG_82_0_0_21_Processing_BuildFct();
}

on envVar M_FSG_82_0_0_21_Start // bus value of IAA_TriggerRemoteProcess (21).
{
    // opcodes: AbortResult-StartResult
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Param1
    byte param5; // Param2
    byte param6[130]; // Param3
    word len6;
    byte cnt6;
    byte param7[130]; // Param4
    word len7;
    byte cnt7;
    byte param8[130]; // Param5
    word len8;
    byte cnt8;
    byte param9[18]; // Param6
    word len9;
    byte cnt9;
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[412];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 412; i++ ) {
        superval[i] = 0;
    }
    getValue(M_FSG_82_0_0_21_Start, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(M_FSG_82_0_0_21_Start_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(M_FSG_82_0_0_21_Start_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Start_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Start_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(M_FSG_82_0_0_21_Start_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - STRING /////////
    getValue(M_FSG_82_0_0_21_Start_6, param6);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(128>127) /* Max Fct-Katalog Laenge: 128*/
        {
            len6 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt6 = 1;
        }
        else
        {
            len6 = 128;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_82_0_0_21_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len6 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt6 = 0;
    }

    if(len6 > 128)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len6, currentPos);
        len6 = 128;

        if(len6 < 128) cnt6 = 0;
        else cnt6 = 1;
    }

    for(i = 0; i < len6; i++)
    {
        param6[i] = superval[currentPos++];
    }

    putValue(M_FSG_82_0_0_21_Start_6_len, len6);
    putValue(M_FSG_82_0_0_21_Start_6_cnt, cnt6);

    putValue(M_FSG_82_0_0_21_Start_6, param6, len6);

    ///////// Start param7 - STRING /////////
    getValue(M_FSG_82_0_0_21_Start_7, param7);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(128>127) /* Max Fct-Katalog Laenge: 128*/
        {
            len7 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt7 = 1;
        }
        else
        {
            len7 = 128;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_82_0_0_21_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len7 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt7 = 0;
    }

    if(len7 > 128)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len7, currentPos);
        len7 = 128;

        if(len7 < 128) cnt7 = 0;
        else cnt7 = 1;
    }

    for(i = 0; i < len7; i++)
    {
        param7[i] = superval[currentPos++];
    }

    putValue(M_FSG_82_0_0_21_Start_7_len, len7);
    putValue(M_FSG_82_0_0_21_Start_7_cnt, cnt7);

    putValue(M_FSG_82_0_0_21_Start_7, param7, len7);

    ///////// Start param8 - STRING /////////
    getValue(M_FSG_82_0_0_21_Start_8, param8);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(128>127) /* Max Fct-Katalog Laenge: 128*/
        {
            len8 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt8 = 1;
        }
        else
        {
            len8 = 128;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_82_0_0_21_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len8 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt8 = 0;
    }

    if(len8 > 128)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len8, currentPos);
        len8 = 128;

        if(len8 < 128) cnt8 = 0;
        else cnt8 = 1;
    }

    for(i = 0; i < len8; i++)
    {
        param8[i] = superval[currentPos++];
    }

    putValue(M_FSG_82_0_0_21_Start_8_len, len8);
    putValue(M_FSG_82_0_0_21_Start_8_cnt, cnt8);

    putValue(M_FSG_82_0_0_21_Start_8, param8, len8);

    ///////// Start param9 - STRING /////////
    getValue(M_FSG_82_0_0_21_Start_9, param9);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(17>127) /* Max Fct-Katalog Laenge: 17*/
        {
            len9 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt9 = 1;
        }
        else
        {
            len9 = 17;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_82_0_0_21_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len9 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt9 = 0;
    }

    if(len9 > 17)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len9, currentPos);
        len9 = 17;

        if(len9 < 128) cnt9 = 0;
        else cnt9 = 1;
    }

    for(i = 0; i < len9; i++)
    {
        param9[i] = superval[currentPos++];
    }

    putValue(M_FSG_82_0_0_21_Start_9_len, len9);
    putValue(M_FSG_82_0_0_21_Start_9_cnt, cnt9);

    putValue(M_FSG_82_0_0_21_Start_9, param9, len9);

}

// Updates the bus value field and other dependencies.
M_FSG_82_0_0_21_Start_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Param1
    byte param5; // Param2
    byte param6[130]; // Param3
    word len6;
    byte cnt6;
    byte param7[130]; // Param4
    word len7;
    byte cnt7;
    byte param8[130]; // Param5
    word len8;
    byte cnt8;
    byte param9[18]; // Param6
    word len9;
    byte cnt9;

    dword i;
    byte superval[412];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(M_FSG_82_0_0_21_Start_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Start_2_range = round(@M_FSG_82_0_0_21_Start_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    param3 = getValue(M_FSG_82_0_0_21_Start_3);
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Start_4_range = round(@M_FSG_82_0_0_21_Start_4 + (0), 1.0); // slider value + min = real value
    param4 = (@M_FSG_82_0_0_21_Start_4 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_21_Start_5_range = round(@M_FSG_82_0_0_21_Start_5 + (0), 1.0); // slider value + min = real value
    param5 = (@M_FSG_82_0_0_21_Start_5 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals
    getValue(M_FSG_82_0_0_21_Start_6, param6);
    len6 = getValue(M_FSG_82_0_0_21_Start_6_len);
    cnt6= getValue(M_FSG_82_0_0_21_Start_6_cnt);

    /* check box aktiviert*/
    if (cnt6 == 1)
    {
        /* 0 bis 128 (MaxString - 1B oder 2B) */
        if(len6 >= 0 && len6 <= 128)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
            superval[currentPos] = ((len6>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len6 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 128);
            return;
        }
    }
    else if(cnt6 == 0) /*check box deaktiviert*/
    {
        if(len6 >= 0 && len6 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
            superval[currentPos]= len6 & 0x00ff;
            putValue(M_FSG_82_0_0_21_Start_6_len, len6);
        }
        else if(len6 > 127 && len6 <= 128)
        {
            superval[currentPos] = ((len6>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len6 & 0x00ff;
            putValue(M_FSG_82_0_0_21_Start_6_len, len6);
            putValue(M_FSG_82_0_0_21_Start_6_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 128);
            return;
        }
    }
    currentPos += cnt6+1;
    for(i = 0; i < len6; i++)
    {
        superval[currentPos++]= param6[i];
    }

// gen_BuildFunc_SetSuperVals
    getValue(M_FSG_82_0_0_21_Start_7, param7);
    len7 = getValue(M_FSG_82_0_0_21_Start_7_len);
    cnt7= getValue(M_FSG_82_0_0_21_Start_7_cnt);

    /* check box aktiviert*/
    if (cnt7 == 1)
    {
        /* 0 bis 128 (MaxString - 1B oder 2B) */
        if(len7 >= 0 && len7 <= 128)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
            superval[currentPos] = ((len7>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len7 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 128);
            return;
        }
    }
    else if(cnt7 == 0) /*check box deaktiviert*/
    {
        if(len7 >= 0 && len7 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
            superval[currentPos]= len7 & 0x00ff;
            putValue(M_FSG_82_0_0_21_Start_7_len, len7);
        }
        else if(len7 > 127 && len7 <= 128)
        {
            superval[currentPos] = ((len7>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len7 & 0x00ff;
            putValue(M_FSG_82_0_0_21_Start_7_len, len7);
            putValue(M_FSG_82_0_0_21_Start_7_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 128);
            return;
        }
    }
    currentPos += cnt7+1;
    for(i = 0; i < len7; i++)
    {
        superval[currentPos++]= param7[i];
    }

// gen_BuildFunc_SetSuperVals
    getValue(M_FSG_82_0_0_21_Start_8, param8);
    len8 = getValue(M_FSG_82_0_0_21_Start_8_len);
    cnt8= getValue(M_FSG_82_0_0_21_Start_8_cnt);

    /* check box aktiviert*/
    if (cnt8 == 1)
    {
        /* 0 bis 128 (MaxString - 1B oder 2B) */
        if(len8 >= 0 && len8 <= 128)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
            superval[currentPos] = ((len8>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len8 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 128);
            return;
        }
    }
    else if(cnt8 == 0) /*check box deaktiviert*/
    {
        if(len8 >= 0 && len8 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
            superval[currentPos]= len8 & 0x00ff;
            putValue(M_FSG_82_0_0_21_Start_8_len, len8);
        }
        else if(len8 > 127 && len8 <= 128)
        {
            superval[currentPos] = ((len8>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len8 & 0x00ff;
            putValue(M_FSG_82_0_0_21_Start_8_len, len8);
            putValue(M_FSG_82_0_0_21_Start_8_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 128);
            return;
        }
    }
    currentPos += cnt8+1;
    for(i = 0; i < len8; i++)
    {
        superval[currentPos++]= param8[i];
    }

// gen_BuildFunc_SetSuperVals
    getValue(M_FSG_82_0_0_21_Start_9, param9);
    len9 = getValue(M_FSG_82_0_0_21_Start_9_len);
    cnt9= getValue(M_FSG_82_0_0_21_Start_9_cnt);

    /* check box aktiviert*/
    if (cnt9 == 1)
    {
        /* 0 bis 17 (MaxString - 1B oder 2B) */
        if(len9 >= 0 && len9 <= 17)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len9: %d", len9);
            superval[currentPos] = ((len9>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len9 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_9 ist ungueltig. Die max. erlaubte Laenge ist %d.", len9, 17);
            return;
        }
    }
    else if(cnt9 == 0) /*check box deaktiviert*/
    {
        if(len9 >= 0 && len9 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len9: %d", len9);
            superval[currentPos]= len9 & 0x00ff;
            putValue(M_FSG_82_0_0_21_Start_9_len, len9);
        }
        else if(len9 > 127 && len9 <= 17)
        {
            superval[currentPos] = ((len9>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len9 & 0x00ff;
            putValue(M_FSG_82_0_0_21_Start_9_len, len9);
            putValue(M_FSG_82_0_0_21_Start_9_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_9 ist ungueltig. Die max. erlaubte Laenge ist %d.", len9, 17);
            return;
        }
    }
    currentPos += cnt9+1;
    for(i = 0; i < len9; i++)
    {
        superval[currentPos++]= param9[i];
    }

    putValue(M_FSG_82_0_0_21_Start, superval, currentPos);
}


on envVar M_FSG_82_0_0_21_Start_1 // IAA_TriggerRemoteProcess.ASG_ID
{
    M_FSG_82_0_0_21_Start_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Start_2_range // IAA_TriggerRemoteProcess.Extension1
{
    @M_FSG_82_0_0_21_Start_2 = @M_FSG_82_0_0_21_Start_2_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Start_2 // IAA_TriggerRemoteProcess.Extension1
{
    M_FSG_82_0_0_21_Start_BuildFct();
}

on envVar M_FSG_82_0_0_21_Start_3 // IAA_TriggerRemoteProcess.CommandType
{
    M_FSG_82_0_0_21_Start_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Start_4_range // IAA_TriggerRemoteProcess.Param1
{
    @M_FSG_82_0_0_21_Start_4 = @M_FSG_82_0_0_21_Start_4_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Start_4 // IAA_TriggerRemoteProcess.Param1
{
    M_FSG_82_0_0_21_Start_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_21_Start_5_range // IAA_TriggerRemoteProcess.Param2
{
    @M_FSG_82_0_0_21_Start_5 = @M_FSG_82_0_0_21_Start_5_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_21_Start_5 // IAA_TriggerRemoteProcess.Param2
{
    M_FSG_82_0_0_21_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_82_0_0_21_Start_6_cnt
{
    word len;
    byte cnt;
    len = getValue(M_FSG_82_0_0_21_Start_6_len);
    cnt = getValue(M_FSG_82_0_0_21_Start_6_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(M_FSG_82_0_0_21_Start_6_len, 127);
        }
    }

    M_FSG_82_0_0_21_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_82_0_0_21_Start_6_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 128)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 128);
        putValue(this, 128);
    }
    M_FSG_82_0_0_21_Start_BuildFct();
}


on envVar M_FSG_82_0_0_21_Start_6 // IAA_TriggerRemoteProcess.Param3
{
    putValue(M_FSG_82_0_0_21_Start_6_len, getValueSize(this));
    M_FSG_82_0_0_21_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_82_0_0_21_Start_7_cnt
{
    word len;
    byte cnt;
    len = getValue(M_FSG_82_0_0_21_Start_7_len);
    cnt = getValue(M_FSG_82_0_0_21_Start_7_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(M_FSG_82_0_0_21_Start_7_len, 127);
        }
    }

    M_FSG_82_0_0_21_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_82_0_0_21_Start_7_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 128)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 128);
        putValue(this, 128);
    }
    M_FSG_82_0_0_21_Start_BuildFct();
}


on envVar M_FSG_82_0_0_21_Start_7 // IAA_TriggerRemoteProcess.Param4
{
    putValue(M_FSG_82_0_0_21_Start_7_len, getValueSize(this));
    M_FSG_82_0_0_21_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_82_0_0_21_Start_8_cnt
{
    word len;
    byte cnt;
    len = getValue(M_FSG_82_0_0_21_Start_8_len);
    cnt = getValue(M_FSG_82_0_0_21_Start_8_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(M_FSG_82_0_0_21_Start_8_len, 127);
        }
    }

    M_FSG_82_0_0_21_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_82_0_0_21_Start_8_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 128)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_8 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 128);
        putValue(this, 128);
    }
    M_FSG_82_0_0_21_Start_BuildFct();
}


on envVar M_FSG_82_0_0_21_Start_8 // IAA_TriggerRemoteProcess.Param5
{
    putValue(M_FSG_82_0_0_21_Start_8_len, getValueSize(this));
    M_FSG_82_0_0_21_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_82_0_0_21_Start_9_cnt
{
    word len;
    byte cnt;
    len = getValue(M_FSG_82_0_0_21_Start_9_len);
    cnt = getValue(M_FSG_82_0_0_21_Start_9_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(M_FSG_82_0_0_21_Start_9_len, 127);
        }
    }

    M_FSG_82_0_0_21_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_82_0_0_21_Start_9_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 17)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_21_Start_9 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 17);
        putValue(this, 17);
    }
    M_FSG_82_0_0_21_Start_BuildFct();
}


on envVar M_FSG_82_0_0_21_Start_9 // IAA_TriggerRemoteProcess.Param6
{
    putValue(M_FSG_82_0_0_21_Start_9_len, getValueSize(this));
    M_FSG_82_0_0_21_Start_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_22_ErrCode
{
       if(gP_FSG_82_0_0_22_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_22", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_22_ErrCode = 1;
}
on envVar P_FSG_82_0_0_22Status_BTN
{
    byte BAPTemp[6];
   if (P_FSG_82_0_0_22Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_82_0_0_22_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_22",MakeRGB(255,255,255));
      P_FSG_82_0_0_22Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_82_0_0_22, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_82_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_22));
      P_FSG_82_0_0_22Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_82_0_0_22_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_22_ID;
    data[2]=getValue(P_FSG_82_0_0_22_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_22
on envVar P_FSG_82_0_0_22_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_22",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_22",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_22",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_22", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_22",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_22",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_22",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_22", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_82_0_0_22 // bus value of IAA_RemoteProcessCommands (22).
{
    // opcodes: Error-Status
    byte param1; // SupportedCommands0
    byte param2; // SupportedCommands1
    byte param3; // SupportedCommands2
    byte param4; // Extension1
    byte param5; // Extension2
    byte param6; // Extension3
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[6];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 6; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_22, superval);
    ///////// Start param1 - UINT8 /////////
    param1 = superval[currentPos++];
    putValue(P_FSG_82_0_0_22_1, param1);
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_82_0_0_22_2, param2);
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_22_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_82_0_0_22_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_22_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_82_0_0_22_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_82_0_0_22_1_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_1);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_22_1,thisval);
}

on envVar P_FSG_82_0_0_22_1_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_1);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_22_1,thisval);
}

on envVar P_FSG_82_0_0_22_1_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_1);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_22_1,thisval);
}

on envVar P_FSG_82_0_0_22_1_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_1);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_22_1,thisval);
}

on envVar P_FSG_82_0_0_22_1_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_1);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_22_1,thisval);
}

on envVar P_FSG_82_0_0_22_1_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_1);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_22_1,thisval);
}

on envVar P_FSG_82_0_0_22_1_6
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_1);
    thisval = thisval&~(1<<6)|(bitval<<6);
    putValue(P_FSG_82_0_0_22_1,thisval);
}

on envVar P_FSG_82_0_0_22_1_7
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_1);
    thisval = thisval&~(1<<7)|(bitval<<7);
    putValue(P_FSG_82_0_0_22_1,thisval);
}

on envVar P_FSG_82_0_0_22_1 // IAA_RemoteProcessCommands.SupportedCommands0
{
    byte superval[6];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // SupportedCommands0
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_22_1_0, 1);
    else
        putValue(P_FSG_82_0_0_22_1_0, 0);
    if(thisval&(mask<<1))
        putValue(P_FSG_82_0_0_22_1_1, 1);
    else
        putValue(P_FSG_82_0_0_22_1_1, 0);
    if(thisval&(mask<<2))
        putValue(P_FSG_82_0_0_22_1_2, 1);
    else
        putValue(P_FSG_82_0_0_22_1_2, 0);
    if(thisval&(mask<<3))
        putValue(P_FSG_82_0_0_22_1_3, 1);
    else
        putValue(P_FSG_82_0_0_22_1_3, 0);
    if(thisval&(mask<<4))
        putValue(P_FSG_82_0_0_22_1_4, 1);
    else
        putValue(P_FSG_82_0_0_22_1_4, 0);
    if(thisval&(mask<<5))
        putValue(P_FSG_82_0_0_22_1_5, 1);
    else
        putValue(P_FSG_82_0_0_22_1_5, 0);
    if(thisval&(mask<<6))
        putValue(P_FSG_82_0_0_22_1_6, 1);
    else
        putValue(P_FSG_82_0_0_22_1_6, 0);
    if(thisval&(mask<<7))
        putValue(P_FSG_82_0_0_22_1_7, 1);
    else
        putValue(P_FSG_82_0_0_22_1_7, 0);

    // Update superval
    getValue(P_FSG_82_0_0_22, superval);
    superval[0]=thisval;
    putValue(P_FSG_82_0_0_22,superval);
}

on envVar P_FSG_82_0_0_22_2_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_2);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_22_2,thisval);
}

on envVar P_FSG_82_0_0_22_2_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_2);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_22_2,thisval);
}

on envVar P_FSG_82_0_0_22_2_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_2);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_22_2,thisval);
}

on envVar P_FSG_82_0_0_22_2_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_2);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_22_2,thisval);
}

on envVar P_FSG_82_0_0_22_2_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_2);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_22_2,thisval);
}

on envVar P_FSG_82_0_0_22_2_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_2);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_22_2,thisval);
}

on envVar P_FSG_82_0_0_22_2_6
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_2);
    thisval = thisval&~(1<<6)|(bitval<<6);
    putValue(P_FSG_82_0_0_22_2,thisval);
}

on envVar P_FSG_82_0_0_22_2_7
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_2);
    thisval = thisval&~(1<<7)|(bitval<<7);
    putValue(P_FSG_82_0_0_22_2,thisval);
}

on envVar P_FSG_82_0_0_22_2 // IAA_RemoteProcessCommands.SupportedCommands1
{
    byte superval[6];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // SupportedCommands1
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_22_2_0, 1);
    else
        putValue(P_FSG_82_0_0_22_2_0, 0);
    if(thisval&(mask<<1))
        putValue(P_FSG_82_0_0_22_2_1, 1);
    else
        putValue(P_FSG_82_0_0_22_2_1, 0);
    if(thisval&(mask<<2))
        putValue(P_FSG_82_0_0_22_2_2, 1);
    else
        putValue(P_FSG_82_0_0_22_2_2, 0);
    if(thisval&(mask<<3))
        putValue(P_FSG_82_0_0_22_2_3, 1);
    else
        putValue(P_FSG_82_0_0_22_2_3, 0);
    if(thisval&(mask<<4))
        putValue(P_FSG_82_0_0_22_2_4, 1);
    else
        putValue(P_FSG_82_0_0_22_2_4, 0);
    if(thisval&(mask<<5))
        putValue(P_FSG_82_0_0_22_2_5, 1);
    else
        putValue(P_FSG_82_0_0_22_2_5, 0);
    if(thisval&(mask<<6))
        putValue(P_FSG_82_0_0_22_2_6, 1);
    else
        putValue(P_FSG_82_0_0_22_2_6, 0);
    if(thisval&(mask<<7))
        putValue(P_FSG_82_0_0_22_2_7, 1);
    else
        putValue(P_FSG_82_0_0_22_2_7, 0);

    // Update superval
    getValue(P_FSG_82_0_0_22, superval);
    superval[1]=thisval;
    putValue(P_FSG_82_0_0_22,superval);
}

on envVar P_FSG_82_0_0_22_3_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands2
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_3);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_22_3,thisval);
}

on envVar P_FSG_82_0_0_22_3_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands2
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_3);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_22_3,thisval);
}

on envVar P_FSG_82_0_0_22_3_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands2
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_3);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_22_3,thisval);
}

on envVar P_FSG_82_0_0_22_3_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands2
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_3);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_22_3,thisval);
}

on envVar P_FSG_82_0_0_22_3_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands2
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_3);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_22_3,thisval);
}

on envVar P_FSG_82_0_0_22_3_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands2
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_22_3);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_22_3,thisval);
}

on envVar P_FSG_82_0_0_22_3 // IAA_RemoteProcessCommands.SupportedCommands2
{
    byte superval[6];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // SupportedCommands2
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_22_3_0, 1);
    else
        putValue(P_FSG_82_0_0_22_3_0, 0);
    if(thisval&(mask<<1))
        putValue(P_FSG_82_0_0_22_3_1, 1);
    else
        putValue(P_FSG_82_0_0_22_3_1, 0);
    if(thisval&(mask<<2))
        putValue(P_FSG_82_0_0_22_3_2, 1);
    else
        putValue(P_FSG_82_0_0_22_3_2, 0);
    if(thisval&(mask<<3))
        putValue(P_FSG_82_0_0_22_3_3, 1);
    else
        putValue(P_FSG_82_0_0_22_3_3, 0);
    if(thisval&(mask<<4))
        putValue(P_FSG_82_0_0_22_3_4, 1);
    else
        putValue(P_FSG_82_0_0_22_3_4, 0);
    if(thisval&(mask<<5))
        putValue(P_FSG_82_0_0_22_3_5, 1);
    else
        putValue(P_FSG_82_0_0_22_3_5, 0);

    // Update superval
    getValue(P_FSG_82_0_0_22, superval);
    superval[2]=thisval;
    putValue(P_FSG_82_0_0_22,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_22_4_range // IAA_RemoteProcessCommands.Extension1
{
    @P_FSG_82_0_0_22_4 = @P_FSG_82_0_0_22_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_22_4 // IAA_RemoteProcessCommands.Extension1
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension1
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_22_4_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_22, superval);
    superval[3]=thisval;
    putValue(P_FSG_82_0_0_22,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_22_5_range // IAA_RemoteProcessCommands.Extension2
{
    @P_FSG_82_0_0_22_5 = @P_FSG_82_0_0_22_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_22_5 // IAA_RemoteProcessCommands.Extension2
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension2
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_22_5_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_22, superval);
    superval[4]=thisval;
    putValue(P_FSG_82_0_0_22,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_22_6_range // IAA_RemoteProcessCommands.Extension3
{
    @P_FSG_82_0_0_22_6 = @P_FSG_82_0_0_22_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_22_6 // IAA_RemoteProcessCommands.Extension3
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension3
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_22_6_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_22, superval);
    superval[5]=thisval;
    putValue(P_FSG_82_0_0_22,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_23_ErrCode
{
       if(gP_FSG_82_0_0_23_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_23", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_23_ErrCode = 1;
}
on envVar P_FSG_82_0_0_23Status_BTN
{
    byte BAPTemp[6];
   if (P_FSG_82_0_0_23Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_82_0_0_23_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_23",MakeRGB(255,255,255));
      P_FSG_82_0_0_23Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_82_0_0_23, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_82_0_0_23_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_23));
      P_FSG_82_0_0_23Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_82_0_0_23_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_23_ID;
    data[2]=getValue(P_FSG_82_0_0_23_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_23
on envVar P_FSG_82_0_0_23_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_23",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_23",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_23",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_23", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_23",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_23",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_23",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_23", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_82_0_0_23 // bus value of IAA_General_Status (23).
{
    // opcodes: Error-Status
    byte param1; // IAA_Status
    byte param2; // AuthLevelPostrunTimer
    byte param3; // Extension1
    byte param4; // Extension2
    byte param5; // Extension3
    byte param6; // Extension4
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[6];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 6; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_23, superval);
    ///////// Start param1 - UINT8 /////////
    param1 = superval[currentPos++];
    putValue(P_FSG_82_0_0_23_1, param1);
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_82_0_0_23_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_23_3, round((param3 * 1.0) - (0) + (0), 1.0));
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_82_0_0_23_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_23_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_82_0_0_23_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_82_0_0_23_1_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // IAA_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_23_1);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_23_1,thisval);
}

on envVar P_FSG_82_0_0_23_1_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // IAA_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_23_1);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_23_1,thisval);
}

on envVar P_FSG_82_0_0_23_1_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // IAA_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_23_1);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_23_1,thisval);
}

on envVar P_FSG_82_0_0_23_1_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // IAA_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_23_1);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_23_1,thisval);
}

on envVar P_FSG_82_0_0_23_1_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // IAA_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_23_1);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_23_1,thisval);
}

on envVar P_FSG_82_0_0_23_1_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // IAA_Status
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_23_1);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_23_1,thisval);
}

on envVar P_FSG_82_0_0_23_1 // IAA_General_Status.IAA_Status
{
    byte superval[6];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // IAA_Status
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_23_1_0, 1);
    else
        putValue(P_FSG_82_0_0_23_1_0, 0);
    if(thisval&(mask<<1))
        putValue(P_FSG_82_0_0_23_1_1, 1);
    else
        putValue(P_FSG_82_0_0_23_1_1, 0);
    if(thisval&(mask<<2))
        putValue(P_FSG_82_0_0_23_1_2, 1);
    else
        putValue(P_FSG_82_0_0_23_1_2, 0);
    if(thisval&(mask<<3))
        putValue(P_FSG_82_0_0_23_1_3, 1);
    else
        putValue(P_FSG_82_0_0_23_1_3, 0);
    if(thisval&(mask<<4))
        putValue(P_FSG_82_0_0_23_1_4, 1);
    else
        putValue(P_FSG_82_0_0_23_1_4, 0);
    if(thisval&(mask<<5))
        putValue(P_FSG_82_0_0_23_1_5, 1);
    else
        putValue(P_FSG_82_0_0_23_1_5, 0);

    // Update superval
    getValue(P_FSG_82_0_0_23, superval);
    superval[0]=thisval;
    putValue(P_FSG_82_0_0_23,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_23_2_range // IAA_General_Status.AuthLevelPostrunTimer
{
    @P_FSG_82_0_0_23_2 = @P_FSG_82_0_0_23_2_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_23_2 // IAA_General_Status.AuthLevelPostrunTimer
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // AuthLevelPostrunTimer
    float slider_value;

    slider_value = round(@P_FSG_82_0_0_23_2, 1.0);
    @P_FSG_82_0_0_23_2_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_23, superval);
    superval[1]=thisval;
    putValue(P_FSG_82_0_0_23,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_23_3_range // IAA_General_Status.Extension1
{
    @P_FSG_82_0_0_23_3 = @P_FSG_82_0_0_23_3_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_23_3 // IAA_General_Status.Extension1
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension1
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_23_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_23, superval);
    superval[2]=thisval;
    putValue(P_FSG_82_0_0_23,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_23_4_range // IAA_General_Status.Extension2
{
    @P_FSG_82_0_0_23_4 = @P_FSG_82_0_0_23_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_23_4 // IAA_General_Status.Extension2
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension2
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_23_4_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_23, superval);
    superval[3]=thisval;
    putValue(P_FSG_82_0_0_23,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_23_5_range // IAA_General_Status.Extension3
{
    @P_FSG_82_0_0_23_5 = @P_FSG_82_0_0_23_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_23_5 // IAA_General_Status.Extension3
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension3
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_23_5_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_23, superval);
    superval[4]=thisval;
    putValue(P_FSG_82_0_0_23,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_23_6_range // IAA_General_Status.Extension4
{
    @P_FSG_82_0_0_23_6 = @P_FSG_82_0_0_23_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_23_6 // IAA_General_Status.Extension4
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension4
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_23_6_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_23, superval);
    superval[5]=thisval;
    putValue(P_FSG_82_0_0_23,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_24_ErrCode
{
       if(gP_FSG_82_0_0_24_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_24", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_24_ErrCode = 1;
}
on envVar P_FSG_82_0_0_24Status_BTN
{
    byte BAPTemp[6];
   if (P_FSG_82_0_0_24Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_82_0_0_24_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_24",MakeRGB(255,255,255));
      P_FSG_82_0_0_24Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_82_0_0_24, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_82_0_0_24_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_24));
      P_FSG_82_0_0_24Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_82_0_0_24_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_24_ID;
    data[2]=getValue(P_FSG_82_0_0_24_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_24
on envVar P_FSG_82_0_0_24_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_24",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_24",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_24",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_24", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_24",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_24",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_24",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_24", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_82_0_0_24 // bus value of IAA_FFB_Key_Status (24).
{
    // opcodes: Error-Status
    byte param1; // FFB_CurrentKeyNumber
    byte param2; // FFB_CurrentKeyState
    byte param3; // FFB_KeyAssignmentState
    byte param4; // FFB_KeyAssignmentMode
    byte param5; // Extension1
    byte param6; // Extension2
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[6];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 6; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_24, superval);
    ///////// Start param1 - UINT8 /////////
    param1 = superval[currentPos++];
    putValue(P_FSG_82_0_0_24_1, param1);
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_82_0_0_24_2, param2);
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_24_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_82_0_0_24_4, param4);
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_24_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_82_0_0_24_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_82_0_0_24_1 // IAA_FFB_Key_Status.FFB_CurrentKeyNumber
{
    byte superval[6];

    //Update Childvalue (Enum)
    byte thisval; // FFB_CurrentKeyNumber
    thisval = getValue(this);

    // Update superval
    getValue(P_FSG_82_0_0_24, superval);
    superval[0]=thisval;
    putValue(P_FSG_82_0_0_24,superval);
}

on envVar P_FSG_82_0_0_24_2_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FFB_CurrentKeyState
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_24_2);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_24_2,thisval);
}

on envVar P_FSG_82_0_0_24_2_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FFB_CurrentKeyState
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_24_2);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_24_2,thisval);
}

on envVar P_FSG_82_0_0_24_2 // IAA_FFB_Key_Status.FFB_CurrentKeyState
{
    byte superval[6];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // FFB_CurrentKeyState
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_24_2_0, 1);
    else
        putValue(P_FSG_82_0_0_24_2_0, 0);
    if(thisval&(mask<<1))
        putValue(P_FSG_82_0_0_24_2_1, 1);
    else
        putValue(P_FSG_82_0_0_24_2_1, 0);

    // Update superval
    getValue(P_FSG_82_0_0_24, superval);
    superval[1]=thisval;
    putValue(P_FSG_82_0_0_24,superval);
}

on envVar P_FSG_82_0_0_24_3_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // FFB_KeyAssignmentState
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_24_3);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_24_3,thisval);
}

on envVar P_FSG_82_0_0_24_3 // IAA_FFB_Key_Status.FFB_KeyAssignmentState
{
    byte superval[6];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // FFB_KeyAssignmentState
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_24_3_0, 1);
    else
        putValue(P_FSG_82_0_0_24_3_0, 0);

    // Update superval
    getValue(P_FSG_82_0_0_24, superval);
    superval[2]=thisval;
    putValue(P_FSG_82_0_0_24,superval);
}

on envVar P_FSG_82_0_0_24_4 // IAA_FFB_Key_Status.FFB_KeyAssignmentMode
{
    byte superval[6];

    //Update Childvalue (Enum)
    byte thisval; // FFB_KeyAssignmentMode
    thisval = getValue(this);

    // Update superval
    getValue(P_FSG_82_0_0_24, superval);
    superval[3]=thisval;
    putValue(P_FSG_82_0_0_24,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_24_5_range // IAA_FFB_Key_Status.Extension1
{
    @P_FSG_82_0_0_24_5 = @P_FSG_82_0_0_24_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_24_5 // IAA_FFB_Key_Status.Extension1
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension1
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_24_5_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_24, superval);
    superval[4]=thisval;
    putValue(P_FSG_82_0_0_24,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_24_6_range // IAA_FFB_Key_Status.Extension2
{
    @P_FSG_82_0_0_24_6 = @P_FSG_82_0_0_24_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_24_6 // IAA_FFB_Key_Status.Extension2
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension2
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_24_6_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_24, superval);
    superval[5]=thisval;
    putValue(P_FSG_82_0_0_24,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_25_ErrCode
{
       if(gP_FSG_82_0_0_25_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_25", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_25_ErrCode = 1;
}
on envVar P_FSG_82_0_0_25Status_BTN
{
    byte BAPTemp[6];
   if (P_FSG_82_0_0_25Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_82_0_0_25_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_25",MakeRGB(255,255,255));
      P_FSG_82_0_0_25Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_82_0_0_25, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_82_0_0_25_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_25));
      P_FSG_82_0_0_25Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_82_0_0_25_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_25_ID;
    data[2]=getValue(P_FSG_82_0_0_25_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_25
on envVar P_FSG_82_0_0_25_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_25",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_25",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_25",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_25", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_25",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_25",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_25",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_25", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_82_0_0_25 // bus value of IAA_ASG_Sync_Status (25).
{
    // opcodes: Error-Status
    byte param1; // ASG_1_OperationalStatus
    byte param2; // ASG_2_OperationalStatus
    byte param3; // ASG_3_OperationalStatus
    byte param4; // Extension1
    byte param5; // Extension2
    byte param6; // Extension3
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[6];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 6; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_25, superval);
    ///////// Start param1 - UINT8 /////////
    param1 = superval[currentPos++];
    putValue(P_FSG_82_0_0_25_1, param1);
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_82_0_0_25_2, param2);
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_25_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_82_0_0_25_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_25_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_82_0_0_25_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_82_0_0_25_1 // IAA_ASG_Sync_Status.ASG_1_OperationalStatus
{
    byte superval[6];

    //Update Childvalue (Enum)
    byte thisval; // ASG_1_OperationalStatus
    thisval = getValue(this);

    // Update superval
    getValue(P_FSG_82_0_0_25, superval);
    superval[0]=thisval;
    putValue(P_FSG_82_0_0_25,superval);
}

on envVar P_FSG_82_0_0_25_2 // IAA_ASG_Sync_Status.ASG_2_OperationalStatus
{
    byte superval[6];

    //Update Childvalue (Enum)
    byte thisval; // ASG_2_OperationalStatus
    thisval = getValue(this);

    // Update superval
    getValue(P_FSG_82_0_0_25, superval);
    superval[1]=thisval;
    putValue(P_FSG_82_0_0_25,superval);
}

on envVar P_FSG_82_0_0_25_3 // IAA_ASG_Sync_Status.ASG_3_OperationalStatus
{
    byte superval[6];

    //Update Childvalue (Enum)
    byte thisval; // ASG_3_OperationalStatus
    thisval = getValue(this);

    // Update superval
    getValue(P_FSG_82_0_0_25, superval);
    superval[2]=thisval;
    putValue(P_FSG_82_0_0_25,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_25_4_range // IAA_ASG_Sync_Status.Extension1
{
    @P_FSG_82_0_0_25_4 = @P_FSG_82_0_0_25_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_25_4 // IAA_ASG_Sync_Status.Extension1
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension1
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_25_4_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_25, superval);
    superval[3]=thisval;
    putValue(P_FSG_82_0_0_25,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_25_5_range // IAA_ASG_Sync_Status.Extension2
{
    @P_FSG_82_0_0_25_5 = @P_FSG_82_0_0_25_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_25_5 // IAA_ASG_Sync_Status.Extension2
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension2
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_25_5_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_25, superval);
    superval[4]=thisval;
    putValue(P_FSG_82_0_0_25,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_25_6_range // IAA_ASG_Sync_Status.Extension3
{
    @P_FSG_82_0_0_25_6 = @P_FSG_82_0_0_25_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_25_6 // IAA_ASG_Sync_Status.Extension3
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension3
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_25_6_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_25, superval);
    superval[5]=thisval;
    putValue(P_FSG_82_0_0_25,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_26_ErrCode
{
       if(gP_FSG_82_0_0_26_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_26", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_26_ErrCode = 1;
}
on envVar P_FSG_82_0_0_26Status_BTN
{
    byte BAPTemp[142];
    if (P_FSG_82_0_0_26Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_82_0_0_26_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_26",MakeRGB(255,255,255));
        P_FSG_82_0_0_26Status_BTN_already_pressed = 1;
    }
    else
    {
        P_FSG_82_0_0_26_BuildFct();
        getValue(P_FSG_82_0_0_26, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_82_0_0_26_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_26));
        if(getValue(P_FSG_82_0_0_26_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_82_0_0_26_ID);
        }
        if(getValue(P_FSG_82_0_0_26_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_82_0_0_26_ID,elCount(BAPTemp));
        }
       P_FSG_82_0_0_26Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_82_0_0_26_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_26_ID;
    data[2]=getValue(P_FSG_82_0_0_26_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_26
on envVar P_FSG_82_0_0_26_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_26",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_26",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_26",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_26", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_26",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_26",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_26",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_26", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_26_IntTlgEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_26_SegmEn,0);
           intertelegram_err(P_FSG_82_0_0_26_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_82_0_0_26_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_26_SegmEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_26_IntTlgEn,0);
           sequence_err(P_FSG_82_0_0_26_ID,getValueSize(P_FSG_82_0_0_26_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_82_0_0_26_ID);
       }
}
on envVar P_FSG_82_0_0_26 // bus value of N_Key_OV (26).
{
    // opcodes: Error-Status
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // OV_State
    byte param4; // HMI_State
    byte param5; // NumberOfAssociatedKeys
    byte param6; // NumberOfRequiredKeys
    byte param7; // NumberOfConfirmedKeys
    byte param8; // CurrentlyPressedKey
    byte param9; // TimeoutValue
    byte param10[130]; // OV_challenge
    word len10;
    byte cnt10;
    byte param11; // ExceptionState
    byte param12; // Extension2
    byte param13; // Extension3
    byte param14; // Extension4
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[142];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 142; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_26, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(P_FSG_82_0_0_26_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(P_FSG_82_0_0_26_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_4, param4);
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_6, round((param6 * 1.0) - (0) + (0), 1.0));
    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_7, round((param7 * 1.0) - (0) + (0), 1.0));
    ///////// Start param8 - UINT8 /////////
    param8 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_8, param8);
    ///////// Start param9 - UINT8 /////////
    param9 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_9, round((param9 * 10.0) - (10) + (10), 10.0));
    ///////// Start param10 - STRING /////////
    getValue(P_FSG_82_0_0_26_10, param10);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(128>127) /* Max Fct-Katalog Laenge: 128*/
        {
            len10 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt10 = 1;
        }
        else
        {
            len10 = 128;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_82_0_0_26 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len10 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt10 = 0;
    }

    if(len10 > 128)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len10, currentPos);
        len10 = 128;

        if(len10 < 128) cnt10 = 0;
        else cnt10 = 1;
    }

    for(i = 0; i < len10; i++)
    {
        param10[i] = superval[currentPos++];
    }

    putValue(P_FSG_82_0_0_26_10_len, len10);
    putValue(P_FSG_82_0_0_26_10_cnt, cnt10);

    putValue(P_FSG_82_0_0_26_10, param10, len10);

    ///////// Start param11 - UINT8 /////////
    param11 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_11, param11);
    ///////// Start param12 - UINT8 /////////
    param12 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_12, round((param12 * 1.0) - (0) + (0), 1.0));
    ///////// Start param13 - UINT8 /////////
    param13 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_13, round((param13 * 1.0) - (0) + (0), 1.0));
    ///////// Start param14 - UINT8 /////////
    param14 = superval[currentPos++];
    putValue(P_FSG_82_0_0_26_14, round((param14 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_FSG_82_0_0_26_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // OV_State
    byte param4; // HMI_State
    byte param5; // NumberOfAssociatedKeys
    byte param6; // NumberOfRequiredKeys
    byte param7; // NumberOfConfirmedKeys
    byte param8; // CurrentlyPressedKey
    byte param9; // TimeoutValue
    byte param10[130]; // OV_challenge
    word len10;
    byte cnt10;
    byte param11; // ExceptionState
    byte param12; // Extension2
    byte param13; // Extension3
    byte param14; // Extension4

    dword i;
    byte superval[142];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(P_FSG_82_0_0_26_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_26_2_range = round(@P_FSG_82_0_0_26_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    param3 = getValue(P_FSG_82_0_0_26_3);
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    param4 = getValue(P_FSG_82_0_0_26_4);
    superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_26_5_range = round(@P_FSG_82_0_0_26_5 + (0), 1.0); // slider value + min = real value
    param5 = (@P_FSG_82_0_0_26_5 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_26_6_range = round(@P_FSG_82_0_0_26_6 + (0), 1.0); // slider value + min = real value
    param6 = (@P_FSG_82_0_0_26_6 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_26_7_range = round(@P_FSG_82_0_0_26_7 + (0), 1.0); // slider value + min = real value
    param7 = (@P_FSG_82_0_0_26_7 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param7;
// gen_BuildFunc_SetSuperVals
    param8 = getValue(P_FSG_82_0_0_26_8);
    @P_FSG_82_0_0_26_8_0 = (param8 & 1) > 0;
    @P_FSG_82_0_0_26_8_1 = (param8 & 2) > 0;
    @P_FSG_82_0_0_26_8_2 = (param8 & 4) > 0;
    @P_FSG_82_0_0_26_8_3 = (param8 & 8) > 0;
    @P_FSG_82_0_0_26_8_4 = (param8 & 16) > 0;
    @P_FSG_82_0_0_26_8_5 = (param8 & 32) > 0;
    @P_FSG_82_0_0_26_8_6 = (param8 & 64) > 0;
    @P_FSG_82_0_0_26_8_7 = (param8 & 128) > 0;
    superval[currentPos++]=param8;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_26_9_range = round(@P_FSG_82_0_0_26_9 + (10), 10.0); // slider value + min = real value
    param9 = (@P_FSG_82_0_0_26_9 + (10) - (10)) / (10.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param9;
// gen_BuildFunc_SetSuperVals
    getValue(P_FSG_82_0_0_26_10, param10);
    len10 = getValue(P_FSG_82_0_0_26_10_len);
    cnt10= getValue(P_FSG_82_0_0_26_10_cnt);

    /* check box aktiviert*/
    if (cnt10 == 1)
    {
        /* 0 bis 128 (MaxString - 1B oder 2B) */
        if(len10 >= 0 && len10 <= 128)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len10: %d", len10);
            superval[currentPos] = ((len10>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len10 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_26_10 ist ungueltig. Die max. erlaubte Laenge ist %d.", len10, 128);
            return;
        }
    }
    else if(cnt10 == 0) /*check box deaktiviert*/
    {
        if(len10 >= 0 && len10 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len10: %d", len10);
            superval[currentPos]= len10 & 0x00ff;
            putValue(P_FSG_82_0_0_26_10_len, len10);
        }
        else if(len10 > 127 && len10 <= 128)
        {
            superval[currentPos] = ((len10>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len10 & 0x00ff;
            putValue(P_FSG_82_0_0_26_10_len, len10);
            putValue(P_FSG_82_0_0_26_10_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_26_10 ist ungueltig. Die max. erlaubte Laenge ist %d.", len10, 128);
            return;
        }
    }
    currentPos += cnt10+1;
    for(i = 0; i < len10; i++)
    {
        superval[currentPos++]= param10[i];
    }

// gen_BuildFunc_SetSuperVals
    param11 = getValue(P_FSG_82_0_0_26_11);
    superval[currentPos++]=param11;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_26_12_range = round(@P_FSG_82_0_0_26_12 + (0), 1.0); // slider value + min = real value
    param12 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param12;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_26_13_range = round(@P_FSG_82_0_0_26_13 + (0), 1.0); // slider value + min = real value
    param13 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param13;
// gen_BuildFunc_SetSuperVals
    @P_FSG_82_0_0_26_14_range = round(@P_FSG_82_0_0_26_14 + (0), 1.0); // slider value + min = real value
    param14 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param14;
    putValue(P_FSG_82_0_0_26, superval, currentPos);
}


on envVar P_FSG_82_0_0_26_1 // N_Key_OV.ASG_ID
{
    P_FSG_82_0_0_26_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_26_2_range // N_Key_OV.Extension1
{
    @P_FSG_82_0_0_26_2 = @P_FSG_82_0_0_26_2_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_26_2 // N_Key_OV.Extension1
{
    P_FSG_82_0_0_26_BuildFct();
}

on envVar P_FSG_82_0_0_26_3 // N_Key_OV.OV_State
{
    P_FSG_82_0_0_26_BuildFct();
}

on envVar P_FSG_82_0_0_26_4 // N_Key_OV.HMI_State
{
    P_FSG_82_0_0_26_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_26_5_range // N_Key_OV.NumberOfAssociatedKeys
{
    @P_FSG_82_0_0_26_5 = @P_FSG_82_0_0_26_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_26_5 // N_Key_OV.NumberOfAssociatedKeys
{
    P_FSG_82_0_0_26_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_26_6_range // N_Key_OV.NumberOfRequiredKeys
{
    @P_FSG_82_0_0_26_6 = @P_FSG_82_0_0_26_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_26_6 // N_Key_OV.NumberOfRequiredKeys
{
    P_FSG_82_0_0_26_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_26_7_range // N_Key_OV.NumberOfConfirmedKeys
{
    @P_FSG_82_0_0_26_7 = @P_FSG_82_0_0_26_7_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_26_7 // N_Key_OV.NumberOfConfirmedKeys
{
    P_FSG_82_0_0_26_BuildFct();
}

on envVar P_FSG_82_0_0_26_8_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // CurrentlyPressedKey
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_26_8);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_26_8,thisval);
}

on envVar P_FSG_82_0_0_26_8_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // CurrentlyPressedKey
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_26_8);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_26_8,thisval);
}

on envVar P_FSG_82_0_0_26_8_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // CurrentlyPressedKey
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_26_8);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_26_8,thisval);
}

on envVar P_FSG_82_0_0_26_8_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // CurrentlyPressedKey
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_26_8);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_26_8,thisval);
}

on envVar P_FSG_82_0_0_26_8_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // CurrentlyPressedKey
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_26_8);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_26_8,thisval);
}

on envVar P_FSG_82_0_0_26_8_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // CurrentlyPressedKey
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_26_8);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_26_8,thisval);
}

on envVar P_FSG_82_0_0_26_8_6
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // CurrentlyPressedKey
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_26_8);
    thisval = thisval&~(1<<6)|(bitval<<6);
    putValue(P_FSG_82_0_0_26_8,thisval);
}

on envVar P_FSG_82_0_0_26_8_7
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // CurrentlyPressedKey
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_26_8);
    thisval = thisval&~(1<<7)|(bitval<<7);
    putValue(P_FSG_82_0_0_26_8,thisval);
}

on envVar P_FSG_82_0_0_26_8 // N_Key_OV.CurrentlyPressedKey
{
    P_FSG_82_0_0_26_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_26_9_range // N_Key_OV.TimeoutValue
{
    @P_FSG_82_0_0_26_9 = @P_FSG_82_0_0_26_9_range - (10); // slider = range - min
}

on envVar P_FSG_82_0_0_26_9 // N_Key_OV.TimeoutValue
{
    P_FSG_82_0_0_26_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_82_0_0_26_10_cnt
{
    word len;
    byte cnt;
    len = getValue(P_FSG_82_0_0_26_10_len);
    cnt = getValue(P_FSG_82_0_0_26_10_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(P_FSG_82_0_0_26_10_len, 127);
        }
    }

    P_FSG_82_0_0_26_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_82_0_0_26_10_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 128)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_26_10 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 128);
        putValue(this, 128);
    }
    P_FSG_82_0_0_26_BuildFct();
}


on envVar P_FSG_82_0_0_26_10 // N_Key_OV.OV_challenge
{
    putValue(P_FSG_82_0_0_26_10_len, getValueSize(this));
    P_FSG_82_0_0_26_BuildFct();
}

on envVar P_FSG_82_0_0_26_11 // N_Key_OV.ExceptionState
{
    P_FSG_82_0_0_26_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_26_12_range // N_Key_OV.Extension2
{
    @P_FSG_82_0_0_26_12 = @P_FSG_82_0_0_26_12_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_26_12 // N_Key_OV.Extension2
{
    P_FSG_82_0_0_26_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_26_13_range // N_Key_OV.Extension3
{
    @P_FSG_82_0_0_26_13 = @P_FSG_82_0_0_26_13_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_26_13 // N_Key_OV.Extension3
{
    P_FSG_82_0_0_26_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_26_14_range // N_Key_OV.Extension4
{
    @P_FSG_82_0_0_26_14 = @P_FSG_82_0_0_26_14_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_26_14 // N_Key_OV.Extension4
{
    P_FSG_82_0_0_26_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_27_ErrCode
{
       if(gP_FSG_82_0_0_27_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_27", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_27_ErrCode = 1;
}
on envVar P_FSG_82_0_0_27Status_BTN
{
    byte BAPTemp[260];
    if (P_FSG_82_0_0_27Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_82_0_0_27_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_27",MakeRGB(255,255,255));
        P_FSG_82_0_0_27Status_BTN_already_pressed = 1;
    }
    else
    {
        P_FSG_82_0_0_27_BuildFct();
        getValue(P_FSG_82_0_0_27, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_82_0_0_27_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_27));
        if(getValue(P_FSG_82_0_0_27_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_82_0_0_27_ID);
        }
        if(getValue(P_FSG_82_0_0_27_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_82_0_0_27_ID,elCount(BAPTemp));
        }
       P_FSG_82_0_0_27Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_82_0_0_27_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_27_ID;
    data[2]=getValue(P_FSG_82_0_0_27_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_27
on envVar P_FSG_82_0_0_27_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_27",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_27",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_27",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_27", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_27",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_27",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_27",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_27", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_27_IntTlgEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_27_SegmEn,0);
           intertelegram_err(P_FSG_82_0_0_27_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_82_0_0_27_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_27_SegmEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_27_IntTlgEn,0);
           sequence_err(P_FSG_82_0_0_27_ID,getValueSize(P_FSG_82_0_0_27_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_82_0_0_27_ID);
       }
}
on envVar P_FSG_82_0_0_27 // bus value of N_Key_InCarMutualAuth (27).
{
    // opcodes: Error-Status
    byte param1[130]; // ASG_A_Challenge
    word len1;
    byte cnt1;
    byte param2[130]; // ASG_B_Signature
    word len2;
    byte cnt2;
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[260];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 260; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_27, superval);
    ///////// Start param1 - STRING /////////
    getValue(P_FSG_82_0_0_27_1, param1);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(128>127) /* Max Fct-Katalog Laenge: 128*/
        {
            len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt1 = 1;
        }
        else
        {
            len1 = 128;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_82_0_0_27 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len1 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt1 = 0;
    }

    if(len1 > 128)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
        len1 = 128;

        if(len1 < 128) cnt1 = 0;
        else cnt1 = 1;
    }

    for(i = 0; i < len1; i++)
    {
        param1[i] = superval[currentPos++];
    }

    putValue(P_FSG_82_0_0_27_1_len, len1);
    putValue(P_FSG_82_0_0_27_1_cnt, cnt1);

    putValue(P_FSG_82_0_0_27_1, param1, len1);

    ///////// Start param2 - STRING /////////
    getValue(P_FSG_82_0_0_27_2, param2);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(128>127) /* Max Fct-Katalog Laenge: 128*/
        {
            len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt2 = 1;
        }
        else
        {
            len2 = 128;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_82_0_0_27 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len2 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt2 = 0;
    }

    if(len2 > 128)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
        len2 = 128;

        if(len2 < 128) cnt2 = 0;
        else cnt2 = 1;
    }

    for(i = 0; i < len2; i++)
    {
        param2[i] = superval[currentPos++];
    }

    putValue(P_FSG_82_0_0_27_2_len, len2);
    putValue(P_FSG_82_0_0_27_2_cnt, cnt2);

    putValue(P_FSG_82_0_0_27_2, param2, len2);

}

// Updates the bus value field and other dependencies.
P_FSG_82_0_0_27_BuildFct()
{
    byte param1[130]; // ASG_A_Challenge
    word len1;
    byte cnt1;
    byte param2[130]; // ASG_B_Signature
    word len2;
    byte cnt2;

    dword i;
    byte superval[260];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    getValue(P_FSG_82_0_0_27_1, param1);
    len1 = getValue(P_FSG_82_0_0_27_1_len);
    cnt1= getValue(P_FSG_82_0_0_27_1_cnt);

    /* check box aktiviert*/
    if (cnt1 == 1)
    {
        /* 0 bis 128 (MaxString - 1B oder 2B) */
        if(len1 >= 0 && len1 <= 128)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
            superval[currentPos] = ((len1>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len1 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_27_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 128);
            return;
        }
    }
    else if(cnt1 == 0) /*check box deaktiviert*/
    {
        if(len1 >= 0 && len1 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
            superval[currentPos]= len1 & 0x00ff;
            putValue(P_FSG_82_0_0_27_1_len, len1);
        }
        else if(len1 > 127 && len1 <= 128)
        {
            superval[currentPos] = ((len1>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len1 & 0x00ff;
            putValue(P_FSG_82_0_0_27_1_len, len1);
            putValue(P_FSG_82_0_0_27_1_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_27_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 128);
            return;
        }
    }
    currentPos += cnt1+1;
    for(i = 0; i < len1; i++)
    {
        superval[currentPos++]= param1[i];
    }

// gen_BuildFunc_SetSuperVals
    getValue(P_FSG_82_0_0_27_2, param2);
    len2 = getValue(P_FSG_82_0_0_27_2_len);
    cnt2= getValue(P_FSG_82_0_0_27_2_cnt);

    /* check box aktiviert*/
    if (cnt2 == 1)
    {
        /* 0 bis 128 (MaxString - 1B oder 2B) */
        if(len2 >= 0 && len2 <= 128)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
            superval[currentPos] = ((len2>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len2 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_27_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 128);
            return;
        }
    }
    else if(cnt2 == 0) /*check box deaktiviert*/
    {
        if(len2 >= 0 && len2 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
            superval[currentPos]= len2 & 0x00ff;
            putValue(P_FSG_82_0_0_27_2_len, len2);
        }
        else if(len2 > 127 && len2 <= 128)
        {
            superval[currentPos] = ((len2>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len2 & 0x00ff;
            putValue(P_FSG_82_0_0_27_2_len, len2);
            putValue(P_FSG_82_0_0_27_2_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_27_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 128);
            return;
        }
    }
    currentPos += cnt2+1;
    for(i = 0; i < len2; i++)
    {
        superval[currentPos++]= param2[i];
    }

    putValue(P_FSG_82_0_0_27, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_82_0_0_27_1_cnt
{
    word len;
    byte cnt;
    len = getValue(P_FSG_82_0_0_27_1_len);
    cnt = getValue(P_FSG_82_0_0_27_1_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(P_FSG_82_0_0_27_1_len, 127);
        }
    }

    P_FSG_82_0_0_27_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_82_0_0_27_1_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 128)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_27_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 128);
        putValue(this, 128);
    }
    P_FSG_82_0_0_27_BuildFct();
}


on envVar P_FSG_82_0_0_27_1 // N_Key_InCarMutualAuth.ASG_A_Challenge
{
    putValue(P_FSG_82_0_0_27_1_len, getValueSize(this));
    P_FSG_82_0_0_27_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_82_0_0_27_2_cnt
{
    word len;
    byte cnt;
    len = getValue(P_FSG_82_0_0_27_2_len);
    cnt = getValue(P_FSG_82_0_0_27_2_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(P_FSG_82_0_0_27_2_len, 127);
        }
    }

    P_FSG_82_0_0_27_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_82_0_0_27_2_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 128)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_27_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 128);
        putValue(this, 128);
    }
    P_FSG_82_0_0_27_BuildFct();
}


on envVar P_FSG_82_0_0_27_2 // N_Key_InCarMutualAuth.ASG_B_Signature
{
    putValue(P_FSG_82_0_0_27_2_len, getValueSize(this));
    P_FSG_82_0_0_27_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_82_0_0_28_ErrCode
{
       if(gA_FSG_82_0_0_28_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_A_FSG_82_0_0_28", MakeRGB(255,255,255));
       }
       gA_FSG_82_0_0_28_ErrCode = 1;
}
on envVar A_FSG_82_0_0_28Changed_BTN
{
    byte data[165];
    byte stringValue[165];
    byte head[5];
    dword i;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_82_0_0_28Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_82_0_0_28_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_82_0_0_28",MakeRGB(255,255,255));
        A_FSG_82_0_0_28Changed_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_82_0_0_28_Changed);
        getValue(A_FSG_82_0_0_28_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_82_0_0_28_Changed_Start);
     elementsVal = getValue(A_FSG_82_0_0_28_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_82_0_0_28_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 28");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_82_0_0_28_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_82_0_0_28_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 28");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_82_0_0_28_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_82_0_0_28_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_82_0_0_28_ID);
       }
       if(getValue(A_FSG_82_0_0_28_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_82_0_0_28_ID,getValueSize(A_FSG_82_0_0_28_Changed));
       }
        A_FSG_82_0_0_28Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_82_0_0_28Status_BTN
{
    byte data[165 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[165];
    byte head[5];
    dword i = 0;
    dword j = 0;
    dword StringLength = 0;
    int headLength;
    long tempValue;
    dword currentPos;
    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_82_0_0_28Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_82_0_0_28_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_82_0_0_28",MakeRGB(255,255,255));
        A_FSG_82_0_0_28Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_82_0_0_28_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_82_0_0_28_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_82_0_0_28_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_82_0_0_28);
        getValue(A_FSG_82_0_0_28,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_82_0_0_28_Start);
     elementsVal = getValue(A_FSG_82_0_0_28_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_82_0_0_28_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 28");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable KeyType:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable KeyReference:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_28_ArrayDataList[i].Param3_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_28_Data_3_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_28_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_28_Data_3_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_28_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable IAA_UserID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param4 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_82_0_0_28_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_82_0_0_28_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 28");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable KeyType:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable KeyReference:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_28_ArrayDataList[i].Param3_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_28_Data_3_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_28_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_28_Data_3_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_28_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable IAA_UserID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param4 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_82_0_0_28, data);
        Request_ByteSequence(LSGID, A_FSG_82_0_0_28_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_82_0_0_28_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_82_0_0_28_ID);
        }
        if(getValue(A_FSG_82_0_0_28_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_82_0_0_28_ID,getValueSize(A_FSG_82_0_0_28));
        }
        A_FSG_82_0_0_28Status_BTN_already_pressed = 0;
    }
}
A_FSG_82_0_0_28_SendStatus()
{
    dword currentPos;
    word headLength;
    dword i;
    dword j;
    dword StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[165];
    byte stringValue[165];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_82_0_0_28_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_82_0_0_28_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_82_0_0_28_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_82_0_0_28);
        getValue(A_FSG_82_0_0_28,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_82_0_0_28_Start);
     elementsVal = getValue(A_FSG_82_0_0_28_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_82_0_0_28_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 28");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable KeyType:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable KeyReference:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_28_ArrayDataList[i].Param3_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_28_Data_3_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_28_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_28_Data_3_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_28_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable IAA_UserID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param4 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_82_0_0_28_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_82_0_0_28_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 28");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable KeyType:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param2 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable KeyReference:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_82_0_0_28_ArrayDataList[i].Param3_Length;
        /* Pruefung ob die Laenge-Checkbox aktiv ist */
        if (1 == A_FSG_82_0_0_28_Data_3_CntList[i] )
        {
            if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 17-2)
            {
                data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
                data[currentPos++] = StringLength &0xFF;
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_28_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 17-2);
                return;
            }
        }
        else if(0 == A_FSG_82_0_0_28_Data_3_CntList[i] ) /*check box deaktiviert*/
        {
            if(StringLength >= 0 && StringLength <= 127 && StringLength <= 17-1)
            {
                data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
            }
            else
            {
                writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_28_Data_3 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 17-1);
                return;
            }
        }
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_82_0_0_28_ArrayDataList[i].Param3[j];
        }
       }
      // Check if the current value of RecAdr enables the variable IAA_UserID:
      if( 0 || 1 == getValue( A_FSG_82_0_0_28_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_82_0_0_28_ArrayDataList[i].Param4 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_82_0_0_28_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_82_0_0_28
{
    byte temp[165];
    getValue(A_FSG_82_0_0_28, temp);
    putValue(A_FSG_82_0_0_28_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_82_0_0_28_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_82_0_0_28_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_82_0_0_28_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_82_0_0_28_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_82_0_0_28_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_82_0_0_28_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_82_0_0_28_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_82_0_0_28_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_82_0_0_28_IndexSize))
    {
        putValue(A_FSG_82_0_0_28_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_82_0_0_28_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_82_0_0_28_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_82_0_0_28_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_82_0_0_28_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_82_0_0_28_RecAdr) > 0x0F)
        putValue(A_FSG_82_0_0_28_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_82_0_0_28_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_82_0_0_28_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_82_0_0_28_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_82_0_0_28_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_82_0_0_28_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_82_0_0_28_Start) & 0xFF;
        head[2] = (getValue(A_FSG_82_0_0_28_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_82_0_0_28_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_82_0_0_28_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_82_0_0_28_Start) & 0xFF;
        head[2] = getValue(A_FSG_82_0_0_28_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_82_0_0_28, head, headLength);
}

on envVar A_FSG_82_0_0_28_RecAdr
{
    A_FSG_82_0_0_28_GenerateStatus();
}

on envVar A_FSG_82_0_0_28_Shift
{
    A_FSG_82_0_0_28_GenerateStatus();
}

on envVar A_FSG_82_0_0_28_Direction
{
    A_FSG_82_0_0_28_GenerateStatus();
}

on envVar A_FSG_82_0_0_28_Start
{
    A_FSG_82_0_0_28_GenerateStatus();
}

on envVar A_FSG_82_0_0_28_Elements
{
    A_FSG_82_0_0_28_GenerateStatus();
}

on envVar A_FSG_82_0_0_28_IndexSize
{
    A_FSG_82_0_0_28_GenerateStatus();
}
on envVar A_FSG_82_0_0_28_TransPos
{
    A_FSG_82_0_0_28_GenerateStatus();
}
A_FSG_82_0_0_28_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_82_0_0_28_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_82_0_0_28_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_82_0_0_28_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_82_0_0_28_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_82_0_0_28_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_82_0_0_28_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_82_0_0_28_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_82_0_0_28_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_82_0_0_28_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_82_0_0_28_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_82_0_0_28_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_82_0_0_28_Changed, head, 5);
    }
    else
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_82_0_0_28_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_82_0_0_28_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_82_0_0_28_Changed, head, 3);
    }
}

on envVar A_FSG_82_0_0_28_Changed_RecAdr
{
    A_FSG_82_0_0_28_Changed_GenerateChanged();
}

on envVar A_FSG_82_0_0_28_Changed_Shift
{
    A_FSG_82_0_0_28_Changed_GenerateChanged();
}

on envVar A_FSG_82_0_0_28_Changed_Direction
{
    A_FSG_82_0_0_28_Changed_GenerateChanged();
}

on envVar A_FSG_82_0_0_28_Changed_Start
{
    A_FSG_82_0_0_28_Changed_GenerateChanged();
}

on envVar A_FSG_82_0_0_28_Changed_Elements
{
    A_FSG_82_0_0_28_Changed_GenerateChanged();
}

on envVar A_FSG_82_0_0_28_Changed_IndexSize
{
    A_FSG_82_0_0_28_Changed_GenerateChanged();
}
on envVar A_FSG_82_0_0_28_Changed_TransPos
{
    A_FSG_82_0_0_28_Changed_GenerateChanged();
}
on envVar A_FSG_82_0_0_28_SetGet
{
    byte temp[165];
    getValue(A_FSG_82_0_0_28_SetGet, temp);
    putValue(A_FSG_82_0_0_28_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_82_0_0_28_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_82_0_0_28_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_82_0_0_28_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_82_0_0_28_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_82_0_0_28_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_82_0_0_28_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_82_0_0_28_SetGet_IndexSize))
    {
        putValue(A_FSG_82_0_0_28_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_82_0_0_28_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_82_0_0_28_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_82_0_0_28_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_82_0_0_28_LoadArray()
{
    /********* Statische Deklarationen ***********/
    dword CSVfileHandle;
    dword filePos;
    dword paramPos;
    dword Num_of_csv_byte;
    dword element;
    dword current_CSV_line;
    byte buffer_byte[0xFFFF];
    dword i;
    dword j;
    char CSV_filename[255];
    char CSV_path[255];
    char CSV_file[255];

    /********* Param Puffer Deklarationen ***********/
    char temp1[25];
    char temp2[25];
    char temp4[25];

    /********* Initialisierungen ***********/
    CSVfileHandle = 0;
    filePos = 0;
    paramPos = 0;
    Num_of_csv_byte = 0;
    element = 1;
    current_CSV_line = 0;
    for(i = 0; i < A_FSG_82_0_0_28_ArrayDataList_Length; i++)
    { /* Initialisierung von den Ziel-Strukturen */
        A_FSG_82_0_0_28_ArrayDataList[i].Param1 = 0;
        A_FSG_82_0_0_28_ArrayDataList[i].Param2 = 0;
        for(j=0; j<17; j++)
            A_FSG_82_0_0_28_ArrayDataList[i].Param3[j] = 0;
        A_FSG_82_0_0_28_ArrayDataList[i].Param3_Length = 0;
        A_FSG_82_0_0_28_Data_3_LenList[i] = 0;
        A_FSG_82_0_0_28_ArrayDataList[i].Param4 = 0;
    }

    /********* Laden der CSV-Datei ***********/
    getValue(A_FSG_82_0_0_28_fileSelector, CSV_filename);
    SplitFullFileName(CSV_filename, CSV_path, CSV_file );
    setFilePath(CSV_path, 0);
    CSVfileHandle = openFileRead(CSV_file, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

    if (CSVfileHandle!=0) //*.csv file access successful
    {
        writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
        //get data from *.csv and store the total number of byte in *.csv-file
        Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

        for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
        {
            if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
            {
                //nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
                {
                    if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
                    {
                        A_FSG_82_0_0_28_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
                        A_FSG_82_0_0_28_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //KeyType
                        A_FSG_82_0_0_28_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //IAA_UserID
                        for(i = 0; i < 25; i++)
                        { /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
                            temp1[i]=0;
                            temp2[i]=0;
                            temp4[i]=0;
                        }
                    }
                    current_CSV_line++; //next line in *.csv file
                    element = 1; //start at 'POS' (first record element of "array data")
                    paramPos = 0; //reset value
                }
                 //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                else if(current_CSV_line > 0 && current_CSV_line < 256)
                {
                    //writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
                    switch (element)
                    {
                        case 1: //Pos
                                if( paramPos >= elCount(temp1) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp1[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 2: //KeyType
                                if( paramPos >= elCount(temp2) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp2[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        case 3: //KeyReference
                                if(paramPos < 16)
                                {
                                    A_FSG_82_0_0_28_ArrayDataList[current_CSV_line-1].Param3[paramPos] = buffer_byte[filePos];
                                    A_FSG_82_0_0_28_ArrayDataList[current_CSV_line-1].Param3_Length = paramPos +1;
                                }
                                paramPos++;
                        break;
                        case 4: //IAA_UserID
                                if( paramPos >= elCount(temp4) ){
                                    writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
                                    return; //False
                                }else{
                                    temp4[paramPos] = buffer_byte[filePos];
                                    paramPos++;
                                }
                            break;
                        default:
                        break;
                    }
                }
            }
            else  // ";" is detected ->next record element of "array data"
            {
                //writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
                element++;
                paramPos=0; //reset value
            }
        }

        if(fileClose (CSVfileHandle) !=0) //close *.csv file
            writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
        else
            writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
        writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
    }
}

on envVar A_FSG_82_0_0_28_loadArray_Btn
{
    char filePath[255];
    if (A_FSG_82_0_0_28_generateData_Btn_already_pressed == 0)
    {
        A_FSG_82_0_0_28_generateData_Btn_already_pressed = 1;
    }
    else
    {
        A_FSG_82_0_0_28_generateData_Btn_already_pressed = 0;
        getValue(A_FSG_82_0_0_28_fileSelector, filePath);
        if(0 == strlen(filePath))
        {
            writelineEx(gBAP_Trace, 0, "Invalid file path!");
        }
        else
        {
            A_FSG_82_0_0_28_LoadArray();
            writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
        }
        putValue(A_FSG_82_0_0_28_Data_1, A_FSG_82_0_0_28_ArrayDataList[ getValue( A_FSG_82_0_0_28_DataIndex) ].Param1);
    putValue(A_FSG_82_0_0_28_Data_2, A_FSG_82_0_0_28_ArrayDataList[ getValue( A_FSG_82_0_0_28_DataIndex) ].Param2);
    putValue(A_FSG_82_0_0_28_Data_3, A_FSG_82_0_0_28_ArrayDataList[ getValue( A_FSG_82_0_0_28_DataIndex) ].Param3, A_FSG_82_0_0_28_ArrayDataList[getValue(A_FSG_82_0_0_28_DataIndex)].Param3_Length);
    putValue(A_FSG_82_0_0_28_Data_4, A_FSG_82_0_0_28_ArrayDataList[ getValue( A_FSG_82_0_0_28_DataIndex) ].Param4);
    }
}


on envVar A_FSG_82_0_0_28_generateData_Btn
{
    word i;
    dword elementsArray[5] = {1, 1, 17, 2, 1};
    byte elementsTypeArray[5] = {0, 0, 0xE, 0xF, 0};
    dword elementsMaxSizeArray[5] = {255, 0xFF, 0, 0, 255};
    byte tempArray[5610];
    if (A_FSG_82_0_0_28_generateData_Btn_already_pressed == 0)
    {
        A_FSG_82_0_0_28_generateData_Btn_already_pressed = 1;
    }
    else
    {
        initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 28, 255 );
        for(i = 0; i < 255; i++)
        {
            memcpy(A_FSG_82_0_0_28_ArrayDataList[i], tempArray, (i * 22) );
            if(A_FSG_82_0_0_28_ArrayDataList[i].Param3_Length > 127 )
                A_FSG_82_0_0_28_Data_3_CntList[i] = 1;
        }
        A_FSG_82_0_0_28_generateData_Btn_already_pressed = 0;
    putValue(A_FSG_82_0_0_28_Data_1, A_FSG_82_0_0_28_ArrayDataList[ getValue( A_FSG_82_0_0_28_DataIndex) ].Param1);
    putValue(A_FSG_82_0_0_28_Data_2, A_FSG_82_0_0_28_ArrayDataList[ getValue( A_FSG_82_0_0_28_DataIndex) ].Param2);
    putValue(A_FSG_82_0_0_28_Data_3, A_FSG_82_0_0_28_ArrayDataList[ getValue( A_FSG_82_0_0_28_DataIndex) ].Param3, A_FSG_82_0_0_28_ArrayDataList[getValue(A_FSG_82_0_0_28_DataIndex)].Param3_Length);
    putValue(A_FSG_82_0_0_28_Data_4, A_FSG_82_0_0_28_ArrayDataList[ getValue( A_FSG_82_0_0_28_DataIndex) ].Param4);
    }
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_82_0_0_28_DataIndex
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_82_0_0_28_Data_1, A_FSG_82_0_0_28_ArrayDataList[index].Param1*(1.0)-(0.0));
    putValue(A_FSG_82_0_0_28_Data_2, A_FSG_82_0_0_28_ArrayDataList[index].Param2);
    putValue(A_FSG_82_0_0_28_Data_3_len, A_FSG_82_0_0_28_Data_3_LenList[index]);
    putValue(A_FSG_82_0_0_28_Data_3_cnt, A_FSG_82_0_0_28_Data_3_CntList[index]);
    putValue(A_FSG_82_0_0_28_Data_3, A_FSG_82_0_0_28_ArrayDataList[index].Param3, A_FSG_82_0_0_28_ArrayDataList[index].Param3_Length);
    putValue(A_FSG_82_0_0_28_Data_4, A_FSG_82_0_0_28_ArrayDataList[index].Param4*(1.0)-(0.0));

}
on envVar A_FSG_82_0_0_28_DataIndex_Incr
{
    long index;
    if(A_FSG_82_0_0_28_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_82_0_0_28_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_82_0_0_28_DataIndex);
        index++;
        putValue(A_FSG_82_0_0_28_DataIndex, index);
        A_FSG_82_0_0_28_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_82_0_0_28_DataIndex_Decr
{
    long index;
    if(A_FSG_82_0_0_28_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_82_0_0_28_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_82_0_0_28_DataIndex);
        index--;
        putValue(A_FSG_82_0_0_28_DataIndex, index);
        A_FSG_82_0_0_28_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_82_0_0_28_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_82_0_0_28_ID;
    data[2]=getValue(A_FSG_82_0_0_28_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_82_0_0_28
on envVar A_FSG_82_0_0_28_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_28",1);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_82_0_0_28",1);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_28",1);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_28_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_82_0_0_28", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_28",0);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_82_0_0_28",0);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_28",0);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_82_0_0_28_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_82_0_0_28", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_82_0_0_28_IntTlgEn
{
       if(getValue(this))
       {
           putValue(A_FSG_82_0_0_28_SegmEn,0);
           intertelegram_err(A_FSG_82_0_0_28_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_82_0_0_28_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_82_0_0_28_SegmEn
{
       if(getValue(this))
       {
           putValue(A_FSG_82_0_0_28_IntTlgEn,0);
           sequence_err(A_FSG_82_0_0_28_ID,getValueSize(A_FSG_82_0_0_28_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_82_0_0_28_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_82_0_0_28_AT
{
    if(getValue(this))
    {
        EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Status",0);
    }
    else
    {
       EnableControl(panel_name,"panel_A_FSG_82_0_0_28_Status",1);
     }
}



A_FSG_82_0_0_28_SetInd () { /* leere Function*/ }

A_FSG_82_0_0_28_SetGetInd () { /* leere Function*/ }

A_FSG_82_0_0_28_GetInd()
{
    dword currentPos;
    byte head[5];
    byte stringTempValue[165];
    dword i;
    dword j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_82_0_0_28_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_82_0_0_28_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_82_0_0_28_SetGet, head, 5);
                if(getValue(A_FSG_82_0_0_28_AT))
                {
                    putValue(A_FSG_82_0_0_28,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_82_0_0_28_SetGet, head, 3);
            if(getValue(A_FSG_82_0_0_28_AT))
            {
                putValue(A_FSG_82_0_0_28,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_82_0_0_28_AT))
        {
            putValue(A_FSG_82_0_0_28_RecAdr,recordAddressVal);
            putValue(A_FSG_82_0_0_28_Start, startVal);
            putValue(A_FSG_82_0_0_28_Elements, elementsVal);
            putValue(A_FSG_82_0_0_28_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_82_0_0_28_1
{

    //Update Childvalue (Enum)
    byte thisval; // ASG_ID
    thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_28_2_range // IAA_KeyReferenceList.TAID
{
    @A_FSG_82_0_0_28_2 = @A_FSG_82_0_0_28_2_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_28_2
{

    //Update Childvalue (Number)
    byte thisval; // TAID
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_28_2, 1.0);
    @A_FSG_82_0_0_28_2_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_28_3_range // IAA_KeyReferenceList.TotalNumListElements
{
    @A_FSG_82_0_0_28_3 = @A_FSG_82_0_0_28_3_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_28_3
{

    //Update Childvalue (Number)
    byte thisval; // TotalNumListElements
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_28_3, 1.0);
    @A_FSG_82_0_0_28_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_28_Data_1_range // IAA_KeyReferenceList.Pos
{
    @A_FSG_82_0_0_28_Data_1 = @A_FSG_82_0_0_28_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_28_Data_1
{

    //Update Childvalue (Number)
    byte thisval; // Pos
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_28_Data_1, 1.0);
    @A_FSG_82_0_0_28_Data_1_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_82_0_0_28_ArrayDataList[getValue(A_FSG_82_0_0_28_DataIndex)].Param1 = thisval;
}
on envVar A_FSG_82_0_0_28_Data_2
{

    //Update Childvalue (Enum)
    byte thisval; // KeyType
    thisval = getValue(this);
    A_FSG_82_0_0_28_ArrayDataList[getValue(A_FSG_82_0_0_28_DataIndex)].Param2 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_82_0_0_28_Data_3_cnt
{
    word len;
    byte cnt;
    len = getValue(A_FSG_82_0_0_28_Data_3_len);
    cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
     A_FSG_82_0_0_28_Data_3_CntList[ getValue(A_FSG_82_0_0_28_DataIndex) ] = cnt;

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if(cnt == 0)
    {
        if(len > 127 )
        {
            putValue(A_FSG_82_0_0_28_Data_3_len, 127);
        }
    }

}


on envVar A_FSG_82_0_0_28_Data_3_len
{
    long thisval;
    byte cnt;
    thisval = getValue(this);
    cnt = getValue(A_FSG_82_0_0_28_Data_3_cnt);

    /* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
    if(thisval > 16 || thisval < 0 )
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_82_0_0_28_Data_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 16);
        thisval = 16;
    }
    if( thisval >127)
    {
        putValue(A_FSG_82_0_0_28_Data_3_cnt, 1); /* Switch checkbox on */
    }

    A_FSG_82_0_0_28_ArrayDataList[getValue(A_FSG_82_0_0_28_DataIndex)].Param3_Length = thisval;
    A_FSG_82_0_0_28_Data_3_LenList[ getValue(A_FSG_82_0_0_28_DataIndex) ] = thisval;
    putValue(A_FSG_82_0_0_28_Data_3_len, thisval);

}

on envVar A_FSG_82_0_0_28_Data_3
{

    //Update Childvalue (String)
    word i;
    byte thisval[17];
    getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_82_0_0_28_ArrayDataList[getValue(A_FSG_82_0_0_28_DataIndex)].Param3[i] = thisval[i];
    A_FSG_82_0_0_28_ArrayDataList[getValue(A_FSG_82_0_0_28_DataIndex)].Param3_Length = getValueSize(this);
    A_FSG_82_0_0_28_Data_3_LenList[getValue(A_FSG_82_0_0_28_DataIndex)]= getValueSize(this);
    putValue(A_FSG_82_0_0_28_Data_3_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_28_Data_4_range // IAA_KeyReferenceList.IAA_UserID
{
    @A_FSG_82_0_0_28_Data_4 = @A_FSG_82_0_0_28_Data_4_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_28_Data_4
{

    //Update Childvalue (Number)
    byte thisval; // IAA_UserID
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_28_Data_4, 1.0);
    @A_FSG_82_0_0_28_Data_4_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_82_0_0_28_ArrayDataList[getValue(A_FSG_82_0_0_28_DataIndex)].Param4 = thisval;
}
on envVar A_FSG_82_0_0_28_1_SetGet
{

    //Update Childvalue (Enum)
    byte thisval; // ASG_ID
    thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_82_0_0_28_2_SetGet_range // IAA_KeyReferenceList.TAID
{
    @A_FSG_82_0_0_28_2_SetGet = @A_FSG_82_0_0_28_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_82_0_0_28_2_SetGet
{

    //Update Childvalue (Number)
    byte thisval; // TAID
    float slider_value;

    slider_value = round(@A_FSG_82_0_0_28_2_SetGet, 1.0);
    @A_FSG_82_0_0_28_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_82_0_0_29_ErrCode
{
       if(gM_FSG_82_0_0_29_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_M_FSG_82_0_0_29", MakeRGB(255,255,255));
       }
       gM_FSG_82_0_0_29_ErrCode = 1;
}
on envVar M_FSG_82_0_0_29Result_BTN
{
    byte temp[137];
    if (M_FSG_82_0_0_29Result_BTN_already_pressed == 0)
    {
        putValue(M_FSG_82_0_0_29_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_FSG_82_0_0_29",MakeRGB(255,255,255));
        M_FSG_82_0_0_29Result_BTN_already_pressed = 1;
    }
    else
    {
         M_FSG_82_0_0_29_Result_BuildFct();
        putValue(M_FSG_82_0_0_29_State, "Result");
        getValue(M_FSG_82_0_0_29_Result, temp);
        Request_ByteSequence(LSGID, M_FSG_82_0_0_29_ID, Result_REQ, temp, getValueSize(M_FSG_82_0_0_29_Result));
        if(getValue(M_FSG_82_0_0_29_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(M_FSG_82_0_0_29_ID);
        }
        if(getValue(M_FSG_82_0_0_29_SegmEn))   //getvalue(SG)
        {
            sequence_err(M_FSG_82_0_0_29_ID,getValueSize(M_FSG_82_0_0_29_SegmEn));
        }
        M_FSG_82_0_0_29Result_BTN_already_pressed = 0;
    }
}
on envVar M_FSG_82_0_0_29_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_82_0_0_29_ID;
    data[2]=getValue(M_FSG_82_0_0_29_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_82_0_0_29
on envVar M_FSG_82_0_0_29_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_29",1);
           EnableControl(panel_name,"errfield_M_FSG_82_0_0_29",1);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_29",1);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_82_0_0_29", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_29",0);
           EnableControl(panel_name,"errfield_M_FSG_82_0_0_29",0);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_29",0);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_82_0_0_29_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_82_0_0_29", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar M_FSG_82_0_0_29_IntTlgEn
{
       if(getValue(this))
       {
           putValue(M_FSG_82_0_0_29_SegmEn,0);
           intertelegram_err(M_FSG_82_0_0_29_ID);
       }
       else
       {
           intertelegram_err_off(M_FSG_82_0_0_29_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar M_FSG_82_0_0_29_SegmEn
{
       if(getValue(this))
       {
           putValue(M_FSG_82_0_0_29_IntTlgEn,0);
           sequence_err(M_FSG_82_0_0_29_ID,getValueSize(M_FSG_82_0_0_29_SegmEn));
       }
       else
       {
              sequence_err_off(M_FSG_82_0_0_29_ID);
       }
}
on envVar M_FSG_82_0_0_29_Result // bus value of IAA_TriggerLocalFunction (29).
{
    // opcodes: Error-Processing-Result
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Triggerresult
    byte param5; // Resultparam1
    byte param6; // Resultparam2
    byte param7; // Resultparam3
    byte param8; // Resultparam4
    byte param9[130]; // Resultparam5
    word len9;
    byte cnt9;
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[137];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 137; i++ ) {
        superval[i] = 0;
    }
    getValue(M_FSG_82_0_0_29_Result, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(M_FSG_82_0_0_29_Result_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(M_FSG_82_0_0_29_Result_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Result_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Result_4, param4);
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Result_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Result_6, round((param6 * 1.0) - (0) + (0), 1.0));
    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Result_7, round((param7 * 1.0) - (0) + (0), 1.0));
    ///////// Start param8 - UINT8 /////////
    param8 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Result_8, round((param8 * 1.0) - (0) + (0), 1.0));
    ///////// Start param9 - STRING /////////
    getValue(M_FSG_82_0_0_29_Result_9, param9);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(128>127) /* Max Fct-Katalog Laenge: 128*/
        {
            len9 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt9 = 1;
        }
        else
        {
            len9 = 128;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_82_0_0_29_Result ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len9 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt9 = 0;
    }

    if(len9 > 128)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len9, currentPos);
        len9 = 128;

        if(len9 < 128) cnt9 = 0;
        else cnt9 = 1;
    }

    for(i = 0; i < len9; i++)
    {
        param9[i] = superval[currentPos++];
    }

    putValue(M_FSG_82_0_0_29_Result_9_len, len9);
    putValue(M_FSG_82_0_0_29_Result_9_cnt, cnt9);

    putValue(M_FSG_82_0_0_29_Result_9, param9, len9);

}

// Updates the bus value field and other dependencies.
M_FSG_82_0_0_29_Result_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Triggerresult
    byte param5; // Resultparam1
    byte param6; // Resultparam2
    byte param7; // Resultparam3
    byte param8; // Resultparam4
    byte param9[130]; // Resultparam5
    word len9;
    byte cnt9;

    dword i;
    byte superval[137];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(M_FSG_82_0_0_29_Result_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Result_2_range = round(@M_FSG_82_0_0_29_Result_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    param3 = getValue(M_FSG_82_0_0_29_Result_3);
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    param4 = getValue(M_FSG_82_0_0_29_Result_4);
    superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Result_5_range = round(@M_FSG_82_0_0_29_Result_5 + (0), 1.0); // slider value + min = real value
    param5 = (@M_FSG_82_0_0_29_Result_5 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Result_6_range = round(@M_FSG_82_0_0_29_Result_6 + (0), 1.0); // slider value + min = real value
    param6 = (@M_FSG_82_0_0_29_Result_6 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Result_7_range = round(@M_FSG_82_0_0_29_Result_7 + (0), 1.0); // slider value + min = real value
    param7 = (@M_FSG_82_0_0_29_Result_7 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param7;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Result_8_range = round(@M_FSG_82_0_0_29_Result_8 + (0), 1.0); // slider value + min = real value
    param8 = (@M_FSG_82_0_0_29_Result_8 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param8;
// gen_BuildFunc_SetSuperVals
    getValue(M_FSG_82_0_0_29_Result_9, param9);
    len9 = getValue(M_FSG_82_0_0_29_Result_9_len);
    cnt9= getValue(M_FSG_82_0_0_29_Result_9_cnt);

    /* check box aktiviert*/
    if (cnt9 == 1)
    {
        /* 0 bis 128 (MaxString - 1B oder 2B) */
        if(len9 >= 0 && len9 <= 128)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len9: %d", len9);
            superval[currentPos] = ((len9>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len9 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_29_Result_9 ist ungueltig. Die max. erlaubte Laenge ist %d.", len9, 128);
            return;
        }
    }
    else if(cnt9 == 0) /*check box deaktiviert*/
    {
        if(len9 >= 0 && len9 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len9: %d", len9);
            superval[currentPos]= len9 & 0x00ff;
            putValue(M_FSG_82_0_0_29_Result_9_len, len9);
        }
        else if(len9 > 127 && len9 <= 128)
        {
            superval[currentPos] = ((len9>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len9 & 0x00ff;
            putValue(M_FSG_82_0_0_29_Result_9_len, len9);
            putValue(M_FSG_82_0_0_29_Result_9_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_29_Result_9 ist ungueltig. Die max. erlaubte Laenge ist %d.", len9, 128);
            return;
        }
    }
    currentPos += cnt9+1;
    for(i = 0; i < len9; i++)
    {
        superval[currentPos++]= param9[i];
    }

    putValue(M_FSG_82_0_0_29_Result, superval, currentPos);
}


on envVar M_FSG_82_0_0_29_Result_1 // IAA_TriggerLocalFunction.ASG_ID
{
    M_FSG_82_0_0_29_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Result_2_range // IAA_TriggerLocalFunction.Extension1
{
    @M_FSG_82_0_0_29_Result_2 = @M_FSG_82_0_0_29_Result_2_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Result_2 // IAA_TriggerLocalFunction.Extension1
{
    M_FSG_82_0_0_29_Result_BuildFct();
}

on envVar M_FSG_82_0_0_29_Result_3 // IAA_TriggerLocalFunction.CommandType
{
    M_FSG_82_0_0_29_Result_BuildFct();
}

on envVar M_FSG_82_0_0_29_Result_4 // IAA_TriggerLocalFunction.Triggerresult
{
    M_FSG_82_0_0_29_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Result_5_range // IAA_TriggerLocalFunction.Resultparam1
{
    @M_FSG_82_0_0_29_Result_5 = @M_FSG_82_0_0_29_Result_5_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Result_5 // IAA_TriggerLocalFunction.Resultparam1
{
    M_FSG_82_0_0_29_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Result_6_range // IAA_TriggerLocalFunction.Resultparam2
{
    @M_FSG_82_0_0_29_Result_6 = @M_FSG_82_0_0_29_Result_6_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Result_6 // IAA_TriggerLocalFunction.Resultparam2
{
    M_FSG_82_0_0_29_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Result_7_range // IAA_TriggerLocalFunction.Resultparam3
{
    @M_FSG_82_0_0_29_Result_7 = @M_FSG_82_0_0_29_Result_7_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Result_7 // IAA_TriggerLocalFunction.Resultparam3
{
    M_FSG_82_0_0_29_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Result_8_range // IAA_TriggerLocalFunction.Resultparam4
{
    @M_FSG_82_0_0_29_Result_8 = @M_FSG_82_0_0_29_Result_8_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Result_8 // IAA_TriggerLocalFunction.Resultparam4
{
    M_FSG_82_0_0_29_Result_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_82_0_0_29_Result_9_cnt
{
    word len;
    byte cnt;
    len = getValue(M_FSG_82_0_0_29_Result_9_len);
    cnt = getValue(M_FSG_82_0_0_29_Result_9_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(M_FSG_82_0_0_29_Result_9_len, 127);
        }
    }

    M_FSG_82_0_0_29_Result_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_82_0_0_29_Result_9_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 128)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_29_Result_9 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 128);
        putValue(this, 128);
    }
    M_FSG_82_0_0_29_Result_BuildFct();
}


on envVar M_FSG_82_0_0_29_Result_9 // IAA_TriggerLocalFunction.Resultparam5
{
    putValue(M_FSG_82_0_0_29_Result_9_len, getValueSize(this));
    M_FSG_82_0_0_29_Result_BuildFct();
}

on envVar M_FSG_82_0_0_29_Processing // bus value of IAA_TriggerLocalFunction (29).
{
    // opcodes: Error-Processing-Result
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Reserve1
    byte param5; // Reserve2
    byte param6; // Reserve3
    byte param7; // Reserve4
    byte param8; // Reserve5
    byte param9; // Reserve6
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[137];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 137; i++ ) {
        superval[i] = 0;
    }
    getValue(M_FSG_82_0_0_29_Processing, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(M_FSG_82_0_0_29_Processing_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(M_FSG_82_0_0_29_Processing_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Processing_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Processing_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Processing_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Processing_6, round((param6 * 1.0) - (0) + (0), 1.0));
    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Processing_7, round((param7 * 1.0) - (0) + (0), 1.0));
    ///////// Start param8 - UINT8 /////////
    param8 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Processing_8, round((param8 * 1.0) - (0) + (0), 1.0));
    ///////// Start param9 - UINT8 /////////
    param9 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Processing_9, round((param9 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
M_FSG_82_0_0_29_Processing_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Reserve1
    byte param5; // Reserve2
    byte param6; // Reserve3
    byte param7; // Reserve4
    byte param8; // Reserve5
    byte param9; // Reserve6

    dword i;
    byte superval[137];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(M_FSG_82_0_0_29_Processing_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Processing_2_range = round(@M_FSG_82_0_0_29_Processing_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    param3 = getValue(M_FSG_82_0_0_29_Processing_3);
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Processing_4_range = round(@M_FSG_82_0_0_29_Processing_4 + (0), 1.0); // slider value + min = real value
    param4 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Processing_5_range = round(@M_FSG_82_0_0_29_Processing_5 + (0), 1.0); // slider value + min = real value
    param5 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Processing_6_range = round(@M_FSG_82_0_0_29_Processing_6 + (0), 1.0); // slider value + min = real value
    param6 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Processing_7_range = round(@M_FSG_82_0_0_29_Processing_7 + (0), 1.0); // slider value + min = real value
    param7 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param7;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Processing_8_range = round(@M_FSG_82_0_0_29_Processing_8 + (0), 1.0); // slider value + min = real value
    param8 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param8;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Processing_9_range = round(@M_FSG_82_0_0_29_Processing_9 + (0), 1.0); // slider value + min = real value
    param9 = 0; // underlying parameter has constant value 0.0.
    superval[currentPos++]=param9;
    putValue(M_FSG_82_0_0_29_Processing, superval, currentPos);
}


on envVar M_FSG_82_0_0_29_Processing_1 // IAA_TriggerLocalFunction.ASG_ID
{
    M_FSG_82_0_0_29_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Processing_2_range // IAA_TriggerLocalFunction.Extension1
{
    @M_FSG_82_0_0_29_Processing_2 = @M_FSG_82_0_0_29_Processing_2_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Processing_2 // IAA_TriggerLocalFunction.Extension1
{
    M_FSG_82_0_0_29_Processing_BuildFct();
}

on envVar M_FSG_82_0_0_29_Processing_3 // IAA_TriggerLocalFunction.CommandType
{
    M_FSG_82_0_0_29_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Processing_4_range // IAA_TriggerLocalFunction.Reserve1
{
    @M_FSG_82_0_0_29_Processing_4 = @M_FSG_82_0_0_29_Processing_4_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Processing_4 // IAA_TriggerLocalFunction.Reserve1
{
    M_FSG_82_0_0_29_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Processing_5_range // IAA_TriggerLocalFunction.Reserve2
{
    @M_FSG_82_0_0_29_Processing_5 = @M_FSG_82_0_0_29_Processing_5_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Processing_5 // IAA_TriggerLocalFunction.Reserve2
{
    M_FSG_82_0_0_29_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Processing_6_range // IAA_TriggerLocalFunction.Reserve3
{
    @M_FSG_82_0_0_29_Processing_6 = @M_FSG_82_0_0_29_Processing_6_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Processing_6 // IAA_TriggerLocalFunction.Reserve3
{
    M_FSG_82_0_0_29_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Processing_7_range // IAA_TriggerLocalFunction.Reserve4
{
    @M_FSG_82_0_0_29_Processing_7 = @M_FSG_82_0_0_29_Processing_7_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Processing_7 // IAA_TriggerLocalFunction.Reserve4
{
    M_FSG_82_0_0_29_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Processing_8_range // IAA_TriggerLocalFunction.Reserve5
{
    @M_FSG_82_0_0_29_Processing_8 = @M_FSG_82_0_0_29_Processing_8_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Processing_8 // IAA_TriggerLocalFunction.Reserve5
{
    M_FSG_82_0_0_29_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Processing_9_range // IAA_TriggerLocalFunction.Reserve6
{
    @M_FSG_82_0_0_29_Processing_9 = @M_FSG_82_0_0_29_Processing_9_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Processing_9 // IAA_TriggerLocalFunction.Reserve6
{
    M_FSG_82_0_0_29_Processing_BuildFct();
}

on envVar M_FSG_82_0_0_29_Start // bus value of IAA_TriggerLocalFunction (29).
{
    // opcodes: AbortResult-StartResult
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Param1
    byte param5; // Param2
    byte param6[130]; // Param3
    word len6;
    byte cnt6;
    byte param7[130]; // Param4
    word len7;
    byte cnt7;
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[264];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 264; i++ ) {
        superval[i] = 0;
    }
    getValue(M_FSG_82_0_0_29_Start, superval);
    ///////// Start param1 - NIBBLE /////////
    param1 = (superval[currentPos] & 0xf0)>>4;
    putValue(M_FSG_82_0_0_29_Start_1, param1);
    ///////// Start param2 - NIBBLE /////////
    param2 = superval[currentPos++] & 0x0f;
    putValue(M_FSG_82_0_0_29_Start_2, round((param2 * 1.0) - (0) + (0), 1.0));
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Start_3, param3);
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Start_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(M_FSG_82_0_0_29_Start_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - STRING /////////
    getValue(M_FSG_82_0_0_29_Start_6, param6);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(128>127) /* Max Fct-Katalog Laenge: 128*/
        {
            len6 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt6 = 1;
        }
        else
        {
            len6 = 128;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_82_0_0_29_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len6 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt6 = 0;
    }

    if(len6 > 128)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len6, currentPos);
        len6 = 128;

        if(len6 < 128) cnt6 = 0;
        else cnt6 = 1;
    }

    for(i = 0; i < len6; i++)
    {
        param6[i] = superval[currentPos++];
    }

    putValue(M_FSG_82_0_0_29_Start_6_len, len6);
    putValue(M_FSG_82_0_0_29_Start_6_cnt, cnt6);

    putValue(M_FSG_82_0_0_29_Start_6, param6, len6);

    ///////// Start param7 - STRING /////////
    getValue(M_FSG_82_0_0_29_Start_7, param7);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(128>127) /* Max Fct-Katalog Laenge: 128*/
        {
            len7 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt7 = 1;
        }
        else
        {
            len7 = 128;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_82_0_0_29_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len7 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt7 = 0;
    }

    if(len7 > 128)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len7, currentPos);
        len7 = 128;

        if(len7 < 128) cnt7 = 0;
        else cnt7 = 1;
    }

    for(i = 0; i < len7; i++)
    {
        param7[i] = superval[currentPos++];
    }

    putValue(M_FSG_82_0_0_29_Start_7_len, len7);
    putValue(M_FSG_82_0_0_29_Start_7_cnt, cnt7);

    putValue(M_FSG_82_0_0_29_Start_7, param7, len7);

}

// Updates the bus value field and other dependencies.
M_FSG_82_0_0_29_Start_BuildFct()
{
    byte param1; // ASG_ID
    byte param2; // Extension1
    byte param3; // CommandType
    byte param4; // Param1
    byte param5; // Param2
    byte param6[130]; // Param3
    word len6;
    byte cnt6;
    byte param7[130]; // Param4
    word len7;
    byte cnt7;

    dword i;
    byte superval[264];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    param1 = getValue(M_FSG_82_0_0_29_Start_1);
    param1 = param1 & 0x0f;
    superval[currentPos]= superval[currentPos]&0x0f;
    superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Start_2_range = round(@M_FSG_82_0_0_29_Start_2 + (0), 1.0); // slider value + min = real value
    param2 = 0; // underlying parameter has constant value 0.0.
    param2 = param2 & 0x0f;
    superval[currentPos]= superval[currentPos]&0xf0;
    superval[currentPos]= superval[currentPos]|param2;
    currentPos++;
// gen_BuildFunc_SetSuperVals
    param3 = getValue(M_FSG_82_0_0_29_Start_3);
    superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Start_4_range = round(@M_FSG_82_0_0_29_Start_4 + (0), 1.0); // slider value + min = real value
    param4 = (@M_FSG_82_0_0_29_Start_4 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals
    @M_FSG_82_0_0_29_Start_5_range = round(@M_FSG_82_0_0_29_Start_5 + (0), 1.0); // slider value + min = real value
    param5 = (@M_FSG_82_0_0_29_Start_5 + (0) - (0)) / (1.0); // (slider value + min - offset) / step = busvalue
    superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals
    getValue(M_FSG_82_0_0_29_Start_6, param6);
    len6 = getValue(M_FSG_82_0_0_29_Start_6_len);
    cnt6= getValue(M_FSG_82_0_0_29_Start_6_cnt);

    /* check box aktiviert*/
    if (cnt6 == 1)
    {
        /* 0 bis 128 (MaxString - 1B oder 2B) */
        if(len6 >= 0 && len6 <= 128)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
            superval[currentPos] = ((len6>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len6 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_29_Start_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 128);
            return;
        }
    }
    else if(cnt6 == 0) /*check box deaktiviert*/
    {
        if(len6 >= 0 && len6 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
            superval[currentPos]= len6 & 0x00ff;
            putValue(M_FSG_82_0_0_29_Start_6_len, len6);
        }
        else if(len6 > 127 && len6 <= 128)
        {
            superval[currentPos] = ((len6>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len6 & 0x00ff;
            putValue(M_FSG_82_0_0_29_Start_6_len, len6);
            putValue(M_FSG_82_0_0_29_Start_6_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_29_Start_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 128);
            return;
        }
    }
    currentPos += cnt6+1;
    for(i = 0; i < len6; i++)
    {
        superval[currentPos++]= param6[i];
    }

// gen_BuildFunc_SetSuperVals
    getValue(M_FSG_82_0_0_29_Start_7, param7);
    len7 = getValue(M_FSG_82_0_0_29_Start_7_len);
    cnt7= getValue(M_FSG_82_0_0_29_Start_7_cnt);

    /* check box aktiviert*/
    if (cnt7 == 1)
    {
        /* 0 bis 128 (MaxString - 1B oder 2B) */
        if(len7 >= 0 && len7 <= 128)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
            superval[currentPos] = ((len7>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len7 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_29_Start_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 128);
            return;
        }
    }
    else if(cnt7 == 0) /*check box deaktiviert*/
    {
        if(len7 >= 0 && len7 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
            superval[currentPos]= len7 & 0x00ff;
            putValue(M_FSG_82_0_0_29_Start_7_len, len7);
        }
        else if(len7 > 127 && len7 <= 128)
        {
            superval[currentPos] = ((len7>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len7 & 0x00ff;
            putValue(M_FSG_82_0_0_29_Start_7_len, len7);
            putValue(M_FSG_82_0_0_29_Start_7_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_29_Start_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 128);
            return;
        }
    }
    currentPos += cnt7+1;
    for(i = 0; i < len7; i++)
    {
        superval[currentPos++]= param7[i];
    }

    putValue(M_FSG_82_0_0_29_Start, superval, currentPos);
}


on envVar M_FSG_82_0_0_29_Start_1 // IAA_TriggerLocalFunction.ASG_ID
{
    M_FSG_82_0_0_29_Start_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Start_2_range // IAA_TriggerLocalFunction.Extension1
{
    @M_FSG_82_0_0_29_Start_2 = @M_FSG_82_0_0_29_Start_2_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Start_2 // IAA_TriggerLocalFunction.Extension1
{
    M_FSG_82_0_0_29_Start_BuildFct();
}

on envVar M_FSG_82_0_0_29_Start_3 // IAA_TriggerLocalFunction.CommandType
{
    M_FSG_82_0_0_29_Start_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Start_4_range // IAA_TriggerLocalFunction.Param1
{
    @M_FSG_82_0_0_29_Start_4 = @M_FSG_82_0_0_29_Start_4_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Start_4 // IAA_TriggerLocalFunction.Param1
{
    M_FSG_82_0_0_29_Start_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_82_0_0_29_Start_5_range // IAA_TriggerLocalFunction.Param2
{
    @M_FSG_82_0_0_29_Start_5 = @M_FSG_82_0_0_29_Start_5_range - (0); // slider = range - min
}

on envVar M_FSG_82_0_0_29_Start_5 // IAA_TriggerLocalFunction.Param2
{
    M_FSG_82_0_0_29_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_82_0_0_29_Start_6_cnt
{
    word len;
    byte cnt;
    len = getValue(M_FSG_82_0_0_29_Start_6_len);
    cnt = getValue(M_FSG_82_0_0_29_Start_6_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(M_FSG_82_0_0_29_Start_6_len, 127);
        }
    }

    M_FSG_82_0_0_29_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_82_0_0_29_Start_6_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 128)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_29_Start_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 128);
        putValue(this, 128);
    }
    M_FSG_82_0_0_29_Start_BuildFct();
}


on envVar M_FSG_82_0_0_29_Start_6 // IAA_TriggerLocalFunction.Param3
{
    putValue(M_FSG_82_0_0_29_Start_6_len, getValueSize(this));
    M_FSG_82_0_0_29_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_82_0_0_29_Start_7_cnt
{
    word len;
    byte cnt;
    len = getValue(M_FSG_82_0_0_29_Start_7_len);
    cnt = getValue(M_FSG_82_0_0_29_Start_7_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(M_FSG_82_0_0_29_Start_7_len, 127);
        }
    }

    M_FSG_82_0_0_29_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_82_0_0_29_Start_7_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 128)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_82_0_0_29_Start_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 128);
        putValue(this, 128);
    }
    M_FSG_82_0_0_29_Start_BuildFct();
}


on envVar M_FSG_82_0_0_29_Start_7 // IAA_TriggerLocalFunction.Param4
{
    putValue(M_FSG_82_0_0_29_Start_7_len, getValueSize(this));
    M_FSG_82_0_0_29_Start_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_30_ErrCode
{
       if(gP_FSG_82_0_0_30_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_30", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_30_ErrCode = 1;
}
on envVar P_FSG_82_0_0_30Status_BTN
{
    byte BAPTemp[6];
   if (P_FSG_82_0_0_30Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_82_0_0_30_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_30",MakeRGB(255,255,255));
      P_FSG_82_0_0_30Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_82_0_0_30, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_82_0_0_30_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_30));
      P_FSG_82_0_0_30Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_82_0_0_30_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_30_ID;
    data[2]=getValue(P_FSG_82_0_0_30_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_30
on envVar P_FSG_82_0_0_30_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_30",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_30",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_30",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_30", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_30",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_30",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_30",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_30", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_82_0_0_30 // bus value of IAA_LocalFunctionCommands (30).
{
    // opcodes: Error-Status
    byte param1; // SupportedCommands0
    byte param2; // SupportedCommands1
    byte param3; // Extension1
    byte param4; // Extension2
    byte param5; // Extension3
    byte param6; // Extension4
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[6];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 6; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_30, superval);
    ///////// Start param1 - UINT8 /////////
    param1 = superval[currentPos++];
    putValue(P_FSG_82_0_0_30_1, param1);
    ///////// Start param2 - UINT8 /////////
    param2 = superval[currentPos++];
    putValue(P_FSG_82_0_0_30_2, param2);
    ///////// Start param3 - UINT8 /////////
    param3 = superval[currentPos++];
    putValue(P_FSG_82_0_0_30_3, round((param3 * 1.0) - (0) + (0), 1.0));
    ///////// Start param4 - UINT8 /////////
    param4 = superval[currentPos++];
    putValue(P_FSG_82_0_0_30_4, round((param4 * 1.0) - (0) + (0), 1.0));
    ///////// Start param5 - UINT8 /////////
    param5 = superval[currentPos++];
    putValue(P_FSG_82_0_0_30_5, round((param5 * 1.0) - (0) + (0), 1.0));
    ///////// Start param6 - UINT8 /////////
    param6 = superval[currentPos++];
    putValue(P_FSG_82_0_0_30_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_82_0_0_30_1_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_1);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_30_1,thisval);
}

on envVar P_FSG_82_0_0_30_1_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_1);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_30_1,thisval);
}

on envVar P_FSG_82_0_0_30_1_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_1);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_30_1,thisval);
}

on envVar P_FSG_82_0_0_30_1_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_1);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_30_1,thisval);
}

on envVar P_FSG_82_0_0_30_1_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_1);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_30_1,thisval);
}

on envVar P_FSG_82_0_0_30_1_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_1);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_30_1,thisval);
}

on envVar P_FSG_82_0_0_30_1_6
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_1);
    thisval = thisval&~(1<<6)|(bitval<<6);
    putValue(P_FSG_82_0_0_30_1,thisval);
}

on envVar P_FSG_82_0_0_30_1_7
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands0
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_1);
    thisval = thisval&~(1<<7)|(bitval<<7);
    putValue(P_FSG_82_0_0_30_1,thisval);
}

on envVar P_FSG_82_0_0_30_1 // IAA_LocalFunctionCommands.SupportedCommands0
{
    byte superval[6];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // SupportedCommands0
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_30_1_0, 1);
    else
        putValue(P_FSG_82_0_0_30_1_0, 0);
    if(thisval&(mask<<1))
        putValue(P_FSG_82_0_0_30_1_1, 1);
    else
        putValue(P_FSG_82_0_0_30_1_1, 0);
    if(thisval&(mask<<2))
        putValue(P_FSG_82_0_0_30_1_2, 1);
    else
        putValue(P_FSG_82_0_0_30_1_2, 0);
    if(thisval&(mask<<3))
        putValue(P_FSG_82_0_0_30_1_3, 1);
    else
        putValue(P_FSG_82_0_0_30_1_3, 0);
    if(thisval&(mask<<4))
        putValue(P_FSG_82_0_0_30_1_4, 1);
    else
        putValue(P_FSG_82_0_0_30_1_4, 0);
    if(thisval&(mask<<5))
        putValue(P_FSG_82_0_0_30_1_5, 1);
    else
        putValue(P_FSG_82_0_0_30_1_5, 0);
    if(thisval&(mask<<6))
        putValue(P_FSG_82_0_0_30_1_6, 1);
    else
        putValue(P_FSG_82_0_0_30_1_6, 0);
    if(thisval&(mask<<7))
        putValue(P_FSG_82_0_0_30_1_7, 1);
    else
        putValue(P_FSG_82_0_0_30_1_7, 0);

    // Update superval
    getValue(P_FSG_82_0_0_30, superval);
    superval[0]=thisval;
    putValue(P_FSG_82_0_0_30,superval);
}

on envVar P_FSG_82_0_0_30_2_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_2);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_30_2,thisval);
}

on envVar P_FSG_82_0_0_30_2_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_2);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_30_2,thisval);
}

on envVar P_FSG_82_0_0_30_2_2
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_2);
    thisval = thisval&~(1<<2)|(bitval<<2);
    putValue(P_FSG_82_0_0_30_2,thisval);
}

on envVar P_FSG_82_0_0_30_2_3
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_2);
    thisval = thisval&~(1<<3)|(bitval<<3);
    putValue(P_FSG_82_0_0_30_2,thisval);
}

on envVar P_FSG_82_0_0_30_2_4
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_2);
    thisval = thisval&~(1<<4)|(bitval<<4);
    putValue(P_FSG_82_0_0_30_2,thisval);
}

on envVar P_FSG_82_0_0_30_2_5
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // SupportedCommands1
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_30_2);
    thisval = thisval&~(1<<5)|(bitval<<5);
    putValue(P_FSG_82_0_0_30_2,thisval);
}

on envVar P_FSG_82_0_0_30_2 // IAA_LocalFunctionCommands.SupportedCommands1
{
    byte superval[6];

    //Update Childvalue (BitField)
    byte mask=0x01;
    int i = 0;
    byte thisval; // SupportedCommands1
    thisval = getValue(this);
    if(thisval&(mask<<0))
        putValue(P_FSG_82_0_0_30_2_0, 1);
    else
        putValue(P_FSG_82_0_0_30_2_0, 0);
    if(thisval&(mask<<1))
        putValue(P_FSG_82_0_0_30_2_1, 1);
    else
        putValue(P_FSG_82_0_0_30_2_1, 0);
    if(thisval&(mask<<2))
        putValue(P_FSG_82_0_0_30_2_2, 1);
    else
        putValue(P_FSG_82_0_0_30_2_2, 0);
    if(thisval&(mask<<3))
        putValue(P_FSG_82_0_0_30_2_3, 1);
    else
        putValue(P_FSG_82_0_0_30_2_3, 0);
    if(thisval&(mask<<4))
        putValue(P_FSG_82_0_0_30_2_4, 1);
    else
        putValue(P_FSG_82_0_0_30_2_4, 0);
    if(thisval&(mask<<5))
        putValue(P_FSG_82_0_0_30_2_5, 1);
    else
        putValue(P_FSG_82_0_0_30_2_5, 0);

    // Update superval
    getValue(P_FSG_82_0_0_30, superval);
    superval[1]=thisval;
    putValue(P_FSG_82_0_0_30,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_30_3_range // IAA_LocalFunctionCommands.Extension1
{
    @P_FSG_82_0_0_30_3 = @P_FSG_82_0_0_30_3_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_30_3 // IAA_LocalFunctionCommands.Extension1
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension1
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_30_3_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_30, superval);
    superval[2]=thisval;
    putValue(P_FSG_82_0_0_30,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_30_4_range // IAA_LocalFunctionCommands.Extension2
{
    @P_FSG_82_0_0_30_4 = @P_FSG_82_0_0_30_4_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_30_4 // IAA_LocalFunctionCommands.Extension2
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension2
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_30_4_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_30, superval);
    superval[3]=thisval;
    putValue(P_FSG_82_0_0_30,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_30_5_range // IAA_LocalFunctionCommands.Extension3
{
    @P_FSG_82_0_0_30_5 = @P_FSG_82_0_0_30_5_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_30_5 // IAA_LocalFunctionCommands.Extension3
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension3
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_30_5_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_30, superval);
    superval[4]=thisval;
    putValue(P_FSG_82_0_0_30,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_82_0_0_30_6_range // IAA_LocalFunctionCommands.Extension4
{
    @P_FSG_82_0_0_30_6 = @P_FSG_82_0_0_30_6_range - (0); // slider = range - min
}

on envVar P_FSG_82_0_0_30_6 // IAA_LocalFunctionCommands.Extension4
{
    byte superval[6];

    //Update Childvalue (Number)
    byte thisval; // Extension4
    float slider_value;

    slider_value = 0; // Konstanter Parameter.
    @P_FSG_82_0_0_30_6_range = slider_value + (0); // real value := slider value + range min.
    thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
    getValue(P_FSG_82_0_0_30, superval);
    superval[5]=thisval;
    putValue(P_FSG_82_0_0_30,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_82_0_0_31_ErrCode
{
       if(gP_FSG_82_0_0_31_ErrCode)
       {
           setControlBackColor(panel_name,"errfield_P_FSG_82_0_0_31", MakeRGB(255,255,255));
       }
       gP_FSG_82_0_0_31_ErrCode = 1;
}
on envVar P_FSG_82_0_0_31Status_BTN
{
    byte BAPTemp[601];
    if (P_FSG_82_0_0_31Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_82_0_0_31_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_82_0_0_31",MakeRGB(255,255,255));
        P_FSG_82_0_0_31Status_BTN_already_pressed = 1;
    }
    else
    {
        P_FSG_82_0_0_31_BuildFct();
        getValue(P_FSG_82_0_0_31, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_82_0_0_31_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_82_0_0_31));
        if(getValue(P_FSG_82_0_0_31_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_82_0_0_31_ID);
        }
        if(getValue(P_FSG_82_0_0_31_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_82_0_0_31_ID,elCount(BAPTemp));
        }
       P_FSG_82_0_0_31Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_82_0_0_31_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_82_0_0_31_ID;
    data[2]=getValue(P_FSG_82_0_0_31_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_82_0_0_31
on envVar P_FSG_82_0_0_31_FctLstItemEn
{
       if(getValue(this))
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_31",1);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_31",1);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_31",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_31", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_82_0_0_31",0);
           EnableControl(panel_name,"errfield_P_FSG_82_0_0_31",0);
           EnableControl(panel_name,"panel_P_FSG_82_0_0_31",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_82_0_0_31", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_31_IntTlgEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_31_SegmEn,0);
           intertelegram_err(P_FSG_82_0_0_31_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_82_0_0_31_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_82_0_0_31_SegmEn
{
       if(getValue(this))
       {
           putValue(P_FSG_82_0_0_31_IntTlgEn,0);
           sequence_err(P_FSG_82_0_0_31_ID,getValueSize(P_FSG_82_0_0_31_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_82_0_0_31_ID);
       }
}
on envVar P_FSG_82_0_0_31 // bus value of RuR_PrimaryUser (31).
{
    // opcodes: Error-Status
    byte param1[242]; // UserName
    word len1;
    byte cnt1;
    byte param2[121]; // FirstName
    word len2;
    byte cnt2;
    byte param3[121]; // FamilyName
    word len3;
    byte cnt3;
    byte param4[67]; // NickName
    word len4;
    byte cnt4;
    byte param5[31]; // MBB_ID
    word len5;
    byte cnt5;
    byte param6[18]; // DateOfEnrollment
    word len6;
    byte cnt6;
    byte param7; // UserLoginState
    // DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
    dword i;
    byte superval[601];
    dword currentPos;
    currentPos = 0;
    for( i = 0; i < 601; i++ ) {
        superval[i] = 0;
    }
    getValue(P_FSG_82_0_0_31, superval);
    ///////// Start param1 - STRING /////////
    getValue(P_FSG_82_0_0_31_1, param1);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(240>127) /* Max Fct-Katalog Laenge: 240*/
        {
            len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt1 = 1;
        }
        else
        {
            len1 = 240;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_82_0_0_31 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len1 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt1 = 0;
    }

    if(len1 > 240)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
        len1 = 240;

        if(len1 < 128) cnt1 = 0;
        else cnt1 = 1;
    }

    for(i = 0; i < len1; i++)
    {
        param1[i] = superval[currentPos++];
    }

    putValue(P_FSG_82_0_0_31_1_len, len1);
    putValue(P_FSG_82_0_0_31_1_cnt, cnt1);

    putValue(P_FSG_82_0_0_31_1, param1, len1);

    ///////// Start param2 - STRING /////////
    getValue(P_FSG_82_0_0_31_2, param2);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(120>127) /* Max Fct-Katalog Laenge: 120*/
        {
            len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt2 = 1;
        }
        else
        {
            len2 = 120;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_82_0_0_31 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len2 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt2 = 0;
    }

    if(len2 > 120)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
        len2 = 120;

        if(len2 < 128) cnt2 = 0;
        else cnt2 = 1;
    }

    for(i = 0; i < len2; i++)
    {
        param2[i] = superval[currentPos++];
    }

    putValue(P_FSG_82_0_0_31_2_len, len2);
    putValue(P_FSG_82_0_0_31_2_cnt, cnt2);

    putValue(P_FSG_82_0_0_31_2, param2, len2);

    ///////// Start param3 - STRING /////////
    getValue(P_FSG_82_0_0_31_3, param3);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(120>127) /* Max Fct-Katalog Laenge: 120*/
        {
            len3 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt3 = 1;
        }
        else
        {
            len3 = 120;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_82_0_0_31 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len3 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt3 = 0;
    }

    if(len3 > 120)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len3, currentPos);
        len3 = 120;

        if(len3 < 128) cnt3 = 0;
        else cnt3 = 1;
    }

    for(i = 0; i < len3; i++)
    {
        param3[i] = superval[currentPos++];
    }

    putValue(P_FSG_82_0_0_31_3_len, len3);
    putValue(P_FSG_82_0_0_31_3_cnt, cnt3);

    putValue(P_FSG_82_0_0_31_3, param3, len3);

    ///////// Start param4 - STRING /////////
    getValue(P_FSG_82_0_0_31_4, param4);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(66>127) /* Max Fct-Katalog Laenge: 66*/
        {
            len4 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt4 = 1;
        }
        else
        {
            len4 = 66;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_82_0_0_31 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len4 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt4 = 0;
    }

    if(len4 > 66)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len4, currentPos);
        len4 = 66;

        if(len4 < 128) cnt4 = 0;
        else cnt4 = 1;
    }

    for(i = 0; i < len4; i++)
    {
        param4[i] = superval[currentPos++];
    }

    putValue(P_FSG_82_0_0_31_4_len, len4);
    putValue(P_FSG_82_0_0_31_4_cnt, cnt4);

    putValue(P_FSG_82_0_0_31_4, param4, len4);

    ///////// Start param5 - STRING /////////
    getValue(P_FSG_82_0_0_31_5, param5);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(30>127) /* Max Fct-Katalog Laenge: 30*/
        {
            len5 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt5 = 1;
        }
        else
        {
            len5 = 30;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_82_0_0_31 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len5 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt5 = 0;
    }

    if(len5 > 30)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len5, currentPos);
        len5 = 30;

        if(len5 < 128) cnt5 = 0;
        else cnt5 = 1;
    }

    for(i = 0; i < len5; i++)
    {
        param5[i] = superval[currentPos++];
    }

    putValue(P_FSG_82_0_0_31_5_len, len5);
    putValue(P_FSG_82_0_0_31_5_cnt, cnt5);

    putValue(P_FSG_82_0_0_31_5, param5, len5);

    ///////// Start param6 - STRING /////////
    getValue(P_FSG_82_0_0_31_6, param6);
    if((superval[currentPos] & 0x80) > 0)
    {
        if(17>127) /* Max Fct-Katalog Laenge: 17*/
        {
            len6 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
            currentPos = currentPos + 2;
            cnt6 = 1;
        }
        else
        {
            len6 = 17;
            writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_82_0_0_31 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
        }
    }
    else
    {
        len6 = superval[currentPos]&0x7F;
        currentPos = currentPos + 1;
        cnt6 = 0;
    }

    if(len6 > 17)
    {
        writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len6, currentPos);
        len6 = 17;

        if(len6 < 128) cnt6 = 0;
        else cnt6 = 1;
    }

    for(i = 0; i < len6; i++)
    {
        param6[i] = superval[currentPos++];
    }

    putValue(P_FSG_82_0_0_31_6_len, len6);
    putValue(P_FSG_82_0_0_31_6_cnt, cnt6);

    putValue(P_FSG_82_0_0_31_6, param6, len6);

    ///////// Start param7 - UINT8 /////////
    param7 = superval[currentPos++];
    putValue(P_FSG_82_0_0_31_7, param7);
}

// Updates the bus value field and other dependencies.
P_FSG_82_0_0_31_BuildFct()
{
    byte param1[242]; // UserName
    word len1;
    byte cnt1;
    byte param2[121]; // FirstName
    word len2;
    byte cnt2;
    byte param3[121]; // FamilyName
    word len3;
    byte cnt3;
    byte param4[67]; // NickName
    word len4;
    byte cnt4;
    byte param5[31]; // MBB_ID
    word len5;
    byte cnt5;
    byte param6[18]; // DateOfEnrollment
    word len6;
    byte cnt6;
    byte param7; // UserLoginState

    dword i;
    byte superval[601];
    dword currentPos;
    currentPos = 0;
// gen_BuildFunc_SetSuperVals
    getValue(P_FSG_82_0_0_31_1, param1);
    len1 = getValue(P_FSG_82_0_0_31_1_len);
    cnt1= getValue(P_FSG_82_0_0_31_1_cnt);

    /* check box aktiviert*/
    if (cnt1 == 1)
    {
        /* 0 bis 240 (MaxString - 1B oder 2B) */
        if(len1 >= 0 && len1 <= 240)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
            superval[currentPos] = ((len1>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len1 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 240);
            return;
        }
    }
    else if(cnt1 == 0) /*check box deaktiviert*/
    {
        if(len1 >= 0 && len1 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
            superval[currentPos]= len1 & 0x00ff;
            putValue(P_FSG_82_0_0_31_1_len, len1);
        }
        else if(len1 > 127 && len1 <= 240)
        {
            superval[currentPos] = ((len1>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len1 & 0x00ff;
            putValue(P_FSG_82_0_0_31_1_len, len1);
            putValue(P_FSG_82_0_0_31_1_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 240);
            return;
        }
    }
    currentPos += cnt1+1;
    for(i = 0; i < len1; i++)
    {
        superval[currentPos++]= param1[i];
    }

// gen_BuildFunc_SetSuperVals
    getValue(P_FSG_82_0_0_31_2, param2);
    len2 = getValue(P_FSG_82_0_0_31_2_len);
    cnt2= getValue(P_FSG_82_0_0_31_2_cnt);

    /* check box aktiviert*/
    if (cnt2 == 1)
    {
        /* 0 bis 120 (MaxString - 1B oder 2B) */
        if(len2 >= 0 && len2 <= 120)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
            superval[currentPos] = ((len2>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len2 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 120);
            return;
        }
    }
    else if(cnt2 == 0) /*check box deaktiviert*/
    {
        if(len2 >= 0 && len2 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
            superval[currentPos]= len2 & 0x00ff;
            putValue(P_FSG_82_0_0_31_2_len, len2);
        }
        else if(len2 > 127 && len2 <= 120)
        {
            superval[currentPos] = ((len2>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len2 & 0x00ff;
            putValue(P_FSG_82_0_0_31_2_len, len2);
            putValue(P_FSG_82_0_0_31_2_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 120);
            return;
        }
    }
    currentPos += cnt2+1;
    for(i = 0; i < len2; i++)
    {
        superval[currentPos++]= param2[i];
    }

// gen_BuildFunc_SetSuperVals
    getValue(P_FSG_82_0_0_31_3, param3);
    len3 = getValue(P_FSG_82_0_0_31_3_len);
    cnt3= getValue(P_FSG_82_0_0_31_3_cnt);

    /* check box aktiviert*/
    if (cnt3 == 1)
    {
        /* 0 bis 120 (MaxString - 1B oder 2B) */
        if(len3 >= 0 && len3 <= 120)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len3: %d", len3);
            superval[currentPos] = ((len3>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len3 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_3 ist ungueltig. Die max. erlaubte Laenge ist %d.", len3, 120);
            return;
        }
    }
    else if(cnt3 == 0) /*check box deaktiviert*/
    {
        if(len3 >= 0 && len3 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len3: %d", len3);
            superval[currentPos]= len3 & 0x00ff;
            putValue(P_FSG_82_0_0_31_3_len, len3);
        }
        else if(len3 > 127 && len3 <= 120)
        {
            superval[currentPos] = ((len3>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len3 & 0x00ff;
            putValue(P_FSG_82_0_0_31_3_len, len3);
            putValue(P_FSG_82_0_0_31_3_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_3 ist ungueltig. Die max. erlaubte Laenge ist %d.", len3, 120);
            return;
        }
    }
    currentPos += cnt3+1;
    for(i = 0; i < len3; i++)
    {
        superval[currentPos++]= param3[i];
    }

// gen_BuildFunc_SetSuperVals
    getValue(P_FSG_82_0_0_31_4, param4);
    len4 = getValue(P_FSG_82_0_0_31_4_len);
    cnt4= getValue(P_FSG_82_0_0_31_4_cnt);

    /* check box aktiviert*/
    if (cnt4 == 1)
    {
        /* 0 bis 66 (MaxString - 1B oder 2B) */
        if(len4 >= 0 && len4 <= 66)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
            superval[currentPos] = ((len4>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len4 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 66);
            return;
        }
    }
    else if(cnt4 == 0) /*check box deaktiviert*/
    {
        if(len4 >= 0 && len4 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
            superval[currentPos]= len4 & 0x00ff;
            putValue(P_FSG_82_0_0_31_4_len, len4);
        }
        else if(len4 > 127 && len4 <= 66)
        {
            superval[currentPos] = ((len4>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len4 & 0x00ff;
            putValue(P_FSG_82_0_0_31_4_len, len4);
            putValue(P_FSG_82_0_0_31_4_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 66);
            return;
        }
    }
    currentPos += cnt4+1;
    for(i = 0; i < len4; i++)
    {
        superval[currentPos++]= param4[i];
    }

// gen_BuildFunc_SetSuperVals
    getValue(P_FSG_82_0_0_31_5, param5);
    len5 = getValue(P_FSG_82_0_0_31_5_len);
    cnt5= getValue(P_FSG_82_0_0_31_5_cnt);

    /* check box aktiviert*/
    if (cnt5 == 1)
    {
        /* 0 bis 30 (MaxString - 1B oder 2B) */
        if(len5 >= 0 && len5 <= 30)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len5: %d", len5);
            superval[currentPos] = ((len5>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len5 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_5 ist ungueltig. Die max. erlaubte Laenge ist %d.", len5, 30);
            return;
        }
    }
    else if(cnt5 == 0) /*check box deaktiviert*/
    {
        if(len5 >= 0 && len5 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len5: %d", len5);
            superval[currentPos]= len5 & 0x00ff;
            putValue(P_FSG_82_0_0_31_5_len, len5);
        }
        else if(len5 > 127 && len5 <= 30)
        {
            superval[currentPos] = ((len5>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len5 & 0x00ff;
            putValue(P_FSG_82_0_0_31_5_len, len5);
            putValue(P_FSG_82_0_0_31_5_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_5 ist ungueltig. Die max. erlaubte Laenge ist %d.", len5, 30);
            return;
        }
    }
    currentPos += cnt5+1;
    for(i = 0; i < len5; i++)
    {
        superval[currentPos++]= param5[i];
    }

// gen_BuildFunc_SetSuperVals
    getValue(P_FSG_82_0_0_31_6, param6);
    len6 = getValue(P_FSG_82_0_0_31_6_len);
    cnt6= getValue(P_FSG_82_0_0_31_6_cnt);

    /* check box aktiviert*/
    if (cnt6 == 1)
    {
        /* 0 bis 17 (MaxString - 1B oder 2B) */
        if(len6 >= 0 && len6 <= 17)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
            superval[currentPos] = ((len6>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len6 & 0x00ff;
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 17);
            return;
        }
    }
    else if(cnt6 == 0) /*check box deaktiviert*/
    {
        if(len6 >= 0 && len6 <= 127)
        {
            //writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
            superval[currentPos]= len6 & 0x00ff;
            putValue(P_FSG_82_0_0_31_6_len, len6);
        }
        else if(len6 > 127 && len6 <= 17)
        {
            superval[currentPos] = ((len6>>8)&0x7F) | 0x80;
            superval[currentPos+1] = len6 & 0x00ff;
            putValue(P_FSG_82_0_0_31_6_len, len6);
            putValue(P_FSG_82_0_0_31_6_cnt, 1);
        }
        else
        {
            writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 17);
            return;
        }
    }
    currentPos += cnt6+1;
    for(i = 0; i < len6; i++)
    {
        superval[currentPos++]= param6[i];
    }

// gen_BuildFunc_SetSuperVals
    param7 = getValue(P_FSG_82_0_0_31_7);
    @P_FSG_82_0_0_31_7_0 = (param7 & 1) > 0;
    @P_FSG_82_0_0_31_7_1 = (param7 & 2) > 0;
    superval[currentPos++]=param7;
    putValue(P_FSG_82_0_0_31, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_82_0_0_31_1_cnt
{
    word len;
    byte cnt;
    len = getValue(P_FSG_82_0_0_31_1_len);
    cnt = getValue(P_FSG_82_0_0_31_1_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(P_FSG_82_0_0_31_1_len, 127);
        }
    }

    P_FSG_82_0_0_31_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_82_0_0_31_1_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 240)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 240);
        putValue(this, 240);
    }
    P_FSG_82_0_0_31_BuildFct();
}


on envVar P_FSG_82_0_0_31_1 // RuR_PrimaryUser.UserName
{
    putValue(P_FSG_82_0_0_31_1_len, getValueSize(this));
    P_FSG_82_0_0_31_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_82_0_0_31_2_cnt
{
    word len;
    byte cnt;
    len = getValue(P_FSG_82_0_0_31_2_len);
    cnt = getValue(P_FSG_82_0_0_31_2_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(P_FSG_82_0_0_31_2_len, 127);
        }
    }

    P_FSG_82_0_0_31_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_82_0_0_31_2_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 120)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 120);
        putValue(this, 120);
    }
    P_FSG_82_0_0_31_BuildFct();
}


on envVar P_FSG_82_0_0_31_2 // RuR_PrimaryUser.FirstName
{
    putValue(P_FSG_82_0_0_31_2_len, getValueSize(this));
    P_FSG_82_0_0_31_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_82_0_0_31_3_cnt
{
    word len;
    byte cnt;
    len = getValue(P_FSG_82_0_0_31_3_len);
    cnt = getValue(P_FSG_82_0_0_31_3_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(P_FSG_82_0_0_31_3_len, 127);
        }
    }

    P_FSG_82_0_0_31_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_82_0_0_31_3_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 120)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 120);
        putValue(this, 120);
    }
    P_FSG_82_0_0_31_BuildFct();
}


on envVar P_FSG_82_0_0_31_3 // RuR_PrimaryUser.FamilyName
{
    putValue(P_FSG_82_0_0_31_3_len, getValueSize(this));
    P_FSG_82_0_0_31_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_82_0_0_31_4_cnt
{
    word len;
    byte cnt;
    len = getValue(P_FSG_82_0_0_31_4_len);
    cnt = getValue(P_FSG_82_0_0_31_4_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(P_FSG_82_0_0_31_4_len, 127);
        }
    }

    P_FSG_82_0_0_31_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_82_0_0_31_4_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 66)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 66);
        putValue(this, 66);
    }
    P_FSG_82_0_0_31_BuildFct();
}


on envVar P_FSG_82_0_0_31_4 // RuR_PrimaryUser.NickName
{
    putValue(P_FSG_82_0_0_31_4_len, getValueSize(this));
    P_FSG_82_0_0_31_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_82_0_0_31_5_cnt
{
    word len;
    byte cnt;
    len = getValue(P_FSG_82_0_0_31_5_len);
    cnt = getValue(P_FSG_82_0_0_31_5_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(P_FSG_82_0_0_31_5_len, 127);
        }
    }

    P_FSG_82_0_0_31_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_82_0_0_31_5_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 30)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 30);
        putValue(this, 30);
    }
    P_FSG_82_0_0_31_BuildFct();
}


on envVar P_FSG_82_0_0_31_5 // RuR_PrimaryUser.MBB_ID
{
    putValue(P_FSG_82_0_0_31_5_len, getValueSize(this));
    P_FSG_82_0_0_31_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_82_0_0_31_6_cnt
{
    word len;
    byte cnt;
    len = getValue(P_FSG_82_0_0_31_6_len);
    cnt = getValue(P_FSG_82_0_0_31_6_cnt);

    /* wird nur gerufen, wenn check box deaktiviert mit Length>127*/
    if( cnt == 0)
    {
        if(len > 127 )
        {
            putValue(P_FSG_82_0_0_31_6_len, 127);
        }
    }

    P_FSG_82_0_0_31_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_82_0_0_31_6_len
{
    dword len;
    len = getValue(this);
    /* Validierung der Eingabe*/
    if(len > 17)
    {
        writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_82_0_0_31_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 17);
        putValue(this, 17);
    }
    P_FSG_82_0_0_31_BuildFct();
}


on envVar P_FSG_82_0_0_31_6 // RuR_PrimaryUser.DateOfEnrollment
{
    putValue(P_FSG_82_0_0_31_6_len, getValueSize(this));
    P_FSG_82_0_0_31_BuildFct();
}

on envVar P_FSG_82_0_0_31_7_0
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // UserLoginState
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_31_7);
    thisval = thisval&~(1<<0)|(bitval<<0);
    putValue(P_FSG_82_0_0_31_7,thisval);
}

on envVar P_FSG_82_0_0_31_7_1
{
    byte bitval;
    //thisval steht hier fuer den bitfield-wert,
    //aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
    byte thisval; // UserLoginState
    bitval= getValue(this);
    thisval = getValue(P_FSG_82_0_0_31_7);
    thisval = thisval&~(1<<1)|(bitval<<1);
    putValue(P_FSG_82_0_0_31_7,thisval);
}

on envVar P_FSG_82_0_0_31_7 // RuR_PrimaryUser.UserLoginState
{
    P_FSG_82_0_0_31_BuildFct();
}



/**
*
* Template-Funktion zum automatischen befuellen der Array-Daten, die in einer Arrayfunktion genutzt werden.
* Die Funktion wird durch den von BAPSimGen generierten Code aufgerufen.
*
* Parameter:
* - structArray: Muss mindestens nMax * Arraygroesse Bytes Platz haben, wird vom BAPSimGen automatisch generiert
* - structElementsSizeArray: Enthaelt die Groesseangabe jedes Array-Elements. Die Arraygroesse entspricht der Elementanzahl im Array.
*       Byte & Nibble = 1; Word = 2; usw. Bei Strings wird die maximale Stringlaenge angegeben.
* - structElementsTypeArray: Gibt den Datentyp eines Array-Elements zurueck. Die Arraygroesse entspricht der Elmentanzahl im Array.
*                               0x0 = Zahlenwert, also ein Slider, Enum, Bitfield,...
*                               0xE = String (darauf folgt immer eine 2, mit der Angabe der benutzen Bytes im String)
*                               0xF = Laenge der Nutzdaten des Strings, nur return Wert
* - fctID: Kann zur Fallunterscheidung der Funktions-IDs verwendet werden.
* - nMax: Array-Index
*
* Die Funktion kann im Switch-Case beliebig erweitert werden. Der Switch-Case wertet den Parameter fctID aus.
*
*
**/
initStruct(byte structArray[], dword structElementsSizeArray[], byte structElementsTypeArray[], dword structElementsMaxSizeArray[], word fctID, word nMax )
{
    byte rand8;
    word rand16;
    dword randSize;
    word index;           //indexNr die an die String Parameter angehaengt wird.
    dword destArraySize;   //groesse von structArray
    dword destStructSize;  //groesse eines "Structs" also destArraySize / Anzahl Elemente (nMax))
    dword rand32;
    dword i;
    dword pos;    //aktuelle Position im structArray
    dword elpos;  //aktuelle Position in den structElementsXXXArray's

    destArraySize = elCount(structArray);
    destStructSize = destArraySize / nMax;

    Switch(fctID){

        //Idee ist, die Arrays je nach Funcion-ID speziell initalisieren zu koennen.
        //hierbei koennten die Daten z.B. aus einer Datei eingelesen werden,
        //oder auch ueber spezielle init Funktionen mit festen Werten initialisiert werden.
        //Der Default-Fall befuellt das Array mit Random-Werten und Strings mit einem vordefinierten Wort (hier test,)

        default :
        {
            pos = 0;
            for(i = 1; i <= nMax; i++)
            {
                //walk through the array

                elpos = 0;
                while(pos < (destStructSize * i) )
                {
                    //check Element type
                    if( structElementsTypeArray[elpos] == 0x0)
                    { //Params like int, word, etc.
                        //check element length
                        Switch(structElementsSizeArray[elpos])
                        {
                            case(1) : //byte / nibble
                                rand8 = random(structElementsMaxSizeArray[elpos]);
                                structArray[pos] = rand8;
                                pos++;
                                break;

                            case(2) : //word / int
                                rand16 = random(structElementsMaxSizeArray[elpos]);
                                int2byte(structArray, pos, rand16);
                                pos += 2;
                                break;

                            case (4) : //dword / long
                                rand32 = random(structElementsMaxSizeArray[elpos]);
                                long2byte(structArray, pos, rand32);
                                pos += 4;
                                break;
                         }
                    }
                    else if(structElementsTypeArray[elpos] == 0xC)
                    { //String Params like byte[]
                        randSize = random(structElementsSizeArray[elpos]);
                        if(randSize < 4) randSize = 4;
                        index = i-1;
                        setRandomString(structArray ,pos ,structElementsSizeArray[elpos], randSize, index);
                        pos += structElementsSizeArray[elpos];
                    }
                    else if(structElementsTypeArray[elpos] == 0xD)
                    {
                        structArray[pos++] = randSize & 0xFF;
                        structArray[pos++] = (randSize >> 8) & 0xFF;
                        structArray[pos++] = (randSize >> 16) & 0xFF;
                        structArray[pos++] = (randSize >> 24) & 0xFF;
                    }
                    else if(structElementsTypeArray[elpos] == 0xE)
                    { //String Params like byte[]
                        randSize = random(structElementsSizeArray[elpos]);
                        if(randSize < 2) randSize = 2;
                        index = i-1;
                        setRandomString(structArray ,pos ,structElementsSizeArray[elpos], randSize, index);
                        pos += structElementsSizeArray[elpos];
                    }
                    else if(structElementsTypeArray[elpos] == 0xF)
                    {
                        int2byte(structArray, pos, randSize);
                        pos += 2;
                        //write("Pos: %d Strlth: %d Type: %d ",pos-1,randSize,structElementsTypeArray[elpos]);
                    }
                    elpos++;
                }
            }
        break;
        }
    }
}

long2Byte(byte in[], dword pos, dword value)
{
    if( (elCount(in)-pos) < 4)
        write("Array out ouf bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);
    in[++pos] = (value >> 16);
    in[++pos] = (value >> 24);
}

int2byte (byte in[],dword pos,word value)
{
    if( (elCount(in)-pos) < 2 )
        write("Array out of bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);
}

setRandomString (byte in[], dword pos, word strSize, dword randSize, dword count)
{
    dword endPos, endString, j;
    byte testString[4]={'t','e','s','t'};

    endPos = pos + strSize;
    endString = pos + randSize;
    j=0;

    int2ascii(in, pos, count);
    pos += 2;

    for(pos; pos < endPos ;pos ++)
    {
        if(j > 3 )
            j = 0;
        if(pos < endString)
            in[pos] = testString[j++];
        else
            in[pos] = 0x0;
    }
}

int2ascii (byte in[], dword pos, word value)
{
    //Konvertiert nur die erste und zweite Dezimalstelle, also Zahlen zw. 0 und 99.

    //auf 2 Stellen kuerzen
    value = value%100;
    //10er schreiben
    in[pos] = (value/10) + 48;    //  0x30 hex = 48 dez = ascii null
    //1er schreiben
    in[pos+1] = (value%10) + 48;  //  0x30 hex = 48 dez = ascii null
}

void SplitFullFileName(char FullFileName[], char FilePath[], char FileName[])
{
  dword i;
  i= strlen(FullFileName);

  while(i>0)
  {
    if(FullFileName[i] == '\\')
      break;
    i--;
  }
  substr_cpy(FilePath, FullFileName, 0, i+1, elcount(FilePath));
  substr_cpy(FileName, FullFileName, i+1, -1, elcount(FileName));
}

