/*@!Encoding:1252*/
includes
{
}
variables
{
    dword udpHandle;
    dword transmitterIPdw, transmitterPortdw;
    dword receiverIPdw, receiverPortdw;
    char  rxBuffer[1460], txBuffer[1460];
    char  transmitterIPstr[16], transmitterNAMEstr[16];
    char  receiverIPstr[16], receiverNAMEstr[16];

    char  kPanelName[32] = "DoIP_Test";   // Name of the panel

    const dword IPV6_STR_SIZE = 40; // IPv6 string size

    char ipv6SourceAddrStr[IPV6_STR_SIZE] = "fd53:7cb8:383:5::73";//"FD53:7CB8:383:5::73";//fe80::b1a0:9103:1645:37e4
    char ipv6GatewayStr[IPV6_STR_SIZE] = "fd53:7cb8:383:5::10";
    char ipv6KombiStr[IPV6_STR_SIZE] = "fd53:7cb8:383:5::14";
    char ipv6MulticastGrpStr[IPV6_STR_SIZE] = "ff14:0000:0000:0000:0000:0000:0003:0000";
    char ipv6DestAddrStr[IPV6_STR_SIZE]   = "ff14::5";
    char ipv6TA02_MulticastGrpStr[IPV6_STR_SIZE]   = "ff14::1";   // according Patrick Lehmann GVJ-60374

    byte ipv6SourceAddr[16];              // IPv6 address bytes.  
    byte ipv6DestAddr[16]; 
    byte ipv6Gateway[16];
    byte ipv6Kombi[16];
    byte ipv6MulticastGrp[16]; 
    byte ipv6TA02_MulticastGrp[16];   
  
    dword dwSrcPort = 13400;
    dword dwDstPort = 13400;
    dword gResult = 0;
  
    dword gUdpSocketHandleGW = 0;
    dword gTcpSocketHandleGW = 0;
  
    char gErrorText[200];
    char gRxBuffer[1472]; // Max. UDP payload without fragmentation
    char gTxBuffer[1472]; // Max. UDP payload without fragmentation
  
    char gReceiveBuffer[1452];
  
    char textData[20] = "Hello UDP Server";
    byte abData[20];
  
//    timer TestTimer;
  
//    timer PollTimer;
  
/*    struct DoIP_tstHead
    {
        byte ProtocolVer;
        byte InvProtocolVer;
        word wPayloadType;
        dword dwpayloadLen;
    } stDoIPHead;*/
  
    const word gcRequestHeadLen = 8; //8 bytes
  
//    byte gDoIPPayload[1452];
    byte gabEmptyArray[1452];

  //DOIP Specific data
//    byte Eid[6] = {0,0,0,0,0,0x0B};
//    byte Vin[17] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
      
/*    struct
    {
        word SrcAddr;
        byte ActType;
        dword Reservedoc;
        dword ReserveOEM;
    } stRoutingActivation;*/

/*    struct
    {
        word SrcAddr;
        word DstAddr;
    } stDiagMsgHead;*/
      
    byte DiagUserData[8] = {1,2,3,4,5,6,7,8};

    byte TestDiagUserData[8] = {1,2,3,4,5,6,7,8};

    const byte gMAXIDNO = 7;
//    byte DoIPID = 0;

    /* TA_02 specific variables */
    struct stPduHead
    {
        byte PduID[4];
        byte PduLen[4];
        byte PduData[256];
    } tstPduHead[8];

    LONG packetHandle;
    word Pdu_PduReadOffset =0;
    word Pdu_PduWriteOffset = 0;
    char Pdu_PduMarshallingData[1452];  

    word PduReadPtrNM =0;
    word PduWritePtrPdu = 0;

    struct stNMPduHeadPdu
    {
        byte PduID[4];
        byte PduLen[4];
        byte PduData[256];
    } tstNMPduHeadPdu[8];

    char gSignalData[256];
    char error[100];

    // IPv6 address bytes.
    dword ipv6SourceUdpPort = 0xA7F2;//42994;
    dword ipv6DestinationUdpPort = 0xA63D;//42557;

    dword gUdpSocketHandleTA_02 = 0;
    dword gUdpSocketHandleTA_02Recv = 0;


    dword ipv6TA02_SrcPort = 42994;//42994;
    dword ipv6TA02_DstPort = 42557;//42993; 
    
    dword ifIdx = 2; //2 is adapter vlan 1.5
    
    msTimer tTA02_TxMsg;
    const dword  TA02_TxMsgCycleTime = 20; //it is actually 20ms, set 500ms for testing purpose

//    msTimer Diag_SendTP;
}

on timer tTA02_TxMsg
{
  if(@TA_02_Var::TA_02_On == 1 && getValue( eUDPSendEnabled ))
  {
    SendIPV6data();

  }
        
  setTimer( tTA02_TxMsg, TA02_TxMsgCycleTime );
}

/// <Pdu_TA_02>
BYTE Pdu_u8BuildTA_02(char acSignalData[])
{
  int value;

    Pdu_vClearPduSendBuff();
    
    Pdu_vSetSignalSize(packetHandle,TA_02.DLC);

    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Ego_li_Seg1_QuerAbst,       @TA_02_Var::TA_02_Sig[0]); //
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Ego_re_Seg1_QuerAbst,       @TA_02_Var::TA_02_Sig[1]);  //01
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Nachb_li_Seg1_QuerAbst,     @TA_02_Var::TA_02_Sig[2]);  //01
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Nachb_re_Seg1_QuerAbst,     @TA_02_Var::TA_02_Sig[3]);  //01
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Ego_li_Typ,                 @TA_02_Var::TA_02_Sig[4]);  //01
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Ego_re_Typ,                 @TA_02_Var::TA_02_Sig[5]);  //01
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Nachb_li_Typ,               @TA_02_Var::TA_02_Sig[6]);  //01
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Nachb_re_Typ,               @TA_02_Var::TA_02_Sig[7]);  //01
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Seg2_Beginn,                @TA_02_Var::TA_02_Sig[8]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Seg1_Kruemmung,             @TA_02_Var::TA_02_Sig[9]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Seg2_Kruemmung,             @TA_02_Var::TA_02_Sig[10]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Seg1_Gierwinkel,            @TA_02_Var::TA_02_Sig[11]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Spurwechsel_li,             @TA_02_Var::TA_02_Sig[12]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Spurwechsel_re,             @TA_02_Var::TA_02_Sig[13]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Zoomstufe,                  @TA_02_Var::TA_02_Sig[14]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Kurvenwarnung,              @TA_02_Var::TA_02_Sig[15]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_TrajektVorausschau,         @TA_02_Var::TA_02_Sig[16]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_TaZoomstufeAktiv,           @TA_02_Var::TA_02_Sig[17]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_TrajektSeg1_Valid,          @TA_02_Var::TA_02_Sig[18]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_TrajektSeg1_Kruemmung,      @TA_02_Var::TA_02_Sig[19]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_TrajektSeg2_Kruemmung,      @TA_02_Var::TA_02_Sig[20]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_TrajektSeg1_QuerAbst,       @TA_02_Var::TA_02_Sig[21]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_TrajektSeg1_Gierwinkel,     @TA_02_Var::TA_02_Sig[22]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_TrajektSeg2_Beginn,         @TA_02_Var::TA_02_Sig[23]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_01_Spurzuordnung,       @TA_02_Var::TA_02_Sig[24]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_02_Spurzuordnung,       @TA_02_Var::TA_02_Sig[25]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_03_Spurzuordnung,       @TA_02_Var::TA_02_Sig[26]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_04_Spurzuordnung,       @TA_02_Var::TA_02_Sig[27]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_05_Spurzuordnung,       @TA_02_Var::TA_02_Sig[28]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_06_Spurzuordnung,       @TA_02_Var::TA_02_Sig[29]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_07_Spurzuordnung,       @TA_02_Var::TA_02_Sig[30]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_08_Spurzuordnung,       @TA_02_Var::TA_02_Sig[31]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_09_Spurzuordnung,       @TA_02_Var::TA_02_Sig[32]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_10_Spurzuordnung,       @TA_02_Var::TA_02_Sig[33]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_11_Spurzuordnung,       @TA_02_Var::TA_02_Sig[34]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_EgoObj_dy,                  @TA_02_Var::TA_02_Sig[35]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_01_dx,                  @TA_02_Var::TA_02_Sig[36]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_01_LaengsRegelung,      @TA_02_Var::TA_02_Sig[37]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_01_Typ,                 @TA_02_Var::TA_02_Sig[38]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_01_dy,                  @TA_02_Var::TA_02_Sig[39]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_01_QuerRegelung,        @TA_02_Var::TA_02_Sig[40]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_02_dx,                  @TA_02_Var::TA_02_Sig[41]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_02_LaengsRegelung,      @TA_02_Var::TA_02_Sig[42]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_02_Typ,                 @TA_02_Var::TA_02_Sig[43]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_02_dy,                  @TA_02_Var::TA_02_Sig[44]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_02_QuerRegelung,        @TA_02_Var::TA_02_Sig[45]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_03_dx,                  @TA_02_Var::TA_02_Sig[46]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_03_LaengsRegelung,      @TA_02_Var::TA_02_Sig[47]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_03_Typ,                 @TA_02_Var::TA_02_Sig[48]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_03_dy,                  @TA_02_Var::TA_02_Sig[49]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_03_QuerRegelung,        @TA_02_Var::TA_02_Sig[50]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_04_dx,                  @TA_02_Var::TA_02_Sig[51]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_04_LaengsRegelung,      @TA_02_Var::TA_02_Sig[52]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_04_Typ,                 @TA_02_Var::TA_02_Sig[53]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_04_dy,                  @TA_02_Var::TA_02_Sig[54]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_04_QuerRegelung,        @TA_02_Var::TA_02_Sig[55]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_05_dx,                  @TA_02_Var::TA_02_Sig[56]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_05_LaengsRegelung,      @TA_02_Var::TA_02_Sig[57]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_05_Typ,                 @TA_02_Var::TA_02_Sig[58]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_05_dy,                  @TA_02_Var::TA_02_Sig[59]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_05_QuerRegelung,        @TA_02_Var::TA_02_Sig[60]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_06_dx,                  @TA_02_Var::TA_02_Sig[61]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_06_LaengsRegelung,      @TA_02_Var::TA_02_Sig[62]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_06_Typ,                 @TA_02_Var::TA_02_Sig[63]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_06_dy,                  @TA_02_Var::TA_02_Sig[64]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_06_QuerRegelung,        @TA_02_Var::TA_02_Sig[65]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_07_dx,                  @TA_02_Var::TA_02_Sig[66]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_07_LaengsRegelung,      @TA_02_Var::TA_02_Sig[67]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_07_Typ,                 @TA_02_Var::TA_02_Sig[68]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_07_dy,                  @TA_02_Var::TA_02_Sig[69]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_07_QuerRegelung,        @TA_02_Var::TA_02_Sig[70]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_08_dx,                  @TA_02_Var::TA_02_Sig[71]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_08_LaengsRegelung,      @TA_02_Var::TA_02_Sig[72]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_08_Typ,                 @TA_02_Var::TA_02_Sig[73]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_08_dy,                  @TA_02_Var::TA_02_Sig[74]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_08_QuerRegelung,        @TA_02_Var::TA_02_Sig[75]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_09_dx,                  @TA_02_Var::TA_02_Sig[76]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_09_LaengsRegelung,      @TA_02_Var::TA_02_Sig[77]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_09_Typ,                 @TA_02_Var::TA_02_Sig[78]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_09_dy,                  @TA_02_Var::TA_02_Sig[79]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_09_QuerRegelung,        @TA_02_Var::TA_02_Sig[80]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_10_dx,                  @TA_02_Var::TA_02_Sig[81]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_10_LaengsRegelung,      @TA_02_Var::TA_02_Sig[82]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_10_Typ,                 @TA_02_Var::TA_02_Sig[83]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_10_dy,                  @TA_02_Var::TA_02_Sig[84]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_10_QuerRegelung,        @TA_02_Var::TA_02_Sig[85]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_11_dx,                  @TA_02_Var::TA_02_Sig[86]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_11_LaengsRegelung,      @TA_02_Var::TA_02_Sig[87]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_11_Typ,                 @TA_02_Var::TA_02_Sig[88]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_11_dy,                  @TA_02_Var::TA_02_Sig[89]);
    EthSetTokenSignalValue( packetHandle, TA_02::TA_HMI_Obj_11_QuerRegelung,        @TA_02_Var::TA_02_Sig[90]);

    Pdu_vConvertSignaltoByte(packetHandle, TA_02.DLC,TA_02.id, acSignalData);
  
  //  write("%s",gSignalData);
  
  return 0;
}
/// <Pdu_TA_02>
void Pdu_vSetSignalSize(Long PkgHdl,long DLC)
{
   EthResizeToken( PkgHdl, "udp", "data", DLC*8 /*bits*/ ); 
  
}
/// <Pdu_TA_02>
void Pdu_vClearPduSendBuff()
{
  Pdu_PduWriteOffset = 0;
  PduWritePtrPdu = 0;
}

/// <Pdu_TA_02>
void Pdu_vConvertSignaltoByte(Long PkgHdl, long DLC, long ID, char acSignalData[])
{
    EthGetTokenData(packetHandle, "udp","data",DLC,acSignalData);  
}

/// <Pdu_TA_02>
//Hence, 1452 bytes per datagram are available for the transmission of signals according to
//the SoAd-approach
word Pdu_u16SetPduMarshallingUdp(long Len,long ID,char Data[])
 {
  char PduLen[4]; //Pdu length of the user data in byte according to the data
  char PduID[4]; 

  
  PduID[3] = (char)(ID & 0x000000ff);
  PduID[2] = (char)((ID & 0x0000ff00) >> 8);
  PduID[1] = (char)((ID & 0x00ff0000) >> 16);
  PduID[0] = (char)((ID & 0xff000000) >> 24);
  
  
  PduLen[3] = (char)(Len & 0x000000ff);
  PduLen[2] = (char)((Len & 0x0000ff00) >> 8);
  PduLen[1] = (char)((Len & 0x00ff0000) >> 16);
  PduLen[0] = (char)((Len & 0xff000000) >> 24); 
  
  write("PDU ID: %d \r",Len);
  write("%x \r",PduLen[0]);
  write("%x \r",PduLen[1]);
  write("%x \r",PduLen[2]);
  write("%x \r",PduLen[3]);
  
  write("PDU Len: %d \r",ID);
  write("%x \r",PduID[0]);
  write("%x \r",PduID[1]);
  write("%x \r",PduID[2]);
  write("%x \r",PduID[3]);
   
  if(1452 <= PduWritePtrPdu) /* Udp Payload is full */
    return 0;
  

  memcpy_off( Pdu_PduMarshallingData,  PduWritePtrPdu + 0, PduID,0,4 );
  
  memcpy_off( Pdu_PduMarshallingData,  PduWritePtrPdu + 4, PduLen,0,4 ); 
  
  memcpy_off( Pdu_PduMarshallingData,  PduWritePtrPdu + 8, Data,0,Len );  
  
  PduWritePtrPdu = PduWritePtrPdu + 8 + Len;

  return 0;
 }


/// <Pdu_TA_02>
void InitIPV6data()
{
  char NM_PduData[256];
  char BAP_PduData[256];
  char c8Data[1];
  
  // create packet
  packetHandle = EthInitPacket("ipv6");
  
  // init UDP protocol
  EthInitProtocol(packetHandle, "udp" );

  if (EthGetLastError() == 0)
  {
    // set protocol fields    
    EthSetTokenData( packetHandle, "ipv6", "source", 16, ipv6SourceAddr ); // 255.255.255.255
    EthSetTokenData( packetHandle, "ipv6", "destination", 16, ipv6DestAddr ); // 255.255.255.255
    EthSetTokenInt( packetHandle, "udp", "source", ipv6SourceUdpPort );
    EthSetTokenInt( packetHandle, "udp", "destination", ipv6DestinationUdpPort );

    // set UDP payload
    
    Pdu_vClearPduSendBuff();
    
 
   
    
    //PDU2
    Pdu_u8BuildTA_02(gSignalData);

    Pdu_u16SetPduMarshallingUdp(TA_02.DLC,TA_02.id,gSignalData);
 

    
    // Complete and send packet
    EthCompletePacket( packetHandle );
    //EthOutputPacket( packetHandle );

    // release packet
    //EthReleasePacket( packetHandle );

        
    }
    else
    {
        EthGetLastErrorText( elCount(error), error );
        write("Error: %s", error );
    }
}

on sysvar_update TA_02_Var::TA_02_Sig
{
    InitIPV6data();//Update Ethernet message
}

/// <Pdu_TA_02>
void Pdu_u16SendIPv6MulticastCastMessage(char abUdpMsg[])
{

  gResult = UdpSendTo(gUdpSocketHandleTA_02, ipv6TA02_MulticastGrp, ipv6TA02_DstPort, abUdpMsg, PduWritePtrPdu);
  // Check for error
  if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleTA_02) != 997) )
  {
    IpGetLastSocketErrorAsString(gUdpSocketHandleTA_02, gErrorText, elcount(gErrorText) );
//    write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleTA_02) );  
  }
}

/// <Pdu_TA_02>
void SendIPV6data()
{
    /* Send to ff14::05 */
    Pdu_u16SendIPv6MulticastCastMessage(Pdu_PduMarshallingData);
}


/// <Pdu_TA_02>
void Pdu_vOpenIPv6MulticastUdpPort( byte ipv6SrcAddr[],dword ipv6SrcPort,byte ipv6DstAddr[],dword ipv6DstPort)
{
    int i;                          // loop variable  
    dword result,result2;   
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
    char textData[30] = "HUNM: Hello UDP Server";

  //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
      // success...
  //    write("<%BASE_FILE_NAME%>IpGetAddressAsArray: returned wildcard array with IPv6 bytes:");
      for ( i=0; i<16; i++)
      {
 //       write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6WildcardAddrArray[i]);
      }
    }
    else
    {
 //     writeLineEx(1, 3, "<%BASE_FILE_NAME%>IpGetAddressAsArray: The wildcard address string was invalid.");
    }

    // Open UDP socket
    gUdpSocketHandleTA_02 = UdpOpen(ipv6SrcAddr, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
   // gUdpSocketHandleNM = UdpOpen(ipv6WildcardAddrArray, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.
    
    // Check for valid socket handle
    if (gUdpSocketHandleTA_02 == ~0)
    {
  //    write("<%BASE_FILE_NAME%> UdpOpen failed: Result %d", IpGetLastError());
    }
    else // Socket handle valid
    {

      result = IpSetMulticastInterface( gUdpSocketHandleTA_02, ifIdx );
      if (result == 0)
      {
 //       write("<%BASE_FILE_NAME%>Socket %d set to send multicast on adapter %d.", gUdpSocketHandleTA_02, ifIdx);
 //       write("<%BASE_FILE_NAME%>Sending some multicast messages to :%d ...", ipv6DstPort);
       }
      else
      {
  //      writeLineEx(1, 3, "<%BASE_FILE_NAME%>IpSetMulticastInterface: Error %d", result);
      }
      // Send UDP data
      gResult = UdpSendTo(gUdpSocketHandleTA_02, ipv6DstAddr, ipv6DstPort, textData, strlen(textData));
//      write( "<%BASE_FILE_NAME%>UdpSendTo to ipv6: ");
      for ( i=0; i<16; i++)
      {
//        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6DstAddr[i]);
      }

      // Check for error
      if ( (gResult != 0) && (IpGetLastSocketError(gUdpSocketHandleTA_02) != 997) )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleTA_02, gErrorText, elcount(gErrorText) );
 //       write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleTA_02) );
      }
 
      // Optionally receive answer from UDP server
      UdpReceiveFrom(gUdpSocketHandleTA_02, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(gUdpSocketHandleTA_02) != 997 )
      {
        IpGetLastSocketErrorAsString(gUdpSocketHandleTA_02, gErrorText, elcount(gErrorText));
//        write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleTA_02));
      }
    }
 }

/// <Pdu_TA_02>
void Pdu_vJoinIPv6MulticastGrp( byte ipv6MultiCastAddr[],dword ipv6MulticastPort)
{
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
  //wildcard IP binding
  long result; // function result
  dword ifIdx = 2;
  Dword port = 12345;
  
    //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
  
        gUdpSocketHandleTA_02Recv = UdpOpen(ipv6WildcardAddrArray, ipv6MulticastPort); // open an UDP socket...
        if (gUdpSocketHandleTA_02Recv != ~0)
        {
          result = IpJoinMulticastGroup( gUdpSocketHandleTA_02Recv, ifIdx, ipv6MultiCastAddr );
          if (result == 0)
          {
            // successfully joined.
            write("successfully joined:  %d", result);
            
            // Optionally receive answer from UDP server
            UdpReceiveFrom(gUdpSocketHandleTA_02Recv, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

            // Check for error
            if ( IpGetLastSocketError(gUdpSocketHandleTA_02Recv) != 997 )
            {
              IpGetLastSocketErrorAsString(gUdpSocketHandleTA_02Recv, gErrorText, elcount(gErrorText));
     //         write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(gUdpSocketHandleTA_02Recv));
              }  
          }
          else
          {
    //        writeLineEx(1, 3, "IpJoinMulticastGroup: Error %d", result);
          }
        }
    }
    else
     {
  //     writeLineEx(1, 3, "IpGetAddressAsArray: The wildcard address string was invalid.");
     }
}

/*
on sysvar_update DoIP::SendID
{
  if(@this)
    DoIP_SenCmd(0x0001);
}

on sysvar_update DoIP::SendIDVIN
{
   if(@this)
  DoIP_SenCmd(0x0003);
}

on sysvar_update DoIP::SendIDEID
{
   if(@this)
  DoIP_SenCmd(0x0002);
}

on sysvar_update DoIP::SendPwrMode
{
   if(@this)
  DoIP_SenCmd(0x4003);
}

on sysvar_update DoIP::SendEntityStatus
{
   if(@this)
    DoIP_SenCmd(0x4001);
}

on sysvar_update DoIP::SendRoutingAct
{
  if(@this)
    DoIP_SenCmd(0x0005);
}

on sysvar_update DoIP::SendDiagMsg
{
   if(@this)
     DoIP_SenCmd(0x8001);
}
*/

/*
on key 'g'
{
  DoIP_SenCmd(0x0007);
}
*/

/*
/// <DoIP_Cmd>
void DoIP_SenCmd(word wID)
{
    DoIP_ProInit();
  
    switch (wID)
    {
        case 0x1:      DoIP_VinRequest();              break;
        case 0x2:      DoIP_VinRequest_EID();          break;
        case 0x3:      DoIP_VinRequest_VIN();          break;
        case 0x4001:   DoIP_Entity_Status_Request();   break;
        case 0x4003:   DoIP_Pwr_mode_Request();        break;
        case 0x5:      DoIP_Route_Act_Request();       break;
        case 0x8001:   DoIP_DiagMsg_Request();         break;
        case 0x0007:   DoIP_AliveCheck_Request();      break;
    }
}
*/

/*
DoIP_AliveCheck_Request()
{
   DoIP_MessageHeadBuilder( 0x0007, 0 );
   DoIP_MessageTcpSend(gcRequestHeadLen);
  
}
*/

on start
{
    vOpenIPv6UdpPort(gUdpSocketHandleGW, ipv6Gateway,dwSrcPort );
    TcPClientStart();
  
//    DoIP_ProInit();
  
    memcpy(abData,textData,elcount(textData));
  
    InitIPV6data();
  
  //TA02 Multicast UDP socket
  Pdu_vOpenIPv6MulticastUdpPort(ipv6Gateway,ipv6TA02_SrcPort,ipv6TA02_MulticastGrp,ipv6TA02_DstPort);
  
  Pdu_vJoinIPv6MulticastGrp(ipv6TA02_MulticastGrp,ipv6TA02_DstPort);
  
  
   setTimer( tTA02_TxMsg, TA02_TxMsgCycleTime );
  //SendUdpMsg(gUdpSocketHandleGW,ipv6Kombi,dwDstPort,abData);
  
 // DoIP_VinRequest();
    
  ReceiveUdpMsg(gUdpSocketHandleGW);
    
 //  setTimer( TestTimer, 1 ); //disabled for test
}


/*
/// <DoIP_Cmd>
void DoIP_VinRequest()
{
    DoIP_MessageHeadBuilder( 0x0001, 0 );
    DoIP_MessageUdpSend( gcRequestHeadLen );
  
 //   putValueToControl( kPanelName, "DoIPOutput", " Sent Vehicle Identification  request. \r\n");
}
*/

/*
/// <DoIP_Cmd>
void DoIP_VinRequest_EID()
{
    DoIP_MessageHeadBuilder( 0x0002 ,6 ); //6 bytes of eid
  
    memcpy( gDoIPPayload, gabEmptyArray, elcount( gabEmptyArray ) );
  
    memcpy_off( gDoIPPayload, 8, Eid, 0, 6 );
  
    DoIP_MessageUdpSend( gcRequestHeadLen + 6 );
  
    putValueToControl( kPanelName, "DoIPOutput", " Sent Vehicle Indetification  request with EID. \r\n");
}*/


/// <TCP>
/*
  Start Chat Client and connect to server
*/
int TcPClientStart()
{
  BYTE  remoteAddressIPv6[16];
  BYTE  localAddressIPv6[16];
  CHAR  errorText[200];
  CHAR  buf[32];
  LONG  result;
  byte ServerPortIndex;
    long TcpServerPorts;
    long TcpClientPort = 13400 ;
 
    TcpServerPorts = 13400;

  

  // Setup server address
  //

  if( ipGetAddressAsArray(ipv6KombiStr, remoteAddressIPv6) == 0 )
  {
    //
    // Create IPv6 TCP socket and connect
    //

//      write( "$$  <%BASE_FILE_NAME%> Connecting to %s ...", ipv6KombiStr );


    
          ipGetAddressAsArray("::", localAddressIPv6);
    
          gTcpSocketHandleGW = TcpOpen( localAddressIPv6, TcpClientPort );
    
          if (IpGetLastSocketError(gTcpSocketHandleGW) != 0)
          {
            IpGetLastSocketErrorAsString( gTcpSocketHandleGW, errorText, elcount(errorText) );
            write( "$$  <%BASE_FILE_NAME%> TcpSocket::open IPv6 failed, %s (Result %d)", errorText, IpGetLastSocketError(gTcpSocketHandleGW) );
            return -1;
          }

          result = TcpConnect( gTcpSocketHandleGW, remoteAddressIPv6, TcpServerPorts );
          if (result != 0 && ipGetLastSocketError(gTcpSocketHandleGW) != 10035 ) // WSAEWOULDBLOCK
          {
            IpGetLastSocketErrorAsString(gTcpSocketHandleGW, errorText, elcount(errorText) );
            write( "$$  <%BASE_FILE_NAME%> TcpSocket::connect IPv6 failed, %s (Result %d)", errorText,IpGetLastSocketError(gTcpSocketHandleGW) );
            return -1;
          }
          
          write( "$$  <%BASE_FILE_NAME%> TCP Client connecting to port: %d, from Socket: 0x%x", TcpServerPorts,gTcpSocketHandleGW  );
    }
    return 0;
}

/*
on sysvar_update DoIP::PollDiag
{
    if( @this )
    {
        setTimer( PollTimer, 1 ); //disabled for test
    }
    else
    {
        cancelTimer( PollTimer );
    }
}
*/

/*
on timer PollTimer
{
    DoIP_SenCmd(0x8001);
    setTimer(PollTimer, 3);
}
*/

/*
/// <DoIP_Cmd>
//tcp cmd
void DoIP_Route_Act_Request()
{
   // memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
  
    DoIP_MessageHeadBuilder(0x005,11); //6 bytes of eid
  
     memcpy_h2n(gDoIPPayload,8,stRoutingActivation);
   
    DoIP_MessageTcpSend(gcRequestHeadLen+11);
  
    putValueToControl( kPanelName, "DoIPOutput", " Sent Routing activation request. \r\n");
}
*/

/*
word DoIP_wBuildDiagMsg(byte abData[])
{
  word wLen;
  
  wLen = elcount(abData);
  
  return wLen;
}
*/

/*
/// <DoIP_Cmd>
void DoIP_DiagMsg_Request()
{
  word wDiagMsgLen;
  
  byte abDiagUserData[100];
  long CmdLen;
  
  CmdLen = elcount(sysvar::DoIP::DiagCmd); 
  
   sysGetVariableData( sysvar::DoIP::DiagCmd, abDiagUserData, CmdLen);
  
  //   wDiagMsgLen = DoIP_wBuildDiagMsg(abDiagUserData);
    wDiagMsgLen =   CmdLen;
  
     DoIP_MessageHeadBuilder(0x8001,4+wDiagMsgLen); //4 bytes of addr + diag length
  

     memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
  
     memcpy_h2n(gDoIPPayload,8,stDiagMsgHead);
  
     memcpy_off(gDoIPPayload,8+4,abDiagUserData,0,wDiagMsgLen); //8 = head, 4= Diag head
    
   
    DoIP_MessageTcpSend(gcRequestHeadLen+wDiagMsgLen+4);
  
    putValueToControl( kPanelName, "DoIPOutput", " Sent Diagnosis request. \r\n");
}
*/

/*
/// <DoIP_Cmd>
void DoIP_Diag_SendTesterPresent()
{  
  byte DiagTPData[2]={0x3E,0x00};

     DoIP_MessageHeadBuilder(0x8001,4 + 2); //4 bytes of addr + TesterPresent length
  
     memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
  
     memcpy_h2n(gDoIPPayload,8,stDiagMsgHead);
  
     memcpy_off(gDoIPPayload,8+4,DiagTPData,0,2); //8 = head, 4= Diag head
                                                  
    DoIP_MessageTcpSend(gcRequestHeadLen+2+4);   // 2 = TP Command Length 
  
    putValueToControl( kPanelName, "DoIPOutput", " Sent Tester Present. \r\n");
}
*/

/*
on sysvar_update DoIP::SendTP
{
  if(@this == 1)
   {
    settimer(Diag_SendTP,0);
   }
  else
  {
    cancelTimer(Diag_SendTP);
  }  
}
*/

/*
on timer Diag_SendTP
{
  DoIP_Diag_SendTesterPresent();
  settimer(this,2000);
}
/// <TCP>
*/
/*
  Stop Chat Client and close connection to server
*/
int TcpClientStop()
{
  CHAR errorText[200];
  byte ServerPortIndex;

  //
  // Close socket
  //
        TcpClose(gTcpSocketHandleGW);
        gTcpSocketHandleGW = 0;
    return 0;
  
}

/// <TCP>
/*
 * Send text of SysVar ChatClient1::Text to server.
 */
int TcpSendtoServer(byte abData[], word wLen)
{
  Byte text[1048510];
  char chartext[1048510]; 
  long copiedBytes;
  byte newData[1];
  long result;
  
 // sysGetVariableData( sysvar::TCPClt::SendBuffer, text,copiedBytes );
  
  //sysSetVariableData( sysvar::TCPSrv::RecvBuffer, newData, 0 ); //clear buffer
  
  //sysSetVariableInt( sysvar::TCPSrv::RecvLen, 0 );
  
  result =  TcpSend( gTcpSocketHandleGW, abData, wLen );
  
 // sysGetVariableInt( sysvar::TCPClt::SendLen, copiedBytes );


    memcpy(chartext,text,copiedBytes);
  
   if (result == 0)
  {
    // sending took place immediately.
      
 //   write( "$$  <%BASE_FILE_NAME%> TCP Sent out %d bytes",wLen );
   // writeLineEx(1, 1, " [ $ <%BASE_FILE_NAME%>: Synchronous sending: on socket %d ]", gTcpSocketHandleGW);
    OnTcpSend(gTcpSocketHandleGW, result, chartext, copiedBytes); // trigger callback manually
  }
  else
  {
    if (result == -1)
    {
      result = IpGetLastSocketError(gTcpSocketHandleGW);
      if (result == 997)
      {
        // sending is done asynchronously.
  //      writeLineEx(1, 1, " [ $$ <%BASE_FILE_NAME%>: Asynchronous sending: on socket %d ]", gTcpSocketHandleGW);
        // => OnTcpSend is called when done sending.
      }
      else
      {
 //       writeLineEx( 1, 3, " [ $$ <%BASE_FILE_NAME%>: sendTcpData: Error sending data. (%d) ]", result);
      }
    }
    else
    {
 //     writeLineEx( 1, 3, " [ $$ <%BASE_FILE_NAME%>: sendTcpData: Error sending data. (%d) ]", result);
    }
  } 
  
  return 0;
}

OnTcpSend(dword socket, long result, char buffer[], dword size)
{
  TcpReceivefromServer();
}

/// <TCP>
int TcpReceivefromServer()
{
    CHAR errorText[200];
  long result;
  
//   write( "$$  <%BASE_FILE_NAME%> Started receiving.." );
  
   //sysSetVariableInt( sysvar::TCPClt::RecvLen, 0 );
  
   result = TcpReceive( gTcpSocketHandleGW, gReceiveBuffer, elcount(gReceiveBuffer) );

  /*
    if (ipGetLastSocketError(gClientSocket) != 997)
    {
      IpGetLastSocketErrorAsString( gClientSocket, errorText, elcount(errorText) );
      write( "$$  <%BASE_FILE_NAME%> TcpSocket::Receive failed, %s (Result %d)", errorText, IpGetLastSocketError(gClientSocket) );
      return -1;
    }
    */
  
  if (result == -1)
  {
    result = IpGetLastSocketError(gTcpSocketHandleGW);
    if (result != 997) // not asynchronous
    {
      // failure
      IPGetLastSocketErrorAsString(gTcpSocketHandleGW, errorText, elcount(errorText) );
//      write( "$$ <%BASE_FILE_NAME%> TcpReceive failed, %s (Result %d)", errorText, IpGetLastSocketError(gTcpSocketHandleGW) );
      
    }
  }
  else if (result != 0) // synchronous sending failed
  {
    // failure
//    writeLineEx( 1, 3, "$$ <%BASE_FILE_NAME%>: TcpReceive error %d", result);
  }
    return 0;
}

/// <TCP>
/*
 * Data is received from Chat Server. Put it to text buffer.
 *
 * socket  - Socket handle of the client
 * result  - Result of the operation, 0 on success
 * buffer  - Buffer which contains the received data
 * size    - Size in bytes of the received data
 */
void TcpReceiveInternal( dword socket, long result, char buffer[], dword size)
{
  CHAR errorText[200];
  //BYTE receiveData[1500];
  int i;
  LONG retVal;
  char SendText[200];
  byte newData[1];
  long copypostion;
  char bufferlocal[50];
   long copiedBytes;
  dword localsize;
  byte TempByte[50];

localsize=size;
  
  memcpy(TempByte,buffer,size);
  //
  // Put text to the panel
  //

    write( "$$  <%BASE_FILE_NAME%> TCP received %d bytes, socket 0x%x", size, socket );

  //  if (result == 0)
  if(socket == gTcpSocketHandleGW )
    {
      
          //there is still unread bytes?
          //sysGetVariableInt( sysvar::TCPClt::RecvLen, copypostion );

         if(localsize == size+1)
        {}
        else
          sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, size );


    //  write( "$$  <%BASE_FILE_NAME%>  %d bytes copied to Hex Panel", size);
      

      putValueToControl( kPanelName, "DoIPOutput", "Received Tcp response from Kombi. \r\n");
    }    
}

OnTcpConnect(dword socket, long result)
{
  //  write( "$$  <%BASE_FILE_NAME%> OnTcpConnect with result %d, socket 0x%x", result, socket );
  if (result == 0)
  {
      if(socket == gTcpSocketHandleGW  )
      {
  //       write("Tcp client connected from socket 0x%x ", gTcpSocketHandleGW);
      }
    }
}

OnTcpClose( dword socket, long result)
{
 // write( "$$  <%BASE_FILE_NAME%> TCP connection closed, result %d", result );

  TcpClose(socket);
  socket = 0;
}

OnTcpReceive(dword socket, long result, byte ipv6Address[], dword port, char buffer[], dword size)
{
    TcpReceiveInternal( socket, result, buffer, size);
}

/*
/// <DoIP_Cmd>
void DoIP_VinRequest_VIN()
{
  DoIP_MessageHeadBuilder(0x0003,17); //6 bytes of eid
  
  memcpy(gDoIPPayload,gabEmptyArray,elcount(gabEmptyArray));
  
  memcpy_off(gDoIPPayload,8,Vin,0,17);
  
  DoIP_MessageUdpSend(gcRequestHeadLen+17);
  
  putValueToControl( kPanelName, "DoIPOutput", " Sent Vehicle Indetification  request with VIN. \r\n");
}
*/

/*
/// <DoIP_Cmd>
void DoIP_Entity_Status_Request()
{
    DoIP_MessageHeadBuilder( 0x4001,0 ); //6 bytes of eid
   
    DoIP_MessageUdpSend( gcRequestHeadLen );
  
    putValueToControl( kPanelName, "DoIPOutput", " Sent Entity status request. \r\n");
}
*/

/*
/// <DoIP_Cmd>
void DoIP_Pwr_mode_Request()
{
  DoIP_MessageHeadBuilder(0x4003,0); //6 bytes of eid
   
  DoIP_MessageUdpSend(gcRequestHeadLen);
  
    putValueToControl( kPanelName, "DoIPOutput", " Sent Power mode status request. \r\n");
  
}
*/

/*
/// <DoIP>
void DoIP_ProInit()
{
  long EidLen =6;
  long VinLen =17;
  long lSrcAddr;
  long lDstAddr;
  long lProtoVer;
  long lActType;

  stRoutingActivation.Reservedoc = 0;
  stRoutingActivation.ReserveOEM = 0;

  sysGetVariableInt( sysvar::DoIP::SrcAddr,lSrcAddr ); 
  sysGetVariableInt( sysvar::DoIP::DstAddr, lDstAddr); 
  sysGetVariableInt( sysvar::DoIP::ProtocolVer, lProtoVer); 
  sysGetVariableInt( sysvar::DoIP::ActType, lActType); 

  stDoIPHead.ProtocolVer = lProtoVer;
  stDoIPHead.InvProtocolVer = ~stDoIPHead.ProtocolVer;
  
  stRoutingActivation.ActType = lActType;
  stRoutingActivation.SrcAddr = lSrcAddr;

  stDiagMsgHead.SrcAddr = lSrcAddr;
  stDiagMsgHead.DstAddr = lDstAddr;

  sysGetVariableData( sysvar::DoIP::EID, Eid, EidLen ); 
  sysGetVariableData( sysvar::DoIP::VIN, Vin, VinLen ); 
}
*/

/*
on timer TestTimer
{
    //SendUdpMsg(gUdpSocketHandleGW,ipv6Kombi,dwDstPort,abData);
  
  switch (DoIPID)
   {
    case 0:
        DoIP_VinRequest();

      break;
      
    case 1:
       DoIP_VinRequest_EID();
      break;
      
      
    case 2:
       DoIP_VinRequest_VIN();
      break;
      
    case 3:
       DoIP_Entity_Status_Request();
      break;
      
    case 4:
       DoIP_Pwr_mode_Request();
      break;
    
    case 5:
      DoIP_Route_Act_Request();
      break;
      
    case 6:
     DoIP_DiagMsg_Request();
      break;

   }
  
  DoIPID++;
  
  if(DoIPID >= gMAXIDNO)
    DoIPID = 0;
  
  
    setTimer( TestTimer, 3 );
}
*/

/// <Udp>
OnUdpReceiveFrom(dword socket, long result, byte ipv6Address[], dword port, char buffer[], dword size)
{
      if(port == dwDstPort) //Only if it is msg from the UDPNM channel 
    {
        RecvMsghandler(buffer, size);
        write("<%BASE_FILE_NAME%> Received message from Udp port");
    }

   ReceiveUdpMsg( socket);
}

/*
on key 'b'
{
  strncpy(txBuffer, "Hello UDP from CANoe", elcount (txBuffer));
  udpSendTo(udpHandle, receiverIPdw, receiverPortdw, txBuffer, strlen(txBuffer)); 
  
 // OutputToPanel(3, receiverPortdw);
}
*/

/// <Udp>
byte u8IPv6Compare(byte ipv6Address1[],byte ipv6Address2[])
{
  byte Cnt;
  
  for(Cnt=0;Cnt<16;Cnt++)
  {
    if(ipv6Address1[Cnt] != ipv6Address2[Cnt])
    {
      return 1; //different IP
    }
  }
  return 0;//same IP
}

/// <Udp>
void vOpenIPv6UdpPort( dword &UdpSocketHandler, byte ipv6SrcAddr[],dword ipv6SrcPort)
{
    int i;                          // loop variable  
    dword result;  
    byte ipv6WildcardAddrArray[16]; /* ipv6  address  Wildcard */
    char textData[20] = "Hello UDP Server";
  
  //wildcard IP binding
    result = IpGetAddressAsArray("::", ipv6WildcardAddrArray);

    if (result == 0)
    {
      // success...
      write("<%BASE_FILE_NAME%>IpGetAddressAsArray: returned wildcard array with IPv6 bytes:");
      for ( i=0; i<16; i++)
      {
        write("<%BASE_FILE_NAME%>Byte %.2d = 0x%.2x", i, ipv6WildcardAddrArray[i]);
      }
    }
    else
    {
      writeLineEx(1, 3, "IpGetAddressAsArray: The wildcard address string was invalid.");
    }
 

    // Open UDP socket
    UdpSocketHandler = UdpOpen(ipv6SrcAddr, ipv6SrcPort); // if The port parameter is set to zero. => A free local port is selected by the stack.

    // Check for valid socket handle
    if (UdpSocketHandler == ~0)
    {
      write("<%BASE_FILE_NAME%> UdpOpen failed: Result %d", IpGetLastError());
    }
    else // Socket handle valid
    {

        write("<%BASE_FILE_NAME%> Udp Open is successful..  ");

    }
 }

/*
on sysvar_update DoIP::ConnectSrv
{
    BYTE  remoteAddressIPv6[16];
    BYTE  localAddressIPv6[16];
    CHAR  errorText[200];
    LONG  result;

    long TcpServerPorts;
    long TcpClientPort = 13400 ;

    TcpServerPorts = 13400;
  

  
   if(@this)
  {
    
    
          TcpClose(gTcpSocketHandleGW);
          gTcpSocketHandleGW = 0;

          gTcpSocketHandleGW = TcpOpen( localAddressIPv6, TcpClientPort );
          ipSetSocketOption( gTcpSocketHandleGW, "IPPROTO_IPV6", "IPV6_AUTOFLOWLABEL", 0 );
          if (IpGetLastSocketError(gTcpSocketHandleGW) != 0)
          {
            IpGetLastSocketErrorAsString( gTcpSocketHandleGW, errorText, elcount(errorText) );
            write( "$$  <%BASE_FILE_NAME%> TcpSocket::open IPv6 failed, %s (Result %d)", errorText, IpGetLastSocketError(gTcpSocketHandleGW) );
           
          }

         ipGetAddressAsArray(ipv6KombiStr, remoteAddressIPv6);

          result = TcpConnect( gTcpSocketHandleGW, remoteAddressIPv6, TcpServerPorts );
          if (result != 0 && ipGetLastSocketError(gTcpSocketHandleGW) != 10035 ) // WSAEWOULDBLOCK
          {
            IpGetLastSocketErrorAsString(gTcpSocketHandleGW, errorText, elcount(errorText) );
            write( "$$  <%BASE_FILE_NAME%> TcpSocket::connect IPv6 failed, %s (Result %d)", errorText,IpGetLastSocketError(gTcpSocketHandleGW) );
         
          }
          
          write( "$$  <%BASE_FILE_NAME%> TCP Client connecting to port: %d, from Socket: 0x%x", TcpServerPorts,gTcpSocketHandleGW  );
 
  }
     
}
*/

/*
/// <DoIP>
void DoIP_MessageHeadBuilder(word wMsgID,dword dwLen)
{
  stDoIPHead.wPayloadType = wMsgID;
  stDoIPHead.dwpayloadLen = dwLen;
 
}
*/

/*
/// <DoIP_Cmd>
dword DoIP_MessageUdpSend(word wLen)
{

  byte TempByte[1] ='\0';
  
  memcpy_h2n(gDoIPPayload,stDoIPHead);

  gResult = SendUdpMsg(gUdpSocketHandleGW,ipv6Kombi,dwDstPort,gDoIPPayload,wLen);
  
  
  sysSetVariableData( sysvar::DoIP::InputHext, gDoIPPayload, wLen ); //output sent hex 
  
  sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, 0 ); //clear hex output
  
  return gResult;
}
*/

/*
/// <DoIP>
dword DoIP_MessageTcpSend(word wLen)
{
  byte TempByte[1] = '\0';
  
  memcpy_h2n(gDoIPPayload,stDoIPHead);
  
   gResult = TcpSendtoServer(gDoIPPayload,wLen);
  
  if(gDoIPPayload[12]== 0x3E && gDoIPPayload[13]==0x00)
  {}
  else
   sysSetVariableData( sysvar::DoIP::InputHext, gDoIPPayload, wLen ); //output sent hex 
  
   sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, 0 ); //clear hex output

  return gResult;
}
*/

/// <Udp>
dword SendUdpMsg(dword &UdpSocketHandler,byte ipv6DstAddr[],dword ipv6DstPort,byte textData[], word wLen)
{
    if(wLen == 0)
        wLen = elcount(textData);
  
    gResult = UdpSendTo(UdpSocketHandler, ipv6DstAddr, ipv6DstPort, textData,wLen );
  
      // Check for error
    if ( (gResult != 0) && (IpGetLastSocketError(UdpSocketHandler) != 997) )
    {
      IpGetLastSocketErrorAsString(UdpSocketHandler, gErrorText, elcount(gErrorText) );
      write( "<%BASE_FILE_NAME%> UdpSendTo failed, %s (Result %d)", gErrorText, IpGetLastSocketError(UdpSocketHandler) );
    }
    return gResult; 
 }

/// <Udp>
dword ReceiveUdpMsg(dword &UdpSocketHandler)
 {
  
       // Optionally receive answer from UDP server
      UdpReceiveFrom(UdpSocketHandler, gRxBuffer, 0); // Set size to 0 to enforce reception in callback only

      // Check for error
      if ( IpGetLastSocketError(UdpSocketHandler) != 997 )
      {
        IpGetLastSocketErrorAsString(UdpSocketHandler, gErrorText, elcount(gErrorText));
        write("<%BASE_FILE_NAME%> UdpReceiveFrom failed, %s (Result %d)", gErrorText, IpGetLastSocketError(UdpSocketHandler));
      }
 return  gResult;
}

/// <Udp>
void RecvMsghandler(char buffer[], dword size)
{
      byte TempByte[50];
  
       memcpy(TempByte,buffer,size);
  
      putValueToControl( kPanelName, "DoIPOutput", "Received Udp response from Kombi. \r\n");
     
      sysSetVariableData( sysvar::DoIP::OutputHex, TempByte, size );
}

/// <Udp>
void vConvertIPv6toArray(char acAddrStr[], byte abAddr[])
{
     int i; // loop variable 
  LONG gResult;
  //1nd IPv6 interface 
 //   write("Converting IPv6 Address %s to bytes...", acAddrStr);

    gResult = IpGetAddressAsArray( acAddrStr, abAddr );
    if (gResult == 0)
    {
      // success...
 //     write("IpGetAddressAsArray: returned array with IPv6 bytes:");
      for ( i=0; i<16; i++)
      {        
  //      write("Byte %.2d = 0x%.2x", i, abAddr[i]);
      }
    }
    else
    {
      write("Error converting");
    } 
}

on preStart
{
    // prepare IPv6-Adresses in Array-format
    vConvertIPv6toArray( ipv6SourceAddrStr, ipv6SourceAddr );
    vConvertIPv6toArray( ipv6DestAddrStr, ipv6DestAddr );
    vConvertIPv6toArray( ipv6GatewayStr, ipv6Gateway );
    vConvertIPv6toArray( ipv6KombiStr, ipv6Kombi );
    vConvertIPv6toArray( ipv6MulticastGrpStr, ipv6MulticastGrp ); 
    vConvertIPv6toArray( ipv6TA02_MulticastGrpStr, ipv6TA02_MulticastGrp );  
}

