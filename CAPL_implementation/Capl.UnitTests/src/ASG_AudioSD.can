/*@!Encoding:1252*/
/* Global variables for the AudioSD CANoe BAP simulation */
variables
{
  //*************************General Variables*************************************
  // general values for readable code
  const FALSE             =0;
	const TRUE              =1;
	const NULL              =0x00;
  const VALID             =0x01;
  const INVALID           =0x00;
  const FORWARD           =0;
  const BACKWARD          =1;
  char empty_string [3]   ={0,0,0};
  char gstring_reserved [10]      ="reserved";
  char gstring_defect [10]        ="defect";
  char gstring_not_supported [20] ="not supported";
  char gstring_unknown [20]       ="unknown";
  //BAP Data Type 
  const Bap_Void			    =0;
  const Bap_UInt8			    =1;
  const Bap_UInt16		    =2;
  const Bap_UInt32		    =3;
  const Bap_ByteSequence	    =4;
  const Bap_Error			    =5;
  const Bap_Acknowledge       =6;
  //BAP request types (FSG)
  const DataSetGet_REQ	=0x00;
  const DataSet_REQ		=0x01;
  const DataGet_REQ		=0x02;
  const Start_REQ			=0x05;
  const StartResult_REQ	=0x06;
  const AbortResult_REQ	=0x07;
  const Ack_REQ           =0x0B;    
  const Invalid_REQ    	=0x1F;  // Interne Kennzeichnung fuer einen ungueltigen Request
  //BAP indication types (ASG)
  const Data_IND			=0x00;
  const Reset_IND         =0x01;
  const DataAck_IND       =0x02;
  const Result_IND		=0x03;
  const Processing_IND	=0x04;  
  const Changed_IND		=0x05;
  const Invalid_IND		=0x1F;  // Interne Kennzeichnung fuer eine ungueltige Indication
  // BAP and BAL error codes
  const gBAP_datalength_error =0x41;
  const Error_REQ=0x55;
  const Error_IND =0x55;
  const BAP_NO_ERROR               =0x00;
  const BAP_BAL_OUT_OF_RANGE       =0x41;
  const BAP_BAL_TEMP_NOT_AVAILABLE =0x42;
  const BAP_BAL_MAX_DL_EXCEEDED    =0x43;
  const BAP_BAL_UNIT_MISMATCH      =0x44;
  const BAP_ERR_OK = 0x00;
  char gerror_codes_BCL [16][30] = {  0,
								"Media not accesible",
								"illegal sequence",
								"Sequenzfehler Segmentierung",
								"Timeout Segmentierung",
								"BCL not running",
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0};
  char gerror_codes_BPL [16][30] = {  0,
								"Heartbeat Timeout",
								"Retry Timeout",
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0};
  char gerror_codes_BAL [16][40] = {  0,
								"Falsche Adressierung",
								"Inkompatible Protokollversion",
								"Inkompatible Version Datenfestlegung",
								"Daten ungültig",
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0,
								0};
  char gerror_codes_0x40_0x7F [17][40] = {"reserved",
									"Apll-out of range",
									"Appl-temporary not available",
									"Appl-max data length exceeded",
									"Appl - unit mismatch",
									"Appl - parameter mismatch",
									"Appl - invalid argument",
									"Appl - FailedToCreateNewListMember",
									"reserved",
									"reserved",
									"reserved",
									"reserved",
									"reserved",
									"reserved",
									"reserved",
									"reserved",
									"Appl-method aborted"};
  //Array's
  //values for reading *.csv-file
  const AUDIO_DEFAULT_LIST  = 0;
  const AUDIO_EXTERNAL_LIST = 1;
  const AUDIO_FILENAME_SIZE = 50;
  const AUDIO_BUFFERSIZE    = 0xFFFF;
  const AUDIO_TEXTLENGTH    = 500;
  const AUDIO_TEXTLENGTH_URI    = 600;
  //other
  byte gErrorCode;
  byte gASG_PowerOnOff = FALSE;
  const POWER_OFF = 0x00;
  const POWER_ON  = 0x01;
  byte gBAP_Init = FALSE;
  char gstring_ASG_PowerOnOff[2][4]={ "Off",
         							            "On"};
  dword gRGB_red;
  dword gRGB_yellow;
  dword gRGB_green;
  dword gRGB_grey;
  dword gRGB_white;
  byte gBAP_AudioSD_available =FALSE;
  //Ethernet
  struct UdpSocket{
    dword Handle;
    dword Id;
  };
  struct UdpSocket gUdpSockets[5];
  dword gUdpSocketCnt;
  int canEthernetDecider;
  
  //*************************BAP node**********************************************
  //Timers
  mstimer TaskTimer;													//timer for BAP-Task
  mstimer Powerontimer; 
  // node index and LSG-IDs
  dword NODE_INDEX;
  const LSG_AudioSD	=0x31;
  // BAP and LSG-Version information (these are not used, just informations; see XML-file for current definitions!)
  const BAP_VERSION_MAJOR =0x03;
  const BAP_VERSION_MINOR =0x00;
  const LSG_CLASS_1       =LSG_AudioSD;
  const LSG_SUBCLASS_1    =0x00;
  const LSG_VERSION_MAJOR =0x05;
  const LSG_VERSION_MINOR =0x00;
  byte FunctionList_flag  =FALSE;
  // Function-IDs
  //common function-IDs
  const FctID_GetAll				=0x01;
  const FctID_BAP_Config			=0x02;
  const FctID_FunctionList		=0x03;
  const FctID_HeartBeat			=0x04;
  const FctID_FSG_Control			=0x0D;
  const FctID_FSG_Setup			=0x0E;
  const FctID_FSG_OperationState	=0x0F;
  // specific function-IDs
  const FctID_ASG_Capabilities		= 0x10;
  const FctID_InfoStates				= 0x11;
  const FctID_SDS_State				= 0x12;
  const FctID_GeneralInfoSwitches		= 0x13;
  const FctID_ActiveSource			= 0x14;
  const FctID_ActiveSourceName		= 0x15;
  const FctID_CurrentVolume			= 0x16;
  const FctID_SourceState				= 0x17;
  const FctID_CurrentStationInfo		= 0x18;
  const FctID_CurrentStation_Handle	= 0x19;
  const FctID_PlayPosition			= 0x1A;
  const FctID_Station_Track_Switch	= 0x1B;
  const FctID_AnnouncementInfo		= 0x1C;
  const FctID_AnnouncementEscape		= 0x1D;
  const FctID_ReceptionList			= 0x1E;
  const FctID_RadioTV_PresetList		= 0x1F;
  const FctID_ListSetup				= 0x20;
  const FctID_SourceList				= 0x21;
  const FctID_DedicatedAudioControl	= 0x22;
  const FctID_SwitchSource			= 0x23;
  const FctID_Browser_FolderLevel		= 0x24;
  const FctID_Browser					= 0x25;
  const FctID_BrowserPath				= 0x26;
  const FctID_BrowserControl			= 0x27;
  const FctID_Picture					= 0x28;
  
  //***********************************BAP buffer**********************************
  const REQUESTBUFFER_LINES    =100;
  const BAP_BUFFER_SIZE        =4000;
  int gBAP_Requestbuffer_status [REQUESTBUFFER_LINES];				//datalength
  int gBAP_Requestbuffer_BAPDataTyp [REQUESTBUFFER_LINES];			//data type
  dword gBAP_Indication[BAP_BUFFER_SIZE];								//Bap-Indication-buffer
  dword gBAP_Request [REQUESTBUFFER_LINES] [BAP_BUFFER_SIZE];			//ringbuffer for BAP-Request
  int gwrite_requestbuffer_line   =0;									//next free position
  int gstatus_requestbuffer       =0;                                 //next position to send
  
  //***********************************Config Files********************************
  char dbc_path[255]  = "DBs\\MQB2020.MQB_W_ICAN_KMatrix_V9.04F_20171214_MB.dbc";    		//relative path for dbc-file							
  char dbce_path[255] = "DBs\\MQB_V7.19F_AR421_20170529.arxml";//relative path for dbc-file
  char xml_path[255]  = "XML\\BAP_SW18_KI_FPK_Medium_All_MQB37W_v1_20_F_modCAN.xml";   //relative path for xml-file
  char xmle_path[255] = "XML\\BAP_SW18_KI_FPK_Medium_All_MQB37W_v1_30_ETH.xml";

  //***********************************Output windows******************************
  dword gBAP_Trace, gError_Trace;
  
  
  //*************************************************************************
  //*****************Fct-IDs*************************************************
  //*************************************************************************
  /***GetAll***/
  msTimer ASGCapa_startTimer;
  
  /***FunctionList***/
  byte gFunctionList_FctList[8];
  
  /***FSG-Control***/
  byte gAudioSD_FSGControl_Extension1 = 0;
  byte gAudioSD_FSGControl_Extension2 = 0;
  byte gAudioSD_FSGControl_Extension3 = 0;
  byte gAudioSD_FSGControl_Extension4 = 0;
  byte gAudioSD_FSGControl_Extension5 = 0;
  byte gAudioSD_FSGControl_Extension6 = 0;
  
  /***FSG-Setup***/
  byte gAudioSD_FSGSetup_FunctionSupport = 0;
  byte gAudioSD_FSGSetup_FunctionSupport_Bit0 = 0;
  byte gAudioSD_FSGSetup_FunctionSupport_Bit1 = 0;
  byte gAudioSD_FSGSetup_FunctionProtection = 0;
  byte gAudioSD_FSGSetup_FunctionProtection_Bit0 = 0;
  byte gAudioSD_FSGSetup_WebAppState = 0;
  byte gAudioSD_FSGSetup_WebAppState_Bit0 = 0;
  byte gAudioSD_FSGSetup_Extension1 = 0;
  byte gAudioSD_FSGSetup_Extension2 = 0;
  byte gAudioSD_FSGSetup_Extension3 = 0;
  byte gAudioSD_FSGSetup_Extension4 = 0;
  
  /*** FSG-OperationState***/
  const FSGOPERATIONSTATE_NORMALOPERATION = 0x00;
  const FSGOPERATIONSTATE_OFF             = 0x01;
  const FSGOPERATIONSTATE_INITIALIZING    = 0x03;
  const FSGOPERATIONSTATE_DEFECT          = 0x0F;
  byte gAudioSD_FSGOperationState_OpState = FSGOPERATIONSTATE_OFF;
  byte gAudioSD_FSGOperationState_Extension1 = 0;
  byte gAudioSD_FSGOperationState_Extension2 = 0;
  byte gAudioSD_FSGOperationState_Extension3 = 0;
  byte gAudioSD_FSGOperationState_Extension4 = 0;
  byte gAudioSD_FSGOperationState_Extension5 = 0;

  /***ASG_Capabilities***/
  byte gAudioSD_ASGCapabilities_PresentationCapabilities = 0;
  byte gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = 0;
  char gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0_string[2][20]= {   "DAB short",
                                                                                 "DAB long"};
  byte gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 = 0;
  char gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1_string[2][20]= {   "SDARS short",
                                                                                 "SDARS long"};
  byte gAudioSD_ASGCapabilities_Extension1 = 0;
  byte gAudioSD_ASGCapabilities_Extension2 = 0;
  byte gAudioSD_ASGCapabilities_Extension3 = 0;
  byte gAudioSD_ASGCapabilities_Extension4 = 0;
  byte gAudioSD_ASGCapabilities_Extension5 = 0;
  
  /***InfoStates***/
  //mstimer InfoStates_Start_Timer;
  byte gAudioSD_InfoStates_States = 0;
  byte gAudioSD_InfoStates_AdditionalStateInfo = 0;
  byte gAudioSD_InfoStates_AdditionalStateInfo_Bit0 = 0;
  byte gAudioSD_InfoStates_Extension1 = 0;
  byte gAudioSD_InfoStates_Extension2 = 0;
  byte gAudioSD_InfoStates_Extension3 = 0;
  byte gAudioSD_InfoStates_Extension4 = 0;
  
  /***SDS_State***/
  byte gAudioSD_SDSState_State = 0;
  byte gAudioSD_SDSState_Extension1 = 0;
  byte gAudioSD_SDSState_Extension2 = 0;
  byte gAudioSD_SDSState_Extension3 = 0;
  byte gAudioSD_SDSState_Extension4 = 0;
  byte gAudioSD_SDSState_Extension5 = 0;
  
  /***GeneralInfoSwitches***/
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches = 0;
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA      = 0; //Bit0
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS       = 0; //Bit1
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic = 0; //Bit2
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC       = 0; //Bit3
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS      = 0; //Bit4
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online    = 0; //Bit5
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB       = 0; //Bit6
  byte gAudioSD_GeneralInfoSwitches_Extension1 = 0;
  byte gAudioSD_GeneralInfoSwitches_Extension2 = 0;
  byte gAudioSD_GeneralInfoSwitches_Extension3 = 0;
  byte gAudioSD_GeneralInfoSwitches_Extension4 = 0;
  byte gAudioSD_GeneralInfoSwitches_Extension5 = 0;
  
  /***ActiveSource***/
  const ACTIVESOURCE_UNKNOWNSOURCE                = 0xFF;
  const ACTIVESOURCE_SOURCETYPE_FM                = 0x01;
  byte gAudioSD_activeSource_SourceType = 0;
  word gAudioSD_activeSource_SourceList_Reference = 0;
  byte gAudioSD_activeSource_ListAvailable = 0;
  byte gAudioSD_activeSource_ListAvailable_Bit0 = 0;
  byte gAudioSD_activeSource_ListAvailable_Bit1 = 0;
  byte gAudioSD_activeSource_ListAvailable_Bit2 = 0;
  const ACTIVESOURCE_LISTSTATE_COMPLETELY_LOADED  = 0x03;
  byte gAudioSD_activeSource_ListState = 0;
  byte gAudioSD_activeSource_Extension1 = 0;
  byte gAudioSD_activeSource_Number = 0;
  
  /***ActiveSourceName***/
  const ACTIVE_SOURCE_NAME_LENGTH = 61;
  char gAudioSD_activeSourceName[ACTIVE_SOURCE_NAME_LENGTH];
  
  /***CurrentVolume***/
  byte gAudioSD_currentVolume_ChangingVolumeType = 0;
  byte gAudioSD_currentVolume_maxVolume = 0;
  byte gAudioSD_currentVolume_GenericVolume = 0;
  byte gAudioSD_currentVolume_MuteState = 0;
  byte gAudioSD_currentVolume_MuteState_Bit0 = 0;
  byte gAudioSD_currentVolume_MuteState_Bit1 = 0;
  byte gAudioSD_currentVolume_MuteState_Bit2 = 0;
  byte gAudioSD_currentVolume_MuteState_Bit3 = 0;
  byte gAudioSD_currentVolume_MuteState_Bit4 = 0;
  byte gAudioSD_currentVolume_MuteState_Bit5 = 0;
  byte gAudioSD_currentVolume_MuteState_Bit6 = 0;
  byte gAudioSD_currentVolume_MuteState_Bit7 = 0;
  byte gAudioSD_currentVolume_Extension1 = 0;
  byte gAudioSD_currentVolume_Extension2 = 0;
  
  /***SourceState***/
  byte gAudioSD_SourceState_StateInfo = 0;
  char gAudioSD_SourceState_StateInfo_string[8][20] = {   "unknown",
            							                                "scan",
            							                                "mix",
            							                                "repeat",
                                                          "repeat/mix",
                                                          "manual tuning",
                                                          "seek",
                                                          "play more like this"};
  byte gAudioSD_SourceState_Scope = 0;
  char gAudioSD_SourceState_Scope_string[9][40] ={    "unknown scope /any scope",
                                                      "file/track",
                                                      "device",
                                                      "medium",
                                                      "directory without subdirectories",
                                                      "directory with subdirectories",
                                                      "all directories /all folders",
                                                      "playlist",
                                                      "all playlists"};
  byte gAudioSD_SourceState_Extension1 = 0;
  byte gAudioSD_SourceState_Extension2 = 0;
  byte gAudioSD_SourceState_Extension3 = 0;
  byte gAudioSD_SourceState_Extension4 = 0;
  
  /***CurrentStationInfo***/
  const CSI_INFORMATION_TEXTLENGTH = 73;
  const PRIMARYINFORMATION_TEXTLENGTH = 73;
  char gAudioSD_CSI_PrimaryInformation[PRIMARYINFORMATION_TEXTLENGTH];
  byte gAudioSD_CSI_PI_Type = 0;
  word gAudioSD_CSI_PIID = 0;
  const SECONDARYINFORMATION_TEXTLENGTH = 73;
  char gAudioSD_CSI_SecondaryInformation[SECONDARYINFORMATION_TEXTLENGTH];
  byte gAudioSD_CSI_SI_Type = 0;
  const TERTIARYINFORMATION_TEXTLENGTH = 73;
  char gAudioSD_CSI_TertiaryInformation[TERTIARYINFORMATION_TEXTLENGTH];
  byte gAudioSD_CSI_TI_Type = 0;
  const QUATERNARYINFORMATION_TEXTLENGTH = 73;
  char gAudioSD_CSI_QuarternaryInformation[QUATERNARYINFORMATION_TEXTLENGTH];
  byte gAudioSD_CSI_QI_Type = 0;
  const INFORMATION5_TEXTLENGTH = 73;
  char gAudioSD_CSI_Information5[INFORMATION5_TEXTLENGTH];
  byte gAudioSD_CSI_I5_Type = 0;
  const INFORMATION6_TEXTLENGTH = 73;
  char gAudioSD_CSI_Information6[INFORMATION6_TEXTLENGTH];
  byte gAudioSD_CSI_I6_Type = 0;
  const INFORMATION7_TEXTLENGTH = 73;
  char gAudioSD_CSI_Information7[INFORMATION7_TEXTLENGTH];
  byte gAudioSD_CSI_I7_Type = 0;
  const INFORMATION8_TEXTLENGTH = 73;
  char gAudioSD_CSI_Information8[INFORMATION8_TEXTLENGTH];
  byte gAudioSD_CSI_I8_Type = 0;
  byte gAudioSD_CSI_StationInfoSwitches = 0;
  byte gAudioSD_CSI_StationInfoSwitches_Bit0  = 0; //Bit0
  byte gAudioSD_CSI_StationInfoSwitches_Bit1  = 0; //Bit1
  byte gAudioSD_CSI_StationInfoSwitches_Bit2  = 0; //Bit2
  byte gAudioSD_CSI_StationInfoSwitches_Bit3  = 0; //Bit3
  byte gAudioSD_CSI_StationInfoSwitches_Bit4  = 0; //Bit4
  byte gAudioSD_CSI_StationProperties = 0;
  byte gAudioSD_CSI_StationProperties_Bit0            = 0; //Bit0
  byte gAudioSD_CSI_StationProperties_Bit1            = 0; //Bit1
  byte gAudioSD_CSI_StationProperties_Bit2            = 0; //Bit2
  byte gAudioSD_CSI_StationProperties_Bit3            = 0; //Bit3
  byte gAudioSD_CSI_StationProperties_Bit4            = 0; //Bit4
  byte gAudioSD_CSI_StationLinkingState = 0;
  word gAudioSD_CSI_ChannelID = 0;
  byte gAudioSD_CSI_RadioCategory = 0;
  byte gAudioSD_CSI_Extension1 = 0;
  
  /***CurrentStation_Handle***/
  word gAudioSD_CSIhandle_FSGhandle = 0;
  word gAudioSD_CSIhandle_FSGhandle_absolutePos = 0;
  byte gAudioSD_CSIhandle_PresetListRef = 0;
  byte gAudioSD_CSIhandle_PresetListabsolutePos = 0;
  word gAudioSD_CSIhandle_PictureRef = 0;
  byte gAudioSD_CSIhandle_Extension1 = 0;
  byte gAudioSD_CSIhandle_Extension2 = 0;
  byte gAudioSD_CSIhandle_Extension3 = 0;
  byte gAudioSD_CSIhandle_Extension4 = 0;
  byte gAudioSD_CSIhandle_Extension5 = 0;
  byte gAudioSD_CSIhandle_Extension6 = 0;
  byte gAudioSD_CSIhandle_Extension7 = 0;
  byte gAudioSD_CSIhandle_Extension8 = 0;
  byte gAudioSD_CSIhandle_Extension9 = 0;
  byte gAudioSD_CSIhandle_Extension10 = 0;
  byte gAudioSD_CSIhandle_Extension11 = 0;
  byte gAudioSD_CSIhandle_Extension12 = 0;
  byte gAudioSD_CSIhandle_Extension13 = 0;
  byte gAudioSD_CSIhandle_Extension14 = 0;
  byte gAudioSD_CSIhandle_Extension15 = 0;
  
  /***PlayPosition***/
  word gAudioSD_PlayPosition_TimePosition = 0;
  word gAudioSD_PlayPosition_TotalPlayTime = 0;
  byte gAudioSD_PlayPosition_Attributes = 0;
  byte gAudioSD_PlayPosition_Attributes_Bit0 = 0;
  byte gAudioSD_PlayPosition_BufferLevel = 0;
  
  /***Station_Track_Switch***/
  byte gAudioSD_STS_Event = 0;
  byte gAudioSD_STS_Direction = 0;
  byte gAudioSD_STS_Extension1 = 0;
  byte gAudioSD_STS_Extension2 = 0;
  byte gAudioSD_STS_Extension3 = 0;
  byte gAudioSD_STS_Extension4 = 0;
  byte gAudioSD_STS_Extension5 = 0;
  
  /***AnnouncementInfo***/
  const ANNOUNCEMENT_TYPE_NO_MESSAGE          = 0x00;
  byte gAudioSD_AnnouncementInfo_Type = 0;
  const ANNOUNCEMENT_STATIONNAME_TEXTLENGTH = 49;
  char gAudioSD_AnnouncementInfo_StationName[ANNOUNCEMENT_STATIONNAME_TEXTLENGTH];
  
  /***AnnouncementEscape***/
  byte gAudioSD_AnnouncementEscape_MethodHandling = 0;
  byte gAudioSD_AnnouncementEscape_status = 0;                    //flag for status of the method (0=not activ, 1=activ)
  byte gAudioSD_AnnouncementEscape_Reserve = 0;
  byte gAudioSD_AnnouncementEscape_Result = 0;
  const AUDIO_ANNOUNCEMENTESCAPE_SUCCESSFUL               = 0x00;
  const AUDIO_ANNOUNCEMENTESCAPE_NOTSUCCESSFUL            = 0x01;
  const AUDIO_ANNOUNCEMENTESCAPE_ABORTSUCCESSFUL          = 0x02;
  const AUDIO_ANNOUNCEMENTESCAPE_ABORTNOTSUCCESSFUL       = 0x03;
  const AUDIO_ANNOUNCEMENTESCAPE_ANNOUNCEMENTNOTACTIVE    = 0x04;
  byte gAudioSD_AnnouncementEscape_AsgId = 0;
  byte gAudioSD_AnnouncementEscape_Extension1 = 0;
  
  /***ReceptionList***/
  byte gReceptionList_ASGID = 0;
  byte gReceptionList_TAID = 0;
  word gReceptionList_TotalNumListElements = 0;
  const AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES = 0x00;
  byte gReceptionList_ElementType = AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES;
  word gReceptionList_ParentID = 0x0000;
  const AUDIO_RECEPTIONLIST_ENTRIES = 0xFF;
  word gReceptionList_Pos[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Waveband[AUDIO_RECEPTIONLIST_ENTRIES];     
  byte gReceptionList_Type[AUDIO_RECEPTIONLIST_ENTRIES];                                                 
  byte gReceptionList_Attributes1_Bit0[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit1[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit2[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit3[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit4[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit5[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit6[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit7[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes2_Bit0[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes2_Bit1[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes2_Bit2[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes2_Bit3[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes2[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_PresetID[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_FmRegCode[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Category[AUDIO_RECEPTIONLIST_ENTRIES];
  const AUDIO_RECEPTIONLIST_NAME_LENGTH = 49;
  char gReceptionList_Name[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_RECEPTIONLIST_NAME_LENGTH];
  const AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH = 31;
  char gReceptionList_Frequency[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH];  
  word gReceptionList_PicRef[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_ListEntryValidInformation[AUDIO_RECEPTIONLIST_ENTRIES]; //indicates the existence of the "record element" 
  byte gReceptionList_sum = 0;
  char gReceptionList_CSV_filename[AUDIO_FILENAME_SIZE];
  //other RL
  const AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE =9;
  const AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE   =0;
  const AUDIO_RECEPTIONLIST_SLIDINGWINDOW_ACTIVE      =1;
  byte gReceptionList_SlidingWindow_State             =AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE;
  const AUDIO_RECEPTIONLIST_NOCACHE              =0;
  const AUDIO_RECEPTIONLIST_BUILDUPCACHE         =1;
  const AUDIO_RECEPTIONLIST_DOWN_CACHE           =2;
  const AUDIO_RECEPTIONLIST_UP_CACHE             =3;
  const AUDIO_RECEPTIONLIST_UP                   =4;
  const AUDIO_RECEPTIONLIST_DOWN                 =5;
  byte gReceptionList_ListHandlingType           =AUDIO_RECEPTIONLIST_NOCACHE; 
  const AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE              =0;
  const AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_UP             =1;
  const AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_WINDOW         =2;
  const AUDIO_RECEPTIONLIST_BUILDUPCACHECACHE_DOWN           =3; 
  byte gReceptionList_cacheBuildUp                           =AUDIO_RECEPTIONLIST_BUILDUPCACHENOCACHE;
  const AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK        =0;
  const AUDIO_RECEPTIONLIST_CALLBACKREASON_CACHENEXT         =1;
  const AUDIO_RECEPTIONLIST_CALLBACKREASON_CHECKCACHE        =2;
  const AUDIO_RECEPTIONLIST_CALLBACKREASON_DISPLAYLIST       =3;
  byte gReceptionList_CallBackReason                         =AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK;
  byte gReceptionList_cacheDown                            =FALSE;
  byte gReceptionList_cacheUp                              =FALSE;
  byte gReceptionList_LastFirstElement                     =0;
  const AUDIO_RECEPTIONLIST_NO_NEXT_POSITION               =99;
  byte gReceptionList_recordaddress            =0; 
  byte gReceptionList_transmitpos              =0;
  const AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING             =0;  
  const AUDIO_RECEPTIONLIST_CURSORACTION_DOWN                =1;
  const AUDIO_RECEPTIONLIST_CURSORACTION_UP                  =2;
  byte gReceptionList_CursorAction                            =AUDIO_RECEPTIONLIST_CURSORACTION_NOTHING;
  const AUDIO_RECEPTIONLIST_DISPLAYLIST_REFRESH              =0;
  const AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS       =1;
  const AUDIO_RECEPTIONLIST_DISPLAYLIST_SEARCH_ELEMENTS      =2;
  byte gReceptionList_DisplayStatus                           =AUDIO_RECEPTIONLIST_DISPLAYLIST_FIRST_ELEMENTS;                                      
  const AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
  const AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;
  
  /***RadioTV_PresetList***/
  byte gRadioTVPresetList_ASGID = 0;
  byte gRadioTVPresetList_TAID = 0;
  byte gRadioTVPresetList_TotalNumListElements = 0;
  const AUDIO_RADIOTVPRESETLIST_ENTRIES = 0xFF;
  byte gRadioTVPresetList_Pos[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_PresetIndex[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  const AUDIO_RADIOTVPRESETLIST_WB_UNKNOWN      = 0x00;
  const AUDIO_RADIOTVPRESETLIST_WB_FM           = 0x01;
  const AUDIO_RADIOTVPRESETLIST_WB_AM           = 0x02;
  const AUDIO_RADIOTVPRESETLIST_WB_DAB          = 0x03;
  const AUDIO_RADIOTVPRESETLIST_WB_DMB          = 0x04;
  const AUDIO_RADIOTVPRESETLIST_WB_DVB          = 0x05;
  const AUDIO_RADIOTVPRESETLIST_WB_TV           = 0x06;
  const AUDIO_RADIOTVPRESETLIST_WB_SDARS        = 0x07;
  const AUDIO_RADIOTVPRESETLIST_WB_OnlineRadio  = 0x08;
  const AUDIO_RADIOTVPRESETLIST_WB_OnlineTV     = 0x09;
  byte gRadioTVPresetList_Waveband[AUDIO_RADIOTVPRESETLIST_ENTRIES]; 
  byte gRadioTVPresetList_Attributes1_Bit0[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit1[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit2[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit3[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit4[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit5[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit6[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit7[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2_Bit0[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2_Bit1[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2_Bit2[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2_Bit3[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2_Bit4[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  const AUDIO_RADIOTVPRESETLIST_NAME_LENGTH = 49;
  char gRadioTVPresetList_Name[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_RADIOTVPRESETLIST_NAME_LENGTH];    
  const AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH = 31;
  char gRadioTVPresetList_Frequency[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH];  
  word gRadioTVPresetList_PicRef[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_ListEntryValidInformation[AUDIO_RADIOTVPRESETLIST_ENTRIES]; //indicates the existence of the "record element" 
  byte gRadioTVPresetList_sum = 0;
  char gRadioTVPresetList_CSV_filename[AUDIO_FILENAME_SIZE];
  //other
  const AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE =9;
  const AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE   =0;
  const AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_ACTIVE      =1;
  byte gRadioTVPresetList_SlidingWindow_State             =AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE;
  const AUDIO_RADIOTVPRESETLIST_NOCACHE              =0;
  const AUDIO_RADIOTVPRESETLIST_BUILDUPCACHE         =1;
  const AUDIO_RADIOTVPRESETLIST_DOWN_CACHE           =2;
  const AUDIO_RADIOTVPRESETLIST_UP_CACHE             =3;
  const AUDIO_RADIOTVPRESETLIST_UP                   =4;
  const AUDIO_RADIOTVPRESETLIST_DOWN                 =5;
  byte gRadioTVPresetList_ListHandlingType           =AUDIO_RADIOTVPRESETLIST_NOCACHE; 
  const AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE              =0;
  const AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_UP             =1;
  const AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_WINDOW         =2;
  const AUDIO_RADIOTVPRESETLIST_BUILDUPCACHECACHE_DOWN           =3; 
  byte gRadioTVPresetList_cacheBuildUp                           =AUDIO_RADIOTVPRESETLIST_BUILDUPCACHENOCACHE;
  const AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK        =0;
  const AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CACHENEXT         =1;
  const AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_CHECKCACHE        =2;
  const AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_DISPLAYLIST       =3;
  byte gRadioTVPresetList_CallBackReason                         =AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK;
  byte gRadioTVPresetList_cacheDown                            =FALSE;
  byte gRadioTVPresetList_cacheUp                              =FALSE;
  byte gRadioTVPresetList_LastFirstElement                     =0;
  const AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION               =99;
  byte gRadioTVPresetList_recordaddress            =0; 
  byte gRadioTVPresetList_transmitpos              =0;
  const AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING             =0;  
  const AUDIO_RADIOTVPRESETLIST_CURSORACTION_DOWN                =1;
  const AUDIO_RADIOTVPRESETLIST_CURSORACTION_UP                  =2;
  byte gRadioTVPresetList_CursorAction                           =AUDIO_RADIOTVPRESETLIST_CURSORACTION_NOTHING;
  const AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_REFRESH              =0;
  const AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS       =1;
  const AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_SEARCH_ELEMENTS      =2;
  byte gRadioTVPresetList_DisplayStatus                          =AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIRST_ELEMENTS;                                      
  const AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
  const AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;
  
  /***ListSetup***/
  byte gAudioSD_ListSetup_PreferredList = 0;
  byte gAudioSD_ListSetup_ReceptionListType = 0;
  byte gAudioSD_ListSetup_Extension1 = 0;
  byte gAudioSD_ListSetup_Extension2 = 0;
  byte gAudioSD_ListSetup_Extension3 = 0;
  byte gAudioSD_ListSetup_Extension4 = 0;
  
  /***SourceList***/
  byte gSourceList_ASGID = 0;
  byte gSourceList_TAID = 0;
  word gSourceList_TotalNumListElements = 0;
  const AUDIO_SOURCELIST_ENTRIES = 0xFF;
  word gSourceList_Pos[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_SourceType[AUDIO_SOURCELIST_ENTRIES];   
  byte gSourceList_InstanceID[AUDIO_SOURCELIST_ENTRIES]; 
  byte gSourceList_Attributes_Bit0[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit1[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit2[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit3[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit4[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit5[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit6[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes[AUDIO_SOURCELIST_ENTRIES];
  const AUDIO_SOURCELIST_NAME_LENGTH = 61;
  char gSourceList_Name[AUDIO_SOURCELIST_ENTRIES][AUDIO_SOURCELIST_NAME_LENGTH];   
  word gSourceList_PicRef[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_ListEntryValidInformation[AUDIO_SOURCELIST_ENTRIES]; //indicates the existence of the "record element" 
  byte gSourceList_sum = 0;
  char gSourceList_CSV_filename[AUDIO_FILENAME_SIZE];
  //other
  const AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE =9;
  const AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE   =0;
  const AUDIO_SOURCELIST_SLIDINGWINDOW_ACTIVE      =1;
  byte gSourceList_SlidingWindow_State             =AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE;
  const AUDIO_SOURCELIST_NOCACHE              =0;
  const AUDIO_SOURCELIST_BUILDUPCACHE         =1;
  const AUDIO_SOURCELIST_DOWN_CACHE           =2;
  const AUDIO_SOURCELIST_UP_CACHE             =3;
  const AUDIO_SOURCELIST_UP                   =4;
  const AUDIO_SOURCELIST_DOWN                 =5;
  byte gSourceList_ListHandlingType           =AUDIO_SOURCELIST_NOCACHE; 
  const AUDIO_SOURCELIST_BUILDUPCACHENOCACHE              =0;
  const AUDIO_SOURCELIST_BUILDUPCACHECACHE_UP             =1;
  const AUDIO_SOURCELIST_BUILDUPCACHECACHE_WINDOW         =2;
  const AUDIO_SOURCELIST_BUILDUPCACHECACHE_DOWN           =3; 
  byte gSourceList_cacheBuildUp                           =AUDIO_SOURCELIST_BUILDUPCACHENOCACHE;
  const AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK        =0;
  const AUDIO_SOURCELIST_CALLBACKREASON_CACHENEXT         =1;
  const AUDIO_SOURCELIST_CALLBACKREASON_CHECKCACHE        =2;
  const AUDIO_SOURCELIST_CALLBACKREASON_DISPLAYLIST       =3;
  byte gSourceList_CallBackReason                         =AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK;
  byte gSourceList_cacheDown                            =FALSE;
  byte gSourceList_cacheUp                              =FALSE;
  byte gSourceList_LastFirstElement                     =0;
  const AUDIO_SOURCELIST_NO_NEXT_POSITION               =99;
  byte gSourceList_recordaddress            =0; 
  byte gSourceList_transmitpos              =0;
  const AUDIO_SOURCELIST_CURSORACTION_NOTHING             =0;  
  const AUDIO_SOURCELIST_CURSORACTION_DOWN                =1;
  const AUDIO_SOURCELIST_CURSORACTION_UP                  =2;
  byte gSourceList_CursorAction                           =AUDIO_SOURCELIST_CURSORACTION_NOTHING;
  const AUDIO_SOURCELIST_DISPLAYLIST_REFRESH              =0;
  const AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS       =1;
  const AUDIO_SOURCELIST_DISPLAYLIST_SEARCH_ELEMENTS      =2;
  byte gSourceList_DisplayStatus                          =AUDIO_SOURCELIST_DISPLAYLIST_FIRST_ELEMENTS;                                      
  const AUDIO_SOURCELIST_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
  const AUDIO_SOURCELIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;
  
  /***DedicatedAudioControl***/
  byte gAudioSD_DAC_MethodHandling = 0;
  byte gAudioSD_DAC_Reserve = 0;
  byte gAudioSD_DAC_status = 0;                   //flag for status of the method (0=not activ, 1=activ)
  word gAudioSD_DAC_FSGHandle = 0;
  byte gAudioSD_DAC_AsgId = 0;
  byte gAudioSD_DAC_Extension1 = 0;
  byte gAudioSD_DAC_Result = 0;
  const AUDIO_DAC_SUCCESSFUL          = 0x00;
  const AUDIO_DAC_NOTSUCCESSFUL       = 0x01;
  const AUDIO_DAC_ABORTSUCCESSFUL     = 0x02;
  const AUDIO_DAC_ABORTNOTSUCCESSFUL  = 0x03;
  byte gAudioSD_DAC_ControlType = 0;
  const AUDIO_DAC_SELECT_LIST_ENTRY         = 0x00;
  const AUDIO_DAC_NEXT                      = 0x01;
  const AUDIO_DAC_PREVIOUS                  = 0x02;
  const AUDIO_DAC_FASTFORWARD               = 0x03;
  const AUDIO_DAC_FASTBACKWARD              = 0x04;
  word gAudioSD_DAC_AdditionalControlInfo = 0;
  byte gAudioSD_DAC_ListType = 0;
  const AUDIO_DAC_NOLIST            = 0x00;
  const AUDIO_DAC_RECEPTIONLIST     = 0x01;
  const AUDIO_DAC_RADIOTVPRESETLIST = 0x02;
  const AUDIO_DAC_MEDIABROWSER      = 0x03;
  
  /***SwitchSource***/
  byte gAudioSD_SwitchSource_status = 0;
  word gAudioSD_SwitchSource_Reference = 0;
  byte gAudioSD_SwitchSource_Reserve = 0;
  const AUDIO_SWITCHSOURCERESULT_SUCCESSFUL             = 0x00;
  const AUDIO_SWITCHSOURCERESULT_NOT_SUCCESSFUL         = 0x01;
  const AUDIO_SWITCHSOURCERESULT_ABORT_SUCCESSFUL       = 0x02;
  const AUDIO_SWITCHSOURCERESULT_ABORT_NOT_SUCCESSFUL   = 0x03;
  byte gAudioSD_SwitchSource_Result = AUDIO_SWITCHSOURCERESULT_SUCCESSFUL;
  byte gAudioSD_SwitchSource_AsgId = 0;
  byte gAudioSD_SwitchSource_Extension1 = 0;
  byte gAudioSD_SwitchSource_ControlType = 0;
  word gAudioSD_SwitchSource_SourceListRef = 0;
  
  /***Browser_FolderLevel***/
  byte gAudioSD_MediaBrowser_FL_FolderLevel = 0;
  word gAudioSD_MediaBrowser_FL_RefMediaBrowser = 0;
  word gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos = 0;
  byte gAudioSD_MediaBrowser_FL_Extension1 = 0;
  
  /***Browser***/
  byte gMediaBrowser_ASGID = 0;
  byte gMediaBrowser_TAID = 0;
  word gMediaBrowser_TotalNumListElements = 0;
  word gMediaBrowser_ActiveListPos = 0;
  const AUDIO_MEDIABROWSER_ENTRIES = 0xFF;
  word gMediaBrowser_Pos[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Type[AUDIO_MEDIABROWSER_ENTRIES];
  const AUDIO_MEDIABROWSER_NAME_LENGTH = 97;
  char gMediaBrowser_Name[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_MEDIABROWSER_NAME_LENGTH];
  byte gMediaBrowser_FileState_Bit0[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit1[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit2[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit3[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit4[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit5[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit6[AUDIO_MEDIABROWSER_ENTRIES];
  word gMediaBrowser_FileState[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Waveband[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_RadioCategory[AUDIO_MEDIABROWSER_ENTRIES];
  const AUDIO_MEDIABROWSER_FREQUENCY_LENGTH = 31;
  char gMediaBrowser_Frequency[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_MEDIABROWSER_FREQUENCY_LENGTH];
  byte gMediaBrowser_FmRegCode[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_PresetID[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit0[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit1[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit2[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit3[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit4[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit5[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit6[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit7[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes2_Bit0[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes2_Bit1[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes2[AUDIO_MEDIABROWSER_ENTRIES];
  word gMediaBrowser_PicRef[AUDIO_MEDIABROWSER_ENTRIES];  
  byte gMediaBrowser_ListEntryValidInformation[AUDIO_MEDIABROWSER_ENTRIES]; //indicates the existence of the "record element" 
  byte gMediaBrowser_sum = 0;
  char gMediaBrowser_CSV_filename[AUDIO_FILENAME_SIZE];
  //other
  const AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE =9;
  const AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE   =0;
  const AUDIO_MEDIABROWSER_SLIDINGWINDOW_ACTIVE      =1;
  byte gMediaBrowser_SlidingWindow_State             =AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE;
  const AUDIO_MEDIABROWSER_NOCACHE              =0;
  const AUDIO_MEDIABROWSER_BUILDUPCACHE         =1;
  const AUDIO_MEDIABROWSER_DOWN_CACHE           =2;
  const AUDIO_MEDIABROWSER_UP_CACHE             =3;
  const AUDIO_MEDIABROWSER_UP                   =4;
  const AUDIO_MEDIABROWSER_DOWN                 =5;
  byte gMediaBrowser_ListHandlingType           =AUDIO_MEDIABROWSER_NOCACHE; 
  const AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE              =0;
  const AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_UP             =1;
  const AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_WINDOW         =2;
  const AUDIO_MEDIABROWSER_BUILDUPCACHECACHE_DOWN           =3; 
  byte gMediaBrowser_cacheBuildUp                           =AUDIO_MEDIABROWSER_BUILDUPCACHENOCACHE;
  const AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK        =0;
  const AUDIO_MEDIABROWSER_CALLBACKREASON_CACHENEXT         =1;
  const AUDIO_MEDIABROWSER_CALLBACKREASON_CHECKCACHE        =2;
  const AUDIO_MEDIABROWSER_CALLBACKREASON_DISPLAYLIST       =3;
  byte gMediaBrowser_CallBackReason                         =AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK;
  byte gMediaBrowser_cacheDown                            =FALSE;
  byte gMediaBrowser_cacheUp                              =FALSE;
  byte gMediaBrowser_LastFirstElement                     =0;
  const AUDIO_MEDIABROWSER_NO_NEXT_POSITION               =99;
  byte gMediaBrowser_recordaddress            =0; 
  byte gMediaBrowser_transmitpos              =0;
  const AUDIO_MEDIABROWSER_CURSORACTION_NOTHING             =0;  
  const AUDIO_MEDIABROWSER_CURSORACTION_DOWN                =1;
  const AUDIO_MEDIABROWSER_CURSORACTION_UP                  =2;
  byte gMediaBrowser_CursorAction                            =AUDIO_MEDIABROWSER_CURSORACTION_NOTHING;
  const AUDIO_MEDIABROWSER_DISPLAYLIST_REFRESH              =0;
  const AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS       =1;
  const AUDIO_MEDIABROWSER_DISPLAYLIST_SEARCH_ELEMENTS      =2;
  byte gMediaBrowser_DisplayStatus                           =AUDIO_MEDIABROWSER_DISPLAYLIST_FIRST_ELEMENTS;                                      
  const AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
  const AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;
  
  
  /***BrowserPath***/
  byte gAudioSD_MediaPath_FolderType = 0;
  const MEDIAPATH_PATH_TEXTLENGTH = 152;
  char gAudioSD_MediaPath_Path[MEDIAPATH_PATH_TEXTLENGTH];
  
  /***BrowserControl***/
  byte gAudioSD_MediaBrowserControl_status = FALSE;
  byte gAudioSD_MediaBrowserControl_Control = 0; 
  byte gAudioSD_MediaBrowserControl_Reserve = 0;
  word gAudioSD_MediaBrowserControl_Reference = 0;
  const AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL             = 0x00;
  const AUDIO_MEDIABROWSERCONTROL_NOT_SUCCESSFUL         = 0x01;
  const AUDIO_MEDIABROWSERCONTROL_ABORT_SUCCESSFUL       = 0x02;
  const AUDIO_MEDIABROWSERCONTROL_ABORT_NOT_SUCCESSFUL   = 0x03;
  byte gAudioSD_MediaBrowserControl_Result = AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL;
  byte gAudioSD_MediaBrowserControl_AsgId = 0;
  byte gAudioSD_MediaBrowserControl_Extension1 = 0;
  
  /***Picture***/  
  byte gPicture_ASGID    =0;
  byte gPicture_TAID     =0;
  byte gPicture_TotalNumListElements =0;
  const AUDIO_PICTURE_ENTRIES = 0xFF;
  word gPicture_Pos[AUDIO_PICTURE_ENTRIES];    
  byte gPicture_Type[AUDIO_PICTURE_ENTRIES];
  const AUDIO_PICTURE_TYPE_NOPIC              =0x00;
  const AUDIO_PICTURE_TYPE_STATIONART_NORMAL  =0x01;
  const AUDIO_PICTURE_TYPE_COVERART_NORMAL    =0x02;
  const AUDIO_PICTURE_TYPE_STATIONART_DEFAULT =0x03;
  const AUDIO_PICTURE_TYPE_COVERART_DEFAULT   =0x04;
  const AUDIO_PICTURE_TYPE_DYNAMIC            =0x05;
  const AUDIO_PICTURE_TYPE_UNKNOWNPIC         =0xFF;
  const AUDIO_PICTURE_IPADDRESS_LENGTH =17;
  char gPicture_IpAddress [AUDIO_PICTURE_ENTRIES][AUDIO_PICTURE_IPADDRESS_LENGTH];
  word gPicture_TcpPort[AUDIO_PICTURE_ENTRIES];
  const AUDIO_PICTURE_URI_LENGTH =602;
  char gPicture_Uri [AUDIO_PICTURE_ENTRIES][AUDIO_PICTURE_URI_LENGTH];
  byte gPicture_ListEntryValidInformation [AUDIO_PICTURE_ENTRIES]; //indicates the existence of the "record element"  
  byte gPicture_sum =0; 
  char gPicture_CSV_filename[AUDIO_FILENAME_SIZE];
  dword requestarrayPictureGlobal [BAP_BUFFER_SIZE];
  word offsetPictureGlobal;
  int tempPictureID =0;
  int gID_PictureAct;  
  //other
  const AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE   =0;
  const AUDIO_PICTURE_SLIDINGWINDOW_ACTIVE      =1;
  byte gPicture_SlidingWindow_State             =AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE;
  const AUDIO_PICTURE_NOCACHE              =0;
  const AUDIO_PICTURE_BUILDUPCACHE         =1;
  const AUDIO_PICTURE_DOWN_CACHE           =2;
  const AUDIO_PICTURE_UP_CACHE             =3;
  const AUDIO_PICTURE_UP                   =4;
  const AUDIO_PICTURE_DOWN                 =5;
  byte gPicture_ListHandlingType           =AUDIO_PICTURE_NOCACHE; 
  const AUDIO_PICTURE_BUILDUPCACHENOCACHE              =0;
  const AUDIO_PICTURE_BUILDUPCACHECACHE_UP             =1;
  const AUDIO_PICTURE_BUILDUPCACHECACHE_WINDOW         =2;
  const AUDIO_PICTURE_BUILDUPCACHECACHE_DOWN           =3; 
  byte gPicture_cacheBuildUp                           =AUDIO_PICTURE_BUILDUPCACHENOCACHE;
  const AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK        =0;
  const AUDIO_PICTURE_CALLBACKREASON_CACHENEXT         =1;
  const AUDIO_PICTURE_CALLBACKREASON_CHECKCACHE        =2;
  const AUDIO_PICTURE_CALLBACKREASON_DISPLAYLIST       =3;
  byte gPicture_CallBackReason                         =AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK;
  byte gPicture_cacheDown                            =FALSE;
  byte gPicture_cacheUp                              =FALSE;
  byte gPicture_LastFirstElement                     =0;
  const AUDIO_PICTURE_NO_NEXT_POSITION               =99;
  byte gPicture_recordaddress            =0; 
  byte gPicture_transmitpos              =0;
  const AUDIO_PICTURE_CURSORACTION_NOTHING             =0;  
  const AUDIO_PICTURE_CURSORACTION_DOWN                =1;
  const AUDIO_PICTURE_CURSORACTION_UP                  =2;
  byte gPicture_CursorAction                            =AUDIO_PICTURE_CURSORACTION_NOTHING;
  const AUDIO_PICTURE_DISPLAYLIST_REFRESH              =0;
  const AUDIO_PICTURE_DISPLAYLIST_FIRST_ELEMENTS       =1;
  const AUDIO_PICTURE_DISPLAYLIST_SEARCH_ELEMENTS      =2;
  byte gPicture_DisplayStatus                           =AUDIO_PICTURE_DISPLAYLIST_FIRST_ELEMENTS;                                      
  const AUDIO_PICTURE_DISPLAYLIST_FIND_NEXT_ELEMENT        =0;
  const AUDIO_PICTURE_DISPLAYLIST_FIND_PREVIUOS_ELEMENT    =1;
}

//*************************************************************************
//*****************PreStart************************************************
//*************************************************************************

on preStart
{
  char Path[255];
  char BAPVersion [200];
    
  // create write window for BAP communication
  gBAP_Trace  =writecreate("BAP-Trace ASG-AudioSD");								
  // clear BAP trace window
  writeclear(gBAP_Trace);													
  // error window for BAP communication
	gError_Trace=writecreate("ASG-AudioSD Error");									
	writeclear(gError_Trace);												
	//clear CAPL-window in write-window
  writeclear(1);															

	//get version from Stack
	Bap180_GetVersions(BAPVersion, 200);
	write(" ");
	write("***************************************************");
	write(BAPVersion);
	write("***************************************************");
	write(" ");
	
  write("***************************************************");
	write("ASG-AudioSD function catalog: 'BAP-FC_Audio_P30DF50_v3.01_F.pdf'");
	write("ASG-AudioSD MSCs: 'BAP-MSCs_Audio-SD_P30DF40_v2.02.pdf'");
	write("***************************************************");
	
	// Create Node
	NODE_INDEX=Bap180_CreateNode();
  // Debug info
	// write("NODE_INDEX = 0x%x", NODE_INDEX); 
  // Load DBC and XML files. 
	write("*********************************************************************************");

  //load dbc-file
  canEthernetDecider = prestartEthernetCanDecider();
  //canEthernetDecider = 2; //CAN only
  write("canEthernetDecider = %d",canEthernetDecider);

  switch(canEthernetDecider)
  {
    case 2: // CAN
      getAbsFilePath(dbc_path, Path, 255);
        write("AudioSD Load BAP_DBC-File: '%s'",Path);
      if(Bap180_LoadDBC(NODE_INDEX, 1, Path) != BAP_ERR_OK)		
        writelineEx(gError_Trace, 0, "FSG-AudioSD Fehler beim Laden: '%s', Path");      
      //load xml-file 
      getAbsFilePath(xml_path, Path, 255);
      write("ASG-AudioSD: Load BAP-XML-File: '%s'", Path);
      if (Bap180_LoadConfig(NODE_INDEX, Path, "") != BAP_ERR_OK) 
        writelineEx(gError_Trace, 0, "ASG-AudioSD: Fehler beim Laden: '%s' !", Path);	   
      write("*********************************************************************************");
      write("");
    break;
    case 1: // Ethernet
      getAbsFilePath(dbce_path, Path, 255);
        write("AudioSD Load BAP_DBC-File: '%s'",Path);
      if(Bap180_LoadDB(NODE_INDEX, 20, 2, Path) != BAP_ERR_OK)		
        writelineEx(gError_Trace, 0, "FSG-AudioSD Fehler beim Laden: '%s', Path");      
      //load xml-file 
      getAbsFilePath(xmle_path, Path, 255);
      write("ASG-AudioSD: Load BAP-XML-File: '%s'", Path);
      if (Bap180_LoadConfig(NODE_INDEX, Path, "") != BAP_ERR_OK) 
        writelineEx(gError_Trace, 0, "ASG-AudioSD: Fehler beim Laden: '%s' !", Path);	   
      write("*********************************************************************************");
      write(""); 
    break;
    case -1:
      write("Neither Ethernet nor CAN could be find in Configuration Name!");
    break;
    default:
      write("Not a possible Value");
    break;
  }
  // BAP DLL: Add CAN channel: BAP channel 1 is mapped to CAN card channel 1.
	if(canEthernetDecider==1)
	{
		Bap180_AddCanMap(NODE_INDEX, 20, 2);
		EthernetCreateSocket();
	} 
	else
	{
		Bap180_AddCanMap(NODE_INDEX, 1, 1);
	}
} /* end of method */

int prestartEthernetCanDecider()
{
  char configNameBuffer[100];
    
  getConfigurationName(configNameBuffer,100);
  if(strstr_regex(configNameBuffer, "Ethernet") > 0)
  {
    return 1;
  }
  else if(strstr_regex(configNameBuffer, "CAN") > 0)
  {
    return 2;
  }
  else
  {
    return -1;
  }
}

void CloseUdpSocket()
{
	int i;
	const long  INVALID_SOCKET =    ~0;
	for(i=0;i<gUdpSocketCnt;i++)
	{
		if(gUdpSockets[i].Handle != INVALID_SOCKET)
		{
			UdpClose(gUdpSockets[i].Handle);
			gUdpSockets[i].Handle = INVALID_SOCKET;
		}
	}
}

//*************************************************************************
//*****************Start***************************************************
//*************************************************************************
on start
{
  //Power on/off
  gBAP_Init=0;
  gASG_PowerOnOff=0;
  putvalue(env_ASG_PowerOnOff_s, gstring_ASG_PowerOnOff[gASG_PowerOnOff]);

  //Panel
  closePanel("ASG_AudioSD_Properties_1");
  closePanel("ASG_AudioSD_Properties_2");
  closePanel("ASG_AudioSD_Properties_3");
  closePanel("ASG_AudioSD_Properties_4");
  closePanel("ASG_AudioSD_Methods");
  closePanel("ASG_AudioSD_0x17 - ReceptionList_(array)");
  closePanel("ASG_AudioSD_0x1B - TpMemoList_(array)");
  closePanel("ASG_AudioSD_0x20 - SourceList_(array)");
  closePanel("ASG_AudioSD_0x21 - RadioTV_PresetList_(array)");
  closePanel("ASG_AudioSD_0x24 - MediaBrowser_(array)");
  closePanel("ASG_AudioSD_MainPanel");
  closePanel("ASG_Property_DF41");
  closePanel("Method_2_AudioSD_ASG");
  closePanel("CommonList_ASG"); 
  closePanel("ASG_Property_DF48");
  closePanel("ASG_AudioSD_0x32 - SiriusAlertList_(array)");
  closePanel("0x3B_FavoriteList_ASG2");
  closePanel("0x38_LastStationList_ASG2");
  closePanel("0x3E_Picture_ASG2");

  openPanel("AudioSD_MainPanel");
}

on stopMeasurement
{
  Bap180_Shutdown(NODE_INDEX,LSG_AudioSD);
}

//*************************************************************************
//*****************TaskTimer***********************************************
//*************************************************************************
on timer TaskTimer
{
  Bap180_Task(NODE_INDEX);	//DLL-Task
  BAP_DLL_Indication();
  BAP_DLL_Request();
  BAP_CAN_TX_Request();
  if(canEthernetDecider == 1) 
    BAP_DLL_SetRxData();
  setTimer(TaskTimer, 10);    //restart real CAN-communication timer
}

//*************************************************************************
//*****************TaskTimer Functions*************************************
//*************************************************************************
void BAP_DLL_SetRxData()
{
  int i;
  byte gRxBuffer[1500];
  
  for(i=0;i<gUdpSocketCnt;i++)
    UdpReceiveFrom(gUdpSockets[i].Handle, gRxBuffer, 0);
}

void BAP_DLL_Request ()
{
  int i, datalength;
  byte temp;
  byte Request_data[BAP_BUFFER_SIZE];	//Request data for DLL
  dword Request_header[6];	//Request header for DLL
  byte Wammw;					//data-error-flag (Geräusch)

  //init lokal variables
  datalength=0;
  temp=0;
  Wammw=1;
  
  for(i=0;i<6;i++)
  	Request_header[i]=0;
  for(i=0;i<BAP_BUFFER_SIZE;i++)
  	Request_data[i]=0;
  //********************

  if(gBAP_Requestbuffer_status [gstatus_requestbuffer]>0)							//if ready to send
  {
  //	writelineEx(gBAP_Trace, 0, "DataTyp: %d", gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer]);
  	switch(gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer])
  	{
  		case Bap_Void:
  			//request-array for BAP-DLL funcion 'BAP_Request'
  			Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
  			Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
  			Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
  			Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
  			Request_header[4]=0;														//not used
  			Request_header[5]=0;														//not used
  		break;
  		case Bap_UInt8:
  			//request-array for BAP-DLL funcion 'BAP_Request'
  			Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
  			Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
  			Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
  			Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
  			Request_header[4]=0;														//not used
  			Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit8-value
  		break;
  		case Bap_UInt16:
  			//request-array for BAP-DLL funcion 'BAP_Request'
  			Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
  			Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
  			Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
  			Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
  			Request_header[4]=0;														//not used
  			Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit16-value
  		break;
  		case Bap_UInt32:
  			//request-array for BAP-DLL funcion 'BAP_Request'
  			Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
  			Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
  			Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
  			Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
  			Request_header[4]=0;														//not used
  			Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit32-value
  		break;
  		case Bap_ByteSequence:					//BAP-data-type is byte sequence
  			datalength=gBAP_Requestbuffer_status [gstatus_requestbuffer]-3;

  			//request-array for BAP-DLL funcion 'BAP_Request'
  			Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
  			Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
  			Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
  			Request_header[3]=Bap_ByteSequence;											//BAP data type
  			Request_header[4]=datalength;												//length of date-array

  			//data-array for BAP-DLL funcion 'BAP_Request'
  			for(i=0;i<datalength;i++)
  				Request_data[i]=gBAP_Request[gstatus_requestbuffer] [i+3];
    	break;
      case Bap_Acknowledge:// not used only BAP 3.1
      break;
  		default:
  			writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer]);
  			Wammw=0;
  		break;			
  	}
  	if(Wammw)																			//no data-error
  	{
  		temp=Bap180_Request(NODE_INDEX, Request_header, Request_data);					//send data to BAP-DLL
  		if(temp==0)																		//BAP-Request successful 											
  		{
  			writelineEx(gBAP_Trace, 0, "ASG-Request:    ");								//BAL-Trace		
  			for (i=0;i<gBAP_Requestbuffer_status [gstatus_requestbuffer];i++)			//BAL-Trace	
  				writeEX(gBAP_Trace, 0, " %x",gBAP_Request [gstatus_requestbuffer] [i]);	//BAL-Trace	
  		  //	write("Send buffer-element %d to BAP-DLL", gstatus_requestbuffer); 			//debug
  		}
  		else																			//BAP-Request error
  		{
  			writelineEx(gBAP_Trace, 0, "ASG Error BAP_Request, errorcode: %x. ASG-Request:",temp);				//debug
  			for (i=0;i<gBAP_Requestbuffer_status [gstatus_requestbuffer];i++)									//debug
  				writeEX(gBAP_Trace, 0, " %x",gBAP_Request [gstatus_requestbuffer] [i]);							//debug
  		}
  	}
  	gBAP_Requestbuffer_status [gstatus_requestbuffer]=0;		//reset position status -> free position 
  	gBAP_Requestbuffer_BAPDataTyp [gstatus_requestbuffer]=0;	//reset BAP-datatyp of sendet buffer element
  	//delete sendet request buffer elements
  	for(i=0;i<BAP_BUFFER_SIZE;i++)
  		gBAP_Request [gstatus_requestbuffer] [i]=0;				//delete sended array
  	if (gstatus_requestbuffer<(REQUESTBUFFER_LINES-1))			//last element of buffer is not reached	
  		gstatus_requestbuffer++;
  	else														//last element of buffer is reached
  		gstatus_requestbuffer=0;
  }
}
void BAP_CAN_TX_Request()
{
  int i;
  byte send_result;
  byte DestIp[16];
  byte TX_Data[1500];				//CAN-data
  dword TX_Header[13];			//CAN-header
  message 0x100 TX_Message;	//dummy-message
   
  if(canEthernetDecider == 2)
  {
    TX_Header[2] = 8; // max-Length of TX_Data
    while (Bap180_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) 	//get BAP-data in CAN-format from DLL
    {
      TX_Message.CAN = TX_Header[0]; 		//CAN channel
      TX_Message.ID =TX_Header[1]; 			//Can ID
      TX_Message.DLC = TX_Header[2]; 		//received length
      for (i=0; i<TX_Message.DLC; i++)		//CAN data-bytes
      {
        TX_Message.byte(i) = TX_Data[i];
      }
      output(TX_Message);					//send CAN message
      TX_Header[2] = 8; 					// max-Length of TX_Data
    } 
  }
  else
  {
    TX_Header[0] = 4; // /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
    TX_Header[2] = 1500; // max-Length of TX_Data
    while( BAP180_GetTxData( NODE_INDEX,TX_Header,TX_Data ) == 0 ) 
    {
      for(i=0; i<8;i++)
      {
        DestIp[2*i]   = (byte)(TX_Header[i+4]>>8);
        DestIp[2*i+1] = (byte)(TX_Header[i+4]&0xFF);
      }
      for (i=0; i<TX_Header[2]; i++) 
      {	//CAN data-bytes
        TX_Data.byte(i) = TX_Data[i];
      }
      send_result = UdpSendTo(gUdpSockets[TX_Header[3]-1].Handle, DestIp, TX_Header[12], TX_Data, TX_Header[2]);
      if (send_result)
      {
        writeLineEx(0,3, "UdpSendTo failed, error code %d, last error %d", send_result, IpGetLastError());
      }
      TX_Header[2] = 1500; // max-Length of TX_Data
    }
  }
}

void BAP_DLL_Indication()
{
  int i, length, datalength, temp;
  byte Indication_data[BAP_BUFFER_SIZE];												//indication data from DLL
  dword Indication_header[6];															//indication header from DLL
  byte BAP_data_type;

  //init lokal variables
  length=0;
  datalength=0;
  temp=0;
  BAP_data_type=0;

  for(i=0;i<6;i++)
  	Indication_header[i]=0;
  for(i=0;i<BAP_BUFFER_SIZE;i++)
  	Indication_data[i]=0;
  //********************
  Indication_header[4]=BAP_BUFFER_SIZE;											//BAP-Stack needs this information for successful BAP_GetIndication 
  temp=Bap180_GetInd(NODE_INDEX, Indication_header, Indication_data);				//get BAP-Indication data from DLL
  //write("BAP_GetIndication: %d", temp);											//debug
  if(temp==0)
  {
  	//read header
  	gBAP_Indication[0]=Indication_header[0];									//LSG-ID
  	gBAP_Indication[1]=Indication_header[1];									//Function-ID
  	gBAP_Indication[2]=Indication_header[2];									//indication
  	BAP_data_type=Indication_header[3];											//BAP data type
  	//writelineEx(gBAP_Trace, 0, "Data-Type: %d", BAP_data_type);					//debug
  	switch(BAP_data_type)
  	{
  		case Bap_Void:
  			datalength=3;
  			BAP_Indication(datalength);											        //evaluate BAP-Indication data
  		break;
  		case Bap_UInt8:
  			gBAP_Indication[3]=Indication_header[5];							//unit8-value
  			datalength=4;
   			BAP_Indication(datalength);											        //evaluate BAP-Indication data
  		break;
  		case Bap_UInt16:
  			gBAP_Indication[3]=Indication_header[5];							//unit16-value
   			datalength=4;
  			for (i=0;i<datalength;i++)											//BAL-Trace
  				//writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace
  			BAP_Indication(datalength);											        //evaluate BAP-Indication data
  		break;
  		case Bap_UInt32:
  			gBAP_Indication[3]=Indication_header[5];							//unit32-value
  			datalength=4;
  		  BAP_Indication(datalength);											        //evaluate BAP-Indication data
  		break;
  		case Bap_ByteSequence:													//BAP-data-type is byte sequence
  			//read datalength
  			length=Indication_header[4];										//length of date-array
  			datalength=length+3;												//length of indication-array
  			//read data-array
  			for(i=0;i<length;i++)
  				gBAP_Indication[i+3]=Indication_data[i];
  			//writelineEx(gBAP_Trace, 0, "ASG-Indication: ");						//BAL-Trace
  			for (i=0;i<datalength;i++)											//BAL-Trace
  			{
  				writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace
  				if(i>20)
  				{
  					i=datalength;
  					writeEX(gBAP_Trace, 0, "...");
  				}
  			}
  			BAP_Indication(datalength);											        //evaluate BAP-Indication data
  		break;
      case Bap_Acknowledge: //not used, only at BAP 3.1
      break;
  		case Bap_Error:
  			gBAP_Indication[2]=Error_IND;										//internal indication-value for error
  			gBAP_Indication[3]=Indication_header[5];							//error-code
  			datalength=4;														//length of indication-array
  			writelineEx(gBAP_Trace, 0, "ASG-Error-Indication: ");				//BAL-Trace
  			writeEX(gBAP_Trace, 0, "LSG-ID: 0x%x   ",gBAP_Indication[0]);		//BAL-Trace
  			writeEX(gBAP_Trace, 0, "Fct-ID: 0x%x   ",gBAP_Indication[1]);		//BAL-Trace
  		  //	writeEX(gBAP_Trace, 0, "Opcode: 0x%x   ",gBAP_Indication[2]);		//BAL-Trace
  			writeEX(gBAP_Trace, 0, "Error-Code: 0x%x   ",gBAP_Indication[3]);	//BAL-Trace
  			BAP_Indication(datalength);											        //evaluate BAP-Indication data
  		break;
  		default:
  			writelineEx(gError_Trace, 0, "ASG BAP_DLL_Indication: invalid BAP-Data-Type: %d", BAP_data_type);
  		break;
  	}
  }
}

void BAP_Indication(int datalength)
{
  switch(gBAP_Indication[0])
  {
    case LSG_AudioSD:
	    AudioSD_functions(datalength); 
    break;
  	default:
  	  write("error BAP_Indication: invalid/unhandled LSG-ID %x", gBAP_Indication[0]);
  }
}

void AudioSD_functions (int datalength)	
{
  int i=0;

  switch (gBAP_Indication[1]) // function-ID
  {
    case FctID_GetAll:		
      GetAll_Indication(gBAP_Indication, datalength);
  	break;
  	case FctID_BAP_Config:
  		BAP_Config_Indication(gBAP_Indication, datalength);
  	break;
  	case FctID_FunctionList:
  		FunctionList_Indication(gBAP_Indication, datalength);
  	break;
  	case FctID_HeartBeat:
  		HeartBeat_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_FSG_Control:
  		FSG_Control_Indication(gBAP_Indication, datalength);
  	break;
  	case FctID_FSG_Setup:
  		FSG_Setup_Indication(gBAP_Indication, datalength);
  	break;
  	case FctID_FSG_OperationState:
  		FSG_OperationState_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_ASG_Capabilities:
  		ASGCapabilities_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_InfoStates:
  		InfoStates_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_SDS_State:
  		SDSState_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_GeneralInfoSwitches:
  		GeneralInfoSwitches_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_ActiveSource:
  		activeSource_Indication(gBAP_Indication, datalength);
  	break;
  	case FctID_ActiveSourceName:
  		activeSourceName_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_CurrentVolume:
  		currentVolume_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_SourceState:
  		SourceState_Indication(gBAP_Indication, datalength);
  	break;  
    case FctID_CurrentStationInfo:
  		CurrentStationInfo_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_CurrentStation_Handle:
  		CurrentStationHandle_Indication(gBAP_Indication, datalength);
  	break;   
    case FctID_PlayPosition:
  		PlayPosition_Indication(gBAP_Indication, datalength);
  	break;    
    case FctID_Station_Track_Switch:
      Station_Track_Switch_Indication(gBAP_Indication, datalength);
    break;
    case FctID_AnnouncementInfo:
  		AnnouncementInfo_Indication(gBAP_Indication, datalength);
  	break;
  	case FctID_AnnouncementEscape:
  		AnnouncementEscape_Indication(gBAP_Indication, datalength);
  	break;  
    case FctID_ReceptionList:
  		ReceptionList_Indication(gBAP_Indication, datalength);
  	break;  
    case FctID_RadioTV_PresetList:
  		RadioTVPresetList_Indication(gBAP_Indication, datalength);
  	break; 
    case FctID_ListSetup:
  		ListSetup_Indication(gBAP_Indication, datalength);
  	break;   
    case FctID_SourceList:
  		SourceList_Indication(gBAP_Indication, datalength);
  	break;  
    case FctID_DedicatedAudioControl:
  		DedicatedAudioControl_Indication(gBAP_Indication, datalength);
  	break;  
    case FctID_SwitchSource:
  		SwitchSource_Indication(gBAP_Indication, datalength);
  	break;    
    case FctID_Browser_FolderLevel:
  		Browser_FolderLevel_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_Browser:
  	  Browser_Indication(gBAP_Indication, datalength);
  	break;
    case FctID_BrowserPath:
  		BrowserPath_Indication(gBAP_Indication, datalength);
  	break;  
    case FctID_BrowserControl:
  		BrowserControl_Indication(gBAP_Indication, datalength);
  	break;  
    case FctID_Picture:
      Picture_Indication(gBAP_Indication, datalength);
    break;  
  	default:
  		write("ASG_functions: unknown funcion-ID %x", gBAP_Indication[1]);
  	break;
  }	
}

//*************************************************************************
//*****************PowerOnOff Event****************************************
//*************************************************************************
on timer Powerontimer
{
  gASG_PowerOnOff =TRUE;
  settimer(TaskTimer, 10);    //start BAP-DLL-Timer	
}

on envVar env_ASG_PowerOnOff
{
  int length, temp;

  putvalue(env_ASG_PowerOnOff_s, gstring_ASG_PowerOnOff [getvalue(this)]);	
  if(getvalue(this)==1)
  {
  	if(gBAP_Init==0)
  	{
  		gBAP_Init=1;
  		//BAP-Init ASG
  		temp=Bap180_Init(NODE_INDEX,LSG_AudioSD);
  	 	if(temp==0)
  			write("ASG-AudioSD BAP_Init successful ");
  		else
  			write("ASG-AudioSD error BAP_Init: %d", temp);
  	}
  	init_variables();							//initialize variables
  	//BAP-Start ASG
  	temp =Bap180_Start(NODE_INDEX,LSG_AudioSD);
  	if(temp==0)
  		write("ASG-AudioSD BAP_Start successful ");
  	else
  		write("ASG-AudioSD error BAP_Start: %d", temp);
  	settimer(Powerontimer, 20);
  }
  else
  {
  	temp =Bap180_Shutdown(NODE_INDEX,LSG_AudioSD);
    if(temp==0)
  		write("ASG-AudioSD BAP_Shutdown successful ");
  	else
  		write("ASG-AudioSD error BAP_Shutdown: %d", temp);
  	gASG_PowerOnOff =getvalue(this);
  	Shutdown_AudioSD();
  }
}

void EthernetCreateSocket()
{ 
  int index;
  dword i, j, Header[200], val, VlanId, VlanPrio, ifIndex;
  byte ipv6_adapter_adresses[5][16];
  byte ipv6_temp[16] = {0};
  byte ipv6_zero[16] = {0}; 
  int ii;

  gUdpSocketCnt = 0;
  Header[0] = 1;
  //write("HIER : %d", BAP180_GetEthConfig(NODE_INDEX, Header));
  write("%lx", BAP180_GetEthConfig(NODE_INDEX, Header));
  if(BAP180_GetEthConfig(NODE_INDEX, Header) == 0)
  {
    for(i=1;i<=3;i++)
    {
      if(IpGetAdapterAddress(i, ipv6_adapter_adresses, 5) == 0)
      {
        val = IpGetAdapterAddressCount(i, 28);
        for(j=0;j<val;j++)
        {
          IpRemoveAdapterAddress(i, ipv6_adapter_adresses[j], 64);
        }
      }
      else
      {
        break;
      }
    }
    index=0;
    ifIndex = 1;
    VlanId = Header[index++];
    VlanPrio = Header[index++];
    writelineex(0, 1, "VLAN ID: %d", VlanId);
    writelineex(0, 1, "VLAN Prio: %d", VlanPrio);
    if(VlanId != 0xFFFF)
      ifIndex = 2;
    gUdpSocketCnt = Header[index++];
    for(i=0; i<gUdpSocketCnt;i++)
    {
      gUdpSockets[i].Id = Header[index++];
      for(j=0;j<8;j++)
     {
        ipv6_temp[j*2]   = Header[index]>>8;
        ipv6_temp[j*2+1] = Header[index++]&0xFF;
      }
      IpAddAdapterAddress(ifIndex, ipv6_temp, 64);
      write("%d", gUdpSockets[i].Handle);
      if(ipv6_temp[0] == 0xFF)
      {
        gUdpSockets[i].Handle = UdpOpen( ipv6_zero, Header[index++]);
        write("ipv6 temp 0 : 0xFF");
      }
      else
      {
        gUdpSockets[i].Handle = UdpOpen( ipv6_temp, Header[index++]);
      }
      if (gUdpSockets[i].Handle == ~0){
        writelineex(0, 3, "Error: could not create Udp socket! %d", IpGetLastError());
      }else{
        writelineex(0, 1, "Udp socket is opened successfully.");
        if(ipv6_temp[0] == 0xFF)
        {
          if(IpJoinMulticastGroup(gUdpSockets[i].Handle, ifIndex, ipv6_temp) != 0)
           writelineex(0, 3, "IpJoinMulticastGroup failed.");
        }
        if(IpSetMulticastInterface ( gUdpSockets[i].Handle, ifIndex) != 0)
          writelineex(0, 3, "IpSetMulticastInterface failed");
      }
    }
  }
  else
  {
    writelineex(0, 3, "Error: BAP180_GetEthConfig failed!");
  }
  for(ii = 0; ii < 70; ii++)
  {
    //write("HEADER[%d] : %d", ii, Header[ii]);
  }
}

//*************************************************************************
//*****************init/shutdown functions*********************************
//*************************************************************************
init_variables()	//initialize/reset all global variables
{
  dword i, j;

  //BAP communication
  for (i=0;i<BAP_BUFFER_SIZE;i++)
  	gBAP_Indication[i]=0;
  //RGB-Values for background colors
  gRGB_red    =MakeRGB(255,0,0);
  gRGB_yellow =MakeRGB(255,255,0);
  gRGB_green  =MakeRGB(0,255,0);
  gRGB_grey   =MakeRGB(192,192,192);
  gRGB_white  =MakeRGB(255,255,255);
  for (j=0;j<REQUESTBUFFER_LINES;j++)
  {
  	gBAP_Requestbuffer_status[j] =0;
  	gBAP_Requestbuffer_BAPDataTyp[j] =0;

  	for (i=0;i<BAP_BUFFER_SIZE;i++)
  		gBAP_Request[j][i] =0;
  }
  gwrite_requestbuffer_line   =0; 
  gstatus_requestbuffer       =0;
  putvalue(env_ASG_AudioSD_Config_SWConfig,xml_path);
  putvalue(env_ASG_AudioSD_Config_DBC,dbc_path);
  FunctionList_flag  =FALSE;

  //FctList
  for(i=0; i<8; i++)
    gFunctionList_FctList[i] =0;
  putvalue(env_ASG_AudioSD_FctList_Bit01,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit02,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit03,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit04,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit13,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit14,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit15,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit16,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit17,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit18,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit19,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit20,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit21,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit22,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit23,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit24,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit25,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit26,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit27,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit28,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit29,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit30,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit31,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit32,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit33,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit34,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit35,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit36,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit37,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit38,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit39,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit40,FALSE);
  
  //0x0D FSG-Control
  gAudioSD_FSGControl_Extension1 = 0;
  gAudioSD_FSGControl_Extension2 = 0;
  gAudioSD_FSGControl_Extension3 = 0;
  gAudioSD_FSGControl_Extension4 = 0;
  gAudioSD_FSGControl_Extension5 = 0;
  gAudioSD_FSGControl_Extension6 = 0;
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext1, gAudioSD_FSGControl_Extension1);
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext2, gAudioSD_FSGControl_Extension2);
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext3, gAudioSD_FSGControl_Extension3);
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext4, gAudioSD_FSGControl_Extension4);
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext5, gAudioSD_FSGControl_Extension5);
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext6, gAudioSD_FSGControl_Extension6);
  
  //0x0E FSG-Setup
  gAudioSD_FSGSetup_FunctionSupport = 0;
  gAudioSD_FSGSetup_FunctionSupport_Bit0 = 0;
  gAudioSD_FSGSetup_FunctionSupport_Bit1 = 0;
  gAudioSD_FSGSetup_FunctionProtection = 0;
  gAudioSD_FSGSetup_FunctionProtection_Bit0 = 0;
  gAudioSD_FSGSetup_WebAppState = 0;
  gAudioSD_FSGSetup_WebAppState_Bit0 = 0; 
  gAudioSD_FSGSetup_Extension1 = 0;
  gAudioSD_FSGSetup_Extension2 = 0;
  gAudioSD_FSGSetup_Extension3 = 0;
  gAudioSD_FSGSetup_Extension4 = 0;
  putvalue(env_ASG_AudioSD_FSGSetup_FS_Bit0, gAudioSD_FSGSetup_FunctionSupport_Bit0);
  putvalue(env_ASG_AudioSD_FSGSetup_FS_Bit1, gAudioSD_FSGSetup_FunctionSupport_Bit1);
  putvalue(env_ASG_AudioSD_FSGSetup_FP_Bit0, gAudioSD_FSGSetup_FunctionProtection_Bit0);
  putvalue(env_ASG_AudioSD_FSGSetup_WASBit0, gAudioSD_FSGSetup_WebAppState_Bit0);
  putvalue(env_ASG_AudioSD_FSGSetup_Ext1, gAudioSD_FSGSetup_Extension1);
  putvalue(env_ASG_AudioSD_FSGSetup_Ext2, gAudioSD_FSGSetup_Extension2);
  putvalue(env_ASG_AudioSD_FSGSetup_Ext3, gAudioSD_FSGSetup_Extension3);
  putvalue(env_ASG_AudioSD_FSGSetup_Ext4, gAudioSD_FSGSetup_Extension4);

  //0x0F FSG-OperationState
  gAudioSD_FSGOperationState_OpState = FSGOPERATIONSTATE_INITIALIZING;
  gAudioSD_FSGOperationState_Extension1 = 0;
  gAudioSD_FSGOperationState_Extension2 = 0;
  gAudioSD_FSGOperationState_Extension3 = 0;
  gAudioSD_FSGOperationState_Extension4 = 0;
  gAudioSD_FSGOperationState_Extension5 = 0;
  putvalue(env_ASG_AudioSD_FSGOpState_State, gAudioSD_FSGOperationState_OpState);
  putvalue(env_ASG_AudioSD_FSGOpState_Ext1, gAudioSD_FSGOperationState_Extension1);
  putvalue(env_ASG_AudioSD_FSGOpState_Ext2, gAudioSD_FSGOperationState_Extension2);
  putvalue(env_ASG_AudioSD_FSGOpState_Ext3, gAudioSD_FSGOperationState_Extension3);
  putvalue(env_ASG_AudioSD_FSGOpState_Ext4, gAudioSD_FSGOperationState_Extension4);
  putvalue(env_ASG_AudioSD_FSGOpState_Ext5, gAudioSD_FSGOperationState_Extension5);
  
  //0x10 ASG_Capabilities
  gAudioSD_ASGCapabilities_PresentationCapabilities = 0;
  gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = 0;
  gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 = 0;
  gAudioSD_ASGCapabilities_Extension1 = 0;
  gAudioSD_ASGCapabilities_Extension2 = 0;
  gAudioSD_ASGCapabilities_Extension3 = 0;
  gAudioSD_ASGCapabilities_Extension4 = 0;
  gAudioSD_ASGCapabilities_Extension5 = 0;
  putvalue(env_ASG_AudioSD_ASGCap_PrC_DAB, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0);
  putvalue(env_ASG_AudioSD_ASGCap_PrC_SDARS, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1);
  putvalue(env_ASG_AudioSD_ASGCap_Ext1, gAudioSD_ASGCapabilities_Extension1);
  putvalue(env_ASG_AudioSD_ASGCap_Ext2, gAudioSD_ASGCapabilities_Extension2);
  putvalue(env_ASG_AudioSD_ASGCap_Ext3, gAudioSD_ASGCapabilities_Extension3);
  putvalue(env_ASG_AudioSD_ASGCap_Ext4, gAudioSD_ASGCapabilities_Extension4);
  putvalue(env_ASG_AudioSD_ASGCap_Ext5, gAudioSD_ASGCapabilities_Extension5);
  
  //0x11 InfoStates
  gAudioSD_InfoStates_States = 0;
  gAudioSD_InfoStates_AdditionalStateInfo_Bit0 = 0;
  gAudioSD_InfoStates_AdditionalStateInfo = gAudioSD_InfoStates_AdditionalStateInfo_Bit0;
  gAudioSD_InfoStates_Extension1 = 0;
  gAudioSD_InfoStates_Extension2 = 0;
  gAudioSD_InfoStates_Extension3 = 0;
  gAudioSD_InfoStates_Extension4 = 0;
  putvalue(env_ASG_AudioSD_InfoSt_States, gAudioSD_InfoStates_States);
  putvalue(env_ASG_AudioSD_InfoSt_ASI_Bit0, gAudioSD_InfoStates_AdditionalStateInfo);
  putvalue(env_ASG_AudioSD_InfoSt_Ext1, gAudioSD_InfoStates_Extension1);
  putvalue(env_ASG_AudioSD_InfoSt_Ext2, gAudioSD_InfoStates_Extension2);
  putvalue(env_ASG_AudioSD_InfoSt_Ext3, gAudioSD_InfoStates_Extension3);
  putvalue(env_ASG_AudioSD_InfoSt_Ext4, gAudioSD_InfoStates_Extension4);
  
  //0x12 SDS_State
  gAudioSD_SDSState_State = 0;
  gAudioSD_SDSState_Extension1 = 0;
  gAudioSD_SDSState_Extension2 = 0;
  gAudioSD_SDSState_Extension3 = 0;
  gAudioSD_SDSState_Extension4 = 0;
  gAudioSD_SDSState_Extension5 = 0;
  putvalue(env_ASG_AudioSD_SDSState_State, gAudioSD_SDSState_State);
  putvalue(env_ASG_AudioSD_SDSState_Ext1, gAudioSD_SDSState_Extension1);
  putvalue(env_ASG_AudioSD_SDSState_Ext2, gAudioSD_SDSState_Extension2);
  putvalue(env_ASG_AudioSD_SDSState_Ext3, gAudioSD_SDSState_Extension3);
  putvalue(env_ASG_AudioSD_SDSState_Ext4, gAudioSD_SDSState_Extension4);
  putvalue(env_ASG_AudioSD_SDSState_Ext5, gAudioSD_SDSState_Extension5);
  
  //0x13 GeneralInfoSwitches
  gAudioSD_GeneralInfoSwitches_OnOffSwitches = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS = 0;
  gAudioSD_GeneralInfoSwitches_Extension1 = 0;
  gAudioSD_GeneralInfoSwitches_Extension2 = 0;
  gAudioSD_GeneralInfoSwitches_Extension3 = 0;
  gAudioSD_GeneralInfoSwitches_Extension4 = 0;
  gAudioSD_GeneralInfoSwitches_Extension5 = 0;
  putvalue(env_ASG_AudioSD_GIS_OnOffSw_TP, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA);
  putvalue(env_ASG_AudioSD_GIS_OnOffSw_RDS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS);
  putvalue(env_ASG_AudioSD_GIS_OnOffSw_JP, gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic);
  putvalue(env_ASG_AudioSD_GIS_OnOffSw_TMC, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC);
  putvalue(env_ASG_AudioSD_GIS_OnOffSw_VICS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS);
  putvalue(env_ASG_AudioSD_GIS_Ext1, gAudioSD_GeneralInfoSwitches_Extension1);
  putvalue(env_ASG_AudioSD_GIS_Ext2, gAudioSD_GeneralInfoSwitches_Extension2);
  putvalue(env_ASG_AudioSD_GIS_Ext3, gAudioSD_GeneralInfoSwitches_Extension3);
  putvalue(env_ASG_AudioSD_GIS_Ext4, gAudioSD_GeneralInfoSwitches_Extension4);
  putvalue(env_ASG_AudioSD_GIS_Ext5, gAudioSD_GeneralInfoSwitches_Extension5);
  
  //0x14 ActiveSource
  gAudioSD_activeSource_SourceType = ACTIVESOURCE_SOURCETYPE_FM;
  gAudioSD_activeSource_SourceList_Reference = 0;
  gAudioSD_activeSource_ListAvailable_Bit0 = 0;
  gAudioSD_activeSource_ListAvailable_Bit1 = 0;
  gAudioSD_activeSource_ListAvailable_Bit2 = 0;
  gAudioSD_activeSource_ListAvailable = (gAudioSD_activeSource_ListAvailable_Bit2*0x04) + (gAudioSD_activeSource_ListAvailable_Bit1*0x02) + (gAudioSD_activeSource_ListAvailable_Bit0&0x01);
  gAudioSD_activeSource_ListState = ACTIVESOURCE_LISTSTATE_COMPLETELY_LOADED;
  gAudioSD_activeSource_Number = 0;
  gAudioSD_activeSource_Extension1 = 0;
  putvalue(env_ASG_AudioSD_AS_SourceType, gAudioSD_activeSource_SourceType);
  putvalue(env_ASG_AudioSD_AS_SL_Ref, gAudioSD_activeSource_SourceList_Reference);
  putvalue(env_ASG_AudioSD_AS_LiAv_RL, gAudioSD_activeSource_ListAvailable_Bit0);
  putvalue(env_ASG_AudioSD_AS_LiAv_PL, gAudioSD_activeSource_ListAvailable_Bit1);
  putvalue(env_ASG_AudioSD_AS_LiAv_BL, gAudioSD_activeSource_ListAvailable_Bit2);
  putvalue(env_ASG_AudioSD_AS_ListState, gAudioSD_activeSource_ListState);
  putvalue(env_ASG_AudioSD_AS_Number, gAudioSD_activeSource_Number);
  putvalue(env_ASG_AudioSD_AS_Ext1, gAudioSD_activeSource_Extension1);
  
  //0x15 ActiveSourceName
  for (i = 0; i < ACTIVE_SOURCE_NAME_LENGTH; i++)
      gAudioSD_activeSourceName[i] = 0;
  strncpy(gAudioSD_activeSourceName, "'activeSourceName'", elcount(gAudioSD_activeSourceName));
  putvalue(env_ASG_AudioSD_ASName_Name_s, gAudioSD_activeSourceName);
  
  //0x16 CurrentVolume
  gAudioSD_currentVolume_ChangingVolumeType = 0;
  gAudioSD_currentVolume_maxVolume = 0;
  gAudioSD_currentVolume_GenericVolume = 0;
  gAudioSD_currentVolume_MuteState = 0;
  gAudioSD_currentVolume_Extension1 = 0;
  gAudioSD_currentVolume_Extension2 = 0;
  putvalue(env_ASG_AudioSD_CurrVol_CVT, gAudioSD_currentVolume_ChangingVolumeType);
  putvalue(env_ASG_AudioSD_CurrVol_maxVol, gAudioSD_currentVolume_maxVolume);
  putvalue(env_ASG_AudioSD_CurrVol_GenVol, gAudioSD_currentVolume_GenericVolume);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit0, gAudioSD_currentVolume_MuteState_Bit0);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit1, gAudioSD_currentVolume_MuteState_Bit1);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit2, gAudioSD_currentVolume_MuteState_Bit2);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit3, gAudioSD_currentVolume_MuteState_Bit3);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit4, gAudioSD_currentVolume_MuteState_Bit4);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit5, gAudioSD_currentVolume_MuteState_Bit5);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit6, gAudioSD_currentVolume_MuteState_Bit6);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit7, gAudioSD_currentVolume_MuteState_Bit7);
  putvalue(env_ASG_AudioSD_CurrVol_Ext1, gAudioSD_currentVolume_Extension1);
  putvalue(env_ASG_AudioSD_CurrVol_Ext2, gAudioSD_currentVolume_Extension2);
  
  //0x17 SourceState
  gAudioSD_SourceState_StateInfo = 0;
  gAudioSD_SourceState_Scope = 0;
  gAudioSD_SourceState_Extension1 = 0;
  gAudioSD_SourceState_Extension2 = 0;
  gAudioSD_SourceState_Extension3 = 0;
  gAudioSD_SourceState_Extension4 = 0;
  putvalue(env_ASG_AudioSD_SrcSt_SateInfo, gAudioSD_SourceState_StateInfo);
  putvalue(env_ASG_AudioSD_SrcSt_Scope, gAudioSD_SourceState_Scope);
  putvalue(env_ASG_AudioSD_SrcSt_Ext1, gAudioSD_SourceState_Extension1);
  putvalue(env_ASG_AudioSD_SrcSt_Ext2, gAudioSD_SourceState_Extension2);
  putvalue(env_ASG_AudioSD_SrcSt_Ext3, gAudioSD_SourceState_Extension3);
  putvalue(env_ASG_AudioSD_SrcSt_Ext4, gAudioSD_SourceState_Extension4);
  
  //0x18 CurrentStationInfo
  gAudioSD_CSI_PI_Type = 0;
  gAudioSD_CSI_PIID = 0;
  gAudioSD_CSI_SI_Type = 0;
  gAudioSD_CSI_TI_Type = 0;
  gAudioSD_CSI_QI_Type = 0;
  gAudioSD_CSI_I5_Type = 0;
  gAudioSD_CSI_I6_Type = 0;
  gAudioSD_CSI_I7_Type = 0;
  gAudioSD_CSI_I8_Type = 0;
  gAudioSD_CSI_ChannelID = 0;
  gAudioSD_CSI_RadioCategory = 0;
  gAudioSD_CSI_Extension1 = 0;
  gAudioSD_CSI_StationInfoSwitches_Bit0 = TRUE;
  gAudioSD_CSI_StationInfoSwitches_Bit1 = 0;
  gAudioSD_CSI_StationInfoSwitches_Bit2 = 0;
  gAudioSD_CSI_StationInfoSwitches_Bit3 = 0;
  gAudioSD_CSI_StationInfoSwitches_Bit4 = 0;
  gAudioSD_CSI_StationInfoSwitches = gAudioSD_CSI_StationInfoSwitches_Bit0 + 
                                    (gAudioSD_CSI_StationInfoSwitches_Bit1 * 0x02) +
                                    (gAudioSD_CSI_StationInfoSwitches_Bit2 * 0x04) + 
                                    (gAudioSD_CSI_StationInfoSwitches_Bit3 * 0x08) + 
                                    (gAudioSD_CSI_StationInfoSwitches_Bit4 * 0x10);
  gAudioSD_CSI_StationProperties_Bit0 = 0;
  gAudioSD_CSI_StationProperties_Bit1 = 0;
  gAudioSD_CSI_StationProperties_Bit2 = 0;
  gAudioSD_CSI_StationProperties_Bit3 = 0;
  gAudioSD_CSI_StationProperties_Bit4 = 0;
  gAudioSD_CSI_StationProperties = gAudioSD_CSI_StationProperties_Bit0 + 
                                  (gAudioSD_CSI_StationProperties_Bit1 * 0x02) + 
                                  (gAudioSD_CSI_StationProperties_Bit2 * 0x04) + 
                                  (gAudioSD_CSI_StationProperties_Bit3 * 0x08) + 
                                  (gAudioSD_CSI_StationProperties_Bit4 * 0x10);
  for (i = 0; i < PRIMARYINFORMATION_TEXTLENGTH; i++)
    gAudioSD_CSI_PrimaryInformation[i] = 0;
  strncpy(gAudioSD_CSI_PrimaryInformation, "'CSI_PrimaryInformation'", elcount(gAudioSD_CSI_PrimaryInformation));

  for (i = 0; i < SECONDARYINFORMATION_TEXTLENGTH; i++)
    gAudioSD_CSI_SecondaryInformation[i] = 0;
  strncpy(gAudioSD_CSI_SecondaryInformation, "'CSI_SecondaryInformation'", elcount(gAudioSD_CSI_SecondaryInformation));

  for (i = 0; i < TERTIARYINFORMATION_TEXTLENGTH; i++)
    gAudioSD_CSI_TertiaryInformation[i] = 0;
  strncpy(gAudioSD_CSI_TertiaryInformation, "'CSI_TertiaryInformation'", elcount(gAudioSD_CSI_TertiaryInformation));

  for (i = 0; i < QUATERNARYINFORMATION_TEXTLENGTH; i++)
  {
    gAudioSD_CSI_QuarternaryInformation[i] = 0;
    gAudioSD_CSI_Information5[i] = 0;
    gAudioSD_CSI_Information6[i] = 0;
    gAudioSD_CSI_Information7[i] = 0;
    gAudioSD_CSI_Information8[i] = 0;
  }
  strncpy(gAudioSD_CSI_QuarternaryInformation, "'CSI_QuarternaryInformation'", elcount(gAudioSD_CSI_QuarternaryInformation));

  putvalue(env_ASG_AudioSD_CSI2_Info1, gAudioSD_CSI_PrimaryInformation);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy1, gAudioSD_CSI_PI_Type);
  putvalue(env_ASG_AudioSD_CSI2_InfoID1, gAudioSD_CSI_PIID);
  putvalue(env_ASG_AudioSD_CSI2_Info2, gAudioSD_CSI_SecondaryInformation);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy2, gAudioSD_CSI_SI_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info3, gAudioSD_CSI_TertiaryInformation);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy3, gAudioSD_CSI_TI_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info4, gAudioSD_CSI_QuarternaryInformation);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy4, gAudioSD_CSI_QI_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info5, gAudioSD_CSI_Information5);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy5, gAudioSD_CSI_I5_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info6, gAudioSD_CSI_Information6);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy6, gAudioSD_CSI_I6_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info7, gAudioSD_CSI_Information7);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy7, gAudioSD_CSI_I7_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info8, gAudioSD_CSI_Information8);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy8, gAudioSD_CSI_I8_Type);
  putvalue(env_ASG_AudioSD_CSI2_SIS_Bit0, gAudioSD_CSI_StationInfoSwitches_Bit0);
  putvalue(env_ASG_AudioSD_CSI2_SIS_Bit1, gAudioSD_CSI_StationInfoSwitches_Bit1);
  putvalue(env_ASG_AudioSD_CSI2_SIS_Bit2, gAudioSD_CSI_StationInfoSwitches_Bit2);
  putvalue(env_ASG_AudioSD_CSI2_SIS_Bit3, gAudioSD_CSI_StationInfoSwitches_Bit3);
  putvalue(env_ASG_AudioSD_CSI2_SIS_Bit4, gAudioSD_CSI_StationInfoSwitches_Bit4);
  putvalue(env_ASG_AudioSD_CSI2_SP_Bit0, gAudioSD_CSI_StationProperties_Bit0);
  putvalue(env_ASG_AudioSD_CSI2_SP_Bit1, gAudioSD_CSI_StationProperties_Bit1);
  putvalue(env_ASG_AudioSD_CSI2_SP_Bit2, gAudioSD_CSI_StationProperties_Bit2);
  putvalue(env_ASG_AudioSD_CSI2_SP_Bit3, gAudioSD_CSI_StationProperties_Bit3);
  putvalue(env_ASG_AudioSD_CSI2_SP_Bit4, gAudioSD_CSI_StationProperties_Bit4);
  putvalue(env_ASG_AudioSD_CSI2_SLS, gAudioSD_CSI_StationLinkingState);
  putvalue(env_ASG_AudioSD_CSI2_ChanID, gAudioSD_CSI_ChannelID);
  putvalue(env_ASG_AudioSD_CSI2_RadioCat, gAudioSD_CSI_RadioCategory);
  putvalue(env_ASG_AudioSD_CSI2_Ext1, gAudioSD_CSI_Extension1);  
  
  //0x19 CurrentStation_Handle
  gAudioSD_CSIhandle_FSGhandle = 0x10;
  gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;
  gAudioSD_CSIhandle_PresetListRef = 0;
  gAudioSD_CSIhandle_PresetListabsolutePos = 0;
  gAudioSD_CSIhandle_PictureRef = 0;
  gAudioSD_CSIhandle_Extension1 = 0;
  gAudioSD_CSIhandle_Extension2 = 0;
  gAudioSD_CSIhandle_Extension3 = 0;
  gAudioSD_CSIhandle_Extension4 = 0;
  gAudioSD_CSIhandle_Extension5 = 0;
  gAudioSD_CSIhandle_Extension6 = 0;
  gAudioSD_CSIhandle_Extension7 = 0;
  gAudioSD_CSIhandle_Extension8 = 0;
  gAudioSD_CSIhandle_Extension9 = 0;
  gAudioSD_CSIhandle_Extension10 = 0;
  gAudioSD_CSIhandle_Extension11 = 0;
  gAudioSD_CSIhandle_Extension12 = 0;
  gAudioSD_CSIhandle_Extension13 = 0;
  gAudioSD_CSIhandle_Extension14 = 0;
  gAudioSD_CSIhandle_Extension15 = 0;

  putvalue(env_ASG_AudioSD_CSH_FSGh, gAudioSD_CSIhandle_FSGhandle);
  putvalue(env_ASG_AudioSD_CSH_FSGh_abs, gAudioSD_CSIhandle_FSGhandle_absolutePos);
  putvalue(env_ASG_AudioSD_CSH_PL_Ref, gAudioSD_CSIhandle_PresetListRef);
  putvalue(env_ASG_AudioSD_CSH_PL_abs, gAudioSD_CSIhandle_PresetListabsolutePos);
  putvalue(env_ASG_AudioSD_CSH_PicRef, gAudioSD_CSIhandle_PictureRef);
  putvalue(env_ASG_AudioSD_CSH_Extension1, gAudioSD_CSIhandle_Extension1);
  putvalue(env_ASG_AudioSD_CSH_Extension2, gAudioSD_CSIhandle_Extension2);
  putvalue(env_ASG_AudioSD_CSH_Extension3, gAudioSD_CSIhandle_Extension3);
  putvalue(env_ASG_AudioSD_CSH_Extension4, gAudioSD_CSIhandle_Extension4);
  putvalue(env_ASG_AudioSD_CSH_Extension5, gAudioSD_CSIhandle_Extension5);
  putvalue(env_ASG_AudioSD_CSH_Extension6, gAudioSD_CSIhandle_Extension6);
  putvalue(env_ASG_AudioSD_CSH_Extension7, gAudioSD_CSIhandle_Extension7);
  putvalue(env_ASG_AudioSD_CSH_Extension8, gAudioSD_CSIhandle_Extension8);
  putvalue(env_ASG_AudioSD_CSH_Extension9, gAudioSD_CSIhandle_Extension9);
  putvalue(env_ASG_AudioSD_CSH_Extension10, gAudioSD_CSIhandle_Extension10);
  putvalue(env_ASG_AudioSD_CSH_Extension11, gAudioSD_CSIhandle_Extension11);
  putvalue(env_ASG_AudioSD_CSH_Extension12, gAudioSD_CSIhandle_Extension12);
  putvalue(env_ASG_AudioSD_CSH_Extension13, gAudioSD_CSIhandle_Extension13);
  putvalue(env_ASG_AudioSD_CSH_Extension14, gAudioSD_CSIhandle_Extension14);
  putvalue(env_ASG_AudioSD_CSH_Extension15, gAudioSD_CSIhandle_Extension15);
  
  //0x1A PlayPosition
  gAudioSD_PlayPosition_TimePosition = 0;
  gAudioSD_PlayPosition_TotalPlayTime = 0;
  gAudioSD_PlayPosition_Attributes_Bit0 = 0;
  gAudioSD_PlayPosition_Attributes = gAudioSD_PlayPosition_Attributes_Bit0;
  gAudioSD_PlayPosition_BufferLevel = 0;
  putvalue(env_ASG_AudioSD_PP_TimePos, gAudioSD_PlayPosition_TimePosition);
  putvalue(env_ASG_AudioSD_PP_TotalPlayTime, gAudioSD_PlayPosition_TotalPlayTime);
  putvalue(env_ASG_AudioSD_PP_Attr_Bit0, gAudioSD_PlayPosition_Attributes);
  putvalue(env_ASG_AudioSD_PP_BufferLevel, gAudioSD_PlayPosition_BufferLevel);
  
  //0x1B Station_Track_Switch
  gAudioSD_STS_Event = 0;
  gAudioSD_STS_Direction = 0;
  gAudioSD_STS_Extension1 = 0;
  gAudioSD_STS_Extension2 = 0;
  gAudioSD_STS_Extension3 = 0;
  gAudioSD_STS_Extension4 = 0;
  gAudioSD_STS_Extension5 = 0;
  putvalue(env_ASG_AudioSD_STS_Event, gAudioSD_STS_Event);
  putvalue(env_ASG_AudioSD_STS_Direction, gAudioSD_STS_Direction);
  putvalue(env_ASG_AudioSD_STS_Extension1, gAudioSD_STS_Extension1);
  putvalue(env_ASG_AudioSD_STS_Extension2, gAudioSD_STS_Extension2);
  putvalue(env_ASG_AudioSD_STS_Extension3, gAudioSD_STS_Extension3);
  putvalue(env_ASG_AudioSD_STS_Extension4, gAudioSD_STS_Extension4);
  putvalue(env_ASG_AudioSD_STS_Extension5, gAudioSD_STS_Extension5);
  
  //0x1C AnnouncementInfo
  gAudioSD_AnnouncementInfo_Type = ANNOUNCEMENT_TYPE_NO_MESSAGE;
  for (i = 0; i < ANNOUNCEMENT_STATIONNAME_TEXTLENGTH; i++)
      gAudioSD_AnnouncementInfo_StationName[i] = 0;
  strncpy(gAudioSD_AnnouncementInfo_StationName, "'Announcement_StationName'", elcount(gAudioSD_AnnouncementInfo_StationName));
  putvalue(env_ASG_AudioSD_AnInf_Type, 0);
  putvalue(env_ASG_AudioSD_AnInf_Name_s, gAudioSD_AnnouncementInfo_StationName);
  
  //0x1D AnnouncementEscape
  gAudioSD_AnnouncementEscape_AsgId = 0;
  gAudioSD_AnnouncementEscape_Extension1 = 0;
  gAudioSD_AnnouncementEscape_Reserve = 0;
  gAudioSD_AnnouncementEscape_Result = 0;
  putvalue(env_ASG_AudioSD_AnE_AsgID, gAudioSD_AnnouncementEscape_AsgId);
  putvalue(env_ASG_AudioSD_AnE_Ext1, gAudioSD_AnnouncementEscape_Extension1);
  putvalue(env_ASG_AudioSD_AnE_Res, gAudioSD_AnnouncementEscape_Result);
  
  //0x1E ReceptionList
  gReceptionList_ASGID = 0;
  gReceptionList_TAID = 0;
  gReceptionList_TotalNumListElements = 0;
  gReceptionList_ElementType = AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES;
  gReceptionList_ParentID = 0;
  gReceptionList_sum = 0;
  for (j = 0; j < AUDIO_RECEPTIONLIST_ENTRIES; j++)
  {
      gReceptionList_ListEntryValidInformation[j] = 0;
      gReceptionList_Pos[j] = 0;
      gReceptionList_Waveband[j] = 0;
      gReceptionList_Type[j] = 0;
      gReceptionList_Attributes1_Bit0[j] = 0;
      gReceptionList_Attributes1_Bit1[j] = 0;
      gReceptionList_Attributes1_Bit2[j] = 0;
      gReceptionList_Attributes1_Bit3[j] = 0;
      gReceptionList_Attributes1_Bit4[j] = 0;
      gReceptionList_Attributes1_Bit5[j] = 0;
      gReceptionList_Attributes1_Bit6[j] = 0;
      gReceptionList_Attributes1_Bit7[j] = 0;
      gReceptionList_Attributes1[j] = 0;
      gReceptionList_Attributes2_Bit0[j] = 0;
      gReceptionList_Attributes2_Bit1[j] = 0;
      gReceptionList_Attributes2_Bit2[j] = 0;
      gReceptionList_Attributes2_Bit3[j] = 0;
      gReceptionList_Attributes2[j] = 0;
      gReceptionList_PresetID[j] = 0;
      gReceptionList_FmRegCode[j] = 0;
      gReceptionList_Category[j] = 0;
      for (i = 0; i < AUDIO_RECEPTIONLIST_NAME_LENGTH; i++)
          gReceptionList_Name[j][i] = 0;
      for (i = 0; i < AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH; i++)
          gReceptionList_Frequency[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gReceptionList_CSV_filename[i] = 0;
  putvalue(env_ASG_AudioSD_RL_ASGID, gReceptionList_ASGID);
  putvalue(env_ASG_AudioSD_RL_TAID, gReceptionList_TAID);
  putvalue(env_ASG_AudioSD_RL_ParentID, gReceptionList_ParentID);
  putvalue(env_ASG_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements);
  putvalue(env_ASG_AudioSD_RL_ElementType, gReceptionList_ElementType);
  putvalue(env_ASG_AudioSD_RL_AH_shift, FALSE);
  putvalue(env_ASG_AudioSD_RL_AH_dir, FORWARD);
  putvalue(env_ASG_AudioSD_RL_AH_PosTrans, TRUE);
  putvalue(env_ASG_AudioSD_RL_AH_IS, TRUE);
  putvalue(env_ASG_AudioSD_RL_AH_RA, 0);
  putvalue(env_ASG_AudioSD_RL_AH_start, 0);
  putvalue(env_ASG_AudioSD_RL_AH_elements, 3);
  
  //0x1F RadioTV_PresetList
  gRadioTVPresetList_ASGID = 0;
  gRadioTVPresetList_TAID = 0;
  gRadioTVPresetList_TotalNumListElements = 0;
  gRadioTVPresetList_sum = 0;
  for (j = 0; j < AUDIO_RADIOTVPRESETLIST_ENTRIES; j++)
  {
      gRadioTVPresetList_ListEntryValidInformation[j] = 0;
      gRadioTVPresetList_Pos[j] = 0;
      gRadioTVPresetList_PresetIndex[j] = 0;
      gRadioTVPresetList_Waveband[j] = 0;
      gRadioTVPresetList_Attributes1_Bit0[j] = 0;
      gRadioTVPresetList_Attributes1_Bit1[j] = 0;
      gRadioTVPresetList_Attributes1_Bit2[j] = 0;
      gRadioTVPresetList_Attributes1_Bit3[j] = 0;
      gRadioTVPresetList_Attributes1_Bit4[j] = 0;
      gRadioTVPresetList_Attributes1_Bit5[j] = 0;
      gRadioTVPresetList_Attributes1_Bit6[j] = 0;
      gRadioTVPresetList_Attributes1_Bit7[j] = 0;
      gRadioTVPresetList_Attributes1[j] = 0;
      gRadioTVPresetList_Attributes2_Bit0[j] = 0;
      gRadioTVPresetList_Attributes2_Bit1[j] = 0;
      gRadioTVPresetList_Attributes2_Bit2[j] = 0;
      gRadioTVPresetList_Attributes2_Bit3[j] = 0;
      gRadioTVPresetList_Attributes2_Bit4[j] = 0;
      gRadioTVPresetList_Attributes2[j] = 0;
      gRadioTVPresetList_PicRef[j] = 0;
      for (i = 0; i < AUDIO_RADIOTVPRESETLIST_NAME_LENGTH; i++)
          gRadioTVPresetList_Name[j][i] = 0;
      for (i = 0; i < AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH; i++)
          gRadioTVPresetList_Frequency[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gRadioTVPresetList_CSV_filename[i] = 0;
  putvalue(env_ASG_AudioSD_RTPL_ASGID, gRadioTVPresetList_ASGID);
  putvalue(env_ASG_AudioSD_RTPL_TAID, gRadioTVPresetList_TAID);
  putvalue(env_ASG_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements);
  putvalue(env_ASG_AudioSD_RTPL_AH_shift, FALSE);
  putvalue(env_ASG_AudioSD_RTPL_AH_dir, FORWARD);
  putvalue(env_ASG_AudioSD_RTPL_AH_PosTrans, TRUE);
  putvalue(env_ASG_AudioSD_RTPL_AH_IS, TRUE);
  putvalue(env_ASG_AudioSD_RTPL_AH_RA, 0);
  putvalue(env_ASG_AudioSD_RTPL_AH_start, 0);
  putvalue(env_ASG_AudioSD_RTPL_AH_elements, 3);
  
  //0x20 ListSetup
  gAudioSD_ListSetup_PreferredList = 0;
  gAudioSD_ListSetup_ReceptionListType = 0;
  gAudioSD_ListSetup_Extension1 = 0;
  gAudioSD_ListSetup_Extension2 = 0;
  gAudioSD_ListSetup_Extension3 = 0;
  gAudioSD_ListSetup_Extension4 = 0;
  putvalue(env_ASG_AudioSD_LS_PrefList, gAudioSD_ListSetup_PreferredList);
  putvalue(env_ASG_AudioSD_LS_RLType, gAudioSD_ListSetup_ReceptionListType);
  putvalue(env_ASG_AudioSD_LS_Ext1, gAudioSD_ListSetup_Extension1);
  putvalue(env_ASG_AudioSD_LS_Ext2, gAudioSD_ListSetup_Extension2);
  putvalue(env_ASG_AudioSD_LS_Ext3, gAudioSD_ListSetup_Extension3);
  putvalue(env_ASG_AudioSD_LS_Ext4, gAudioSD_ListSetup_Extension4);
  
  //0x21 SourceList
  gSourceList_ASGID = 0;
  gSourceList_TAID = 0;
  gSourceList_TotalNumListElements = 0;
  gSourceList_sum = 0;
  for (j = 0; j < AUDIO_SOURCELIST_ENTRIES; j++)
  {
      gSourceList_ListEntryValidInformation[j] = 0;
      gSourceList_Pos[j] = 0;
      gSourceList_SourceType[j] = 0;
      gSourceList_InstanceID[j] = 0;
      gSourceList_PicRef[j] = 0;
      gSourceList_Attributes_Bit0[j] = 0;
      gSourceList_Attributes_Bit1[j] = 0;
      gSourceList_Attributes_Bit2[j] = 0;
      gSourceList_Attributes_Bit3[j] = 0;
      gSourceList_Attributes_Bit4[j] = 0;
      gSourceList_Attributes_Bit5[j] = 0;
      gSourceList_Attributes_Bit6[j] = 0;
      gSourceList_Attributes[j] = 0;
      for (i = 0; i < AUDIO_SOURCELIST_NAME_LENGTH; i++)
          gSourceList_Name[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gSourceList_CSV_filename[i] = 0;
  putvalue(env_ASG_AudioSD_SL_ASGID, gSourceList_ASGID);
  putvalue(env_ASG_AudioSD_SL_TAID, gSourceList_TAID);
  putvalue(env_ASG_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements);
  putvalue(env_ASG_AudioSD_SL_AH_shift, FALSE);
  putvalue(env_ASG_AudioSD_SL_AH_dir, FORWARD);
  putvalue(env_ASG_AudioSD_SL_AH_PosTrans, TRUE);
  putvalue(env_ASG_AudioSD_SL_AH_IS, TRUE);
  putvalue(env_ASG_AudioSD_SL_AH_RA, 0);
  putvalue(env_ASG_AudioSD_SL_AH_start, 0);
  putvalue(env_ASG_AudioSD_SL_AH_elements, 3);
  
  //0x22 DedicatedAudioControl
  gAudioSD_DAC_AsgId = 0;
  gAudioSD_DAC_Extension1 = 0;
  gAudioSD_DAC_status = FALSE;
  gAudioSD_DAC_FSGHandle = 0;
  gAudioSD_DAC_Result = AUDIO_DAC_SUCCESSFUL;
  gAudioSD_DAC_ControlType = AUDIO_DAC_SELECT_LIST_ENTRY;
  gAudioSD_DAC_ListType = AUDIO_DAC_NOLIST;
  putvalue(env_ASG_AudioSD_DAC_AsgID, gAudioSD_DAC_AsgId);
  putvalue(env_ASG_AudioSD_DAC_Ext1, gAudioSD_DAC_Extension1);
  putvalue(env_ASG_AudioSD_DAC_Res, gAudioSD_DAC_Result);
  putvalue(env_ASG_AudioSD_DAC_CT, gAudioSD_DAC_ControlType);
  putvalue(env_ASG_AudioSD_DAC_FSGHandle, gAudioSD_DAC_FSGHandle);
  putvalue(env_ASG_AudioSD_DAC_LT, gAudioSD_DAC_ListType);
  
  //0x23 SwitchSource
  gAudioSD_SwitchSource_status = FALSE;
  gAudioSD_SwitchSource_AsgId = 0;
  gAudioSD_SwitchSource_Extension1 = 0;
  gAudioSD_SwitchSource_ControlType = 0;
  gAudioSD_SwitchSource_Reference = 0;
  gAudioSD_SwitchSource_Reserve = 0;
  gAudioSD_SwitchSource_Result = AUDIO_SWITCHSOURCERESULT_SUCCESSFUL;
  putvalue(env_ASG_AudioSD_SwSource_AsgID, gAudioSD_SwitchSource_AsgId);
  putvalue(env_ASG_AudioSD_SwSource_Ext1, gAudioSD_SwitchSource_Extension1);
  putvalue(env_ASG_AudioSD_SwSource_CT, gAudioSD_SwitchSource_ControlType);
  putvalue(env_ASG_AudioSD_SwSource_Ref, gAudioSD_SwitchSource_Reference);
  putvalue(env_ASG_AudioSD_SwSource_Res, gAudioSD_SwitchSource_Result);
  
  //0x24 Browser_FolderLevel
  gAudioSD_MediaBrowser_FL_FolderLevel = 0;
  gAudioSD_MediaBrowser_FL_RefMediaBrowser = 0;
  gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos = 0;
  gAudioSD_MediaBrowser_FL_Extension1 = 0;
  putvalue(env_ASG_AudioSD_MeBrLevel_FL, gAudioSD_MediaBrowser_FL_FolderLevel);
  putvalue(env_ASG_AudioSD_MeBrLevel_Ref, gAudioSD_MediaBrowser_FL_RefMediaBrowser);
  putvalue(env_ASG_AudioSD_MeBrLevel_Ref_a, gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos);
  putvalue(env_ASG_AudioSD_MeBrLevel_Ext1, gAudioSD_MediaBrowser_FL_Extension1);
  
  //0x25 Browser
  gMediaBrowser_ASGID = 0;
  gMediaBrowser_TAID = 0;
  gMediaBrowser_TotalNumListElements = 0;
  gMediaBrowser_ActiveListPos = 0;
  gMediaBrowser_sum = 0;
  for (j = 0; j < AUDIO_MEDIABROWSER_ENTRIES; j++)
  {
      gMediaBrowser_ListEntryValidInformation[j] = 0;
      gMediaBrowser_Pos[j] = 0;
      gMediaBrowser_Type[j] = 0;
      gMediaBrowser_FileState_Bit0[j] = 0;
      gMediaBrowser_FileState_Bit1[j] = 0;
      gMediaBrowser_FileState_Bit2[j] = 0;
      gMediaBrowser_FileState_Bit3[j] = 0;
      gMediaBrowser_FileState_Bit4[j] = 0;
      gMediaBrowser_FileState_Bit5[j] = 0;
      gMediaBrowser_FileState_Bit6[j] = 0;
      gMediaBrowser_FileState[j] = 0;
      gMediaBrowser_Waveband[j] = 0;
      gMediaBrowser_RadioCategory[j] = 0;
      gMediaBrowser_FmRegCode[j] = 0;
      gMediaBrowser_PresetID[j] = 0;
      gMediaBrowser_PicRef[j] = 0;
      gMediaBrowser_Attributes1_Bit0[j] = 0;
      gMediaBrowser_Attributes1_Bit1[j] = 0;
      gMediaBrowser_Attributes1_Bit2[j] = 0;
      gMediaBrowser_Attributes1_Bit3[j] = 0;
      gMediaBrowser_Attributes1_Bit4[j] = 0;
      gMediaBrowser_Attributes1_Bit5[j] = 0;
      gMediaBrowser_Attributes1_Bit6[j] = 0;
      gMediaBrowser_Attributes1_Bit7[j] = 0;
      gMediaBrowser_Attributes1[j] = 0;
      gMediaBrowser_Attributes2_Bit0[j] = 0;
      gMediaBrowser_Attributes2_Bit1[j] = 0;
      gMediaBrowser_Attributes2[j] = 0;
      for (i = 0; i < AUDIO_MEDIABROWSER_NAME_LENGTH; i++)
          gMediaBrowser_Name[j][i] = 0;
      for (i = 0; i < AUDIO_MEDIABROWSER_FREQUENCY_LENGTH; i++)
          gMediaBrowser_Frequency[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gMediaBrowser_CSV_filename[i] = 0;
  putvalue(env_ASG_AudioSD_MB_ASGID, gMediaBrowser_ASGID);
  putvalue(env_ASG_AudioSD_MB_TAID, gMediaBrowser_TAID);
  putvalue(env_ASG_AudioSD_MB_ActiveListPos, gMediaBrowser_ActiveListPos);
  putvalue(env_ASG_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements);
  putvalue(env_ASG_AudioSD_MB_AH_shift, FALSE);
  putvalue(env_ASG_AudioSD_MB_AH_dir, FORWARD);
  putvalue(env_ASG_AudioSD_MB_AH_PosTrans, TRUE);
  putvalue(env_ASG_AudioSD_MB_AH_IS, TRUE);
  putvalue(env_ASG_AudioSD_MB_AH_RA, 0);
  putvalue(env_ASG_AudioSD_MB_AH_start, 0);
  putvalue(env_ASG_AudioSD_MB_AH_elements, 3);
  
  //0x26 BrowserPath
  gAudioSD_MediaPath_FolderType = 0;
  for (i = 0; i < MEDIAPATH_PATH_TEXTLENGTH; i++)
      gAudioSD_MediaPath_Path[i] = 0;
  strncpy(gAudioSD_MediaPath_Path, "'MediaPath'", elcount(gAudioSD_MediaPath_Path));
  putvalue(env_ASG_AudioSD_MePath_Type, gAudioSD_MediaPath_FolderType);
  putvalue(env_ASG_AudioSD_MePath_Path_s, gAudioSD_MediaPath_Path);
  
  //0x27 BrowserControl
  gAudioSD_MediaBrowserControl_status = FALSE;
  gAudioSD_MediaBrowserControl_AsgId = 0;
  gAudioSD_MediaBrowserControl_Extension1 = 0;
  gAudioSD_MediaBrowserControl_Control = 0;
  gAudioSD_MediaBrowserControl_Reference = 0;
  gAudioSD_MediaBrowserControl_Reserve = 0;
  gAudioSD_MediaBrowserControl_Result = AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL;
  putvalue(env_ASG_AudioSD_MBrC_AsgID, gAudioSD_MediaBrowserControl_AsgId);
  putvalue(env_ASG_AudioSD_MBrC_Ext1, gAudioSD_MediaBrowserControl_Extension1);
  putvalue(env_ASG_AudioSD_MBrC_Ref, gAudioSD_MediaBrowserControl_Reference);
  putvalue(env_ASG_AudioSD_MBrC_Control, gAudioSD_MediaBrowserControl_Control);
  putvalue(env_ASG_AudioSD_MBrC_Res, gAudioSD_MediaBrowserControl_Result);
  
  //0x28 Picture
  gPicture_ASGID = 0;
  gPicture_TAID = 0;
  gPicture_TotalNumListElements = 0;
  gPicture_sum = 0;
  for (j = 0; j < AUDIO_PICTURE_ENTRIES; j++)
  {
      gPicture_ListEntryValidInformation[j] = 0;
      gPicture_Pos[j] = 0;
      gPicture_Type[j] = 0;
      gPicture_TcpPort[j] = 0;
      for (i = 0; i < AUDIO_PICTURE_IPADDRESS_LENGTH; i++)
          gPicture_IpAddress[j][i] = 0;
      for (i = 0; i < AUDIO_PICTURE_URI_LENGTH; i++)
          gPicture_Uri[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gPicture_CSV_filename[i] = 0;
  putvalue(env_ASG_AudioSD_Pic_ASGID, gPicture_ASGID);
  putvalue(env_ASG_AudioSD_Pic_TAID, gPicture_TAID);
  putvalue(env_ASG_AudioSD_Pic_TotalNumLE, gPicture_TotalNumListElements);
  putvalue(env_ASG_AudioSD_Pic_AH_shift, FALSE);
  putvalue(env_ASG_AudioSD_Pic_AH_dir, FORWARD);
  putvalue(env_ASG_AudioSD_Pic_AH_PosTrans, TRUE);
  putvalue(env_ASG_AudioSD_Pic_AH_IS, TRUE);
  putvalue(env_ASG_AudioSD_Pic_AH_RA, 0);
  putvalue(env_ASG_AudioSD_Pic_AH_start, 0);
  putvalue(env_ASG_AudioSD_Pic_AH_elements, 3);
}

void Shutdown_AudioSD ()
{ 
  dword i, j;
  
  canceltimer(TaskTimer);
  putvalue(env_ASG_AudioSD_Config_SWConfig,empty_string);
  putvalue(env_ASG_AudioSD_Config_DBC,empty_string);

  //FctList
  putvalue(env_ASG_AudioSD_FctList_Bit01,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit02,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit03,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit04,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit13,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit14,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit15,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit16,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit17,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit18,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit19,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit20,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit21,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit22,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit23,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit24,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit25,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit26,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit27,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit28,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit29,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit30,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit31,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit32,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit33,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit34,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit35,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit36,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit37,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit38,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit39,FALSE);
  putvalue(env_ASG_AudioSD_FctList_Bit40,FALSE);

  //0x0D FSG-Control
  gAudioSD_FSGControl_Extension1 = 0;
  gAudioSD_FSGControl_Extension2 = 0;
  gAudioSD_FSGControl_Extension3 = 0;
  gAudioSD_FSGControl_Extension4 = 0;
  gAudioSD_FSGControl_Extension5 = 0;
  gAudioSD_FSGControl_Extension6 = 0;
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext1, gAudioSD_FSGControl_Extension1);
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext2, gAudioSD_FSGControl_Extension2);
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext3, gAudioSD_FSGControl_Extension3);
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext4, gAudioSD_FSGControl_Extension4);
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext5, gAudioSD_FSGControl_Extension5);
  putvalue(env_ASG_AudioSD_FSGCtrl_Ext6, gAudioSD_FSGControl_Extension6);
  
  //0x0E FSG-Setup
  gAudioSD_FSGSetup_FunctionSupport = 0;
  gAudioSD_FSGSetup_FunctionSupport_Bit0 = 0;
  gAudioSD_FSGSetup_FunctionSupport_Bit1 = 0;
  gAudioSD_FSGSetup_FunctionProtection = 0;
  gAudioSD_FSGSetup_FunctionProtection_Bit0 = 0;
  gAudioSD_FSGSetup_WebAppState = 0;
  gAudioSD_FSGSetup_WebAppState_Bit0 = 0; 
  gAudioSD_FSGSetup_Extension1 = 0;
  gAudioSD_FSGSetup_Extension2 = 0;
  gAudioSD_FSGSetup_Extension3 = 0;
  gAudioSD_FSGSetup_Extension4 = 0;
  putvalue(env_ASG_AudioSD_FSGSetup_FS_Bit0, gAudioSD_FSGSetup_FunctionSupport_Bit0);
  putvalue(env_ASG_AudioSD_FSGSetup_FS_Bit1, gAudioSD_FSGSetup_FunctionSupport_Bit1);
  putvalue(env_ASG_AudioSD_FSGSetup_FP_Bit0, gAudioSD_FSGSetup_FunctionProtection_Bit0);
  putvalue(env_ASG_AudioSD_FSGSetup_WASBit0, gAudioSD_FSGSetup_WebAppState_Bit0);
  putvalue(env_ASG_AudioSD_FSGSetup_Ext1, gAudioSD_FSGSetup_Extension1);
  putvalue(env_ASG_AudioSD_FSGSetup_Ext2, gAudioSD_FSGSetup_Extension2);
  putvalue(env_ASG_AudioSD_FSGSetup_Ext3, gAudioSD_FSGSetup_Extension3);
  putvalue(env_ASG_AudioSD_FSGSetup_Ext4, gAudioSD_FSGSetup_Extension4);

  //0x0F FSG-OperationState
  gAudioSD_FSGOperationState_OpState = FSGOPERATIONSTATE_INITIALIZING;
  gAudioSD_FSGOperationState_Extension1 = 0;
  gAudioSD_FSGOperationState_Extension2 = 0;
  gAudioSD_FSGOperationState_Extension3 = 0;
  gAudioSD_FSGOperationState_Extension4 = 0;
  gAudioSD_FSGOperationState_Extension5 = 0;
  putvalue(env_ASG_AudioSD_FSGOpState_State, gAudioSD_FSGOperationState_OpState);
  putvalue(env_ASG_AudioSD_FSGOpState_Ext1, gAudioSD_FSGOperationState_Extension1);
  putvalue(env_ASG_AudioSD_FSGOpState_Ext2, gAudioSD_FSGOperationState_Extension2);
  putvalue(env_ASG_AudioSD_FSGOpState_Ext3, gAudioSD_FSGOperationState_Extension3);
  putvalue(env_ASG_AudioSD_FSGOpState_Ext4, gAudioSD_FSGOperationState_Extension4);
  putvalue(env_ASG_AudioSD_FSGOpState_Ext5, gAudioSD_FSGOperationState_Extension5);
  
  //0x10 ASG_Capabilities
  gAudioSD_ASGCapabilities_PresentationCapabilities = 0;
  gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = 0;
  gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 = 0;
  gAudioSD_ASGCapabilities_Extension1 = 0;
  gAudioSD_ASGCapabilities_Extension2 = 0;
  gAudioSD_ASGCapabilities_Extension3 = 0;
  gAudioSD_ASGCapabilities_Extension4 = 0;
  gAudioSD_ASGCapabilities_Extension5 = 0;
  putvalue(env_ASG_AudioSD_ASGCap_PrC_DAB, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0);
  putvalue(env_ASG_AudioSD_ASGCap_PrC_SDARS, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1);
  putvalue(env_ASG_AudioSD_ASGCap_Ext1, gAudioSD_ASGCapabilities_Extension1);
  putvalue(env_ASG_AudioSD_ASGCap_Ext2, gAudioSD_ASGCapabilities_Extension2);
  putvalue(env_ASG_AudioSD_ASGCap_Ext3, gAudioSD_ASGCapabilities_Extension3);
  putvalue(env_ASG_AudioSD_ASGCap_Ext4, gAudioSD_ASGCapabilities_Extension4);
  putvalue(env_ASG_AudioSD_ASGCap_Ext5, gAudioSD_ASGCapabilities_Extension5);
  
  //0x11 InfoStates
  gAudioSD_InfoStates_States = 0;
  gAudioSD_InfoStates_AdditionalStateInfo_Bit0 = 0;
  gAudioSD_InfoStates_AdditionalStateInfo = gAudioSD_InfoStates_AdditionalStateInfo_Bit0;
  gAudioSD_InfoStates_Extension1 = 0;
  gAudioSD_InfoStates_Extension2 = 0;
  gAudioSD_InfoStates_Extension3 = 0;
  gAudioSD_InfoStates_Extension4 = 0;
  putvalue(env_ASG_AudioSD_InfoSt_States, gAudioSD_InfoStates_States);
  putvalue(env_ASG_AudioSD_InfoSt_ASI_Bit0, gAudioSD_InfoStates_AdditionalStateInfo);
  putvalue(env_ASG_AudioSD_InfoSt_Ext1, gAudioSD_InfoStates_Extension1);
  putvalue(env_ASG_AudioSD_InfoSt_Ext2, gAudioSD_InfoStates_Extension2);
  putvalue(env_ASG_AudioSD_InfoSt_Ext3, gAudioSD_InfoStates_Extension3);
  putvalue(env_ASG_AudioSD_InfoSt_Ext4, gAudioSD_InfoStates_Extension4);
  
  //0x12 SDS_State
  gAudioSD_SDSState_State = 0;
  gAudioSD_SDSState_Extension1 = 0;
  gAudioSD_SDSState_Extension2 = 0;
  gAudioSD_SDSState_Extension3 = 0;
  gAudioSD_SDSState_Extension4 = 0;
  gAudioSD_SDSState_Extension5 = 0;
  putvalue(env_ASG_AudioSD_SDSState_State, gAudioSD_SDSState_State);
  putvalue(env_ASG_AudioSD_SDSState_Ext1, gAudioSD_SDSState_Extension1);
  putvalue(env_ASG_AudioSD_SDSState_Ext2, gAudioSD_SDSState_Extension2);
  putvalue(env_ASG_AudioSD_SDSState_Ext3, gAudioSD_SDSState_Extension3);
  putvalue(env_ASG_AudioSD_SDSState_Ext4, gAudioSD_SDSState_Extension4);
  putvalue(env_ASG_AudioSD_SDSState_Ext5, gAudioSD_SDSState_Extension5);
  
  //0x13 GeneralInfoSwitches
  gAudioSD_GeneralInfoSwitches_OnOffSwitches = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS = 0;
  gAudioSD_GeneralInfoSwitches_Extension1 = 0;
  gAudioSD_GeneralInfoSwitches_Extension2 = 0;
  gAudioSD_GeneralInfoSwitches_Extension3 = 0;
  gAudioSD_GeneralInfoSwitches_Extension4 = 0;
  gAudioSD_GeneralInfoSwitches_Extension5 = 0;
  putvalue(env_ASG_AudioSD_GIS_OnOffSw_TP, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA);
  putvalue(env_ASG_AudioSD_GIS_OnOffSw_RDS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS);
  putvalue(env_ASG_AudioSD_GIS_OnOffSw_JP, gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic);
  putvalue(env_ASG_AudioSD_GIS_OnOffSw_TMC, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC);
  putvalue(env_ASG_AudioSD_GIS_OnOffSw_VICS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS);
  putvalue(env_ASG_AudioSD_GIS_Ext1, gAudioSD_GeneralInfoSwitches_Extension1);
  putvalue(env_ASG_AudioSD_GIS_Ext2, gAudioSD_GeneralInfoSwitches_Extension2);
  putvalue(env_ASG_AudioSD_GIS_Ext3, gAudioSD_GeneralInfoSwitches_Extension3);
  putvalue(env_ASG_AudioSD_GIS_Ext4, gAudioSD_GeneralInfoSwitches_Extension4);
  putvalue(env_ASG_AudioSD_GIS_Ext5, gAudioSD_GeneralInfoSwitches_Extension5);
  
  //0x14 ActiveSource
  gAudioSD_activeSource_SourceType = ACTIVESOURCE_SOURCETYPE_FM;
  gAudioSD_activeSource_SourceList_Reference = 0;
  gAudioSD_activeSource_ListAvailable_Bit0 = 0;
  gAudioSD_activeSource_ListAvailable_Bit1 = 0;
  gAudioSD_activeSource_ListAvailable_Bit2 = 0;
  gAudioSD_activeSource_ListAvailable = (gAudioSD_activeSource_ListAvailable_Bit2*0x04) + (gAudioSD_activeSource_ListAvailable_Bit1*0x02) + (gAudioSD_activeSource_ListAvailable_Bit0&0x01);
  gAudioSD_activeSource_ListState = ACTIVESOURCE_LISTSTATE_COMPLETELY_LOADED;
  gAudioSD_activeSource_Number = 0;
  gAudioSD_activeSource_Extension1 = 0;
  putvalue(env_ASG_AudioSD_AS_SourceType, gAudioSD_activeSource_SourceType);
  putvalue(env_ASG_AudioSD_AS_SL_Ref, gAudioSD_activeSource_SourceList_Reference);
  putvalue(env_ASG_AudioSD_AS_LiAv_RL, gAudioSD_activeSource_ListAvailable_Bit0);
  putvalue(env_ASG_AudioSD_AS_LiAv_PL, gAudioSD_activeSource_ListAvailable_Bit1);
  putvalue(env_ASG_AudioSD_AS_LiAv_BL, gAudioSD_activeSource_ListAvailable_Bit2);
  putvalue(env_ASG_AudioSD_AS_ListState, gAudioSD_activeSource_ListState);
  putvalue(env_ASG_AudioSD_AS_Number, gAudioSD_activeSource_Number);
  putvalue(env_ASG_AudioSD_AS_Ext1, gAudioSD_activeSource_Extension1);
  
  //0x15 ActiveSourceName
  for (i = 0; i < ACTIVE_SOURCE_NAME_LENGTH; i++)
      gAudioSD_activeSourceName[i] = 0;
  strncpy(gAudioSD_activeSourceName, "'activeSourceName'", elcount(gAudioSD_activeSourceName));
  putvalue(env_ASG_AudioSD_ASName_Name_s, gAudioSD_activeSourceName);
  
  //0x16 CurrentVolume
  gAudioSD_currentVolume_ChangingVolumeType = 0;
  gAudioSD_currentVolume_maxVolume = 0;
  gAudioSD_currentVolume_GenericVolume = 0;
  gAudioSD_currentVolume_MuteState = 0;
  gAudioSD_currentVolume_Extension1 = 0;
  gAudioSD_currentVolume_Extension2 = 0;
  putvalue(env_ASG_AudioSD_CurrVol_CVT, gAudioSD_currentVolume_ChangingVolumeType);
  putvalue(env_ASG_AudioSD_CurrVol_maxVol, gAudioSD_currentVolume_maxVolume);
  putvalue(env_ASG_AudioSD_CurrVol_GenVol, gAudioSD_currentVolume_GenericVolume);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit0, gAudioSD_currentVolume_MuteState_Bit0);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit1, gAudioSD_currentVolume_MuteState_Bit1);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit2, gAudioSD_currentVolume_MuteState_Bit2);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit3, gAudioSD_currentVolume_MuteState_Bit3);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit4, gAudioSD_currentVolume_MuteState_Bit4);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit5, gAudioSD_currentVolume_MuteState_Bit5);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit6, gAudioSD_currentVolume_MuteState_Bit6);
  putvalue(env_ASG_AudioSD_CurrVol_MS_Bit7, gAudioSD_currentVolume_MuteState_Bit7);
  putvalue(env_ASG_AudioSD_CurrVol_Ext1, gAudioSD_currentVolume_Extension1);
  putvalue(env_ASG_AudioSD_CurrVol_Ext2, gAudioSD_currentVolume_Extension2);
  
  //0x17 SourceState
  gAudioSD_SourceState_StateInfo = 0;
  gAudioSD_SourceState_Scope = 0;
  gAudioSD_SourceState_Extension1 = 0;
  gAudioSD_SourceState_Extension2 = 0;
  gAudioSD_SourceState_Extension3 = 0;
  gAudioSD_SourceState_Extension4 = 0;
  putvalue(env_ASG_AudioSD_SrcSt_SateInfo, gAudioSD_SourceState_StateInfo);
  putvalue(env_ASG_AudioSD_SrcSt_Scope, gAudioSD_SourceState_Scope);
  putvalue(env_ASG_AudioSD_SrcSt_Ext1, gAudioSD_SourceState_Extension1);
  putvalue(env_ASG_AudioSD_SrcSt_Ext2, gAudioSD_SourceState_Extension2);
  putvalue(env_ASG_AudioSD_SrcSt_Ext3, gAudioSD_SourceState_Extension3);
  putvalue(env_ASG_AudioSD_SrcSt_Ext4, gAudioSD_SourceState_Extension4);
  
  //0x18 CurrentStationInfo
  gAudioSD_CSI_PI_Type = 0;
  gAudioSD_CSI_PIID = 0;
  gAudioSD_CSI_SI_Type = 0;
  gAudioSD_CSI_TI_Type = 0;
  gAudioSD_CSI_QI_Type = 0;
  gAudioSD_CSI_I5_Type = 0;
  gAudioSD_CSI_I6_Type = 0;
  gAudioSD_CSI_I7_Type = 0;
  gAudioSD_CSI_I8_Type = 0;
  gAudioSD_CSI_ChannelID = 0;
  gAudioSD_CSI_RadioCategory = 0;
  gAudioSD_CSI_Extension1 = 0;
  gAudioSD_CSI_StationInfoSwitches_Bit0 = TRUE;
  gAudioSD_CSI_StationInfoSwitches_Bit1 = 0;
  gAudioSD_CSI_StationInfoSwitches_Bit2 = 0;
  gAudioSD_CSI_StationInfoSwitches_Bit3 = 0;
  gAudioSD_CSI_StationInfoSwitches_Bit4 = 0;
  gAudioSD_CSI_StationInfoSwitches = gAudioSD_CSI_StationInfoSwitches_Bit0 + 
                                    (gAudioSD_CSI_StationInfoSwitches_Bit1 * 0x02) +
                                    (gAudioSD_CSI_StationInfoSwitches_Bit2 * 0x04) + 
                                    (gAudioSD_CSI_StationInfoSwitches_Bit3 * 0x08) + 
                                    (gAudioSD_CSI_StationInfoSwitches_Bit4 * 0x10);
  gAudioSD_CSI_StationProperties_Bit0 = 0;
  gAudioSD_CSI_StationProperties_Bit1 = 0;
  gAudioSD_CSI_StationProperties_Bit2 = 0;
  gAudioSD_CSI_StationProperties_Bit3 = 0;
  gAudioSD_CSI_StationProperties_Bit4 = 0;
  gAudioSD_CSI_StationProperties = gAudioSD_CSI_StationProperties_Bit0 + 
                                  (gAudioSD_CSI_StationProperties_Bit1 * 0x02) + 
                                  (gAudioSD_CSI_StationProperties_Bit2 * 0x04) + 
                                  (gAudioSD_CSI_StationProperties_Bit3 * 0x08) + 
                                  (gAudioSD_CSI_StationProperties_Bit4 * 0x10);
  for (i = 0; i < PRIMARYINFORMATION_TEXTLENGTH; i++)
    gAudioSD_CSI_PrimaryInformation[i] = 0;
  strncpy(gAudioSD_CSI_PrimaryInformation, "'CSI_PrimaryInformation'", elcount(gAudioSD_CSI_PrimaryInformation));

  for (i = 0; i < SECONDARYINFORMATION_TEXTLENGTH; i++)
    gAudioSD_CSI_SecondaryInformation[i] = 0;
  strncpy(gAudioSD_CSI_SecondaryInformation, "'CSI_SecondaryInformation'", elcount(gAudioSD_CSI_SecondaryInformation));

  for (i = 0; i < TERTIARYINFORMATION_TEXTLENGTH; i++)
    gAudioSD_CSI_TertiaryInformation[i] = 0;
  strncpy(gAudioSD_CSI_TertiaryInformation, "'CSI_TertiaryInformation'", elcount(gAudioSD_CSI_TertiaryInformation));

  for (i = 0; i < QUATERNARYINFORMATION_TEXTLENGTH; i++)
  {
    gAudioSD_CSI_QuarternaryInformation[i] = 0;
    gAudioSD_CSI_Information5[i] = 0;
    gAudioSD_CSI_Information6[i] = 0;
    gAudioSD_CSI_Information7[i] = 0;
    gAudioSD_CSI_Information8[i] = 0;
  }
  strncpy(gAudioSD_CSI_QuarternaryInformation, "'CSI_QuarternaryInformation'", elcount(gAudioSD_CSI_QuarternaryInformation));

  putvalue(env_ASG_AudioSD_CSI2_Info1, gAudioSD_CSI_PrimaryInformation);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy1, gAudioSD_CSI_PI_Type);
  putvalue(env_ASG_AudioSD_CSI2_InfoID1, gAudioSD_CSI_PIID);
  putvalue(env_ASG_AudioSD_CSI2_Info2, gAudioSD_CSI_SecondaryInformation);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy2, gAudioSD_CSI_SI_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info3, gAudioSD_CSI_TertiaryInformation);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy3, gAudioSD_CSI_TI_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info4, gAudioSD_CSI_QuarternaryInformation);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy4, gAudioSD_CSI_QI_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info5, gAudioSD_CSI_Information5);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy5, gAudioSD_CSI_I5_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info6, gAudioSD_CSI_Information6);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy6, gAudioSD_CSI_I6_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info7, gAudioSD_CSI_Information7);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy7, gAudioSD_CSI_I7_Type);
  putvalue(env_ASG_AudioSD_CSI2_Info8, gAudioSD_CSI_Information8);
  putvalue(env_ASG_AudioSD_CSI2_InfoTy8, gAudioSD_CSI_I8_Type);
  putvalue(env_ASG_AudioSD_CSI2_SIS_Bit0, gAudioSD_CSI_StationInfoSwitches_Bit0);
  putvalue(env_ASG_AudioSD_CSI2_SIS_Bit1, gAudioSD_CSI_StationInfoSwitches_Bit1);
  putvalue(env_ASG_AudioSD_CSI2_SIS_Bit2, gAudioSD_CSI_StationInfoSwitches_Bit2);
  putvalue(env_ASG_AudioSD_CSI2_SIS_Bit3, gAudioSD_CSI_StationInfoSwitches_Bit3);
  putvalue(env_ASG_AudioSD_CSI2_SIS_Bit4, gAudioSD_CSI_StationInfoSwitches_Bit4);
  putvalue(env_ASG_AudioSD_CSI2_SP_Bit0, gAudioSD_CSI_StationProperties_Bit0);
  putvalue(env_ASG_AudioSD_CSI2_SP_Bit1, gAudioSD_CSI_StationProperties_Bit1);
  putvalue(env_ASG_AudioSD_CSI2_SP_Bit2, gAudioSD_CSI_StationProperties_Bit2);
  putvalue(env_ASG_AudioSD_CSI2_SP_Bit3, gAudioSD_CSI_StationProperties_Bit3);
  putvalue(env_ASG_AudioSD_CSI2_SP_Bit4, gAudioSD_CSI_StationProperties_Bit4);
  putvalue(env_ASG_AudioSD_CSI2_SLS, gAudioSD_CSI_StationLinkingState);
  putvalue(env_ASG_AudioSD_CSI2_ChanID, gAudioSD_CSI_ChannelID);
  putvalue(env_ASG_AudioSD_CSI2_RadioCat, gAudioSD_CSI_RadioCategory);
  putvalue(env_ASG_AudioSD_CSI2_Ext1, gAudioSD_CSI_Extension1);  
  
  //0x19 CurrentStation_Handle
  gAudioSD_CSIhandle_FSGhandle = 0x10;
  gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;
  gAudioSD_CSIhandle_PresetListRef = 0;
  gAudioSD_CSIhandle_PresetListabsolutePos = 0;
  gAudioSD_CSIhandle_PictureRef = 0;
  gAudioSD_CSIhandle_Extension1 = 0;
  gAudioSD_CSIhandle_Extension2 = 0;
  gAudioSD_CSIhandle_Extension3 = 0;
  gAudioSD_CSIhandle_Extension4 = 0;
  gAudioSD_CSIhandle_Extension5 = 0;
  gAudioSD_CSIhandle_Extension6 = 0;
  gAudioSD_CSIhandle_Extension7 = 0;
  gAudioSD_CSIhandle_Extension8 = 0;
  gAudioSD_CSIhandle_Extension9 = 0;
  gAudioSD_CSIhandle_Extension10 = 0;
  gAudioSD_CSIhandle_Extension11 = 0;
  gAudioSD_CSIhandle_Extension12 = 0;
  gAudioSD_CSIhandle_Extension13 = 0;
  gAudioSD_CSIhandle_Extension14 = 0;
  gAudioSD_CSIhandle_Extension15 = 0;

  putvalue(env_ASG_AudioSD_CSH_FSGh, gAudioSD_CSIhandle_FSGhandle);
  putvalue(env_ASG_AudioSD_CSH_FSGh_abs, gAudioSD_CSIhandle_FSGhandle_absolutePos);
  putvalue(env_ASG_AudioSD_CSH_PL_Ref, gAudioSD_CSIhandle_PresetListRef);
  putvalue(env_ASG_AudioSD_CSH_PL_abs, gAudioSD_CSIhandle_PresetListabsolutePos);
  putvalue(env_ASG_AudioSD_CSH_PicRef, gAudioSD_CSIhandle_PictureRef);
  putvalue(env_ASG_AudioSD_CSH_Extension1, gAudioSD_CSIhandle_Extension1);
  putvalue(env_ASG_AudioSD_CSH_Extension2, gAudioSD_CSIhandle_Extension2);
  putvalue(env_ASG_AudioSD_CSH_Extension3, gAudioSD_CSIhandle_Extension3);
  putvalue(env_ASG_AudioSD_CSH_Extension4, gAudioSD_CSIhandle_Extension4);
  putvalue(env_ASG_AudioSD_CSH_Extension5, gAudioSD_CSIhandle_Extension5);
  putvalue(env_ASG_AudioSD_CSH_Extension6, gAudioSD_CSIhandle_Extension6);
  putvalue(env_ASG_AudioSD_CSH_Extension7, gAudioSD_CSIhandle_Extension7);
  putvalue(env_ASG_AudioSD_CSH_Extension8, gAudioSD_CSIhandle_Extension8);
  putvalue(env_ASG_AudioSD_CSH_Extension9, gAudioSD_CSIhandle_Extension9);
  putvalue(env_ASG_AudioSD_CSH_Extension10, gAudioSD_CSIhandle_Extension10);
  putvalue(env_ASG_AudioSD_CSH_Extension11, gAudioSD_CSIhandle_Extension11);
  putvalue(env_ASG_AudioSD_CSH_Extension12, gAudioSD_CSIhandle_Extension12);
  putvalue(env_ASG_AudioSD_CSH_Extension13, gAudioSD_CSIhandle_Extension13);
  putvalue(env_ASG_AudioSD_CSH_Extension14, gAudioSD_CSIhandle_Extension14);
  putvalue(env_ASG_AudioSD_CSH_Extension15, gAudioSD_CSIhandle_Extension15);
  
  //0x1A PlayPosition
  gAudioSD_PlayPosition_TimePosition = 0;
  gAudioSD_PlayPosition_TotalPlayTime = 0;
  gAudioSD_PlayPosition_Attributes_Bit0 = 0;
  gAudioSD_PlayPosition_Attributes = gAudioSD_PlayPosition_Attributes_Bit0;
  gAudioSD_PlayPosition_BufferLevel = 0;
  putvalue(env_ASG_AudioSD_PP_TimePos, gAudioSD_PlayPosition_TimePosition);
  putvalue(env_ASG_AudioSD_PP_TotalPlayTime, gAudioSD_PlayPosition_TotalPlayTime);
  putvalue(env_ASG_AudioSD_PP_Attr_Bit0, gAudioSD_PlayPosition_Attributes);
  putvalue(env_ASG_AudioSD_PP_BufferLevel, gAudioSD_PlayPosition_BufferLevel);
  
  //0x1B Station_Track_Switch
  gAudioSD_STS_Event = 0;
  gAudioSD_STS_Direction = 0;
  gAudioSD_STS_Extension1 = 0;
  gAudioSD_STS_Extension2 = 0;
  gAudioSD_STS_Extension3 = 0;
  gAudioSD_STS_Extension4 = 0;
  gAudioSD_STS_Extension5 = 0;
  putvalue(env_ASG_AudioSD_STS_Event, gAudioSD_STS_Event);
  putvalue(env_ASG_AudioSD_STS_Direction, gAudioSD_STS_Direction);
  putvalue(env_ASG_AudioSD_STS_Extension1, gAudioSD_STS_Extension1);
  putvalue(env_ASG_AudioSD_STS_Extension2, gAudioSD_STS_Extension2);
  putvalue(env_ASG_AudioSD_STS_Extension3, gAudioSD_STS_Extension3);
  putvalue(env_ASG_AudioSD_STS_Extension4, gAudioSD_STS_Extension4);
  putvalue(env_ASG_AudioSD_STS_Extension5, gAudioSD_STS_Extension5);
  
  //0x1C AnnouncementInfo
  gAudioSD_AnnouncementInfo_Type = ANNOUNCEMENT_TYPE_NO_MESSAGE;
  for (i = 0; i < ANNOUNCEMENT_STATIONNAME_TEXTLENGTH; i++)
      gAudioSD_AnnouncementInfo_StationName[i] = 0;
  strncpy(gAudioSD_AnnouncementInfo_StationName, "'Announcement_StationName'", elcount(gAudioSD_AnnouncementInfo_StationName));
  putvalue(env_ASG_AudioSD_AnInf_Type, 0);
  putvalue(env_ASG_AudioSD_AnInf_Name_s, gAudioSD_AnnouncementInfo_StationName);
  
  //0x1D AnnouncementEscape
  gAudioSD_AnnouncementEscape_AsgId = 0;
  gAudioSD_AnnouncementEscape_Extension1 = 0;
  gAudioSD_AnnouncementEscape_Reserve = 0;
  gAudioSD_AnnouncementEscape_Result = 0;
  putvalue(env_ASG_AudioSD_AnE_AsgID, gAudioSD_AnnouncementEscape_AsgId);
  putvalue(env_ASG_AudioSD_AnE_Ext1, gAudioSD_AnnouncementEscape_Extension1);
  putvalue(env_ASG_AudioSD_AnE_Res, gAudioSD_AnnouncementEscape_Result);
  
  //0x1E ReceptionList
  gReceptionList_ASGID = 0;
  gReceptionList_TAID = 0;
  gReceptionList_TotalNumListElements = 0;
  gReceptionList_ElementType = AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES;
  gReceptionList_ParentID = 0;
  gReceptionList_sum = 0;
  for (j = 0; j < AUDIO_RECEPTIONLIST_ENTRIES; j++)
  {
      gReceptionList_ListEntryValidInformation[j] = 0;
      gReceptionList_Pos[j] = 0;
      gReceptionList_Waveband[j] = 0;
      gReceptionList_Type[j] = 0;
      gReceptionList_Attributes1_Bit0[j] = 0;
      gReceptionList_Attributes1_Bit1[j] = 0;
      gReceptionList_Attributes1_Bit2[j] = 0;
      gReceptionList_Attributes1_Bit3[j] = 0;
      gReceptionList_Attributes1_Bit4[j] = 0;
      gReceptionList_Attributes1_Bit5[j] = 0;
      gReceptionList_Attributes1_Bit6[j] = 0;
      gReceptionList_Attributes1_Bit7[j] = 0;
      gReceptionList_Attributes1[j] = 0;
      gReceptionList_Attributes2_Bit0[j] = 0;
      gReceptionList_Attributes2_Bit1[j] = 0;
      gReceptionList_Attributes2_Bit2[j] = 0;
      gReceptionList_Attributes2_Bit3[j] = 0;
      gReceptionList_Attributes2[j] = 0;
      gReceptionList_PresetID[j] = 0;
      gReceptionList_FmRegCode[j] = 0;
      gReceptionList_Category[j] = 0;
      for (i = 0; i < AUDIO_RECEPTIONLIST_NAME_LENGTH; i++)
          gReceptionList_Name[j][i] = 0;
      for (i = 0; i < AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH; i++)
          gReceptionList_Frequency[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gReceptionList_CSV_filename[i] = 0;
  putvalue(env_ASG_AudioSD_RL_ASGID, gReceptionList_ASGID);
  putvalue(env_ASG_AudioSD_RL_TAID, gReceptionList_TAID);
  putvalue(env_ASG_AudioSD_RL_ParentID, gReceptionList_ParentID);
  putvalue(env_ASG_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements);
  putvalue(env_ASG_AudioSD_RL_ElementType, gReceptionList_ElementType);
  putvalue(env_ASG_AudioSD_RL_AH_shift, FALSE);
  putvalue(env_ASG_AudioSD_RL_AH_dir, FORWARD);
  putvalue(env_ASG_AudioSD_RL_AH_PosTrans, TRUE);
  putvalue(env_ASG_AudioSD_RL_AH_IS, TRUE);
  putvalue(env_ASG_AudioSD_RL_AH_RA, 0);
  putvalue(env_ASG_AudioSD_RL_AH_start, 0);
  putvalue(env_ASG_AudioSD_RL_AH_elements, 3);
  
  //0x1F RadioTV_PresetList
  gRadioTVPresetList_ASGID = 0;
  gRadioTVPresetList_TAID = 0;
  gRadioTVPresetList_TotalNumListElements = 0;
  gRadioTVPresetList_sum = 0;
  for (j = 0; j < AUDIO_RADIOTVPRESETLIST_ENTRIES; j++)
  {
      gRadioTVPresetList_ListEntryValidInformation[j] = 0;
      gRadioTVPresetList_Pos[j] = 0;
      gRadioTVPresetList_PresetIndex[j] = 0;
      gRadioTVPresetList_Waveband[j] = 0;
      gRadioTVPresetList_Attributes1_Bit0[j] = 0;
      gRadioTVPresetList_Attributes1_Bit1[j] = 0;
      gRadioTVPresetList_Attributes1_Bit2[j] = 0;
      gRadioTVPresetList_Attributes1_Bit3[j] = 0;
      gRadioTVPresetList_Attributes1_Bit4[j] = 0;
      gRadioTVPresetList_Attributes1_Bit5[j] = 0;
      gRadioTVPresetList_Attributes1_Bit6[j] = 0;
      gRadioTVPresetList_Attributes1_Bit7[j] = 0;
      gRadioTVPresetList_Attributes1[j] = 0;
      gRadioTVPresetList_Attributes2_Bit0[j] = 0;
      gRadioTVPresetList_Attributes2_Bit1[j] = 0;
      gRadioTVPresetList_Attributes2_Bit2[j] = 0;
      gRadioTVPresetList_Attributes2_Bit3[j] = 0;
      gRadioTVPresetList_Attributes2_Bit4[j] = 0;
      gRadioTVPresetList_Attributes2[j] = 0;
      gRadioTVPresetList_PicRef[j] = 0;
      for (i = 0; i < AUDIO_RADIOTVPRESETLIST_NAME_LENGTH; i++)
          gRadioTVPresetList_Name[j][i] = 0;
      for (i = 0; i < AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH; i++)
          gRadioTVPresetList_Frequency[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gRadioTVPresetList_CSV_filename[i] = 0;
  putvalue(env_ASG_AudioSD_RTPL_ASGID, gRadioTVPresetList_ASGID);
  putvalue(env_ASG_AudioSD_RTPL_TAID, gRadioTVPresetList_TAID);
  putvalue(env_ASG_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements);
  putvalue(env_ASG_AudioSD_RTPL_AH_shift, FALSE);
  putvalue(env_ASG_AudioSD_RTPL_AH_dir, FORWARD);
  putvalue(env_ASG_AudioSD_RTPL_AH_PosTrans, TRUE);
  putvalue(env_ASG_AudioSD_RTPL_AH_IS, TRUE);
  putvalue(env_ASG_AudioSD_RTPL_AH_RA, 0);
  putvalue(env_ASG_AudioSD_RTPL_AH_start, 0);
  putvalue(env_ASG_AudioSD_RTPL_AH_elements, 3);
  
  //0x20 ListSetup
  gAudioSD_ListSetup_PreferredList = 0;
  gAudioSD_ListSetup_ReceptionListType = 0;
  gAudioSD_ListSetup_Extension1 = 0;
  gAudioSD_ListSetup_Extension2 = 0;
  gAudioSD_ListSetup_Extension3 = 0;
  gAudioSD_ListSetup_Extension4 = 0;
  putvalue(env_ASG_AudioSD_LS_PrefList, gAudioSD_ListSetup_PreferredList);
  putvalue(env_ASG_AudioSD_LS_RLType, gAudioSD_ListSetup_ReceptionListType);
  putvalue(env_ASG_AudioSD_LS_Ext1, gAudioSD_ListSetup_Extension1);
  putvalue(env_ASG_AudioSD_LS_Ext2, gAudioSD_ListSetup_Extension2);
  putvalue(env_ASG_AudioSD_LS_Ext3, gAudioSD_ListSetup_Extension3);
  putvalue(env_ASG_AudioSD_LS_Ext4, gAudioSD_ListSetup_Extension4);
  
  //0x21 SourceList
  gSourceList_ASGID = 0;
  gSourceList_TAID = 0;
  gSourceList_TotalNumListElements = 0;
  gSourceList_sum = 0;
  for (j = 0; j < AUDIO_SOURCELIST_ENTRIES; j++)
  {
      gSourceList_ListEntryValidInformation[j] = 0;
      gSourceList_Pos[j] = 0;
      gSourceList_SourceType[j] = 0;
      gSourceList_InstanceID[j] = 0;
      gSourceList_PicRef[j] = 0;
      gSourceList_Attributes_Bit0[j] = 0;
      gSourceList_Attributes_Bit1[j] = 0;
      gSourceList_Attributes_Bit2[j] = 0;
      gSourceList_Attributes_Bit3[j] = 0;
      gSourceList_Attributes_Bit4[j] = 0;
      gSourceList_Attributes_Bit5[j] = 0;
      gSourceList_Attributes_Bit6[j] = 0;
      gSourceList_Attributes[j] = 0;
      for (i = 0; i < AUDIO_SOURCELIST_NAME_LENGTH; i++)
          gSourceList_Name[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gSourceList_CSV_filename[i] = 0;
  putvalue(env_ASG_AudioSD_SL_ASGID, gSourceList_ASGID);
  putvalue(env_ASG_AudioSD_SL_TAID, gSourceList_TAID);
  putvalue(env_ASG_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements);
  putvalue(env_ASG_AudioSD_SL_AH_shift, FALSE);
  putvalue(env_ASG_AudioSD_SL_AH_dir, FORWARD);
  putvalue(env_ASG_AudioSD_SL_AH_PosTrans, TRUE);
  putvalue(env_ASG_AudioSD_SL_AH_IS, TRUE);
  putvalue(env_ASG_AudioSD_SL_AH_RA, 0);
  putvalue(env_ASG_AudioSD_SL_AH_start, 0);
  putvalue(env_ASG_AudioSD_SL_AH_elements, 3);
  
  //0x22 DedicatedAudioControl
  gAudioSD_DAC_AsgId = 0;
  gAudioSD_DAC_Extension1 = 0;
  gAudioSD_DAC_status = FALSE;
  gAudioSD_DAC_FSGHandle = 0;
  gAudioSD_DAC_Result = AUDIO_DAC_SUCCESSFUL;
  gAudioSD_DAC_ControlType = AUDIO_DAC_SELECT_LIST_ENTRY;
  gAudioSD_DAC_ListType = AUDIO_DAC_NOLIST;
  putvalue(env_ASG_AudioSD_DAC_AsgID, gAudioSD_DAC_AsgId);
  putvalue(env_ASG_AudioSD_DAC_Ext1, gAudioSD_DAC_Extension1);
  putvalue(env_ASG_AudioSD_DAC_Res, gAudioSD_DAC_Result);
  putvalue(env_ASG_AudioSD_DAC_CT, gAudioSD_DAC_ControlType);
  putvalue(env_ASG_AudioSD_DAC_FSGHandle, gAudioSD_DAC_FSGHandle);
  putvalue(env_ASG_AudioSD_DAC_LT, gAudioSD_DAC_ListType);
  
  //0x23 SwitchSource
  gAudioSD_SwitchSource_status = FALSE;
  gAudioSD_SwitchSource_AsgId = 0;
  gAudioSD_SwitchSource_Extension1 = 0;
  gAudioSD_SwitchSource_ControlType = 0;
  gAudioSD_SwitchSource_Reference = 0;
  gAudioSD_SwitchSource_Reserve = 0;
  gAudioSD_SwitchSource_Result = AUDIO_SWITCHSOURCERESULT_SUCCESSFUL;
  putvalue(env_ASG_AudioSD_SwSource_AsgID, gAudioSD_SwitchSource_AsgId);
  putvalue(env_ASG_AudioSD_SwSource_Ext1, gAudioSD_SwitchSource_Extension1);
  putvalue(env_ASG_AudioSD_SwSource_CT, gAudioSD_SwitchSource_ControlType);
  putvalue(env_ASG_AudioSD_SwSource_Ref, gAudioSD_SwitchSource_Reference);
  putvalue(env_ASG_AudioSD_SwSource_Res, gAudioSD_SwitchSource_Result);
  
  //0x24 Browser_FolderLevel
  gAudioSD_MediaBrowser_FL_FolderLevel = 0;
  gAudioSD_MediaBrowser_FL_RefMediaBrowser = 0;
  gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos = 0;
  gAudioSD_MediaBrowser_FL_Extension1 = 0;
  putvalue(env_ASG_AudioSD_MeBrLevel_FL, gAudioSD_MediaBrowser_FL_FolderLevel);
  putvalue(env_ASG_AudioSD_MeBrLevel_Ref, gAudioSD_MediaBrowser_FL_RefMediaBrowser);
  putvalue(env_ASG_AudioSD_MeBrLevel_Ref_a, gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos);
  putvalue(env_ASG_AudioSD_MeBrLevel_Ext1, gAudioSD_MediaBrowser_FL_Extension1);
  
  //0x25 Browser
  gMediaBrowser_ASGID = 0;
  gMediaBrowser_TAID = 0;
  gMediaBrowser_TotalNumListElements = 0;
  gMediaBrowser_ActiveListPos = 0;
  gMediaBrowser_sum = 0;
  for (j = 0; j < AUDIO_MEDIABROWSER_ENTRIES; j++)
  {
      gMediaBrowser_ListEntryValidInformation[j] = 0;
      gMediaBrowser_Pos[j] = 0;
      gMediaBrowser_Type[j] = 0;
      gMediaBrowser_FileState_Bit0[j] = 0;
      gMediaBrowser_FileState_Bit1[j] = 0;
      gMediaBrowser_FileState_Bit2[j] = 0;
      gMediaBrowser_FileState_Bit3[j] = 0;
      gMediaBrowser_FileState_Bit4[j] = 0;
      gMediaBrowser_FileState_Bit5[j] = 0;
      gMediaBrowser_FileState_Bit6[j] = 0;
      gMediaBrowser_FileState[j] = 0;
      gMediaBrowser_Waveband[j] = 0;
      gMediaBrowser_RadioCategory[j] = 0;
      gMediaBrowser_FmRegCode[j] = 0;
      gMediaBrowser_PresetID[j] = 0;
      gMediaBrowser_PicRef[j] = 0;
      gMediaBrowser_Attributes1_Bit0[j] = 0;
      gMediaBrowser_Attributes1_Bit1[j] = 0;
      gMediaBrowser_Attributes1_Bit2[j] = 0;
      gMediaBrowser_Attributes1_Bit3[j] = 0;
      gMediaBrowser_Attributes1_Bit4[j] = 0;
      gMediaBrowser_Attributes1_Bit5[j] = 0;
      gMediaBrowser_Attributes1_Bit6[j] = 0;
      gMediaBrowser_Attributes1_Bit7[j] = 0;
      gMediaBrowser_Attributes1[j] = 0;
      gMediaBrowser_Attributes2_Bit0[j] = 0;
      gMediaBrowser_Attributes2_Bit1[j] = 0;
      gMediaBrowser_Attributes2[j] = 0;
      for (i = 0; i < AUDIO_MEDIABROWSER_NAME_LENGTH; i++)
          gMediaBrowser_Name[j][i] = 0;
      for (i = 0; i < AUDIO_MEDIABROWSER_FREQUENCY_LENGTH; i++)
          gMediaBrowser_Frequency[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gMediaBrowser_CSV_filename[i] = 0;
  putvalue(env_ASG_AudioSD_MB_ASGID, gMediaBrowser_ASGID);
  putvalue(env_ASG_AudioSD_MB_TAID, gMediaBrowser_TAID);
  putvalue(env_ASG_AudioSD_MB_ActiveListPos, gMediaBrowser_ActiveListPos);
  putvalue(env_ASG_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements);
  putvalue(env_ASG_AudioSD_MB_AH_shift, FALSE);
  putvalue(env_ASG_AudioSD_MB_AH_dir, FORWARD);
  putvalue(env_ASG_AudioSD_MB_AH_PosTrans, TRUE);
  putvalue(env_ASG_AudioSD_MB_AH_IS, TRUE);
  putvalue(env_ASG_AudioSD_MB_AH_RA, 0);
  putvalue(env_ASG_AudioSD_MB_AH_start, 0);
  putvalue(env_ASG_AudioSD_MB_AH_elements, 3);
  
  //0x26 BrowserPath
  gAudioSD_MediaPath_FolderType = 0;
  for (i = 0; i < MEDIAPATH_PATH_TEXTLENGTH; i++)
      gAudioSD_MediaPath_Path[i] = 0;
  strncpy(gAudioSD_MediaPath_Path, "'MediaPath'", elcount(gAudioSD_MediaPath_Path));
  putvalue(env_ASG_AudioSD_MePath_Type, gAudioSD_MediaPath_FolderType);
  putvalue(env_ASG_AudioSD_MePath_Path_s, gAudioSD_MediaPath_Path);
  
  //0x27 BrowserControl
  gAudioSD_MediaBrowserControl_status = FALSE;
  gAudioSD_MediaBrowserControl_AsgId = 0;
  gAudioSD_MediaBrowserControl_Extension1 = 0;
  gAudioSD_MediaBrowserControl_Control = 0;
  gAudioSD_MediaBrowserControl_Reference = 0;
  gAudioSD_MediaBrowserControl_Reserve = 0;
  gAudioSD_MediaBrowserControl_Result = AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL;
  putvalue(env_ASG_AudioSD_MBrC_AsgID, gAudioSD_MediaBrowserControl_AsgId);
  putvalue(env_ASG_AudioSD_MBrC_Ext1, gAudioSD_MediaBrowserControl_Extension1);
  putvalue(env_ASG_AudioSD_MBrC_Ref, gAudioSD_MediaBrowserControl_Reference);
  putvalue(env_ASG_AudioSD_MBrC_Control, gAudioSD_MediaBrowserControl_Control);
  putvalue(env_ASG_AudioSD_MBrC_Res, gAudioSD_MediaBrowserControl_Result);
  
  //0x28 Picture
  gPicture_ASGID = 0;
  gPicture_TAID = 0;
  gPicture_TotalNumListElements = 0;
  gPicture_sum = 0;
  for (j = 0; j < AUDIO_PICTURE_ENTRIES; j++)
  {
      gPicture_ListEntryValidInformation[j] = 0;
      gPicture_Pos[j] = 0;
      gPicture_Type[j] = 0;
      gPicture_TcpPort[j] = 0;
      for (i = 0; i < AUDIO_PICTURE_IPADDRESS_LENGTH; i++)
          gPicture_IpAddress[j][i] = 0;
      for (i = 0; i < AUDIO_PICTURE_URI_LENGTH; i++)
          gPicture_Uri[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gPicture_CSV_filename[i] = 0;
  putvalue(env_ASG_AudioSD_Pic_ASGID, gPicture_ASGID);
  putvalue(env_ASG_AudioSD_Pic_TAID, gPicture_TAID);
  putvalue(env_ASG_AudioSD_Pic_TotalNumLE, gPicture_TotalNumListElements);
  putvalue(env_ASG_AudioSD_Pic_AH_shift, FALSE);
  putvalue(env_ASG_AudioSD_Pic_AH_dir, FORWARD);
  putvalue(env_ASG_AudioSD_Pic_AH_PosTrans, TRUE);
  putvalue(env_ASG_AudioSD_Pic_AH_IS, TRUE);
  putvalue(env_ASG_AudioSD_Pic_AH_RA, 0);
  putvalue(env_ASG_AudioSD_Pic_AH_start, 0);
  putvalue(env_ASG_AudioSD_Pic_AH_elements, 3);
}

//*************************************************************************
//*****************BAP helper functions************************************
//*************************************************************************
void set_status_requestbuffer (dword Request_array [], int length, byte BAPDataType)
{
  int bufferline = 0, i;

  bufferline = get_requestbuffer_line();
  for(i = 0; i < length; i++)
  	gBAP_Request[bufferline][i] = Request_array[i];
  gBAP_Requestbuffer_status[bufferline] = length;
  gBAP_Requestbuffer_BAPDataTyp[bufferline] = BAPDataType;
}

byte get_requestbuffer_line()	//function to reserve memory in request-ring-buffer
{
  int line;

  //init lokal variables
  line=0;
  //********************	
  line=gwrite_requestbuffer_line;							//next free element in ring-buffer
  if(gwrite_requestbuffer_line<(REQUESTBUFFER_LINES-1))	//last element of ring-buffer is not reached
  	gwrite_requestbuffer_line++;
  else													//last element of ring-buffer is reached
  	gwrite_requestbuffer_line=0;
  return (line);											//return position of free ring-buffer element
}

//*************************************************************************
//*****************Helper functions****************************************
//*************************************************************************



//*************************************************************************
//*****************On BAP Messages****************************************
//*************************************************************************
on message BAP_Audio_FSG_01
{
  int i, error;
  byte RX_Data[8];		//received CAN-DATA
  dword RX_Header[3];		//received CAN-Header

  RX_Header[0]=this.CAN; 
  RX_Header[1]=this.ID; 
  RX_Header[2]=this.DLC; // received length
  // extract CAN data    																	
  for (i=0; i<this.DLC; i++) 														
    RX_Data[i]=this.byte(i);		       
  //send recieved CAN-data with CAN-header to BAP-DLL
  error =Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
  if(error !=0)
    write("ASG-AudioSD: BAP_CAN_SetRxData: %d", error);   
}

on message BAP_Audio_FSG_02
{
  int i, error;
  byte RX_Data[8];		//received CAN-DATA
  dword RX_Header[3];		//received CAN-Header

  RX_Header[0]=this.CAN; 
  RX_Header[1]=this.ID; 
  RX_Header[2]=this.DLC; // received length
  // extract CAN data    																	
  for (i=0; i<this.DLC; i++) 														
    RX_Data[i]=this.byte(i);		         
  //send recieved CAN-data with CAN-header to BAP-DLL
  error =Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
  if(error !=0)
    write("ASG-AudioSD: BAP_CAN_SetRxData: %d", error);      
}

void OnUdpReceiveFrom( dword socket, long result, byte ipv6Address[], dword port, byte buffer[], dword size)
{
  int i;
  dword Header[13];
  byte Ipv6_temp[16];
  const long  INVALID_SOCKET = ~0;

  if(socket != INVALID_SOCKET)
  {
    if(result == 0)
    {
      Header[0] = 4; // /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
      Header[1] = 2; // channel
      Header[2] = size;
     for(i=0;i<gUdpSocketCnt;i++)
      {
        if(gUdpSockets[i].Handle == socket)
        {
          Header[3] = gUdpSockets[i].Id;
          for(i=0; i<8; i++)
          {
            Header[i+4] = ((dword)ipv6Address[2*i]) << 8;
            Header[i+4] |= ((dword)ipv6Address[2*i+1]) ;
          }
          Header[12] = port;
          BAP180_SetRxData(NODE_INDEX, Header, buffer);
          break;
        }
      }
    }
  }
}

//*************************************************************************
//*****************Fct-IDs Events******************************************
//*************************************************************************

//*****************BapConfig***********************************************
on envVar env_ASG_AudioSD_BAPcfg_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    BAP_Config_Request(DataGet_REQ);
}

void BAP_Config_Indication(dword Indication_array [], int datalength)
{ 
  switch (gBAP_Indication[2]) // indication
	{
		case Reset_IND:         
      init_variables();				//reset all variables and states				
      gBAP_AudioSD_available =TRUE;   //FSG available
      if(getvalue(env_ASG_AudioSD_BAPstart_GetAll))
      {
        FunctionList_Request(DataGet_REQ);
        FunctionList_flag =TRUE;
      }                                               
		break;
    case Data_IND:  
			gBAP_AudioSD_available =TRUE;   //FSG available             
      if(getvalue(env_ASG_AudioSD_BAPstart_GetAll))                       
      {
        FunctionList_Request(DataGet_REQ);
        FunctionList_flag =TRUE;
      }                
		break;
    case Error_IND:			            	            			            
      if(Indication_array[3]<0x20 && Indication_array[3] !=0)			//BCL-error
        writelineEx(gError_Trace, 0, "ASG-AudioSD BAP_Config_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
      else if(Indication_array[3]<0x30)			//BPL-error
        writelineEx(gError_Trace, 0, "ASG-AudioSD BAP_Config_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
      else if(Indication_array[3]<0x40)			//BAL-error
        writelineEx(gError_Trace, 0, "ASG-AudioSD BAP_Config_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
      else
        writelineEx(gError_Trace, 0, "ASG-AudioSD BAP_Config_Indication: Application-Error: 0x%x", Indication_array[3]);			            	
		break;
    default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD BAP_Config_Indication: unknown indication 0x%x", gBAP_Indication[2]);
		break;
	}
}

void BAP_Config_Request(byte request)
{   
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_BAP_Config;	//Fct.-ID
	requestarray[2] =request;               //request type   
  switch (request)
	{
	  case DataGet_REQ: 										
      set_status_requestbuffer (requestarray, 3, Bap_Void);   		 
    break;
    default:
		  writelineEx(gError_Trace, 0, "ASG-AudioSD BAP_Config_Request: unknown request %d", request);
	  break;
  }
}

//*************************************************************************
//*****************GetAll**************************************************
on envVar env_ASG_AudioSD_GetAll
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    GetAll_Request(DataGet_REQ);
}

void GetAll_Indication(dword Indication_array [], int datalength)
{
  switch (gBAP_Indication[2])
  {
    case Data_IND: 
      FunctionList_Request(DataGet_REQ);
      HeartBeat_Request(DataGet_REQ);
      FSG_Control_Request(DataGet_REQ);
      FSG_Setup_Request(DataGet_REQ);
      FSG_OperationState_Request(DataGet_REQ);
      ASGCapabilities_Request(DataGet_REQ);
      InfoStates_Request(DataGet_REQ);
      SDSState_Request(DataGet_REQ);
      GeneralInfoSwitches_Request(DataGet_REQ);
      ActiveSource_Request(DataGet_REQ);
      ActiveSourceName_Request(DataGet_REQ);
      CurrentVolume_Request(DataGet_REQ);
      SourceState_Request(DataGet_REQ);
      CurrentStationInfo_Request(DataGet_REQ);
      CurrentStationHandle_Request(DataGet_REQ);
      PlayPosition_Request(DataGet_REQ);
      Station_Track_Switch_Request(DataGet_REQ);
      AnnouncementInfo_Request(DataGet_REQ);  
      ListSetup_Request(DataGet_REQ);  
      Browser_FolderLevel_Request(DataGet_REQ);    
      BrowserPath_Request(DataGet_REQ); 
      settimer (ASGCapa_startTimer,30);
    break;
    case Error_IND:						
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD GetAll_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD GetAll_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD GetAll_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD GetAll_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			write("ASG-AudioSD GetAll_Indication: unknown indication 0x%d", gBAP_Indication[0]);
		break;
  }
}

void GetAll_Request(byte request)
{
  int i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables.
  for(i=0;i<BAP_BUFFER_SIZE;i++)
  	requestarray [i]=0;
  // Handle request
  requestarray[0]=LSG_AudioSD;	//LSG-ID
  requestarray[1]=FctID_GetAll;	//Fct.-ID
  requestarray[2]=request;        //request
  switch (request)
  {
  	case DataGet_REQ:					
  		set_status_requestbuffer (requestarray, 3, Bap_Void);	//send GetAll.Get
    break;
    default:
  		writelineEx(gError_Trace, 0,"ASG-AudioSD GetAll_Request: unknown request %d", request);
  	break;
  }
}

on timer ASGCapa_startTimer
{
    ASGCapabilities_Request(DataSetGet_REQ);
}

//*************************************************************************
//*****************FunctionList********************************************
on envVar env_ASG_AudioSD_FctList_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    FunctionList_Request(DataGet_REQ);
}

void FunctionList_Indication(dword Indication_array [], int datalength)
{
  int i =0, j =0;
  switch (gBAP_Indication[2]) // indication
  {
  	case Data_IND: 
      j=0;
      for(i=3;i<11;i++)
      {   
        gFunctionList_FctList[j] =Indication_array [i];
        j++;
      }    
      //Panel
      //Byte_0
      if(gFunctionList_FctList[0] &0x40)
          putvalue(env_ASG_AudioSD_FctList_Bit01,TRUE); 
      else
          putvalue(env_ASG_AudioSD_FctList_Bit01,FALSE);

      if(gFunctionList_FctList[0] &0x20)
          putvalue(env_ASG_AudioSD_FctList_Bit02,TRUE);
      else
          putvalue(env_ASG_AudioSD_FctList_Bit02,FALSE);

      if(gFunctionList_FctList[0] &0x10)
          putvalue(env_ASG_AudioSD_FctList_Bit03,TRUE);
      else
          putvalue(env_ASG_AudioSD_FctList_Bit03,FALSE);

      if(gFunctionList_FctList[0] &0x08)
          putvalue(env_ASG_AudioSD_FctList_Bit04,TRUE);
      else
          putvalue(env_ASG_AudioSD_FctList_Bit04,FALSE);

      //Byte_1
      if(gFunctionList_FctList[1] &0x04)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit13,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x0D_FSG-Control", gRGB_white);
          enableControl("ASG_AudioSD_Properties_1", "ASG_0x0D_FSG-Control_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit13,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x0D_FSG-Control", gRGB_red);
          enableControl("ASG_AudioSD_Properties_1", "ASG_0x0D_FSG-Control_PanelElement", FALSE);
      }
      if(gFunctionList_FctList[1] &0x02)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit14,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x0E_FSG-Setup", gRGB_white);
          enableControl("ASG_AudioSD_Properties_1", "ASG_0x0E_FSG-Setup_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit14,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x0E_FSG-Setup", gRGB_red);
          enableControl("ASG_AudioSD_Properties_1", "ASG_0x0E_FSG-Setup_PanelElement", FALSE);
      }
      if(gFunctionList_FctList[1] &0x01)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit15,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x0F_FSG-OperationState", gRGB_white);
          enableControl("ASG_AudioSD_Properties_1", "ASG_0x0F_FSG-OperationState_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit15,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x0F_FSG-OperationState", gRGB_red);
          enableControl("ASG_AudioSD_Properties_1", "ASG_0x0F_FSG-OperationState_PanelElement", FALSE);
      }
      //Byte_2
      if(gFunctionList_FctList[2] &0x80)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit16,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x10_activeSource", gRGB_white);
          enableControl("ASG_AudioSD_Properties_2", "ASG_0x10_activeSource_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit16,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x10_activeSource", gRGB_red);
          enableControl("ASG_AudioSD_Properties_2", "ASG_0x10_activeSource_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[2] &0x40)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit17,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x11_activeSourceName", gRGB_white);
          enableControl("ASG_AudioSD_Properties_2", "ASG_0x11_activeSourceName_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit17,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x11_activeSourceName", gRGB_red);
          enableControl("ASG_AudioSD_Properties_2", "ASG_0x11_activeSourceName_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[2] &0x20)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit18,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x12_currentVolume", gRGB_white);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x12_currentVolume_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit18,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x12_currentVolume", gRGB_red);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x12_currentVolume_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[2] &0x10)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit19,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x13_Mute", gRGB_white);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x13_Mute_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit19,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x13_Mute", gRGB_red);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x13_Mute_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[2] &0x08)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit20,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x14_SourceState", gRGB_white);
          enableControl("ASG_AudioSD_Properties_2", "ASG_0x14_SourceState_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit20,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x14_SourceState", gRGB_red);
          enableControl("ASG_AudioSD_Properties_2", "ASG_0x14_SourceState_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[2] &0x04)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit21,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x15_currentStationInfo", gRGB_white);
          enableControl("ASG_AudioSD_Properties_2", "ASG_0x15_currentStationInfo_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit21,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x15_currentStationInfo", gRGB_red);
          enableControl("ASG_AudioSD_Properties_2", "ASG_0x15_currentStationInfo_PanelElement", FALSE);
      }
      
      if(gFunctionList_FctList[2] &0x02)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit22,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x16_currentStation_Handle", gRGB_white);
          enableControl("ASG_AudioSD_Properties_2", "ASG_0x16_currentStation_Handle_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit22,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_2", "ASG_0x16_currentStation_Handle", gRGB_red);
          enableControl("ASG_AudioSD_Properties_2", "ASG_0x16_currentStation_Handle_PanelElement", FALSE);
      }
      
      if(gFunctionList_FctList[2] &0x01)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit23,TRUE);
          SetControlBackColor("ASG_AudioSD_0x17 - ReceptionList_(array)", "ASG_0x17_ReceptionList", gRGB_white);
          enableControl("ASG_AudioSD_0x17 - ReceptionList_(array)", "ASG_0x17_ReceptionList_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit23,FALSE);
          SetControlBackColor("ASG_AudioSD_0x17 - ReceptionList_(array)", "ASG_0x17_ReceptionList", gRGB_red);
          enableControl("ASG_AudioSD_0x17 - ReceptionList_(array)", "ASG_0x17_ReceptionList_PanelElement", FALSE);
      }

      //Byte_3
      if(gFunctionList_FctList[3] &0x80)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit24,TRUE);
          SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x18_dedicatedAudioControl", gRGB_white);
          enableControl("ASG_AudioSD_Methods", "ASG_0x18_dedicatedAudioControl_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit24,FALSE);
          SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x18_dedicatedAudioControl", gRGB_red);
          enableControl("ASG_AudioSD_Methods", "ASG_0x18_dedicatedAudioControl_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[3] &0x40)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit25,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x19_generalInfoSwitches", gRGB_white);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x19_generalInfoSwitches_PanelElement", TRUE);    
      }

      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit25,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x19_generalInfoSwitches", gRGB_red);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x19_generalInfoSwitches_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[3] &0x20)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit26,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1A_TpMemoInfo", gRGB_white);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x1A_TpMemoInfo_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit26,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1A_TpMemoInfo", gRGB_red);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x1A_TpMemoInfo_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[3] &0x10)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit27,TRUE);
          SetControlBackColor("ASG_AudioSD_0x1B - TpMemoList_(array)", "ASG_0x1B_TpMemoList", gRGB_white);
          enableControl("ASG_AudioSD_0x1B - TpMemoList_(array)", "ASG_0x1B_TpMemoList_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit27,FALSE);
          SetControlBackColor("ASG_AudioSD_0x1B - TpMemoList_(array)", "ASG_0x1B_TpMemoList", gRGB_red);
          enableControl("ASG_AudioSD_0x1B - TpMemoList_(array)", "ASG_0x1B_TpMemoList_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[3] &0x08)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit28,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1C_AnnouncementInfo", gRGB_white);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x1C_AnnouncementInfo_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit28,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1C_AnnouncementInfo", gRGB_red);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x1C_AnnouncementInfo_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[3] &0x04)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit29,TRUE);
          SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x1D_AnnouncementEscape", gRGB_white);
          enableControl("ASG_AudioSD_Methods", "ASG_0x1D_AnnouncementEscape_PanelElement", TRUE);
      }
      else
      {    
          putvalue(env_ASG_AudioSD_FctList_Bit29,FALSE);
          SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x1D_AnnouncementEscape", gRGB_red);
          enableControl("ASG_AudioSD_Methods", "ASG_0x1D_AnnouncementEscape_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[3] &0x02)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit30,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x1E_InfoStates", gRGB_white);
          enableControl("ASG_AudioSD_Properties_1", "ASG_0x1E_InfoStates_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit30,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_1", "ASG_0x1E_InfoStates", gRGB_red);
          enableControl("ASG_AudioSD_Properties_1", "ASG_0x1E_InfoStates_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[3] &0x01)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit31,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1F_ReceptionListType", gRGB_white);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x1F_ReceptionListType_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit31,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x1F_ReceptionListType", gRGB_red);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x1F_ReceptionListType_PanelElement", FALSE);
      }

      //Byte_4
      if(gFunctionList_FctList[4] &0x80)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit32,TRUE);
          SetControlBackColor("ASG_AudioSD_0x20 - SourceList_(array)", "ASG_0x20_SourceList", gRGB_white);
          enableControl("ASG_AudioSD_0x20 - SourceList_(array)", "ASG_0x20_SourceList_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit32,FALSE);
          SetControlBackColor("ASG_AudioSD_0x20 - SourceList_(array)", "ASG_0x20_SourceList", gRGB_red);
          enableControl("ASG_AudioSD_0x20 - SourceList_(array)", "ASG_0x20_SourceList_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[4] &0x40)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit33,TRUE);
          SetControlBackColor("ASG_AudioSD_0x21 - RadioTV_PresetList_(array)", "ASG_0x21_RadioTV_PresetList", gRGB_white);
          enableControl("ASG_AudioSD_0x21 - RadioTV_PresetList_(array)", "ASG_0x21_RadioTV_PresetList_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit33,FALSE);
          SetControlBackColor("ASG_AudioSD_0x21 - RadioTV_PresetList_(array)", "ASG_0x21_RadioTV_PresetList", gRGB_red);
          enableControl("ASG_AudioSD_0x21 - RadioTV_PresetList_(array)", "ASG_0x21_RadioTV_PresetList_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[4] &0x20)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit34,TRUE);
          SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x22_SwitchSource", gRGB_white);
          enableControl("ASG_AudioSD_Methods", "ASG_0x22_SwitchSource_PanelElement", TRUE);
      }

      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit34,FALSE);
          SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x22_SwitchSource", gRGB_red);
          enableControl("ASG_AudioSD_Methods", "ASG_0x22_SwitchSource_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[4] &0x10)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit35,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x23_MediaBrowser_FolderLevel", gRGB_white);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x23_MediaBrowser_FolderLevel_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit35,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x23_MediaBrowser_FolderLevel", gRGB_red);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x23_MediaBrowser_FolderLevel_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[4] &0x08)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit36,TRUE);
          SetControlBackColor("ASG_AudioSD_0x24 - MediaBrowser_(array)", "ASG_0x24_MediaBrowser", gRGB_white);
          enableControl("ASG_AudioSD_0x24 - MediaBrowser_(array)", "ASG_0x24_MediaBrowser_PanelElement", TRUE);
      }

      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit36,FALSE);
          SetControlBackColor("ASG_AudioSD_0x24 - MediaBrowser_(array)", "ASG_0x24_MediaBrowser", gRGB_red);
          enableControl("ASG_AudioSD_0x24 - MediaBrowser_(array)", "ASG_0x24_MediaBrowser_PanelElement", FALSE);
      }
      
      if(gFunctionList_FctList[4] &0x04)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit37,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x25_MediaPath", gRGB_white);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x25_MediaPath_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit37,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x25_MediaPath", gRGB_red);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x25_MediaPath_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[4] &0x02)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit38,TRUE);
          SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x26_MediaBrowserControl", gRGB_white);
          enableControl("ASG_AudioSD_Methods", "ASG_0x26_MediaBrowserControl_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit38,FALSE);
          SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x26_MediaBrowserControl", gRGB_red);
          enableControl("ASG_AudioSD_Methods", "ASG_0x26_MediaBrowserControl_PanelElement", FALSE);
      }

      if(gFunctionList_FctList[4] &0x01)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit39,TRUE);
          SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x27_MediaFileInfo", gRGB_white);
          enableControl("ASG_AudioSD_Methods", "ASG_0x27_MediaFileInfo_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit39,FALSE);
          SetControlBackColor("ASG_AudioSD_Methods", "ASG_0x27_MediaFileInfo", gRGB_red);
          enableControl("ASG_AudioSD_Methods", "ASG_0x27_MediaFileInfo_PanelElement", FALSE);
      }

      //Byte_5
      if(gFunctionList_FctList[5] &0x80)
      {
          putvalue(env_ASG_AudioSD_FctList_Bit40,TRUE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x28_PreferredList", gRGB_white);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x28_PreferredList_PanelElement", TRUE);
      }
      else
      {
          putvalue(env_ASG_AudioSD_FctList_Bit40,FALSE);
          SetControlBackColor("ASG_AudioSD_Properties_3", "ASG_0x28_PreferredList", gRGB_red);
          enableControl("ASG_AudioSD_Properties_3", "ASG_0x28_PreferredList_PanelElement", FALSE);
      }
      
      if(FunctionList_flag)
      {
          GetAll_Request(DataGet_REQ);	//send GetAll.Get
          FunctionList_flag =FALSE;
      }                            
  	break;
    case Error_IND:
      if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
        writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
      else if(Indication_array[3]<0x30)			//BPL-error
        writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
      else if(Indication_array[3]<0x40)			//BAL-error
        writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
      else
        writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Indication: Application-Error: 0x%x", Indication_array[3]);
  	break;
  	default:
  		writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Indication: unknown indication 0x%d", gBAP_Indication[2]);
  	break;
  }
}

void FunctionList_Request(byte request)
{   
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_FunctionList;	//Fct.-ID
	requestarray[2] =request;               //request type   
  switch (request)
	{
	  case DataGet_REQ: 										
      set_status_requestbuffer (requestarray, 3, Bap_Void);   		 
    break;
    default:
		  writelineEx(gError_Trace, 0, "ASG-AudioSD FunctionList_Request: unknown request %d", request);
	  break;
  }
}

//*************************************************************************
//*****************HeartBeat***********************************************
on envVar env_ASG_AudioSD_HeartBeat_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    HeartBeat_Request(DataGet_REQ);
}

void HeartBeat_Indication(dword Indication_array [], int datalength)
{
  switch (gBAP_Indication[2]) // indication
	{
		case Data_IND:                   
		break;
		case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Indication: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

void HeartBeat_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0]=LSG_AudioSD;	        //LSG-ID
	requestarray[1]=FctID_HeartBeat;	    //Fct.-ID
	requestarray[2]=request;              //request type
	switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD HeartBeat_Request: unknown request %d", request);
		break;
	}
}

//*************************************************************************
//*****************FSG_Control*********************************************
on envVar env_ASG_AudioSD_FSGCtrl_get
{
	if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
		FSG_Control_Request(DataGet_REQ);
}

void FSG_Control_Indication (dword Indication_array[], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
			gAudioSD_FSGControl_Extension1  =Indication_array[3];
      gAudioSD_FSGControl_Extension2  =Indication_array[4];
      gAudioSD_FSGControl_Extension3  =Indication_array[5];
      gAudioSD_FSGControl_Extension4  =Indication_array[6];
      gAudioSD_FSGControl_Extension5  =Indication_array[7];
      gAudioSD_FSGControl_Extension6  =Indication_array[8];
      putvalue(env_ASG_AudioSD_FSGCtrl_Ext1, gAudioSD_FSGControl_Extension1);
      putvalue(env_ASG_AudioSD_FSGCtrl_Ext2, gAudioSD_FSGControl_Extension2);
      putvalue(env_ASG_AudioSD_FSGCtrl_Ext3, gAudioSD_FSGControl_Extension3);
      putvalue(env_ASG_AudioSD_FSGCtrl_Ext4, gAudioSD_FSGControl_Extension4);
      putvalue(env_ASG_AudioSD_FSGCtrl_Ext5, gAudioSD_FSGControl_Extension5);
      putvalue(env_ASG_AudioSD_FSGCtrl_Ext6, gAudioSD_FSGControl_Extension6);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Control_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Control_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Control_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Control_Indication: Application-Error: 0x%x", Indication_array[3]);
  	break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-AudioSD FSG_Control_Indication: unknown indication %x", gBAP_Indication[2]);
  	break;
	}
}

void FSG_Control_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_FSG_Setup;	        //Fct.-ID
	requestarray[2] =request;                   //request type
  switch(request)
	{
		case DataGet_REQ:
	    requestarray[3] =Bap_Void;                   //request type
			set_status_requestbuffer (requestarray, 4, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Control_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************FSG_Setup***********************************************
on envVar env_ASG_AudioSD_FSGSetup_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    FSG_Setup_Request(DataGet_REQ);
}

void FSG_Setup_Indication (dword Indication_array[], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
			gAudioSD_FSGSetup_FunctionSupport     =Indication_array[3];
      gAudioSD_FSGSetup_FunctionSupport_Bit0   =gAudioSD_FSGSetup_FunctionSupport &0x01;        //Bit '0'                       
      gAudioSD_FSGSetup_FunctionSupport_Bit1   =(gAudioSD_FSGSetup_FunctionSupport &0x02)/0x02; //Bit '1' 
      gAudioSD_FSGSetup_FunctionProtection  =Indication_array[4];
      gAudioSD_FSGSetup_FunctionProtection_Bit0=gAudioSD_FSGSetup_FunctionProtection &0x01;     //Bit '0' 
      gAudioSD_FSGSetup_WebAppState         =(Indication_array[5]&0xF0)/0x10;
      gAudioSD_FSGSetup_WebAppState_Bit0       =gAudioSD_FSGSetup_WebAppState &0x01;            //Bit '0'
      gAudioSD_FSGSetup_Extension1          =Indication_array[5]&0x0F;
      gAudioSD_FSGSetup_Extension2          =Indication_array[6];
      gAudioSD_FSGSetup_Extension3          =Indication_array[7];
      gAudioSD_FSGSetup_Extension4          =Indication_array[8];
      gAudioSD_FSGSetup_WebAppState_Bit0       =gAudioSD_FSGSetup_WebAppState &0x01;            //Bit '0'
      putvalue(env_ASG_AudioSD_FSGSetup_FS_Bit0, gAudioSD_FSGSetup_FunctionSupport_Bit0);
      putvalue(env_ASG_AudioSD_FSGSetup_FS_Bit1, gAudioSD_FSGSetup_FunctionSupport_Bit1);
      putvalue(env_ASG_AudioSD_FSGSetup_FP_Bit0, gAudioSD_FSGSetup_FunctionProtection_Bit0);
      putvalue(env_ASG_AudioSD_FSGSetup_WASBit0, gAudioSD_FSGSetup_WebAppState_Bit0);
      putvalue(env_ASG_AudioSD_FSGSetup_Ext1, gAudioSD_FSGSetup_Extension1);
      putvalue(env_ASG_AudioSD_FSGSetup_Ext2, gAudioSD_FSGSetup_Extension2);
      putvalue(env_ASG_AudioSD_FSGSetup_Ext3, gAudioSD_FSGSetup_Extension3);
      putvalue(env_ASG_AudioSD_FSGSetup_Ext4, gAudioSD_FSGSetup_Extension4);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Setup_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Setup_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Setup_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Setup_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD FSG_Setup_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void FSG_Setup_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_FSG_Setup;	        //Fct.-ID
	requestarray[2] =request;                   //request type
  switch(request)
	{
		case DataGet_REQ:
	    requestarray[3] =Bap_Void;                   //request type
			set_status_requestbuffer (requestarray, 4, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_Setup_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************FSG_OperationState**************************************
on envVar env_ASG_AudioSD_FSGOpState_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    FSG_OperationState_Request(DataGet_REQ);
}

void FSG_OperationState_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
			gAudioSD_FSGOperationState_OpState     =Indication_array[3];
      gAudioSD_FSGOperationState_Extension1   =Indication_array[4];
      gAudioSD_FSGOperationState_Extension2   =Indication_array[5];
      gAudioSD_FSGOperationState_Extension3   =Indication_array[6];
      gAudioSD_FSGOperationState_Extension4   =Indication_array[7];
      gAudioSD_FSGOperationState_Extension5   =Indication_array[8];
      //Panel
      putvalue(env_ASG_AudioSD_FSGOpState_State,gAudioSD_FSGOperationState_OpState);
      putvalue(env_ASG_AudioSD_FSGOpState_Ext1,gAudioSD_FSGOperationState_Extension1);
      putvalue(env_ASG_AudioSD_FSGOpState_Ext2,gAudioSD_FSGOperationState_Extension2);
      putvalue(env_ASG_AudioSD_FSGOpState_Ext3,gAudioSD_FSGOperationState_Extension3);
      putvalue(env_ASG_AudioSD_FSGOpState_Ext4,gAudioSD_FSGOperationState_Extension4);
      putvalue(env_ASG_AudioSD_FSGOpState_Ext5,gAudioSD_FSGOperationState_Extension5);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_OperationState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_OperationState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_OperationState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_OperationState_Indication: Application-Error: 0x%x", Indication_array[3]);
  	break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-AudioSD FSG_OperationState_Indication: unknown indication %x", gBAP_Indication[2]);
  	break;
	}
}

void FSG_OperationState_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_FSG_OperationState;	//Fct.-ID
	requestarray[2] =request;                   //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD FSG_OperationState_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************ASG_Capabilities****************************************
on envVar env_ASG_AudioSD_ASGCap_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    ASGCapabilities_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_ASGCap_set
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
	{
    gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = getvalue(env_ASG_AudioSD_ASGCap_PrC_DAB);
    gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 = getvalue(env_ASG_AudioSD_ASGCap_PrC_SDARS);
    gAudioSD_ASGCapabilities_PresentationCapabilities =gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0;
    gAudioSD_ASGCapabilities_PresentationCapabilities +=(gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1)*0x02;
    gAudioSD_ASGCapabilities_Extension1 =getvalue(env_ASG_AudioSD_ASGCap_Ext1);
    gAudioSD_ASGCapabilities_Extension2 =getvalue(env_ASG_AudioSD_ASGCap_Ext2);
    gAudioSD_ASGCapabilities_Extension3 =getvalue(env_ASG_AudioSD_ASGCap_Ext3);
    gAudioSD_ASGCapabilities_Extension4 =getvalue(env_ASG_AudioSD_ASGCap_Ext4);
    gAudioSD_ASGCapabilities_Extension5 =getvalue(env_ASG_AudioSD_ASGCap_Ext5);
    ASGCapabilities_Request(DataSetGet_REQ);
  }
}

void ASGCapabilities_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
			gAudioSD_ASGCapabilities_PresentationCapabilities     =Indication_array[3];
      gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 =gAudioSD_ASGCapabilities_PresentationCapabilities &0x01;
      gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 =(gAudioSD_ASGCapabilities_PresentationCapabilities &0x02)/0x02;               
      //Panel
      putvalue(env_ASG_AudioSD_ASGCap_PrC_DAB, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0);
      putvalue(env_ASG_AudioSD_ASGCap_PrC_SDARS, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1);
      putvalue(env_ASG_AudioSD_ASGCap_Ext1, gAudioSD_ASGCapabilities_Extension1);
      putvalue(env_ASG_AudioSD_ASGCap_Ext2, gAudioSD_ASGCapabilities_Extension2);
      putvalue(env_ASG_AudioSD_ASGCap_Ext3, gAudioSD_ASGCapabilities_Extension3);
      putvalue(env_ASG_AudioSD_ASGCap_Ext4, gAudioSD_ASGCapabilities_Extension4);
      putvalue(env_ASG_AudioSD_ASGCap_Ext5, gAudioSD_ASGCapabilities_Extension5);
    break;
    case Error_IND:				
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD ASGCapabilities_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD ASGCapabilities_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD ASGCapabilities_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD ASGCapabilities_Indication: Application-Error: 0x%x", Indication_array[3]);
  	break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-AudioSD ASGCapabilities_Indication: unknown indication %x", gBAP_Indication[2]);
  	break;
	}
}

void ASGCapabilities_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_ASG_Capabilities;	//Fct.-ID
	requestarray[2] =request;                   //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
    case DataSetGet_REQ:
      requestarray[3] =gAudioSD_ASGCapabilities_PresentationCapabilities;
      requestarray[4] =gAudioSD_ASGCapabilities_Extension1;
      requestarray[5] =gAudioSD_ASGCapabilities_Extension2;
      requestarray[6] =gAudioSD_ASGCapabilities_Extension3;
      requestarray[7] =gAudioSD_ASGCapabilities_Extension4;
      requestarray[8] =gAudioSD_ASGCapabilities_Extension5;
			set_status_requestbuffer (requestarray, 9, Bap_ByteSequence);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD ASGCapabilities_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************InfoStates**********************************************
on envVar env_ASG_AudioSD_InfoSt_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    InfoStates_Request(DataGet_REQ);
}

void InfoStates_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
      gAudioSD_InfoStates_States =Indication_array[3];
      gAudioSD_InfoStates_AdditionalStateInfo =Indication_array[4];
      gAudioSD_InfoStates_AdditionalStateInfo_Bit0 =gAudioSD_InfoStates_AdditionalStateInfo&0x01;
      gAudioSD_InfoStates_Extension1 =Indication_array[5];
      gAudioSD_InfoStates_Extension2 =Indication_array[6];
      gAudioSD_InfoStates_Extension3 =Indication_array[7];
      gAudioSD_InfoStates_Extension4 =Indication_array[8];
      //Panel
      putvalue(env_ASG_AudioSD_InfoSt_States,gAudioSD_InfoStates_States);
      putvalue(env_ASG_AudioSD_InfoSt_ASI_Bit0,gAudioSD_InfoStates_AdditionalStateInfo_Bit0);
      putvalue(env_ASG_AudioSD_InfoSt_Ext1,gAudioSD_InfoStates_Extension1);
      putvalue(env_ASG_AudioSD_InfoSt_Ext2,gAudioSD_InfoStates_Extension2);
      putvalue(env_ASG_AudioSD_InfoSt_Ext3,gAudioSD_InfoStates_Extension3);
      putvalue(env_ASG_AudioSD_InfoSt_Ext4,gAudioSD_InfoStates_Extension4);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD InfoStates_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD InfoStates_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD InfoStates_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD InfoStates_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD InfoStates_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
 }

void InfoStates_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_InfoStates;	        //Fct.-ID
	requestarray[2] =request;                   //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD InfoStates_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************SDS_State***********************************************
on envVar env_ASG_AudioSD_SDSState_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    SDSState_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_SDSState_setGet
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
	{
    gAudioSD_SDSState_State =getvalue(env_ASG_AudioSD_SDSState_State);
    gAudioSD_SDSState_Extension1 =getvalue(env_ASG_AudioSD_SDSState_Ext1);
    gAudioSD_SDSState_Extension2 =getvalue(env_ASG_AudioSD_SDSState_Ext2);
    gAudioSD_SDSState_Extension3 =getvalue(env_ASG_AudioSD_SDSState_Ext3);
    gAudioSD_SDSState_Extension4 =getvalue(env_ASG_AudioSD_SDSState_Ext4);
    gAudioSD_SDSState_Extension5 =getvalue(env_ASG_AudioSD_SDSState_Ext5);
    SDSState_Request(DataSetGet_REQ);
  }
}

void SDSState_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
      gAudioSD_SDSState_State       =Indication_array[3];
      gAudioSD_SDSState_Extension1  =Indication_array[4];
      gAudioSD_SDSState_Extension2  =Indication_array[5];
      gAudioSD_SDSState_Extension3  =Indication_array[6];
      gAudioSD_SDSState_Extension4  =Indication_array[7];
      gAudioSD_SDSState_Extension5  =Indication_array[8];
      //Panel
      putvalue(env_ASG_AudioSD_SDSState_State, gAudioSD_SDSState_State);
      putvalue(env_ASG_AudioSD_SDSState_Ext1, gAudioSD_SDSState_Extension1);
      putvalue(env_ASG_AudioSD_SDSState_Ext2, gAudioSD_SDSState_Extension2);
      putvalue(env_ASG_AudioSD_SDSState_Ext3, gAudioSD_SDSState_Extension3);
      putvalue(env_ASG_AudioSD_SDSState_Ext4, gAudioSD_SDSState_Extension4);
      putvalue(env_ASG_AudioSD_SDSState_Ext5, gAudioSD_SDSState_Extension5);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD SDSState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD SDSState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD SDSState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD SDSState_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD SDSState_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void SDSState_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_SDS_State;	//Fct.-ID
	requestarray[2] =request;           //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
    case DataSetGet_REQ:
      requestarray[3] = gAudioSD_SDSState_State;
      requestarray[4] = gAudioSD_SDSState_Extension1;
      requestarray[5] = gAudioSD_SDSState_Extension2;
      requestarray[6] = gAudioSD_SDSState_Extension3;
      requestarray[7] = gAudioSD_SDSState_Extension4;
      requestarray[8] = gAudioSD_SDSState_Extension5;
			set_status_requestbuffer (requestarray, 9, Bap_ByteSequence);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD SDSState_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************GeneralInfoSwitches*************************************
on envVar env_ASG_AudioSD_GIS_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    GeneralInfoSwitches_Request(DataGet_REQ);
}

void GeneralInfoSwitches_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
      gAudioSD_GeneralInfoSwitches_OnOffSwitches  =Indication_array[3];
      gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA       =gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x01;
      gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS        =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x02) /0x02;
      gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic  =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x04) /0x04;
      gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC        =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x08) /0x08;
      gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS       =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x10) /0x10;
      gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online     =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x20) /0x20;
      gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB        =(gAudioSD_GeneralInfoSwitches_OnOffSwitches &0x40) /0x40;
      gAudioSD_GeneralInfoSwitches_Extension1  =Indication_array[4];
      gAudioSD_GeneralInfoSwitches_Extension2  =Indication_array[5];
      gAudioSD_GeneralInfoSwitches_Extension3  =Indication_array[6];
      gAudioSD_GeneralInfoSwitches_Extension4  =Indication_array[7];
      gAudioSD_GeneralInfoSwitches_Extension5  =Indication_array[8];
      //Panel
      putvalue(env_ASG_AudioSD_GIS_OnOffSw_TP, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA);
      putvalue(env_ASG_AudioSD_GIS_OnOffSw_RDS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS);
      putvalue(env_ASG_AudioSD_GIS_OnOffSw_JP, gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic);
      putvalue(env_ASG_AudioSD_GIS_OnOffSw_TMC, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC);
      putvalue(env_ASG_AudioSD_GIS_OnOffSw_VICS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS);
      putvalue(env_ASG_AudioSD_GIS_OnOffSw_ON, gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online);
      putvalue(env_ASG_AudioSD_GIS_OnOffSw_DAB, gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB);
      putvalue(env_ASG_AudioSD_GIS_Ext1, gAudioSD_GeneralInfoSwitches_Extension1);
      putvalue(env_ASG_AudioSD_GIS_Ext2, gAudioSD_GeneralInfoSwitches_Extension2);
      putvalue(env_ASG_AudioSD_GIS_Ext3, gAudioSD_GeneralInfoSwitches_Extension3);
      putvalue(env_ASG_AudioSD_GIS_Ext4, gAudioSD_GeneralInfoSwitches_Extension4);
      putvalue(env_ASG_AudioSD_GIS_Ext5, gAudioSD_GeneralInfoSwitches_Extension5);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD GeneralInfoSwitches_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD GeneralInfoSwitches_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD GeneralInfoSwitches_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD GeneralInfoSwitches_Indication: Application-Error: 0x%x", Indication_array[3]);			
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD GeneralInfoSwitches_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void GeneralInfoSwitches_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_GeneralInfoSwitches;	//Fct.-ID
	requestarray[2] =request;                   //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD GeneralInfoSwitches_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************ActiveSource********************************************
on envVar env_ASG_AudioSD_AS_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    activeSource_Request(DataGet_REQ);
}

void activeSource_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
      gAudioSD_activeSource_SourceType            = Indication_array[3];
      gAudioSD_activeSource_SourceList_Reference  = Indication_array[4] + (Indication_array[5]*0x100);
      gAudioSD_activeSource_ListAvailable         = Indication_array[6];
      gAudioSD_activeSource_ListAvailable_Bit0    = gAudioSD_activeSource_ListAvailable&0x01;
      gAudioSD_activeSource_ListAvailable_Bit1    =(gAudioSD_activeSource_ListAvailable&0x02)/0x02;
      gAudioSD_activeSource_ListAvailable_Bit2    =(gAudioSD_activeSource_ListAvailable&0x04)/0x04;
      gAudioSD_activeSource_ListState             =(Indication_array[7] &0xF0)/0x10;
      gAudioSD_activeSource_Extension1            = Indication_array[7] &0x0F;
      gAudioSD_activeSource_Number                = Indication_array[8];
      //Panel
      putvalue(env_ASG_AudioSD_AS_SourceType, gAudioSD_activeSource_SourceType);
      putvalue(env_ASG_AudioSD_AS_SL_Ref, gAudioSD_activeSource_SourceList_Reference);
      putvalue(env_ASG_AudioSD_AS_LiAv_RL, gAudioSD_activeSource_ListAvailable_Bit0);
      putvalue(env_ASG_AudioSD_AS_LiAv_PL, gAudioSD_activeSource_ListAvailable_Bit1);
      putvalue(env_ASG_AudioSD_AS_LiAv_BL, gAudioSD_activeSource_ListAvailable_Bit2);
      putvalue(env_ASG_AudioSD_AS_ListState, gAudioSD_activeSource_ListState);
      putvalue(env_ASG_AudioSD_AS_Ext1, gAudioSD_activeSource_Extension1);
      putvalue(env_ASG_AudioSD_AS_Number, gAudioSD_activeSource_Number);
    break;
    case Error_IND:
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
  			writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30)			//BPL-error
  			writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40)			//BAL-error
  			writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  			writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Indication: Application-Error: 0x%x", Indication_array[3]);
  	break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-AudioSD activeSource_Indication: unknown indication %x", gBAP_Indication[2]);
  	break;
	}
}

void activeSource_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_ActiveSource;	    //Fct.-ID
	requestarray[2] =request;                   //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD activeSource_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************ActiveSourceName****************************************
on envVar env_ASG_AudioSD_ASName_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    activeSourceName_Request(DataGet_REQ);
}

void activeSourceName_Indication (dword Indication_array [], int datalength)
{
  int i=0;

	switch (gBAP_Indication[2])
	{
		case Data_IND:     
      //clear
      for(i=0; i<ACTIVE_SOURCE_NAME_LENGTH; i++)
          gAudioSD_activeSourceName[i] =0;                    
      //get data
      if(datalength >=(Indication_array[3]+4))
      {
        for (i=0; i<Indication_array[3]; i++)
          gAudioSD_activeSourceName[i] =Indication_array[4+i];
      }
      //Panel
      putvalue(env_ASG_AudioSD_ASName_Name_s, gAudioSD_activeSourceName);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD activeSourceName_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD activeSourceName_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD activeSourceName_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD activeSourceName_Indication: Application-Error: 0x%x", Indication_array[3]);
  	break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-AudioSD activeSourceName_Indication: unknown indication %x", gBAP_Indication[2]);
  	break;
	}
}

void activeSourceName_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_ActiveSourceName;	//Fct.-ID
	requestarray[2] =request;                   //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD activeSourceName_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************CurrentVolume*******************************************
on envVar env_ASG_AudioSD_CurrVol_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    currentVolume_Request(DataGet_REQ);
}

void currentVolume_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:       
      //get data
			gAudioSD_currentVolume_ChangingVolumeType =Indication_array[3];
      gAudioSD_currentVolume_maxVolume          =Indication_array[4];         
      gAudioSD_currentVolume_GenericVolume      =Indication_array[5];
      gAudioSD_currentVolume_MuteState          =Indication_array[6];
      gAudioSD_currentVolume_MuteState_Bit0     = gAudioSD_currentVolume_MuteState&0x01;
      gAudioSD_currentVolume_MuteState_Bit1     =(gAudioSD_currentVolume_MuteState&0x02)/0x02;
      gAudioSD_currentVolume_MuteState_Bit2     =(gAudioSD_currentVolume_MuteState&0x04)/0x04;
      gAudioSD_currentVolume_MuteState_Bit3     =(gAudioSD_currentVolume_MuteState&0x08)/0x08;
      gAudioSD_currentVolume_MuteState_Bit4     =(gAudioSD_currentVolume_MuteState&0x10)/0x10;
      gAudioSD_currentVolume_MuteState_Bit5     =(gAudioSD_currentVolume_MuteState&0x20)/0x20;
      gAudioSD_currentVolume_MuteState_Bit6     =(gAudioSD_currentVolume_MuteState&0x40)/0x40;
      gAudioSD_currentVolume_MuteState_Bit7     =(gAudioSD_currentVolume_MuteState&0x80)/0x80;
      gAudioSD_currentVolume_Extension1         =Indication_array[7];
      gAudioSD_currentVolume_Extension2         =Indication_array[8];
      //Panel
      putvalue(env_ASG_AudioSD_CurrVol_CVT,gAudioSD_currentVolume_ChangingVolumeType);
      putvalue(env_ASG_AudioSD_CurrVol_maxVol,gAudioSD_currentVolume_maxVolume);
      putvalue(env_ASG_AudioSD_CurrVol_GenVol,gAudioSD_currentVolume_GenericVolume);
      putvalue(env_ASG_AudioSD_CurrVol_MS_Bit0,gAudioSD_currentVolume_MuteState_Bit0);
      putvalue(env_ASG_AudioSD_CurrVol_MS_Bit1,gAudioSD_currentVolume_MuteState_Bit1);
      putvalue(env_ASG_AudioSD_CurrVol_MS_Bit2,gAudioSD_currentVolume_MuteState_Bit2);
      putvalue(env_ASG_AudioSD_CurrVol_MS_Bit3,gAudioSD_currentVolume_MuteState_Bit3);
      putvalue(env_ASG_AudioSD_CurrVol_MS_Bit4,gAudioSD_currentVolume_MuteState_Bit4);
      putvalue(env_ASG_AudioSD_CurrVol_MS_Bit5,gAudioSD_currentVolume_MuteState_Bit5);
      putvalue(env_ASG_AudioSD_CurrVol_MS_Bit6,gAudioSD_currentVolume_MuteState_Bit6);
      putvalue(env_ASG_AudioSD_CurrVol_MS_Bit7,gAudioSD_currentVolume_MuteState_Bit7);
      putvalue(env_ASG_AudioSD_CurrVol_Ext1,gAudioSD_currentVolume_Extension1);
      putvalue(env_ASG_AudioSD_CurrVol_Ext2,gAudioSD_currentVolume_Extension2);
    break;
    case Error_IND:				
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD currentVolume_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD currentVolume_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD currentVolume_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD currentVolume_Indication: Application-Error: 0x%x", Indication_array[3]);
  	break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-AudioSD currentVolume_Indication: unknown indication %x", gBAP_Indication[2]);
  	break;
	}
}

void currentVolume_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_CurrentVolume;	    //Fct.-ID
	requestarray[2] =request;                   //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD currentVolume_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************SourceState*********************************************
on envVar env_ASG_AudioSD_SrcSt_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    SourceState_Request(DataGet_REQ);
}

void SourceState_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
			gAudioSD_SourceState_StateInfo =Indication_array[3];
      gAudioSD_SourceState_Scope     =Indication_array[4];
      gAudioSD_SourceState_Extension1=Indication_array[5];
      gAudioSD_SourceState_Extension2=Indication_array[6];
      gAudioSD_SourceState_Extension3=Indication_array[7];
      gAudioSD_SourceState_Extension4=Indication_array[8];
      //Panel
      putvalue(env_ASG_AudioSD_SrcSt_SateInfo, gAudioSD_SourceState_StateInfo);
      putvalue(env_ASG_AudioSD_SrcSt_Scope, gAudioSD_SourceState_Scope);
      putvalue(env_ASG_AudioSD_SrcSt_Ext1, gAudioSD_SourceState_Extension1);
      putvalue(env_ASG_AudioSD_SrcSt_Ext2, gAudioSD_SourceState_Extension2);
      putvalue(env_ASG_AudioSD_SrcSt_Ext3, gAudioSD_SourceState_Extension3);
      putvalue(env_ASG_AudioSD_SrcSt_Ext4, gAudioSD_SourceState_Extension4);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD SourceState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD SourceState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD SourceState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD SourceState_Indication: Application-Error: 0x%x", Indication_array[3]);
  	break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-AudioSD SourceState_Indication: unknown indication %x", gBAP_Indication[2]);
  	break;
	}
}

void SourceState_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_SourceState;	//Fct.-ID
	requestarray[2] =request;           //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD SourceState_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************CurrentStationInfo**************************************
on envVar env_ASG_AudioSD_CSI2_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    CurrentStationInfo_Request(DataGet_REQ);   
}

void CurrentStationInfo_Indication (dword Indication_array [], int datalength)
{
	int i =0, Offset =0, length =0;

  switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
      length =Indication_array[3];
      Offset =4;
      //Name
      for (i=0; i<CSI_INFORMATION_TEXTLENGTH; i++)
        gAudioSD_CSI_PrimaryInformation[i] =0;
      for (i=0; i< length; i++)
      { 
        gAudioSD_CSI_PrimaryInformation[i] =Indication_array[Offset];
        Offset++;
      }
      //Type
      gAudioSD_CSI_PI_Type =Indication_array[Offset];
      Offset++;
      //ID
      gAudioSD_CSI_PIID =Indication_array[Offset]; 
      Offset++;
      gAudioSD_CSI_PIID +=Indication_array[Offset] *0x100;
      Offset++;
      //Name
      length =Indication_array[Offset];
      Offset++;
      for (i=0; i<CSI_INFORMATION_TEXTLENGTH; i++)
        gAudioSD_CSI_SecondaryInformation[i] =0;
      for (i=0; i< length; i++)
      { 
        gAudioSD_CSI_SecondaryInformation[i] =Indication_array[Offset];
        Offset++;
      }
      //Type
      gAudioSD_CSI_SI_Type =Indication_array[Offset];
      Offset++;
      //Name
      length =Indication_array[Offset];
      Offset++;
      for (i=0; i<CSI_INFORMATION_TEXTLENGTH; i++)
        gAudioSD_CSI_TertiaryInformation[i] =0;
      for (i=0; i< length; i++)
      { 
        gAudioSD_CSI_TertiaryInformation[i] =Indication_array[Offset];
        Offset++;
      }
      //Type
      gAudioSD_CSI_TI_Type =Indication_array[Offset];
      Offset++;
      //Name
      length =Indication_array[Offset];
      Offset++;
      for (i=0; i<CSI_INFORMATION_TEXTLENGTH; i++)
          gAudioSD_CSI_QuarternaryInformation[i] =0;
      for (i=0; i< length; i++)
      { 
          gAudioSD_CSI_QuarternaryInformation[i] =Indication_array[Offset];
          Offset++;
      }
      //Type
      gAudioSD_CSI_QI_Type =Indication_array[Offset];
      Offset++;
      //Name
      length =Indication_array[Offset];
      Offset++;
      for (i=0; i<CSI_INFORMATION_TEXTLENGTH; i++)
          gAudioSD_CSI_Information5[i] =0;
      for (i=0; i< length; i++)
      { 
          gAudioSD_CSI_Information5[i] =Indication_array[Offset];
          Offset++;
      }
      //Type
      gAudioSD_CSI_I5_Type =Indication_array[Offset];
      Offset++;
      //Name
      length =Indication_array[Offset];
      Offset++;
      for (i=0; i<CSI_INFORMATION_TEXTLENGTH; i++)
          gAudioSD_CSI_Information6[i] =0;
      for (i=0; i< length; i++)
      { 
          gAudioSD_CSI_Information6[i] =Indication_array[Offset];
          Offset++;
      }
      //Type
      gAudioSD_CSI_I6_Type =Indication_array[Offset];
      Offset++;
      //Name
      length =Indication_array[Offset];
      Offset++;
      for (i=0; i<CSI_INFORMATION_TEXTLENGTH; i++)
          gAudioSD_CSI_Information7[i] =0;
      for (i=0; i< length; i++)
      { 
          gAudioSD_CSI_Information7[i] =Indication_array[Offset];
          Offset++;
      }
      //Type
      gAudioSD_CSI_I7_Type =Indication_array[Offset];
      Offset++;
      //Name
      length =Indication_array[Offset];
      Offset++;
      for (i=0; i<CSI_INFORMATION_TEXTLENGTH; i++)
          gAudioSD_CSI_Information8[i] =0;
      for (i=0; i< length; i++)
      { 
          gAudioSD_CSI_Information8[i] =Indication_array[Offset];
          Offset++;
      }
      //Type
      gAudioSD_CSI_I8_Type =Indication_array[Offset];
      Offset++;
      //StationInfoSwitches
      gAudioSD_CSI_StationInfoSwitches =Indication_array[Offset]; 
      Offset++;
      gAudioSD_CSI_StationInfoSwitches_Bit0  = gAudioSD_CSI_StationInfoSwitches &0x01;
      gAudioSD_CSI_StationInfoSwitches_Bit1  =(gAudioSD_CSI_StationInfoSwitches &0x02) /0x02;
      gAudioSD_CSI_StationInfoSwitches_Bit2  =(gAudioSD_CSI_StationInfoSwitches &0x04) /0x04;
      gAudioSD_CSI_StationInfoSwitches_Bit3  =(gAudioSD_CSI_StationInfoSwitches &0x08) /0x08;
      gAudioSD_CSI_StationInfoSwitches_Bit4  =(gAudioSD_CSI_StationInfoSwitches &0x10) /0x10;
      //StationProperties
      gAudioSD_CSI_StationProperties =Indication_array[Offset]; 
      Offset++;
      gAudioSD_CSI_StationProperties_Bit0  = gAudioSD_CSI_StationProperties &0x01;
      gAudioSD_CSI_StationProperties_Bit1  =(gAudioSD_CSI_StationProperties &0x02) /0x02;
      gAudioSD_CSI_StationProperties_Bit2  =(gAudioSD_CSI_StationProperties &0x04) /0x04;
      gAudioSD_CSI_StationProperties_Bit3  =(gAudioSD_CSI_StationProperties &0x08) /0x08;
      gAudioSD_CSI_StationProperties_Bit4  =(gAudioSD_CSI_StationProperties &0x10) /0x10;
      //StationLinkingState
      gAudioSD_CSI_StationLinkingState = Indication_array[Offset]; 
      Offset++;
      //Channel_ID
      gAudioSD_CSI_ChannelID =Indication_array[Offset]; 
      Offset++;
      gAudioSD_CSI_ChannelID +=Indication_array[Offset] *0x100;
      Offset++;
      //RadioCategory
      gAudioSD_CSI_RadioCategory = Indication_array[Offset]; 
      Offset++;
      //Extension
      gAudioSD_CSI_Extension1 = Indication_array[Offset]; 
      Offset++;
      //Panel
      putvalue(env_ASG_AudioSD_CSI2_InfoID1,gAudioSD_CSI_PIID);
      putvalue(env_ASG_AudioSD_CSI2_InfoTy1,gAudioSD_CSI_PI_Type);
      putvalue(env_ASG_AudioSD_CSI2_InfoTy2,gAudioSD_CSI_SI_Type);
      putvalue(env_ASG_AudioSD_CSI2_InfoTy3,gAudioSD_CSI_TI_Type);
      putvalue(env_ASG_AudioSD_CSI2_InfoTy4,gAudioSD_CSI_QI_Type);
      putvalue(env_ASG_AudioSD_CSI2_InfoTy5,gAudioSD_CSI_I5_Type);
      putvalue(env_ASG_AudioSD_CSI2_InfoTy6,gAudioSD_CSI_I6_Type);
      putvalue(env_ASG_AudioSD_CSI2_InfoTy7,gAudioSD_CSI_I7_Type);
      putvalue(env_ASG_AudioSD_CSI2_InfoTy8,gAudioSD_CSI_I8_Type);
      putvalue(env_ASG_AudioSD_CSI2_Info1,gAudioSD_CSI_PrimaryInformation);
      putvalue(env_ASG_AudioSD_CSI2_Info2,gAudioSD_CSI_SecondaryInformation);
      putvalue(env_ASG_AudioSD_CSI2_Info3,gAudioSD_CSI_TertiaryInformation);
      putvalue(env_ASG_AudioSD_CSI2_Info4,gAudioSD_CSI_QuarternaryInformation);
      putvalue(env_ASG_AudioSD_CSI2_Info5,gAudioSD_CSI_Information5);
      putvalue(env_ASG_AudioSD_CSI2_Info6,gAudioSD_CSI_Information6);
      putvalue(env_ASG_AudioSD_CSI2_Info7,gAudioSD_CSI_Information7);
      putvalue(env_ASG_AudioSD_CSI2_Info8,gAudioSD_CSI_Information8);
      putvalue(env_ASG_AudioSD_CSI2_ChanID,gAudioSD_CSI_ChannelID);
      putvalue(env_ASG_AudioSD_CSI2_SIS_Bit0,gAudioSD_CSI_StationInfoSwitches_Bit0);
      putvalue(env_ASG_AudioSD_CSI2_SIS_Bit1,gAudioSD_CSI_StationInfoSwitches_Bit1);
      putvalue(env_ASG_AudioSD_CSI2_SIS_Bit2,gAudioSD_CSI_StationInfoSwitches_Bit2);
      putvalue(env_ASG_AudioSD_CSI2_SIS_Bit3,gAudioSD_CSI_StationInfoSwitches_Bit3);
      putvalue(env_ASG_AudioSD_CSI2_SIS_Bit4,gAudioSD_CSI_StationInfoSwitches_Bit4);
      putvalue(env_ASG_AudioSD_CSI2_SP_Bit0,gAudioSD_CSI_StationProperties_Bit0);
      putvalue(env_ASG_AudioSD_CSI2_SP_Bit1,gAudioSD_CSI_StationProperties_Bit1);
      putvalue(env_ASG_AudioSD_CSI2_SP_Bit2,gAudioSD_CSI_StationProperties_Bit2);
      putvalue(env_ASG_AudioSD_CSI2_SP_Bit3,gAudioSD_CSI_StationProperties_Bit3);
      putvalue(env_ASG_AudioSD_CSI2_SP_Bit4,gAudioSD_CSI_StationProperties_Bit4);
      putvalue(env_ASG_AudioSD_CSI2_SLS,gAudioSD_CSI_StationLinkingState);
      putvalue(env_ASG_AudioSD_CSI2_RadioCat,gAudioSD_CSI_RadioCategory);
      putvalue(env_ASG_AudioSD_CSI2_Ext1,gAudioSD_CSI_Extension1);
    break;	
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD CurrentStationInfo_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void CurrentStationInfo_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_CurrentStationInfo;	    //Fct.-ID
	requestarray[2] =request;                 //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationInfo2_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************CurrentStation_Handle***********************************
on envVar env_ASG_AudioSD_CSH_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    CurrentStationHandle_Request(DataGet_REQ);
}

void CurrentStationHandle_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
      gAudioSD_CSIhandle_FSGhandle                =Indication_array[3] +(Indication_array[4] *0x100);
      gAudioSD_CSIhandle_FSGhandle_absolutePos    =Indication_array[5] +(Indication_array[6] *0x100);
      gAudioSD_CSIhandle_PresetListRef            =Indication_array[7];
      gAudioSD_CSIhandle_PresetListabsolutePos    =Indication_array[8];
      gAudioSD_CSIhandle_PictureRef               =Indication_array[9] +(Indication_array[10] *0x100);
      gAudioSD_CSIhandle_Extension1               =Indication_array[11];
      gAudioSD_CSIhandle_Extension2               =Indication_array[12];
      gAudioSD_CSIhandle_Extension3               =Indication_array[13];
      gAudioSD_CSIhandle_Extension4               =Indication_array[14];
      gAudioSD_CSIhandle_Extension5               =Indication_array[15];
      gAudioSD_CSIhandle_Extension6               =Indication_array[16];
      gAudioSD_CSIhandle_Extension7               =Indication_array[17];
      gAudioSD_CSIhandle_Extension8               =Indication_array[18];
      gAudioSD_CSIhandle_Extension9               =Indication_array[19];
      gAudioSD_CSIhandle_Extension10              =Indication_array[20];
      gAudioSD_CSIhandle_Extension11              =Indication_array[21];
      gAudioSD_CSIhandle_Extension12              =Indication_array[22];
      gAudioSD_CSIhandle_Extension13              =Indication_array[23];
      gAudioSD_CSIhandle_Extension14              =Indication_array[24];
      gAudioSD_CSIhandle_Extension15              =Indication_array[25];
      //Panel
      putvalue(env_ASG_AudioSD_CSH_FSGh,gAudioSD_CSIhandle_FSGhandle);
      putvalue(env_ASG_AudioSD_CSH_FSGh_abs,gAudioSD_CSIhandle_FSGhandle_absolutePos);
      putvalue(env_ASG_AudioSD_CSH_PL_Ref,gAudioSD_CSIhandle_PresetListRef);
      putvalue(env_ASG_AudioSD_CSH_PL_abs,gAudioSD_CSIhandle_PresetListabsolutePos);
      putvalue(env_ASG_AudioSD_CSH_PicRef,gAudioSD_CSIhandle_PictureRef);
      putvalue(env_ASG_AudioSD_CSH_Extension1,gAudioSD_CSIhandle_Extension1);
      putvalue(env_ASG_AudioSD_CSH_Extension2,gAudioSD_CSIhandle_Extension2);
      putvalue(env_ASG_AudioSD_CSH_Extension3,gAudioSD_CSIhandle_Extension3);
      putvalue(env_ASG_AudioSD_CSH_Extension4,gAudioSD_CSIhandle_Extension4);
      putvalue(env_ASG_AudioSD_CSH_Extension5,gAudioSD_CSIhandle_Extension5);
      putvalue(env_ASG_AudioSD_CSH_Extension6,gAudioSD_CSIhandle_Extension6);
      putvalue(env_ASG_AudioSD_CSH_Extension7,gAudioSD_CSIhandle_Extension7);
      putvalue(env_ASG_AudioSD_CSH_Extension8,gAudioSD_CSIhandle_Extension8);
      putvalue(env_ASG_AudioSD_CSH_Extension9,gAudioSD_CSIhandle_Extension9);
      putvalue(env_ASG_AudioSD_CSH_Extension10,gAudioSD_CSIhandle_Extension10);
      putvalue(env_ASG_AudioSD_CSH_Extension11,gAudioSD_CSIhandle_Extension11);
      putvalue(env_ASG_AudioSD_CSH_Extension12,gAudioSD_CSIhandle_Extension12);
      putvalue(env_ASG_AudioSD_CSH_Extension13,gAudioSD_CSIhandle_Extension13);
      putvalue(env_ASG_AudioSD_CSH_Extension14,gAudioSD_CSIhandle_Extension14);
      putvalue(env_ASG_AudioSD_CSH_Extension15,gAudioSD_CSIhandle_Extension15);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Indication: Application-Error: 0x%x", Indication_array[3]);
  	break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-AudioSD CurrentStationHandle_Indication: unknown indication %x", gBAP_Indication[2]);
  	break;
	}
}

void CurrentStationHandle_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	                //LSG-ID
	requestarray[1] =FctID_CurrentStation_Handle;	//Fct.-ID
	requestarray[2] =request;                       //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD CurrentStationHandle_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************PlayPosition********************************************
on envVar env_ASG_AudioSD_PP_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    PlayPosition_Request(DataGet_REQ);
}

void PlayPosition_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
			gAudioSD_PlayPosition_TimePosition    = Indication_array[3] + (Indication_array[4]*0x100);
      gAudioSD_PlayPosition_TotalPlayTime   = Indication_array[5] + (Indication_array[6]*0x100);
      gAudioSD_PlayPosition_Attributes      = Indication_array[7];
      gAudioSD_PlayPosition_Attributes_Bit0 = gAudioSD_PlayPosition_Attributes&0x01; //Bit '0'
      gAudioSD_PlayPosition_BufferLevel     = Indication_array[8];
      //panel
      putvalue(env_ASG_AudioSD_PP_TimePos,gAudioSD_PlayPosition_TimePosition);
      putvalue(env_ASG_AudioSD_PP_TotalPlayTime,gAudioSD_PlayPosition_TotalPlayTime);
      putvalue(env_ASG_AudioSD_PP_Attr_Bit0,gAudioSD_PlayPosition_Attributes_Bit0);
      putvalue(env_ASG_AudioSD_PP_BufferLevel,gAudioSD_PlayPosition_BufferLevel);
    break;	
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD PlayPosition_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD PlayPosition_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD PlayPosition_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD PlayPosition_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD PlayPosition_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void PlayPosition_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_PlayPosition;	    //Fct.-ID
	requestarray[2] =request;                 //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD PlayPosition_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************Station_Track_Switch************************************
on envVar env_ASG_AudioSD_STS_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    Station_Track_Switch_Request(DataGet_REQ);
}

void Station_Track_Switch_Indication (dword Indication_array [], int datalength)
{
  byte temp;
		
  switch (gBAP_Indication[2])
	{
		case Data_IND:      
      //get data
      temp = Indication_array[3];
			gAudioSD_STS_Event       =(temp & 0xF0)/0x10;
			gAudioSD_STS_Direction   = temp & 0x0F;
      gAudioSD_STS_Extension1  = Indication_array[4];
      gAudioSD_STS_Extension2  = Indication_array[5];
      gAudioSD_STS_Extension3  = Indication_array[6];
      gAudioSD_STS_Extension4  = Indication_array[7];
      gAudioSD_STS_Extension5  = Indication_array[8];
      //panel
      putvalue(env_ASG_AudioSD_STS_Event,gAudioSD_STS_Event);
      putvalue(env_ASG_AudioSD_STS_Direction,gAudioSD_STS_Direction);
      putvalue(env_ASG_AudioSD_STS_Extension1,gAudioSD_STS_Extension1);
      putvalue(env_ASG_AudioSD_STS_Extension2,gAudioSD_STS_Extension2);
      putvalue(env_ASG_AudioSD_STS_Extension3,gAudioSD_STS_Extension3);
      putvalue(env_ASG_AudioSD_STS_Extension4,gAudioSD_STS_Extension4);
      putvalue(env_ASG_AudioSD_STS_Extension4,gAudioSD_STS_Extension5);
    break;	
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD Station_Track_Switch_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD Station_Track_Switch_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD Station_Track_Switch_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD Station_Track_Switch_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD Station_Track_Switch_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void Station_Track_Switch_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_Station_Track_Switch;	    //Fct.-ID
	requestarray[2] =request;                 //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD Station_Track_Switch_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************AnnouncementInfo****************************************
on envVar env_ASG_AudioSD_AnInf_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    AnnouncementInfo_Request(DataGet_REQ);
}

void AnnouncementInfo_Indication (dword Indication_array [], int datalength)
{   
  int i =0;   
    
  switch (gBAP_Indication[2])
	{
    case Data_IND:
      if(datalength >=2) 
      {
        //get data
			  gAudioSD_AnnouncementInfo_Type =Indication_array[3];   
        //clear
        for(i=0; i<ANNOUNCEMENT_STATIONNAME_TEXTLENGTH; i++)
            gAudioSD_AnnouncementInfo_StationName[i] =0;
        for(i=0; i<Indication_array[4]; i++)
            gAudioSD_AnnouncementInfo_StationName[i] =Indication_array[5+i];
        //Panel
        putvalue(env_ASG_AudioSD_AnInf_Type, gAudioSD_AnnouncementInfo_Type);
        putvalue(env_ASG_AudioSD_AnInf_Name_s, gAudioSD_AnnouncementInfo_StationName);
      }
    break;	
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementInfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementInfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementInfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementInfo_Indication: Application-Error: 0x%x", Indication_array[3]);
	  break;
	  default:
		    writelineEx(gError_Trace, 0,"ASG-AudioSD AnnouncementInfo_Indication: unknown indication %x", gBAP_Indication[2]);
	  break;
  }
}

void AnnouncementInfo_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_AnnouncementInfo;	//Fct.-ID
	requestarray[2] =request;                   //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementInfo_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************AnnouncementEscape**************************************
on envVar env_ASG_AudioSD_AnE_SR
{
  if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
  {
    gAudioSD_AnnouncementEscape_AsgId       =getvalue(env_ASG_AudioSD_AnE_AsgID);
    gAudioSD_AnnouncementEscape_Extension1  =getvalue(env_ASG_AudioSD_AnE_Ext1);
    putvalue(env_ASG_AudioSD_AnE_Err,0);
    putvalue(env_ASG_AudioSD_AnE_Err_s,empty_string);
    putvalue(env_ASG_AudioSD_AnE_Res_s,empty_string);
    AnnouncementEscape_Request(StartResult_REQ, 0);
  }
}

on envVar env_ASG_AudioSD_AnE_Abort
{
  if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
  {
    putvalue(env_ASG_AudioSD_AnE_Err,0);
    putvalue(env_ASG_AudioSD_AnE_Err_s,empty_string);
    putvalue(env_ASG_AudioSD_AnE_Res_s,empty_string);
    AnnouncementEscape_Request(AbortResult_REQ, 0);
  }
}

void AnnouncementEscape_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
      gAudioSD_AnnouncementEscape_AsgId     =(Indication_array[3]&0xF0)/0x10;
      gAudioSD_AnnouncementEscape_Extension1= Indication_array[3]&0x0F;
      gAudioSD_AnnouncementEscape_Result =Indication_array[4];
		  putvalue(env_ASG_AudioSD_AnE_AsgID, gAudioSD_AnnouncementEscape_AsgId);
      putvalue(env_ASG_AudioSD_AnE_Ext1, gAudioSD_AnnouncementEscape_Extension1);
      putvalue(env_ASG_AudioSD_AnE_Res, gAudioSD_AnnouncementEscape_Result);
		break;
		case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementEscape_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementEscape_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementEscape_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
			{	
        writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementEscape_Indication: Application-Error: 0x%x", Indication_array[3]);
        putvalue(env_ASG_AudioSD_AnE_Err,Indication_array[3]);
        
        if (Indication_array[3] ==0)
            putvalue(env_ASG_AudioSD_AnE_Err_s,"no error");
        
        else if((Indication_array[3]-0x40)<17)
            putvalue(env_ASG_AudioSD_AnE_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
        else
            putvalue(env_ASG_AudioSD_AnE_Err_s,gstring_reserved);
      }
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD AnnouncementEscape_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

void AnnouncementEscape_Request (byte request, byte errorcode)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	                //LSG-ID
	requestarray[1] =FctID_AnnouncementEscape;	    //Fct.-ID
	requestarray[2] =request;                       //request type
  switch(request)
	{
		case StartResult_REQ:
		  requestarray[3] =(gAudioSD_AnnouncementEscape_AsgId*0x10)+(gAudioSD_AnnouncementEscape_Extension1&0x0F);
      set_status_requestbuffer (requestarray, 4, Bap_ByteSequence);
		break;
    case AbortResult_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD AnnouncementEscape_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************ReceptionList*******************************************
on envVar env_ASG_AudioSD_RL_GetArray
{
  byte mode, shift, direction, transmitpos, indexsize,recordaddress;
  word requested_startelement, startelement, elements;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;

  if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
    gReceptionList_ASGID            =getvalue(env_ASG_AudioSD_RL_ASGID);
    gReceptionList_TAID             =getvalue(env_ASG_AudioSD_RL_TAID);
    gReceptionList_ParentID         =getvalue(env_ASG_AudioSD_RL_ParentID);
    gReceptionList_ElementType      =getvalue(env_ASG_AudioSD_RL_ElementType);
    shift                           =getvalue(env_ASG_AudioSD_RL_AH_shift);
    direction                       =getvalue(env_ASG_AudioSD_RL_AH_dir);
    transmitpos                     =getvalue(env_ASG_AudioSD_RL_AH_PosTrans);
    indexsize                       =getvalue(env_ASG_AudioSD_RL_AH_IS);
    recordaddress                   =getvalue(env_ASG_AudioSD_RL_AH_RA);
    startelement                    =getvalue(env_ASG_AudioSD_RL_AH_start);
    elements                        =getvalue(env_ASG_AudioSD_RL_AH_elements);
    requested_startelement          =startelement;
    mode                            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    ReceptionList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
  }
}

void ReceptionList_Indication (dword Indication_array [], int datalength)
{
  byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
  word  startelement, elements, startelement_check, Offset =0;
  int i =0, j=0;

  // Init local variables
  mode                    =0;
  direction               =0;
  shift                   =0;
  recordaddress           =0;
  startelement            =0;
  elements                =0;
  current_element         =0;
  transmitpos             =0;
  length                  =0;
  startelement_check      =0;
  StartElementInCache     =FALSE;
  CacheElements           =FALSE;
  
	switch (gBAP_Indication[2])
	{
		case Data_IND:
			//get data
                gReceptionList_ASGID =(Indication_array[3] &0xF0) /0x10;
                gReceptionList_TAID  =Indication_array[3] &0x0F;
                
                gReceptionList_ElementType =Indication_array[4];
                
                gReceptionList_ParentID =Indication_array[5]; 
                gReceptionList_ParentID +=(Indication_array[6] *0x100);              

                gReceptionList_TotalNumListElements =Indication_array[7];
                gReceptionList_TotalNumListElements +=(Indication_array[8] *0x100);
              
                /***ArrayHeader***/
                mode            =(Indication_array[9] &0xF0) /0x10;
                recordaddress   =Indication_array[9] &0x0F;
                Offset =10;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gReceptionList_Pos[i])  
                            i =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                /* new DF5.0 RecAddress 0 for FullRangeUpdate only, no data send...
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                                */
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                /*   new DF5.0 RecAddress 0 for FullRangeUpdate only, no data send...                                 
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                                */
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> Type, Attributes, PResetID, FmREG_Code, Category, Name, Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> Type, Attributes

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 3: //recordaddress =3 -> PresetID, FmREG_Code, Category, Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends
                    
                    case 4: //recordaddress =4 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends 
                    
                    case 5: //recordaddress =5 -> Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =5 ends
                    case 6: //recordaddress =6 -> Type, Attributes, Category, Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                    gReceptionList_Name[current_element][i] =0; 
                                    }   
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                    //POS    
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                    gReceptionList_Name[current_element][i] =0; 
                                    }    
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =6 ends
                     case 7: //recordaddress =7 -> Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =7 ends   
                     case 8: //recordaddress =8 -> PicRef

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =8 ends   
                     case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_RL_ASGID, gReceptionList_ASGID);
                putvalue(env_ASG_AudioSD_RL_TAID, gReceptionList_TAID);
                putvalue(env_ASG_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements);
                putvalue(env_ASG_AudioSD_RL_ParentID, gReceptionList_ParentID);
                putvalue(env_ASG_AudioSD_RL_ElementType, gReceptionList_ElementType);

                gReceptionList_recordaddress =recordaddress;
                gReceptionList_transmitpos   =transmitpos;             
			break;
            case Changed_IND:
                //get data  
                gReceptionList_ElementType =Indication_array[3];
                
                gReceptionList_ParentID =Indication_array[4]; 
                gReceptionList_ParentID +=(Indication_array[5] *0x100);              
              
                /***ArrayHeader***/
                mode            =(Indication_array[6] &0xF0) /0x10;
                recordaddress   =Indication_array[6] &0x0F;
                Offset =7;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==65535) //check 'full range update'?
                {
                    putvalue(env_ASG_AudioSD_RL_OnOff, FALSE);
                    putvalue(env_ASG_AudioSD_RL_ListOpState, "'full range update' received");
                }
                else if (datalength>11)
                {
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gReceptionList_Pos[i])  
                            i =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                              /* new DF5.0 RecAddress 0 FullRangeUpdate only -> no data send...
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                   
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                                */
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                 
                                /* new DF5.0 RecAddress 0 FullRangeUpdate only -> no data send...
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gReceptionList_Attributes_available_Bit0[current_element]    =(gReceptionList_Attributes[current_element] &0x01);
                                        gReceptionList_Attributes_DVB_Bit1[current_element]          =(gReceptionList_Attributes[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes_DAB_Bit2[current_element]          =(gReceptionList_Attributes[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes_DAB_Bit3[current_element]          =(gReceptionList_Attributes[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes_DAB_Bit4[current_element]          =(gReceptionList_Attributes[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes_TP_Bit5[current_element]           =(gReceptionList_Attributes[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes_TMC_Bit6[current_element]          =(gReceptionList_Attributes[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes_SDARS_Bit7[current_element]        =(gReceptionList_Attributes[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes_DABserv_Bit8[current_element]      =(gReceptionList_Attributes[current_element] &0x100) /0x100;
                                        gReceptionList_Attributes_FMOnline_Bit9[current_element]     =(gReceptionList_Attributes[current_element] &0x200) /0x200;
                                        gReceptionList_Attributes_StationSelect_BitA[current_element]=(gReceptionList_Attributes[current_element] &0x400) /0x700;
                                        gReceptionList_Attributes_OnlineRadioMute_BitB[current_element]=(gReceptionList_Attributes[current_element] &0x800) /0x800;
                                        gReceptionList_Attributes_StationLinked_BitC[current_element]  =(gReceptionList_Attributes[current_element] &0x1000) /0x1000;
                                    }

                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
			                                gReceptionList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
			                                gReceptionList_Frequency[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                                */
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    case 1: //recordaddress =1 -> Type, Attributes, PResetID, FmREG_Code, Category, Name, Frequency
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }                                 
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                  current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                  i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                              }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> Type, Attributes

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 3: //recordaddress =3 -> PresetID, FmREG_Code, Category, Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends
                    
                    case 4: //recordaddress =4 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_Attributes1_Bit0[current_element]    =(gReceptionList_Attributes1[current_element] &0x01);
                                        gReceptionList_Attributes1_Bit1[current_element]    =(gReceptionList_Attributes1[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes1_Bit2[current_element]    =(gReceptionList_Attributes1[current_element] &0x04) /0x04; 
                                        gReceptionList_Attributes1_Bit3[current_element]    =(gReceptionList_Attributes1[current_element] &0x08) /0x08;
                                        gReceptionList_Attributes1_Bit4[current_element]    =(gReceptionList_Attributes1[current_element] &0x10) /0x10;
                                        gReceptionList_Attributes1_Bit5[current_element]    =(gReceptionList_Attributes1[current_element] &0x20) /0x20;
                                        gReceptionList_Attributes1_Bit6[current_element]    =(gReceptionList_Attributes1[current_element] &0x40) /0x40;
                                        gReceptionList_Attributes1_Bit7[current_element]    =(gReceptionList_Attributes1[current_element] &0x80) /0x80;
                                        gReceptionList_Attributes2_Bit0[current_element]    =(gReceptionList_Attributes2[current_element] &0x01);
                                        gReceptionList_Attributes2_Bit1[current_element]    =(gReceptionList_Attributes2[current_element] &0x02) /0x02;
                                        gReceptionList_Attributes2_Bit2[current_element]    =(gReceptionList_Attributes2[current_element] &0x04) /0x04;
                                        gReceptionList_Attributes2_Bit3[current_element]    =(gReceptionList_Attributes2[current_element] &0x08) /0x08;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends 
                    
                    case 5: //recordaddress =5 -> Frequency

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Category
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_Category[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =5 ends
                    case 6: //recordaddress =6 -> Type,Attributes,Category,Name

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++) //clear
		                                    gReceptionList_Name[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =6 ends
                     case 7: //recordaddress =7 -> Frequency
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }                                 
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                  current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                  i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                              }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                      for(i=0; i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++) //clear
		                                    gReceptionList_Frequency[current_element][i] =0; 
                                    } 
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gReceptionList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =7 ends   
                     case 8: //recordaddress =8 -> PicRef
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }                                 
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                  current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                  i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                              }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                 
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gReceptionList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gReceptionList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =8 ends   
                     case 15: //recordaddress =0xf -> Pos

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gReceptionList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gReceptionList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gReceptionList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gReceptionList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gReceptionList_Pos[i] && gReceptionList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gReceptionList_ListHandlingType !=AUDIO_RECEPTIONLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gReceptionList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =ReceptionList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RECEPTIONLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gReceptionList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gReceptionList_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gReceptionList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gReceptionList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gReceptionList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =ReceptionList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                }                   
                
                //Panel
                putvalue(env_ASG_AudioSD_RL_ASGID, gReceptionList_ASGID);
                putvalue(env_ASG_AudioSD_RL_TAID, gReceptionList_TAID);
                putvalue(env_ASG_AudioSD_RL_ParentID, gReceptionList_ParentID);
                putvalue(env_ASG_AudioSD_RL_ElementType, gReceptionList_ElementType);

                gReceptionList_recordaddress =recordaddress;
                gReceptionList_transmitpos   =transmitpos;             
            
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD ReceptionList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}

    //for "sliding window concept"
  /*
    if(gReceptionList_TotalNumListElements<=AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE)
        gReceptionList_SlidingWindow_State =AUDIO_RECEPTIONLIST_SLIDINGWINDOW_NOTACTIVE;
    else
        gReceptionList_SlidingWindow_State =AUDIO_RECEPTIONLIST_SLIDINGWINDOW_ACTIVE;

    if (gReceptionList_CallBackReason !=AUDIO_RECEPTIONLIST_CALLBACKREASON_NOCALLBACK)
        ReceptionList_ListHandling ();
    else
        ReceptionList_display();
  */
}

void ReceptionList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
  int  i;
  dword requestarray [BAP_BUFFER_SIZE], Offset;
  word indexsize;

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  indexsize   =0;
  Offset      =0;
  // decode "mode-byte"
  indexsize   =(mode &0x08)/0x08; 
  // Handle request.
  requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_ReceptionList;	//Fct.-ID
	requestarray[2] =request;               //request type
  switch(request)
	{
    case DataGet_REQ:              
      requestarray[3] =((gReceptionList_ASGID *0x10) &0xF0) +(gReceptionList_TAID &0x0F);
      requestarray[4] =gReceptionList_ElementType;
      requestarray[5] =(gReceptionList_ParentID &0x00FF);
      requestarray[6] =((gReceptionList_ParentID &0xFF00) /0x100);
      /***ArrayHeader***/
	    requestarray[7] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
      Offset =8;
      if(indexsize)
      {
        requestarray[Offset] =requested_startelement &0x00FF;
        Offset++;
        requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
        Offset++;  
        requestarray[Offset] =elements &0x00FF;
        Offset++;
        requestarray[Offset] =(elements &0xFF00) /0x100;
        Offset++;       
      }
      else
      {
        requestarray[Offset] =requested_startelement;
        Offset++;
        requestarray[Offset] =elements;
        Offset++;
      }
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD ReceptionList_Request: invalid request %d", request);
		break;
  }
}

int ReceptionList_GetNextCachedElement (int currentElement,byte direction)
{
  int i=0, nextElement=0;

  switch (direction)
  {
    case AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_NEXT_ELEMENT:                
      nextElement = ++currentElement;
      if (nextElement<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
      {
        for(i =nextElement; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
        {
          if(gReceptionList_ListEntryValidInformation[i] ==TRUE)
          {   
            nextElement =i; 
            i= AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
          }
          else
            nextElement =0;
        }
      }
      else    //start at first element
      {
        nextElement =0;
        for(i =nextElement; i<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;i++)
        {
          if(gReceptionList_ListEntryValidInformation[i] ==TRUE)
          {   
            nextElement =i; 
            i =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE;
          }   
        }
      }
    break;
    case AUDIO_RECEPTIONLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
      nextElement = --currentElement;
      if (nextElement ==0 && gReceptionList_ListEntryValidInformation[nextElement] ==TRUE)
        nextElement =0;
      else if (nextElement>0) 
      {
        for(i =nextElement; i>0; i--)
        {
          if(gReceptionList_ListEntryValidInformation[i] ==TRUE)
          {   
            nextElement =i; 
            i =0;
          }
          else
            nextElement =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE-1;
        }
      }    
      else    //start at last element
      {
        nextElement =AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE-1;
        for(i =nextElement; i>0; i--)
        {
          if(gReceptionList_ListEntryValidInformation[i] ==TRUE)
          {   
            nextElement =i; 
            i =0;
          }
          else if(gReceptionList_ListEntryValidInformation[0] ==TRUE)
            nextElement =0;          
        }
      }
    break;
    default:
    break;
  }
  return(nextElement);
}

int ReceptionList_GetNextLineInCache (int currentElement,byte direction)
{
  int i=0, nextElement=0;

  switch (direction)
  {
    case FORWARD:              
      if(currentElement<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
        nextElement = ++currentElement;  
      else if (currentElement ==8)            
        nextElement =0;
      else
        nextElement =AUDIO_RECEPTIONLIST_NO_NEXT_POSITION;
    break;
    case BACKWARD:
      if(currentElement<AUDIO_RECEPTIONLIST_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
        nextElement =--currentElement;
      else if (currentElement ==0)            
        nextElement =8;
      else
        nextElement =AUDIO_RECEPTIONLIST_NO_NEXT_POSITION;
    break;
    default:
    break;
  }
  return(nextElement);
}

//*************************************************************************
//*****************RadioTV_PresetList**************************************
on envVar env_ASG_AudioSD_RTPL_GetArray
{
  byte mode, shift, direction, transmitpos, indexsize,recordaddress;
  word requested_startelement, startelement, elements;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;

  if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gRadioTVPresetList_ListHandlingType ==AUDIO_RADIOTVPRESETLIST_NOCACHE)
  {
    gRadioTVPresetList_ASGID        =getvalue(env_ASG_AudioSD_RTPL_ASGID);
    gRadioTVPresetList_TAID         =getvalue(env_ASG_AudioSD_RTPL_TAID);
    shift                           =getvalue(env_ASG_AudioSD_RTPL_AH_shift);
    direction                       =getvalue(env_ASG_AudioSD_RTPL_AH_dir);
    transmitpos                     =getvalue(env_ASG_AudioSD_RTPL_AH_PosTrans);
    recordaddress                   =getvalue(env_ASG_AudioSD_RTPL_AH_RA);
    indexsize                       =getvalue(env_ASG_AudioSD_RTPL_AH_IS);
    startelement                    =getvalue(env_ASG_AudioSD_RTPL_AH_start);
    elements                        =getvalue(env_ASG_AudioSD_RTPL_AH_elements);
    requested_startelement  =startelement;
    mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    RadioTVPresetList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
  }
}

void RadioTVPresetList_Indication(dword Indication_array [], int datalength)
{
    byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
    word  startelement, elements, startelement_check, Offset =0;
    int i =0, j=0;
    
    // Init local variables
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    current_element         =0;
    transmitpos             =0;
    length                  =0;
    startelement_check      =0;
    StartElementInCache     =FALSE;
    CacheElements           =FALSE;

		switch (gBAP_Indication[2])
		{
			case Data_IND:
				//get data
                gRadioTVPresetList_ASGID =(Indication_array[3] &0xF0) /0x10;
                gRadioTVPresetList_TAID  =Indication_array[3] &0x0F;             

                gRadioTVPresetList_TotalNumListElements =Indication_array[4];
              
                /***ArrayHeader***/
                mode            =(Indication_array[5] &0xF0) /0x10;
                recordaddress   =Indication_array[5] &0x0F;
                Offset =6;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 
                
                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
                
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gRadioTVPresetList_Pos[i])  
                            i =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;              
                    }
                }
                
                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record
                         
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                              
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {   
                                /*  
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes[current_element] +=Indication_array[Offset] *0x100;
                                        Offset++;
                                        
                                        gRadioTVPresetList_Attributes_IBOC_Bit0[current_element]        =(gRadioTVPresetList_Attributes[current_element] &0x01);
                                        gRadioTVPresetList_Attributes_DABSecServ_Bit1[current_element]  =(gRadioTVPresetList_Attributes[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[current_element] =(gRadioTVPresetList_Attributes[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes_TP_Bit5[current_element]          =(gRadioTVPresetList_Attributes[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes_TMC_Bit6[current_element]         =(gRadioTVPresetList_Attributes[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes_SDRAS_Bit7[current_element]       =(gRadioTVPresetList_Attributes[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes_StationSelect_Bit8[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x100) /0x100;
                                        gRadioTVPresetList_Attributes_OnRadMute_Bit9[current_element]    =(gRadioTVPresetList_Attributes[current_element] &0x200) /0x200;
                                        gRadioTVPresetList_Attributes_StationLinked_BitA[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x400) /0x400;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                                */
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                /*    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes[current_element] +=Indication_array[Offset] *0x100;
                                        Offset++;
                                        
                                        gRadioTVPresetList_Attributes_IBOC_Bit0[current_element]        =(gRadioTVPresetList_Attributes[current_element] &0x01);
                                        gRadioTVPresetList_Attributes_DABSecServ_Bit1[current_element]  =(gRadioTVPresetList_Attributes[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[current_element] =(gRadioTVPresetList_Attributes[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes_TP_Bit5[current_element]          =(gRadioTVPresetList_Attributes[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes_TMC_Bit6[current_element]         =(gRadioTVPresetList_Attributes[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes_SDRAS_Bit7[current_element]       =(gRadioTVPresetList_Attributes[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes_StationSelect_Bit8[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x100) /0x100;
                                        gRadioTVPresetList_Attributes_OnRadMute_Bit9[current_element]    =(gRadioTVPresetList_Attributes[current_element] &0x200) /0x200;
                                        gRadioTVPresetList_Attributes_StationLinked_BitA[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x400) /0x400;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                                */
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> PresetIndex, Waveband, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes1_Bit0[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x01);
                                        gRadioTVPresetList_Attributes1_Bit1[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes1_Bit2[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes1_Bit3[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes1_Bit4[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes1_Bit5[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes1_Bit6[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes1_Bit7[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes2_Bit0[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x01) /0x01;
                                        gRadioTVPresetList_Attributes2_Bit1[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes2_Bit2[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes2_Bit3[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes2_Bit4[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x10) /0x10;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH;i++) //clear
			                                gRadioTVPresetList_Frequency[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes1_Bit0[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x01);
                                        gRadioTVPresetList_Attributes1_Bit1[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes1_Bit2[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes1_Bit3[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes1_Bit4[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes1_Bit5[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes1_Bit6[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes1_Bit7[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes2_Bit0[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x01) /0x01;
                                        gRadioTVPresetList_Attributes2_Bit1[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes2_Bit2[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes2_Bit3[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes2_Bit4[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x10) /0x10;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH;i++) //clear
			                                gRadioTVPresetList_Frequency[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends 
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> PresetIndex, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                                                        
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                   case 3: //recordaddress =3 -> PresetIndex, Waveband, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends 
                     break; //recordaddress =3 ends 
                     case 4: //recordaddress =4 -> PresetIndex, Waveband, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends 
                     break; //recordaddress =4 ends   
                    case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_RTPL_ASGID, gRadioTVPresetList_ASGID);
                putvalue(env_ASG_AudioSD_RTPL_TAID, gRadioTVPresetList_TAID);
                putvalue(env_ASG_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements);

                gRadioTVPresetList_recordaddress =recordaddress;
                gRadioTVPresetList_transmitpos   =transmitpos;             
            
			break;

            case Changed_IND:
                //get data
                /***ArrayHeader***/
                mode            =(Indication_array[3] &0xF0) /0x10;
                recordaddress   =Indication_array[3] &0x0F;
                Offset =4;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gRadioTVPresetList_Pos[i])  
                            i =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;              
                    }
                }
                
                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
                {
                    putvalue(env_ASG_AudioSD_RTPL_OnOff, FALSE);
                    putvalue(env_ASG_AudioSD_RTPL_ListOpState, "'full range update' received");
                }
                else if (datalength>8)
                {
                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                              /*
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes[current_element] +=Indication_array[Offset] *0x100;
                                        Offset++;
                                        
                                        gRadioTVPresetList_Attributes_IBOC_Bit0[current_element]        =(gRadioTVPresetList_Attributes[current_element] &0x01);
                                        gRadioTVPresetList_Attributes_DABSecServ_Bit1[current_element]  =(gRadioTVPresetList_Attributes[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[current_element] =(gRadioTVPresetList_Attributes[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes_TP_Bit5[current_element]          =(gRadioTVPresetList_Attributes[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes_TMC_Bit6[current_element]         =(gRadioTVPresetList_Attributes[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes_SDRAS_Bit7[current_element]       =(gRadioTVPresetList_Attributes[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes_StationSelect_Bit8[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x100) /0x100;
                                        gRadioTVPresetList_Attributes_OnRadMute_Bit9[current_element]    =(gRadioTVPresetList_Attributes[current_element] &0x200) /0x200;
                                        gRadioTVPresetList_Attributes_StationLinked_BitA[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x400) /0x400;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                                */
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                /*  
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes[current_element] +=Indication_array[Offset] *0x100;
                                        Offset++;
                                        
                                        gRadioTVPresetList_Attributes_IBOC_Bit0[current_element]        =(gRadioTVPresetList_Attributes[current_element] &0x01);
                                        gRadioTVPresetList_Attributes_DABSecServ_Bit1[current_element]  =(gRadioTVPresetList_Attributes[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[current_element] =(gRadioTVPresetList_Attributes[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes_OnRadSecondary_Bit3[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes_OnRadPrimary_Bit4[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes_TP_Bit5[current_element]          =(gRadioTVPresetList_Attributes[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes_TMC_Bit6[current_element]         =(gRadioTVPresetList_Attributes[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes_SDRAS_Bit7[current_element]       =(gRadioTVPresetList_Attributes[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes_StationSelect_Bit8[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x100) /0x100;
                                        gRadioTVPresetList_Attributes_OnRadMute_Bit9[current_element]    =(gRadioTVPresetList_Attributes[current_element] &0x200) /0x200;
                                        gRadioTVPresetList_Attributes_StationLinked_BitA[current_element]=(gRadioTVPresetList_Attributes[current_element] &0x400) /0x400;
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                                */
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> PresetIndex, Waveband, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }                               
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes1_Bit0[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x01);
                                        gRadioTVPresetList_Attributes1_Bit1[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes1_Bit2[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes1_Bit3[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes1_Bit4[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes1_Bit5[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes1_Bit6[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes1_Bit7[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes2_Bit0[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x01) /0x01;
                                        gRadioTVPresetList_Attributes2_Bit1[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes2_Bit2[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes2_Bit3[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes2_Bit4[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x10) /0x10;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH;i++) //clear
			                                gRadioTVPresetList_Frequency[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_Attributes1_Bit0[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x01);
                                        gRadioTVPresetList_Attributes1_Bit1[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes1_Bit2[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes1_Bit3[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes1_Bit4[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x10) /0x10;
                                        gRadioTVPresetList_Attributes1_Bit5[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x20) /0x20;
                                        gRadioTVPresetList_Attributes1_Bit6[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x40) /0x40;
                                        gRadioTVPresetList_Attributes1_Bit7[current_element]  =(gRadioTVPresetList_Attributes1[current_element] &0x80) /0x80;
                                        gRadioTVPresetList_Attributes2_Bit0[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x01) /0x01;
                                        gRadioTVPresetList_Attributes2_Bit1[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x02) /0x02;
                                        gRadioTVPresetList_Attributes2_Bit2[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x04) /0x04;
                                        gRadioTVPresetList_Attributes2_Bit3[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x08) /0x08;
                                        gRadioTVPresetList_Attributes2_Bit4[current_element]  =(gRadioTVPresetList_Attributes2[current_element] &0x10) /0x10;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH;i++) //clear
			                                gRadioTVPresetList_Frequency[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends 
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> PresetIndex, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                                                        
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                   case 3: //recordaddress =3 -> PresetIndex, Waveband, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }                               
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PresetIndex
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PresetIndex[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++) //clear
			                                gRadioTVPresetList_Name[current_element][i] =0; 
                                    }  
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gRadioTVPresetList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                                                        
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends 
                     break; //recordaddress =3 ends 
                    case 4: //recordaddress =4 -> PresetIndex, Waveband, Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }                               
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gRadioTVPresetList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gRadioTVPresetList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends 
                     break; //recordaddress =4 ends    
                    case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gRadioTVPresetList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gRadioTVPresetList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gRadioTVPresetList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gRadioTVPresetList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gRadioTVPresetList_Pos[i] && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gRadioTVPresetList_ListHandlingType !=AUDIO_RADIOTVPRESETLIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gRadioTVPresetList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gRadioTVPresetList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gRadioTVPresetList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gRadioTVPresetList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gRadioTVPresetList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =RadioTVPresetList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }                  
                }
                gRadioTVPresetList_recordaddress =recordaddress;
                gRadioTVPresetList_transmitpos   =transmitpos;             
            
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD RadioTVPresetList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD RadioTVPresetList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD RadioTVPresetList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD RadioTVPresetList_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD RadioTVPresetList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
/*
    //for "sliding window concept"
    if(gRadioTVPresetList_TotalNumListElements<=AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE)
        gRadioTVPresetList_SlidingWindow_State =AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_NOTACTIVE;
    else
        gRadioTVPresetList_SlidingWindow_State =AUDIO_RADIOTVPRESETLIST_SLIDINGWINDOW_ACTIVE;

    if (gRadioTVPresetList_CallBackReason !=AUDIO_RADIOTVPRESETLIST_CALLBACKREASON_NOCALLBACK)
        RadioTVPresetList_ListHandling ();
    else
        RadioTVPresetList_display();
*/
}

void RadioTVPresetList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
  int  i;
  dword requestarray [BAP_BUFFER_SIZE], Offset;
  word indexsize;

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  indexsize   =0;
  Offset      =0;

  // decode "mode-byte"
  indexsize   =(mode &0x08)/0x08; 
  // Handle request.
  requestarray[0] =LSG_AudioSD;	            //LSG-ID
	requestarray[1] =FctID_RadioTV_PresetList;	//Fct.-ID
	requestarray[2] =request;                   //request type
    
  switch(request)
	{
    case DataGet_REQ:            
      requestarray[3] =((gRadioTVPresetList_ASGID *0x10) &0xF0) +(gRadioTVPresetList_TAID &0x0F);
      /***ArrayHeader***/
	    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
      Offset =5;
      if(indexsize)
      {
          requestarray[Offset] =requested_startelement &0x00FF;
          Offset++;
          requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
          Offset++;  
          requestarray[Offset] =elements &0x00FF;
          Offset++;
          requestarray[Offset] =(elements &0xFF00) /0x100;
          Offset++;       
      }
      else
      {
          requestarray[Offset] =requested_startelement;
          Offset++;
          requestarray[Offset] =elements;
          Offset++;
      }
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD RadioTVPresetList_Request: invalid request %d", request);
		break;
    }
}

int RadioTVPresetList_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE;
                        }   
                    }
                }
        break;

        case AUDIO_RADIOTVPRESETLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gRadioTVPresetList_ListEntryValidInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gRadioTVPresetList_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gRadioTVPresetList_ListEntryValidInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int RadioTVPresetList_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_RADIOTVPRESETLIST_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_RADIOTVPRESETLIST_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

//*************************************************************************
//*****************ListSetup***********************************************
on envVar env_ASG_AudioSD_LS_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    ListSetup_Request(DataGet_REQ);
}

on envVar env_ASG_AudioSD_LS_setget
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
	{
    gAudioSD_ListSetup_PreferredList =getvalue(env_ASG_AudioSD_LS_PrefList);
    //gAudioSD_ListSetup_PreferredList =getvalue(env_ASG_AudioSD_LS_Reserve);
    gAudioSD_ListSetup_Extension1 =getvalue(env_ASG_AudioSD_LS_Ext1);
    gAudioSD_ListSetup_Extension2 =getvalue(env_ASG_AudioSD_LS_Ext2);
    gAudioSD_ListSetup_Extension3 =getvalue(env_ASG_AudioSD_LS_Ext3);
    gAudioSD_ListSetup_Extension4 =getvalue(env_ASG_AudioSD_LS_Ext4);
    ListSetup_Request(DataSetGet_REQ);
  }
}

void ListSetup_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
      gAudioSD_ListSetup_PreferredList      =Indication_array[3];
      gAudioSD_ListSetup_ReceptionListType  =Indication_array[4];
      gAudioSD_ListSetup_Extension1         =Indication_array[5];
      gAudioSD_ListSetup_Extension2          =Indication_array[6];
      gAudioSD_ListSetup_Extension3          =Indication_array[7];
      gAudioSD_ListSetup_Extension4          =Indication_array[8];
      //Panel
      putvalue(env_ASG_AudioSD_LS_PrefList, gAudioSD_ListSetup_PreferredList);
      putvalue(env_ASG_AudioSD_LS_RLType, gAudioSD_ListSetup_ReceptionListType);
      putvalue(env_ASG_AudioSD_LS_Ext1, gAudioSD_ListSetup_Extension1);
      putvalue(env_ASG_AudioSD_LS_Ext2, gAudioSD_ListSetup_Extension2);
      putvalue(env_ASG_AudioSD_LS_Ext3, gAudioSD_ListSetup_Extension3);
      putvalue(env_ASG_AudioSD_LS_Ext4, gAudioSD_ListSetup_Extension4);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD ListSetup_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD ListSetup_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD ListSetup_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD ListSetup_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD ListSetup_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void ListSetup_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_ListSetup;	//Fct.-ID
	requestarray[2] =request;           //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
    case DataSetGet_REQ:
      requestarray[3] = gAudioSD_ListSetup_PreferredList;
      requestarray[4] = 0x00;         //Reserve
      requestarray[5] = gAudioSD_ListSetup_Extension1;
      requestarray[6] = gAudioSD_ListSetup_Extension2;
      requestarray[7] = gAudioSD_ListSetup_Extension3;
      requestarray[8] = gAudioSD_ListSetup_Extension4;
			set_status_requestbuffer (requestarray, 9, Bap_ByteSequence);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD ListSetup_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************SourceList**********************************************
on envVar env_ASG_AudioSD_SL_GetArray
{
  byte mode, shift, direction, transmitpos, indexsize,recordaddress;
  word requested_startelement, startelement, elements;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;

  if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gSourceList_ListHandlingType ==AUDIO_SOURCELIST_NOCACHE)
	{
        gSourceList_ASGID            =getvalue(env_ASG_AudioSD_SL_ASGID);
        gSourceList_TAID             =getvalue(env_ASG_AudioSD_SL_TAID);

        shift                           =getvalue(env_ASG_AudioSD_SL_AH_shift);
        direction                       =getvalue(env_ASG_AudioSD_SL_AH_dir);
        transmitpos                     =getvalue(env_ASG_AudioSD_SL_AH_PosTrans);
        indexsize                       =getvalue(env_ASG_AudioSD_SL_AH_IS);
        recordaddress                   =getvalue(env_ASG_AudioSD_SL_AH_RA);
        startelement                    =getvalue(env_ASG_AudioSD_SL_AH_start);
        elements                        =getvalue(env_ASG_AudioSD_SL_AH_elements);
        
        requested_startelement  =startelement;
        mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        SourceList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
    }
}

SourceList_Indication (dword Indication_array [], int datalength)
{
    byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
    word  startelement, elements, startelement_check, Offset =0;
    int i =0, j=0;

    // Init local variables
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    current_element         =0;
    transmitpos             =0;
    length                  =0;
    startelement_check      =0;
    StartElementInCache     =FALSE;
    CacheElements           =FALSE;
    
		switch (gBAP_Indication[2])
		{
			case Data_IND:
				//get data
                gSourceList_ASGID =(Indication_array[3] &0xF0) /0x10;
                gSourceList_TAID  =Indication_array[3] &0x0F;             

                gSourceList_TotalNumListElements =Indication_array[4];
                gSourceList_TotalNumListElements +=(Indication_array[5] *0x100);
              
                /***ArrayHeader***/
                mode            =(Indication_array[6] &0xF0) /0x10;
                recordaddress   =Indication_array[6] &0x0F;
                Offset =7;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gSourceList_Pos[i])  
                            i =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                              /*
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                        
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                                */
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                /*    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                            
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                                */
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> SourceType, InstanceID, MediaType, Attributes
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                    gSourceList_Name[current_element][i] =0; 
                                    }   
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                    gSourceList_Name[current_element][i] =0; 
                                    }   
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 3: //recordaddress =3 -> Attributes
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                    gSourceList_Name[current_element][i] =0; 
                                    }   
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                    gSourceList_Name[current_element][i] =0; 
                                    }   
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends
                    
                    case 4: //recordaddress =4 -> Mediatype
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends 
                    case 5: //recordaddress =5 -> SourceType, InstanceID, MediaType, Attributes
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =5 ends
                    case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_SL_ASGID, gSourceList_ASGID);
                putvalue(env_ASG_AudioSD_SL_TAID, gSourceList_TAID);
                putvalue(env_ASG_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements);

                gSourceList_recordaddress =recordaddress;
                gSourceList_transmitpos   =transmitpos;             
            
			break;

            case Changed_IND:
                //get data
                /***ArrayHeader***/
                mode            =(Indication_array[3] &0xF0) /0x10;
                recordaddress   =Indication_array[3] &0x0F;
                Offset =4;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
                
                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==65535) //check 'full range update'?
                {
                    putvalue(env_ASG_AudioSD_SL_OnOff, FALSE);
                    putvalue(env_ASG_AudioSD_SL_ListOpState, "'full range update' received");
                }
                else if (datalength>8)
                {
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gSourceList_Pos[i])  
                            i =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                              /*
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                                */
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                /*    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //MediaType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_MediaType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        
                                        gSourceList_Attributes_BuiltIn_Bit0[current_element]    =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_MediaError_Bit1[current_element] =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_MediaPlay_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_MediaRead_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_MediaLoad_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_ImportRun_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_MediaSupp_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                             
                                    }

                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                gSourceList_Name[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                                */
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> SourceType, InstanceID, MediaType, Attributes
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                    gSourceList_Name[current_element][i] =0; 
                                    }   
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                    gSourceList_Name[current_element][i] =0; 
                                    }   
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> Name
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //SourceType
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_SourceType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }                                    
                                    //InstanceID
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_InstanceID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                                                        
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                    
                    case 3: //recordaddress =3 -> Attributes
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                    gSourceList_Name[current_element][i] =0; 
                                    }   
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_SOURCELIST_NAME_LENGTH;i++) //clear
			                                    gSourceList_Name[current_element][i] =0; 
                                    }   
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gSourceList_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends
                    
                    case 4: //recordaddress =4 -> Mediatype
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Attributes
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_Attributes[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_Attributes_Bit0[current_element]  =(gSourceList_Attributes[current_element] &0x01);
                                        gSourceList_Attributes_Bit1[current_element]  =(gSourceList_Attributes[current_element] &0x02) /0x02;
                                        gSourceList_Attributes_Bit2[current_element]  =(gSourceList_Attributes[current_element] &0x04) /0x04; 
                                        gSourceList_Attributes_Bit3[current_element]  =(gSourceList_Attributes[current_element] &0x08) /0x08;
                                        gSourceList_Attributes_Bit4[current_element]  =(gSourceList_Attributes[current_element] &0x10) /0x10;
                                        gSourceList_Attributes_Bit5[current_element]  =(gSourceList_Attributes[current_element] &0x20) /0x20;
                                        gSourceList_Attributes_Bit6[current_element]  =(gSourceList_Attributes[current_element] &0x40) /0x40;                                         
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends 
                    case 5: //recordaddress =5 -> SourceType, InstanceID, MediaType, Attributes
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gSourceList_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gSourceList_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =5 ends
                    case 15: //recordaddress =0xf -> Pos
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gSourceList_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gSourceList_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gSourceList_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gSourceList_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gSourceList_Pos[i] && gSourceList_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gSourceList_ListHandlingType !=AUDIO_SOURCELIST_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gSourceList_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =SourceList_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_SOURCELIST_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gSourceList_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gSourceList_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gSourceList_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gSourceList_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gSourceList_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =SourceList_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }                  

                gSourceList_recordaddress =recordaddress;
                gSourceList_transmitpos   =transmitpos;             
                }
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD SourceList_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD SourceList_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
/*
    //for "sliding window concept"
    if(gSourceList_TotalNumListElements<=AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE)
        gSourceList_SlidingWindow_State =AUDIO_SOURCELIST_SLIDINGWINDOW_NOTACTIVE;
    else
        gSourceList_SlidingWindow_State =AUDIO_SOURCELIST_SLIDINGWINDOW_ACTIVE;

    if (gSourceList_CallBackReason !=AUDIO_SOURCELIST_CALLBACKREASON_NOCALLBACK)
        SourceList_ListHandling ();
    else
        SourceList_display();
*/    
}

void SourceList_Request (byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
  int  i;
  dword requestarray [BAP_BUFFER_SIZE], Offset;
  word indexsize;

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  
  indexsize   =0;
  Offset      =0;

  // decode "mode-byte"
  indexsize   =(mode &0x08)/0x08; 

  // Handle request.
  requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_SourceList;	    //Fct.-ID
	requestarray[2] =request;               //request type

  switch(request)
	{
    case DataGet_REQ:              
      requestarray[3] =((gSourceList_ASGID *0x10) &0xF0) +(gSourceList_TAID &0x0F);
      /***ArrayHeader***/
	    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
      Offset =5;
      if(indexsize)
      {
          requestarray[Offset] =requested_startelement &0x00FF;
          Offset++;
          requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
          Offset++;  
          requestarray[Offset] =elements &0x00FF;
          Offset++;
          requestarray[Offset] =(elements &0xFF00) /0x100;
          Offset++;       
      }
      else
      {
          requestarray[Offset] =requested_startelement;
          Offset++;
          requestarray[Offset] =elements;
          Offset++;
      }
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD SourceList_Request: invalid request %d", request);
		break;
    }
}

int SourceList_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_SOURCELIST_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gSourceList_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gSourceList_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE;
                        }   
                    }
                }
        break;

        case AUDIO_SOURCELIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gSourceList_ListEntryValidInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gSourceList_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gSourceList_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gSourceList_ListEntryValidInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int SourceList_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_SOURCELIST_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_SOURCELIST_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_SOURCELIST_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

//*************************************************************************
//*****************DedicatedAudioControl***********************************
on envVar env_ASG_AudioSD_DAC_SR
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
	{
		gAudioSD_DAC_ControlType            =getvalue(env_ASG_AudioSD_DAC_CT);
    gAudioSD_DAC_AsgId                  =getvalue(env_ASG_AudioSD_DAC_AsgID);
    gAudioSD_DAC_Extension1             =getvalue(env_ASG_AudioSD_DAC_Ext1);
    gAudioSD_DAC_ListType               =getvalue(env_ASG_AudioSD_DAC_LT);
    gAudioSD_DAC_AdditionalControlInfo  =getvalue(env_ASG_AudioSD_DAC_FSGHandle);
    putvalue(env_ASG_AudioSD_DAC_Err,0);
    putvalue(env_ASG_AudioSD_DAC_Err_s,empty_string);
    putvalue(env_ASG_AudioSD_DAC_Res_s,empty_string);
    DedicatedAudioControl_Request(StartResult_REQ, 0);
	}
}

on envVar env_ASG_AudioSD_DAC_Abort
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
  {        
    putvalue(env_ASG_AudioSD_DAC_Err,0);
    putvalue(env_ASG_AudioSD_DAC_Err_s,empty_string);
    putvalue(env_ASG_AudioSD_DAC_Res_s,empty_string);
    DedicatedAudioControl_Request(AbortResult_REQ, 0);
  }
}

void DedicatedAudioControl_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
      gAudioSD_DAC_AsgId =Indication_array[3]/0x10;
      gAudioSD_DAC_Extension1 =Indication_array[3]&0x0F;
      gAudioSD_DAC_Result =Indication_array[4];
      putvalue(env_ASG_AudioSD_DAC_AsgID, gAudioSD_DAC_AsgId);             
      putvalue(env_ASG_AudioSD_DAC_Ext1, gAudioSD_DAC_Extension1);
      putvalue(env_ASG_AudioSD_DAC_Res, gAudioSD_DAC_Result);
		break;
		case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD DedicatedAudioControl_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD DedicatedAudioControl_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD DedicatedAudioControl_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
			{	
        writelineEx(gError_Trace, 0, "ASG-AudioSD DedicatedAudioControl_Indication: Application-Error: 0x%x", Indication_array[3]);
        putvalue(env_ASG_AudioSD_DAC_Err,Indication_array[3]);
        if (Indication_array[3] ==0)
            putvalue(env_ASG_AudioSD_DAC_Err_s,"no error");
        else if((Indication_array[3]-0x40)<17)
            putvalue(env_ASG_AudioSD_DAC_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
        else
            putvalue(env_ASG_AudioSD_DAC_Err_s,gstring_reserved);
      }	
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD DedicatedAudioControl_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

void DedicatedAudioControl_Request (byte request, byte errorcode)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	                //LSG-ID
	requestarray[1] =FctID_DedicatedAudioControl;	//Fct.-ID
	requestarray[2] =request;                       //request type
  switch(request)
	{
		case StartResult_REQ:
      requestarray[3] =(gAudioSD_DAC_AsgId*0x10)+(gAudioSD_DAC_Extension1&0x0F);
      requestarray[4] = gAudioSD_DAC_ControlType;                 
	    requestarray[5] = gAudioSD_DAC_AdditionalControlInfo &0x00FF;
      requestarray[6] =(gAudioSD_DAC_AdditionalControlInfo &0xFF00) /0x100;
      requestarray[7] = gAudioSD_DAC_ListType;
			set_status_requestbuffer (requestarray, 8, Bap_ByteSequence);
		break;
    case AbortResult_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD DedicatedAudioControl_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************SwitchSource********************************************
on envVar env_ASG_AudioSD_SwSource_SR
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
	{
		gAudioSD_SwitchSource_AsgId      = getvalue(env_ASG_AudioSD_SwSource_AsgID);
    gAudioSD_SwitchSource_Extension1 = getvalue(env_ASG_AudioSD_SwSource_Ext1);
    gAudioSD_SwitchSource_ControlType= getvalue(env_ASG_AudioSD_SwSource_CT);
    gAudioSD_SwitchSource_Reference  = getvalue(env_ASG_AudioSD_SwSource_Ref);
    putvalue(env_ASG_AudioSD_SwSource_Err,0);
    putvalue(env_ASG_AudioSD_SwSource_Err_s,empty_string);
    putvalue(env_ASG_AudioSD_SwSource_Res_s,empty_string);
    SwitchSource_Request(StartResult_REQ, 0);
	}
}

on envVar env_ASG_AudioSD_SwSource_abort
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
  {
    putvalue(env_ASG_AudioSD_SwSource_Err,0);
    putvalue(env_ASG_AudioSD_SwSource_Err_s,empty_string);
    putvalue(env_ASG_AudioSD_SwSource_Res_s,empty_string);
    SwitchSource_Request(AbortResult_REQ, 0);
  }
}

void SwitchSource_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
      gAudioSD_SwitchSource_AsgId =(Indication_array[3]&0xF0)/0x10;
      gAudioSD_SwitchSource_Extension1 =Indication_array[3]&0x0F;
      gAudioSD_SwitchSource_Result =Indication_array[4];
		  putvalue(env_ASG_AudioSD_SwSource_AsgID, gAudioSD_SwitchSource_AsgId);
      putvalue(env_ASG_AudioSD_SwSource_Ext1, gAudioSD_SwitchSource_Extension1);
      putvalue(env_ASG_AudioSD_SwSource_Res, gAudioSD_SwitchSource_Result);
		break;
		case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchSource_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchSource_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchSource_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
			{	
        writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchSource_Indication: Application-Error: 0x%x", Indication_array[3]);
        putvalue(env_ASG_AudioSD_SwSource_Err,Indication_array[3]);
        if (Indication_array[3] ==0)
          putvalue(env_ASG_AudioSD_SwSource_Err_s,"no error");
        else if((Indication_array[3]-0x40)<17)
          putvalue(env_ASG_AudioSD_SwSource_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
        else
          putvalue(env_ASG_AudioSD_SwSource_Err_s,gstring_reserved); 
      }
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD SwitchSource_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

void SwitchSource_Request (byte request, byte errorcode)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	                //LSG-ID
	requestarray[1] =FctID_SwitchSource;	    //Fct.-ID
	requestarray[2] =request;                       //request type
  switch(request)
	{
		case StartResult_REQ:
      requestarray[3] = gAudioSD_SwitchSource_AsgId*0x10;                 
	    requestarray[3] +=gAudioSD_SwitchSource_Extension1&0x0F;
      requestarray[4] =gAudioSD_SwitchSource_ControlType;
      requestarray[5] = gAudioSD_SwitchSource_Reference&0x00FF;
      requestarray[6] =(gAudioSD_SwitchSource_Reference&0xFF00)/0x100;
			set_status_requestbuffer (requestarray, 7, Bap_ByteSequence);
		break;
    case AbortResult_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD SwitchSource_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************Browser_FolderLevel*************************************
on envVar env_ASG_AudioSD_MeBrLevel_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
      Browser_FolderLevel_Request(DataGet_REQ);
}

void Browser_FolderLevel_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Data_IND:
      //get data
			gAudioSD_MediaBrowser_FL_FolderLevel            =Indication_array[3];
      gAudioSD_MediaBrowser_FL_RefMediaBrowser        =Indication_array[4] +(Indication_array[5] *0x100);
      gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos =Indication_array[6] +(Indication_array[7] *0x100);        
      gAudioSD_MediaBrowser_FL_Extension1             =Indication_array[8];
      //Panel
      putvalue(env_ASG_AudioSD_MeBrLevel_FL, gAudioSD_MediaBrowser_FL_FolderLevel);
      putvalue(env_ASG_AudioSD_MeBrLevel_Ref, gAudioSD_MediaBrowser_FL_RefMediaBrowser);
      putvalue(env_ASG_AudioSD_MeBrLevel_Ref_a, gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos);  
      putvalue(env_ASG_AudioSD_MeBrLevel_Ext1, gAudioSD_MediaBrowser_FL_Extension1);
    break;
    case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserFolderLevel_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserFolderLevel_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserFolderLevel_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD MediaBrowserFolderLevel_Indication: Application-Error: 0x%x", Indication_array[3]);
  	break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-AudioSD MediaBrowserFolderLevel_Indication: unknown indication %x", gBAP_Indication[2]);
  	break;
	}
}

void Browser_FolderLevel_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	                    //LSG-ID
	requestarray[1] =FctID_Browser_FolderLevel;	//Fct.-ID
	requestarray[2] =request;                           //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD Browser_FolderLevel_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************Browser*************************************************
on envVar env_ASG_AudioSD_MB_GetArray
{
  byte mode, shift, direction, transmitpos, indexsize,recordaddress;
  word requested_startelement, startelement, elements;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;

  if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gMediaBrowser_ListHandlingType ==AUDIO_MEDIABROWSER_NOCACHE)
	{
    gMediaBrowser_ASGID            =getvalue(env_ASG_AudioSD_MB_ASGID);
    gMediaBrowser_TAID             =getvalue(env_ASG_AudioSD_MB_TAID);
    gMediaBrowser_ActiveListPos    =getvalue(env_ASG_AudioSD_MB_ActiveListPos);

    shift                           =getvalue(env_ASG_AudioSD_MB_AH_shift);
    direction                       =getvalue(env_ASG_AudioSD_MB_AH_dir);
    transmitpos                     =getvalue(env_ASG_AudioSD_MB_AH_PosTrans);
    indexsize                       =getvalue(env_ASG_AudioSD_MB_AH_IS);
    recordaddress                   =getvalue(env_ASG_AudioSD_MB_AH_RA);
    startelement                    =getvalue(env_ASG_AudioSD_MB_AH_start);
    elements                        =getvalue(env_ASG_AudioSD_MB_AH_elements);
    
    requested_startelement  =startelement;
    mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

    Browser_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
  }
}

void Browser_Indication (dword Indication_array [], int datalength)
{
    byte mode, direction, shift, recordaddress, indexsize, current_element, transmitpos, length, CacheElements, StartElementInCache;
    word  startelement, elements, startelement_check, Offset =0;
    int i =0, j=0;

    // Init local variables
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    current_element         =0;
    transmitpos             =0;
    length                  =0;
    startelement_check      =0;
    StartElementInCache     =FALSE;
    CacheElements           =FALSE;

		switch (gBAP_Indication[2])
		{
			case Data_IND:
				//get data
                gMediaBrowser_ASGID =(Indication_array[3] &0xF0) /0x10;
                gMediaBrowser_TAID  =Indication_array[3] &0x0F;
                
                gMediaBrowser_TotalNumListElements =Indication_array[4];
                gMediaBrowser_TotalNumListElements +=(Indication_array[5] *0x100);
                
                gMediaBrowser_ActiveListPos =Indication_array[6]; 
                gMediaBrowser_ActiveListPos +=(Indication_array[7] *0x100);                              
              
                /***ArrayHeader***/
                mode            =(Indication_array[8] &0xF0) /0x10;
                recordaddress   =Indication_array[8] &0x0F;
                Offset =9;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gMediaBrowser_Pos[i])  
                            i =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;              
                    }
                }

                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                              /*
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }

                                   
                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                                */
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                /*   
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }
                                    
                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                                */
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //RadioCategory
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_RadioCategory[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //RadioCategory
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_RadioCategory[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> FileName
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //RadioCategory
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_RadioCategory[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //RadioCategory
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_RadioCategory[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                   case 3: //recordaddress =3 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends 
                   case 4: //recordaddress =4 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends     
                    case 5: //recordaddress =5 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =5 ends    
                    case 6: //recordaddress =6 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =6 ends    
                    case 7: //recordaddress =7 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =7 ends
                   case 8: //recordaddress =8 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =8 ends     
                    case 9: //recordaddress =9 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =9 ends    
                    case 15: //recordaddress =0xf -> Pos

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                                   
                //Panel
                putvalue(env_ASG_AudioSD_MB_ASGID, gMediaBrowser_ASGID);
                putvalue(env_ASG_AudioSD_MB_TAID, gMediaBrowser_TAID);
                putvalue(env_ASG_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements);
                putvalue(env_ASG_AudioSD_MB_ActiveListPos, gMediaBrowser_ActiveListPos);

                gMediaBrowser_recordaddress =recordaddress;
                gMediaBrowser_transmitpos   =transmitpos;             
            
			break;

            case Changed_IND:
                             
              /***ArrayHeader***/
                mode            =(Indication_array[3] &0xF0) /0x10;
                recordaddress   =Indication_array[3] &0x0F;
                Offset =4;
                
                // decode "mode-byte"
                shift       =mode &0x01;
                direction   =(mode &0x02)/0x02;
                transmitpos =(mode &0x04)/0x04;
                indexsize   =(mode &0x08)/0x08; 

                if (indexsize)
                {   
                    startelement =Indication_array[Offset];
                    Offset++;
                    startelement +=(Indication_array[Offset] *0x100);
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                    elements +=(Indication_array[Offset] *0x100);
                    Offset++;
                }
                else
                {   
                    startelement =Indication_array[Offset];
                    Offset++;

                    elements =Indication_array[Offset];
                    Offset++;
                }           
            
                if(startelement !=0)
                {
                    for (i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(startelement ==gMediaBrowser_Pos[i])  
                            i =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;              
                    }
                }

                if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==65535) //check 'full range update'?
                {
                    putvalue(env_ASG_AudioSD_MB_OnOff, FALSE);
                    putvalue(env_ASG_AudioSD_MB_ListOpState, "'full range update' received");
                }
                else if (datalength>8)
                {
                switch (recordaddress)
                {
                    case 0: //recordaddress =0 -> complete record

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                              /*
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }

                                   
                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                                */
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                /*    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    //FileType
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileType[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState[current_element] +=(Indication_array[Offset] *0x100);
                                        Offset++;
                                        
                                        gMediaBrowser_FileState_emptyFolder_Bit0[current_element]       =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_DRM_Bit1[current_element]               =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_FileCorrupted_Bit2[current_element]     =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_DeadLink_Bit3[current_element]          =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_ImportFinished_Bit4[current_element]    =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_ImportPending_Bit5[current_element]     =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_ImportPlayable_Bit6[current_element]    =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    }
                                    
                                    //FileName
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FILENAME_LENGTH;i++) //clear
			                                gMediaBrowser_FileName[current_element][i] =0; 
                                    }
                                         
                                    length =Indication_array[Offset];
                                    Offset++;
                                    
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_FileName[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                                */
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0 ends
                    
                    case 1: //recordaddress =1 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //RadioCategory
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_RadioCategory[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //RadioCategory
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_RadioCategory[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =1 ends
                    
                    case 2: //recordaddress =2 -> FileName
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //RadioCategory
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_RadioCategory[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //RadioCategory
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_RadioCategory[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FmREG_Code
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FmRegCode[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //PresetID
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PresetID[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =2 ends
                   case 3: //recordaddress =3 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =3 ends 
                    case 4: //recordaddress =4 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Waveband
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Waveband[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    } 
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =4 ends
                    case 5: //recordaddress =5 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Type
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Type[current_element] =Indication_array[Offset];
                                        Offset++;
                                    }
                                    //FileState
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_FileState[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_FileState_Bit0[current_element]   =(gMediaBrowser_FileState[current_element] &0x01);
                                        gMediaBrowser_FileState_Bit1[current_element]   =(gMediaBrowser_FileState[current_element] &0x02) /0x02;
                                        gMediaBrowser_FileState_Bit2[current_element]   =(gMediaBrowser_FileState[current_element] &0x04) /0x04; 
                                        gMediaBrowser_FileState_Bit3[current_element]   =(gMediaBrowser_FileState[current_element] &0x08) /0x08;
                                        gMediaBrowser_FileState_Bit4[current_element]   =(gMediaBrowser_FileState[current_element] &0x10) /0x10;
                                        gMediaBrowser_FileState_Bit5[current_element]   =(gMediaBrowser_FileState[current_element] &0x20) /0x20;
                                        gMediaBrowser_FileState_Bit6[current_element]   =(gMediaBrowser_FileState[current_element] &0x40) /0x40;
                                    } 
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =5 ends    
                    case 6: //recordaddress =6 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Name
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++) //clear
			                                    gMediaBrowser_Name[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Name[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =6 ends    
                   case 7: //recordaddress =7 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Frequency
                                    if(CacheElements ==TRUE)
                                    {
                                        for(i=0; i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++) //clear
			                                    gMediaBrowser_Frequency[current_element][i] =0; 
                                    }
                                    length =Indication_array[Offset];
                                    Offset++;
                                    for(i=0; i<length;i++) //copy data
                                    {   
                                        if(CacheElements ==TRUE)
                                            gMediaBrowser_Frequency[current_element][i] =Indication_array[Offset];
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =7 ends     
                    case 8: //recordaddress =8 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    }
                                    //Attributes1&2
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_Attributes1[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes2[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_Attributes1_Bit0[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x01);
                                        gMediaBrowser_Attributes1_Bit1[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x02) /0x02;
                                        gMediaBrowser_Attributes1_Bit2[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x04) /0x04; 
                                        gMediaBrowser_Attributes1_Bit3[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x08) /0x08;
                                        gMediaBrowser_Attributes1_Bit4[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x10) /0x10;
                                        gMediaBrowser_Attributes1_Bit5[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x20) /0x20;
                                        gMediaBrowser_Attributes1_Bit6[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x40) /0x40;
                                        gMediaBrowser_Attributes1_Bit7[current_element]   =(gMediaBrowser_Attributes1[current_element] &0x80) /0x80;
                                        gMediaBrowser_Attributes2_Bit0[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x01);
                                        gMediaBrowser_Attributes2_Bit1[current_element]   =(gMediaBrowser_Attributes2[current_element] &0x02) /0x02;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =8 ends    
                    case 9: //recordaddress =9 -> FileType, FileState
                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +(Indication_array[Offset+1]*0x100)) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                       
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
          					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
          					        {
          						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
          						        {                                                                                  
                                              current_element     =i;                         //found element is valid_startelement
          						            StartElementInCache =TRUE;
                                              i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                          }
          					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {   
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                startelement_check =0;
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];
                                               
                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {   
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    //POS                                   
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset]; 
                                        }
                                        Offset++;
                                    } 
                                    //PicRef
                                    if(CacheElements ==TRUE)
                                    {
                                        gMediaBrowser_PicRef[current_element] =Indication_array[Offset];
                                        Offset++;
                                        gMediaBrowser_PicRef[current_element] +=(Indication_array[Offset]*0x100);
                                        Offset++;
                                    }

                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =9 ends    
                    case 15: //recordaddress =0xf -> Pos

                        /***startelement ==0***/                        
                        if(0==startelement)
                        {     
                            /***find "start line" in ASG cache***/
                            if(FORWARD ==direction)
                            {    
                                if (gMediaBrowser_cacheDown)
                                {   
                                    current_element         =5; //it's the Pos of last element in ASG cache
                                    
                                    //reset "sliding window" values
                                    gMediaBrowser_cacheDown         =FALSE;
                                }
                                else
                                    current_element =startelement;
                                    
                                if (shift ==TRUE) //startelement not next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);   
                            }
                            
                            else if(BACKWARD ==direction && shift==TRUE)
                            {
                                if(gMediaBrowser_cacheUp)
                                {   
                                    current_element         =6; //it's the Pos of first element in ASG cache
                                    
                                    //reset "sliding window" values
                                        gMediaBrowser_cacheUp           =FALSE;
                                }
                                else 
                                    current_element =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE -1; // position of last element in array 
                            }                 
                                
                            /***copy elements***/
                            if (current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION) 
                            {
                                for (j=0; j<elements;j++) //copy elements
                                {   
                                    //check, if elements must be cached and in case find position in array
                                    CacheElements =FALSE;
                                    for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                    {  
                                        //if element already cached, find position in ASG-cache
                                        if(indexsize ==FALSE && (transmitpos ==TRUE) && Indication_array[Offset] ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        else if((indexsize ==TRUE && (transmitpos ==TRUE) && (Indication_array[Offset] +Indication_array[Offset+1]*100) ==gMediaBrowser_Pos[i] && gMediaBrowser_ListEntryValidInformation[i] ==TRUE))
                                        {   
                                            current_element =i; 
                                            CacheElements   =TRUE;
                                        }
                                        //if not already cached, then store element only, if Cache is build-up!
                                        else if((gMediaBrowser_ListHandlingType !=AUDIO_MEDIABROWSER_NOCACHE))
                                            CacheElements   =TRUE;
                                    }
                                                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                            
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                    
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                                       
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element     
                                }   //copy data of current element finished
                            } //copy of elements finished       
                        } //startelement=0 ends
    
                        /***startelement !=0***/
                        else if (startelement !=0) //startelement !=0
                        {
                            //searching for valid startelement in stored list
					        for(i=0;i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
					        {
						        if(gMediaBrowser_Pos[i] ==startelement)				//found a valid element
						        {                                                                                  
                                    current_element     =i;                         //found element is valid_startelement
						            StartElementInCache =TRUE;
                                    i                   =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                                }
					        }
                            if (StartElementInCache)
                            {   
                                if (shift ==TRUE) //first array element is next element
                                    current_element =MediaBrowser_GetNextLineInCache (current_element, direction);                 
                                    
                                for (j=0; j<elements;j++) //copy elements
                                {
                                    if(current_element !=AUDIO_MEDIABROWSER_NO_NEXT_POSITION)
                                    {
                                        CacheElements =TRUE;
                                        //if element already exist in ASG-cache, search the position 
                                        for (i=0; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE; i++)
                                        {
                                            if((transmitpos ==TRUE) && gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                                            {   
                                                if(indexsize)
                                                    startelement_check =Indication_array[Offset] +(Indication_array[Offset+1]*0x100); 
                                                else
                                                    startelement_check =Indication_array[Offset];

                                                if(startelement_check ==gMediaBrowser_Pos[i])
                                                {
                                                    current_element =i; 
                                                    CacheElements   =TRUE;
                                                }
                                                startelement_check=0;
                                            }  
                                        }
                                    }
                                    else
                                        CacheElements =FALSE;
                                        
                                    if (transmitpos)
                                    {   
                                        if(CacheElements ==TRUE)
                                        {   
                                            if(indexsize)
                                            {    
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                                Offset++;
                                                gMediaBrowser_Pos[current_element] +=Indication_array[Offset] *0x100;
                                            }
                                            else
                                                gMediaBrowser_Pos[current_element] =Indication_array[Offset];
                                        }
                                        Offset++;
                                    }
                                    
                                    if(CacheElements ==TRUE)                                   
                                        gMediaBrowser_ListEntryValidInformation [current_element] =TRUE;
                                    
                                    if(CacheElements ==TRUE)    
                                        current_element =MediaBrowser_GetNextLineInCache (current_element, direction); //go on with next element       
                                }   //copy data of current element finished
                            }       //copy of elements finished
                        }           //startelement !=0 ends
                     break; //recordaddress =0xf ends
                }
                }                   
                
                //Panel
                gMediaBrowser_recordaddress =recordaddress;
                gMediaBrowser_transmitpos   =transmitpos;             
            
            break;
			
            case Error_IND:
					
				if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD Browser_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
				else if(Indication_array[3]<0x30)			//BPL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD Browser_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
				else if(Indication_array[3]<0x40)			//BAL-error
					writelineEx(gError_Trace, 0, "ASG-AudioSD Browser_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
				else
					writelineEx(gError_Trace, 0, "ASG-AudioSD Browser_Indication: Application-Error: 0x%x", Indication_array[3]);
				
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD Browser_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
		}
/*
    //for "sliding window concept"
    if(gMediaBrowser_TotalNumListElements<=AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE)
        gMediaBrowser_SlidingWindow_State =AUDIO_MEDIABROWSER_SLIDINGWINDOW_NOTACTIVE;
    else
        gMediaBrowser_SlidingWindow_State =AUDIO_MEDIABROWSER_SLIDINGWINDOW_ACTIVE;

    if (gMediaBrowser_CallBackReason !=AUDIO_MEDIABROWSER_CALLBACKREASON_NOCALLBACK)
        MediaBrowser_ListHandling ();
    else
        MediaBrowser_display();
*/
}

void Browser_Request (byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
  int  i;
  dword requestarray [BAP_BUFFER_SIZE], Offset;
  word indexsize;

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  
  indexsize   =0;
  Offset      =0;

  // decode "mode-byte"
  indexsize   =(mode &0x08)/0x08; 

  // Handle request.
  requestarray[0] =LSG_AudioSD;	        //LSG-ID
	requestarray[1] =FctID_Browser;	//Fct.-ID
	requestarray[2] =request;               //request type

  switch(request)
	{
    case DataGet_REQ:              
      requestarray[3] =((gMediaBrowser_ASGID *0x10) &0xF0) +(gMediaBrowser_TAID &0x0F);
      /***ArrayHeader***/
	    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
      Offset =5;
      if(indexsize)
      {
          requestarray[Offset] =requested_startelement &0x00FF;
          Offset++;
          requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
          Offset++;  
          requestarray[Offset] =elements &0x00FF;
          Offset++;
          requestarray[Offset] =(elements &0xFF00) /0x100;
          Offset++;       
      }
      else
      {
          requestarray[Offset] =requested_startelement;
          Offset++;
          requestarray[Offset] =elements;
          Offset++;
      }
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD Browser_Request: invalid request %d", request);
		break;
  }
}

int MediaBrowser_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;i++)
                    {
                        if(gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE;
                        }   
                    }
                }
        break;

        case AUDIO_MEDIABROWSER_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gMediaBrowser_ListEntryValidInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gMediaBrowser_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gMediaBrowser_ListEntryValidInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int MediaBrowser_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_MEDIABROWSER_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_MEDIABROWSER_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_MEDIABROWSER_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

//*************************************************************************
//*****************BrowserPath*********************************************
on envVar env_ASG_AudioSD_MePath_get
{
  if(gASG_PowerOnOff ==POWER_ON && getvalue(this))
    BrowserPath_Request(DataGet_REQ);
}

void BrowserPath_Indication (dword Indication_array [], int datalength)
{
  int i =0;

	switch (gBAP_Indication[2])
	{
		case Data_IND:
      if(datalength>= 2) 
      {
        //get data
  			gAudioSD_MediaPath_FolderType =Indication_array[3];
        //clear
        for (i=0; i<MEDIAPATH_PATH_TEXTLENGTH; i++)
            gAudioSD_MediaPath_Path[i] =0;
        for (i=0; i<Indication_array[4]; i++)
            gAudioSD_MediaPath_Path[i] =Indication_array[5+i];      
        //Panel
        putvalue(env_ASG_AudioSD_MePath_Type, gAudioSD_MediaPath_FolderType);
        putvalue(env_ASG_AudioSD_MePath_Path_s, gAudioSD_MediaPath_Path);
      }
    break;
    case Error_IND:
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
  			writelineEx(gError_Trace, 0, "ASG-AudioSD BrowserPath_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30)			//BPL-error
  			writelineEx(gError_Trace, 0, "ASG-AudioSD BrowserPath_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40)			//BAL-error
  			writelineEx(gError_Trace, 0, "ASG-AudioSD BrowserPath_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  			writelineEx(gError_Trace, 0, "ASG-AudioSD BrowserPath_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD BrowserPath_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void BrowserPath_Request (byte request)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_BrowserPath;   //Fct.-ID
	requestarray[2] =request;           //request type
  switch(request)
	{
		case DataGet_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD BrowserPath_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************BrowserControl******************************************
on envVar env_ASG_AudioSD_MBrC_SR
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
	{
		gAudioSD_MediaBrowserControl_Control    =getvalue(env_ASG_AudioSD_MBrC_Control);
    gAudioSD_MediaBrowserControl_Reference  =getvalue(env_ASG_AudioSD_MBrC_Ref);
    gAudioSD_MediaBrowserControl_AsgId      =getvalue(env_ASG_AudioSD_MBrC_AsgID);
    gAudioSD_MediaBrowserControl_Extension1 =getvalue(env_ASG_AudioSD_MBrC_Ext1);
    putvalue(env_ASG_AudioSD_MBrC_Err,0);
    putvalue(env_ASG_AudioSD_MBrC_Err_s,empty_string);
    putvalue(env_ASG_AudioSD_MBrC_Res_s,empty_string);
    BrowserControl_Request(StartResult_REQ, 0);
	}
}

on envVar env_ASG_AudioSD_MBrC_Abort
{
	if(POWER_ON==gASG_PowerOnOff && TRUE==gBAP_AudioSD_available && getvalue(this))
  {
    putvalue(env_ASG_AudioSD_MBrC_Err,0);
    putvalue(env_ASG_AudioSD_MBrC_Err_s,empty_string);
    putvalue(env_ASG_AudioSD_MBrC_Res_s,empty_string);
    BrowserControl_Request(AbortResult_REQ, 0);
  }
}

void BrowserControl_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
		case Processing_IND:
		break;
		case Result_IND:
      gAudioSD_MediaBrowserControl_AsgId =Indication_array[3]/0x10;
      gAudioSD_MediaBrowserControl_Extension1 =Indication_array[3]&0x0F;
      gAudioSD_MediaBrowserControl_Result =Indication_array[4];
		  putvalue(env_ASG_AudioSD_MBrC_AsgID, gAudioSD_MediaBrowserControl_AsgId);
      putvalue(env_ASG_AudioSD_MBrC_Ext1, gAudioSD_MediaBrowserControl_Extension1);
      putvalue(env_ASG_AudioSD_MBrC_Res, gAudioSD_MediaBrowserControl_Result);
		break;
		case Error_IND:
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD BrowserControl_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD BrowserControl_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD BrowserControl_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
			{	
        writelineEx(gError_Trace, 0, "ASG-AudioSD BrowserControl_Indication: Application-Error: 0x%x", Indication_array[3]);
        putvalue(env_ASG_AudioSD_MBrC_Err,Indication_array[3]);
        if (Indication_array[3] ==0)
          putvalue(env_ASG_AudioSD_MBrC_Err_s,"no error");
        else if((Indication_array[3]-0x40)<17)
          putvalue(env_ASG_AudioSD_MBrC_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
        else
          putvalue(env_ASG_AudioSD_MBrC_Err_s,gstring_reserved); 
      }
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD BrowserControl_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

void BrowserControl_Request (byte request, byte errorcode)
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  // Handle request.
  requestarray[0] =LSG_AudioSD;	                //LSG-ID
	requestarray[1] =FctID_BrowserControl;	    //Fct.-ID
	requestarray[2] =request;                       //request type
  switch(request)
	{
		case StartResult_REQ:
      requestarray[3] = gAudioSD_MediaBrowserControl_AsgId*0x10;                 
	    requestarray[3] +=gAudioSD_MediaBrowserControl_Extension1&0x0F;
      requestarray[4] =gAudioSD_MediaBrowserControl_Control;
      requestarray[5] = gAudioSD_MediaBrowserControl_Reference&0x00FF;
      requestarray[6] =(gAudioSD_MediaBrowserControl_Reference&0xFF00)/0x100;
			set_status_requestbuffer (requestarray, 7, Bap_ByteSequence);
		break;
    case AbortResult_REQ:
			set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
		default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD BrowserControl_Request: invalid request %d", request);
		break;
	}
}

//*************************************************************************
//*****************Picture*************************************************
on envVar env_ASG_AudioSD_Pic_GetArray
{
  byte mode, shift, direction, transmitpos, indexsize,recordaddress;
  word requested_startelement, startelement, elements;
  
  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;

  if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
    gPicture_ASGID                  =getvalue(env_ASG_AudioSD_Pic_ASGID);
    gPicture_TAID                   =getvalue(env_ASG_AudioSD_Pic_TAID);;
    shift                           =getvalue(env_ASG_AudioSD_Pic_AH_shift);;
    direction                       =getvalue(env_ASG_AudioSD_Pic_AH_dir);;
    transmitpos                     =getvalue(env_ASG_AudioSD_Pic_AH_PosTrans);;
    indexsize                       =getvalue(env_ASG_AudioSD_Pic_AH_IS);;
    recordaddress                   =getvalue(env_ASG_AudioSD_Pic_AH_RA);;
    startelement                    =getvalue(env_ASG_AudioSD_Pic_AH_start);;
    elements                        =getvalue(env_ASG_AudioSD_Pic_AH_elements);;
    
    requested_startelement  =startelement;
    mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    //writeEX(gBAP_Trace, 0, "GetArray_indexSize %x",indexsize); //debug
    Picture_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
  }
}

void Picture_Indication(dword Indication_array [], int datalength)
{
  byte mode, direction, shift, recordaddress, transmitpos, length, indexsize, CacheElements;
  word startelement, elements, current_element;
  int i =0, j=0, Offset =0;
  
  // Init local variables
  mode                    =0;
  direction               =0;
  shift                   =0;
  recordaddress           =0;
  startelement            =0;
  elements                =0;
  current_element         =0;
  transmitpos             =0;
  length                  =0;
  CacheElements =FALSE;
  
  write("Debug: Indication_Picture -> ind-type=%d",gBAP_Indication[2]);
  
	switch (gBAP_Indication[2])
	{
		case Data_IND:
		//get data
      gPicture_ASGID =(Indication_array[3] &0xF0) /0x10;
      gPicture_TAID  =Indication_array[3] &0x0F; 
      gPicture_TotalNumListElements =Indication_array[4];
      /***ArrayHeader***/
      mode            =(Indication_array[5] &0xF0) /0x10;
      recordaddress   =Indication_array[5] &0x0F;
      startelement    =Indication_array[6];
      elements        =Indication_array[7];
      Offset =8;
      // decode "mode-byte"
      shift       =mode &0x01;
      direction   =(mode &0x02)/0x02;
      transmitpos =(mode &0x04)/0x04;
      indexsize   =(mode &0x08)/0x08;             
 
      if(startelement !=0)
      {
        for (i=0;i<AUDIO_PICTURE_ENTRIES;i++)
        {
          if(startelement ==gPicture_Pos[i])  
            i =AUDIO_PICTURE_ENTRIES;              
        }
      }
      switch (recordaddress)
      { 
        case 0: //recordaddress =0 -> complete record
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              /*
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }       
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
              */
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              /*
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }    
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished     
              */
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
              /*                  
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
              */
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              /*
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //Handle
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished 
              */
            }
          }          //startelement !=0 ends
        break;         //recordaddress =0 ends
        case 1: //recordaddress =1 -> PicType, IPV6_Address, TCP_Port, URI
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }       
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }    
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //PictureType
                if (CacheElements ==TRUE)
                  gPicture_Type[current_element] =Indication_array[Offset];
                Offset++;
                //IPv6Address
                for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_IpAddress[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                  Offset++;
                } 
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =1 ends
        case 2: //recordaddress =2 -> TCP_Port, URI
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;             
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }       
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element++; //go on with next element  
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
			    	{
              current_element =AUDIO_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  } 
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }    
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is next element
                current_element++;
                                
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element++; //go on with next element    
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;         
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //TCP_Port
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] =Indication_array[Offset];
                Offset++;
                if (CacheElements ==TRUE)
                  gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                Offset++;
                //URI
                for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                {
                  if (CacheElements ==TRUE)
                    gPicture_Uri[current_element][i] =0; 
                }
                length =Indication_array[Offset];
                Offset++;                
                for(i=0; i<length;i++) //copy data
                {   
                  if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =1 ends
        case 15: //recordaddress =15 -> POS 
          if(0==startelement)
          {
            if(FORWARD==direction)  //forward-start
    		    {          
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;                 
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
    		    {
              current_element =AUDIO_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                     
            }       //backward ends
          }          //startelement=0 ends
          else if (startelement !=0) //startelement !=0
          {
            if(FORWARD==direction)  //forward-start
    		    {
              current_element =startelement;
              if (shift ==TRUE) //startelement is next element
                current_element++;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element++; //go on with next element       
              }   //copy data of current element finished
            }       //forward ends
            else if(BACKWARD==direction)
            {
              current_element =startelement; 
              if (shift ==TRUE) //startelement is previous element
                current_element--;
              for (j=0; j<elements;j++) //copy elements
              {
                //check, if elements must be cached and in case find position in array
                CacheElements =FALSE;
                for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                {  
                  //if element already cached, find position in ASG-cache
                  if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                  {    
                    current_element =i; 
                    CacheElements   =TRUE;
                  }
                  //if not already cached, then store element only, if Cache is build-up!
                  else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                    CacheElements   =TRUE;
                }
                //Pos
                if (transmitpos)
                {   
                  if (CacheElements ==TRUE)
                    gPicture_Pos[current_element]=Indication_array[Offset];
                  Offset++;
                }
                //next element
                if (CacheElements ==TRUE)
                  gPicture_ListEntryValidInformation [current_element] =TRUE;
                current_element--;
              }   //copy data of current element finished                                 
            }
          }          //startelement !=0 ends
        break;         //recordaddress =15 ends    
      }                             
      //Panel
      putvalue(env_ASG_AudioSD_Pic_ASGID, gPicture_ASGID);
      putvalue(env_ASG_AudioSD_Pic_TAID, gPicture_TAID);
      putvalue(env_ASG_AudioSD_Pic_TotalNumLE, gPicture_TotalNumListElements);
      
      /*
      if (gPicture_CallBackReason !=AUDIOSD_PICTURE_CALLBACKREASON_NOCALLBACK)
        Picture_ListHandling ();
      else
        Picture_display(recordaddress, transmitpos);         
      */
		break;
    case Changed_IND:
      //get data
      /***ArrayHeader***/
      mode            =(Indication_array[3] &0xF0) /0x10;
      recordaddress   =Indication_array[3] &0x0F;
      Offset =4;
      // decode "mode-byte"
      shift       =mode &0x01;
      direction   =(mode &0x02)/0x02;
      transmitpos =(mode &0x04)/0x04;
      indexsize   =(mode &0x08)/0x08;               
      if (indexsize)
      {   
        startelement =Indication_array[Offset];
        Offset++;
        startelement +=(Indication_array[Offset] *0x100);
        Offset++;
        elements =Indication_array[Offset];
        Offset++;
        elements +=(Indication_array[Offset] *0x100);
        Offset++;
      }
      else
      {   
        startelement =Indication_array[Offset];
        Offset++;
        elements =Indication_array[Offset];
        Offset++;
      }           
      if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
      {
        /*
        putvalue(env_ASG_NaviSD_LG_OnOff, FALSE);
        putvalue(env_ASG_NaviSD_LG_ListOpState, "'full range update' received");
        */
      }
      else if (datalength>9)
      {
        if(startelement !=0)
        {
          for (i=0;i<AUDIO_PICTURE_ENTRIES;i++)
          {
            if(startelement ==gPicture_Pos[i])  
              i =AUDIO_PICTURE_ENTRIES;              
          }
        }
        switch (recordaddress)
        {  
          case 0: //recordaddress =0 -> complete record
            if(0==startelement)
            {
              if(FORWARD==direction)  //forward-start
      		    {          
                current_element =startelement;             
                if (shift ==TRUE) //startelement is next element
                  current_element++;                 
                /*
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }       
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element++; //go on with next element  
                }   //copy data of current element finished
                */
              }       //forward ends
              if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
  			    	{
                current_element =AUDIO_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
                /*
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    } 
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }    
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished   
                */
              }       //backward ends
            }          //startelement=0 ends
            else if (startelement !=0) //startelement !=0
            {
              if(FORWARD==direction)  //forward-start
      		    {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is next element
                  current_element++;
                /*                  
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element++; //go on with next element    
                }   //copy data of current element finished
                */
              }       //forward ends
              else if(BACKWARD==direction)
              {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is previous element
                  current_element--;         
                /*
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //Handle
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_Handle[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished  
                */
              }
            }          //startelement !=0 ends
          break;         //recordaddress =0 ends
          case 1: //recordaddress =1 -> PictureType, Handle, IPV6_Address, TCP_Port, URI
            if(0==startelement)
            {
              if(FORWARD==direction)  //forward-start
      		    {          
                current_element =startelement;             
                if (shift ==TRUE) //startelement is next element
                  current_element++;                 
   
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }       
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element++; //go on with next element  
                }   //copy data of current element finished
              }       //forward ends
              if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
  			    	{
                current_element =AUDIO_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    } 
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }    
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                     
              }       //backward ends
            }          //startelement=0 ends
            else if (startelement !=0) //startelement !=0
            {
              if(FORWARD==direction)  //forward-start
      		    {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is next element
                  current_element++;
                                  
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element++; //go on with next element    
                }   //copy data of current element finished
              }       //forward ends
              else if(BACKWARD==direction)
              {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is previous element
                  current_element--;         
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //PictureType
                  if (CacheElements ==TRUE)
                    gPicture_Type[current_element] =Indication_array[Offset];
                  Offset++;
                  //IPv6Address
                  for(i=0; i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_IpAddress[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_IpAddress[current_element][i] =Indication_array[Offset];
                    Offset++;
                  } 
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                                 
              }
            }          //startelement !=0 ends
          break;         //recordaddress =1 ends
          case 2: //recordaddress =2 -> TCP_Port, URI
            if(0==startelement)
            {
              if(FORWARD==direction)  //forward-start
      		    {          
                current_element =startelement;             
                if (shift ==TRUE) //startelement is next element
                  current_element++;                 
   
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }       
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element++; //go on with next element  
                }   //copy data of current element finished
              }       //forward ends
              if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
  			    	{
                current_element =AUDIO_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    } 
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }    
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                     
              }       //backward ends
            }          //startelement=0 ends
            else if (startelement !=0) //startelement !=0
            {
              if(FORWARD==direction)  //forward-start
      		    {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is next element
                  current_element++;
                                  
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element++; //go on with next element    
                }   //copy data of current element finished
              }       //forward ends
              else if(BACKWARD==direction)
              {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is previous element
                  current_element--;         
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //TCP_Port
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] =Indication_array[Offset];
                  Offset++;
                  if (CacheElements ==TRUE)
                    gPicture_TcpPort[current_element] +=Indication_array[Offset]*0x100;
                  Offset++;
                  //URI
                  for(i=0; i<AUDIO_PICTURE_URI_LENGTH;i++) //clear
                  {
                    if (CacheElements ==TRUE)
                      gPicture_Uri[current_element][i] =0; 
                  }
                  length =Indication_array[Offset];
                  Offset++;                
                  for(i=0; i<length;i++) //copy data
                  {   
                    if (CacheElements ==TRUE)
                        gPicture_Uri[current_element][i] =Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                                 
              }
            }          //startelement !=0 ends
          break;         //recordaddress =1 ends
          case 15: //recordaddress =15 -> POS 
            if(0==startelement)
            {
              if(FORWARD==direction)  //forward-start
      		    {          
                current_element =startelement;
                if (shift ==TRUE) //startelement is next element
                  current_element++;                 
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element++; //go on with next element       
                }   //copy data of current element finished
              }       //forward ends
              if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
      		    {
                current_element =AUDIO_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                     
              }       //backward ends
            }          //startelement=0 ends
            else if (startelement !=0) //startelement !=0
            {
              if(FORWARD==direction)  //forward-start
      		    {
                current_element =startelement;
                if (shift ==TRUE) //startelement is next element
                  current_element++;
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element++; //go on with next element       
                }   //copy data of current element finished
              }       //forward ends
              else if(BACKWARD==direction)
              {
                current_element =startelement; 
                if (shift ==TRUE) //startelement is previous element
                  current_element--;
                for (j=0; j<elements;j++) //copy elements
                {
                  //check, if elements must be cached and in case find position in array
                  CacheElements =FALSE;
                  for (i=0; i<AUDIO_PICTURE_ENTRIES; i++)
                  {  
                    //if element already cached, find position in ASG-cache
                    if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryValidInformation[i] ==TRUE)
                    {    
                      current_element =i; 
                      CacheElements   =TRUE;
                    }
                    //if not already cached, then store element only, if Cache is build-up!
                    else if((gPicture_ListHandlingType !=AUDIO_PICTURE_NOCACHE))
                      CacheElements   =TRUE;
                  }
                  //Pos
                  if (transmitpos)
                  {   
                    if (CacheElements ==TRUE)
                      gPicture_Pos[current_element]=Indication_array[Offset];
                    Offset++;
                  }
                  //next element
                  if (CacheElements ==TRUE)
                    gPicture_ListEntryValidInformation [current_element] =TRUE;
                  current_element--;
                }   //copy data of current element finished                                 
              }
            }          //startelement !=0 ends
          break;         //recordaddress =15 ends    
        }
      }
    break;            
    case Error_IND:	
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD Picture_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD Picture_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
				writelineEx(gError_Trace, 0, "ASG-AudioSD Picture_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
				writelineEx(gError_Trace, 0, "ASG-AudioSD Picture_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
		default:
			writelineEx(gError_Trace, 0,"ASG-AudioSD Picture_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}  
  //for "sliding window concept"
  /*  
  if(gPicture_TotalNumListElements<=AUDIO_PICTURE_ENTRIES)
        gPicture_SlidingWindow_State =AUDIO_PICTURE_SLIDINGWINDOW_NOTACTIVE;
    else
        gPicture_SlidingWindow_State =AUDIO_PICTURE_SLIDINGWINDOW_ACTIVE;

    if (gPicture_CallBackReason !=AUDIO_PICTURE_CALLBACKREASON_NOCALLBACK)
    {
      write("Pic: handling");  
      Picture_ListHandling ();
    }
    else
    {
      write("Pic: display");
      Picture_display();
    }
  */
}

void Picture_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];
  byte Offset;
  word indexsize;

  // Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
    requestarray [i]=0;
  
  indexsize   =0;
  Offset      =0;

  // decode "mode-byte"
  indexsize   =(mode &0x08)/0x08; 

  // Handle request.
  requestarray[0] =LSG_AudioSD;	    //LSG-ID
	requestarray[1] =FctID_Picture;	//Fct.-ID
	requestarray[2] =request;           //request type

  switch(request)
	{
    case DataGet_REQ:              
      requestarray[3] =((gPicture_ASGID *0x10) &0xF0) +(gPicture_TAID &0x0F);      
      /***ArrayHeader***/
	    requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
      Offset =5;
      if(indexsize)
      {
        requestarray[Offset] =requested_startelement &0x00FF;
        Offset++;
        requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
        Offset++;  
        requestarray[Offset] =elements &0x00FF;
        Offset++;
        requestarray[Offset] =(elements &0xFF00) /0x100;
        Offset++;       
        //writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_16bit %x",indexsize); //debug
      }
      else
      {
        requestarray[Offset] =requested_startelement;
        Offset++;
        requestarray[Offset] =elements;
        Offset++;
        //writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_8bit %x",indexsize); //debug
      }
      set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
    break;
    default:	
			writelineEx(gError_Trace, 0, "ASG-AudioSD Picture_Request: invalid request %d", request);
		break;
  }
}

int Picture_GetNextCachedElement (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case AUDIO_PICTURE_DISPLAYLIST_FIND_NEXT_ELEMENT:                
                nextElement = ++currentElement;

                if (nextElement<AUDIO_PICTURE_ENTRIES) //start at next element, if next element is not >8
                {
                    for(i =nextElement; i<AUDIO_PICTURE_ENTRIES;i++)
                    {
                        if(gPicture_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i= AUDIO_PICTURE_ENTRIES;
                        }
                        else
                            nextElement =0;
                    }
                }
                else    //start at first element
                {
                    nextElement =0;

                    for(i =nextElement; i<AUDIO_PICTURE_ENTRIES;i++)
                    {
                        if(gPicture_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =AUDIO_PICTURE_ENTRIES;
                        }   
                    }
                }
        break;

        case AUDIO_PICTURE_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
                nextElement = --currentElement;
                if (nextElement ==0 && gPicture_ListEntryValidInformation[nextElement] ==TRUE)
                    nextElement =0;
                else if (nextElement>0) 
                {
                    for(i =nextElement; i>0; i--)
                    {
                        if(gPicture_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else
                            nextElement =AUDIO_PICTURE_ENTRIES-1;
                    }
                }    
                else    //start at last element
                {
                    nextElement =AUDIO_PICTURE_ENTRIES-1;

                    for(i =nextElement; i>0; i--)
                    {
                        if(gPicture_ListEntryValidInformation[i] ==TRUE)
                        {   
                            nextElement =i; 
                            i =0;
                        }
                        else if(gPicture_ListEntryValidInformation[0] ==TRUE)
                            nextElement =0;          
                    }
                }
        break;

        default:
        break;
    }
    return(nextElement);
}

int Picture_GetNextLineInCache (int currentElement,byte direction)
{
    int i=0, nextElement=0;

    switch (direction)
    {
        case FORWARD:
                           
                if(currentElement<AUDIO_PICTURE_ENTRIES-1 && currentElement !=5) 
                    nextElement = ++currentElement;  
                
                else if (currentElement ==8)            
                    nextElement =0;
                else
                    nextElement =AUDIO_PICTURE_NO_NEXT_POSITION;
        break;

        case BACKWARD:
                if(currentElement<AUDIO_PICTURE_ENTRIES && currentElement !=0 && currentElement !=6) 
                    nextElement =--currentElement;
                
                else if (currentElement ==0)            
                    nextElement =8;
                
                else
                    nextElement =AUDIO_PICTURE_NO_NEXT_POSITION;
        break;

        default:
        break;
    }
    return(nextElement);
}

//*************************************************************************
//*************************************************************************

void fctDummy()
{
}