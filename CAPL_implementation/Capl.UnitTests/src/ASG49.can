/*@!Encoding:1252*/
includes
{
  #pragma library ("..\..\v7540_BAP180\BAP180_7540.dll")
  
}

variables
{

	//@BAPSIMGEN_VAR_SECTION_BEGIN

	/***************************************************/
	/*            BapSimGen ASG template               */
	/***************************************************/

	/************** Ausgabe Konsolen (Traces) ***********/
	dword gBAP_Trace;
	dword gError_Trace;

	/************** Node Verwaltung ***************/
	//Power on/off
	byte gSG_PowerOnOff=0x01;     // wird mit Power_off/on gesetzt
	byte gBAP_Init=0;             // schon mal initialisiert?

	const Power_off = 0x00;
	const Power_on	= 0x01;

	mstimer TaskTimer;				//real communication timer

	/************** Request **************/
	const Requestbuffer_lines = 100;
	const BAP_buffer_size = 4096;

	/************ Speichern von Requests im "Ringbuffer" ***********/
	int   gBAP_Requestbuffer_status     [Requestbuffer_lines];		            // 0: kein Eintrag, 1:pending
	dword gBAP_Request_header			[Requestbuffer_lines] [6];				// beinhaltet auch skalare Daten
	dword gBAP_Request_data             [Requestbuffer_lines] [BAP_buffer_size];// ringbuffer Eintrag fuer BAP-Request


	/************** Indication **************/
	// enthaelt die derzeitige Indication
	dword gBAP_Indication_header[6];	
	byte  gBAP_Indication_data[BAP_buffer_size];		

	/************** Konstanten ****************/

	//BAP Data Type 
	const Bap_void				=0;
	const Bap_uint8				=1;
	const Bap_uint16			=2;
	const Bap_uint32			=3;
	const Bap_byteSequence		=4;
	const Bap_error				=5;
	const Bap_acknowledge		=6;

	char Datatype_Text[7][20] =
	{
		"void", "uint8", "uint16", "uint32", "byteSequence", "error", "acknowledge"
	};

	//BAP request types
	const DataSetGet_REQ  = 0x00;
	const DataSet_REQ	  = 0x01;
	const DataGet_REQ	  = 0x02;
	const Data_REQ		  = 0x03;
	const Changed_REQ	  = 0x04;
	const Start_REQ		  = 0x05;
	const StartResult_REQ = 0x06;
	const AbortResult_REQ = 0x07;
	const Processing_REQ  = 0x08;
	const Result_REQ      = 0x09;
	const DataAck_REQ     = 0x0A;
	const Ack_REQ         = 0x0B;
	const Invalid_REQ     = 0x1F;      // Interne Kennzeichnung fuer einen ungueltigen Request

	//eigene Error-Definition
	const Error_REQ=0x20;

	char Requesttype_Text[33][30] =
	{
		"DataSetGet_REQ", "DataSet_REQ", "DataGet_REQ", "Data_REQ",			/* 00 .. 03 */
		"Changed_REQ", "Start_REQ", "StartResult_REQ", "AbortResult_REQ",   /* 04 .. 07 */
		"Processing_REQ", "Result_REQ", "DataAck_REQ", "Ack_REQ", 			/* 08 .. 0b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 0c .. 0f */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 10 .. 13 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 14 .. 17 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", 		/* 18 .. 1b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 1c .. 1f */
		"Error_REQ"	  														/* 20 */
	};

	//BAP indication types
	const Data_IND			 = 0x00;
	const Reset_IND			 = 0x01;
	const DataAck_IND        = 0x02;
	const Result_IND		 = 0x03;
	const Processing_IND	 = 0x04;
  	const Changed_IND		 = 0x05;
  	const DataSetGet_IND	 = 0x06;
	const DataSet_IND		 = 0x07;
	const DataGet_IND		 = 0x08;
	const Ack_IND            = 0x09;
	const Processing_CNF_IND = 0x0A;
	const Start_IND			 = 0x0B;
	const StartResult_IND	 = 0x0C;
	const AbortResult_IND	 = 0x0D;
	const Invalid_IND		 = 0x1F; // Kennzeichnung fuer eine ungueltige Indication
	const Error_IND			 = 0x20;
	
	char Indicationtype_Text[33][30] =
	{
		"Data_IND", "Reset_IND", "DataAck_IND", "Result_IND",			 	/* 00 .. 03 */
		"Processing_IND", "Changed_IND", "DataSetGet_IND", "DataSet_IND", 	/* 04 .. 07 */
		"DataGet_IND", "Ack_IND", "Processing_CNF_IND", "Start_REQ",	 	/* 08 .. 0b */
		"StartResult_REQ", "AbortResult_REQ", "Invalid_REQ", "Invalid_REQ", /* 0c .. 0f */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 10 .. 13 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 14 .. 17 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", 		/* 18 .. 1b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 1c .. 1f */
		"Error_REQ"	  														/* 20 */
	};	
	
	char Acknowledgetype_Text[24][30] =
	{
		"Property_SetGet_ACK", "Array_SetGet_ACK", "Property_Set_ACK", "Array_Set_ACK",  			/* 00 .. 03 */
		"Method_Start_ACK", "Method_StartResult_ACK", "Method_AbortResult_ACK", "Property_Get_ACK",	/* 04 .. 07 */
		"Array_Get_ACK", "Cache_GetAll_ACK", "Property_Ack_ACK", "Property_Status_ACK",	   			/* 08 .. 0b */
		"Property_StatusAck_ACK", "Property_Error_ACK", "Array_Status_ACK", "Array_Changed_ACK",	/* 0c .. 0f */
		"Array_Error_ACK", "Method_Processing_ACK", "Method_Result_ACK", "Method_Error_ACK",  		/* 10 .. 13 */
		"Unknown_ACK", "Unknown_ACK", "Unknown_ACK", "Unknown_ACK"									/* 14 .. 17 */
	};

	/**************************** Global Function-ID's ******************************/
	/** TODO: already_pressed kann zwischen den Funktionen geshared werden          */

	byte already_pressed = 0;

	const FctID_GetAll									= 0x01;
	const FctID_BAP_Config								= 0x02;
	const FctID_FunctionList							= 0x03;
	const FctID_HeartBeat								= 0x04;
    
    char SGtype[4]="ASG";

	char  dbcan_path[255]             = "asg\\bapdb\\BAP_only_MQB_MLBevo_v1.50.dbc";
	char  dbeth_path[255]             = "asg\\bapdb\\MQB_V7.19F_AR421_20170529_Kombi_MQB_OCU_Sound_MIB_ab_Gen3_TVTuner_MQB_ZR_MIB_OPTION_ab_Gen3_FD.arxml";
	char  xml_path[255]             = "asg\\bapxml\\BAP_SW18_Audio_P30DF48_ASG1_Eth_v2.0.xml";
	dword NODE_INDEX                =  0;
	char  NODE_NAME[100]            = "Audio_SD";
	const LSGID                     = 49;
	char  panel_name[100]           = "ASG49_0";
	char  bapconfig_panel_name[100]    = "panel1";
	char  common_panel_name[100]    = "panel2";
	const TaskTime                  = 10;
	const heartBeatFactor                               = 5;
	 const C_ASG_49_0_0_1_ID = 1;
	 byte C_ASG_49_0_0_1GetAll_BTN_already_pressed = 0;
	 char gCheckbox1[100] = "checkbox_C_ASG_49_0_0_1";
	 char gErrField1[100] = "errfield_C_ASG_49_0_0_1";
	 byte gC_ASG_49_0_0_1_ErrCode = 1;
	 const P_ASG_49_0_0_2_ID = 2;
	 byte P_ASG_49_0_0_2Get_BTN_already_pressed = 0;
	 char gCheckbox2[100] = "checkbox_P_ASG_49_0_0_2";
	 char gErrField2[100] = "errfield_P_ASG_49_0_0_2";
	 byte gP_ASG_49_0_0_2_ErrCode = 1;
	 const P_ASG_49_0_0_3_ID = 3;
	 byte P_ASG_49_0_0_3Get_BTN_already_pressed = 0;
	 char gCheckbox3[100] = "checkbox_P_ASG_49_0_0_3";
	 char gErrField3[100] = "errfield_P_ASG_49_0_0_3";
	 byte gP_ASG_49_0_0_3_ErrCode = 1;
	 const P_ASG_49_0_0_4_ID = 4;
	 byte P_ASG_49_0_0_4Get_BTN_already_pressed = 0;
	 char gCheckbox4[100] = "checkbox_P_ASG_49_0_0_4";
	 char gErrField4[100] = "errfield_P_ASG_49_0_0_4";
	 byte gP_ASG_49_0_0_4_ErrCode = 1;
	 const P_ASG_49_0_0_14_ID = 14;
	 byte P_ASG_49_0_0_14Get_BTN_already_pressed = 0;
	 char gCheckbox14[100] = "checkbox_P_ASG_49_0_0_14";
	 char gErrField14[100] = "errfield_P_ASG_49_0_0_14";
	 byte gP_ASG_49_0_0_14_ErrCode = 1;
	 char gPanel14[100] = "panel_P_ASG_49_0_0_14";
	 const P_ASG_49_0_0_15_ID = 15;
	 byte P_ASG_49_0_0_15Get_BTN_already_pressed = 0;
	 char gCheckbox15[100] = "checkbox_P_ASG_49_0_0_15";
	 char gErrField15[100] = "errfield_P_ASG_49_0_0_15";
	 byte gP_ASG_49_0_0_15_ErrCode = 1;
	 char gPanel15[100] = "panel_P_ASG_49_0_0_15";
	 const P_ASG_49_0_0_16_ID = 16;
	 byte P_ASG_49_0_0_16Get_BTN_already_pressed = 0;
	 char gCheckbox16[100] = "checkbox_P_ASG_49_0_0_16";
	 char gErrField16[100] = "errfield_P_ASG_49_0_0_16";
	 byte gP_ASG_49_0_0_16_ErrCode = 1;
	 char gPanel16[100] = "panel_P_ASG_49_0_0_16";
	 const P_ASG_49_0_0_17_ID = 17;
	 byte P_ASG_49_0_0_17Get_BTN_already_pressed = 0;
	 char gCheckbox17[100] = "checkbox_P_ASG_49_0_0_17";
	 char gErrField17[100] = "errfield_P_ASG_49_0_0_17";
	 byte gP_ASG_49_0_0_17_ErrCode = 1;
	 char gPanel17[100] = "panel_P_ASG_49_0_0_17";
	 const P_ASG_49_0_0_18_ID = 18;
	 byte P_ASG_49_0_0_18Get_BTN_already_pressed = 0;
	 char gCheckbox18[100] = "checkbox_P_ASG_49_0_0_18";
	 char gErrField18[100] = "errfield_P_ASG_49_0_0_18";
	 byte gP_ASG_49_0_0_18_ErrCode = 1;
	 char gPanel18[100] = "panel_P_ASG_49_0_0_18";
	 const P_ASG_49_0_0_19_ID = 19;
	 byte P_ASG_49_0_0_19Get_BTN_already_pressed = 0;
	 byte P_ASG_49_0_0_19SetGet_BTN_already_pressed = 0;
	 char gCheckbox19[100] = "checkbox_P_ASG_49_0_0_19";
	 char gErrField19[100] = "errfield_P_ASG_49_0_0_19";
	 byte gP_ASG_49_0_0_19_ErrCode = 1;
	 char gPanel19[100] = "panel_P_ASG_49_0_0_19";
	 const P_ASG_49_0_0_20_ID = 20;
	 byte P_ASG_49_0_0_20Get_BTN_already_pressed = 0;
	 byte P_ASG_49_0_0_20SetGet_BTN_already_pressed = 0;
	 char gCheckbox20[100] = "checkbox_P_ASG_49_0_0_20";
	 char gErrField20[100] = "errfield_P_ASG_49_0_0_20";
	 byte gP_ASG_49_0_0_20_ErrCode = 1;
	 char gPanel20[100] = "panel_P_ASG_49_0_0_20";
	 const P_ASG_49_0_0_21_ID = 21;
	 byte P_ASG_49_0_0_21Get_BTN_already_pressed = 0;
	 char gCheckbox21[100] = "checkbox_P_ASG_49_0_0_21";
	 char gErrField21[100] = "errfield_P_ASG_49_0_0_21";
	 byte gP_ASG_49_0_0_21_ErrCode = 1;
	 char gPanel21[100] = "panel_P_ASG_49_0_0_21";
	 const P_ASG_49_0_0_22_ID = 22;
	 byte P_ASG_49_0_0_22Get_BTN_already_pressed = 0;
	 char gCheckbox22[100] = "checkbox_P_ASG_49_0_0_22";
	 char gErrField22[100] = "errfield_P_ASG_49_0_0_22";
	 byte gP_ASG_49_0_0_22_ErrCode = 1;
	 char gPanel22[100] = "panel_P_ASG_49_0_0_22";
	 const A_ASG_49_0_0_23_ID = 23;
	 byte A_ASG_49_0_0_23Get_BTN_already_pressed = 0;
	 char gCheckbox23[100] = "checkbox_A_ASG_49_0_0_23";
	 char gErrField23[100] = "errfield_A_ASG_49_0_0_23";
	 byte gA_ASG_49_0_0_23_ErrCode = 1;
	 char gPanel23[100] = "panel_A_ASG_49_0_0_23";
	 byte A_ASG_49_0_0_23_DataIndex_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_23_DataIndex_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_23_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_23_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_23_generateData_Btn_already_pressed = 0;
	 byte A_ASG_49_0_0_23_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_ASG_49_0_0_23_ArrayDataStruct {
		 word Param1;
		 byte Param2;
		 word Param3;
		 byte Param4;
		 byte Param5;
		 byte Param6;
		 byte Param7[49];
		 word Param7_Length;
		 byte Param8[31];
		 word Param8_Length;
	 };
	 struct A_ASG_49_0_0_23_ArrayDataStruct A_ASG_49_0_0_23_ArrayDataList[65535];
	 const A_ASG_49_0_0_23_ArrayDataList_Length = 65535;
	 long A_ASG_49_0_0_23_Data_7_LenList[65535];
	 byte A_ASG_49_0_0_23_Data_7_CntList[65535];
	 long A_ASG_49_0_0_23_Data_7_SetGet_LenList[65535];
	 byte A_ASG_49_0_0_23_Data_7_SetGet_CntList[65535];
	 long A_ASG_49_0_0_23_Data_8_LenList[65535];
	 byte A_ASG_49_0_0_23_Data_8_CntList[65535];
	 long A_ASG_49_0_0_23_Data_8_SetGet_LenList[65535];
	 byte A_ASG_49_0_0_23_Data_8_SetGet_CntList[65535];
	 const M_ASG_49_0_0_24_ID = 24;
	 byte M_ASG_49_0_0_24AbortResult_BTN_already_pressed = 0;
	 byte M_ASG_49_0_0_24StartResult_BTN_already_pressed = 0;
	 char gCheckbox24[100] = "checkbox_M_ASG_49_0_0_24";
	 char gErrField24[100] = "errfield_M_ASG_49_0_0_24";
	 byte gM_ASG_49_0_0_24_ErrCode = 1;
	 char gPanel24[100] = "panel_M_ASG_49_0_0_24";
	 const P_ASG_49_0_0_25_ID = 25;
	 byte P_ASG_49_0_0_25Get_BTN_already_pressed = 0;
	 byte P_ASG_49_0_0_25SetGet_BTN_already_pressed = 0;
	 char gCheckbox25[100] = "checkbox_P_ASG_49_0_0_25";
	 char gErrField25[100] = "errfield_P_ASG_49_0_0_25";
	 byte gP_ASG_49_0_0_25_ErrCode = 1;
	 char gPanel25[100] = "panel_P_ASG_49_0_0_25";
	 const P_ASG_49_0_0_26_ID = 26;
	 byte P_ASG_49_0_0_26Get_BTN_already_pressed = 0;
	 char gCheckbox26[100] = "checkbox_P_ASG_49_0_0_26";
	 char gErrField26[100] = "errfield_P_ASG_49_0_0_26";
	 byte gP_ASG_49_0_0_26_ErrCode = 1;
	 char gPanel26[100] = "panel_P_ASG_49_0_0_26";
	 const A_ASG_49_0_0_27_ID = 27;
	 byte A_ASG_49_0_0_27Get_BTN_already_pressed = 0;
	 char gCheckbox27[100] = "checkbox_A_ASG_49_0_0_27";
	 char gErrField27[100] = "errfield_A_ASG_49_0_0_27";
	 byte gA_ASG_49_0_0_27_ErrCode = 1;
	 char gPanel27[100] = "panel_A_ASG_49_0_0_27";
	 byte A_ASG_49_0_0_27_DataIndex_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_27_DataIndex_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_27_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_27_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_27_generateData_Btn_already_pressed = 0;
	 byte A_ASG_49_0_0_27_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_ASG_49_0_0_27_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3;
		 byte Param4;
		 byte Param5[49];
		 word Param5_Length;
	 };
	 struct A_ASG_49_0_0_27_ArrayDataStruct A_ASG_49_0_0_27_ArrayDataList[255];
	 const A_ASG_49_0_0_27_ArrayDataList_Length = 255;
	 long A_ASG_49_0_0_27_Data_5_LenList[255];
	 byte A_ASG_49_0_0_27_Data_5_CntList[255];
	 long A_ASG_49_0_0_27_Data_5_SetGet_LenList[255];
	 byte A_ASG_49_0_0_27_Data_5_SetGet_CntList[255];
	 const P_ASG_49_0_0_28_ID = 28;
	 byte P_ASG_49_0_0_28Get_BTN_already_pressed = 0;
	 char gCheckbox28[100] = "checkbox_P_ASG_49_0_0_28";
	 char gErrField28[100] = "errfield_P_ASG_49_0_0_28";
	 byte gP_ASG_49_0_0_28_ErrCode = 1;
	 char gPanel28[100] = "panel_P_ASG_49_0_0_28";
	 const M_ASG_49_0_0_29_ID = 29;
	 byte M_ASG_49_0_0_29AbortResult_BTN_already_pressed = 0;
	 byte M_ASG_49_0_0_29StartResult_BTN_already_pressed = 0;
	 char gCheckbox29[100] = "checkbox_M_ASG_49_0_0_29";
	 char gErrField29[100] = "errfield_M_ASG_49_0_0_29";
	 byte gM_ASG_49_0_0_29_ErrCode = 1;
	 char gPanel29[100] = "panel_M_ASG_49_0_0_29";
	 const P_ASG_49_0_0_30_ID = 30;
	 byte P_ASG_49_0_0_30Get_BTN_already_pressed = 0;
	 char gCheckbox30[100] = "checkbox_P_ASG_49_0_0_30";
	 char gErrField30[100] = "errfield_P_ASG_49_0_0_30";
	 byte gP_ASG_49_0_0_30_ErrCode = 1;
	 char gPanel30[100] = "panel_P_ASG_49_0_0_30";
	 const P_ASG_49_0_0_31_ID = 31;
	 byte P_ASG_49_0_0_31Get_BTN_already_pressed = 0;
	 char gCheckbox31[100] = "checkbox_P_ASG_49_0_0_31";
	 char gErrField31[100] = "errfield_P_ASG_49_0_0_31";
	 byte gP_ASG_49_0_0_31_ErrCode = 1;
	 char gPanel31[100] = "panel_P_ASG_49_0_0_31";
	 const A_ASG_49_0_0_32_ID = 32;
	 byte A_ASG_49_0_0_32Get_BTN_already_pressed = 0;
	 char gCheckbox32[100] = "checkbox_A_ASG_49_0_0_32";
	 char gErrField32[100] = "errfield_A_ASG_49_0_0_32";
	 byte gA_ASG_49_0_0_32_ErrCode = 1;
	 char gPanel32[100] = "panel_A_ASG_49_0_0_32";
	 byte A_ASG_49_0_0_32_DataIndex_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_32_DataIndex_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_32_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_32_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_32_generateData_Btn_already_pressed = 0;
	 byte A_ASG_49_0_0_32_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_ASG_49_0_0_32_ArrayDataStruct {
		 word Param1;
		 byte Param2;
		 byte Param3;
		 byte Param4;
		 byte Param5;
		 byte Param6[61];
		 word Param6_Length;
	 };
	 struct A_ASG_49_0_0_32_ArrayDataStruct A_ASG_49_0_0_32_ArrayDataList[65535];
	 const A_ASG_49_0_0_32_ArrayDataList_Length = 65535;
	 long A_ASG_49_0_0_32_Data_6_LenList[65535];
	 byte A_ASG_49_0_0_32_Data_6_CntList[65535];
	 long A_ASG_49_0_0_32_Data_6_SetGet_LenList[65535];
	 byte A_ASG_49_0_0_32_Data_6_SetGet_CntList[65535];
	 const A_ASG_49_0_0_33_ID = 33;
	 byte A_ASG_49_0_0_33Get_BTN_already_pressed = 0;
	 char gCheckbox33[100] = "checkbox_A_ASG_49_0_0_33";
	 char gErrField33[100] = "errfield_A_ASG_49_0_0_33";
	 byte gA_ASG_49_0_0_33_ErrCode = 1;
	 char gPanel33[100] = "panel_A_ASG_49_0_0_33";
	 byte A_ASG_49_0_0_33_DataIndex_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_33_DataIndex_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_33_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_33_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_33_generateData_Btn_already_pressed = 0;
	 byte A_ASG_49_0_0_33_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_ASG_49_0_0_33_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3;
		 word Param4;
		 byte Param5[49];
		 word Param5_Length;
	 };
	 struct A_ASG_49_0_0_33_ArrayDataStruct A_ASG_49_0_0_33_ArrayDataList[255];
	 const A_ASG_49_0_0_33_ArrayDataList_Length = 255;
	 long A_ASG_49_0_0_33_Data_5_LenList[255];
	 byte A_ASG_49_0_0_33_Data_5_CntList[255];
	 long A_ASG_49_0_0_33_Data_5_SetGet_LenList[255];
	 byte A_ASG_49_0_0_33_Data_5_SetGet_CntList[255];
	 const M_ASG_49_0_0_34_ID = 34;
	 byte M_ASG_49_0_0_34AbortResult_BTN_already_pressed = 0;
	 byte M_ASG_49_0_0_34StartResult_BTN_already_pressed = 0;
	 char gCheckbox34[100] = "checkbox_M_ASG_49_0_0_34";
	 char gErrField34[100] = "errfield_M_ASG_49_0_0_34";
	 byte gM_ASG_49_0_0_34_ErrCode = 1;
	 char gPanel34[100] = "panel_M_ASG_49_0_0_34";
	 const P_ASG_49_0_0_35_ID = 35;
	 byte P_ASG_49_0_0_35Get_BTN_already_pressed = 0;
	 char gCheckbox35[100] = "checkbox_P_ASG_49_0_0_35";
	 char gErrField35[100] = "errfield_P_ASG_49_0_0_35";
	 byte gP_ASG_49_0_0_35_ErrCode = 1;
	 char gPanel35[100] = "panel_P_ASG_49_0_0_35";
	 const A_ASG_49_0_0_36_ID = 36;
	 byte A_ASG_49_0_0_36Get_BTN_already_pressed = 0;
	 char gCheckbox36[100] = "checkbox_A_ASG_49_0_0_36";
	 char gErrField36[100] = "errfield_A_ASG_49_0_0_36";
	 byte gA_ASG_49_0_0_36_ErrCode = 1;
	 char gPanel36[100] = "panel_A_ASG_49_0_0_36";
	 byte A_ASG_49_0_0_36_DataIndex_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_36_DataIndex_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_36_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_36_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_36_generateData_Btn_already_pressed = 0;
	 byte A_ASG_49_0_0_36_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_ASG_49_0_0_36_ArrayDataStruct {
		 word Param1;
		 byte Param2;
		 word Param3;
		 byte Param4[97];
		 word Param4_Length;
	 };
	 struct A_ASG_49_0_0_36_ArrayDataStruct A_ASG_49_0_0_36_ArrayDataList[65535];
	 const A_ASG_49_0_0_36_ArrayDataList_Length = 65535;
	 long A_ASG_49_0_0_36_Data_4_LenList[65535];
	 byte A_ASG_49_0_0_36_Data_4_CntList[65535];
	 long A_ASG_49_0_0_36_Data_4_SetGet_LenList[65535];
	 byte A_ASG_49_0_0_36_Data_4_SetGet_CntList[65535];
	 const P_ASG_49_0_0_37_ID = 37;
	 byte P_ASG_49_0_0_37Get_BTN_already_pressed = 0;
	 char gCheckbox37[100] = "checkbox_P_ASG_49_0_0_37";
	 char gErrField37[100] = "errfield_P_ASG_49_0_0_37";
	 byte gP_ASG_49_0_0_37_ErrCode = 1;
	 char gPanel37[100] = "panel_P_ASG_49_0_0_37";
	 const M_ASG_49_0_0_38_ID = 38;
	 byte M_ASG_49_0_0_38AbortResult_BTN_already_pressed = 0;
	 byte M_ASG_49_0_0_38StartResult_BTN_already_pressed = 0;
	 char gCheckbox38[100] = "checkbox_M_ASG_49_0_0_38";
	 char gErrField38[100] = "errfield_M_ASG_49_0_0_38";
	 byte gM_ASG_49_0_0_38_ErrCode = 1;
	 char gPanel38[100] = "panel_M_ASG_49_0_0_38";
	 const M_ASG_49_0_0_39_ID = 39;
	 byte M_ASG_49_0_0_39AbortResult_BTN_already_pressed = 0;
	 byte M_ASG_49_0_0_39StartResult_BTN_already_pressed = 0;
	 char gCheckbox39[100] = "checkbox_M_ASG_49_0_0_39";
	 char gErrField39[100] = "errfield_M_ASG_49_0_0_39";
	 byte gM_ASG_49_0_0_39_ErrCode = 1;
	 char gPanel39[100] = "panel_M_ASG_49_0_0_39";
	 const P_ASG_49_0_0_40_ID = 40;
	 byte P_ASG_49_0_0_40Get_BTN_already_pressed = 0;
	 byte P_ASG_49_0_0_40SetGet_BTN_already_pressed = 0;
	 char gCheckbox40[100] = "checkbox_P_ASG_49_0_0_40";
	 char gErrField40[100] = "errfield_P_ASG_49_0_0_40";
	 byte gP_ASG_49_0_0_40_ErrCode = 1;
	 char gPanel40[100] = "panel_P_ASG_49_0_0_40";
	 const P_ASG_49_0_0_41_ID = 41;
	 byte P_ASG_49_0_0_41Get_BTN_already_pressed = 0;
	 byte P_ASG_49_0_0_41SetGet_BTN_already_pressed = 0;
	 char gCheckbox41[100] = "checkbox_P_ASG_49_0_0_41";
	 char gErrField41[100] = "errfield_P_ASG_49_0_0_41";
	 byte gP_ASG_49_0_0_41_ErrCode = 1;
	 char gPanel41[100] = "panel_P_ASG_49_0_0_41";
	 const P_ASG_49_0_0_42_ID = 42;
	 byte P_ASG_49_0_0_42Get_BTN_already_pressed = 0;
	 char gCheckbox42[100] = "checkbox_P_ASG_49_0_0_42";
	 char gErrField42[100] = "errfield_P_ASG_49_0_0_42";
	 byte gP_ASG_49_0_0_42_ErrCode = 1;
	 char gPanel42[100] = "panel_P_ASG_49_0_0_42";
	 const P_ASG_49_0_0_43_ID = 43;
	 byte P_ASG_49_0_0_43Get_BTN_already_pressed = 0;
	 byte P_ASG_49_0_0_43SetGet_BTN_already_pressed = 0;
	 char gCheckbox43[100] = "checkbox_P_ASG_49_0_0_43";
	 char gErrField43[100] = "errfield_P_ASG_49_0_0_43";
	 byte gP_ASG_49_0_0_43_ErrCode = 1;
	 char gPanel43[100] = "panel_P_ASG_49_0_0_43";
	 const M_ASG_49_0_0_44_ID = 44;
	 byte M_ASG_49_0_0_44AbortResult_BTN_already_pressed = 0;
	 byte M_ASG_49_0_0_44StartResult_BTN_already_pressed = 0;
	 char gCheckbox44[100] = "checkbox_M_ASG_49_0_0_44";
	 char gErrField44[100] = "errfield_M_ASG_49_0_0_44";
	 byte gM_ASG_49_0_0_44_ErrCode = 1;
	 char gPanel44[100] = "panel_M_ASG_49_0_0_44";
	 const M_ASG_49_0_0_45_ID = 45;
	 byte M_ASG_49_0_0_45AbortResult_BTN_already_pressed = 0;
	 byte M_ASG_49_0_0_45StartResult_BTN_already_pressed = 0;
	 char gCheckbox45[100] = "checkbox_M_ASG_49_0_0_45";
	 char gErrField45[100] = "errfield_M_ASG_49_0_0_45";
	 byte gM_ASG_49_0_0_45_ErrCode = 1;
	 char gPanel45[100] = "panel_M_ASG_49_0_0_45";
	 const P_ASG_49_0_0_46_ID = 46;
	 byte P_ASG_49_0_0_46Get_BTN_already_pressed = 0;
	 char gCheckbox46[100] = "checkbox_P_ASG_49_0_0_46";
	 char gErrField46[100] = "errfield_P_ASG_49_0_0_46";
	 byte gP_ASG_49_0_0_46_ErrCode = 1;
	 char gPanel46[100] = "panel_P_ASG_49_0_0_46";
	 const P_ASG_49_0_0_47_ID = 47;
	 byte P_ASG_49_0_0_47Get_BTN_already_pressed = 0;
	 byte P_ASG_49_0_0_47SetGet_BTN_already_pressed = 0;
	 char gCheckbox47[100] = "checkbox_P_ASG_49_0_0_47";
	 char gErrField47[100] = "errfield_P_ASG_49_0_0_47";
	 byte gP_ASG_49_0_0_47_ErrCode = 1;
	 char gPanel47[100] = "panel_P_ASG_49_0_0_47";
	 const P_ASG_49_0_0_48_ID = 48;
	 byte P_ASG_49_0_0_48Get_BTN_already_pressed = 0;
	 char gCheckbox48[100] = "checkbox_P_ASG_49_0_0_48";
	 char gErrField48[100] = "errfield_P_ASG_49_0_0_48";
	 byte gP_ASG_49_0_0_48_ErrCode = 1;
	 char gPanel48[100] = "panel_P_ASG_49_0_0_48";
	 const P_ASG_49_0_0_49_ID = 49;
	 byte P_ASG_49_0_0_49Get_BTN_already_pressed = 0;
	 char gCheckbox49[100] = "checkbox_P_ASG_49_0_0_49";
	 char gErrField49[100] = "errfield_P_ASG_49_0_0_49";
	 byte gP_ASG_49_0_0_49_ErrCode = 1;
	 char gPanel49[100] = "panel_P_ASG_49_0_0_49";
	 const A_ASG_49_0_0_50_ID = 50;
	 byte A_ASG_49_0_0_50Get_BTN_already_pressed = 0;
	 char gCheckbox50[100] = "checkbox_A_ASG_49_0_0_50";
	 char gErrField50[100] = "errfield_A_ASG_49_0_0_50";
	 byte gA_ASG_49_0_0_50_ErrCode = 1;
	 char gPanel50[100] = "panel_A_ASG_49_0_0_50";
	 byte A_ASG_49_0_0_50_DataIndex_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_50_DataIndex_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_50_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_50_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_50_generateData_Btn_already_pressed = 0;
	 byte A_ASG_49_0_0_50_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_ASG_49_0_0_50_ArrayDataStruct {
		 word Param1;
		 word Param2;
		 byte Param3;
		 byte Param4[49];
		 word Param4_Length;
		 byte Param5[31];
		 word Param5_Length;
		 byte Param6;
		 byte Param7[61];
		 word Param7_Length;
		 byte Param8[2];
		 word Param8_Length;
	 };
	 struct A_ASG_49_0_0_50_ArrayDataStruct A_ASG_49_0_0_50_ArrayDataList[65535];
	 const A_ASG_49_0_0_50_ArrayDataList_Length = 65535;
	 long A_ASG_49_0_0_50_Data_4_LenList[65535];
	 byte A_ASG_49_0_0_50_Data_4_CntList[65535];
	 long A_ASG_49_0_0_50_Data_4_SetGet_LenList[65535];
	 byte A_ASG_49_0_0_50_Data_4_SetGet_CntList[65535];
	 long A_ASG_49_0_0_50_Data_5_LenList[65535];
	 byte A_ASG_49_0_0_50_Data_5_CntList[65535];
	 long A_ASG_49_0_0_50_Data_5_SetGet_LenList[65535];
	 byte A_ASG_49_0_0_50_Data_5_SetGet_CntList[65535];
	 long A_ASG_49_0_0_50_Data_7_LenList[65535];
	 byte A_ASG_49_0_0_50_Data_7_CntList[65535];
	 long A_ASG_49_0_0_50_Data_7_SetGet_LenList[65535];
	 byte A_ASG_49_0_0_50_Data_7_SetGet_CntList[65535];
	 long A_ASG_49_0_0_50_Data_8_LenList[65535];
	 byte A_ASG_49_0_0_50_Data_8_CntList[65535];
	 long A_ASG_49_0_0_50_Data_8_SetGet_LenList[65535];
	 byte A_ASG_49_0_0_50_Data_8_SetGet_CntList[65535];
	 const P_ASG_49_0_0_51_ID = 51;
	 byte P_ASG_49_0_0_51Get_BTN_already_pressed = 0;
	 char gCheckbox51[100] = "checkbox_P_ASG_49_0_0_51";
	 char gErrField51[100] = "errfield_P_ASG_49_0_0_51";
	 byte gP_ASG_49_0_0_51_ErrCode = 1;
	 char gPanel51[100] = "panel_P_ASG_49_0_0_51";
	 const P_ASG_49_0_0_52_ID = 52;
	 byte P_ASG_49_0_0_52Get_BTN_already_pressed = 0;
	 char gCheckbox52[100] = "checkbox_P_ASG_49_0_0_52";
	 char gErrField52[100] = "errfield_P_ASG_49_0_0_52";
	 byte gP_ASG_49_0_0_52_ErrCode = 1;
	 char gPanel52[100] = "panel_P_ASG_49_0_0_52";
	 const P_ASG_49_0_0_53_ID = 53;
	 byte P_ASG_49_0_0_53Get_BTN_already_pressed = 0;
	 char gCheckbox53[100] = "checkbox_P_ASG_49_0_0_53";
	 char gErrField53[100] = "errfield_P_ASG_49_0_0_53";
	 byte gP_ASG_49_0_0_53_ErrCode = 1;
	 char gPanel53[100] = "panel_P_ASG_49_0_0_53";
	 const P_ASG_49_0_0_54_ID = 54;
	 byte P_ASG_49_0_0_54Get_BTN_already_pressed = 0;
	 char gCheckbox54[100] = "checkbox_P_ASG_49_0_0_54";
	 char gErrField54[100] = "errfield_P_ASG_49_0_0_54";
	 byte gP_ASG_49_0_0_54_ErrCode = 1;
	 char gPanel54[100] = "panel_P_ASG_49_0_0_54";
	 const P_ASG_49_0_0_55_ID = 55;
	 byte P_ASG_49_0_0_55Get_BTN_already_pressed = 0;
	 char gCheckbox55[100] = "checkbox_P_ASG_49_0_0_55";
	 char gErrField55[100] = "errfield_P_ASG_49_0_0_55";
	 byte gP_ASG_49_0_0_55_ErrCode = 1;
	 char gPanel55[100] = "panel_P_ASG_49_0_0_55";
	 const A_ASG_49_0_0_56_ID = 56;
	 byte A_ASG_49_0_0_56Get_BTN_already_pressed = 0;
	 char gCheckbox56[100] = "checkbox_A_ASG_49_0_0_56";
	 char gErrField56[100] = "errfield_A_ASG_49_0_0_56";
	 byte gA_ASG_49_0_0_56_ErrCode = 1;
	 char gPanel56[100] = "panel_A_ASG_49_0_0_56";
	 byte A_ASG_49_0_0_56_DataIndex_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_56_DataIndex_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_56_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_56_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_56_generateData_Btn_already_pressed = 0;
	 byte A_ASG_49_0_0_56_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_ASG_49_0_0_56_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3;
		 word Param4;
		 byte Param5[49];
		 word Param5_Length;
		 byte Param6[31];
		 word Param6_Length;
	 };
	 struct A_ASG_49_0_0_56_ArrayDataStruct A_ASG_49_0_0_56_ArrayDataList[255];
	 const A_ASG_49_0_0_56_ArrayDataList_Length = 255;
	 long A_ASG_49_0_0_56_Data_5_LenList[255];
	 byte A_ASG_49_0_0_56_Data_5_CntList[255];
	 long A_ASG_49_0_0_56_Data_5_SetGet_LenList[255];
	 byte A_ASG_49_0_0_56_Data_5_SetGet_CntList[255];
	 long A_ASG_49_0_0_56_Data_6_LenList[255];
	 byte A_ASG_49_0_0_56_Data_6_CntList[255];
	 long A_ASG_49_0_0_56_Data_6_SetGet_LenList[255];
	 byte A_ASG_49_0_0_56_Data_6_SetGet_CntList[255];
	 const P_ASG_49_0_0_57_ID = 57;
	 byte P_ASG_49_0_0_57Get_BTN_already_pressed = 0;
	 char gCheckbox57[100] = "checkbox_P_ASG_49_0_0_57";
	 char gErrField57[100] = "errfield_P_ASG_49_0_0_57";
	 byte gP_ASG_49_0_0_57_ErrCode = 1;
	 char gPanel57[100] = "panel_P_ASG_49_0_0_57";
	 const A_ASG_49_0_0_58_ID = 58;
	 byte A_ASG_49_0_0_58Get_BTN_already_pressed = 0;
	 char gCheckbox58[100] = "checkbox_A_ASG_49_0_0_58";
	 char gErrField58[100] = "errfield_A_ASG_49_0_0_58";
	 byte gA_ASG_49_0_0_58_ErrCode = 1;
	 char gPanel58[100] = "panel_A_ASG_49_0_0_58";
	 byte A_ASG_49_0_0_58_DataIndex_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_58_DataIndex_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_58_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_58_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_58_generateData_Btn_already_pressed = 0;
	 byte A_ASG_49_0_0_58_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_ASG_49_0_0_58_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 word Param3;
		 byte Param4[17];
		 word Param4_Length;
		 word Param5;
		 byte Param6[602];
		 word Param6_Length;
	 };
	 struct A_ASG_49_0_0_58_ArrayDataStruct A_ASG_49_0_0_58_ArrayDataList[254];
	 const A_ASG_49_0_0_58_ArrayDataList_Length = 254;
	 long A_ASG_49_0_0_58_Data_4_LenList[254];
	 byte A_ASG_49_0_0_58_Data_4_CntList[254];
	 long A_ASG_49_0_0_58_Data_4_SetGet_LenList[254];
	 byte A_ASG_49_0_0_58_Data_4_SetGet_CntList[254];
	 long A_ASG_49_0_0_58_Data_6_LenList[254];
	 byte A_ASG_49_0_0_58_Data_6_CntList[254];
	 long A_ASG_49_0_0_58_Data_6_SetGet_LenList[254];
	 byte A_ASG_49_0_0_58_Data_6_SetGet_CntList[254];
	 const A_ASG_49_0_0_59_ID = 59;
	 byte A_ASG_49_0_0_59Get_BTN_already_pressed = 0;
	 char gCheckbox59[100] = "checkbox_A_ASG_49_0_0_59";
	 char gErrField59[100] = "errfield_A_ASG_49_0_0_59";
	 byte gA_ASG_49_0_0_59_ErrCode = 1;
	 char gPanel59[100] = "panel_A_ASG_49_0_0_59";
	 byte A_ASG_49_0_0_59_DataIndex_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_59_DataIndex_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_59_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_ASG_49_0_0_59_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_ASG_49_0_0_59_generateData_Btn_already_pressed = 0;
	 byte A_ASG_49_0_0_59_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_ASG_49_0_0_59_ArrayDataStruct {
		 byte Param1;
		 byte Param2;
		 byte Param3;
		 word Param4;
		 byte Param5[49];
		 word Param5_Length;
		 byte Param6[31];
		 word Param6_Length;
	 };
	 struct A_ASG_49_0_0_59_ArrayDataStruct A_ASG_49_0_0_59_ArrayDataList[255];
	 const A_ASG_49_0_0_59_ArrayDataList_Length = 255;
	 long A_ASG_49_0_0_59_Data_5_LenList[255];
	 byte A_ASG_49_0_0_59_Data_5_CntList[255];
	 long A_ASG_49_0_0_59_Data_5_SetGet_LenList[255];
	 byte A_ASG_49_0_0_59_Data_5_SetGet_CntList[255];
	 long A_ASG_49_0_0_59_Data_6_LenList[255];
	 byte A_ASG_49_0_0_59_Data_6_CntList[255];
	 long A_ASG_49_0_0_59_Data_6_SetGet_LenList[255];
	 byte A_ASG_49_0_0_59_Data_6_SetGet_CntList[255];
	 const P_ASG_49_0_0_60_ID = 60;
	 byte P_ASG_49_0_0_60Get_BTN_already_pressed = 0;
	 char gCheckbox60[100] = "checkbox_P_ASG_49_0_0_60";
	 char gErrField60[100] = "errfield_P_ASG_49_0_0_60";
	 byte gP_ASG_49_0_0_60_ErrCode = 1;
	 char gPanel60[100] = "panel_P_ASG_49_0_0_60";


	/// Begin: Definition der BUS-Schnittstellen
	
// FLEXRAY NOT ENABLED!
	
	// ETHERNET VARIABLES
  struct UdpSocket{
    dword Handle;
    dword Id;
  };
  struct UdpSocket gUdpSockets[5];
  dword gUdpSocketCnt;
  //	END OF ETHERNET VARIABLES

	
	//// End Bus Schnittstellen
}

on preStart
{
	char Version[200];
  
	/***** Erzeugen der Ausgabeconsolen *****/	
	gBAP_Trace=writecreate("BAP-Trace");		//write-window for BAP-cummunication
	writeclear(gBAP_Trace);						//clear BAP-window in write-window
	
	gError_Trace=writecreate("Error");			//error-window for BAP-cummunication
	writeclear(gError_Trace);					//clear error-window in write-window
	
	writeclear(1);								//clear CAPL-window in write-window
	
	/**** Versionsstring von DLL holen und auf Bildschirm ausgeben ***/	
	BAP150_GetVersions(Version, 200);
	writelineEx(gBAP_Trace, 0, "Versionx:%s", Version);
											
  NODE_INDEX = BAP150_CreateNode();
  writelineEx(gBAP_Trace, 0, "ASG %d Nodeindex:%d", LSGID, Version);

// FLEXRAY NOT ENABLED!
	
}

EthernetCreateSocket()
{ int index;
  dword i, j, Header[200], val, VlanId, VlanPrio, ifIndex;
  byte ipv6_adapter_adresses[5][16];
  byte ipv6_temp[16];
  byte ipv6_zero[16] = {0}; 

  gUdpSocketCnt = 0;
  Header[0] = 1;
  if(BAP180_GetEthConfig(NODE_INDEX, Header) == 0)
  {

    for(i=1;i<=3;i++)
    {
      if(IpGetAdapterAddress(i, ipv6_adapter_adresses, 5) == 0)
      {
        val = IpGetAdapterAddressCount(i, 28);
        for(j=0;j<val;j++)
        {
          IpRemoveAdapterAddress(i, ipv6_adapter_adresses[j], 64);
        }
      }
      else
      {
        break;
      }
    }
    index=0;
    ifIndex = 1;
    VlanId = Header[index++];
    VlanPrio = Header[index++];
    writelineex(0, 1, "VLAN ID: %d", VlanId);
    writelineex(0, 1, "VLAN Prio: %d", VlanPrio);
    if(VlanId != 0xFFFF)
      ifIndex = 2;

    gUdpSocketCnt = Header[index++];
    for(i=0; i<gUdpSocketCnt;i++)
    {
      gUdpSockets[i].Id = Header[index++];
      for(j=0;j<8;j++)
     {
        ipv6_temp[j*2]   = Header[index]>>8;
        ipv6_temp[j*2+1] = Header[index++]&0xFF;
      }

      IpAddAdapterAddress(ifIndex, ipv6_temp, 64);

      if(ipv6_temp[0] == 0xFF)
        gUdpSockets[i].Handle = UdpOpen( ipv6_zero, Header[index++]);
      else
        gUdpSockets[i].Handle = UdpOpen( ipv6_temp, Header[index++]);

      if (gUdpSockets[i].Handle == ~0){
        writelineex(0, 3, "Error: could not create Udp socket! %d", IpGetLastError());
      }else{

        writelineex(0, 1, "Udp socket is opened successfully.");

        if(ipv6_temp[0] == 0xFF)
        {
          if(IpJoinMulticastGroup(gUdpSockets[i].Handle, ifIndex, ipv6_temp) != 0)
           writelineex(0, 3, "IpJoinMulticastGroup failed.");
        }

        if(IpSetMulticastInterface ( gUdpSockets[i].Handle, ifIndex) != 0)
          writelineex(0, 3, "IpSetMulticastInterface failed");
      }
    }
  }
  else{
    writelineex(0, 3, "Error: BAP180_GetEthConfig failed!");
  }
}

 

DisableFctCtrl ()
{
  	EnableControl(panel_name, common_panel_name, 0);
	EnableControl(panel_name,gErrField1,0);
	EnableControl(panel_name,gErrField2,0);
	EnableControl(panel_name,gErrField3,0);
	EnableControl(panel_name,gErrField4,0);
	EnableControl(panel_name,gErrField14,0);
	EnableControl(panel_name,gPanel14,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_14",0);
	EnableControl(panel_name,gErrField15,0);
	EnableControl(panel_name,gPanel15,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_15",0);
	EnableControl(panel_name,gErrField16,0);
	EnableControl(panel_name,gPanel16,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_16",0);
	EnableControl(panel_name,gErrField17,0);
	EnableControl(panel_name,gPanel17,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_17",0);
	EnableControl(panel_name,gErrField18,0);
	EnableControl(panel_name,gPanel18,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_18",0);
	EnableControl(panel_name,gErrField19,0);
	EnableControl(panel_name,gPanel19,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_19",0);
	EnableControl(panel_name,gErrField20,0);
	EnableControl(panel_name,gPanel20,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_20",0);
	EnableControl(panel_name,gErrField21,0);
	EnableControl(panel_name,gPanel21,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_21",0);
	EnableControl(panel_name,gErrField22,0);
	EnableControl(panel_name,gPanel22,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_22",0);
	EnableControl(panel_name,gErrField23,0);
	EnableControl(panel_name,gPanel23,0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_23",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_23_Changed",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_23_SetGet",0);
	EnableControl(panel_name,gErrField24,0);
	EnableControl(panel_name,gPanel24,0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_24_Result",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_24_Processing",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_24_Start",0);
	EnableControl(panel_name,gErrField25,0);
	EnableControl(panel_name,gPanel25,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_25",0);
	EnableControl(panel_name,gErrField26,0);
	EnableControl(panel_name,gPanel26,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_26",0);
	EnableControl(panel_name,gErrField27,0);
	EnableControl(panel_name,gPanel27,0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_27",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_27_Changed",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_27_SetGet",0);
	EnableControl(panel_name,gErrField28,0);
	EnableControl(panel_name,gPanel28,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_28",0);
	EnableControl(panel_name,gErrField29,0);
	EnableControl(panel_name,gPanel29,0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_29_Result",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_29_Processing",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_29_Start",0);
	EnableControl(panel_name,gErrField30,0);
	EnableControl(panel_name,gPanel30,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_30",0);
	EnableControl(panel_name,gErrField31,0);
	EnableControl(panel_name,gPanel31,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_31",0);
	EnableControl(panel_name,gErrField32,0);
	EnableControl(panel_name,gPanel32,0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_32",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_32_Changed",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_32_SetGet",0);
	EnableControl(panel_name,gErrField33,0);
	EnableControl(panel_name,gPanel33,0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_33",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_33_Changed",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_33_SetGet",0);
	EnableControl(panel_name,gErrField34,0);
	EnableControl(panel_name,gPanel34,0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_34_Result",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_34_Processing",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_34_Start",0);
	EnableControl(panel_name,gErrField35,0);
	EnableControl(panel_name,gPanel35,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_35",0);
	EnableControl(panel_name,gErrField36,0);
	EnableControl(panel_name,gPanel36,0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_36",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_36_Changed",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_36_SetGet",0);
	EnableControl(panel_name,gErrField37,0);
	EnableControl(panel_name,gPanel37,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_37",0);
	EnableControl(panel_name,gErrField38,0);
	EnableControl(panel_name,gPanel38,0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_38_Result",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_38_Processing",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_38_Start",0);
	EnableControl(panel_name,gErrField39,0);
	EnableControl(panel_name,gPanel39,0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_39_Result",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_39_Processing",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_39_Start",0);
	EnableControl(panel_name,gErrField40,0);
	EnableControl(panel_name,gPanel40,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_40",0);
	EnableControl(panel_name,gErrField41,0);
	EnableControl(panel_name,gPanel41,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_41",0);
	EnableControl(panel_name,gErrField42,0);
	EnableControl(panel_name,gPanel42,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_42",0);
	EnableControl(panel_name,gErrField43,0);
	EnableControl(panel_name,gPanel43,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_43",0);
	EnableControl(panel_name,gErrField44,0);
	EnableControl(panel_name,gPanel44,0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_44_Result",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_44_Processing",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_44_Start",0);
	EnableControl(panel_name,gErrField45,0);
	EnableControl(panel_name,gPanel45,0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_45_Result",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_45_Processing",0);
	EnableControl(panel_name,"panel_M_ASG_49_0_0_45_Start",0);
	EnableControl(panel_name,gErrField46,0);
	EnableControl(panel_name,gPanel46,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_46",0);
	EnableControl(panel_name,gErrField47,0);
	EnableControl(panel_name,gPanel47,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_47",0);
	EnableControl(panel_name,gErrField48,0);
	EnableControl(panel_name,gPanel48,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_48",0);
	EnableControl(panel_name,gErrField49,0);
	EnableControl(panel_name,gPanel49,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_49",0);
	EnableControl(panel_name,gErrField50,0);
	EnableControl(panel_name,gPanel50,0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_50",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_50_Changed",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_50_SetGet",0);
	EnableControl(panel_name,gErrField51,0);
	EnableControl(panel_name,gPanel51,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_51",0);
	EnableControl(panel_name,gErrField52,0);
	EnableControl(panel_name,gPanel52,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_52",0);
	EnableControl(panel_name,gErrField53,0);
	EnableControl(panel_name,gPanel53,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_53",0);
	EnableControl(panel_name,gErrField54,0);
	EnableControl(panel_name,gPanel54,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_54",0);
	EnableControl(panel_name,gErrField55,0);
	EnableControl(panel_name,gPanel55,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_55",0);
	EnableControl(panel_name,gErrField56,0);
	EnableControl(panel_name,gPanel56,0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_56",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_56_Changed",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_56_SetGet",0);
	EnableControl(panel_name,gErrField57,0);
	EnableControl(panel_name,gPanel57,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_57",0);
	EnableControl(panel_name,gErrField58,0);
	EnableControl(panel_name,gPanel58,0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_58",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_58_Changed",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_58_SetGet",0);
	EnableControl(panel_name,gErrField59,0);
	EnableControl(panel_name,gPanel59,0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_59",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_59_Changed",0);
	EnableControl(panel_name,"panel_A_ASG_49_0_0_59_SetGet",0);
	EnableControl(panel_name,gErrField60,0);
	EnableControl(panel_name,gPanel60,0);
	EnableControl(panel_name,"panel_P_ASG_49_0_0_60",0);

}

EnableFctCtrl ()
{
  	EnableControl(panel_name, common_panel_name, 1);
		 EnableControl(panel_name,gPanel14,1);
		 EnableControl(panel_name,gErrField14,1);
		 EnableControl(panel_name,gPanel15,1);
		 EnableControl(panel_name,gErrField15,1);
		 EnableControl(panel_name,gPanel16,1);
		 EnableControl(panel_name,gErrField16,1);
		 EnableControl(panel_name,gPanel17,1);
		 EnableControl(panel_name,gErrField17,1);
		 EnableControl(panel_name,gPanel18,1);
		 EnableControl(panel_name,gErrField18,1);
		 EnableControl(panel_name,gPanel19,1);
		 EnableControl(panel_name,gErrField19,1);
		 EnableControl(panel_name,gPanel20,1);
		 EnableControl(panel_name,gErrField20,1);
		 EnableControl(panel_name,gPanel21,1);
		 EnableControl(panel_name,gErrField21,1);
		 EnableControl(panel_name,gPanel22,1);
		 EnableControl(panel_name,gErrField22,1);
		 EnableControl(panel_name,gPanel23,1);
		 EnableControl(panel_name,gErrField23,1);
		 EnableControl(panel_name,gPanel24,1);
		 EnableControl(panel_name,gErrField24,1);
		 EnableControl(panel_name,gPanel25,1);
		 EnableControl(panel_name,gErrField25,1);
		 EnableControl(panel_name,gPanel26,1);
		 EnableControl(panel_name,gErrField26,1);
		 EnableControl(panel_name,gPanel27,1);
		 EnableControl(panel_name,gErrField27,1);
		 EnableControl(panel_name,gPanel28,1);
		 EnableControl(panel_name,gErrField28,1);
		 EnableControl(panel_name,gPanel29,1);
		 EnableControl(panel_name,gErrField29,1);
		 EnableControl(panel_name,gPanel30,1);
		 EnableControl(panel_name,gErrField30,1);
		 EnableControl(panel_name,gPanel31,1);
		 EnableControl(panel_name,gErrField31,1);
		 EnableControl(panel_name,gPanel32,1);
		 EnableControl(panel_name,gErrField32,1);
		 EnableControl(panel_name,gPanel33,1);
		 EnableControl(panel_name,gErrField33,1);
		 EnableControl(panel_name,gPanel34,1);
		 EnableControl(panel_name,gErrField34,1);
		 EnableControl(panel_name,gPanel35,1);
		 EnableControl(panel_name,gErrField35,1);
		 EnableControl(panel_name,gPanel36,1);
		 EnableControl(panel_name,gErrField36,1);
		 EnableControl(panel_name,gPanel37,1);
		 EnableControl(panel_name,gErrField37,1);
		 EnableControl(panel_name,gPanel38,1);
		 EnableControl(panel_name,gErrField38,1);
		 EnableControl(panel_name,gPanel39,1);
		 EnableControl(panel_name,gErrField39,1);
		 EnableControl(panel_name,gPanel40,1);
		 EnableControl(panel_name,gErrField40,1);
		 EnableControl(panel_name,gPanel41,1);
		 EnableControl(panel_name,gErrField41,1);
		 EnableControl(panel_name,gPanel42,1);
		 EnableControl(panel_name,gErrField42,1);
		 EnableControl(panel_name,gPanel43,1);
		 EnableControl(panel_name,gErrField43,1);
		 EnableControl(panel_name,gPanel44,1);
		 EnableControl(panel_name,gErrField44,1);
		 EnableControl(panel_name,gPanel45,1);
		 EnableControl(panel_name,gErrField45,1);
		 EnableControl(panel_name,gPanel46,1);
		 EnableControl(panel_name,gErrField46,1);
		 EnableControl(panel_name,gPanel47,1);
		 EnableControl(panel_name,gErrField47,1);
		 EnableControl(panel_name,gPanel48,1);
		 EnableControl(panel_name,gErrField48,1);
		 EnableControl(panel_name,gPanel49,1);
		 EnableControl(panel_name,gErrField49,1);
		 EnableControl(panel_name,gPanel50,1);
		 EnableControl(panel_name,gErrField50,1);
		 EnableControl(panel_name,gPanel51,1);
		 EnableControl(panel_name,gErrField51,1);
		 EnableControl(panel_name,gPanel52,1);
		 EnableControl(panel_name,gErrField52,1);
		 EnableControl(panel_name,gPanel53,1);
		 EnableControl(panel_name,gErrField53,1);
		 EnableControl(panel_name,gPanel54,1);
		 EnableControl(panel_name,gErrField54,1);
		 EnableControl(panel_name,gPanel55,1);
		 EnableControl(panel_name,gErrField55,1);
		 EnableControl(panel_name,gPanel56,1);
		 EnableControl(panel_name,gErrField56,1);
		 EnableControl(panel_name,gPanel57,1);
		 EnableControl(panel_name,gErrField57,1);
		 EnableControl(panel_name,gPanel58,1);
		 EnableControl(panel_name,gErrField58,1);
		 EnableControl(panel_name,gPanel59,1);
		 EnableControl(panel_name,gErrField59,1);
		 EnableControl(panel_name,gPanel60,1);
		 EnableControl(panel_name,gErrField60,1);

}

EnableConfigCtrl ()
{
  	if(getValue(C_ASG_49_0_0_1_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox1, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox1, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_2_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox2, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox2, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_3_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox3, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox3, MakeRGB(250,0,0));
	}
	EnableControl(panel_name, "panel_P_ASG_49_0_0_4", 1);
	if(getValue(P_ASG_49_0_0_4_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox4, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox4, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_14_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_14",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_14",1);
		setControlForeColor(panel_name, gCheckbox14, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_14",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_14",0);
		setControlForeColor(panel_name, gCheckbox14, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_15_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_15",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_15",1);
		setControlForeColor(panel_name, gCheckbox15, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_15",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_15",0);
		setControlForeColor(panel_name, gCheckbox15, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_16_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_16",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_16",1);
		setControlForeColor(panel_name, gCheckbox16, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_16",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_16",0);
		setControlForeColor(panel_name, gCheckbox16, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_17_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_17",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_17",1);
		setControlForeColor(panel_name, gCheckbox17, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_17",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_17",0);
		setControlForeColor(panel_name, gCheckbox17, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_18_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_18",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_18",1);
		setControlForeColor(panel_name, gCheckbox18, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_18",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_18",0);
		setControlForeColor(panel_name, gCheckbox18, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_19_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_19",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_19",1);
		setControlForeColor(panel_name, gCheckbox19, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_19",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_19",0);
		setControlForeColor(panel_name, gCheckbox19, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_20_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_20",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_20",1);
		setControlForeColor(panel_name, gCheckbox20, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_20",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_20",0);
		setControlForeColor(panel_name, gCheckbox20, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_21_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_21",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_21",1);
		setControlForeColor(panel_name, gCheckbox21, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_21",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_21",0);
		setControlForeColor(panel_name, gCheckbox21, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_22_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_22",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_22",1);
		setControlForeColor(panel_name, gCheckbox22, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_22",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_22",0);
		setControlForeColor(panel_name, gCheckbox22, MakeRGB(250,0,0));
	}
	if(getValue(A_ASG_49_0_0_23_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_23",1);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_23",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_23_Changed",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_23_SetGet",1);
		setControlForeColor(panel_name, gCheckbox23, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_23",0);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_23",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_23_Changed",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_23_SetGet",0);
		setControlForeColor(panel_name, gCheckbox23, MakeRGB(250,0,0));
	}
	if(getValue(M_ASG_49_0_0_24_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_24",1);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_24",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_24_Processing",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_24_Start",1);
		setControlForeColor(panel_name, gCheckbox24, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_24",0);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_24",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_24_Processing",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_24_Start",0);
		setControlForeColor(panel_name, gCheckbox24, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_25_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_25",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_25",1);
		setControlForeColor(panel_name, gCheckbox25, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_25",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_25",0);
		setControlForeColor(panel_name, gCheckbox25, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_26_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_26",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_26",1);
		setControlForeColor(panel_name, gCheckbox26, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_26",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_26",0);
		setControlForeColor(panel_name, gCheckbox26, MakeRGB(250,0,0));
	}
	if(getValue(A_ASG_49_0_0_27_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_27",1);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_27",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_27_Changed",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_27_SetGet",1);
		setControlForeColor(panel_name, gCheckbox27, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_27",0);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_27",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_27_Changed",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_27_SetGet",0);
		setControlForeColor(panel_name, gCheckbox27, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_28_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_28",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_28",1);
		setControlForeColor(panel_name, gCheckbox28, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_28",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_28",0);
		setControlForeColor(panel_name, gCheckbox28, MakeRGB(250,0,0));
	}
	if(getValue(M_ASG_49_0_0_29_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_29",1);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_29",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_29_Processing",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_29_Start",1);
		setControlForeColor(panel_name, gCheckbox29, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_29",0);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_29",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_29_Processing",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_29_Start",0);
		setControlForeColor(panel_name, gCheckbox29, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_30_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_30",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_30",1);
		setControlForeColor(panel_name, gCheckbox30, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_30",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_30",0);
		setControlForeColor(panel_name, gCheckbox30, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_31_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_31",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_31",1);
		setControlForeColor(panel_name, gCheckbox31, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_31",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_31",0);
		setControlForeColor(panel_name, gCheckbox31, MakeRGB(250,0,0));
	}
	if(getValue(A_ASG_49_0_0_32_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_32",1);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_32",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_32_Changed",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_32_SetGet",1);
		setControlForeColor(panel_name, gCheckbox32, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_32",0);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_32",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_32_Changed",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_32_SetGet",0);
		setControlForeColor(panel_name, gCheckbox32, MakeRGB(250,0,0));
	}
	if(getValue(A_ASG_49_0_0_33_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_33",1);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_33",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_33_Changed",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_33_SetGet",1);
		setControlForeColor(panel_name, gCheckbox33, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_33",0);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_33",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_33_Changed",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_33_SetGet",0);
		setControlForeColor(panel_name, gCheckbox33, MakeRGB(250,0,0));
	}
	if(getValue(M_ASG_49_0_0_34_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_34",1);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_34",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_34_Processing",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_34_Start",1);
		setControlForeColor(panel_name, gCheckbox34, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_34",0);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_34",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_34_Processing",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_34_Start",0);
		setControlForeColor(panel_name, gCheckbox34, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_35_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_35",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_35",1);
		setControlForeColor(panel_name, gCheckbox35, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_35",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_35",0);
		setControlForeColor(panel_name, gCheckbox35, MakeRGB(250,0,0));
	}
	if(getValue(A_ASG_49_0_0_36_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_36",1);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_36",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_36_Changed",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_36_SetGet",1);
		setControlForeColor(panel_name, gCheckbox36, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_36",0);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_36",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_36_Changed",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_36_SetGet",0);
		setControlForeColor(panel_name, gCheckbox36, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_37_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_37",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_37",1);
		setControlForeColor(panel_name, gCheckbox37, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_37",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_37",0);
		setControlForeColor(panel_name, gCheckbox37, MakeRGB(250,0,0));
	}
	if(getValue(M_ASG_49_0_0_38_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_38",1);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_38",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_38_Processing",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_38_Start",1);
		setControlForeColor(panel_name, gCheckbox38, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_38",0);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_38",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_38_Processing",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_38_Start",0);
		setControlForeColor(panel_name, gCheckbox38, MakeRGB(250,0,0));
	}
	if(getValue(M_ASG_49_0_0_39_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_39",1);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_39",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_39_Processing",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_39_Start",1);
		setControlForeColor(panel_name, gCheckbox39, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_39",0);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_39",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_39_Processing",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_39_Start",0);
		setControlForeColor(panel_name, gCheckbox39, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_40_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_40",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_40",1);
		setControlForeColor(panel_name, gCheckbox40, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_40",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_40",0);
		setControlForeColor(panel_name, gCheckbox40, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_41_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_41",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_41",1);
		setControlForeColor(panel_name, gCheckbox41, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_41",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_41",0);
		setControlForeColor(panel_name, gCheckbox41, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_42_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_42",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_42",1);
		setControlForeColor(panel_name, gCheckbox42, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_42",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_42",0);
		setControlForeColor(panel_name, gCheckbox42, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_43_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_43",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_43",1);
		setControlForeColor(panel_name, gCheckbox43, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_43",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_43",0);
		setControlForeColor(panel_name, gCheckbox43, MakeRGB(250,0,0));
	}
	if(getValue(M_ASG_49_0_0_44_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_44",1);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_44",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_44_Processing",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_44_Start",1);
		setControlForeColor(panel_name, gCheckbox44, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_44",0);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_44",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_44_Processing",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_44_Start",0);
		setControlForeColor(panel_name, gCheckbox44, MakeRGB(250,0,0));
	}
	if(getValue(M_ASG_49_0_0_45_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_45",1);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_45",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_45_Processing",1);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_45_Start",1);
		setControlForeColor(panel_name, gCheckbox45, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_ASG_49_0_0_45",0);
		EnableControl(panel_name,"errfield_M_ASG_49_0_0_45",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_45_Processing",0);
		EnableControl(panel_name,"panel_M_ASG_49_0_0_45_Start",0);
		setControlForeColor(panel_name, gCheckbox45, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_46_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_46",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_46",1);
		setControlForeColor(panel_name, gCheckbox46, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_46",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_46",0);
		setControlForeColor(panel_name, gCheckbox46, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_47_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_47",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_47",1);
		setControlForeColor(panel_name, gCheckbox47, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_47",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_47",0);
		setControlForeColor(panel_name, gCheckbox47, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_48_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_48",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_48",1);
		setControlForeColor(panel_name, gCheckbox48, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_48",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_48",0);
		setControlForeColor(panel_name, gCheckbox48, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_49_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_49",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_49",1);
		setControlForeColor(panel_name, gCheckbox49, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_49",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_49",0);
		setControlForeColor(panel_name, gCheckbox49, MakeRGB(250,0,0));
	}
	if(getValue(A_ASG_49_0_0_50_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_50",1);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_50",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_50_Changed",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_50_SetGet",1);
		setControlForeColor(panel_name, gCheckbox50, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_50",0);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_50",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_50_Changed",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_50_SetGet",0);
		setControlForeColor(panel_name, gCheckbox50, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_51_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_51",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_51",1);
		setControlForeColor(panel_name, gCheckbox51, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_51",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_51",0);
		setControlForeColor(panel_name, gCheckbox51, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_52_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_52",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_52",1);
		setControlForeColor(panel_name, gCheckbox52, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_52",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_52",0);
		setControlForeColor(panel_name, gCheckbox52, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_53_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_53",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_53",1);
		setControlForeColor(panel_name, gCheckbox53, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_53",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_53",0);
		setControlForeColor(panel_name, gCheckbox53, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_54_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_54",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_54",1);
		setControlForeColor(panel_name, gCheckbox54, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_54",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_54",0);
		setControlForeColor(panel_name, gCheckbox54, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_55_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_55",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_55",1);
		setControlForeColor(panel_name, gCheckbox55, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_55",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_55",0);
		setControlForeColor(panel_name, gCheckbox55, MakeRGB(250,0,0));
	}
	if(getValue(A_ASG_49_0_0_56_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_56",1);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_56",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_56_Changed",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_56_SetGet",1);
		setControlForeColor(panel_name, gCheckbox56, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_56",0);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_56",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_56_Changed",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_56_SetGet",0);
		setControlForeColor(panel_name, gCheckbox56, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_57_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_57",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_57",1);
		setControlForeColor(panel_name, gCheckbox57, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_57",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_57",0);
		setControlForeColor(panel_name, gCheckbox57, MakeRGB(250,0,0));
	}
	if(getValue(A_ASG_49_0_0_58_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_58",1);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_58",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_58_Changed",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_58_SetGet",1);
		setControlForeColor(panel_name, gCheckbox58, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_58",0);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_58",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_58_Changed",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_58_SetGet",0);
		setControlForeColor(panel_name, gCheckbox58, MakeRGB(250,0,0));
	}
	if(getValue(A_ASG_49_0_0_59_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_59",1);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_59",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_59_Changed",1);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_59_SetGet",1);
		setControlForeColor(panel_name, gCheckbox59, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_ASG_49_0_0_59",0);
		EnableControl(panel_name,"errfield_A_ASG_49_0_0_59",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_59_Changed",0);
		EnableControl(panel_name,"panel_A_ASG_49_0_0_59_SetGet",0);
		setControlForeColor(panel_name, gCheckbox59, MakeRGB(250,0,0));
	}
	if(getValue(P_ASG_49_0_0_60_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_60",1);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_60",1);
		setControlForeColor(panel_name, gCheckbox60, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_ASG_49_0_0_60",0);
		EnableControl(panel_name,"errfield_P_ASG_49_0_0_60",0);
		setControlForeColor(panel_name, gCheckbox60, MakeRGB(250,0,0));
	}

}

DisableReservedFld ()
{
  	EnableControl(panel_name,"P_ASG_49_0_0_25_2_reserved",0);
	EnableControl(panel_name,"P_ASG_49_0_0_47_2_reserved",0);
	EnableControl(panel_name,"P_ASG_49_0_0_47_3_reserved",0);

}

resetErrfieldColor()
{
  	setControlBackColor(panel_name, "errfield_C_ASG_49_0_0_1", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_2", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_3", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_4", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_14", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_15", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_16", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_17", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_18", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_19", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_20", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_21", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_22", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_23", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_24", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_25", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_26", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_27", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_28", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_29", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_30", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_31", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_32", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_33", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_34", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_35", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_36", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_37", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_38", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_39", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_40", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_41", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_42", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_43", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_44", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_45", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_46", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_47", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_48", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_49", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_50", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_51", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_52", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_53", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_54", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_55", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_56", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_57", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_58", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_59", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_60", MakeRGB(255,255,255));

}

CANoe_Shutdown ()
{
	// Timer 
	canceltimer(TaskTimer);		//cancel real CAN-communication timer

	// Ruecksetzen der Hintergrundfarbe der Error-Felder
	resetErrfieldColor();
	// Deaktivierung aller Panel Elemente 
	DisableFctCtrl();
	EnableControl(panel_name, bapconfig_panel_name, 0); 
	EnableConfigCtrl();

}

on timer TaskTimer
{
  /*** Aufruf des BAP Task in DLL fuer NODE_INDEX ***/
	BAP150_Task(NODE_INDEX);	

	/*** Pollen ueber die anstehenden Indications (Lesen aus DLL, Auslesen eines Puffers der DLL) ***/
	BAP_DLL_Indication();	
	
	/*** Pollen ueber die anstehenden Requests (Schreiben in DLL, dort werden evt. Sendeauftraege gesetzt) ***/
	BAP_DLL_Request();
	
	/*** Abarbeiten der ausstehenden Sendeauftraege innerhalb der BAP DLL und Versenden ueber CANoe ***/
	BAP_CAN_TX_Request();
  
  BAP_DLL_SetRxData();

	/*** Retriggern des Timers mit 10 ms ***/
	setTimer(TaskTimer, TaskTime); // @TODO bei anderer Taskzeit muss hier modifiziert werden
}


BAP_DLL_SetRxData()
{
  int i;
  byte gRxBuffer[1500];
  for(i=0;i<gUdpSocketCnt;i++)
    UdpReceiveFrom(gUdpSockets[i].Handle, gRxBuffer, 0);

}

BAP_DLL_Indication()	//function to get received BAP-data from DLL (at BAL-interface)
{
	int i, length, datalength, temp;
	byte Indication_data[BAP_buffer_size];		// indication data from DLL
	dword Indication_header[6];					// indication header from DLL
	byte BAP_data_type;

	//init local variables
	length=0;
	datalength=0;
	temp=0;
	BAP_data_type=0;

	for(i=0;i<6;i++)
		Indication_header[i]=0;

	for(i=0;i<BAP_buffer_size;i++)
		Indication_data[i]=0;

	// BAP-Stack needs this information for successful BAP150_GetIndication 
	Indication_header[4]=BAP_buffer_size;

	while (BAP150_GetInd(NODE_INDEX, Indication_header, Indication_data) == 0)
	{		
		//read header and write in global variable
		for (i = 0; i < 6; i++) {
			gBAP_Indication_header[i]=Indication_header[i];	
		}

		// nur Bytesequneces haben Datenanteil
		if (gBAP_Indication_header[3] == Bap_byteSequence)
		{
			for (i = 0; i < BAP_buffer_size; i++) {
				gBAP_Indication_data[i]=Indication_data[i];	
			}
		}	
		// Verarbeiten der Indication
		Process_Current_Indication();

		// Vorbereiten fuer naechsten Durchlauf 
		Indication_header[4]=BAP_buffer_size;
	} 
}

ChangeConfig(long paramIndex,long config[])
{

        byte temp ;
        temp = BAP150_ChangeConfig(NODE_INDEX, paramIndex, config);
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP150_ChangeConfig for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP150_ChangeConfig error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        
}

PrintIndicationError(char reason[])
{
	writelineEx(gError_Trace, 0, "%s - %s lsgId:%d fctid:%d indType:%s dataType:%s",
		reason, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]]);
}

BapOnOff(byte _on)
{
  int length, temp;
  char Path[255];
  
  /***** Einschalten ******/
  if(_on==1){
    
    if(@BusType_ASG49_0 == 0){  // Uses CAN
      getAbsFilePath(dbcan_path, Path, 255);
      if(BAP180_LoadDB(NODE_INDEX,20, 0, Path) != 0){
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
      }
    }
    else if(@BusType_ASG49_0== 2){  // Uses Ethernet
      getAbsFilePath(dbeth_path, Path, 255);
      if(BAP180_LoadDB(NODE_INDEX,20, 2, Path) != 0){
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
      }
    }
    
    /**** Laden des BAP XML Files ****/
    getAbsFilePath(xml_path, Path, 255);
    writelineEx(gBAP_Trace, 0, "Load BAP-XML-File: %s", Path);
    if (BAP150_LoadConfig(NODE_INDEX, Path) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
    }

    if (BAP150_AddCanMap(NODE_INDEX, 20, 1) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Mappen!");
    }
  
    // soll der BAP Stack wieder initlialisiert werden?                                 
    if(gBAP_Init==0){
        //gBAP_Init=1;
        temp=BAP150_Init(NODE_INDEX, LSGID);
        if(temp==0)
            writelineEx(gBAP_Trace, 0, "BAP_Init for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP_Init error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);         
    }

    // Initialisierung aller Variablen
    Initialize_Variables();                     

    // Aktivierung aller Panelelemente
    //EnableFctCtrl();
    initInvalidFields();
    EnableControl(panel_name, common_panel_name, 1);
    EnableControl(panel_name, bapconfig_panel_name, 1); 
    DisableReservedFld();
    
    if (@BusType_ASG49_0 == 2) { // Uses Ethernet
  EthernetCreateSocket();
}


    //BAP-Shutdown
    temp = BAP150_Shutdown(NODE_INDEX, LSGID);
    if(temp==0)
        writelineEx(gBAP_Trace, 0, "BAP_Shutdown for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
    else
        writelineEx(gError_Trace, 0, "BAP_Shutdown error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX); 

    //BAP-Start
    temp = BAP150_Start(NODE_INDEX, LSGID);             
    if(temp == 0)
        writelineEx(gBAP_Trace, 0, "BAP_Start for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
    else
        writelineEx(gError_Trace, 0, "BAP_Start error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        

    // setze den Timer fuer den zyklischen Aufruf des CANoe-"Tasks"
    setTimer(TaskTimer, 10);                
EnableBusSelectorPanel(0);
    //  BAPFsg_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID, DEBUG_SWITCH_ON);    
  }
  else{ /***** Ausschalten ****/
      
      BAP150_Shutdown(NODE_INDEX,LSGID);
      
      CANoe_Shutdown();
      
      if (@BusType_ASG49_0 == 2) { // Uses Ethernet
  CloseUdpSocket();
}

  }
}

Initialize_Variables()	//initialize/reset all global variables
{
	int i;
	byte  Init_data[BAP_buffer_size];	// InitSend data for DLL

	/**** Request Buffer Geschichten initialisieren ****/
	for (i = 0; i < Requestbuffer_lines; i++)
	{
		gBAP_Requestbuffer_status[i] = 0;
	}
	for (i = 0; i < BAP_buffer_size; i++)
	{
		Init_data[i] = 0;
	}
	
	/* Wert im Eingabefeld initialisieren*/
	putValue(P_ASG_49_0_0_19, 0);
	getValue(P_ASG_49_0_0_20,Init_data);
	putValue(P_ASG_49_0_0_20,Init_data, 2);
	getValue(P_ASG_49_0_0_25,Init_data);
	putValue(P_ASG_49_0_0_25,Init_data, 2);
	putValue(P_ASG_49_0_0_40, 0);
	putValue(P_ASG_49_0_0_41, 0);
	putValue(P_ASG_49_0_0_43, 0);
	getValue(P_ASG_49_0_0_47,Init_data);
	putValue(P_ASG_49_0_0_47,Init_data, 4);
	/* Farbe setzen*/
	putValue(C_ASG_49_0_0_1_State,"");
	setControlBackColor(panel_name, "errfield_C_ASG_49_0_0_1_State", MakeRGB(255,255,255));

}

initInvalidFields()	//initialize/reset all global variables
{
	    setControlBackColor(panel_name, "panel1_edit", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_4", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_14", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_15", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_16", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_17", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_18", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_19", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_20", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_21", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_22", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_23", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_23_Changed",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_24_Result",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_24_Processing",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_25", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_26", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_27", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_27_Changed",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_28", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_29_Result",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_29_Processing",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_30", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_31", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_32", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_32_Changed",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_33", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_33_Changed",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_34_Result",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_34_Processing",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_35", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_36", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_36_Changed",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_37", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_38_Result",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_38_Processing",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_39_Result",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_39_Processing",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_40", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_41", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_42", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_43", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_44_Result",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_44_Processing",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_45_Result",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_M_ASG_49_0_0_45_Processing",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_46", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_47", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_48", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_49", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_50", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_50_Changed",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_51", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_52", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_53", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_54", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_55", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_56", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_56_Changed",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_57", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_58", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_58_Changed",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_59", MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_A_ASG_49_0_0_59_Changed",MakeRGB(220,220,220));
    setControlBackColor(panel_name, "panel_P_ASG_49_0_0_60", MakeRGB(220,220,220));

}

on start
{
	// noch nicht eingeschaltet
	gSG_PowerOnOff=0;
	// noch nicht initialisiert
	gBAP_Init=0;
	// open the panel, nur fuer CANoe-Version >= 5.1 erlaubt
	//openPanel(panel_name);
	// deaktiviere alle aktiven Panel Elemente, ausser AN/AUSS
    CANoe_Shutdown();
    // ungueltige Felder initialisieren
    initInvalidFields();    
    
	EnableBusSelectorPanel(1);
	// default bus: CAN
	EnableCANFrame(1);
	EnableFRFrame(0);
	EnableEthernetFrame(0);

}

BAP_CAN_TX_Request()	//Function to send BAP-data over CAN
{
   int i;
   byte DestIp[16];
   byte TX_Data[1500];				// CAN-data
   byte TX_Data_FR[10];    		// FlexRay-Data
   dword TX_Header[13];			// Header
   message 0x100 TX_Message;	// dummy-message, Adresse wird noch modifiziert
   
   byte send_result;
   
   if(@BusType_ASG49_0 == 0){  // Uses CAN
      TX_Header[0] = 1; /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
   		TX_Header[2] = 8; // max-Length of TX_Data

		// Pollen ueber die Queue, die von der DLL zur Verfuegung gestellt wird
		// Diese Daten muessen ueber den CAN Bus gesendet werden
	   	while (BAP180_GetTxData(NODE_INDEX,TX_Header,TX_Data) == 0) {	
        TX_Message.CAN = TX_Header[1]; 		//CAN channel
        TX_Message.ID = TX_Header[3]; 	  //Can ID
        TX_Message.DataLength = TX_Header[2]; 		// received length
			
			  for (i=0; i<TX_Message.DataLength; i++) {	//CAN data-bytes
		  		TX_Message.byte(i) = TX_Data[i];
		  	}
		  	
        TX_Message.EDL = 0;
        TX_Message.BRS = 0;
        if(TX_Header[4] & 2) 
          TX_Message.EDL = 1;
        if(TX_Header[4] & 4) 
          TX_Message.BRS = 1;
        
		  	output(TX_Message);					//send CAN message
		  	
		  	//Versions Output
		  	if(TX_Data[0] == 0x40 && TX_Data[1] == 0x00 && TX_Header[2] == 4)
		  	{
		    	writelineEx(gBAP_Trace, 0,"Major Version: %i, Minor Version: %i", TX_Data[2], TX_Data[3]);
		  	}       
		  	TX_Header[2] = 8; // max-Length of TX_Data
	   	} 
   }
   else if (@BusType_ASG49_0 == 2) { // Uses Ethernet
  TX_Header[0] = 4; // /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
  TX_Header[2] = 1500; // max-Length of TX_Data
  while( BAP180_GetTxData( NODE_INDEX,TX_Header,TX_Data ) == 0 ) {
    for(i=0; i<8;i++)
    {
       DestIp[2*i]   = (byte)(TX_Header[i+4]>>8);
       DestIp[2*i+1] = (byte)(TX_Header[i+4]&0xFF);
    }
    for (i=0; i<TX_Header[2]; i++) {	//CAN data-bytes
     TX_Data.byte(i) = TX_Data[i];
    }

    send_result = UdpSendTo(gUdpSockets[TX_Header[3]-1].Handle, DestIp, TX_Header[12], TX_Data, TX_Header[2]);

    if (0 == send_result){

    }else{
      writeLineEx(0,3, "UdpSendTo failed, error code %d, last error %d", send_result, IpGetLastError());
    }

    TX_Header[2] = 1500; // max-Length of TX_Data
  }
}

}

ringbuffer_write (byte lsgID, byte fctID, byte request, byte dataType, word length, dword singleData, byte data[])
{
	int bufferline, i;

	bufferline = getNextWriteIndex();	//get next free position in ring-buffer

	if (bufferline == -1) 
	{
		writelineEx(gError_Trace, 0, "Crititcal Error: No free buffer found!");
		return;
	}
		
	gBAP_Request_header[bufferline][0] = lsgID;	// LSG
	gBAP_Request_header[bufferline][1] = fctID;	// FCT
	gBAP_Request_header[bufferline][3] = dataType; // dataType

    //writelineEx(gBAP_Trace, 0, "Write request in buffer ASG NODEINDEX:%d lsgid:%d fctid:%d requesttype:%d datatype:%d length:%d", 
    //        NODE_INDEX,lsgID,fctID,request,dataType,length);
	switch (dataType)
	{
		case Bap_void:
			gBAP_Request_header[bufferline][2] = request;	// request
			gBAP_Request_header[bufferline][4] = 0;	// length
				// Void
			// @TODO?		
			break;
		case Bap_uint8:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten		
			break;
		case Bap_uint16:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten
			break;			
		case Bap_uint32:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten		
			break;	
		case Bap_byteSequence:
			gBAP_Request_header[bufferline][2] = request;	// request
			gBAP_Request_header[bufferline][4] = length;	// length
			// Daten der ByteSequence kopieren
			for(i = 0; i < BAP_buffer_size; i++)									
				gBAP_Request_data[bufferline][i] = data[i];
		case Bap_error:
			gBAP_Request_header[bufferline][5] = singleData;	// Errorcode						
			break;
		default:
			break;
	}

			

}

float round (float value, float step)
{
	return _floor(value / step + 0.5) * step;
}

Request_Void (byte lsgID, byte fctID, byte request)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_void, 0, 0, dataArray);	
}

Request_Int8 (byte lsgID, byte fctID, byte request, dword data)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_uint8, 0, data, dataArray);

}

Request_Int16 (byte lsgID, byte fctID, byte request, dword data)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_uint16, 0, data, dataArray);

}

Request_Int32 (byte lsgID, byte fctID, byte request, dword data)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_uint32, 0, data, dataArray);
}

Request_ByteSequence (byte lsgID, byte fctID, byte request, byte data[], word length)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	// Fuellen des Arrays
	for(i=0;i<length;i++) dataArray [i]=data[i];

	ringbuffer_write (lsgID, fctID, request, Bap_byteSequence, length, 0, dataArray);
}

Request_Error (byte lsgID, byte fctID, byte errorCode)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, 0, Bap_error, 0, errorCode, dataArray);
}

DisplayRequestErrorCode(dword fctID, dword errCode)
{
       switch(fctID)
   {
       case C_ASG_49_0_0_1_ID:
           gC_ASG_49_0_0_1_ErrCode = 0;
           putValue(C_ASG_49_0_0_1_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_C_ASG_49_0_0_1", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_2_ID:
           gP_ASG_49_0_0_2_ErrCode = 0;
           putValue(P_ASG_49_0_0_2_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_2", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_3_ID:
           gP_ASG_49_0_0_3_ErrCode = 0;
           putValue(P_ASG_49_0_0_3_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_3", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_4_ID:
           gP_ASG_49_0_0_4_ErrCode = 0;
           putValue(P_ASG_49_0_0_4_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_4", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_14_ID:
           gP_ASG_49_0_0_14_ErrCode = 0;
           putValue(P_ASG_49_0_0_14_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_14", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_15_ID:
           gP_ASG_49_0_0_15_ErrCode = 0;
           putValue(P_ASG_49_0_0_15_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_15", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_16_ID:
           gP_ASG_49_0_0_16_ErrCode = 0;
           putValue(P_ASG_49_0_0_16_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_16", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_17_ID:
           gP_ASG_49_0_0_17_ErrCode = 0;
           putValue(P_ASG_49_0_0_17_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_17", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_18_ID:
           gP_ASG_49_0_0_18_ErrCode = 0;
           putValue(P_ASG_49_0_0_18_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_18", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_19_ID:
           gP_ASG_49_0_0_19_ErrCode = 0;
           putValue(P_ASG_49_0_0_19_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_19", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_20_ID:
           gP_ASG_49_0_0_20_ErrCode = 0;
           putValue(P_ASG_49_0_0_20_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_20", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_21_ID:
           gP_ASG_49_0_0_21_ErrCode = 0;
           putValue(P_ASG_49_0_0_21_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_21", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_22_ID:
           gP_ASG_49_0_0_22_ErrCode = 0;
           putValue(P_ASG_49_0_0_22_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_22", MakeRGB(255,79,79));
       break;
       case A_ASG_49_0_0_23_ID:
           gA_ASG_49_0_0_23_ErrCode = 0;
           putValue(A_ASG_49_0_0_23_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_ASG_49_0_0_23", MakeRGB(255,79,79));
       break;
       case M_ASG_49_0_0_24_ID:
           gM_ASG_49_0_0_24_ErrCode = 0;
           putValue(M_ASG_49_0_0_24_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_ASG_49_0_0_24", MakeRGB(255,79,79));
           putValue(M_ASG_49_0_0_24_State,  "ReqErr");
       break;
       case P_ASG_49_0_0_25_ID:
           gP_ASG_49_0_0_25_ErrCode = 0;
           putValue(P_ASG_49_0_0_25_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_25", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_26_ID:
           gP_ASG_49_0_0_26_ErrCode = 0;
           putValue(P_ASG_49_0_0_26_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_26", MakeRGB(255,79,79));
       break;
       case A_ASG_49_0_0_27_ID:
           gA_ASG_49_0_0_27_ErrCode = 0;
           putValue(A_ASG_49_0_0_27_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_ASG_49_0_0_27", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_28_ID:
           gP_ASG_49_0_0_28_ErrCode = 0;
           putValue(P_ASG_49_0_0_28_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_28", MakeRGB(255,79,79));
       break;
       case M_ASG_49_0_0_29_ID:
           gM_ASG_49_0_0_29_ErrCode = 0;
           putValue(M_ASG_49_0_0_29_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_ASG_49_0_0_29", MakeRGB(255,79,79));
           putValue(M_ASG_49_0_0_29_State,  "ReqErr");
       break;
       case P_ASG_49_0_0_30_ID:
           gP_ASG_49_0_0_30_ErrCode = 0;
           putValue(P_ASG_49_0_0_30_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_30", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_31_ID:
           gP_ASG_49_0_0_31_ErrCode = 0;
           putValue(P_ASG_49_0_0_31_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_31", MakeRGB(255,79,79));
       break;
       case A_ASG_49_0_0_32_ID:
           gA_ASG_49_0_0_32_ErrCode = 0;
           putValue(A_ASG_49_0_0_32_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_ASG_49_0_0_32", MakeRGB(255,79,79));
       break;
       case A_ASG_49_0_0_33_ID:
           gA_ASG_49_0_0_33_ErrCode = 0;
           putValue(A_ASG_49_0_0_33_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_ASG_49_0_0_33", MakeRGB(255,79,79));
       break;
       case M_ASG_49_0_0_34_ID:
           gM_ASG_49_0_0_34_ErrCode = 0;
           putValue(M_ASG_49_0_0_34_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_ASG_49_0_0_34", MakeRGB(255,79,79));
           putValue(M_ASG_49_0_0_34_State,  "ReqErr");
       break;
       case P_ASG_49_0_0_35_ID:
           gP_ASG_49_0_0_35_ErrCode = 0;
           putValue(P_ASG_49_0_0_35_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_35", MakeRGB(255,79,79));
       break;
       case A_ASG_49_0_0_36_ID:
           gA_ASG_49_0_0_36_ErrCode = 0;
           putValue(A_ASG_49_0_0_36_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_ASG_49_0_0_36", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_37_ID:
           gP_ASG_49_0_0_37_ErrCode = 0;
           putValue(P_ASG_49_0_0_37_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_37", MakeRGB(255,79,79));
       break;
       case M_ASG_49_0_0_38_ID:
           gM_ASG_49_0_0_38_ErrCode = 0;
           putValue(M_ASG_49_0_0_38_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_ASG_49_0_0_38", MakeRGB(255,79,79));
           putValue(M_ASG_49_0_0_38_State,  "ReqErr");
       break;
       case M_ASG_49_0_0_39_ID:
           gM_ASG_49_0_0_39_ErrCode = 0;
           putValue(M_ASG_49_0_0_39_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_ASG_49_0_0_39", MakeRGB(255,79,79));
           putValue(M_ASG_49_0_0_39_State,  "ReqErr");
       break;
       case P_ASG_49_0_0_40_ID:
           gP_ASG_49_0_0_40_ErrCode = 0;
           putValue(P_ASG_49_0_0_40_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_40", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_41_ID:
           gP_ASG_49_0_0_41_ErrCode = 0;
           putValue(P_ASG_49_0_0_41_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_41", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_42_ID:
           gP_ASG_49_0_0_42_ErrCode = 0;
           putValue(P_ASG_49_0_0_42_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_42", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_43_ID:
           gP_ASG_49_0_0_43_ErrCode = 0;
           putValue(P_ASG_49_0_0_43_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_43", MakeRGB(255,79,79));
       break;
       case M_ASG_49_0_0_44_ID:
           gM_ASG_49_0_0_44_ErrCode = 0;
           putValue(M_ASG_49_0_0_44_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_ASG_49_0_0_44", MakeRGB(255,79,79));
           putValue(M_ASG_49_0_0_44_State,  "ReqErr");
       break;
       case M_ASG_49_0_0_45_ID:
           gM_ASG_49_0_0_45_ErrCode = 0;
           putValue(M_ASG_49_0_0_45_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_ASG_49_0_0_45", MakeRGB(255,79,79));
           putValue(M_ASG_49_0_0_45_State,  "ReqErr");
       break;
       case P_ASG_49_0_0_46_ID:
           gP_ASG_49_0_0_46_ErrCode = 0;
           putValue(P_ASG_49_0_0_46_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_46", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_47_ID:
           gP_ASG_49_0_0_47_ErrCode = 0;
           putValue(P_ASG_49_0_0_47_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_47", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_48_ID:
           gP_ASG_49_0_0_48_ErrCode = 0;
           putValue(P_ASG_49_0_0_48_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_48", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_49_ID:
           gP_ASG_49_0_0_49_ErrCode = 0;
           putValue(P_ASG_49_0_0_49_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_49", MakeRGB(255,79,79));
       break;
       case A_ASG_49_0_0_50_ID:
           gA_ASG_49_0_0_50_ErrCode = 0;
           putValue(A_ASG_49_0_0_50_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_ASG_49_0_0_50", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_51_ID:
           gP_ASG_49_0_0_51_ErrCode = 0;
           putValue(P_ASG_49_0_0_51_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_51", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_52_ID:
           gP_ASG_49_0_0_52_ErrCode = 0;
           putValue(P_ASG_49_0_0_52_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_52", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_53_ID:
           gP_ASG_49_0_0_53_ErrCode = 0;
           putValue(P_ASG_49_0_0_53_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_53", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_54_ID:
           gP_ASG_49_0_0_54_ErrCode = 0;
           putValue(P_ASG_49_0_0_54_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_54", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_55_ID:
           gP_ASG_49_0_0_55_ErrCode = 0;
           putValue(P_ASG_49_0_0_55_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_55", MakeRGB(255,79,79));
       break;
       case A_ASG_49_0_0_56_ID:
           gA_ASG_49_0_0_56_ErrCode = 0;
           putValue(A_ASG_49_0_0_56_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_ASG_49_0_0_56", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_57_ID:
           gP_ASG_49_0_0_57_ErrCode = 0;
           putValue(P_ASG_49_0_0_57_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_57", MakeRGB(255,79,79));
       break;
       case A_ASG_49_0_0_58_ID:
           gA_ASG_49_0_0_58_ErrCode = 0;
           putValue(A_ASG_49_0_0_58_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_ASG_49_0_0_58", MakeRGB(255,79,79));
       break;
       case A_ASG_49_0_0_59_ID:
           gA_ASG_49_0_0_59_ErrCode = 0;
           putValue(A_ASG_49_0_0_59_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_ASG_49_0_0_59", MakeRGB(255,79,79));
       break;
       case P_ASG_49_0_0_60_ID:
           gP_ASG_49_0_0_60_ErrCode = 0;
           putValue(P_ASG_49_0_0_60_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_ASG_49_0_0_60", MakeRGB(255,79,79));
       break;
       default:
           writelineEx(gError_Trace, 0, "%s%d/%d Unknown Functionid in  displayErrorCode", SGtype, LSGID,fctID);
   }

}

BAP_DLL_Request ()
{
	int i;
    int l=0;
	byte temp;
	byte Request_data[4096];	//Request data for DLL
	dword Request_header[6];	//Request header for DLL
	byte dataValid;
	int nextElementToRead;
	
	// defaultmaessig ist senden OK
	dataValid = 1;

	// loeschen der Daten "Container"
	for(i=0;i<6;i++)
		Request_header[i]=0;
	for(i=0;i<BAP_buffer_size;i++)
		Request_data[i]=0;

    
	// Verarbeiten aller noch offenen Requests	
	while ((nextElementToRead = getNextReadIndex()) != -1) 
	{
		// Fuer alle Datentypen gleich
		Request_header[0]=gBAP_Request_header [nextElementToRead][0];		//LSG-ID
		Request_header[1]=gBAP_Request_header [nextElementToRead][1];		//Function-ID
		Request_header[2]=gBAP_Request_header [nextElementToRead][2];		//request type
		Request_header[3]=gBAP_Request_header [nextElementToRead][3];		//BAP data type

		switch(gBAP_Request_header[nextElementToRead][3]){
			case Bap_uint32:
                l=2;
            case Bap_uint16:
                l++;
            case Bap_uint8:
			case Bap_error: // Request (2) wird dabei ignoriert
                l++;
			case Bap_void:  // Datenfeld (5) wird dabei ignoriert
				Request_header[4]=l;												//	not used
				Request_header[5]=gBAP_Request_header [nextElementToRead][5];		// Daten
			break;
			case Bap_byteSequence:									
				Request_header[4]=gBAP_Request_header [nextElementToRead][4];		// length
				Request_header[5]=0;												// not used

				// data-array for BAP-DLL funcion 'BAP_Request'
				for(i=0;i<BAP_buffer_size;i++)
					Request_data[i]=gBAP_Request_data [nextElementToRead][i];
				break;			
			default:
				writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Request_header[nextElementToRead][3]);
				dataValid = 0;
			break;			
		}
		
		if(dataValid){
            // wie heisst der Request?
            writelineEx(gBAP_Trace, 0, "%s%d/%d BAP_Request %s datatype:%s length:%d", SGtype, Request_header[0],Request_header[1],Requesttype_Text[Request_header[2]],Datatype_Text[Request_header[3]],Request_header[4]);
			temp = BAP150_Request(NODE_INDEX, Request_header, Request_data);	//send data to BAP-DLL	
			// BAP-Request failed
            if(temp != 0){
                // Fehlercode: Request failed
                writelineEx(gError_Trace, 0, "%s%d/%d Error during BAP_Request errorcode: 0x%X", SGtype, Request_header[0],Request_header[1],temp);
                DisplayRequestErrorCode(Request_header[1],temp);
            } 
		}

	}
} 

int getNextReadIndex ()
{
	int i, ret;
	// der Puffer wird nach dem naechsten zu lesenden Eintrag durchsucht
	// Existiert keiner wird -1 zurueckgegeben
	ret = -1;

	for (i = 0; i < Requestbuffer_lines; i++)
	{
		if (gBAP_Requestbuffer_status[i] == 1)
		{
			// zum verschicken
			ret = i;
			// und wieder freigeben
			gBAP_Requestbuffer_status[i] = 0;
			break;
		}
	}

	return (ret);
}

int getNextWriteIndex ()
{
	int i, ret;
	// der Puffer wird nach dem naechsten freien Eintrag durchsucht
	// Existiert keiner wird -1 zurueckgegeben
	ret = -1;

	for (i = 0; i < Requestbuffer_lines; i++)
	{
		if (gBAP_Requestbuffer_status[i] == 0)
		{
			// zum schreiben
			ret = i;
			// belegen
			gBAP_Requestbuffer_status[i] = 1;
			break;
		}
	}

	return (ret);
}

byte  isBitForFctSetted(word fctid, byte fctList[])
{
    byte byteNo ;
    byte bitno ;
    byte fctValue ;

    byteNo = fctid / 8;
    bitno = fctid % 8;

    fctValue = 0x80 >> bitno;

    return (fctList[byteNo] & fctValue)?1:0;
}

UpdateAllProperties()
{
	Request_Void(LSGID,P_ASG_49_0_0_2_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_3_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_4_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_14_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_15_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_16_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_17_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_18_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_19_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_20_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_21_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_22_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_25_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_26_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_28_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_30_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_31_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_35_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_37_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_40_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_41_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_42_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_43_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_46_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_47_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_48_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_49_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_51_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_52_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_53_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_54_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_55_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_57_ID,DataGet_REQ);
	Request_Void(LSGID,P_ASG_49_0_0_60_ID,DataGet_REQ);

}

Process_Current_Indication ()
{
   int rxsize;
   int txsize;
   byte temp[BAP_buffer_size];
   char buffer[BAP_buffer_size];
   if(strncmp(Datatype_Text[gBAP_Indication_header[3]], "acknowledge", 4)!=0) 
       writelineEx(gBAP_Trace, 0, "NodeIndex: %d: CurrentIndication %s lsgid:%d fctid:%d indType:%s dataType=%s length=%d",
               NODE_INDEX, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   else 
       writelineEx(gBAP_Trace, 0, "Internal acknowledge %s-%d fctid:%d indType:%s dataType=%s length=%d",
               SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Acknowledgetype_Text[gBAP_Indication_header[5]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   switch(gBAP_Indication_header[0])  // LSGID
   {
   case LSGID:
       switch(gBAP_Indication_header[1]) // FCTID
       {
    case C_ASG_49_0_0_1_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
        case Bap_void:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case Data_IND: // Indicationtyp pruefen
                    //Now every Property with Cache is updated
                    UpdateAllProperties();
                    putValue(C_ASG_49_0_0_1_State, "StatusAll");
                    setControlBackColor(panel_name, "errfield_C_ASG_49_0_0_1_State", MakeRGB(255,255,255));
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
               snprintf(buffer,BAP_buffer_size-1,"Error %02x", gBAP_Indication_header[5]);
               putValue(C_ASG_49_0_0_1_State, buffer);
               setControlBackColor(panel_name, "errfield_C_ASG_49_0_0_1_State", MakeRGB(255,79,79));
               break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_2_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case Reset_IND: // Nur fuer FctId 2 (BAPConfig) relevant
                   putValue(C_ASG_49_0_0_1_State, "");
                   setControlBackColor(panel_name, "errfield_C_ASG_49_0_0_1_State", MakeRGB(255,255,255));
                   initInvalidFields();
                   // Fall through
                case Data_IND: // Indicationtyp pruefen
                    // Daten setzen
                    putValue(BAPCFG_ASG_49_0_0_ProtocolMajor, gBAP_Indication_data[0]);
                    putValue(BAPCFG_ASG_49_0_0_ProtocolMinor, gBAP_Indication_data[1]);
                    putValue(BAPCFG_ASG_49_0_0_LsgClassMajor, gBAP_Indication_data[2]);
                    putValue(BAPCFG_ASG_49_0_0_LsgClassMinor, gBAP_Indication_data[3]);
                    putValue(BAPCFG_ASG_49_0_0_DFMajor, gBAP_Indication_data[4]);
                    putValue(BAPCFG_ASG_49_0_0_DFMinor, gBAP_Indication_data[5]);
                    setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_2", MakeRGB(255,255,255));  
                    setControlBackColor(panel_name, "panel1_edit", MakeRGB(255,255,255));  
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                putValue(P_ASG_49_0_0_2_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_2", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel1_edit", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_3_ID: 
       switch(gBAP_Indication_header[3]) // Datentyp
       {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                    case Reset_IND: // Nur fuer FctId 2 (BAPConfig) relevant
                    {
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_3", MakeRGB(255,255,255));
                        if(isBitForFctSetted(M_ASG_49_0_0_29_ID,gBAP_Indication_data))
                        {
                            putValue(M_ASG_49_0_0_29_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox29,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel29, 1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_29_Result",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_29_Processing",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_29_Start",1);
                        }
                        else
                        {
                            putValue(M_ASG_49_0_0_29_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox29,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel29, 0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_29_Result",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_29_Processing",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_29_Start",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_28_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_28_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox28,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel28, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_28",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_28_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox28,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel28, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_28",0);
                        }

                        if(isBitForFctSetted(A_ASG_49_0_0_59_ID,gBAP_Indication_data))
                        {
                            putValue(A_ASG_49_0_0_59_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox59,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel59, 1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_59",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_59_Changed",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_59_SetGet",1);
                        }
                        else
                        {
                            putValue(A_ASG_49_0_0_59_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox59,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel59, 0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_59",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_59_Changed",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_59_SetGet",0);
                        }

                        if(isBitForFctSetted(A_ASG_49_0_0_27_ID,gBAP_Indication_data))
                        {
                            putValue(A_ASG_49_0_0_27_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox27,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel27, 1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_27",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_27_Changed",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_27_SetGet",1);
                        }
                        else
                        {
                            putValue(A_ASG_49_0_0_27_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox27,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel27, 0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_27",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_27_Changed",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_27_SetGet",0);
                        }

                        if(isBitForFctSetted(A_ASG_49_0_0_58_ID,gBAP_Indication_data))
                        {
                            putValue(A_ASG_49_0_0_58_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox58,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel58, 1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_58",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_58_Changed",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_58_SetGet",1);
                        }
                        else
                        {
                            putValue(A_ASG_49_0_0_58_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox58,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel58, 0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_58",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_58_Changed",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_58_SetGet",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_26_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_26_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox26,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel26, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_26",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_26_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox26,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel26, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_26",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_57_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_57_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox57,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel57, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_57",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_57_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox57,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel57, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_57",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_25_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_25_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox25,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel25, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_25",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_25_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox25,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel25, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_25",0);
                        }

                        if(isBitForFctSetted(A_ASG_49_0_0_56_ID,gBAP_Indication_data))
                        {
                            putValue(A_ASG_49_0_0_56_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox56,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel56, 1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_56",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_56_Changed",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_56_SetGet",1);
                        }
                        else
                        {
                            putValue(A_ASG_49_0_0_56_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox56,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel56, 0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_56",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_56_Changed",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_56_SetGet",0);
                        }

                        if(isBitForFctSetted(M_ASG_49_0_0_24_ID,gBAP_Indication_data))
                        {
                            putValue(M_ASG_49_0_0_24_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox24,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel24, 1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_24_Result",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_24_Processing",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_24_Start",1);
                        }
                        else
                        {
                            putValue(M_ASG_49_0_0_24_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox24,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel24, 0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_24_Result",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_24_Processing",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_24_Start",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_55_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_55_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox55,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel55, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_55",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_55_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox55,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel55, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_55",0);
                        }

                        if(isBitForFctSetted(A_ASG_49_0_0_23_ID,gBAP_Indication_data))
                        {
                            putValue(A_ASG_49_0_0_23_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox23,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel23, 1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_23",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_23_Changed",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_23_SetGet",1);
                        }
                        else
                        {
                            putValue(A_ASG_49_0_0_23_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox23,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel23, 0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_23",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_23_Changed",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_23_SetGet",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_54_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_54_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox54,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel54, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_54",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_54_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox54,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel54, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_54",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_22_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_22_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox22,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel22, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_22",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_22_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox22,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel22, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_22",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_53_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_53_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox53,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel53, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_53",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_53_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox53,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel53, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_53",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_21_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_21_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox21,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel21, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_21",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_21_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox21,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel21, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_21",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_52_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_52_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox52,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel52, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_52",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_52_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox52,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel52, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_52",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_20_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_20_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox20,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel20, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_20",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_20_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox20,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel20, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_20",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_51_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_51_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox51,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel51, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_51",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_51_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox51,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel51, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_51",0);
                        }

                        if(isBitForFctSetted(A_ASG_49_0_0_50_ID,gBAP_Indication_data))
                        {
                            putValue(A_ASG_49_0_0_50_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox50,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel50, 1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_50",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_50_Changed",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_50_SetGet",1);
                        }
                        else
                        {
                            putValue(A_ASG_49_0_0_50_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox50,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel50, 0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_50",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_50_Changed",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_50_SetGet",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_19_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_19_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox19,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel19, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_19",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_19_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox19,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel19, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_19",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_18_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_18_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox18,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel18, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_18",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_18_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox18,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel18, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_18",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_49_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_49_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox49,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel49, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_49",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_49_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox49,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel49, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_49",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_17_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_17_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox17,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel17, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_17",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_17_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox17,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel17, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_17",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_48_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_48_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox48,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel48, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_48",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_48_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox48,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel48, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_48",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_16_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_16_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox16,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel16, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_16",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_16_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox16,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel16, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_16",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_47_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_47_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox47,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel47, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_47",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_47_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox47,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel47, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_47",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_4_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_4_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox4,MakeRGB(0,240,0));
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_4_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox4,MakeRGB(250,0,0));
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_15_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_15_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox15,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel15, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_15",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_15_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox15,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel15, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_15",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_46_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_46_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox46,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel46, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_46",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_46_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox46,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel46, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_46",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_3_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_3_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox3,MakeRGB(0,240,0));
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_3_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox3,MakeRGB(250,0,0));
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_14_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_14_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox14,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel14, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_14",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_14_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox14,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel14, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_14",0);
                        }

                        if(isBitForFctSetted(M_ASG_49_0_0_45_ID,gBAP_Indication_data))
                        {
                            putValue(M_ASG_49_0_0_45_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox45,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel45, 1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_45_Result",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_45_Processing",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_45_Start",1);
                        }
                        else
                        {
                            putValue(M_ASG_49_0_0_45_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox45,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel45, 0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_45_Result",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_45_Processing",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_45_Start",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_2_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_2_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox2,MakeRGB(0,240,0));
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_2_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox2,MakeRGB(250,0,0));
                        }

                        if(isBitForFctSetted(C_ASG_49_0_0_1_ID,gBAP_Indication_data))
                        {
                            putValue(C_ASG_49_0_0_1_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox1,MakeRGB(0,240,0));
                        }
                        else
                        {
                            putValue(C_ASG_49_0_0_1_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox1,MakeRGB(250,0,0));
                        }

                        if(isBitForFctSetted(M_ASG_49_0_0_44_ID,gBAP_Indication_data))
                        {
                            putValue(M_ASG_49_0_0_44_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox44,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel44, 1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_44_Result",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_44_Processing",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_44_Start",1);
                        }
                        else
                        {
                            putValue(M_ASG_49_0_0_44_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox44,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel44, 0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_44_Result",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_44_Processing",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_44_Start",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_43_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_43_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox43,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel43, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_43",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_43_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox43,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel43, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_43",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_42_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_42_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox42,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel42, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_42",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_42_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox42,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel42, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_42",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_41_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_41_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox41,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel41, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_41",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_41_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox41,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel41, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_41",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_40_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_40_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox40,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel40, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_40",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_40_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox40,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel40, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_40",0);
                        }

                        if(isBitForFctSetted(M_ASG_49_0_0_39_ID,gBAP_Indication_data))
                        {
                            putValue(M_ASG_49_0_0_39_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox39,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel39, 1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_39_Result",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_39_Processing",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_39_Start",1);
                        }
                        else
                        {
                            putValue(M_ASG_49_0_0_39_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox39,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel39, 0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_39_Result",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_39_Processing",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_39_Start",0);
                        }

                        if(isBitForFctSetted(M_ASG_49_0_0_38_ID,gBAP_Indication_data))
                        {
                            putValue(M_ASG_49_0_0_38_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox38,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel38, 1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_38_Result",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_38_Processing",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_38_Start",1);
                        }
                        else
                        {
                            putValue(M_ASG_49_0_0_38_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox38,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel38, 0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_38_Result",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_38_Processing",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_38_Start",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_37_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_37_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox37,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel37, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_37",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_37_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox37,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel37, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_37",0);
                        }

                        if(isBitForFctSetted(A_ASG_49_0_0_36_ID,gBAP_Indication_data))
                        {
                            putValue(A_ASG_49_0_0_36_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox36,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel36, 1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_36",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_36_Changed",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_36_SetGet",1);
                        }
                        else
                        {
                            putValue(A_ASG_49_0_0_36_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox36,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel36, 0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_36",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_36_Changed",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_36_SetGet",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_35_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_35_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox35,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel35, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_35",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_35_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox35,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel35, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_35",0);
                        }

                        if(isBitForFctSetted(M_ASG_49_0_0_34_ID,gBAP_Indication_data))
                        {
                            putValue(M_ASG_49_0_0_34_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox34,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel34, 1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_34_Result",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_34_Processing",1);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_34_Start",1);
                        }
                        else
                        {
                            putValue(M_ASG_49_0_0_34_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox34,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel34, 0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_34_Result",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_34_Processing",0);
                            EnableControl(panel_name, "panel_M_ASG_49_0_0_34_Start",0);
                        }

                        if(isBitForFctSetted(A_ASG_49_0_0_33_ID,gBAP_Indication_data))
                        {
                            putValue(A_ASG_49_0_0_33_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox33,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel33, 1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_33",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_33_Changed",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_33_SetGet",1);
                        }
                        else
                        {
                            putValue(A_ASG_49_0_0_33_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox33,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel33, 0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_33",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_33_Changed",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_33_SetGet",0);
                        }

                        if(isBitForFctSetted(A_ASG_49_0_0_32_ID,gBAP_Indication_data))
                        {
                            putValue(A_ASG_49_0_0_32_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox32,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel32, 1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_32",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_32_Changed",1);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_32_SetGet",1);
                        }
                        else
                        {
                            putValue(A_ASG_49_0_0_32_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox32,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel32, 0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_32",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_32_Changed",0);
                            EnableControl(panel_name, "panel_A_ASG_49_0_0_32_SetGet",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_31_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_31_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox31,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel31, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_31",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_31_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox31,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel31, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_31",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_30_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_30_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox30,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel30, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_30",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_30_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox30,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel30, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_30",0);
                        }

                        if(isBitForFctSetted(P_ASG_49_0_0_60_ID,gBAP_Indication_data))
                        {
                            putValue(P_ASG_49_0_0_60_FctLstItemEn, 1);
                            setControlForeColor(panel_name, gCheckbox60,MakeRGB(0,240,0));
                            EnableControl(panel_name, gPanel60, 1);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_60",1);
                        }
                        else
                        {
                            putValue(P_ASG_49_0_0_60_FctLstItemEn, 0);
                            setControlForeColor(panel_name, gCheckbox60,MakeRGB(250,0,0));
                            EnableControl(panel_name, gPanel60, 0);
                            EnableControl(panel_name, "panel_P_ASG_49_0_0_60",0);
                        }

                     }
                        break;
                    default:
                      writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal IndType : lsgid:%d fctid:%d indType:%d",
                           NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], gBAP_Indication_header[2]);
                       break;
                  }
                  break;
            case Bap_error:
                putValue(P_ASG_49_0_0_3_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_3", MakeRGB(255,79,79));
                break;
            case Bap_acknowledge:
            	 break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
       }
       break;
    case P_ASG_49_0_0_4_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
           case Bap_uint8:
                   switch(gBAP_Indication_header[2]) // IndType
                   {
                       case Data_IND: // Indicationtyp pruefen
                           // Daten setzen
                           putValue(P_ASG_49_0_0_4, gBAP_Indication_header[5]);
                           setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_4", MakeRGB(255,255,255));  
                           setControlBackColor(panel_name, "panel_P_ASG_49_0_0_4", MakeRGB(255,255,255));  
                           break;                              
                       default:
                           PrintIndicationError("Illegal IndType");
                           break;
                   }
                   break;
            case Bap_error:
                putValue(P_ASG_49_0_0_4_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_4", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_4", MakeRGB(220,220,220));  
                if(gBAP_Indication_header[5]==0x21)
                {
                   putValue(C_ASG_49_0_0_1_State, "");
                   setControlBackColor(panel_name, "errfield_C_ASG_49_0_0_1_State", MakeRGB(255,255,255));
                }
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_14_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_14, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_14", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_14", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_14_ErrCode = 0;
                putValue(P_ASG_49_0_0_14_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_14", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_14", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_15_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_15, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_15", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_15", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_15_ErrCode = 0;
                putValue(P_ASG_49_0_0_15_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_15", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_15", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_16_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_16, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_16", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_16", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_16_ErrCode = 0;
                putValue(P_ASG_49_0_0_16_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_16", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_16", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_17_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_17, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_17", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_17", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_17_ErrCode = 0;
                putValue(P_ASG_49_0_0_17_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_17", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_17", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_18_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_18, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_18", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_18", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_18_ErrCode = 0;
                putValue(P_ASG_49_0_0_18_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_18", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_18", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_19_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case Data_IND: // Indicationtyp pruefen
                            // Daten setzen
                            putValue(P_ASG_49_0_0_19, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_19", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_P_ASG_49_0_0_19", MakeRGB(255,255,255));  
                            break;                              
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_ASG_49_0_0_19_ErrCode = 0;
                putValue(P_ASG_49_0_0_19_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_19", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_19", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_ASG_49_0_0_20_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_20, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_20", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_20", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_20_ErrCode = 0;
                putValue(P_ASG_49_0_0_20_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_20", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_20", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_21_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_21, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_21", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_21", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_21_ErrCode = 0;
                putValue(P_ASG_49_0_0_21_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_21", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_21", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_22_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_22, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_22", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_22", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_22_ErrCode = 0;
                putValue(P_ASG_49_0_0_22_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_22", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_22", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_ASG_49_0_0_23_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_23, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_23_DataInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_23", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_23", MakeRGB(255,255,255));  
                        break;
                    case Changed_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_23_Changed, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_23_ChangedInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_23", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_23_Changed", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gA_ASG_49_0_0_23_ErrCode = 0;
                putValue(A_ASG_49_0_0_23_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_23", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_23", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_23_Changed", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case M_ASG_49_0_0_24_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_uint8:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case Result_IND: 
                            putValue(M_ASG_49_0_0_24_State, "Result");
                            // Daten setzen
                            putValue(M_ASG_49_0_0_24_Result, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_24", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_24_Result", MakeRGB(255,255,255));  
                            break;
                        case Processing_IND:    
                            putValue(M_ASG_49_0_0_24_State, "Running");
                            // Wert von Processing anzeigen
                            putValue(M_ASG_49_0_0_24_Processing, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_24_Result", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_24_Processing", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_ASG_49_0_0_24_ErrCode = 0;
                putValue(M_ASG_49_0_0_24_State, "Error");
                putValue(M_ASG_49_0_0_24_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_24", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_24_Result", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_24_Processing", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_ASG_49_0_0_25_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_25, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_25", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_25", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_25_ErrCode = 0;
                putValue(P_ASG_49_0_0_25_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_25", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_25", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_26_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_26, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_26", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_26", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_26_ErrCode = 0;
                putValue(P_ASG_49_0_0_26_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_26", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_26", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_ASG_49_0_0_27_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_27, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_27_DataInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_27", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_27", MakeRGB(255,255,255));  
                        break;
                    case Changed_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_27_Changed, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_27_ChangedInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_27", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_27_Changed", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gA_ASG_49_0_0_27_ErrCode = 0;
                putValue(A_ASG_49_0_0_27_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_27", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_27", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_27_Changed", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_ASG_49_0_0_28_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_28, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_28", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_28", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_28_ErrCode = 0;
                putValue(P_ASG_49_0_0_28_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_28", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_28", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_ASG_49_0_0_29_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_uint8:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case Result_IND: 
                            putValue(M_ASG_49_0_0_29_State, "Result");
                            // Daten setzen
                            putValue(M_ASG_49_0_0_29_Result, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_29", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_29_Result", MakeRGB(255,255,255));  
                            break;
                        case Processing_IND:    
                            putValue(M_ASG_49_0_0_29_State, "Running");
                            // Wert von Processing anzeigen
                            putValue(M_ASG_49_0_0_29_Processing, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_29_Result", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_29_Processing", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_ASG_49_0_0_29_ErrCode = 0;
                putValue(M_ASG_49_0_0_29_State, "Error");
                putValue(M_ASG_49_0_0_29_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_29", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_29_Result", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_29_Processing", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_ASG_49_0_0_30_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case Data_IND: // Indicationtyp pruefen
                            // Daten setzen
                            putValue(P_ASG_49_0_0_30, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_30", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_P_ASG_49_0_0_30", MakeRGB(255,255,255));  
                            break;                              
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_ASG_49_0_0_30_ErrCode = 0;
                putValue(P_ASG_49_0_0_30_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_30", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_30", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_ASG_49_0_0_31_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case Data_IND: // Indicationtyp pruefen
                            // Daten setzen
                            putValue(P_ASG_49_0_0_31, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_31", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_P_ASG_49_0_0_31", MakeRGB(255,255,255));  
                            break;                              
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_ASG_49_0_0_31_ErrCode = 0;
                putValue(P_ASG_49_0_0_31_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_31", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_31", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case A_ASG_49_0_0_32_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_32, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_32_DataInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_32", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_32", MakeRGB(255,255,255));  
                        break;
                    case Changed_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_32_Changed, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_32_ChangedInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_32", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_32_Changed", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gA_ASG_49_0_0_32_ErrCode = 0;
                putValue(A_ASG_49_0_0_32_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_32", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_32", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_32_Changed", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case A_ASG_49_0_0_33_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_33, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_33_DataInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_33", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_33", MakeRGB(255,255,255));  
                        break;
                    case Changed_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_33_Changed, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_33_ChangedInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_33", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_33_Changed", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gA_ASG_49_0_0_33_ErrCode = 0;
                putValue(A_ASG_49_0_0_33_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_33", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_33", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_33_Changed", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case M_ASG_49_0_0_34_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_uint8:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case Result_IND: 
                            putValue(M_ASG_49_0_0_34_State, "Result");
                            // Daten setzen
                            putValue(M_ASG_49_0_0_34_Result, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_34", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_34_Result", MakeRGB(255,255,255));  
                            break;
                        case Processing_IND:    
                            putValue(M_ASG_49_0_0_34_State, "Running");
                            // Wert von Processing anzeigen
                            putValue(M_ASG_49_0_0_34_Processing, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_34_Result", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_34_Processing", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_ASG_49_0_0_34_ErrCode = 0;
                putValue(M_ASG_49_0_0_34_State, "Error");
                putValue(M_ASG_49_0_0_34_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_34", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_34_Result", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_34_Processing", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_ASG_49_0_0_35_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_35, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_35", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_35", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_35_ErrCode = 0;
                putValue(P_ASG_49_0_0_35_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_35", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_35", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_ASG_49_0_0_36_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_36, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_36_DataInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_36", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_36", MakeRGB(255,255,255));  
                        break;
                    case Changed_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_36_Changed, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_36_ChangedInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_36", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_36_Changed", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gA_ASG_49_0_0_36_ErrCode = 0;
                putValue(A_ASG_49_0_0_36_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_36", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_36", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_36_Changed", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_ASG_49_0_0_37_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_37, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_37", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_37", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_37_ErrCode = 0;
                putValue(P_ASG_49_0_0_37_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_37", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_37", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_ASG_49_0_0_38_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_uint8:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case Result_IND: 
                            putValue(M_ASG_49_0_0_38_State, "Result");
                            // Daten setzen
                            putValue(M_ASG_49_0_0_38_Result, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_38", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_38_Result", MakeRGB(255,255,255));  
                            break;
                        case Processing_IND:    
                            putValue(M_ASG_49_0_0_38_State, "Running");
                            // Wert von Processing anzeigen
                            putValue(M_ASG_49_0_0_38_Processing, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_38_Result", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_38_Processing", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_ASG_49_0_0_38_ErrCode = 0;
                putValue(M_ASG_49_0_0_38_State, "Error");
                putValue(M_ASG_49_0_0_38_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_38", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_38_Result", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_38_Processing", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_ASG_49_0_0_39_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case Result_IND: 
                            putValue(M_ASG_49_0_0_39_State, "Result");
                            // Daten setzen
                            putValue(M_ASG_49_0_0_39_Result, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_39", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_39_Result", MakeRGB(255,255,255));  
                            break;
                        case Processing_IND:    
                            putValue(M_ASG_49_0_0_39_State, "Running");
                            // Wert von Processing anzeigen
                            putValue(M_ASG_49_0_0_39_Processing, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_39", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_39_Processing", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_ASG_49_0_0_39_ErrCode = 0;
                putValue(M_ASG_49_0_0_39_State, "Error");
                putValue(M_ASG_49_0_0_39_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_39", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_39_Result", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_39_Processing", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_ASG_49_0_0_40_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case Data_IND: // Indicationtyp pruefen
                            // Daten setzen
                            putValue(P_ASG_49_0_0_40, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_40", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_P_ASG_49_0_0_40", MakeRGB(255,255,255));  
                            break;                              
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_ASG_49_0_0_40_ErrCode = 0;
                putValue(P_ASG_49_0_0_40_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_40", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_40", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_ASG_49_0_0_41_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case Data_IND: // Indicationtyp pruefen
                            // Daten setzen
                            putValue(P_ASG_49_0_0_41, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_41", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_P_ASG_49_0_0_41", MakeRGB(255,255,255));  
                            break;                              
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_ASG_49_0_0_41_ErrCode = 0;
                putValue(P_ASG_49_0_0_41_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_41", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_41", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_ASG_49_0_0_42_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_42, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_42", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_42", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_42_ErrCode = 0;
                putValue(P_ASG_49_0_0_42_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_42", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_42", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_43_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case Data_IND: // Indicationtyp pruefen
                            // Daten setzen
                            putValue(P_ASG_49_0_0_43, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_43", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_P_ASG_49_0_0_43", MakeRGB(255,255,255));  
                            break;                              
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_ASG_49_0_0_43_ErrCode = 0;
                putValue(P_ASG_49_0_0_43_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_43", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_43", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case M_ASG_49_0_0_44_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case Result_IND: 
                            putValue(M_ASG_49_0_0_44_State, "Result");
                            // Daten setzen
                            putValue(M_ASG_49_0_0_44_Result, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_44", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_44_Result", MakeRGB(255,255,255));  
                            break;
                        case Processing_IND:    
                            putValue(M_ASG_49_0_0_44_State, "Running");
                            // Wert von Processing anzeigen
                            putValue(M_ASG_49_0_0_44_Processing, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_44", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_44_Processing", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_ASG_49_0_0_44_ErrCode = 0;
                putValue(M_ASG_49_0_0_44_State, "Error");
                putValue(M_ASG_49_0_0_44_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_44", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_44_Result", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_44_Processing", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_ASG_49_0_0_45_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_uint8:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case Result_IND: 
                            putValue(M_ASG_49_0_0_45_State, "Result");
                            // Daten setzen
                            putValue(M_ASG_49_0_0_45_Result, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_45", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_45_Result", MakeRGB(255,255,255));  
                            break;
                        case Processing_IND:    
                            putValue(M_ASG_49_0_0_45_State, "Running");
                            // Wert von Processing anzeigen
                            putValue(M_ASG_49_0_0_45_Processing, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_45_Result", MakeRGB(255,255,255));  
                            setControlBackColor(panel_name, "panel_M_ASG_49_0_0_45_Processing", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_ASG_49_0_0_45_ErrCode = 0;
                putValue(M_ASG_49_0_0_45_State, "Error");
                putValue(M_ASG_49_0_0_45_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_ASG_49_0_0_45", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_45_Result", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_M_ASG_49_0_0_45_Processing", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_ASG_49_0_0_46_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_46, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_46", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_46", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_46_ErrCode = 0;
                putValue(P_ASG_49_0_0_46_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_46", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_46", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_47_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_47, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_47", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_47", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_47_ErrCode = 0;
                putValue(P_ASG_49_0_0_47_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_47", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_47", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_48_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_48, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_48", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_48", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_48_ErrCode = 0;
                putValue(P_ASG_49_0_0_48_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_48", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_48", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_49_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_49, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_49", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_49", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_49_ErrCode = 0;
                putValue(P_ASG_49_0_0_49_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_49", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_49", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_ASG_49_0_0_50_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_50, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_50_DataInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_50", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_50", MakeRGB(255,255,255));  
                        break;
                    case Changed_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_50_Changed, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_50_ChangedInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_50", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_50_Changed", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gA_ASG_49_0_0_50_ErrCode = 0;
                putValue(A_ASG_49_0_0_50_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_50", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_50", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_50_Changed", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_ASG_49_0_0_51_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_51, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_51", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_51", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_51_ErrCode = 0;
                putValue(P_ASG_49_0_0_51_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_51", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_51", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_52_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_52, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_52", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_52", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_52_ErrCode = 0;
                putValue(P_ASG_49_0_0_52_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_52", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_52", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_53_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_53, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_53", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_53", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_53_ErrCode = 0;
                putValue(P_ASG_49_0_0_53_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_53", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_53", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_54_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_54, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_54", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_54", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_54_ErrCode = 0;
                putValue(P_ASG_49_0_0_54_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_54", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_54", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_ASG_49_0_0_55_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_55, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_55", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_55", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_55_ErrCode = 0;
                putValue(P_ASG_49_0_0_55_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_55", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_55", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_ASG_49_0_0_56_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_56, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_56_DataInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_56", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_56", MakeRGB(255,255,255));  
                        break;
                    case Changed_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_56_Changed, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_56_ChangedInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_56", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_56_Changed", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gA_ASG_49_0_0_56_ErrCode = 0;
                putValue(A_ASG_49_0_0_56_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_56", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_56", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_56_Changed", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_ASG_49_0_0_57_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_57, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_57", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_57", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_57_ErrCode = 0;
                putValue(P_ASG_49_0_0_57_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_57", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_57", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_ASG_49_0_0_58_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_58, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_58_DataInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_58", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_58", MakeRGB(255,255,255));  
                        break;
                    case Changed_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_58_Changed, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_58_ChangedInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_58", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_58_Changed", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gA_ASG_49_0_0_58_ErrCode = 0;
                putValue(A_ASG_49_0_0_58_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_58", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_58", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_58_Changed", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case A_ASG_49_0_0_59_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_59, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_59_DataInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_59", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_59", MakeRGB(255,255,255));  
                        break;
                    case Changed_IND: // Indicationtyp pruefen
                        // Daten setzen
                        //putValue(A_ASG_49_0_0_59_Changed, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_ASG_49_0_0_59_ChangedInd();
                        setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_59", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_A_ASG_49_0_0_59_Changed", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gA_ASG_49_0_0_59_ErrCode = 0;
                putValue(A_ASG_49_0_0_59_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_ASG_49_0_0_59", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_59", MakeRGB(220,220,220));  
                setControlBackColor(panel_name, "panel_A_ASG_49_0_0_59_Changed", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_ASG_49_0_0_60_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case Data_IND: // Indicationtyp pruefen
                        // Daten setzen
                        putValue(P_ASG_49_0_0_60, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_60", MakeRGB(255,255,255));  
                        setControlBackColor(panel_name, "panel_P_ASG_49_0_0_60", MakeRGB(255,255,255));  
                        break;
                    default:
                        PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_ASG_49_0_0_60_ErrCode = 0;
                putValue(P_ASG_49_0_0_60_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_ASG_49_0_0_60", MakeRGB(255,79,79));  
                setControlBackColor(panel_name, "panel_P_ASG_49_0_0_60", MakeRGB(220,220,220));  
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
       default:
           writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal Fct: lsgid:%d fctid:%d indType:%d",
           NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], gBAP_Indication_header[2]);
           break;
       }
       break;
   default:
       writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal LSGID: lsgid:%d fctid:%d indType:%s", NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]]);
       break;
   }
}



intertelegram_err(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=1;
    data[3]=940;
    ChangeConfig(0x0020,data);
}

sequence_err(long fctId, long size)
{
    long data[5];
    long lastSeg;

    lastSeg = size-5;

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=lastSeg/7+1;
    data[3]=1;
    data[4]=(lastSeg/7+4) & 15;
    ChangeConfig(0x0021,data);
}

intertelegram_err_off(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    ChangeConfig(0x0020,data);
}

sequence_err_off(long fctId)
{
    long data[5];

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    data[4]=0;
    ChangeConfig(0x0021,data);
}

// START OF BUS CONFIG PANEL CAPL

EnableBusSelectorPanel(byte onOff)	
{	
	enableControl("ASG49_0 Bus Configuration","radio_can", onOff & 0);
	enableControl("ASG49_0 Bus Configuration","radio_fr", onOff & 0);
	enableControl("ASG49_0 Bus Configuration","radio_ethernet", onOff & 1);
	if (@BusType_ASG49_0 == 2){
		EnableEthernetFrame(onOff);
	}else if (@BusType_ASG49_0 == 1){
		EnableFRFrame(onOff);
	}else if (@BusType_ASG49_0 == 0){
		EnableCANFrame(onOff);
	}
}


EnableCANFrame(byte value)
{	
	long color;
	if (value){
		color = MakeRGB(0,0,0);
	}else{
		color = MakeRGB(125,125,125);
	}
	SetControlForeColor("ASG49_0 Bus Configuration", "id_can_label", color);
	SetControlForeColor("ASG49_0 Bus Configuration", "id_can", color);
	}


EnableFRFrame(byte value)
{	
	long color;
	if (value){
		color = MakeRGB(0,0,0);
	}else{
		color = MakeRGB(125,125,125);
	}
	SetControlForeColor("ASG49_0 Bus Configuration", "id_fr_label", color);
	SetControlForeColor("ASG49_0 Bus Configuration", "id_fr", color);
}	


EnableEthernetFrame(byte value)
{	
	long color;
	if (value){
	}else{
	}
	if (value){
		color = MakeRGB(0,0,0);
	}else{
		color = MakeRGB(125,125,125);
	}
	SetControlForeColor("ASG49_0 Bus Configuration", "id_eth_label", color);
	SetControlForeColor("ASG49_0 Bus Configuration", "id_eth", color);
}


on envVar BusType_ASG49_0
{	
	byte type;
	type = getValue(this);
	switch(type){
		case 0:
			EnableCANFrame(1);
			EnableFRFrame(0);
			EnableEthernetFrame(0);
			writeLineEx(0,1,"CAN Selected");
			break;
		case 1:
			EnableCANFrame(0);
			EnableFRFrame(1);
			EnableEthernetFrame(0);
			writeLineEx(0,1,"FR Selected");
			break;
		case 2:
			EnableCANFrame(0);
			EnableFRFrame(0);
			EnableEthernetFrame(1);
			writeLineEx(0,1,"ETHERNET Selected");
			break;
		default:
			writeLineEx(0,3, "!!BUS TYPE ERROR!!");    
			break;
	}
}	


OnUdpReceiveFrom( dword socket, long result, byte ipv6Address[], dword port, byte buffer[], dword size)
{
  int i;
  dword Header[13];
  byte Ipv6_temp[16];
  const long  INVALID_SOCKET = ~0;

  if(socket != INVALID_SOCKET)
  {
    if(result == 0)
    {
      Header[0] = 4; // /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
      Header[1] = 1;
      Header[2] = size;

     for(i=0;i<gUdpSocketCnt;i++)
      {
        if(gUdpSockets[i].Handle == socket)
        {
          Header[3] = gUdpSockets[i].Id;
          for(i=0; i<8; i++)
          {
            Header[i+4] = ((dword)ipv6Address[2*i]) << 8;
            Header[i+4] |= ((dword)ipv6Address[2*i+1]) ;
          }
          Header[12] = port;
          BAP180_SetRxData(NODE_INDEX, Header, buffer);
          
          break;
        }
      }
    }
  }
}


void CloseUdpSocket()
{
  int i;
  const long  INVALID_SOCKET =    ~0;
  for(i=0;i<gUdpSocketCnt;i++)
  {
    if(gUdpSockets[i].Handle != INVALID_SOCKET)
    {
      UdpClose(gUdpSockets[i].Handle);
      gUdpSockets[i].Handle = INVALID_SOCKET;
    }
  }
}


on envVar ON_OFF_ASG49_0
{
   BapOnOff(getvalue(this));
   gSG_PowerOnOff=getvalue(ON_OFF_ASG49_0);
}
on envVar C_ASG_49_0_0_1GetAll_BTN
{
 if (C_ASG_49_0_0_1GetAll_BTN_already_pressed == 0)
  {
     C_ASG_49_0_0_1GetAll_BTN_already_pressed = 1;
     Request_Void(LSGID, C_ASG_49_0_0_1_ID, DataGet_REQ); 
     putValue(C_ASG_49_0_0_1_State, "GetAll");
     setControlBackColor(panel_name, "errfield_C_ASG_49_0_0_1_State", MakeRGB(255,255,255));
 }
 else
 {
     C_ASG_49_0_0_1GetAll_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_2Get_BTN
{
 if (P_ASG_49_0_0_2Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_2_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_2",MakeRGB(255,255,255));
       P_ASG_49_0_0_2Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_2_ID, DataGet_REQ); 
       P_ASG_49_0_0_2Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_3Get_BTN
{
 if (P_ASG_49_0_0_3Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_3_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_3",MakeRGB(255,255,255));
       P_ASG_49_0_0_3Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_3_ID, DataGet_REQ); 
       P_ASG_49_0_0_3Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_4Get_BTN
{
 if (P_ASG_49_0_0_4Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_4_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_4",MakeRGB(255,255,255));
       P_ASG_49_0_0_4Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_4_ID, DataGet_REQ); 
       P_ASG_49_0_0_4Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_14Get_BTN
{
 if (P_ASG_49_0_0_14Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_14_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_14",MakeRGB(255,255,255));
       P_ASG_49_0_0_14Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_14_ID, DataGet_REQ); 
       P_ASG_49_0_0_14Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_14 // bus value of FSG_Setup (14).
{
	// opcodes: Error-Status
	byte param1; // maxVolume
	byte param2; // supportedVolumeTypes
	byte param3; // ReceptionList_AutoUpdate
	byte param4; // Setup_Extensions
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[4];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 4; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_14, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_14_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_14_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_ASG_49_0_0_14_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_ASG_49_0_0_14_4, param4);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_14_1_range // FSG_Setup.maxVolume 
{
	@P_ASG_49_0_0_14_1 = @P_ASG_49_0_0_14_1_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_14_1 // FSG_Setup.maxVolume
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // maxVolume
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_14_1, 1.0);
	@P_ASG_49_0_0_14_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_14, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_14,superval);
}

on envVar P_ASG_49_0_0_14_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedVolumeTypes
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_14_2,thisval);
}

on envVar P_ASG_49_0_0_14_2_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedVolumeTypes
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_2);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_14_2,thisval);
}

on envVar P_ASG_49_0_0_14_2_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedVolumeTypes
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_2);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_14_2,thisval);
}

on envVar P_ASG_49_0_0_14_2_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedVolumeTypes
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_2);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_14_2,thisval);
}

on envVar P_ASG_49_0_0_14_2_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedVolumeTypes
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_2);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_14_2,thisval);
}

on envVar P_ASG_49_0_0_14_2_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedVolumeTypes
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_2);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_ASG_49_0_0_14_2,thisval);
}

on envVar P_ASG_49_0_0_14_2_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedVolumeTypes
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_2);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_ASG_49_0_0_14_2,thisval);
}

on envVar P_ASG_49_0_0_14_2_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // supportedVolumeTypes
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_2);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_ASG_49_0_0_14_2,thisval);
}

on envVar P_ASG_49_0_0_14_2 // FSG_Setup.supportedVolumeTypes
{
	byte superval[4];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // supportedVolumeTypes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_14_2_0, 1);
	else
		putValue(P_ASG_49_0_0_14_2_0, 0);
	if(thisval&(mask<<1))
		putValue(P_ASG_49_0_0_14_2_1, 1);
	else
		putValue(P_ASG_49_0_0_14_2_1, 0);
	if(thisval&(mask<<2))
		putValue(P_ASG_49_0_0_14_2_2, 1);
	else
		putValue(P_ASG_49_0_0_14_2_2, 0);
	if(thisval&(mask<<3))
		putValue(P_ASG_49_0_0_14_2_3, 1);
	else
		putValue(P_ASG_49_0_0_14_2_3, 0);
	if(thisval&(mask<<4))
		putValue(P_ASG_49_0_0_14_2_4, 1);
	else
		putValue(P_ASG_49_0_0_14_2_4, 0);
	if(thisval&(mask<<5))
		putValue(P_ASG_49_0_0_14_2_5, 1);
	else
		putValue(P_ASG_49_0_0_14_2_5, 0);
	if(thisval&(mask<<6))
		putValue(P_ASG_49_0_0_14_2_6, 1);
	else
		putValue(P_ASG_49_0_0_14_2_6, 0);
	if(thisval&(mask<<7))
		putValue(P_ASG_49_0_0_14_2_7, 1);
	else
		putValue(P_ASG_49_0_0_14_2_7, 0);

    // Update superval
	getValue(P_ASG_49_0_0_14, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_14,superval);
}

on envVar P_ASG_49_0_0_14_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ReceptionList_AutoUpdate
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_14_3,thisval);
}

on envVar P_ASG_49_0_0_14_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ReceptionList_AutoUpdate
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_14_3,thisval);
}

on envVar P_ASG_49_0_0_14_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ReceptionList_AutoUpdate
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_14_3,thisval);
}

on envVar P_ASG_49_0_0_14_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ReceptionList_AutoUpdate
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_3);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_14_3,thisval);
}

on envVar P_ASG_49_0_0_14_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ReceptionList_AutoUpdate
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_14_3,thisval);
}

on envVar P_ASG_49_0_0_14_3_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ReceptionList_AutoUpdate
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_3);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_ASG_49_0_0_14_3,thisval);
}

on envVar P_ASG_49_0_0_14_3_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ReceptionList_AutoUpdate
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_3);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_ASG_49_0_0_14_3,thisval);
}

on envVar P_ASG_49_0_0_14_3_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ReceptionList_AutoUpdate
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_3);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_ASG_49_0_0_14_3,thisval);
}

on envVar P_ASG_49_0_0_14_3 // FSG_Setup.ReceptionList_AutoUpdate
{
	byte superval[4];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // ReceptionList_AutoUpdate
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_14_3_0, 1);
	else
		putValue(P_ASG_49_0_0_14_3_0, 0);
	if(thisval&(mask<<1))
		putValue(P_ASG_49_0_0_14_3_1, 1);
	else
		putValue(P_ASG_49_0_0_14_3_1, 0);
	if(thisval&(mask<<2))
		putValue(P_ASG_49_0_0_14_3_2, 1);
	else
		putValue(P_ASG_49_0_0_14_3_2, 0);
	if(thisval&(mask<<3))
		putValue(P_ASG_49_0_0_14_3_3, 1);
	else
		putValue(P_ASG_49_0_0_14_3_3, 0);
	if(thisval&(mask<<4))
		putValue(P_ASG_49_0_0_14_3_4, 1);
	else
		putValue(P_ASG_49_0_0_14_3_4, 0);
	if(thisval&(mask<<5))
		putValue(P_ASG_49_0_0_14_3_5, 1);
	else
		putValue(P_ASG_49_0_0_14_3_5, 0);
	if(thisval&(mask<<6))
		putValue(P_ASG_49_0_0_14_3_6, 1);
	else
		putValue(P_ASG_49_0_0_14_3_6, 0);
	if(thisval&(mask<<7))
		putValue(P_ASG_49_0_0_14_3_7, 1);
	else
		putValue(P_ASG_49_0_0_14_3_7, 0);

    // Update superval
	getValue(P_ASG_49_0_0_14, superval);
	superval[2]=thisval;
	putValue(P_ASG_49_0_0_14,superval);
}

on envVar P_ASG_49_0_0_14_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Setup_Extensions
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_14_4,thisval);
}

on envVar P_ASG_49_0_0_14_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Setup_Extensions
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_14_4,thisval);
}

on envVar P_ASG_49_0_0_14_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Setup_Extensions
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_14_4,thisval);
}

on envVar P_ASG_49_0_0_14_4_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Setup_Extensions
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_4);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_14_4,thisval);
}

on envVar P_ASG_49_0_0_14_4_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Setup_Extensions
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_14_4);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_14_4,thisval);
}

on envVar P_ASG_49_0_0_14_4 // FSG_Setup.Setup_Extensions
{
	byte superval[4];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Setup_Extensions
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_14_4_0, 1);
	else
		putValue(P_ASG_49_0_0_14_4_0, 0);
	if(thisval&(mask<<1))
		putValue(P_ASG_49_0_0_14_4_1, 1);
	else
		putValue(P_ASG_49_0_0_14_4_1, 0);
	if(thisval&(mask<<2))
		putValue(P_ASG_49_0_0_14_4_2, 1);
	else
		putValue(P_ASG_49_0_0_14_4_2, 0);
	if(thisval&(mask<<3))
		putValue(P_ASG_49_0_0_14_4_3, 1);
	else
		putValue(P_ASG_49_0_0_14_4_3, 0);
	if(thisval&(mask<<4))
		putValue(P_ASG_49_0_0_14_4_4, 1);
	else
		putValue(P_ASG_49_0_0_14_4_4, 0);

    // Update superval
	getValue(P_ASG_49_0_0_14, superval);
	superval[3]=thisval;
	putValue(P_ASG_49_0_0_14,superval);
}

on envVar P_ASG_49_0_0_15Get_BTN
{
 if (P_ASG_49_0_0_15Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_15_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_15",MakeRGB(255,255,255));
       P_ASG_49_0_0_15Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_15_ID, DataGet_REQ); 
       P_ASG_49_0_0_15Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_15 // bus value of FSG_OperationState (15).
{
	// opcodes: Error-Status
	byte param1; // OP_State
	byte param2; // HMI_State
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[2];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_15, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_15_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_15_2, param2);
}

on envVar P_ASG_49_0_0_15_1 // FSG_OperationState.OP_State
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // OP_State
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_15, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_15,superval);
}

on envVar P_ASG_49_0_0_15_2 // FSG_OperationState.HMI_State
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // HMI_State
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_15, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_15,superval);
}

on envVar P_ASG_49_0_0_16Get_BTN
{
 if (P_ASG_49_0_0_16Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_16_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_16",MakeRGB(255,255,255));
       P_ASG_49_0_0_16Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_16_ID, DataGet_REQ); 
       P_ASG_49_0_0_16Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_16 // bus value of ActiveSource (16).
{
	// opcodes: Error-Status
	byte param1; // SourceType
	word param2; // SourceList_Reference
	byte param3; // TypeOfNumber
	byte param4; // ListAvailable
	byte param5; // List_State
	byte param6; // ListAvailable2
	byte param7; // Number
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[6];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_16, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_16_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_16_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - NIBBLE /////////
	param3 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_ASG_49_0_0_16_3, param3);
	///////// Start param4 - NIBBLE /////////
	param4 = superval[currentPos++] & 0x0f;
	putValue(P_ASG_49_0_0_16_4, param4);
	///////// Start param5 - NIBBLE /////////
	param5 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_ASG_49_0_0_16_5, param5);
	///////// Start param6 - NIBBLE /////////
	param6 = superval[currentPos++] & 0x0f;
	putValue(P_ASG_49_0_0_16_6, param6);
	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_ASG_49_0_0_16_7, round((param7 * 1.0) - (0) + (0), 1.0));
}

on envVar P_ASG_49_0_0_16_1 // ActiveSource.SourceType
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // SourceType
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_16, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_16,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_16_2_range // ActiveSource.SourceList_Reference 
{
	@P_ASG_49_0_0_16_2 = @P_ASG_49_0_0_16_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_16_2 // ActiveSource.SourceList_Reference
{
	byte superval[6];

	//Update Childvalue (Number)
	word thisval; // SourceList_Reference
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_16_2, 1.0);
	@P_ASG_49_0_0_16_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_16, superval);
	superval[1]=thisval&0x00ff;
	superval[2]=(thisval&0xff00)>>8;
	putValue(P_ASG_49_0_0_16,superval);
}

on envVar P_ASG_49_0_0_16_3 // ActiveSource.TypeOfNumber
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // TypeOfNumber
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_16, superval);
	superval[3]= superval[3]&0x0f;
	superval[3]= superval[3]|(thisval<<4);
	putValue(P_ASG_49_0_0_16,superval);
}

on envVar P_ASG_49_0_0_16_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ListAvailable
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_16_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_16_4,thisval);
}

on envVar P_ASG_49_0_0_16_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ListAvailable
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_16_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_16_4,thisval);
}

on envVar P_ASG_49_0_0_16_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ListAvailable
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_16_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_16_4,thisval);
}

on envVar P_ASG_49_0_0_16_4_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ListAvailable
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_16_4);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_16_4,thisval);
}

on envVar P_ASG_49_0_0_16_4 // ActiveSource.ListAvailable
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // ListAvailable
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_16_4_0, 1);
	else
		putValue(P_ASG_49_0_0_16_4_0, 0);
	if(thisval&(mask<<1))
		putValue(P_ASG_49_0_0_16_4_1, 1);
	else
		putValue(P_ASG_49_0_0_16_4_1, 0);
	if(thisval&(mask<<2))
		putValue(P_ASG_49_0_0_16_4_2, 1);
	else
		putValue(P_ASG_49_0_0_16_4_2, 0);
	if(thisval&(mask<<3))
		putValue(P_ASG_49_0_0_16_4_3, 1);
	else
		putValue(P_ASG_49_0_0_16_4_3, 0);

    // Update superval
	getValue(P_ASG_49_0_0_16, superval);
	superval[3]= superval[3]&0xf0;
	superval[3]= superval[3]|thisval;
	putValue(P_ASG_49_0_0_16,superval);
}

on envVar P_ASG_49_0_0_16_5 // ActiveSource.List_State
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // List_State
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_16, superval);
	superval[4]= superval[4]&0x0f;
	superval[4]= superval[4]|(thisval<<4);
	putValue(P_ASG_49_0_0_16,superval);
}

on envVar P_ASG_49_0_0_16_6_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ListAvailable2
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_16_6);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_16_6,thisval);
}

on envVar P_ASG_49_0_0_16_6_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ListAvailable2
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_16_6);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_16_6,thisval);
}

on envVar P_ASG_49_0_0_16_6 // ActiveSource.ListAvailable2
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // ListAvailable2
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_16_6_0, 1);
	else
		putValue(P_ASG_49_0_0_16_6_0, 0);
	if(thisval&(mask<<1))
		putValue(P_ASG_49_0_0_16_6_1, 1);
	else
		putValue(P_ASG_49_0_0_16_6_1, 0);

    // Update superval
	getValue(P_ASG_49_0_0_16, superval);
	superval[4]= superval[4]&0xf0;
	superval[4]= superval[4]|thisval;
	putValue(P_ASG_49_0_0_16,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_16_7_range // ActiveSource.Number 
{
	@P_ASG_49_0_0_16_7 = @P_ASG_49_0_0_16_7_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_16_7 // ActiveSource.Number
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Number
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_16_7, 1.0);
	@P_ASG_49_0_0_16_7_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_16, superval);
	superval[5]=thisval;
	putValue(P_ASG_49_0_0_16,superval);
}

on envVar P_ASG_49_0_0_17Get_BTN
{
 if (P_ASG_49_0_0_17Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_17_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_17",MakeRGB(255,255,255));
       P_ASG_49_0_0_17Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_17_ID, DataGet_REQ); 
       P_ASG_49_0_0_17Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_17 // bus value of ActiveSourceName (17).
{
	// opcodes: Error-Status
	byte param1[61]; // SourceName
	word len1;
	byte cnt1;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[61];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 61; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_17, superval);
	///////// Start param1 - STRING /////////
	getValue(P_ASG_49_0_0_17_1, param1);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(60>127) /* Max Fct-Katalog Laenge: 60*/
		{
			len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt1 = 1;
		}
		else
		{
			len1 = 60;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_17 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len1 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt1 = 0;
	}
	
	if(len1 > 60)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
		len1 = 60;
	
		if(len1 < 128) cnt1 = 0;
		else cnt1 = 1;
	}
	
	for(i = 0; i < len1; i++)
	{
		param1[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_17_1_len, len1);
	putValue(P_ASG_49_0_0_17_1_cnt, cnt1);
	
	if(len1 > getValueSize(P_ASG_49_0_0_17_1))
		putValue(P_ASG_49_0_0_17_1, param1, len1);
	else
		putValue(P_ASG_49_0_0_17_1, param1, getValueSize(P_ASG_49_0_0_17_1));

}

// Updates the bus value field and other dependencies.
P_ASG_49_0_0_17_BuildFct()
{
	byte param1[61]; // SourceName
	word len1;
	byte cnt1;

	int i;
	byte superval[61];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_17_1, param1);
	len1 = getValue(P_ASG_49_0_0_17_1_len);
	cnt1= getValue(P_ASG_49_0_0_17_1_cnt);
	
	/* check box aktiviert*/
	if (cnt1 == 1)
	{
		/* 0 bis 60 (MaxString - 1B oder 2B) */
		if(len1 >= 0 && len1 <= 60)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_17_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 60);
			return;
		}
	}
	else if(cnt1 == 0) /*check box deaktiviert*/
	{
		if(len1 >= 0 && len1 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos]= len1 & 0x00ff;
			putValue(P_ASG_49_0_0_17_1_len, len1);
		}
		else if(len1 > 127 && len1 <= 60)
		{
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
			putValue(P_ASG_49_0_0_17_1_len, len1);
			putValue(P_ASG_49_0_0_17_1_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_17_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 60);
			return;
		}
	}
	currentPos += cnt1+1;
	for(i = 0; i < len1; i++)
	{
		superval[currentPos++]= param1[i];
	}

	putValue(P_ASG_49_0_0_17, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_17_1_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_17_1_len);
	cnt = getValue(P_ASG_49_0_0_17_1_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_17_1_len, 127);
		}
	}

	P_ASG_49_0_0_17_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_17_1_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 60)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_17_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 60);
		putValue(this, 60);
	}
	P_ASG_49_0_0_17_BuildFct();
}


on envVar P_ASG_49_0_0_17_1 // ActiveSourceName.SourceName
{
	putValue(P_ASG_49_0_0_17_1_len, getValueSize(this));
	P_ASG_49_0_0_17_BuildFct();
}

on envVar P_ASG_49_0_0_18Get_BTN
{
 if (P_ASG_49_0_0_18Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_18_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_18",MakeRGB(255,255,255));
       P_ASG_49_0_0_18Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_18_ID, DataGet_REQ); 
       P_ASG_49_0_0_18Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_18 // bus value of CurrentVolume (18).
{
	// opcodes: Error-Status
	byte param1; // EntertainmentVolume
	byte param2; // NavigationVolume
	byte param3; // TaVolume
	byte param4; // PhoneVolume
	byte param5; // SdsVolume
	byte param6; // ChangingVolumeType
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[6];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_18, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_18_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_18_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_ASG_49_0_0_18_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_ASG_49_0_0_18_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_ASG_49_0_0_18_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_ASG_49_0_0_18_6, param6);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_18_1_range // CurrentVolume.EntertainmentVolume 
{
	@P_ASG_49_0_0_18_1 = @P_ASG_49_0_0_18_1_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_18_1 // CurrentVolume.EntertainmentVolume
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // EntertainmentVolume
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_18_1, 1.0);
	@P_ASG_49_0_0_18_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_18, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_18,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_18_2_range // CurrentVolume.NavigationVolume 
{
	@P_ASG_49_0_0_18_2 = @P_ASG_49_0_0_18_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_18_2 // CurrentVolume.NavigationVolume
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // NavigationVolume
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_18_2, 1.0);
	@P_ASG_49_0_0_18_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_18, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_18,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_18_3_range // CurrentVolume.TaVolume 
{
	@P_ASG_49_0_0_18_3 = @P_ASG_49_0_0_18_3_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_18_3 // CurrentVolume.TaVolume
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // TaVolume
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_18_3, 1.0);
	@P_ASG_49_0_0_18_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_18, superval);
	superval[2]=thisval;
	putValue(P_ASG_49_0_0_18,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_18_4_range // CurrentVolume.PhoneVolume 
{
	@P_ASG_49_0_0_18_4 = @P_ASG_49_0_0_18_4_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_18_4 // CurrentVolume.PhoneVolume
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // PhoneVolume
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_18_4, 1.0);
	@P_ASG_49_0_0_18_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_18, superval);
	superval[3]=thisval;
	putValue(P_ASG_49_0_0_18,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_18_5_range // CurrentVolume.SdsVolume 
{
	@P_ASG_49_0_0_18_5 = @P_ASG_49_0_0_18_5_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_18_5 // CurrentVolume.SdsVolume
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // SdsVolume
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_18_5, 1.0);
	@P_ASG_49_0_0_18_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_18, superval);
	superval[4]=thisval;
	putValue(P_ASG_49_0_0_18,superval);
}

on envVar P_ASG_49_0_0_18_6 // CurrentVolume.ChangingVolumeType
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // ChangingVolumeType
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_18, superval);
	superval[5]=thisval;
	putValue(P_ASG_49_0_0_18,superval);
}

on envVar P_ASG_49_0_0_19Get_BTN
{
 if (P_ASG_49_0_0_19Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_19_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_19",MakeRGB(255,255,255));
       P_ASG_49_0_0_19Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_19_ID, DataGet_REQ); 
       P_ASG_49_0_0_19Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_19SetGet_BTN
{
    if (P_ASG_49_0_0_19SetGet_BTN_already_pressed == 0)
    {
       putValue(P_ASG_49_0_0_19_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_19",MakeRGB(255,255,255));
       P_ASG_49_0_0_19SetGet_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_ASG_49_0_0_19_ID, DataSetGet_REQ, getValue(P_ASG_49_0_0_19));
       P_ASG_49_0_0_19SetGet_BTN_already_pressed = 0;
    }
}
on envVar P_ASG_49_0_0_19 // bus value of Mute (19).
{
	// opcodes: Error-Status
	byte param1; // MuteState
	// DATATYPE_UINTXX
	param1 = getValue(P_ASG_49_0_0_19);
	putValue(P_ASG_49_0_0_19_1, param1);
}

on envVar P_ASG_49_0_0_19_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MuteState
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_19_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_19_1,thisval);
}

on envVar P_ASG_49_0_0_19_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MuteState
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_19_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_19_1,thisval);
}

on envVar P_ASG_49_0_0_19_1_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MuteState
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_19_1);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_19_1,thisval);
}

on envVar P_ASG_49_0_0_19_1_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MuteState
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_19_1);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_19_1,thisval);
}

on envVar P_ASG_49_0_0_19_1_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MuteState
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_19_1);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_19_1,thisval);
}

on envVar P_ASG_49_0_0_19_1_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MuteState
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_19_1);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_ASG_49_0_0_19_1,thisval);
}

on envVar P_ASG_49_0_0_19_1_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MuteState
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_19_1);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_ASG_49_0_0_19_1,thisval);
}

on envVar P_ASG_49_0_0_19_1_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MuteState
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_19_1);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_ASG_49_0_0_19_1,thisval);
}

on envVar P_ASG_49_0_0_19_1 // Mute.MuteState
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // MuteState
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_19_1_0, 1);
	else
		putValue(P_ASG_49_0_0_19_1_0, 0);
	if(thisval&(mask<<1))
		putValue(P_ASG_49_0_0_19_1_1, 1);
	else
		putValue(P_ASG_49_0_0_19_1_1, 0);
	if(thisval&(mask<<2))
		putValue(P_ASG_49_0_0_19_1_2, 1);
	else
		putValue(P_ASG_49_0_0_19_1_2, 0);
	if(thisval&(mask<<3))
		putValue(P_ASG_49_0_0_19_1_3, 1);
	else
		putValue(P_ASG_49_0_0_19_1_3, 0);
	if(thisval&(mask<<4))
		putValue(P_ASG_49_0_0_19_1_4, 1);
	else
		putValue(P_ASG_49_0_0_19_1_4, 0);
	if(thisval&(mask<<5))
		putValue(P_ASG_49_0_0_19_1_5, 1);
	else
		putValue(P_ASG_49_0_0_19_1_5, 0);
	if(thisval&(mask<<6))
		putValue(P_ASG_49_0_0_19_1_6, 1);
	else
		putValue(P_ASG_49_0_0_19_1_6, 0);
	if(thisval&(mask<<7))
		putValue(P_ASG_49_0_0_19_1_7, 1);
	else
		putValue(P_ASG_49_0_0_19_1_7, 0);

    // Update superval
	superval = getValue(P_ASG_49_0_0_19);
	superval = thisval;
	putValue(P_ASG_49_0_0_19,superval);
}

on envVar P_ASG_49_0_0_20Get_BTN
{
 if (P_ASG_49_0_0_20Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_20_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_20",MakeRGB(255,255,255));
       P_ASG_49_0_0_20Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_20_ID, DataGet_REQ); 
       P_ASG_49_0_0_20Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_20SetGet_BTN
{
	byte BAPTemp[2];
    if (P_ASG_49_0_0_20SetGet_BTN_already_pressed == 0)
    {
       putValue(P_ASG_49_0_0_20_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_20",MakeRGB(255,255,255));
       P_ASG_49_0_0_20SetGet_BTN_already_pressed = 1;
    }
    else
    {
       getValue(P_ASG_49_0_0_20, BAPTemp);
       Request_ByteSequence(LSGID, P_ASG_49_0_0_20_ID, DataSetGet_REQ, BAPTemp, getValueSize(P_ASG_49_0_0_20));
       P_ASG_49_0_0_20SetGet_BTN_already_pressed = 0;
    }
}
on envVar P_ASG_49_0_0_20 // bus value of SourceState (20).
{
	// opcodes: Error-Status
	byte param1; // StateInfo
	byte param2; // StateInfo_Scope
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[2];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_20, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_20_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_20_2, param2);
}

on envVar P_ASG_49_0_0_20_1 // SourceState.StateInfo
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // StateInfo
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_20, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_20,superval);
}

on envVar P_ASG_49_0_0_20_2 // SourceState.StateInfo_Scope
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // StateInfo_Scope
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_20, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_20,superval);
}

on envVar P_ASG_49_0_0_21Get_BTN
{
 if (P_ASG_49_0_0_21Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_21_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_21",MakeRGB(255,255,255));
       P_ASG_49_0_0_21Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_21_ID, DataGet_REQ); 
       P_ASG_49_0_0_21Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_21 // bus value of CurrentStationInfo (21).
{
	// opcodes: Error-Status
	byte param1[73]; // PrimaryInformation
	word len1;
	byte cnt1;
	byte param2; // PI_Type
	word param3; // PI_ID
	byte param4[73]; // SecondaryInformation
	word len4;
	byte cnt4;
	byte param5; // SI_Type
	byte param6[73]; // TertiaryInformation
	word len6;
	byte cnt6;
	byte param7; // TI_Type
	byte param8[73]; // QuaternaryInformation
	word len8;
	byte cnt8;
	byte param9; // QI_Type
	byte param10; // StationInfoSwitches
	byte param11; // StationProperties
	word param12; // Channel_ID
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[302];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 302; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_21, superval);
	///////// Start param1 - STRING /////////
	getValue(P_ASG_49_0_0_21_1, param1);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt1 = 1;
		}
		else
		{
			len1 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_21 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len1 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt1 = 0;
	}
	
	if(len1 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
		len1 = 72;
	
		if(len1 < 128) cnt1 = 0;
		else cnt1 = 1;
	}
	
	for(i = 0; i < len1; i++)
	{
		param1[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_21_1_len, len1);
	putValue(P_ASG_49_0_0_21_1_cnt, cnt1);
	
	if(len1 > getValueSize(P_ASG_49_0_0_21_1))
		putValue(P_ASG_49_0_0_21_1, param1, len1);
	else
		putValue(P_ASG_49_0_0_21_1, param1, getValueSize(P_ASG_49_0_0_21_1));

	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_21_2, param2);
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_21_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - STRING /////////
	getValue(P_ASG_49_0_0_21_4, param4);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len4 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt4 = 1;
		}
		else
		{
			len4 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_21 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len4 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt4 = 0;
	}
	
	if(len4 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len4, currentPos);
		len4 = 72;
	
		if(len4 < 128) cnt4 = 0;
		else cnt4 = 1;
	}
	
	for(i = 0; i < len4; i++)
	{
		param4[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_21_4_len, len4);
	putValue(P_ASG_49_0_0_21_4_cnt, cnt4);
	
	if(len4 > getValueSize(P_ASG_49_0_0_21_4))
		putValue(P_ASG_49_0_0_21_4, param4, len4);
	else
		putValue(P_ASG_49_0_0_21_4, param4, getValueSize(P_ASG_49_0_0_21_4));

	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_ASG_49_0_0_21_5, param5);
	///////// Start param6 - STRING /////////
	getValue(P_ASG_49_0_0_21_6, param6);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len6 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt6 = 1;
		}
		else
		{
			len6 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_21 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len6 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt6 = 0;
	}
	
	if(len6 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len6, currentPos);
		len6 = 72;
	
		if(len6 < 128) cnt6 = 0;
		else cnt6 = 1;
	}
	
	for(i = 0; i < len6; i++)
	{
		param6[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_21_6_len, len6);
	putValue(P_ASG_49_0_0_21_6_cnt, cnt6);
	
	if(len6 > getValueSize(P_ASG_49_0_0_21_6))
		putValue(P_ASG_49_0_0_21_6, param6, len6);
	else
		putValue(P_ASG_49_0_0_21_6, param6, getValueSize(P_ASG_49_0_0_21_6));

	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_ASG_49_0_0_21_7, param7);
	///////// Start param8 - STRING /////////
	getValue(P_ASG_49_0_0_21_8, param8);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len8 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt8 = 1;
		}
		else
		{
			len8 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_21 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len8 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt8 = 0;
	}
	
	if(len8 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len8, currentPos);
		len8 = 72;
	
		if(len8 < 128) cnt8 = 0;
		else cnt8 = 1;
	}
	
	for(i = 0; i < len8; i++)
	{
		param8[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_21_8_len, len8);
	putValue(P_ASG_49_0_0_21_8_cnt, cnt8);
	
	if(len8 > getValueSize(P_ASG_49_0_0_21_8))
		putValue(P_ASG_49_0_0_21_8, param8, len8);
	else
		putValue(P_ASG_49_0_0_21_8, param8, getValueSize(P_ASG_49_0_0_21_8));

	///////// Start param9 - UINT8 /////////
	param9 = superval[currentPos++];
	putValue(P_ASG_49_0_0_21_9, param9);
	///////// Start param10 - UINT8 /////////
	param10 = superval[currentPos++];
	putValue(P_ASG_49_0_0_21_10, param10);
	///////// Start param11 - UINT8 /////////
	param11 = superval[currentPos++];
	putValue(P_ASG_49_0_0_21_11, param11);
	///////// Start param12 - UINT16 /////////
	param12 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_21_12, round((param12 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_ASG_49_0_0_21_BuildFct()
{
	byte param1[73]; // PrimaryInformation
	word len1;
	byte cnt1;
	byte param2; // PI_Type
	word param3; // PI_ID
	byte param4[73]; // SecondaryInformation
	word len4;
	byte cnt4;
	byte param5; // SI_Type
	byte param6[73]; // TertiaryInformation
	word len6;
	byte cnt6;
	byte param7; // TI_Type
	byte param8[73]; // QuaternaryInformation
	word len8;
	byte cnt8;
	byte param9; // QI_Type
	byte param10; // StationInfoSwitches
	byte param11; // StationProperties
	word param12; // Channel_ID

	int i;
	byte superval[302];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_21_1, param1);
	len1 = getValue(P_ASG_49_0_0_21_1_len);
	cnt1= getValue(P_ASG_49_0_0_21_1_cnt);
	
	/* check box aktiviert*/
	if (cnt1 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len1 >= 0 && len1 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 72);
			return;
		}
	}
	else if(cnt1 == 0) /*check box deaktiviert*/
	{
		if(len1 >= 0 && len1 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos]= len1 & 0x00ff;
			putValue(P_ASG_49_0_0_21_1_len, len1);
		}
		else if(len1 > 127 && len1 <= 72)
		{
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
			putValue(P_ASG_49_0_0_21_1_len, len1);
			putValue(P_ASG_49_0_0_21_1_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 72);
			return;
		}
	}
	currentPos += cnt1+1;
	for(i = 0; i < len1; i++)
	{
		superval[currentPos++]= param1[i];
	}

// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_ASG_49_0_0_21_2);
	superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_21_3_range = round(@P_ASG_49_0_0_21_3 + (0), 1.0); // slider value + min = real value
	param3 = round( (@P_ASG_49_0_0_21_3 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param3&0x00ff;
	superval[currentPos++]=(param3&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_21_4, param4);
	len4 = getValue(P_ASG_49_0_0_21_4_len);
	cnt4= getValue(P_ASG_49_0_0_21_4_cnt);
	
	/* check box aktiviert*/
	if (cnt4 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len4 >= 0 && len4 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
			superval[currentPos] = (len4&0x7f00) | 0x80;
			superval[currentPos+1] = len4 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 72);
			return;
		}
	}
	else if(cnt4 == 0) /*check box deaktiviert*/
	{
		if(len4 >= 0 && len4 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
			superval[currentPos]= len4 & 0x00ff;
			putValue(P_ASG_49_0_0_21_4_len, len4);
		}
		else if(len4 > 127 && len4 <= 72)
		{
			superval[currentPos] = (len4&0x7f00) | 0x80;
			superval[currentPos+1] = len4 & 0x00ff;
			putValue(P_ASG_49_0_0_21_4_len, len4);
			putValue(P_ASG_49_0_0_21_4_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 72);
			return;
		}
	}
	currentPos += cnt4+1;
	for(i = 0; i < len4; i++)
	{
		superval[currentPos++]= param4[i];
	}

// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_ASG_49_0_0_21_5);
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_21_6, param6);
	len6 = getValue(P_ASG_49_0_0_21_6_len);
	cnt6= getValue(P_ASG_49_0_0_21_6_cnt);
	
	/* check box aktiviert*/
	if (cnt6 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len6 >= 0 && len6 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
			superval[currentPos] = (len6&0x7f00) | 0x80;
			superval[currentPos+1] = len6 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 72);
			return;
		}
	}
	else if(cnt6 == 0) /*check box deaktiviert*/
	{
		if(len6 >= 0 && len6 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
			superval[currentPos]= len6 & 0x00ff;
			putValue(P_ASG_49_0_0_21_6_len, len6);
		}
		else if(len6 > 127 && len6 <= 72)
		{
			superval[currentPos] = (len6&0x7f00) | 0x80;
			superval[currentPos+1] = len6 & 0x00ff;
			putValue(P_ASG_49_0_0_21_6_len, len6);
			putValue(P_ASG_49_0_0_21_6_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 72);
			return;
		}
	}
	currentPos += cnt6+1;
	for(i = 0; i < len6; i++)
	{
		superval[currentPos++]= param6[i];
	}

// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_ASG_49_0_0_21_7);
	superval[currentPos++]=param7;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_21_8, param8);
	len8 = getValue(P_ASG_49_0_0_21_8_len);
	cnt8= getValue(P_ASG_49_0_0_21_8_cnt);
	
	/* check box aktiviert*/
	if (cnt8 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len8 >= 0 && len8 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
			superval[currentPos] = (len8&0x7f00) | 0x80;
			superval[currentPos+1] = len8 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 72);
			return;
		}
	}
	else if(cnt8 == 0) /*check box deaktiviert*/
	{
		if(len8 >= 0 && len8 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
			superval[currentPos]= len8 & 0x00ff;
			putValue(P_ASG_49_0_0_21_8_len, len8);
		}
		else if(len8 > 127 && len8 <= 72)
		{
			superval[currentPos] = (len8&0x7f00) | 0x80;
			superval[currentPos+1] = len8 & 0x00ff;
			putValue(P_ASG_49_0_0_21_8_len, len8);
			putValue(P_ASG_49_0_0_21_8_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 72);
			return;
		}
	}
	currentPos += cnt8+1;
	for(i = 0; i < len8; i++)
	{
		superval[currentPos++]= param8[i];
	}

// gen_BuildFunc_SetSuperVals 
	param9 = getValue(P_ASG_49_0_0_21_9);
	superval[currentPos++]=param9;
// gen_BuildFunc_SetSuperVals 
	param10 = getValue(P_ASG_49_0_0_21_10);
	@P_ASG_49_0_0_21_10_0 = (param10 & 1) > 0;
	@P_ASG_49_0_0_21_10_1 = (param10 & 2) > 0;
	@P_ASG_49_0_0_21_10_2 = (param10 & 4) > 0;
	@P_ASG_49_0_0_21_10_3 = (param10 & 8) > 0;
	superval[currentPos++]=param10;
// gen_BuildFunc_SetSuperVals 
	param11 = getValue(P_ASG_49_0_0_21_11);
	@P_ASG_49_0_0_21_11_0 = (param11 & 1) > 0;
	@P_ASG_49_0_0_21_11_1 = (param11 & 2) > 0;
	@P_ASG_49_0_0_21_11_2 = (param11 & 4) > 0;
	@P_ASG_49_0_0_21_11_3 = (param11 & 8) > 0;
	superval[currentPos++]=param11;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_21_12_range = round(@P_ASG_49_0_0_21_12 + (0), 1.0); // slider value + min = real value
	param12 = round( (@P_ASG_49_0_0_21_12 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param12&0x00ff;
	superval[currentPos++]=(param12&0xff00)>>8;
	putValue(P_ASG_49_0_0_21, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_21_1_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_21_1_len);
	cnt = getValue(P_ASG_49_0_0_21_1_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_21_1_len, 127);
		}
	}

	P_ASG_49_0_0_21_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_21_1_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_21_BuildFct();
}


on envVar P_ASG_49_0_0_21_1 // CurrentStationInfo.PrimaryInformation
{
	putValue(P_ASG_49_0_0_21_1_len, getValueSize(this));
	P_ASG_49_0_0_21_BuildFct();
}

on envVar P_ASG_49_0_0_21_2 // CurrentStationInfo.PI_Type
{
	P_ASG_49_0_0_21_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_21_3_range // CurrentStationInfo.PI_ID 
{
	@P_ASG_49_0_0_21_3 = @P_ASG_49_0_0_21_3_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_21_3 // CurrentStationInfo.PI_ID
{
	P_ASG_49_0_0_21_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_21_4_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_21_4_len);
	cnt = getValue(P_ASG_49_0_0_21_4_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_21_4_len, 127);
		}
	}

	P_ASG_49_0_0_21_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_21_4_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_21_BuildFct();
}


on envVar P_ASG_49_0_0_21_4 // CurrentStationInfo.SecondaryInformation
{
	putValue(P_ASG_49_0_0_21_4_len, getValueSize(this));
	P_ASG_49_0_0_21_BuildFct();
}

on envVar P_ASG_49_0_0_21_5 // CurrentStationInfo.SI_Type
{
	P_ASG_49_0_0_21_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_21_6_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_21_6_len);
	cnt = getValue(P_ASG_49_0_0_21_6_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_21_6_len, 127);
		}
	}

	P_ASG_49_0_0_21_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_21_6_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_21_BuildFct();
}


on envVar P_ASG_49_0_0_21_6 // CurrentStationInfo.TertiaryInformation
{
	putValue(P_ASG_49_0_0_21_6_len, getValueSize(this));
	P_ASG_49_0_0_21_BuildFct();
}

on envVar P_ASG_49_0_0_21_7 // CurrentStationInfo.TI_Type
{
	P_ASG_49_0_0_21_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_21_8_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_21_8_len);
	cnt = getValue(P_ASG_49_0_0_21_8_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_21_8_len, 127);
		}
	}

	P_ASG_49_0_0_21_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_21_8_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_21_8 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_21_BuildFct();
}


on envVar P_ASG_49_0_0_21_8 // CurrentStationInfo.QuaternaryInformation
{
	putValue(P_ASG_49_0_0_21_8_len, getValueSize(this));
	P_ASG_49_0_0_21_BuildFct();
}

on envVar P_ASG_49_0_0_21_9 // CurrentStationInfo.QI_Type
{
	P_ASG_49_0_0_21_BuildFct();
}

on envVar P_ASG_49_0_0_21_10_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // StationInfoSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_21_10);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_21_10,thisval);
}

on envVar P_ASG_49_0_0_21_10_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // StationInfoSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_21_10);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_21_10,thisval);
}

on envVar P_ASG_49_0_0_21_10_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // StationInfoSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_21_10);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_21_10,thisval);
}

on envVar P_ASG_49_0_0_21_10_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // StationInfoSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_21_10);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_21_10,thisval);
}

on envVar P_ASG_49_0_0_21_10 // CurrentStationInfo.StationInfoSwitches
{
	P_ASG_49_0_0_21_BuildFct();
}

on envVar P_ASG_49_0_0_21_11_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_21_11);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_21_11,thisval);
}

on envVar P_ASG_49_0_0_21_11_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_21_11);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_21_11,thisval);
}

on envVar P_ASG_49_0_0_21_11_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_21_11);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_21_11,thisval);
}

on envVar P_ASG_49_0_0_21_11_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_21_11);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_21_11,thisval);
}

on envVar P_ASG_49_0_0_21_11 // CurrentStationInfo.StationProperties
{
	P_ASG_49_0_0_21_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_21_12_range // CurrentStationInfo.Channel_ID 
{
	@P_ASG_49_0_0_21_12 = @P_ASG_49_0_0_21_12_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_21_12 // CurrentStationInfo.Channel_ID
{
	P_ASG_49_0_0_21_BuildFct();
}

on envVar P_ASG_49_0_0_22Get_BTN
{
 if (P_ASG_49_0_0_22Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_22_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_22",MakeRGB(255,255,255));
       P_ASG_49_0_0_22Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_22_ID, DataGet_REQ); 
       P_ASG_49_0_0_22Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_22 // bus value of CurrentStation_Handle (22).
{
	// opcodes: Error-Status
	word param1; // FsgHandle
	word param2; // FsgHandle_absolutePosition
	byte param3; // PresetList_Ref
	byte param4; // PresetList_absolutePosition
	word param5; // DAB_EnsembleHandle
	word param6; // DAB_Ensemble_absolutePosition
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[10];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 10; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_22, superval);
	///////// Start param1 - UINT16 /////////
	param1 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_22_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_22_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_ASG_49_0_0_22_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_ASG_49_0_0_22_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT16 /////////
	param5 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_22_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT16 /////////
	param6 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_22_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_ASG_49_0_0_22_BuildFct()
{
	word param1; // FsgHandle
	word param2; // FsgHandle_absolutePosition
	byte param3; // PresetList_Ref
	byte param4; // PresetList_absolutePosition
	word param5; // DAB_EnsembleHandle
	word param6; // DAB_Ensemble_absolutePosition

	int i;
	byte superval[10];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_22_1_range = round(@P_ASG_49_0_0_22_1 + (0), 1.0); // slider value + min = real value
	param1 = round( (@P_ASG_49_0_0_22_1 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param1&0x00ff;
	superval[currentPos++]=(param1&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_22_2_range = round(@P_ASG_49_0_0_22_2 + (0), 1.0); // slider value + min = real value
	param2 = round( (@P_ASG_49_0_0_22_2 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param2&0x00ff;
	superval[currentPos++]=(param2&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_22_3_range = round(@P_ASG_49_0_0_22_3 + (0), 1.0); // slider value + min = real value
	param3 = round( (@P_ASG_49_0_0_22_3 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_22_4_range = round(@P_ASG_49_0_0_22_4 + (0), 1.0); // slider value + min = real value
	param4 = round( (@P_ASG_49_0_0_22_4 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_22_5_range = round(@P_ASG_49_0_0_22_5 + (0), 1.0); // slider value + min = real value
	param5 = round( (@P_ASG_49_0_0_22_5 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param5&0x00ff;
	superval[currentPos++]=(param5&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_22_6_range = round(@P_ASG_49_0_0_22_6 + (0), 1.0); // slider value + min = real value
	param6 = round( (@P_ASG_49_0_0_22_6 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param6&0x00ff;
	superval[currentPos++]=(param6&0xff00)>>8;
	putValue(P_ASG_49_0_0_22, superval, currentPos);
}


// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_22_1_range // CurrentStation_Handle.FsgHandle 
{
	@P_ASG_49_0_0_22_1 = @P_ASG_49_0_0_22_1_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_22_1 // CurrentStation_Handle.FsgHandle
{
	P_ASG_49_0_0_22_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_22_2_range // CurrentStation_Handle.FsgHandle_absolutePosition 
{
	@P_ASG_49_0_0_22_2 = @P_ASG_49_0_0_22_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_22_2 // CurrentStation_Handle.FsgHandle_absolutePosition
{
	P_ASG_49_0_0_22_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_22_3_range // CurrentStation_Handle.PresetList_Ref 
{
	@P_ASG_49_0_0_22_3 = @P_ASG_49_0_0_22_3_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_22_3 // CurrentStation_Handle.PresetList_Ref
{
	P_ASG_49_0_0_22_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_22_4_range // CurrentStation_Handle.PresetList_absolutePosition 
{
	@P_ASG_49_0_0_22_4 = @P_ASG_49_0_0_22_4_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_22_4 // CurrentStation_Handle.PresetList_absolutePosition
{
	P_ASG_49_0_0_22_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_22_5_range // CurrentStation_Handle.DAB_EnsembleHandle 
{
	@P_ASG_49_0_0_22_5 = @P_ASG_49_0_0_22_5_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_22_5 // CurrentStation_Handle.DAB_EnsembleHandle
{
	P_ASG_49_0_0_22_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_22_6_range // CurrentStation_Handle.DAB_Ensemble_absolutePosition 
{
	@P_ASG_49_0_0_22_6 = @P_ASG_49_0_0_22_6_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_22_6 // CurrentStation_Handle.DAB_Ensemble_absolutePosition
{
	P_ASG_49_0_0_22_BuildFct();
}

on envVar A_ASG_49_0_0_23Get_BTN
{
  byte data[9]; 
  byte stringValue[9];
  byte head[5];
  int i;
  int headLength;
  long tempValue;
  word currentPos;
  word startVal;
  word elementsVal;
  byte nibbleSetted;
  if (A_ASG_49_0_0_23Get_BTN_already_pressed == 0)
  {
     putValue(A_ASG_49_0_0_23_ErrCode,0);
     SetControlBackColor(panel_name,"errField_A_ASG_49_0_0_23",MakeRGB(255,255,255));
     A_ASG_49_0_0_23Get_BTN_already_pressed = 1;
  }
  else
  {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_ASG_49_0_0_23_1_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_ASG_49_0_0_23_2_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: ElementType
        tempValue = getValue(A_ASG_49_0_0_23_3_SetGet);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //Einzelparameter: Parent_ID
        tempValue = getValue(A_ASG_49_0_0_23_4_SetGet);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //head Parameter
        headLength = getValueSize(A_ASG_49_0_0_23_SetGet);
        getValue(A_ASG_49_0_0_23_SetGet,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }

     Request_ByteSequence(LSGID, A_ASG_49_0_0_23_ID, DataGet_REQ, data, currentPos);
     if(getValue(A_ASG_49_0_0_23_IntTlgEn)) //getValue(IT))
     {
       intertelegram_err(A_ASG_49_0_0_23_ID);
     }
     if(getValue(A_ASG_49_0_0_23_SegmEn))   //getvalue(SG)
     {
         sequence_err(A_ASG_49_0_0_23_ID,getValueSize(A_ASG_49_0_0_23_SetGet));
     }
     A_ASG_49_0_0_23Get_BTN_already_pressed = 0;
  }
}
A_ASG_49_0_0_23_SetGet_GenerateSetGet()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_ASG_49_0_0_23_SetGet_RecAdr) > 0x0F)
        putValue(A_ASG_49_0_0_23_SetGet_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_ASG_49_0_0_23_SetGet_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_ASG_49_0_0_23_SetGet_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_ASG_49_0_0_23_SetGet_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // reserverd:  Byte 0 Bit 6
    if( getValue(A_ASG_49_0_0_23_SetGet_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_ASG_49_0_0_23_SetGet_Start) & 0xFF;
        head[2] = (getValue(A_ASG_49_0_0_23_SetGet_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_ASG_49_0_0_23_SetGet_Elements) & 0xFF;
        head[4] = (getValue(A_ASG_49_0_0_23_SetGet_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_ASG_49_0_0_23_SetGet, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_ASG_49_0_0_23_SetGet_Start) & 0xFF;
        head[2] = getValue(A_ASG_49_0_0_23_SetGet_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_ASG_49_0_0_23_SetGet, head, 3); 
    }
}

on envVar A_ASG_49_0_0_23_SetGet_RecAdr
{
    A_ASG_49_0_0_23_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_23_SetGet_Shift
{
    A_ASG_49_0_0_23_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_23_SetGet_Direction
{
    A_ASG_49_0_0_23_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_23_SetGet_Start
{
    A_ASG_49_0_0_23_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_23_SetGet_Elements
{
    A_ASG_49_0_0_23_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_23_SetGet_IndexSize
{
    A_ASG_49_0_0_23_SetGet_GenerateSetGet();
}
on envVar A_ASG_49_0_0_23
{
    byte temp[9];
    byte head[5];
    getValue(A_ASG_49_0_0_23, head);
    putValue(A_ASG_49_0_0_23_RecAdr, 0x0F & head[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & head[0]) >0)
        putValue(A_ASG_49_0_0_23_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & head[0]) >0)
        putValue(A_ASG_49_0_0_23_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & head[0]) >0)
        putValue(A_ASG_49_0_0_23_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & head[0]) >0)
        putValue(A_ASG_49_0_0_23_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_23_IndexSize))
    {
        putValue(A_ASG_49_0_0_23_Start, ((head[2]<<8)| head[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_23_Elements, ((head[4]<<8)| head[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_23_Start, head[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_23_Elements, head[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_23_Changed
{
    byte temp[363];
    getValue(A_ASG_49_0_0_23_Changed, temp);
    putValue(A_ASG_49_0_0_23_Changed_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_23_Changed_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_Changed_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_23_Changed_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_Changed_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_ASG_49_0_0_23_Changed_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_Changed_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_23_Changed_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_Changed_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_23_Changed_IndexSize))
    {
        putValue(A_ASG_49_0_0_23_Changed_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_23_Changed_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_23_Changed_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_23_Changed_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_23_SetGet
{
    byte temp[9];
    getValue(A_ASG_49_0_0_23_SetGet, temp);
    putValue(A_ASG_49_0_0_23_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_23_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_23_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_23_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_23_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_23_SetGet_IndexSize))
    {
        putValue(A_ASG_49_0_0_23_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_23_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_23_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_23_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_ASG_49_0_0_23_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];
	char temp6[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_ASG_49_0_0_23_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_ASG_49_0_0_23_ArrayDataList[i].Param1 = 0;
		A_ASG_49_0_0_23_ArrayDataList[i].Param2 = 0;
		A_ASG_49_0_0_23_ArrayDataList[i].Param3 = 0;
		A_ASG_49_0_0_23_ArrayDataList[i].Param4 = 0;
		A_ASG_49_0_0_23_ArrayDataList[i].Param5 = 0;
		A_ASG_49_0_0_23_ArrayDataList[i].Param6 = 0;
		for(j=0; j<49; j++)
			A_ASG_49_0_0_23_ArrayDataList[i].Param7[j] = 0;
		A_ASG_49_0_0_23_ArrayDataList[i].Param7_Length = 0;
		A_ASG_49_0_0_23_Data_7_LenList[i] = 0;
		for(j=0; j<31; j++)
			A_ASG_49_0_0_23_ArrayDataList[i].Param8[j] = 0;
		A_ASG_49_0_0_23_ArrayDataList[i].Param8_Length = 0;
		A_ASG_49_0_0_23_Data_8_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_ASG_49_0_0_23_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 65536) //ignore first line in *.csv file
					{
						A_ASG_49_0_0_23_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_ASG_49_0_0_23_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //Type
						A_ASG_49_0_0_23_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //Attributes
						A_ASG_49_0_0_23_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //PresetID
						A_ASG_49_0_0_23_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //FmREG_Code
						A_ASG_49_0_0_23_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //Category
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp6[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 65536)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Type
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Attributes
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //PresetID
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //FmREG_Code
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //Category
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //Name
								if(paramPos < 48)
								{
									A_ASG_49_0_0_23_ArrayDataList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_23_ArrayDataList[current_CSV_line-1].Param7_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 8: //Frequency
								if(paramPos < 30)
								{
									A_ASG_49_0_0_23_ArrayDataList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_23_ArrayDataList[current_CSV_line-1].Param8_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_ASG_49_0_0_23_loadArray_Btn
{
	char filePath[255];
	if (A_ASG_49_0_0_23_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_23_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_ASG_49_0_0_23_generateData_Btn_already_pressed = 0;
		getValue(A_ASG_49_0_0_23_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_ASG_49_0_0_23_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_ASG_49_0_0_23_Data_1, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_23_Data_2, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_23_Data_3, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_23_Data_4, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_23_Data_5, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param5);
	putValue(A_ASG_49_0_0_23_Data_6, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param6);
	putValue(A_ASG_49_0_0_23_Data_7, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param7, A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param7_Length);
	putValue(A_ASG_49_0_0_23_Data_8, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param8, A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param8_Length);
}


on envVar A_ASG_49_0_0_23_generateData_Btn
{
	word i;
	dword elementsArray[10] = {2, 1, 2, 1, 1, 1, 49, 2, 31, 2};
	byte elementsTypeArray[10] = {0, 0, 0, 0, 0, 0, 0xE, 0xF, 0xE, 0xF};
	dword elementsMaxSizeArray[10] = {65535, 0xFF, 0xFFFF, 255, 255, 0xFF, 0, 0, 0, 0};
	byte tempArray[6029220];
	if (A_ASG_49_0_0_23_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_23_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 23, 65535 );
		for(i = 0; i < 65535; i++)
		{
			memcpy(A_ASG_49_0_0_23_ArrayDataList[i], tempArray, (i * 92) );
			if(A_ASG_49_0_0_23_ArrayDataList[i].Param7_Length > 127 )
				A_ASG_49_0_0_23_Data_7_CntList[i] = 1;
			if(A_ASG_49_0_0_23_ArrayDataList[i].Param8_Length > 127 )
				A_ASG_49_0_0_23_Data_8_CntList[i] = 1;
		}
		A_ASG_49_0_0_23_generateData_Btn_already_pressed = 0;
	}
	putValue(A_ASG_49_0_0_23_Data_1, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_23_Data_2, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_23_Data_3, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_23_Data_4, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_23_Data_5, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param5);
	putValue(A_ASG_49_0_0_23_Data_6, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param6);
	putValue(A_ASG_49_0_0_23_Data_7, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param7, A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param7_Length);
	putValue(A_ASG_49_0_0_23_Data_8, A_ASG_49_0_0_23_ArrayDataList[ getValue( A_ASG_49_0_0_23_DataIndex) ].Param8, A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param8_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_ASG_49_0_0_23_DataIndex
{
    long index;
    long maxIndex = 65535-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_ASG_49_0_0_23_Data_1, A_ASG_49_0_0_23_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_23_Data_2, A_ASG_49_0_0_23_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_23_Data_3, A_ASG_49_0_0_23_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_23_Data_4, A_ASG_49_0_0_23_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_23_Data_5, A_ASG_49_0_0_23_ArrayDataList[index].Param5);
    putValue(A_ASG_49_0_0_23_Data_6, A_ASG_49_0_0_23_ArrayDataList[index].Param6);
    putValue(A_ASG_49_0_0_23_Data_7_len, A_ASG_49_0_0_23_Data_7_LenList[index]);
    putValue(A_ASG_49_0_0_23_Data_7_cnt, A_ASG_49_0_0_23_Data_7_CntList[index]);
    putValue(A_ASG_49_0_0_23_Data_7, A_ASG_49_0_0_23_ArrayDataList[index].Param7, A_ASG_49_0_0_23_ArrayDataList[index].Param7_Length);
    putValue(A_ASG_49_0_0_23_Data_8_len, A_ASG_49_0_0_23_Data_8_LenList[index]);
    putValue(A_ASG_49_0_0_23_Data_8_cnt, A_ASG_49_0_0_23_Data_8_CntList[index]);
    putValue(A_ASG_49_0_0_23_Data_8, A_ASG_49_0_0_23_ArrayDataList[index].Param8, A_ASG_49_0_0_23_ArrayDataList[index].Param8_Length);

}
on envVar A_ASG_49_0_0_23_DataIndex_Incr
{
    long index;
    if(A_ASG_49_0_0_23_DataIndex_Incr_already_pressed == 0)
    {
        A_ASG_49_0_0_23_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_23_DataIndex);
        index++;
        putValue(A_ASG_49_0_0_23_DataIndex, index);
        A_ASG_49_0_0_23_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_ASG_49_0_0_23_DataIndex_Decr
{
    long index;
    if(A_ASG_49_0_0_23_DataIndex_Decr_already_pressed == 0)
    {
        A_ASG_49_0_0_23_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_23_DataIndex);
        index--;
        putValue(A_ASG_49_0_0_23_DataIndex, index);
        A_ASG_49_0_0_23_DataIndex_Decr_already_pressed = 0;
    }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_23_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_23_SegmEn,0);
           intertelegram_err(A_ASG_49_0_0_23_ID);
       }
       else
       {
           intertelegram_err_off(A_ASG_49_0_0_23_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_23_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_23_IntTlgEn,0);
           sequence_err(A_ASG_49_0_0_23_ID,getValueSize(A_ASG_49_0_0_23_SegmEn));
       }
       else
       {
              sequence_err_off(A_ASG_49_0_0_23_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_ASG_49_0_0_23_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_ASG_49_0_0_23_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_ASG_49_0_0_23_Status",1);
 	}
}

A_ASG_49_0_0_23_DataInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[363];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_23_1, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_23_2, tempValue);
    //Einzelparameter: ElementType
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_ASG_49_0_0_23_3, tempValue);
    //Einzelparameter: Parent_ID
    //voriger Parameter war ein first nibble, bei 2 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue =  (gBAP_Indication_data[currentPos++] & 0xFF);
    tempValue += (gBAP_Indication_data[currentPos++] & 0xFF) << 8;
    putValue(A_ASG_49_0_0_23_4, tempValue);
    //Einzelparameter: TotalNumListElements
    //voriger Parameter war ein first nibble, bei 2 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue =  (gBAP_Indication_data[currentPos++] & 0xFF);
    tempValue += (gBAP_Indication_data[currentPos++] & 0xFF) << 8;
    putValue(A_ASG_49_0_0_23_5, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_23, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_23, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_23_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 23");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_23_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_23_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 2 == recordAddressVal || 6 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_23_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 2 == recordAddressVal || 6 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_23_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_23_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_23_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 3 == recordAddressVal || 6 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_23_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 6 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_23_Data_7_CntList[i] = 1;
            A_ASG_49_0_0_23_ArrayDataList[i].Param7_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_23_Data_7_CntList[i] = 0;
            A_ASG_49_0_0_23_ArrayDataList[i].Param7_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_23_ArrayDataList[i].Param7_Length; j++)
        {
            A_ASG_49_0_0_23_ArrayDataList[i].Param7[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 5 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_23_Data_8_CntList[i] = 1;
            A_ASG_49_0_0_23_ArrayDataList[i].Param8_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_23_Data_8_CntList[i] = 0;
            A_ASG_49_0_0_23_ArrayDataList[i].Param8_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_23_ArrayDataList[i].Param8_Length; j++)
        {
            A_ASG_49_0_0_23_ArrayDataList[i].Param8[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_23_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_23_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 23");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_23_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_23_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 2 == recordAddressVal || 6 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_23_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 2 == recordAddressVal || 6 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_23_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_23_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_23_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 3 == recordAddressVal || 6 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_23_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 3 == recordAddressVal || 4 == recordAddressVal || 6 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_23_Data_7_CntList[i] = 1;
            A_ASG_49_0_0_23_ArrayDataList[i].Param7_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_23_Data_7_CntList[i] = 0;
            A_ASG_49_0_0_23_ArrayDataList[i].Param7_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_23_ArrayDataList[i].Param7_Length; j++)
        {
            A_ASG_49_0_0_23_ArrayDataList[i].Param7[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 5 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_23_Data_8_CntList[i] = 1;
            A_ASG_49_0_0_23_ArrayDataList[i].Param8_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_23_Data_8_CntList[i] = 0;
            A_ASG_49_0_0_23_ArrayDataList[i].Param8_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_23_ArrayDataList[i].Param8_Length; j++)
        {
            A_ASG_49_0_0_23_ArrayDataList[i].Param8[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_23_DataIndex);
    putValue(A_ASG_49_0_0_23_Data_1, A_ASG_49_0_0_23_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_23_Data_2, A_ASG_49_0_0_23_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_23_Data_3, A_ASG_49_0_0_23_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_23_Data_4, A_ASG_49_0_0_23_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_23_Data_5, A_ASG_49_0_0_23_ArrayDataList[index].Param5);
    putValue(A_ASG_49_0_0_23_Data_6, A_ASG_49_0_0_23_ArrayDataList[index].Param6);
    putValue(A_ASG_49_0_0_23_Data_7_len, A_ASG_49_0_0_23_Data_7_LenList[index]);
    putValue(A_ASG_49_0_0_23_Data_7_cnt, A_ASG_49_0_0_23_Data_7_CntList[index]);
    putValue(A_ASG_49_0_0_23_Data_7, A_ASG_49_0_0_23_ArrayDataList[index].Param7, A_ASG_49_0_0_23_ArrayDataList[index].Param7_Length);
    putValue(A_ASG_49_0_0_23_Data_8_len, A_ASG_49_0_0_23_Data_8_LenList[index]);
    putValue(A_ASG_49_0_0_23_Data_8_cnt, A_ASG_49_0_0_23_Data_8_CntList[index]);
    putValue(A_ASG_49_0_0_23_Data_8, A_ASG_49_0_0_23_ArrayDataList[index].Param8, A_ASG_49_0_0_23_ArrayDataList[index].Param8_Length);
}

A_ASG_49_0_0_23_ChangedInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[363];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ElementType
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_ASG_49_0_0_23_1_Changed, tempValue);
    //Einzelparameter: Parent_ID
    //voriger Parameter war ein first nibble, bei 2 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue =  (gBAP_Indication_data[currentPos++] & 0xFF);
    tempValue += (gBAP_Indication_data[currentPos++] & 0xFF) << 8;
    putValue(A_ASG_49_0_0_23_2_Changed, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_23_Changed, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_23_Changed, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_23_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 23");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_23_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_23_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 23");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_23_DataIndex);
}




on envVar A_ASG_49_0_0_23_1
{
	byte superval[363];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_23_2_range // ReceptionList.TAID 
{
	@A_ASG_49_0_0_23_2 = @A_ASG_49_0_0_23_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_23_2
{
	byte superval[363];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_23_2, 1.0);
	@A_ASG_49_0_0_23_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_ASG_49_0_0_23_3
{
	byte superval[363];

	//Update Childvalue (Enum)
	byte thisval; // ElementType
	thisval = getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_23_4_range // ReceptionList.Parent_ID 
{
	@A_ASG_49_0_0_23_4 = @A_ASG_49_0_0_23_4_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_23_4
{
	byte superval[363];

	//Update Childvalue (Number)
	word thisval; // Parent_ID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_23_4, 1.0);
	@A_ASG_49_0_0_23_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_23_5_range // ReceptionList.TotalNumListElements 
{
	@A_ASG_49_0_0_23_5 = @A_ASG_49_0_0_23_5_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_23_5
{
	byte superval[363];

	//Update Childvalue (Number)
	word thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_23_5, 1.0);
	@A_ASG_49_0_0_23_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_23_Data_1_range // ReceptionList.Pos 
{
	@A_ASG_49_0_0_23_Data_1 = @A_ASG_49_0_0_23_Data_1_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_23_Data_1
{
	byte superval[363];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_23_Data_1, 1.0);
	@A_ASG_49_0_0_23_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param1 = thisval;
}
on envVar A_ASG_49_0_0_23_Data_2
{
	byte superval[363];

	//Update Childvalue (Enum)
	byte thisval; // Type
	thisval = getValue(this);
    A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param2 = thisval;
}
on envVar A_ASG_49_0_0_23_Data_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_8
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<8)|(bitval<<8);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_9
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<9)|(bitval<<9);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_10
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<10)|(bitval<<10);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_11
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<11)|(bitval<<11);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3_12
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_23_Data_3);
	thisval = thisval&~(1<<12)|(bitval<<12);
	putValue(A_ASG_49_0_0_23_Data_3,thisval);
}

on envVar A_ASG_49_0_0_23_Data_3
{
	byte superval[363];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	word thisval; // Attributes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_ASG_49_0_0_23_Data_3_0, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_0, 0);
	if(thisval&(mask<<1))
		putValue(A_ASG_49_0_0_23_Data_3_1, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_1, 0);
	if(thisval&(mask<<2))
		putValue(A_ASG_49_0_0_23_Data_3_2, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_2, 0);
	if(thisval&(mask<<3))
		putValue(A_ASG_49_0_0_23_Data_3_3, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_3, 0);
	if(thisval&(mask<<4))
		putValue(A_ASG_49_0_0_23_Data_3_4, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_4, 0);
	if(thisval&(mask<<5))
		putValue(A_ASG_49_0_0_23_Data_3_5, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_5, 0);
	if(thisval&(mask<<6))
		putValue(A_ASG_49_0_0_23_Data_3_6, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_6, 0);
	if(thisval&(mask<<7))
		putValue(A_ASG_49_0_0_23_Data_3_7, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_7, 0);
	if(thisval&(mask<<8))
		putValue(A_ASG_49_0_0_23_Data_3_8, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_8, 0);
	if(thisval&(mask<<9))
		putValue(A_ASG_49_0_0_23_Data_3_9, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_9, 0);
	if(thisval&(mask<<10))
		putValue(A_ASG_49_0_0_23_Data_3_10, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_10, 0);
	if(thisval&(mask<<11))
		putValue(A_ASG_49_0_0_23_Data_3_11, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_11, 0);
	if(thisval&(mask<<12))
		putValue(A_ASG_49_0_0_23_Data_3_12, 1);
	else
		putValue(A_ASG_49_0_0_23_Data_3_12, 0);
    A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param3 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_23_Data_4_range // ReceptionList.PresetID 
{
	@A_ASG_49_0_0_23_Data_4 = @A_ASG_49_0_0_23_Data_4_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_23_Data_4
{
	byte superval[363];

	//Update Childvalue (Number)
	byte thisval; // PresetID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_23_Data_4, 1.0);
	@A_ASG_49_0_0_23_Data_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param4 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_23_Data_5_range // ReceptionList.FmREG_Code 
{
	@A_ASG_49_0_0_23_Data_5 = @A_ASG_49_0_0_23_Data_5_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_23_Data_5
{
	byte superval[363];

	//Update Childvalue (Number)
	byte thisval; // FmREG_Code
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_23_Data_5, 1.0);
	@A_ASG_49_0_0_23_Data_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param5 = thisval;
}
on envVar A_ASG_49_0_0_23_Data_6
{
	byte superval[363];

	//Update Childvalue (Enum)
	byte thisval; // Category
	thisval = getValue(this);
    A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param6 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_23_Data_7_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_23_Data_7_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_23_Data_7_CntList[ getValue(A_ASG_49_0_0_23_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_23_Data_7_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_23_Data_7_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_23_Data_7_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 48 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_23_Data_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 48);
		thisval = 48;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_23_Data_7_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param7_Length = thisval;
	A_ASG_49_0_0_23_Data_7_LenList[ getValue(A_ASG_49_0_0_23_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_23_Data_7_len, thisval);

}

on envVar A_ASG_49_0_0_23_Data_7
{
	byte superval[363];

	//Update Childvalue (String)
	word i;
	byte thisval[49];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param7[i] = thisval[i];
    A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param7_Length = getValueSize(this);
    A_ASG_49_0_0_23_Data_7_LenList[getValue(A_ASG_49_0_0_23_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_23_Data_7_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_23_Data_8_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_23_Data_8_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_23_Data_8_CntList[ getValue(A_ASG_49_0_0_23_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_23_Data_8_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_23_Data_8_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_23_Data_8_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 30 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_23_Data_8 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 30);
		thisval = 30;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_23_Data_8_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param8_Length = thisval;
	A_ASG_49_0_0_23_Data_8_LenList[ getValue(A_ASG_49_0_0_23_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_23_Data_8_len, thisval);

}

on envVar A_ASG_49_0_0_23_Data_8
{
	byte superval[363];

	//Update Childvalue (String)
	word i;
	byte thisval[31];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param8[i] = thisval[i];
    A_ASG_49_0_0_23_ArrayDataList[getValue(A_ASG_49_0_0_23_DataIndex)].Param8_Length = getValueSize(this);
    A_ASG_49_0_0_23_Data_8_LenList[getValue(A_ASG_49_0_0_23_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_23_Data_8_len, getValueSize(this));
}
on envVar A_ASG_49_0_0_23_1_Changed
{
	byte superval[363];

	//Update Childvalue (Enum)
	byte thisval; // ElementType
	thisval = getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_23_2_Changed_range // ReceptionList.Parent_ID 
{
	@A_ASG_49_0_0_23_2_Changed = @A_ASG_49_0_0_23_2_Changed_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_23_2_Changed
{
	byte superval[363];

	//Update Childvalue (Number)
	word thisval; // Parent_ID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_23_2_Changed, 1.0);
	@A_ASG_49_0_0_23_2_Changed_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_ASG_49_0_0_23_1_SetGet
{
	byte superval[9];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_23_2_SetGet_range // ReceptionList.TAID 
{
	@A_ASG_49_0_0_23_2_SetGet = @A_ASG_49_0_0_23_2_SetGet_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_23_2_SetGet
{
	byte superval[9];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_23_2_SetGet, 1.0);
	@A_ASG_49_0_0_23_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_ASG_49_0_0_23_3_SetGet
{
	byte superval[9];

	//Update Childvalue (Enum)
	byte thisval; // ElementType
	thisval = getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_23_4_SetGet_range // ReceptionList.Parent_ID 
{
	@A_ASG_49_0_0_23_4_SetGet = @A_ASG_49_0_0_23_4_SetGet_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_23_4_SetGet
{
	byte superval[9];

	//Update Childvalue (Number)
	word thisval; // Parent_ID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_23_4_SetGet, 1.0);
	@A_ASG_49_0_0_23_4_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar M_ASG_49_0_0_24AbortResult_BTN
{
    if (M_ASG_49_0_0_24AbortResult_BTN_already_pressed == 0)
    {
         putValue(M_ASG_49_0_0_24_ErrCode,0);
         SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_24",MakeRGB(255,255,255));
         M_ASG_49_0_0_24AbortResult_BTN_already_pressed = 1;
    }
    else
    {
         putValue(M_ASG_49_0_0_24_State, "AbortResult");
         Request_Void(LSGID, M_ASG_49_0_0_24_ID, AbortResult_REQ);
         M_ASG_49_0_0_24AbortResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_24StartResult_BTN
{
    byte temp[4];
    if (M_ASG_49_0_0_24StartResult_BTN_already_pressed == 0)
    {
        putValue(M_ASG_49_0_0_24_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_24",MakeRGB(255,255,255));
        M_ASG_49_0_0_24StartResult_BTN_already_pressed = 1;
    }
    else
    {
        getValue(M_ASG_49_0_0_24_Start, temp);
        Request_ByteSequence(LSGID, M_ASG_49_0_0_24_ID, StartResult_REQ, temp, getValueSize(M_ASG_49_0_0_24_Start));
        putValue(M_ASG_49_0_0_24_State, "Started");
        M_ASG_49_0_0_24StartResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_24_Result // bus value of DedicatedAudioControl (24).
{
	// opcodes: Error-Processing-Result
	byte param1; // dedicatedAudioControlResult
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_24_Result);
	putValue(M_ASG_49_0_0_24_Result_1, param1);
}

on envVar M_ASG_49_0_0_24_Result_1 // DedicatedAudioControl.dedicatedAudioControlResult
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // dedicatedAudioControlResult
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_ASG_49_0_0_24_Result);
	superval = thisval;
	putValue(M_ASG_49_0_0_24_Result,superval);
}

on envVar M_ASG_49_0_0_24_Processing // bus value of DedicatedAudioControl (24).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_24_Processing);
	putValue(M_ASG_49_0_0_24_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_24_Processing_1_range // DedicatedAudioControl.Reserve1 
{
	@M_ASG_49_0_0_24_Processing_1 = @M_ASG_49_0_0_24_Processing_1_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_24_Processing_1 // DedicatedAudioControl.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_ASG_49_0_0_24_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_ASG_49_0_0_24_Processing);
	superval = thisval;
	putValue(M_ASG_49_0_0_24_Processing,superval);
}

on envVar M_ASG_49_0_0_24_Start // bus value of DedicatedAudioControl (24).
{
	// opcodes: AbortResult-StartResult
	byte param1; // ControlType
	word param2; // AdditionalControlInformation
	byte param3; // ListType
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[4];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 4; i++ ) {
		superval[i] = 0;
	}
	getValue(M_ASG_49_0_0_24_Start, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_ASG_49_0_0_24_Start_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_ASG_49_0_0_24_Start_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(M_ASG_49_0_0_24_Start_3, param3);
}

on envVar M_ASG_49_0_0_24_Start_1 // DedicatedAudioControl.ControlType
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // ControlType
	thisval = getValue(this);

    // Update superval
	getValue(M_ASG_49_0_0_24_Start, superval);
	superval[0]=thisval;
	putValue(M_ASG_49_0_0_24_Start,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_24_Start_2_range // DedicatedAudioControl.AdditionalControlInformation 
{
	@M_ASG_49_0_0_24_Start_2 = @M_ASG_49_0_0_24_Start_2_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_24_Start_2 // DedicatedAudioControl.AdditionalControlInformation
{
	byte superval[4];

	//Update Childvalue (Number)
	word thisval; // AdditionalControlInformation
	float slider_value;

	slider_value = round(@M_ASG_49_0_0_24_Start_2, 1.0);
	@M_ASG_49_0_0_24_Start_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_ASG_49_0_0_24_Start, superval);
	superval[1]=thisval&0x00ff;
	superval[2]=(thisval&0xff00)>>8;
	putValue(M_ASG_49_0_0_24_Start,superval);
}

on envVar M_ASG_49_0_0_24_Start_3 // DedicatedAudioControl.ListType
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // ListType
	thisval = getValue(this);

    // Update superval
	getValue(M_ASG_49_0_0_24_Start, superval);
	superval[3]=thisval;
	putValue(M_ASG_49_0_0_24_Start,superval);
}

on envVar P_ASG_49_0_0_25Get_BTN
{
 if (P_ASG_49_0_0_25Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_25_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_25",MakeRGB(255,255,255));
       P_ASG_49_0_0_25Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_25_ID, DataGet_REQ); 
       P_ASG_49_0_0_25Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_25SetGet_BTN
{
	byte BAPTemp[2];
    if (P_ASG_49_0_0_25SetGet_BTN_already_pressed == 0)
    {
       putValue(P_ASG_49_0_0_25_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_25",MakeRGB(255,255,255));
       P_ASG_49_0_0_25SetGet_BTN_already_pressed = 1;
    }
    else
    {
       getValue(P_ASG_49_0_0_25, BAPTemp);
       Request_ByteSequence(LSGID, P_ASG_49_0_0_25_ID, DataSetGet_REQ, BAPTemp, getValueSize(P_ASG_49_0_0_25));
       P_ASG_49_0_0_25SetGet_BTN_already_pressed = 0;
    }
}
on envVar P_ASG_49_0_0_25 // bus value of GeneralInfoSwitches (25).
{
	// opcodes: Error-Status
	byte param1; // OnOffSwitches
	byte param2; // Modification
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[2];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_25, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_25_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_25_2, param2);
}

on envVar P_ASG_49_0_0_25_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // OnOffSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_25_1,thisval);
}

on envVar P_ASG_49_0_0_25_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // OnOffSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_25_1,thisval);
}

on envVar P_ASG_49_0_0_25_1_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // OnOffSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_1);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_25_1,thisval);
}

on envVar P_ASG_49_0_0_25_1_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // OnOffSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_1);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_25_1,thisval);
}

on envVar P_ASG_49_0_0_25_1_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // OnOffSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_1);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_25_1,thisval);
}

on envVar P_ASG_49_0_0_25_1_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // OnOffSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_1);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_ASG_49_0_0_25_1,thisval);
}

on envVar P_ASG_49_0_0_25_1_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // OnOffSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_1);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_ASG_49_0_0_25_1,thisval);
}

on envVar P_ASG_49_0_0_25_1 // GeneralInfoSwitches.OnOffSwitches
{
	byte superval[2];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // OnOffSwitches
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_25_1_0, 1);
	else
		putValue(P_ASG_49_0_0_25_1_0, 0);
	if(thisval&(mask<<1))
		putValue(P_ASG_49_0_0_25_1_1, 1);
	else
		putValue(P_ASG_49_0_0_25_1_1, 0);
	if(thisval&(mask<<2))
		putValue(P_ASG_49_0_0_25_1_2, 1);
	else
		putValue(P_ASG_49_0_0_25_1_2, 0);
	if(thisval&(mask<<3))
		putValue(P_ASG_49_0_0_25_1_3, 1);
	else
		putValue(P_ASG_49_0_0_25_1_3, 0);
	if(thisval&(mask<<4))
		putValue(P_ASG_49_0_0_25_1_4, 1);
	else
		putValue(P_ASG_49_0_0_25_1_4, 0);
	if(thisval&(mask<<5))
		putValue(P_ASG_49_0_0_25_1_5, 1);
	else
		putValue(P_ASG_49_0_0_25_1_5, 0);
	if(thisval&(mask<<6))
		putValue(P_ASG_49_0_0_25_1_6, 1);
	else
		putValue(P_ASG_49_0_0_25_1_6, 0);

    // Update superval
	getValue(P_ASG_49_0_0_25, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_25,superval);
}

on envVar P_ASG_49_0_0_25_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Modification
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_25_2,thisval);
}

on envVar P_ASG_49_0_0_25_2_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Modification
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_2);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_25_2,thisval);
}

on envVar P_ASG_49_0_0_25_2_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Modification
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_2);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_25_2,thisval);
}

on envVar P_ASG_49_0_0_25_2_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Modification
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_2);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_25_2,thisval);
}

on envVar P_ASG_49_0_0_25_2_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Modification
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_2);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_25_2,thisval);
}

on envVar P_ASG_49_0_0_25_2_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Modification
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_2);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_ASG_49_0_0_25_2,thisval);
}

on envVar P_ASG_49_0_0_25_2_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Modification
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_25_2);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_ASG_49_0_0_25_2,thisval);
}

on envVar P_ASG_49_0_0_25_2 // GeneralInfoSwitches.Modification
{
	byte superval[2];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Modification
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_25_2_0, 1);
	else
		putValue(P_ASG_49_0_0_25_2_0, 0);
	if(thisval&(mask<<1))
		putValue(P_ASG_49_0_0_25_2_1, 1);
	else
		putValue(P_ASG_49_0_0_25_2_1, 0);
	if(thisval&(mask<<2))
		putValue(P_ASG_49_0_0_25_2_2, 1);
	else
		putValue(P_ASG_49_0_0_25_2_2, 0);
	if(thisval&(mask<<3))
		putValue(P_ASG_49_0_0_25_2_3, 1);
	else
		putValue(P_ASG_49_0_0_25_2_3, 0);
	if(thisval&(mask<<4))
		putValue(P_ASG_49_0_0_25_2_4, 1);
	else
		putValue(P_ASG_49_0_0_25_2_4, 0);
	if(thisval&(mask<<5))
		putValue(P_ASG_49_0_0_25_2_5, 1);
	else
		putValue(P_ASG_49_0_0_25_2_5, 0);
	if(thisval&(mask<<6))
		putValue(P_ASG_49_0_0_25_2_6, 1);
	else
		putValue(P_ASG_49_0_0_25_2_6, 0);

    // Update superval
	getValue(P_ASG_49_0_0_25, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_25,superval);
}

on envVar P_ASG_49_0_0_26Get_BTN
{
 if (P_ASG_49_0_0_26Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_26_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_26",MakeRGB(255,255,255));
       P_ASG_49_0_0_26Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_26_ID, DataGet_REQ); 
       P_ASG_49_0_0_26Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_26 // bus value of TpMemoInfo (26).
{
	// opcodes: Error-Status
	byte param1[2]; //Record: TpCounters
	byte param2[2]; //Record: MessageTime
	byte param3[49]; // StationName
	word len3;
	byte cnt3;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[53];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 53; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_26, superval);
	///////// Start param1 - Record /////////
	for( i = 0; i < 2; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(P_ASG_49_0_0_26_1, param1);
	///////// Start param2 - Record /////////
	for( i = 0; i < 2; i++ )
	{
		param2[i] = superval[currentPos++];
	}
	putValue(P_ASG_49_0_0_26_2, param2);
	///////// Start param3 - STRING /////////
	getValue(P_ASG_49_0_0_26_3, param3);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(48>127) /* Max Fct-Katalog Laenge: 48*/
		{
			len3 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt3 = 1;
		}
		else
		{
			len3 = 48;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_26 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len3 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt3 = 0;
	}
	
	if(len3 > 48)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len3, currentPos);
		len3 = 48;
	
		if(len3 < 128) cnt3 = 0;
		else cnt3 = 1;
	}
	
	for(i = 0; i < len3; i++)
	{
		param3[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_26_3_len, len3);
	putValue(P_ASG_49_0_0_26_3_cnt, cnt3);
	
	if(len3 > getValueSize(P_ASG_49_0_0_26_3))
		putValue(P_ASG_49_0_0_26_3, param3, len3);
	else
		putValue(P_ASG_49_0_0_26_3, param3, getValueSize(P_ASG_49_0_0_26_3));

}

// Updates the bus value field and other dependencies.
P_ASG_49_0_0_26_BuildFct()
{
	byte param1[2]; //Record: TpCounters
	byte param2[2]; //Record: MessageTime
	byte param3[49]; // StationName
	word len3;
	byte cnt3;

	int i;
	byte superval[53];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	//Record:TpCounters
	getValue(P_ASG_49_0_0_26_1, param1);
	for( i = 0; i < 2; i++)
	{
	 superval[currentPos++] = param1[i];
	}
// gen_BuildFunc_SetSuperVals 
	//Record:MessageTime
	getValue(P_ASG_49_0_0_26_2, param2);
	for( i = 0; i < 2; i++)
	{
	 superval[currentPos++] = param2[i];
	}
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_26_3, param3);
	len3 = getValue(P_ASG_49_0_0_26_3_len);
	cnt3= getValue(P_ASG_49_0_0_26_3_cnt);
	
	/* check box aktiviert*/
	if (cnt3 == 1)
	{
		/* 0 bis 48 (MaxString - 1B oder 2B) */
		if(len3 >= 0 && len3 <= 48)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len3: %d", len3);
			superval[currentPos] = (len3&0x7f00) | 0x80;
			superval[currentPos+1] = len3 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_26_3 ist ungueltig. Die max. erlaubte Laenge ist %d.", len3, 48);
			return;
		}
	}
	else if(cnt3 == 0) /*check box deaktiviert*/
	{
		if(len3 >= 0 && len3 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len3: %d", len3);
			superval[currentPos]= len3 & 0x00ff;
			putValue(P_ASG_49_0_0_26_3_len, len3);
		}
		else if(len3 > 127 && len3 <= 48)
		{
			superval[currentPos] = (len3&0x7f00) | 0x80;
			superval[currentPos+1] = len3 & 0x00ff;
			putValue(P_ASG_49_0_0_26_3_len, len3);
			putValue(P_ASG_49_0_0_26_3_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_26_3 ist ungueltig. Die max. erlaubte Laenge ist %d.", len3, 48);
			return;
		}
	}
	currentPos += cnt3+1;
	for(i = 0; i < len3; i++)
	{
		superval[currentPos++]= param3[i];
	}

	putValue(P_ASG_49_0_0_26, superval, currentPos);
}


//Record: TpCounters, Element: CurrentMsgNumber
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_26_1_CurrentMsgNumber_range // TpMemoInfo.CurrentMsgNumber 
{
	@P_ASG_49_0_0_26_1_CurrentMsgNumber = @P_ASG_49_0_0_26_1_CurrentMsgNumber_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_26_1_CurrentMsgNumber // TpCounters.CurrentMsgNumber
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // CurrentMsgNumber
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_26_1_CurrentMsgNumber, 1.0);
	@P_ASG_49_0_0_26_1_CurrentMsgNumber_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_26_1, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_26_1,superval);
}

//Record: TpCounters, Element: TotalMsgNumber
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_26_1_TotalMsgNumber_range // TpMemoInfo.TotalMsgNumber 
{
	@P_ASG_49_0_0_26_1_TotalMsgNumber = @P_ASG_49_0_0_26_1_TotalMsgNumber_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_26_1_TotalMsgNumber // TpCounters.TotalMsgNumber
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // TotalMsgNumber
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_26_1_TotalMsgNumber, 1.0);
	@P_ASG_49_0_0_26_1_TotalMsgNumber_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_26_1, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_26_1,superval);
}

on envVar P_ASG_49_0_0_26_1 // TpMemoInfo.TpCounters
{
	byte recordVal[2]; //Record: TpCounters
	int currentPos;
	int i;
//UpdateChildValue for Record.
	byte param1; // CurrentMsgNumber
	byte param2; // TotalMsgNumber

	currentPos = 0;
	getValue(P_ASG_49_0_0_26_1, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT8 /////////
	param1 = recordVal[currentPos++];
	putValue(P_ASG_49_0_0_26_1_CurrentMsgNumber, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_ASG_49_0_0_26_1_TotalMsgNumber, round((param2 * 1.0) - (0) + (0), 1.0));
	P_ASG_49_0_0_26_BuildFct();
}

//Record: MessageTime, Element: Hour
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_26_2_Hour_range // TpMemoInfo.Hour 
{
	@P_ASG_49_0_0_26_2_Hour = @P_ASG_49_0_0_26_2_Hour_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_26_2_Hour // MessageTime.Hour
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_26_2_Hour, 1.0);
	@P_ASG_49_0_0_26_2_Hour_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_26_2, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_26_2,superval);
}

//Record: MessageTime, Element: Minute
// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_26_2_Minute_range // TpMemoInfo.Minute 
{
	@P_ASG_49_0_0_26_2_Minute = @P_ASG_49_0_0_26_2_Minute_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_26_2_Minute // MessageTime.Minute
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_26_2_Minute, 1.0);
	@P_ASG_49_0_0_26_2_Minute_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_26_2, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_26_2,superval);
}

on envVar P_ASG_49_0_0_26_2 // TpMemoInfo.MessageTime
{
	byte recordVal[2]; //Record: MessageTime
	int currentPos;
	int i;
//UpdateChildValue for Record.
	byte param1; // Hour
	byte param2; // Minute

	currentPos = 0;
	getValue(P_ASG_49_0_0_26_2, recordVal);
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	///////// Start param1 - UINT8 /////////
	param1 = recordVal[currentPos++];
	putValue(P_ASG_49_0_0_26_2_Hour, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = recordVal[currentPos++];
	putValue(P_ASG_49_0_0_26_2_Minute, round((param2 * 1.0) - (0) + (0), 1.0));
	P_ASG_49_0_0_26_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_26_3_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_26_3_len);
	cnt = getValue(P_ASG_49_0_0_26_3_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_26_3_len, 127);
		}
	}

	P_ASG_49_0_0_26_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_26_3_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 48)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_26_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 48);
		putValue(this, 48);
	}
	P_ASG_49_0_0_26_BuildFct();
}


on envVar P_ASG_49_0_0_26_3 // TpMemoInfo.StationName
{
	putValue(P_ASG_49_0_0_26_3_len, getValueSize(this));
	P_ASG_49_0_0_26_BuildFct();
}

on envVar A_ASG_49_0_0_27Get_BTN
{
  byte data[5]; 
  byte stringValue[5];
  byte head[5];
  int i;
  int headLength;
  long tempValue;
  word currentPos;
  word startVal;
  word elementsVal;
  byte nibbleSetted;
  if (A_ASG_49_0_0_27Get_BTN_already_pressed == 0)
  {
     putValue(A_ASG_49_0_0_27_ErrCode,0);
     SetControlBackColor(panel_name,"errField_A_ASG_49_0_0_27",MakeRGB(255,255,255));
     A_ASG_49_0_0_27Get_BTN_already_pressed = 1;
  }
  else
  {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_ASG_49_0_0_27_1_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_ASG_49_0_0_27_2_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //head Parameter
        headLength = getValueSize(A_ASG_49_0_0_27_SetGet);
        getValue(A_ASG_49_0_0_27_SetGet,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }

     Request_ByteSequence(LSGID, A_ASG_49_0_0_27_ID, DataGet_REQ, data, currentPos);
     if(getValue(A_ASG_49_0_0_27_IntTlgEn)) //getValue(IT))
     {
       intertelegram_err(A_ASG_49_0_0_27_ID);
     }
     if(getValue(A_ASG_49_0_0_27_SegmEn))   //getvalue(SG)
     {
         sequence_err(A_ASG_49_0_0_27_ID,getValueSize(A_ASG_49_0_0_27_SetGet));
     }
     A_ASG_49_0_0_27Get_BTN_already_pressed = 0;
  }
}
A_ASG_49_0_0_27_SetGet_GenerateSetGet()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_ASG_49_0_0_27_SetGet_RecAdr) > 0x0F)
        putValue(A_ASG_49_0_0_27_SetGet_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_ASG_49_0_0_27_SetGet_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_ASG_49_0_0_27_SetGet_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_ASG_49_0_0_27_SetGet_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // reserverd:  Byte 0 Bit 6
    if( getValue(A_ASG_49_0_0_27_SetGet_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_ASG_49_0_0_27_SetGet_Start) & 0xFF;
        head[2] = (getValue(A_ASG_49_0_0_27_SetGet_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_ASG_49_0_0_27_SetGet_Elements) & 0xFF;
        head[4] = (getValue(A_ASG_49_0_0_27_SetGet_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_ASG_49_0_0_27_SetGet, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_ASG_49_0_0_27_SetGet_Start) & 0xFF;
        head[2] = getValue(A_ASG_49_0_0_27_SetGet_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_ASG_49_0_0_27_SetGet, head, 3); 
    }
}

on envVar A_ASG_49_0_0_27_SetGet_RecAdr
{
    A_ASG_49_0_0_27_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_27_SetGet_Shift
{
    A_ASG_49_0_0_27_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_27_SetGet_Direction
{
    A_ASG_49_0_0_27_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_27_SetGet_Start
{
    A_ASG_49_0_0_27_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_27_SetGet_Elements
{
    A_ASG_49_0_0_27_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_27_SetGet_IndexSize
{
    A_ASG_49_0_0_27_SetGet_GenerateSetGet();
}
on envVar A_ASG_49_0_0_27
{
    byte temp[5];
    byte head[5];
    getValue(A_ASG_49_0_0_27, head);
    putValue(A_ASG_49_0_0_27_RecAdr, 0x0F & head[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & head[0]) >0)
        putValue(A_ASG_49_0_0_27_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & head[0]) >0)
        putValue(A_ASG_49_0_0_27_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & head[0]) >0)
        putValue(A_ASG_49_0_0_27_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & head[0]) >0)
        putValue(A_ASG_49_0_0_27_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_27_IndexSize))
    {
        putValue(A_ASG_49_0_0_27_Start, ((head[2]<<8)| head[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_27_Elements, ((head[4]<<8)| head[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_27_Start, head[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_27_Elements, head[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_27_Changed
{
    byte temp[164];
    getValue(A_ASG_49_0_0_27_Changed, temp);
    putValue(A_ASG_49_0_0_27_Changed_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_27_Changed_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_Changed_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_27_Changed_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_Changed_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_ASG_49_0_0_27_Changed_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_Changed_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_27_Changed_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_Changed_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_27_Changed_IndexSize))
    {
        putValue(A_ASG_49_0_0_27_Changed_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_27_Changed_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_27_Changed_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_27_Changed_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_27_SetGet
{
    byte temp[5];
    getValue(A_ASG_49_0_0_27_SetGet, temp);
    putValue(A_ASG_49_0_0_27_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_27_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_27_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_27_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_27_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_27_SetGet_IndexSize))
    {
        putValue(A_ASG_49_0_0_27_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_27_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_27_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_27_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_ASG_49_0_0_27_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_ASG_49_0_0_27_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_ASG_49_0_0_27_ArrayDataList[i].Param1 = 0;
		A_ASG_49_0_0_27_ArrayDataList[i].Param2 = 0;
		A_ASG_49_0_0_27_ArrayDataList[i].Param3 = 0;
		A_ASG_49_0_0_27_ArrayDataList[i].Param4 = 0;
		for(j=0; j<49; j++)
			A_ASG_49_0_0_27_ArrayDataList[i].Param5[j] = 0;
		A_ASG_49_0_0_27_ArrayDataList[i].Param5_Length = 0;
		A_ASG_49_0_0_27_Data_5_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_ASG_49_0_0_27_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
					{
						A_ASG_49_0_0_27_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_ASG_49_0_0_27_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //Attributes
						A_ASG_49_0_0_27_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //MessageTime_Hour
						A_ASG_49_0_0_27_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //MessageTime_Minute
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 256)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Attributes
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //MessageTime_Hour
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //MessageTime_Minute
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //StationName
								if(paramPos < 48)
								{
									A_ASG_49_0_0_27_ArrayDataList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_27_ArrayDataList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_ASG_49_0_0_27_loadArray_Btn
{
	char filePath[255];
	if (A_ASG_49_0_0_27_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_27_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_ASG_49_0_0_27_generateData_Btn_already_pressed = 0;
		getValue(A_ASG_49_0_0_27_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_ASG_49_0_0_27_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_ASG_49_0_0_27_Data_1, A_ASG_49_0_0_27_ArrayDataList[ getValue( A_ASG_49_0_0_27_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_27_Data_2, A_ASG_49_0_0_27_ArrayDataList[ getValue( A_ASG_49_0_0_27_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_27_Data_3, A_ASG_49_0_0_27_ArrayDataList[ getValue( A_ASG_49_0_0_27_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_27_Data_4, A_ASG_49_0_0_27_ArrayDataList[ getValue( A_ASG_49_0_0_27_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_27_Data_5, A_ASG_49_0_0_27_ArrayDataList[ getValue( A_ASG_49_0_0_27_DataIndex) ].Param5, A_ASG_49_0_0_27_ArrayDataList[getValue(A_ASG_49_0_0_27_DataIndex)].Param5_Length);
}


on envVar A_ASG_49_0_0_27_generateData_Btn
{
	word i;
	dword elementsArray[6] = {1, 1, 1, 1, 49, 2};
	byte elementsTypeArray[6] = {0, 0, 0, 0, 0xE, 0xF};
	dword elementsMaxSizeArray[6] = {255, 0xFF, 23, 59, 0, 0};
	byte tempArray[14025];
	if (A_ASG_49_0_0_27_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_27_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 27, 255 );
		for(i = 0; i < 255; i++)
		{
			memcpy(A_ASG_49_0_0_27_ArrayDataList[i], tempArray, (i * 55) );
			if(A_ASG_49_0_0_27_ArrayDataList[i].Param5_Length > 127 )
				A_ASG_49_0_0_27_Data_5_CntList[i] = 1;
		}
		A_ASG_49_0_0_27_generateData_Btn_already_pressed = 0;
	}
	putValue(A_ASG_49_0_0_27_Data_1, A_ASG_49_0_0_27_ArrayDataList[ getValue( A_ASG_49_0_0_27_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_27_Data_2, A_ASG_49_0_0_27_ArrayDataList[ getValue( A_ASG_49_0_0_27_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_27_Data_3, A_ASG_49_0_0_27_ArrayDataList[ getValue( A_ASG_49_0_0_27_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_27_Data_4, A_ASG_49_0_0_27_ArrayDataList[ getValue( A_ASG_49_0_0_27_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_27_Data_5, A_ASG_49_0_0_27_ArrayDataList[ getValue( A_ASG_49_0_0_27_DataIndex) ].Param5, A_ASG_49_0_0_27_ArrayDataList[getValue(A_ASG_49_0_0_27_DataIndex)].Param5_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_ASG_49_0_0_27_DataIndex
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_ASG_49_0_0_27_Data_1, A_ASG_49_0_0_27_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_27_Data_2, A_ASG_49_0_0_27_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_27_Data_3, A_ASG_49_0_0_27_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_27_Data_4, A_ASG_49_0_0_27_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_27_Data_5_len, A_ASG_49_0_0_27_Data_5_LenList[index]);
    putValue(A_ASG_49_0_0_27_Data_5_cnt, A_ASG_49_0_0_27_Data_5_CntList[index]);
    putValue(A_ASG_49_0_0_27_Data_5, A_ASG_49_0_0_27_ArrayDataList[index].Param5, A_ASG_49_0_0_27_ArrayDataList[index].Param5_Length);

}
on envVar A_ASG_49_0_0_27_DataIndex_Incr
{
    long index;
    if(A_ASG_49_0_0_27_DataIndex_Incr_already_pressed == 0)
    {
        A_ASG_49_0_0_27_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_27_DataIndex);
        index++;
        putValue(A_ASG_49_0_0_27_DataIndex, index);
        A_ASG_49_0_0_27_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_ASG_49_0_0_27_DataIndex_Decr
{
    long index;
    if(A_ASG_49_0_0_27_DataIndex_Decr_already_pressed == 0)
    {
        A_ASG_49_0_0_27_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_27_DataIndex);
        index--;
        putValue(A_ASG_49_0_0_27_DataIndex, index);
        A_ASG_49_0_0_27_DataIndex_Decr_already_pressed = 0;
    }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_27_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_27_SegmEn,0);
           intertelegram_err(A_ASG_49_0_0_27_ID);
       }
       else
       {
           intertelegram_err_off(A_ASG_49_0_0_27_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_27_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_27_IntTlgEn,0);
           sequence_err(A_ASG_49_0_0_27_ID,getValueSize(A_ASG_49_0_0_27_SegmEn));
       }
       else
       {
              sequence_err_off(A_ASG_49_0_0_27_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_ASG_49_0_0_27_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_ASG_49_0_0_27_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_ASG_49_0_0_27_Status",1);
 	}
}

A_ASG_49_0_0_27_DataInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[164];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_27_1, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_27_2, tempValue);
    //Einzelparameter: TotalNumListElements
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_ASG_49_0_0_27_3, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_27, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_27, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_27_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 27");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_27_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_27_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_27_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_27_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_27_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_27_Data_5_CntList[i] = 1;
            A_ASG_49_0_0_27_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_27_Data_5_CntList[i] = 0;
            A_ASG_49_0_0_27_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_27_ArrayDataList[i].Param5_Length; j++)
        {
            A_ASG_49_0_0_27_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_27_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_27_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 27");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_27_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_27_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_27_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_27_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_27_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_27_Data_5_CntList[i] = 1;
            A_ASG_49_0_0_27_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_27_Data_5_CntList[i] = 0;
            A_ASG_49_0_0_27_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_27_ArrayDataList[i].Param5_Length; j++)
        {
            A_ASG_49_0_0_27_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_27_DataIndex);
    putValue(A_ASG_49_0_0_27_Data_1, A_ASG_49_0_0_27_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_27_Data_2, A_ASG_49_0_0_27_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_27_Data_3, A_ASG_49_0_0_27_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_27_Data_4, A_ASG_49_0_0_27_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_27_Data_5_len, A_ASG_49_0_0_27_Data_5_LenList[index]);
    putValue(A_ASG_49_0_0_27_Data_5_cnt, A_ASG_49_0_0_27_Data_5_CntList[index]);
    putValue(A_ASG_49_0_0_27_Data_5, A_ASG_49_0_0_27_ArrayDataList[index].Param5, A_ASG_49_0_0_27_ArrayDataList[index].Param5_Length);
}

A_ASG_49_0_0_27_ChangedInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[164];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_27_Changed, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_27_Changed, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_27_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 27");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_27_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_27_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 27");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_27_DataIndex);
}




on envVar A_ASG_49_0_0_27_1
{
	byte superval[164];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_27_2_range // TpMemoList.TAID 
{
	@A_ASG_49_0_0_27_2 = @A_ASG_49_0_0_27_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_27_2
{
	byte superval[164];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_27_2, 1.0);
	@A_ASG_49_0_0_27_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_27_3_range // TpMemoList.TotalNumListElements 
{
	@A_ASG_49_0_0_27_3 = @A_ASG_49_0_0_27_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_27_3
{
	byte superval[164];

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_27_3, 1.0);
	@A_ASG_49_0_0_27_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_27_Data_1_range // TpMemoList.Pos 
{
	@A_ASG_49_0_0_27_Data_1 = @A_ASG_49_0_0_27_Data_1_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_27_Data_1
{
	byte superval[164];

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_27_Data_1, 1.0);
	@A_ASG_49_0_0_27_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_27_ArrayDataList[getValue(A_ASG_49_0_0_27_DataIndex)].Param1 = thisval;
}
on envVar A_ASG_49_0_0_27_Data_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_27_Data_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_ASG_49_0_0_27_Data_2,thisval);
}

on envVar A_ASG_49_0_0_27_Data_2
{
	byte superval[164];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Attributes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_ASG_49_0_0_27_Data_2_0, 1);
	else
		putValue(A_ASG_49_0_0_27_Data_2_0, 0);
    A_ASG_49_0_0_27_ArrayDataList[getValue(A_ASG_49_0_0_27_DataIndex)].Param2 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_27_Data_3_range // TpMemoList.MessageTime_Hour 
{
	@A_ASG_49_0_0_27_Data_3 = @A_ASG_49_0_0_27_Data_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_27_Data_3
{
	byte superval[164];

	//Update Childvalue (Number)
	byte thisval; // MessageTime_Hour
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_27_Data_3, 1.0);
	@A_ASG_49_0_0_27_Data_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_27_ArrayDataList[getValue(A_ASG_49_0_0_27_DataIndex)].Param3 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_27_Data_4_range // TpMemoList.MessageTime_Minute 
{
	@A_ASG_49_0_0_27_Data_4 = @A_ASG_49_0_0_27_Data_4_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_27_Data_4
{
	byte superval[164];

	//Update Childvalue (Number)
	byte thisval; // MessageTime_Minute
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_27_Data_4, 1.0);
	@A_ASG_49_0_0_27_Data_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_27_ArrayDataList[getValue(A_ASG_49_0_0_27_DataIndex)].Param4 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_27_Data_5_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_27_Data_5_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_27_Data_5_CntList[ getValue(A_ASG_49_0_0_27_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_27_Data_5_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_27_Data_5_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_27_Data_5_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 48 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_27_Data_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 48);
		thisval = 48;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_27_Data_5_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_27_ArrayDataList[getValue(A_ASG_49_0_0_27_DataIndex)].Param5_Length = thisval;
	A_ASG_49_0_0_27_Data_5_LenList[ getValue(A_ASG_49_0_0_27_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_27_Data_5_len, thisval);

}

on envVar A_ASG_49_0_0_27_Data_5
{
	byte superval[164];

	//Update Childvalue (String)
	word i;
	byte thisval[49];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_27_ArrayDataList[getValue(A_ASG_49_0_0_27_DataIndex)].Param5[i] = thisval[i];
    A_ASG_49_0_0_27_ArrayDataList[getValue(A_ASG_49_0_0_27_DataIndex)].Param5_Length = getValueSize(this);
    A_ASG_49_0_0_27_Data_5_LenList[getValue(A_ASG_49_0_0_27_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_27_Data_5_len, getValueSize(this));
}
on envVar A_ASG_49_0_0_27_1_SetGet
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_27_2_SetGet_range // TpMemoList.TAID 
{
	@A_ASG_49_0_0_27_2_SetGet = @A_ASG_49_0_0_27_2_SetGet_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_27_2_SetGet
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_27_2_SetGet, 1.0);
	@A_ASG_49_0_0_27_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar P_ASG_49_0_0_28Get_BTN
{
 if (P_ASG_49_0_0_28Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_28_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_28",MakeRGB(255,255,255));
       P_ASG_49_0_0_28Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_28_ID, DataGet_REQ); 
       P_ASG_49_0_0_28Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_28 // bus value of AnnouncementInfo (28).
{
	// opcodes: Error-Status
	byte param1; // AnnouncementType
	byte param2[49]; // StationName
	word len2;
	byte cnt2;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[50];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 50; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_28, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_28_1, param1);
	///////// Start param2 - STRING /////////
	getValue(P_ASG_49_0_0_28_2, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(48>127) /* Max Fct-Katalog Laenge: 48*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 48;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_28 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 48)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 48;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_28_2_len, len2);
	putValue(P_ASG_49_0_0_28_2_cnt, cnt2);
	
	if(len2 > getValueSize(P_ASG_49_0_0_28_2))
		putValue(P_ASG_49_0_0_28_2, param2, len2);
	else
		putValue(P_ASG_49_0_0_28_2, param2, getValueSize(P_ASG_49_0_0_28_2));

}

// Updates the bus value field and other dependencies.
P_ASG_49_0_0_28_BuildFct()
{
	byte param1; // AnnouncementType
	byte param2[49]; // StationName
	word len2;
	byte cnt2;

	int i;
	byte superval[50];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_ASG_49_0_0_28_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_28_2, param2);
	len2 = getValue(P_ASG_49_0_0_28_2_len);
	cnt2= getValue(P_ASG_49_0_0_28_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 48 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 48)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_28_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 48);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(P_ASG_49_0_0_28_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 48)
		{
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(P_ASG_49_0_0_28_2_len, len2);
			putValue(P_ASG_49_0_0_28_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_28_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 48);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

	putValue(P_ASG_49_0_0_28, superval, currentPos);
}


on envVar P_ASG_49_0_0_28_1 // AnnouncementInfo.AnnouncementType
{
	P_ASG_49_0_0_28_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_28_2_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_28_2_len);
	cnt = getValue(P_ASG_49_0_0_28_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_28_2_len, 127);
		}
	}

	P_ASG_49_0_0_28_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_28_2_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 48)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_28_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 48);
		putValue(this, 48);
	}
	P_ASG_49_0_0_28_BuildFct();
}


on envVar P_ASG_49_0_0_28_2 // AnnouncementInfo.StationName
{
	putValue(P_ASG_49_0_0_28_2_len, getValueSize(this));
	P_ASG_49_0_0_28_BuildFct();
}

on envVar M_ASG_49_0_0_29AbortResult_BTN
{
    if (M_ASG_49_0_0_29AbortResult_BTN_already_pressed == 0)
    {
         putValue(M_ASG_49_0_0_29_ErrCode,0);
         SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_29",MakeRGB(255,255,255));
         M_ASG_49_0_0_29AbortResult_BTN_already_pressed = 1;
    }
    else
    {
         putValue(M_ASG_49_0_0_29_State, "AbortResult");
         Request_Void(LSGID, M_ASG_49_0_0_29_ID, AbortResult_REQ);
         M_ASG_49_0_0_29AbortResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_29StartResult_BTN
{
    if (M_ASG_49_0_0_29StartResult_BTN_already_pressed == 0)
    {
        putValue(M_ASG_49_0_0_29_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_29",MakeRGB(255,255,255));
        M_ASG_49_0_0_29StartResult_BTN_already_pressed = 1;
    }
    else
    {
        Request_Void(LSGID, M_ASG_49_0_0_29_ID, StartResult_REQ);
        putValue(M_ASG_49_0_0_29_State, "Started");
        M_ASG_49_0_0_29StartResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_29_Result // bus value of AnnouncementEscape (29).
{
	// opcodes: Error-Processing-Result
	byte param1; // AnnouncementEscapeResult
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_29_Result);
	putValue(M_ASG_49_0_0_29_Result_1, param1);
}

on envVar M_ASG_49_0_0_29_Result_1 // AnnouncementEscape.AnnouncementEscapeResult
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // AnnouncementEscapeResult
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_ASG_49_0_0_29_Result);
	superval = thisval;
	putValue(M_ASG_49_0_0_29_Result,superval);
}

on envVar M_ASG_49_0_0_29_Processing // bus value of AnnouncementEscape (29).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_29_Processing);
	putValue(M_ASG_49_0_0_29_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_29_Processing_1_range // AnnouncementEscape.Reserve1 
{
	@M_ASG_49_0_0_29_Processing_1 = @M_ASG_49_0_0_29_Processing_1_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_29_Processing_1 // AnnouncementEscape.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_ASG_49_0_0_29_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_ASG_49_0_0_29_Processing);
	superval = thisval;
	putValue(M_ASG_49_0_0_29_Processing,superval);
}

on envVar P_ASG_49_0_0_30Get_BTN
{
 if (P_ASG_49_0_0_30Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_30_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_30",MakeRGB(255,255,255));
       P_ASG_49_0_0_30Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_30_ID, DataGet_REQ); 
       P_ASG_49_0_0_30Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_30 // bus value of InfoStates (30).
{
	// opcodes: Error-Status
	byte param1; // States
	// DATATYPE_UINTXX
	param1 = getValue(P_ASG_49_0_0_30);
	putValue(P_ASG_49_0_0_30_1, param1);
}

on envVar P_ASG_49_0_0_30_1 // InfoStates.States
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // States
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_ASG_49_0_0_30);
	superval = thisval;
	putValue(P_ASG_49_0_0_30,superval);
}

on envVar P_ASG_49_0_0_31Get_BTN
{
 if (P_ASG_49_0_0_31Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_31_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_31",MakeRGB(255,255,255));
       P_ASG_49_0_0_31Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_31_ID, DataGet_REQ); 
       P_ASG_49_0_0_31Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_31 // bus value of ReceptionListType (31).
{
	// opcodes: Error-Status
	byte param1; // Type
	// DATATYPE_UINTXX
	param1 = getValue(P_ASG_49_0_0_31);
	putValue(P_ASG_49_0_0_31_1, param1);
}

on envVar P_ASG_49_0_0_31_1 // ReceptionListType.Type
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // Type
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_ASG_49_0_0_31);
	superval = thisval;
	putValue(P_ASG_49_0_0_31,superval);
}

on envVar A_ASG_49_0_0_32Get_BTN
{
  byte data[6]; 
  byte stringValue[6];
  byte head[5];
  int i;
  int headLength;
  long tempValue;
  word currentPos;
  word startVal;
  word elementsVal;
  byte nibbleSetted;
  if (A_ASG_49_0_0_32Get_BTN_already_pressed == 0)
  {
     putValue(A_ASG_49_0_0_32_ErrCode,0);
     SetControlBackColor(panel_name,"errField_A_ASG_49_0_0_32",MakeRGB(255,255,255));
     A_ASG_49_0_0_32Get_BTN_already_pressed = 1;
  }
  else
  {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_ASG_49_0_0_32_1_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_ASG_49_0_0_32_2_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //head Parameter
        headLength = getValueSize(A_ASG_49_0_0_32_SetGet);
        getValue(A_ASG_49_0_0_32_SetGet,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }

     Request_ByteSequence(LSGID, A_ASG_49_0_0_32_ID, DataGet_REQ, data, currentPos);
     if(getValue(A_ASG_49_0_0_32_IntTlgEn)) //getValue(IT))
     {
       intertelegram_err(A_ASG_49_0_0_32_ID);
     }
     if(getValue(A_ASG_49_0_0_32_SegmEn))   //getvalue(SG)
     {
         sequence_err(A_ASG_49_0_0_32_ID,getValueSize(A_ASG_49_0_0_32_SetGet));
     }
     A_ASG_49_0_0_32Get_BTN_already_pressed = 0;
  }
}
A_ASG_49_0_0_32_SetGet_GenerateSetGet()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_ASG_49_0_0_32_SetGet_RecAdr) > 0x0F)
        putValue(A_ASG_49_0_0_32_SetGet_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_ASG_49_0_0_32_SetGet_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_ASG_49_0_0_32_SetGet_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_ASG_49_0_0_32_SetGet_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // reserverd:  Byte 0 Bit 6
    if( getValue(A_ASG_49_0_0_32_SetGet_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_ASG_49_0_0_32_SetGet_Start) & 0xFF;
        head[2] = (getValue(A_ASG_49_0_0_32_SetGet_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_ASG_49_0_0_32_SetGet_Elements) & 0xFF;
        head[4] = (getValue(A_ASG_49_0_0_32_SetGet_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_ASG_49_0_0_32_SetGet, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_ASG_49_0_0_32_SetGet_Start) & 0xFF;
        head[2] = getValue(A_ASG_49_0_0_32_SetGet_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_ASG_49_0_0_32_SetGet, head, 3); 
    }
}

on envVar A_ASG_49_0_0_32_SetGet_RecAdr
{
    A_ASG_49_0_0_32_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_32_SetGet_Shift
{
    A_ASG_49_0_0_32_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_32_SetGet_Direction
{
    A_ASG_49_0_0_32_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_32_SetGet_Start
{
    A_ASG_49_0_0_32_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_32_SetGet_Elements
{
    A_ASG_49_0_0_32_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_32_SetGet_IndexSize
{
    A_ASG_49_0_0_32_SetGet_GenerateSetGet();
}
on envVar A_ASG_49_0_0_32
{
    byte temp[6];
    byte head[5];
    getValue(A_ASG_49_0_0_32, head);
    putValue(A_ASG_49_0_0_32_RecAdr, 0x0F & head[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & head[0]) >0)
        putValue(A_ASG_49_0_0_32_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & head[0]) >0)
        putValue(A_ASG_49_0_0_32_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & head[0]) >0)
        putValue(A_ASG_49_0_0_32_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & head[0]) >0)
        putValue(A_ASG_49_0_0_32_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_32_IndexSize))
    {
        putValue(A_ASG_49_0_0_32_Start, ((head[2]<<8)| head[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_32_Elements, ((head[4]<<8)| head[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_32_Start, head[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_32_Elements, head[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_32_Changed
{
    byte temp[276];
    getValue(A_ASG_49_0_0_32_Changed, temp);
    putValue(A_ASG_49_0_0_32_Changed_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_32_Changed_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_Changed_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_32_Changed_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_Changed_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_ASG_49_0_0_32_Changed_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_Changed_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_32_Changed_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_Changed_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_32_Changed_IndexSize))
    {
        putValue(A_ASG_49_0_0_32_Changed_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_32_Changed_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_32_Changed_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_32_Changed_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_32_SetGet
{
    byte temp[6];
    getValue(A_ASG_49_0_0_32_SetGet, temp);
    putValue(A_ASG_49_0_0_32_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_32_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_32_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_32_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_32_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_32_SetGet_IndexSize))
    {
        putValue(A_ASG_49_0_0_32_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_32_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_32_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_32_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_ASG_49_0_0_32_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_ASG_49_0_0_32_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_ASG_49_0_0_32_ArrayDataList[i].Param1 = 0;
		A_ASG_49_0_0_32_ArrayDataList[i].Param2 = 0;
		A_ASG_49_0_0_32_ArrayDataList[i].Param3 = 0;
		A_ASG_49_0_0_32_ArrayDataList[i].Param4 = 0;
		A_ASG_49_0_0_32_ArrayDataList[i].Param5 = 0;
		for(j=0; j<61; j++)
			A_ASG_49_0_0_32_ArrayDataList[i].Param6[j] = 0;
		A_ASG_49_0_0_32_ArrayDataList[i].Param6_Length = 0;
		A_ASG_49_0_0_32_Data_6_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_ASG_49_0_0_32_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 65536) //ignore first line in *.csv file
					{
						A_ASG_49_0_0_32_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_ASG_49_0_0_32_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //SourceType
						A_ASG_49_0_0_32_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //Instance_ID
						A_ASG_49_0_0_32_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //MediaType
						A_ASG_49_0_0_32_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //Attributes
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 65536)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //SourceType
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Instance_ID
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //MediaType
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Attributes
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //Name
								if(paramPos < 60)
								{
									A_ASG_49_0_0_32_ArrayDataList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_32_ArrayDataList[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_ASG_49_0_0_32_loadArray_Btn
{
	char filePath[255];
	if (A_ASG_49_0_0_32_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_32_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_ASG_49_0_0_32_generateData_Btn_already_pressed = 0;
		getValue(A_ASG_49_0_0_32_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_ASG_49_0_0_32_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_ASG_49_0_0_32_Data_1, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_32_Data_2, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_32_Data_3, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_32_Data_4, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_32_Data_5, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param5);
	putValue(A_ASG_49_0_0_32_Data_6, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param6, A_ASG_49_0_0_32_ArrayDataList[getValue(A_ASG_49_0_0_32_DataIndex)].Param6_Length);
}


on envVar A_ASG_49_0_0_32_generateData_Btn
{
	word i;
	dword elementsArray[7] = {2, 1, 1, 1, 1, 61, 2};
	byte elementsTypeArray[7] = {0, 0, 0, 0, 0, 0xE, 0xF};
	dword elementsMaxSizeArray[7] = {65535, 0xFF, 255, 0xFF, 0xFF, 0, 0};
	byte tempArray[4521915];
	if (A_ASG_49_0_0_32_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_32_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 32, 65535 );
		for(i = 0; i < 65535; i++)
		{
			memcpy(A_ASG_49_0_0_32_ArrayDataList[i], tempArray, (i * 69) );
			if(A_ASG_49_0_0_32_ArrayDataList[i].Param6_Length > 127 )
				A_ASG_49_0_0_32_Data_6_CntList[i] = 1;
		}
		A_ASG_49_0_0_32_generateData_Btn_already_pressed = 0;
	}
	putValue(A_ASG_49_0_0_32_Data_1, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_32_Data_2, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_32_Data_3, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_32_Data_4, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_32_Data_5, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param5);
	putValue(A_ASG_49_0_0_32_Data_6, A_ASG_49_0_0_32_ArrayDataList[ getValue( A_ASG_49_0_0_32_DataIndex) ].Param6, A_ASG_49_0_0_32_ArrayDataList[getValue(A_ASG_49_0_0_32_DataIndex)].Param6_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_ASG_49_0_0_32_DataIndex
{
    long index;
    long maxIndex = 65535-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_ASG_49_0_0_32_Data_1, A_ASG_49_0_0_32_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_32_Data_2, A_ASG_49_0_0_32_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_32_Data_3, A_ASG_49_0_0_32_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_32_Data_4, A_ASG_49_0_0_32_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_32_Data_5, A_ASG_49_0_0_32_ArrayDataList[index].Param5);
    putValue(A_ASG_49_0_0_32_Data_6_len, A_ASG_49_0_0_32_Data_6_LenList[index]);
    putValue(A_ASG_49_0_0_32_Data_6_cnt, A_ASG_49_0_0_32_Data_6_CntList[index]);
    putValue(A_ASG_49_0_0_32_Data_6, A_ASG_49_0_0_32_ArrayDataList[index].Param6, A_ASG_49_0_0_32_ArrayDataList[index].Param6_Length);

}
on envVar A_ASG_49_0_0_32_DataIndex_Incr
{
    long index;
    if(A_ASG_49_0_0_32_DataIndex_Incr_already_pressed == 0)
    {
        A_ASG_49_0_0_32_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_32_DataIndex);
        index++;
        putValue(A_ASG_49_0_0_32_DataIndex, index);
        A_ASG_49_0_0_32_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_ASG_49_0_0_32_DataIndex_Decr
{
    long index;
    if(A_ASG_49_0_0_32_DataIndex_Decr_already_pressed == 0)
    {
        A_ASG_49_0_0_32_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_32_DataIndex);
        index--;
        putValue(A_ASG_49_0_0_32_DataIndex, index);
        A_ASG_49_0_0_32_DataIndex_Decr_already_pressed = 0;
    }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_32_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_32_SegmEn,0);
           intertelegram_err(A_ASG_49_0_0_32_ID);
       }
       else
       {
           intertelegram_err_off(A_ASG_49_0_0_32_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_32_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_32_IntTlgEn,0);
           sequence_err(A_ASG_49_0_0_32_ID,getValueSize(A_ASG_49_0_0_32_SegmEn));
       }
       else
       {
              sequence_err_off(A_ASG_49_0_0_32_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_ASG_49_0_0_32_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_ASG_49_0_0_32_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_ASG_49_0_0_32_Status",1);
 	}
}

A_ASG_49_0_0_32_DataInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[276];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_32_1, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_32_2, tempValue);
    //Einzelparameter: TotalNumListElements
    //voriger Parameter war ein first nibble, bei 2 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue =  (gBAP_Indication_data[currentPos++] & 0xFF);
    tempValue += (gBAP_Indication_data[currentPos++] & 0xFF) << 8;
    putValue(A_ASG_49_0_0_32_3, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_32, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_32, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_32_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 32");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_32_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_32_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_32_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_32_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 4 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_32_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_32_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_32_Data_6_CntList[i] = 1;
            A_ASG_49_0_0_32_ArrayDataList[i].Param6_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_32_Data_6_CntList[i] = 0;
            A_ASG_49_0_0_32_ArrayDataList[i].Param6_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_32_ArrayDataList[i].Param6_Length; j++)
        {
            A_ASG_49_0_0_32_ArrayDataList[i].Param6[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_32_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_32_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 32");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_32_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_32_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_32_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_32_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 4 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_32_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_32_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_32_Data_6_CntList[i] = 1;
            A_ASG_49_0_0_32_ArrayDataList[i].Param6_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_32_Data_6_CntList[i] = 0;
            A_ASG_49_0_0_32_ArrayDataList[i].Param6_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_32_ArrayDataList[i].Param6_Length; j++)
        {
            A_ASG_49_0_0_32_ArrayDataList[i].Param6[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_32_DataIndex);
    putValue(A_ASG_49_0_0_32_Data_1, A_ASG_49_0_0_32_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_32_Data_2, A_ASG_49_0_0_32_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_32_Data_3, A_ASG_49_0_0_32_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_32_Data_4, A_ASG_49_0_0_32_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_32_Data_5, A_ASG_49_0_0_32_ArrayDataList[index].Param5);
    putValue(A_ASG_49_0_0_32_Data_6_len, A_ASG_49_0_0_32_Data_6_LenList[index]);
    putValue(A_ASG_49_0_0_32_Data_6_cnt, A_ASG_49_0_0_32_Data_6_CntList[index]);
    putValue(A_ASG_49_0_0_32_Data_6, A_ASG_49_0_0_32_ArrayDataList[index].Param6, A_ASG_49_0_0_32_ArrayDataList[index].Param6_Length);
}

A_ASG_49_0_0_32_ChangedInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[276];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_32_Changed, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_32_Changed, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_32_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 32");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_32_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_32_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 32");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_32_DataIndex);
}




on envVar A_ASG_49_0_0_32_1
{
	byte superval[276];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_32_2_range // SourceList.TAID 
{
	@A_ASG_49_0_0_32_2 = @A_ASG_49_0_0_32_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_32_2
{
	byte superval[276];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_32_2, 1.0);
	@A_ASG_49_0_0_32_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_32_3_range // SourceList.TotalNumListElements 
{
	@A_ASG_49_0_0_32_3 = @A_ASG_49_0_0_32_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_32_3
{
	byte superval[276];

	//Update Childvalue (Number)
	word thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_32_3, 1.0);
	@A_ASG_49_0_0_32_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_32_Data_1_range // SourceList.Pos 
{
	@A_ASG_49_0_0_32_Data_1 = @A_ASG_49_0_0_32_Data_1_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_32_Data_1
{
	byte superval[276];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_32_Data_1, 1.0);
	@A_ASG_49_0_0_32_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_32_ArrayDataList[getValue(A_ASG_49_0_0_32_DataIndex)].Param1 = thisval;
}
on envVar A_ASG_49_0_0_32_Data_2
{
	byte superval[276];

	//Update Childvalue (Enum)
	byte thisval; // SourceType
	thisval = getValue(this);
    A_ASG_49_0_0_32_ArrayDataList[getValue(A_ASG_49_0_0_32_DataIndex)].Param2 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_32_Data_3_range // SourceList.Instance_ID 
{
	@A_ASG_49_0_0_32_Data_3 = @A_ASG_49_0_0_32_Data_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_32_Data_3
{
	byte superval[276];

	//Update Childvalue (Number)
	byte thisval; // Instance_ID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_32_Data_3, 1.0);
	@A_ASG_49_0_0_32_Data_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_32_ArrayDataList[getValue(A_ASG_49_0_0_32_DataIndex)].Param3 = thisval;
}
on envVar A_ASG_49_0_0_32_Data_4
{
	byte superval[276];

	//Update Childvalue (Enum)
	byte thisval; // MediaType
	thisval = getValue(this);
    A_ASG_49_0_0_32_ArrayDataList[getValue(A_ASG_49_0_0_32_DataIndex)].Param4 = thisval;
}
on envVar A_ASG_49_0_0_32_Data_5_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_32_Data_5);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_ASG_49_0_0_32_Data_5,thisval);
}

on envVar A_ASG_49_0_0_32_Data_5_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_32_Data_5);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_ASG_49_0_0_32_Data_5,thisval);
}

on envVar A_ASG_49_0_0_32_Data_5_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_32_Data_5);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(A_ASG_49_0_0_32_Data_5,thisval);
}

on envVar A_ASG_49_0_0_32_Data_5_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_32_Data_5);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(A_ASG_49_0_0_32_Data_5,thisval);
}

on envVar A_ASG_49_0_0_32_Data_5_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_32_Data_5);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(A_ASG_49_0_0_32_Data_5,thisval);
}

on envVar A_ASG_49_0_0_32_Data_5_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_32_Data_5);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(A_ASG_49_0_0_32_Data_5,thisval);
}

on envVar A_ASG_49_0_0_32_Data_5_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_32_Data_5);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(A_ASG_49_0_0_32_Data_5,thisval);
}

on envVar A_ASG_49_0_0_32_Data_5
{
	byte superval[276];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Attributes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_ASG_49_0_0_32_Data_5_0, 1);
	else
		putValue(A_ASG_49_0_0_32_Data_5_0, 0);
	if(thisval&(mask<<1))
		putValue(A_ASG_49_0_0_32_Data_5_1, 1);
	else
		putValue(A_ASG_49_0_0_32_Data_5_1, 0);
	if(thisval&(mask<<2))
		putValue(A_ASG_49_0_0_32_Data_5_2, 1);
	else
		putValue(A_ASG_49_0_0_32_Data_5_2, 0);
	if(thisval&(mask<<3))
		putValue(A_ASG_49_0_0_32_Data_5_3, 1);
	else
		putValue(A_ASG_49_0_0_32_Data_5_3, 0);
	if(thisval&(mask<<4))
		putValue(A_ASG_49_0_0_32_Data_5_4, 1);
	else
		putValue(A_ASG_49_0_0_32_Data_5_4, 0);
	if(thisval&(mask<<5))
		putValue(A_ASG_49_0_0_32_Data_5_5, 1);
	else
		putValue(A_ASG_49_0_0_32_Data_5_5, 0);
	if(thisval&(mask<<6))
		putValue(A_ASG_49_0_0_32_Data_5_6, 1);
	else
		putValue(A_ASG_49_0_0_32_Data_5_6, 0);
    A_ASG_49_0_0_32_ArrayDataList[getValue(A_ASG_49_0_0_32_DataIndex)].Param5 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_32_Data_6_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_32_Data_6_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_32_Data_6_CntList[ getValue(A_ASG_49_0_0_32_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_32_Data_6_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_32_Data_6_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_32_Data_6_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_32_Data_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_32_Data_6_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_32_ArrayDataList[getValue(A_ASG_49_0_0_32_DataIndex)].Param6_Length = thisval;
	A_ASG_49_0_0_32_Data_6_LenList[ getValue(A_ASG_49_0_0_32_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_32_Data_6_len, thisval);

}

on envVar A_ASG_49_0_0_32_Data_6
{
	byte superval[276];

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_32_ArrayDataList[getValue(A_ASG_49_0_0_32_DataIndex)].Param6[i] = thisval[i];
    A_ASG_49_0_0_32_ArrayDataList[getValue(A_ASG_49_0_0_32_DataIndex)].Param6_Length = getValueSize(this);
    A_ASG_49_0_0_32_Data_6_LenList[getValue(A_ASG_49_0_0_32_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_32_Data_6_len, getValueSize(this));
}
on envVar A_ASG_49_0_0_32_1_SetGet
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_32_2_SetGet_range // SourceList.TAID 
{
	@A_ASG_49_0_0_32_2_SetGet = @A_ASG_49_0_0_32_2_SetGet_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_32_2_SetGet
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_32_2_SetGet, 1.0);
	@A_ASG_49_0_0_32_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_ASG_49_0_0_33Get_BTN
{
  byte data[5]; 
  byte stringValue[5];
  byte head[5];
  int i;
  int headLength;
  long tempValue;
  word currentPos;
  word startVal;
  word elementsVal;
  byte nibbleSetted;
  if (A_ASG_49_0_0_33Get_BTN_already_pressed == 0)
  {
     putValue(A_ASG_49_0_0_33_ErrCode,0);
     SetControlBackColor(panel_name,"errField_A_ASG_49_0_0_33",MakeRGB(255,255,255));
     A_ASG_49_0_0_33Get_BTN_already_pressed = 1;
  }
  else
  {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_ASG_49_0_0_33_1_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_ASG_49_0_0_33_2_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //head Parameter
        headLength = getValueSize(A_ASG_49_0_0_33_SetGet);
        getValue(A_ASG_49_0_0_33_SetGet,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }

     Request_ByteSequence(LSGID, A_ASG_49_0_0_33_ID, DataGet_REQ, data, currentPos);
     if(getValue(A_ASG_49_0_0_33_IntTlgEn)) //getValue(IT))
     {
       intertelegram_err(A_ASG_49_0_0_33_ID);
     }
     if(getValue(A_ASG_49_0_0_33_SegmEn))   //getvalue(SG)
     {
         sequence_err(A_ASG_49_0_0_33_ID,getValueSize(A_ASG_49_0_0_33_SetGet));
     }
     A_ASG_49_0_0_33Get_BTN_already_pressed = 0;
  }
}
A_ASG_49_0_0_33_SetGet_GenerateSetGet()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_ASG_49_0_0_33_SetGet_RecAdr) > 0x0F)
        putValue(A_ASG_49_0_0_33_SetGet_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_ASG_49_0_0_33_SetGet_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_ASG_49_0_0_33_SetGet_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_ASG_49_0_0_33_SetGet_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // reserverd:  Byte 0 Bit 6
    if( getValue(A_ASG_49_0_0_33_SetGet_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_ASG_49_0_0_33_SetGet_Start) & 0xFF;
        head[2] = (getValue(A_ASG_49_0_0_33_SetGet_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_ASG_49_0_0_33_SetGet_Elements) & 0xFF;
        head[4] = (getValue(A_ASG_49_0_0_33_SetGet_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_ASG_49_0_0_33_SetGet, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_ASG_49_0_0_33_SetGet_Start) & 0xFF;
        head[2] = getValue(A_ASG_49_0_0_33_SetGet_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_ASG_49_0_0_33_SetGet, head, 3); 
    }
}

on envVar A_ASG_49_0_0_33_SetGet_RecAdr
{
    A_ASG_49_0_0_33_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_33_SetGet_Shift
{
    A_ASG_49_0_0_33_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_33_SetGet_Direction
{
    A_ASG_49_0_0_33_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_33_SetGet_Start
{
    A_ASG_49_0_0_33_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_33_SetGet_Elements
{
    A_ASG_49_0_0_33_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_33_SetGet_IndexSize
{
    A_ASG_49_0_0_33_SetGet_GenerateSetGet();
}
on envVar A_ASG_49_0_0_33
{
    byte temp[5];
    byte head[5];
    getValue(A_ASG_49_0_0_33, head);
    putValue(A_ASG_49_0_0_33_RecAdr, 0x0F & head[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & head[0]) >0)
        putValue(A_ASG_49_0_0_33_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & head[0]) >0)
        putValue(A_ASG_49_0_0_33_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & head[0]) >0)
        putValue(A_ASG_49_0_0_33_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & head[0]) >0)
        putValue(A_ASG_49_0_0_33_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_33_IndexSize))
    {
        putValue(A_ASG_49_0_0_33_Start, ((head[2]<<8)| head[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_33_Elements, ((head[4]<<8)| head[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_33_Start, head[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_33_Elements, head[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_33_Changed
{
    byte temp[221];
    getValue(A_ASG_49_0_0_33_Changed, temp);
    putValue(A_ASG_49_0_0_33_Changed_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_33_Changed_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_Changed_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_33_Changed_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_Changed_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_ASG_49_0_0_33_Changed_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_Changed_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_33_Changed_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_Changed_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_33_Changed_IndexSize))
    {
        putValue(A_ASG_49_0_0_33_Changed_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_33_Changed_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_33_Changed_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_33_Changed_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_33_SetGet
{
    byte temp[5];
    getValue(A_ASG_49_0_0_33_SetGet, temp);
    putValue(A_ASG_49_0_0_33_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_33_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_33_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_33_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_33_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_33_SetGet_IndexSize))
    {
        putValue(A_ASG_49_0_0_33_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_33_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_33_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_33_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_ASG_49_0_0_33_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_ASG_49_0_0_33_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_ASG_49_0_0_33_ArrayDataList[i].Param1 = 0;
		A_ASG_49_0_0_33_ArrayDataList[i].Param2 = 0;
		A_ASG_49_0_0_33_ArrayDataList[i].Param3 = 0;
		A_ASG_49_0_0_33_ArrayDataList[i].Param4 = 0;
		for(j=0; j<49; j++)
			A_ASG_49_0_0_33_ArrayDataList[i].Param5[j] = 0;
		A_ASG_49_0_0_33_ArrayDataList[i].Param5_Length = 0;
		A_ASG_49_0_0_33_Data_5_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_ASG_49_0_0_33_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
					{
						A_ASG_49_0_0_33_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_ASG_49_0_0_33_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //PresetIndex
						A_ASG_49_0_0_33_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //Waveband
						A_ASG_49_0_0_33_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //Attributes
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 256)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PresetIndex
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Waveband
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //Attributes
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Name
								if(paramPos < 48)
								{
									A_ASG_49_0_0_33_ArrayDataList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_33_ArrayDataList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_ASG_49_0_0_33_loadArray_Btn
{
	char filePath[255];
	if (A_ASG_49_0_0_33_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_33_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_ASG_49_0_0_33_generateData_Btn_already_pressed = 0;
		getValue(A_ASG_49_0_0_33_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_ASG_49_0_0_33_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_ASG_49_0_0_33_Data_1, A_ASG_49_0_0_33_ArrayDataList[ getValue( A_ASG_49_0_0_33_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_33_Data_2, A_ASG_49_0_0_33_ArrayDataList[ getValue( A_ASG_49_0_0_33_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_33_Data_3, A_ASG_49_0_0_33_ArrayDataList[ getValue( A_ASG_49_0_0_33_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_33_Data_4, A_ASG_49_0_0_33_ArrayDataList[ getValue( A_ASG_49_0_0_33_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_33_Data_5, A_ASG_49_0_0_33_ArrayDataList[ getValue( A_ASG_49_0_0_33_DataIndex) ].Param5, A_ASG_49_0_0_33_ArrayDataList[getValue(A_ASG_49_0_0_33_DataIndex)].Param5_Length);
}


on envVar A_ASG_49_0_0_33_generateData_Btn
{
	word i;
	dword elementsArray[6] = {1, 1, 1, 2, 49, 2};
	byte elementsTypeArray[6] = {0, 0, 0, 0, 0xE, 0xF};
	dword elementsMaxSizeArray[6] = {255, 255, 0xFF, 0xFFFF, 0, 0};
	byte tempArray[14280];
	if (A_ASG_49_0_0_33_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_33_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 33, 255 );
		for(i = 0; i < 255; i++)
		{
			memcpy(A_ASG_49_0_0_33_ArrayDataList[i], tempArray, (i * 56) );
			if(A_ASG_49_0_0_33_ArrayDataList[i].Param5_Length > 127 )
				A_ASG_49_0_0_33_Data_5_CntList[i] = 1;
		}
		A_ASG_49_0_0_33_generateData_Btn_already_pressed = 0;
	}
	putValue(A_ASG_49_0_0_33_Data_1, A_ASG_49_0_0_33_ArrayDataList[ getValue( A_ASG_49_0_0_33_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_33_Data_2, A_ASG_49_0_0_33_ArrayDataList[ getValue( A_ASG_49_0_0_33_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_33_Data_3, A_ASG_49_0_0_33_ArrayDataList[ getValue( A_ASG_49_0_0_33_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_33_Data_4, A_ASG_49_0_0_33_ArrayDataList[ getValue( A_ASG_49_0_0_33_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_33_Data_5, A_ASG_49_0_0_33_ArrayDataList[ getValue( A_ASG_49_0_0_33_DataIndex) ].Param5, A_ASG_49_0_0_33_ArrayDataList[getValue(A_ASG_49_0_0_33_DataIndex)].Param5_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_ASG_49_0_0_33_DataIndex
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_ASG_49_0_0_33_Data_1, A_ASG_49_0_0_33_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_33_Data_2, A_ASG_49_0_0_33_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_33_Data_3, A_ASG_49_0_0_33_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_33_Data_4, A_ASG_49_0_0_33_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_33_Data_5_len, A_ASG_49_0_0_33_Data_5_LenList[index]);
    putValue(A_ASG_49_0_0_33_Data_5_cnt, A_ASG_49_0_0_33_Data_5_CntList[index]);
    putValue(A_ASG_49_0_0_33_Data_5, A_ASG_49_0_0_33_ArrayDataList[index].Param5, A_ASG_49_0_0_33_ArrayDataList[index].Param5_Length);

}
on envVar A_ASG_49_0_0_33_DataIndex_Incr
{
    long index;
    if(A_ASG_49_0_0_33_DataIndex_Incr_already_pressed == 0)
    {
        A_ASG_49_0_0_33_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_33_DataIndex);
        index++;
        putValue(A_ASG_49_0_0_33_DataIndex, index);
        A_ASG_49_0_0_33_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_ASG_49_0_0_33_DataIndex_Decr
{
    long index;
    if(A_ASG_49_0_0_33_DataIndex_Decr_already_pressed == 0)
    {
        A_ASG_49_0_0_33_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_33_DataIndex);
        index--;
        putValue(A_ASG_49_0_0_33_DataIndex, index);
        A_ASG_49_0_0_33_DataIndex_Decr_already_pressed = 0;
    }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_33_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_33_SegmEn,0);
           intertelegram_err(A_ASG_49_0_0_33_ID);
       }
       else
       {
           intertelegram_err_off(A_ASG_49_0_0_33_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_33_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_33_IntTlgEn,0);
           sequence_err(A_ASG_49_0_0_33_ID,getValueSize(A_ASG_49_0_0_33_SegmEn));
       }
       else
       {
              sequence_err_off(A_ASG_49_0_0_33_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_ASG_49_0_0_33_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_ASG_49_0_0_33_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_ASG_49_0_0_33_Status",1);
 	}
}

A_ASG_49_0_0_33_DataInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[221];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_33_1, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_33_2, tempValue);
    //Einzelparameter: TotalNumListElements
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_ASG_49_0_0_33_3, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_33, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_33, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_33_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 33");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_33_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_33_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_33_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_33_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_33_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_33_Data_5_CntList[i] = 1;
            A_ASG_49_0_0_33_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_33_Data_5_CntList[i] = 0;
            A_ASG_49_0_0_33_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_33_ArrayDataList[i].Param5_Length; j++)
        {
            A_ASG_49_0_0_33_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_33_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_33_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 33");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_33_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_33_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_33_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_33_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_33_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_33_Data_5_CntList[i] = 1;
            A_ASG_49_0_0_33_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_33_Data_5_CntList[i] = 0;
            A_ASG_49_0_0_33_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_33_ArrayDataList[i].Param5_Length; j++)
        {
            A_ASG_49_0_0_33_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_33_DataIndex);
    putValue(A_ASG_49_0_0_33_Data_1, A_ASG_49_0_0_33_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_33_Data_2, A_ASG_49_0_0_33_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_33_Data_3, A_ASG_49_0_0_33_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_33_Data_4, A_ASG_49_0_0_33_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_33_Data_5_len, A_ASG_49_0_0_33_Data_5_LenList[index]);
    putValue(A_ASG_49_0_0_33_Data_5_cnt, A_ASG_49_0_0_33_Data_5_CntList[index]);
    putValue(A_ASG_49_0_0_33_Data_5, A_ASG_49_0_0_33_ArrayDataList[index].Param5, A_ASG_49_0_0_33_ArrayDataList[index].Param5_Length);
}

A_ASG_49_0_0_33_ChangedInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[221];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_33_Changed, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_33_Changed, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_33_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 33");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_33_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_33_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 33");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_33_DataIndex);
}




on envVar A_ASG_49_0_0_33_1
{
	byte superval[221];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_33_2_range // RadioTV_PresetList.TAID 
{
	@A_ASG_49_0_0_33_2 = @A_ASG_49_0_0_33_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_33_2
{
	byte superval[221];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_33_2, 1.0);
	@A_ASG_49_0_0_33_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_33_3_range // RadioTV_PresetList.TotalNumListElements 
{
	@A_ASG_49_0_0_33_3 = @A_ASG_49_0_0_33_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_33_3
{
	byte superval[221];

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_33_3, 1.0);
	@A_ASG_49_0_0_33_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_33_Data_1_range // RadioTV_PresetList.Pos 
{
	@A_ASG_49_0_0_33_Data_1 = @A_ASG_49_0_0_33_Data_1_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_33_Data_1
{
	byte superval[221];

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_33_Data_1, 1.0);
	@A_ASG_49_0_0_33_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_33_ArrayDataList[getValue(A_ASG_49_0_0_33_DataIndex)].Param1 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_33_Data_2_range // RadioTV_PresetList.PresetIndex 
{
	@A_ASG_49_0_0_33_Data_2 = @A_ASG_49_0_0_33_Data_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_33_Data_2
{
	byte superval[221];

	//Update Childvalue (Number)
	byte thisval; // PresetIndex
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_33_Data_2, 1.0);
	@A_ASG_49_0_0_33_Data_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_33_ArrayDataList[getValue(A_ASG_49_0_0_33_DataIndex)].Param2 = thisval;
}
on envVar A_ASG_49_0_0_33_Data_3
{
	byte superval[221];

	//Update Childvalue (Enum)
	byte thisval; // Waveband
	thisval = getValue(this);
    A_ASG_49_0_0_33_ArrayDataList[getValue(A_ASG_49_0_0_33_DataIndex)].Param3 = thisval;
}
on envVar A_ASG_49_0_0_33_Data_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4_8
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<8)|(bitval<<8);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4_9
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<9)|(bitval<<9);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4_10
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_33_Data_4);
	thisval = thisval&~(1<<10)|(bitval<<10);
	putValue(A_ASG_49_0_0_33_Data_4,thisval);
}

on envVar A_ASG_49_0_0_33_Data_4
{
	byte superval[221];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	word thisval; // Attributes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_ASG_49_0_0_33_Data_4_0, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_0, 0);
	if(thisval&(mask<<1))
		putValue(A_ASG_49_0_0_33_Data_4_1, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_1, 0);
	if(thisval&(mask<<2))
		putValue(A_ASG_49_0_0_33_Data_4_2, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_2, 0);
	if(thisval&(mask<<3))
		putValue(A_ASG_49_0_0_33_Data_4_3, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_3, 0);
	if(thisval&(mask<<4))
		putValue(A_ASG_49_0_0_33_Data_4_4, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_4, 0);
	if(thisval&(mask<<5))
		putValue(A_ASG_49_0_0_33_Data_4_5, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_5, 0);
	if(thisval&(mask<<6))
		putValue(A_ASG_49_0_0_33_Data_4_6, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_6, 0);
	if(thisval&(mask<<7))
		putValue(A_ASG_49_0_0_33_Data_4_7, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_7, 0);
	if(thisval&(mask<<8))
		putValue(A_ASG_49_0_0_33_Data_4_8, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_8, 0);
	if(thisval&(mask<<9))
		putValue(A_ASG_49_0_0_33_Data_4_9, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_9, 0);
	if(thisval&(mask<<10))
		putValue(A_ASG_49_0_0_33_Data_4_10, 1);
	else
		putValue(A_ASG_49_0_0_33_Data_4_10, 0);
    A_ASG_49_0_0_33_ArrayDataList[getValue(A_ASG_49_0_0_33_DataIndex)].Param4 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_33_Data_5_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_33_Data_5_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_33_Data_5_CntList[ getValue(A_ASG_49_0_0_33_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_33_Data_5_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_33_Data_5_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_33_Data_5_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 48 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_33_Data_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 48);
		thisval = 48;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_33_Data_5_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_33_ArrayDataList[getValue(A_ASG_49_0_0_33_DataIndex)].Param5_Length = thisval;
	A_ASG_49_0_0_33_Data_5_LenList[ getValue(A_ASG_49_0_0_33_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_33_Data_5_len, thisval);

}

on envVar A_ASG_49_0_0_33_Data_5
{
	byte superval[221];

	//Update Childvalue (String)
	word i;
	byte thisval[49];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_33_ArrayDataList[getValue(A_ASG_49_0_0_33_DataIndex)].Param5[i] = thisval[i];
    A_ASG_49_0_0_33_ArrayDataList[getValue(A_ASG_49_0_0_33_DataIndex)].Param5_Length = getValueSize(this);
    A_ASG_49_0_0_33_Data_5_LenList[getValue(A_ASG_49_0_0_33_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_33_Data_5_len, getValueSize(this));
}
on envVar A_ASG_49_0_0_33_1_SetGet
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_33_2_SetGet_range // RadioTV_PresetList.TAID 
{
	@A_ASG_49_0_0_33_2_SetGet = @A_ASG_49_0_0_33_2_SetGet_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_33_2_SetGet
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_33_2_SetGet, 1.0);
	@A_ASG_49_0_0_33_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar M_ASG_49_0_0_34AbortResult_BTN
{
    if (M_ASG_49_0_0_34AbortResult_BTN_already_pressed == 0)
    {
         putValue(M_ASG_49_0_0_34_ErrCode,0);
         SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_34",MakeRGB(255,255,255));
         M_ASG_49_0_0_34AbortResult_BTN_already_pressed = 1;
    }
    else
    {
         putValue(M_ASG_49_0_0_34_State, "AbortResult");
         Request_Void(LSGID, M_ASG_49_0_0_34_ID, AbortResult_REQ);
         M_ASG_49_0_0_34AbortResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_34StartResult_BTN
{
    if (M_ASG_49_0_0_34StartResult_BTN_already_pressed == 0)
    {
        putValue(M_ASG_49_0_0_34_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_34",MakeRGB(255,255,255));
        M_ASG_49_0_0_34StartResult_BTN_already_pressed = 1;
    }
    else
    {
        Request_Int16(LSGID, M_ASG_49_0_0_34_ID, StartResult_REQ, getValue(M_ASG_49_0_0_34_Start));
        putValue(M_ASG_49_0_0_34_State, "Started");
        M_ASG_49_0_0_34StartResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_34_Result // bus value of SwitchSource (34).
{
	// opcodes: Error-Processing-Result
	byte param1; // SwitchSourceResult
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_34_Result);
	putValue(M_ASG_49_0_0_34_Result_1, param1);
}

on envVar M_ASG_49_0_0_34_Result_1 // SwitchSource.SwitchSourceResult
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // SwitchSourceResult
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_ASG_49_0_0_34_Result);
	superval = thisval;
	putValue(M_ASG_49_0_0_34_Result,superval);
}

on envVar M_ASG_49_0_0_34_Processing // bus value of SwitchSource (34).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_34_Processing);
	putValue(M_ASG_49_0_0_34_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_34_Processing_1_range // SwitchSource.Reserve1 
{
	@M_ASG_49_0_0_34_Processing_1 = @M_ASG_49_0_0_34_Processing_1_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_34_Processing_1 // SwitchSource.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_ASG_49_0_0_34_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_ASG_49_0_0_34_Processing);
	superval = thisval;
	putValue(M_ASG_49_0_0_34_Processing,superval);
}

on envVar M_ASG_49_0_0_34_Start // bus value of SwitchSource (34).
{
	// opcodes: AbortResult-StartResult
	word param1; // SourceList_Reference
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_34_Start);
	putValue(M_ASG_49_0_0_34_Start_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_34_Start_1_range // SwitchSource.SourceList_Reference 
{
	@M_ASG_49_0_0_34_Start_1 = @M_ASG_49_0_0_34_Start_1_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_34_Start_1 // SwitchSource.SourceList_Reference
{
	word superval;

	//Update Childvalue (Number)
	word thisval; // SourceList_Reference
	float slider_value;

	slider_value = round(@M_ASG_49_0_0_34_Start_1, 1.0);
	@M_ASG_49_0_0_34_Start_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_ASG_49_0_0_34_Start);
	superval = thisval;
	putValue(M_ASG_49_0_0_34_Start,superval);
}

on envVar P_ASG_49_0_0_35Get_BTN
{
 if (P_ASG_49_0_0_35Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_35_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_35",MakeRGB(255,255,255));
       P_ASG_49_0_0_35Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_35_ID, DataGet_REQ); 
       P_ASG_49_0_0_35Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_35 // bus value of MediaBrowser_FolderLevel (35).
{
	// opcodes: Error-Status
	byte param1; // FolderLevel
	word param2; // Ref_MediaBrowser
	word param3; // Ref_MediaBrowser_absolutePosition
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[5];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_35, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_35_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_35_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_35_3, round((param3 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_35_1_range // MediaBrowser_FolderLevel.FolderLevel 
{
	@P_ASG_49_0_0_35_1 = @P_ASG_49_0_0_35_1_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_35_1 // MediaBrowser_FolderLevel.FolderLevel
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // FolderLevel
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_35_1, 1.0);
	@P_ASG_49_0_0_35_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_35, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_35,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_35_2_range // MediaBrowser_FolderLevel.Ref_MediaBrowser 
{
	@P_ASG_49_0_0_35_2 = @P_ASG_49_0_0_35_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_35_2 // MediaBrowser_FolderLevel.Ref_MediaBrowser
{
	byte superval[5];

	//Update Childvalue (Number)
	word thisval; // Ref_MediaBrowser
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_35_2, 1.0);
	@P_ASG_49_0_0_35_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_35, superval);
	superval[1]=thisval&0x00ff;
	superval[2]=(thisval&0xff00)>>8;
	putValue(P_ASG_49_0_0_35,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_35_3_range // MediaBrowser_FolderLevel.Ref_MediaBrowser_absolutePosition 
{
	@P_ASG_49_0_0_35_3 = @P_ASG_49_0_0_35_3_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_35_3 // MediaBrowser_FolderLevel.Ref_MediaBrowser_absolutePosition
{
	byte superval[5];

	//Update Childvalue (Number)
	word thisval; // Ref_MediaBrowser_absolutePosition
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_35_3, 1.0);
	@P_ASG_49_0_0_35_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_35, superval);
	superval[3]=thisval&0x00ff;
	superval[4]=(thisval&0xff00)>>8;
	putValue(P_ASG_49_0_0_35,superval);
}

on envVar A_ASG_49_0_0_36Get_BTN
{
  byte data[6]; 
  byte stringValue[6];
  byte head[5];
  int i;
  int headLength;
  long tempValue;
  word currentPos;
  word startVal;
  word elementsVal;
  byte nibbleSetted;
  if (A_ASG_49_0_0_36Get_BTN_already_pressed == 0)
  {
     putValue(A_ASG_49_0_0_36_ErrCode,0);
     SetControlBackColor(panel_name,"errField_A_ASG_49_0_0_36",MakeRGB(255,255,255));
     A_ASG_49_0_0_36Get_BTN_already_pressed = 1;
  }
  else
  {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_ASG_49_0_0_36_1_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_ASG_49_0_0_36_2_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //head Parameter
        headLength = getValueSize(A_ASG_49_0_0_36_SetGet);
        getValue(A_ASG_49_0_0_36_SetGet,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }

     Request_ByteSequence(LSGID, A_ASG_49_0_0_36_ID, DataGet_REQ, data, currentPos);
     if(getValue(A_ASG_49_0_0_36_IntTlgEn)) //getValue(IT))
     {
       intertelegram_err(A_ASG_49_0_0_36_ID);
     }
     if(getValue(A_ASG_49_0_0_36_SegmEn))   //getvalue(SG)
     {
         sequence_err(A_ASG_49_0_0_36_ID,getValueSize(A_ASG_49_0_0_36_SetGet));
     }
     A_ASG_49_0_0_36Get_BTN_already_pressed = 0;
  }
}
A_ASG_49_0_0_36_SetGet_GenerateSetGet()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_ASG_49_0_0_36_SetGet_RecAdr) > 0x0F)
        putValue(A_ASG_49_0_0_36_SetGet_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_ASG_49_0_0_36_SetGet_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_ASG_49_0_0_36_SetGet_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_ASG_49_0_0_36_SetGet_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // reserverd:  Byte 0 Bit 6
    if( getValue(A_ASG_49_0_0_36_SetGet_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_ASG_49_0_0_36_SetGet_Start) & 0xFF;
        head[2] = (getValue(A_ASG_49_0_0_36_SetGet_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_ASG_49_0_0_36_SetGet_Elements) & 0xFF;
        head[4] = (getValue(A_ASG_49_0_0_36_SetGet_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_ASG_49_0_0_36_SetGet, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_ASG_49_0_0_36_SetGet_Start) & 0xFF;
        head[2] = getValue(A_ASG_49_0_0_36_SetGet_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_ASG_49_0_0_36_SetGet, head, 3); 
    }
}

on envVar A_ASG_49_0_0_36_SetGet_RecAdr
{
    A_ASG_49_0_0_36_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_36_SetGet_Shift
{
    A_ASG_49_0_0_36_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_36_SetGet_Direction
{
    A_ASG_49_0_0_36_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_36_SetGet_Start
{
    A_ASG_49_0_0_36_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_36_SetGet_Elements
{
    A_ASG_49_0_0_36_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_36_SetGet_IndexSize
{
    A_ASG_49_0_0_36_SetGet_GenerateSetGet();
}
on envVar A_ASG_49_0_0_36
{
    byte temp[6];
    byte head[5];
    getValue(A_ASG_49_0_0_36, head);
    putValue(A_ASG_49_0_0_36_RecAdr, 0x0F & head[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & head[0]) >0)
        putValue(A_ASG_49_0_0_36_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & head[0]) >0)
        putValue(A_ASG_49_0_0_36_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & head[0]) >0)
        putValue(A_ASG_49_0_0_36_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & head[0]) >0)
        putValue(A_ASG_49_0_0_36_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_36_IndexSize))
    {
        putValue(A_ASG_49_0_0_36_Start, ((head[2]<<8)| head[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_36_Elements, ((head[4]<<8)| head[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_36_Start, head[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_36_Elements, head[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_36_Changed
{
    byte temp[418];
    getValue(A_ASG_49_0_0_36_Changed, temp);
    putValue(A_ASG_49_0_0_36_Changed_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_36_Changed_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_Changed_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_36_Changed_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_Changed_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_ASG_49_0_0_36_Changed_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_Changed_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_36_Changed_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_Changed_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_36_Changed_IndexSize))
    {
        putValue(A_ASG_49_0_0_36_Changed_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_36_Changed_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_36_Changed_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_36_Changed_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_36_SetGet
{
    byte temp[6];
    getValue(A_ASG_49_0_0_36_SetGet, temp);
    putValue(A_ASG_49_0_0_36_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_36_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_36_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_36_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_36_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_36_SetGet_IndexSize))
    {
        putValue(A_ASG_49_0_0_36_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_36_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_36_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_36_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_ASG_49_0_0_36_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_ASG_49_0_0_36_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_ASG_49_0_0_36_ArrayDataList[i].Param1 = 0;
		A_ASG_49_0_0_36_ArrayDataList[i].Param2 = 0;
		A_ASG_49_0_0_36_ArrayDataList[i].Param3 = 0;
		for(j=0; j<97; j++)
			A_ASG_49_0_0_36_ArrayDataList[i].Param4[j] = 0;
		A_ASG_49_0_0_36_ArrayDataList[i].Param4_Length = 0;
		A_ASG_49_0_0_36_Data_4_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_ASG_49_0_0_36_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 65536) //ignore first line in *.csv file
					{
						A_ASG_49_0_0_36_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_ASG_49_0_0_36_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //FileType
						A_ASG_49_0_0_36_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //FileState
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 65536)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //FileType
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //FileState
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //FileName
								if(paramPos < 96)
								{
									A_ASG_49_0_0_36_ArrayDataList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_36_ArrayDataList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_ASG_49_0_0_36_loadArray_Btn
{
	char filePath[255];
	if (A_ASG_49_0_0_36_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_36_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_ASG_49_0_0_36_generateData_Btn_already_pressed = 0;
		getValue(A_ASG_49_0_0_36_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_ASG_49_0_0_36_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_ASG_49_0_0_36_Data_1, A_ASG_49_0_0_36_ArrayDataList[ getValue( A_ASG_49_0_0_36_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_36_Data_2, A_ASG_49_0_0_36_ArrayDataList[ getValue( A_ASG_49_0_0_36_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_36_Data_3, A_ASG_49_0_0_36_ArrayDataList[ getValue( A_ASG_49_0_0_36_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_36_Data_4, A_ASG_49_0_0_36_ArrayDataList[ getValue( A_ASG_49_0_0_36_DataIndex) ].Param4, A_ASG_49_0_0_36_ArrayDataList[getValue(A_ASG_49_0_0_36_DataIndex)].Param4_Length);
}


on envVar A_ASG_49_0_0_36_generateData_Btn
{
	word i;
	dword elementsArray[5] = {2, 1, 2, 97, 2};
	byte elementsTypeArray[5] = {0, 0, 0, 0xE, 0xF};
	dword elementsMaxSizeArray[5] = {65535, 0xFF, 0xFFFF, 0, 0};
	byte tempArray[6815640];
	if (A_ASG_49_0_0_36_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_36_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 36, 65535 );
		for(i = 0; i < 65535; i++)
		{
			memcpy(A_ASG_49_0_0_36_ArrayDataList[i], tempArray, (i * 104) );
			if(A_ASG_49_0_0_36_ArrayDataList[i].Param4_Length > 127 )
				A_ASG_49_0_0_36_Data_4_CntList[i] = 1;
		}
		A_ASG_49_0_0_36_generateData_Btn_already_pressed = 0;
	}
	putValue(A_ASG_49_0_0_36_Data_1, A_ASG_49_0_0_36_ArrayDataList[ getValue( A_ASG_49_0_0_36_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_36_Data_2, A_ASG_49_0_0_36_ArrayDataList[ getValue( A_ASG_49_0_0_36_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_36_Data_3, A_ASG_49_0_0_36_ArrayDataList[ getValue( A_ASG_49_0_0_36_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_36_Data_4, A_ASG_49_0_0_36_ArrayDataList[ getValue( A_ASG_49_0_0_36_DataIndex) ].Param4, A_ASG_49_0_0_36_ArrayDataList[getValue(A_ASG_49_0_0_36_DataIndex)].Param4_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_ASG_49_0_0_36_DataIndex
{
    long index;
    long maxIndex = 65535-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_ASG_49_0_0_36_Data_1, A_ASG_49_0_0_36_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_36_Data_2, A_ASG_49_0_0_36_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_36_Data_3, A_ASG_49_0_0_36_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_36_Data_4_len, A_ASG_49_0_0_36_Data_4_LenList[index]);
    putValue(A_ASG_49_0_0_36_Data_4_cnt, A_ASG_49_0_0_36_Data_4_CntList[index]);
    putValue(A_ASG_49_0_0_36_Data_4, A_ASG_49_0_0_36_ArrayDataList[index].Param4, A_ASG_49_0_0_36_ArrayDataList[index].Param4_Length);

}
on envVar A_ASG_49_0_0_36_DataIndex_Incr
{
    long index;
    if(A_ASG_49_0_0_36_DataIndex_Incr_already_pressed == 0)
    {
        A_ASG_49_0_0_36_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_36_DataIndex);
        index++;
        putValue(A_ASG_49_0_0_36_DataIndex, index);
        A_ASG_49_0_0_36_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_ASG_49_0_0_36_DataIndex_Decr
{
    long index;
    if(A_ASG_49_0_0_36_DataIndex_Decr_already_pressed == 0)
    {
        A_ASG_49_0_0_36_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_36_DataIndex);
        index--;
        putValue(A_ASG_49_0_0_36_DataIndex, index);
        A_ASG_49_0_0_36_DataIndex_Decr_already_pressed = 0;
    }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_36_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_36_SegmEn,0);
           intertelegram_err(A_ASG_49_0_0_36_ID);
       }
       else
       {
           intertelegram_err_off(A_ASG_49_0_0_36_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_36_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_36_IntTlgEn,0);
           sequence_err(A_ASG_49_0_0_36_ID,getValueSize(A_ASG_49_0_0_36_SegmEn));
       }
       else
       {
              sequence_err_off(A_ASG_49_0_0_36_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_ASG_49_0_0_36_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_ASG_49_0_0_36_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_ASG_49_0_0_36_Status",1);
 	}
}

A_ASG_49_0_0_36_DataInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[418];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_36_1, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_36_2, tempValue);
    //Einzelparameter: TotalNumListElements
    //voriger Parameter war ein first nibble, bei 2 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue =  (gBAP_Indication_data[currentPos++] & 0xFF);
    tempValue += (gBAP_Indication_data[currentPos++] & 0xFF) << 8;
    putValue(A_ASG_49_0_0_36_3, tempValue);
    //Einzelparameter: ActiveListPos
    //voriger Parameter war ein first nibble, bei 2 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue =  (gBAP_Indication_data[currentPos++] & 0xFF);
    tempValue += (gBAP_Indication_data[currentPos++] & 0xFF) << 8;
    putValue(A_ASG_49_0_0_36_4, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_36, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_36, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_36_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 36");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_36_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_36_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_36_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_36_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_36_Data_4_CntList[i] = 1;
            A_ASG_49_0_0_36_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_36_Data_4_CntList[i] = 0;
            A_ASG_49_0_0_36_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_36_ArrayDataList[i].Param4_Length; j++)
        {
            A_ASG_49_0_0_36_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_36_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_36_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 36");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_36_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_36_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_36_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_36_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_36_Data_4_CntList[i] = 1;
            A_ASG_49_0_0_36_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_36_Data_4_CntList[i] = 0;
            A_ASG_49_0_0_36_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_36_ArrayDataList[i].Param4_Length; j++)
        {
            A_ASG_49_0_0_36_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_36_DataIndex);
    putValue(A_ASG_49_0_0_36_Data_1, A_ASG_49_0_0_36_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_36_Data_2, A_ASG_49_0_0_36_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_36_Data_3, A_ASG_49_0_0_36_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_36_Data_4_len, A_ASG_49_0_0_36_Data_4_LenList[index]);
    putValue(A_ASG_49_0_0_36_Data_4_cnt, A_ASG_49_0_0_36_Data_4_CntList[index]);
    putValue(A_ASG_49_0_0_36_Data_4, A_ASG_49_0_0_36_ArrayDataList[index].Param4, A_ASG_49_0_0_36_ArrayDataList[index].Param4_Length);
}

A_ASG_49_0_0_36_ChangedInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[418];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_36_Changed, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_36_Changed, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_36_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 36");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_36_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_36_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 36");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_36_DataIndex);
}




on envVar A_ASG_49_0_0_36_1
{
	byte superval[418];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_36_2_range // MediaBrowser.TAID 
{
	@A_ASG_49_0_0_36_2 = @A_ASG_49_0_0_36_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_36_2
{
	byte superval[418];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_36_2, 1.0);
	@A_ASG_49_0_0_36_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_36_3_range // MediaBrowser.TotalNumListElements 
{
	@A_ASG_49_0_0_36_3 = @A_ASG_49_0_0_36_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_36_3
{
	byte superval[418];

	//Update Childvalue (Number)
	word thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_36_3, 1.0);
	@A_ASG_49_0_0_36_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_36_4_range // MediaBrowser.ActiveListPos 
{
	@A_ASG_49_0_0_36_4 = @A_ASG_49_0_0_36_4_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_36_4
{
	byte superval[418];

	//Update Childvalue (Number)
	word thisval; // ActiveListPos
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_36_4, 1.0);
	@A_ASG_49_0_0_36_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_36_Data_1_range // MediaBrowser.Pos 
{
	@A_ASG_49_0_0_36_Data_1 = @A_ASG_49_0_0_36_Data_1_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_36_Data_1
{
	byte superval[418];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_36_Data_1, 1.0);
	@A_ASG_49_0_0_36_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_36_ArrayDataList[getValue(A_ASG_49_0_0_36_DataIndex)].Param1 = thisval;
}
on envVar A_ASG_49_0_0_36_Data_2
{
	byte superval[418];

	//Update Childvalue (Enum)
	byte thisval; // FileType
	thisval = getValue(this);
    A_ASG_49_0_0_36_ArrayDataList[getValue(A_ASG_49_0_0_36_DataIndex)].Param2 = thisval;
}
on envVar A_ASG_49_0_0_36_Data_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // FileState
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_36_Data_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_ASG_49_0_0_36_Data_3,thisval);
}

on envVar A_ASG_49_0_0_36_Data_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // FileState
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_36_Data_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_ASG_49_0_0_36_Data_3,thisval);
}

on envVar A_ASG_49_0_0_36_Data_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // FileState
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_36_Data_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(A_ASG_49_0_0_36_Data_3,thisval);
}

on envVar A_ASG_49_0_0_36_Data_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // FileState
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_36_Data_3);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(A_ASG_49_0_0_36_Data_3,thisval);
}

on envVar A_ASG_49_0_0_36_Data_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // FileState
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_36_Data_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(A_ASG_49_0_0_36_Data_3,thisval);
}

on envVar A_ASG_49_0_0_36_Data_3_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // FileState
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_36_Data_3);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(A_ASG_49_0_0_36_Data_3,thisval);
}

on envVar A_ASG_49_0_0_36_Data_3_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // FileState
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_36_Data_3);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(A_ASG_49_0_0_36_Data_3,thisval);
}

on envVar A_ASG_49_0_0_36_Data_3
{
	byte superval[418];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	word thisval; // FileState
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_ASG_49_0_0_36_Data_3_0, 1);
	else
		putValue(A_ASG_49_0_0_36_Data_3_0, 0);
	if(thisval&(mask<<1))
		putValue(A_ASG_49_0_0_36_Data_3_1, 1);
	else
		putValue(A_ASG_49_0_0_36_Data_3_1, 0);
	if(thisval&(mask<<2))
		putValue(A_ASG_49_0_0_36_Data_3_2, 1);
	else
		putValue(A_ASG_49_0_0_36_Data_3_2, 0);
	if(thisval&(mask<<3))
		putValue(A_ASG_49_0_0_36_Data_3_3, 1);
	else
		putValue(A_ASG_49_0_0_36_Data_3_3, 0);
	if(thisval&(mask<<4))
		putValue(A_ASG_49_0_0_36_Data_3_4, 1);
	else
		putValue(A_ASG_49_0_0_36_Data_3_4, 0);
	if(thisval&(mask<<5))
		putValue(A_ASG_49_0_0_36_Data_3_5, 1);
	else
		putValue(A_ASG_49_0_0_36_Data_3_5, 0);
	if(thisval&(mask<<6))
		putValue(A_ASG_49_0_0_36_Data_3_6, 1);
	else
		putValue(A_ASG_49_0_0_36_Data_3_6, 0);
    A_ASG_49_0_0_36_ArrayDataList[getValue(A_ASG_49_0_0_36_DataIndex)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_36_Data_4_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_36_Data_4_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_36_Data_4_CntList[ getValue(A_ASG_49_0_0_36_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_36_Data_4_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_36_Data_4_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_36_Data_4_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 96 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_36_Data_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 96);
		thisval = 96;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_36_Data_4_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_36_ArrayDataList[getValue(A_ASG_49_0_0_36_DataIndex)].Param4_Length = thisval;
	A_ASG_49_0_0_36_Data_4_LenList[ getValue(A_ASG_49_0_0_36_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_36_Data_4_len, thisval);

}

on envVar A_ASG_49_0_0_36_Data_4
{
	byte superval[418];

	//Update Childvalue (String)
	word i;
	byte thisval[97];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_36_ArrayDataList[getValue(A_ASG_49_0_0_36_DataIndex)].Param4[i] = thisval[i];
    A_ASG_49_0_0_36_ArrayDataList[getValue(A_ASG_49_0_0_36_DataIndex)].Param4_Length = getValueSize(this);
    A_ASG_49_0_0_36_Data_4_LenList[getValue(A_ASG_49_0_0_36_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_36_Data_4_len, getValueSize(this));
}
on envVar A_ASG_49_0_0_36_1_SetGet
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_36_2_SetGet_range // MediaBrowser.TAID 
{
	@A_ASG_49_0_0_36_2_SetGet = @A_ASG_49_0_0_36_2_SetGet_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_36_2_SetGet
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_36_2_SetGet, 1.0);
	@A_ASG_49_0_0_36_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar P_ASG_49_0_0_37Get_BTN
{
 if (P_ASG_49_0_0_37Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_37_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_37",MakeRGB(255,255,255));
       P_ASG_49_0_0_37Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_37_ID, DataGet_REQ); 
       P_ASG_49_0_0_37Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_37 // bus value of MediaPath (37).
{
	// opcodes: Error-Status
	byte param1; // Folder_Type
	byte param2[152]; // Path
	word len2;
	byte cnt2;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[153];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 153; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_37, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_37_1, param1);
	///////// Start param2 - STRING /////////
	getValue(P_ASG_49_0_0_37_2, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(150>127) /* Max Fct-Katalog Laenge: 150*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 150;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_37 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 150)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 150;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_37_2_len, len2);
	putValue(P_ASG_49_0_0_37_2_cnt, cnt2);
	
	if(len2 > getValueSize(P_ASG_49_0_0_37_2))
		putValue(P_ASG_49_0_0_37_2, param2, len2);
	else
		putValue(P_ASG_49_0_0_37_2, param2, getValueSize(P_ASG_49_0_0_37_2));

}

// Updates the bus value field and other dependencies.
P_ASG_49_0_0_37_BuildFct()
{
	byte param1; // Folder_Type
	byte param2[152]; // Path
	word len2;
	byte cnt2;

	int i;
	byte superval[153];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_ASG_49_0_0_37_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_37_2, param2);
	len2 = getValue(P_ASG_49_0_0_37_2_len);
	cnt2= getValue(P_ASG_49_0_0_37_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 150 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 150)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_37_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 150);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(P_ASG_49_0_0_37_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 150)
		{
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(P_ASG_49_0_0_37_2_len, len2);
			putValue(P_ASG_49_0_0_37_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_37_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 150);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

	putValue(P_ASG_49_0_0_37, superval, currentPos);
}


on envVar P_ASG_49_0_0_37_1 // MediaPath.Folder_Type
{
	P_ASG_49_0_0_37_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_37_2_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_37_2_len);
	cnt = getValue(P_ASG_49_0_0_37_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_37_2_len, 127);
		}
	}

	P_ASG_49_0_0_37_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_37_2_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 150)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_37_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 150);
		putValue(this, 150);
	}
	P_ASG_49_0_0_37_BuildFct();
}


on envVar P_ASG_49_0_0_37_2 // MediaPath.Path
{
	putValue(P_ASG_49_0_0_37_2_len, getValueSize(this));
	P_ASG_49_0_0_37_BuildFct();
}

on envVar M_ASG_49_0_0_38AbortResult_BTN
{
    if (M_ASG_49_0_0_38AbortResult_BTN_already_pressed == 0)
    {
         putValue(M_ASG_49_0_0_38_ErrCode,0);
         SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_38",MakeRGB(255,255,255));
         M_ASG_49_0_0_38AbortResult_BTN_already_pressed = 1;
    }
    else
    {
         putValue(M_ASG_49_0_0_38_State, "AbortResult");
         Request_Void(LSGID, M_ASG_49_0_0_38_ID, AbortResult_REQ);
         M_ASG_49_0_0_38AbortResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_38StartResult_BTN
{
    byte temp[3];
    if (M_ASG_49_0_0_38StartResult_BTN_already_pressed == 0)
    {
        putValue(M_ASG_49_0_0_38_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_38",MakeRGB(255,255,255));
        M_ASG_49_0_0_38StartResult_BTN_already_pressed = 1;
    }
    else
    {
        getValue(M_ASG_49_0_0_38_Start, temp);
        Request_ByteSequence(LSGID, M_ASG_49_0_0_38_ID, StartResult_REQ, temp, getValueSize(M_ASG_49_0_0_38_Start));
        putValue(M_ASG_49_0_0_38_State, "Started");
        M_ASG_49_0_0_38StartResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_38_Result // bus value of MediaBrowserControl (38).
{
	// opcodes: Error-Processing-Result
	byte param1; // BrowserControlResult
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_38_Result);
	putValue(M_ASG_49_0_0_38_Result_1, param1);
}

on envVar M_ASG_49_0_0_38_Result_1 // MediaBrowserControl.BrowserControlResult
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // BrowserControlResult
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_ASG_49_0_0_38_Result);
	superval = thisval;
	putValue(M_ASG_49_0_0_38_Result,superval);
}

on envVar M_ASG_49_0_0_38_Processing // bus value of MediaBrowserControl (38).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_38_Processing);
	putValue(M_ASG_49_0_0_38_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_38_Processing_1_range // MediaBrowserControl.Reserve1 
{
	@M_ASG_49_0_0_38_Processing_1 = @M_ASG_49_0_0_38_Processing_1_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_38_Processing_1 // MediaBrowserControl.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_ASG_49_0_0_38_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_ASG_49_0_0_38_Processing);
	superval = thisval;
	putValue(M_ASG_49_0_0_38_Processing,superval);
}

on envVar M_ASG_49_0_0_38_Start // bus value of MediaBrowserControl (38).
{
	// opcodes: AbortResult-StartResult
	byte param1; // Control
	word param2; // Reference
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[3];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(M_ASG_49_0_0_38_Start, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_ASG_49_0_0_38_Start_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_ASG_49_0_0_38_Start_2, round((param2 * 1.0) - (0) + (0), 1.0));
}

on envVar M_ASG_49_0_0_38_Start_1 // MediaBrowserControl.Control
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // Control
	thisval = getValue(this);

    // Update superval
	getValue(M_ASG_49_0_0_38_Start, superval);
	superval[0]=thisval;
	putValue(M_ASG_49_0_0_38_Start,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_38_Start_2_range // MediaBrowserControl.Reference 
{
	@M_ASG_49_0_0_38_Start_2 = @M_ASG_49_0_0_38_Start_2_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_38_Start_2 // MediaBrowserControl.Reference
{
	byte superval[3];

	//Update Childvalue (Number)
	word thisval; // Reference
	float slider_value;

	slider_value = round(@M_ASG_49_0_0_38_Start_2, 1.0);
	@M_ASG_49_0_0_38_Start_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_ASG_49_0_0_38_Start, superval);
	superval[1]=thisval&0x00ff;
	superval[2]=(thisval&0xff00)>>8;
	putValue(M_ASG_49_0_0_38_Start,superval);
}

on envVar M_ASG_49_0_0_39AbortResult_BTN
{
    if (M_ASG_49_0_0_39AbortResult_BTN_already_pressed == 0)
    {
         putValue(M_ASG_49_0_0_39_ErrCode,0);
         SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_39",MakeRGB(255,255,255));
         M_ASG_49_0_0_39AbortResult_BTN_already_pressed = 1;
    }
    else
    {
         putValue(M_ASG_49_0_0_39_State, "AbortResult");
         Request_Void(LSGID, M_ASG_49_0_0_39_ID, AbortResult_REQ);
         M_ASG_49_0_0_39AbortResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_39StartResult_BTN
{
    if (M_ASG_49_0_0_39StartResult_BTN_already_pressed == 0)
    {
        putValue(M_ASG_49_0_0_39_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_39",MakeRGB(255,255,255));
        M_ASG_49_0_0_39StartResult_BTN_already_pressed = 1;
    }
    else
    {
        Request_Int16(LSGID, M_ASG_49_0_0_39_ID, StartResult_REQ, getValue(M_ASG_49_0_0_39_Start));
        putValue(M_ASG_49_0_0_39_State, "Started");
        M_ASG_49_0_0_39StartResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_39_Result // bus value of MediaFileInfo (39).
{
	// opcodes: Error-Processing-Result
	byte param1; // MediaFileInfoResult
	byte param2[76]; // Artist
	word len2;
	byte cnt2;
	byte param3[76]; // Title
	word len3;
	byte cnt3;
	byte param4[76]; // Album
	word len4;
	byte cnt4;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[229];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 229; i++ ) {
		superval[i] = 0;
	}
	getValue(M_ASG_49_0_0_39_Result, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_ASG_49_0_0_39_Result_1, param1);
	///////// Start param2 - STRING /////////
	getValue(M_ASG_49_0_0_39_Result_2, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(75>127) /* Max Fct-Katalog Laenge: 75*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 75;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_ASG_49_0_0_39_Result ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 75)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 75;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(M_ASG_49_0_0_39_Result_2_len, len2);
	putValue(M_ASG_49_0_0_39_Result_2_cnt, cnt2);
	
	if(len2 > getValueSize(M_ASG_49_0_0_39_Result_2))
		putValue(M_ASG_49_0_0_39_Result_2, param2, len2);
	else
		putValue(M_ASG_49_0_0_39_Result_2, param2, getValueSize(M_ASG_49_0_0_39_Result_2));

	///////// Start param3 - STRING /////////
	getValue(M_ASG_49_0_0_39_Result_3, param3);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(75>127) /* Max Fct-Katalog Laenge: 75*/
		{
			len3 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt3 = 1;
		}
		else
		{
			len3 = 75;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_ASG_49_0_0_39_Result ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len3 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt3 = 0;
	}
	
	if(len3 > 75)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len3, currentPos);
		len3 = 75;
	
		if(len3 < 128) cnt3 = 0;
		else cnt3 = 1;
	}
	
	for(i = 0; i < len3; i++)
	{
		param3[i] = superval[currentPos++];
	}
	
	putValue(M_ASG_49_0_0_39_Result_3_len, len3);
	putValue(M_ASG_49_0_0_39_Result_3_cnt, cnt3);
	
	if(len3 > getValueSize(M_ASG_49_0_0_39_Result_3))
		putValue(M_ASG_49_0_0_39_Result_3, param3, len3);
	else
		putValue(M_ASG_49_0_0_39_Result_3, param3, getValueSize(M_ASG_49_0_0_39_Result_3));

	///////// Start param4 - STRING /////////
	getValue(M_ASG_49_0_0_39_Result_4, param4);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(75>127) /* Max Fct-Katalog Laenge: 75*/
		{
			len4 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt4 = 1;
		}
		else
		{
			len4 = 75;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_ASG_49_0_0_39_Result ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len4 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt4 = 0;
	}
	
	if(len4 > 75)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len4, currentPos);
		len4 = 75;
	
		if(len4 < 128) cnt4 = 0;
		else cnt4 = 1;
	}
	
	for(i = 0; i < len4; i++)
	{
		param4[i] = superval[currentPos++];
	}
	
	putValue(M_ASG_49_0_0_39_Result_4_len, len4);
	putValue(M_ASG_49_0_0_39_Result_4_cnt, cnt4);
	
	if(len4 > getValueSize(M_ASG_49_0_0_39_Result_4))
		putValue(M_ASG_49_0_0_39_Result_4, param4, len4);
	else
		putValue(M_ASG_49_0_0_39_Result_4, param4, getValueSize(M_ASG_49_0_0_39_Result_4));

}

// Updates the bus value field and other dependencies.
M_ASG_49_0_0_39_Result_BuildFct()
{
	byte param1; // MediaFileInfoResult
	byte param2[76]; // Artist
	word len2;
	byte cnt2;
	byte param3[76]; // Title
	word len3;
	byte cnt3;
	byte param4[76]; // Album
	word len4;
	byte cnt4;

	int i;
	byte superval[229];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(M_ASG_49_0_0_39_Result_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	getValue(M_ASG_49_0_0_39_Result_2, param2);
	len2 = getValue(M_ASG_49_0_0_39_Result_2_len);
	cnt2= getValue(M_ASG_49_0_0_39_Result_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 75 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 75)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Result_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 75);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(M_ASG_49_0_0_39_Result_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 75)
		{
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(M_ASG_49_0_0_39_Result_2_len, len2);
			putValue(M_ASG_49_0_0_39_Result_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Result_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 75);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

// gen_BuildFunc_SetSuperVals 
	getValue(M_ASG_49_0_0_39_Result_3, param3);
	len3 = getValue(M_ASG_49_0_0_39_Result_3_len);
	cnt3= getValue(M_ASG_49_0_0_39_Result_3_cnt);
	
	/* check box aktiviert*/
	if (cnt3 == 1)
	{
		/* 0 bis 75 (MaxString - 1B oder 2B) */
		if(len3 >= 0 && len3 <= 75)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len3: %d", len3);
			superval[currentPos] = (len3&0x7f00) | 0x80;
			superval[currentPos+1] = len3 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Result_3 ist ungueltig. Die max. erlaubte Laenge ist %d.", len3, 75);
			return;
		}
	}
	else if(cnt3 == 0) /*check box deaktiviert*/
	{
		if(len3 >= 0 && len3 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len3: %d", len3);
			superval[currentPos]= len3 & 0x00ff;
			putValue(M_ASG_49_0_0_39_Result_3_len, len3);
		}
		else if(len3 > 127 && len3 <= 75)
		{
			superval[currentPos] = (len3&0x7f00) | 0x80;
			superval[currentPos+1] = len3 & 0x00ff;
			putValue(M_ASG_49_0_0_39_Result_3_len, len3);
			putValue(M_ASG_49_0_0_39_Result_3_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Result_3 ist ungueltig. Die max. erlaubte Laenge ist %d.", len3, 75);
			return;
		}
	}
	currentPos += cnt3+1;
	for(i = 0; i < len3; i++)
	{
		superval[currentPos++]= param3[i];
	}

// gen_BuildFunc_SetSuperVals 
	getValue(M_ASG_49_0_0_39_Result_4, param4);
	len4 = getValue(M_ASG_49_0_0_39_Result_4_len);
	cnt4= getValue(M_ASG_49_0_0_39_Result_4_cnt);
	
	/* check box aktiviert*/
	if (cnt4 == 1)
	{
		/* 0 bis 75 (MaxString - 1B oder 2B) */
		if(len4 >= 0 && len4 <= 75)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
			superval[currentPos] = (len4&0x7f00) | 0x80;
			superval[currentPos+1] = len4 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Result_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 75);
			return;
		}
	}
	else if(cnt4 == 0) /*check box deaktiviert*/
	{
		if(len4 >= 0 && len4 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
			superval[currentPos]= len4 & 0x00ff;
			putValue(M_ASG_49_0_0_39_Result_4_len, len4);
		}
		else if(len4 > 127 && len4 <= 75)
		{
			superval[currentPos] = (len4&0x7f00) | 0x80;
			superval[currentPos+1] = len4 & 0x00ff;
			putValue(M_ASG_49_0_0_39_Result_4_len, len4);
			putValue(M_ASG_49_0_0_39_Result_4_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Result_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 75);
			return;
		}
	}
	currentPos += cnt4+1;
	for(i = 0; i < len4; i++)
	{
		superval[currentPos++]= param4[i];
	}

	putValue(M_ASG_49_0_0_39_Result, superval, currentPos);
}


on envVar M_ASG_49_0_0_39_Result_1 // MediaFileInfo.MediaFileInfoResult
{
	M_ASG_49_0_0_39_Result_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_ASG_49_0_0_39_Result_2_cnt
{
	word len;
	byte cnt;
	len = getValue(M_ASG_49_0_0_39_Result_2_len);
	cnt = getValue(M_ASG_49_0_0_39_Result_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_ASG_49_0_0_39_Result_2_len, 127);
		}
	}

	M_ASG_49_0_0_39_Result_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_ASG_49_0_0_39_Result_2_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 75)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Result_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 75);
		putValue(this, 75);
	}
	M_ASG_49_0_0_39_Result_BuildFct();
}


on envVar M_ASG_49_0_0_39_Result_2 // MediaFileInfo.Artist
{
	putValue(M_ASG_49_0_0_39_Result_2_len, getValueSize(this));
	M_ASG_49_0_0_39_Result_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_ASG_49_0_0_39_Result_3_cnt
{
	word len;
	byte cnt;
	len = getValue(M_ASG_49_0_0_39_Result_3_len);
	cnt = getValue(M_ASG_49_0_0_39_Result_3_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_ASG_49_0_0_39_Result_3_len, 127);
		}
	}

	M_ASG_49_0_0_39_Result_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_ASG_49_0_0_39_Result_3_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 75)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Result_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 75);
		putValue(this, 75);
	}
	M_ASG_49_0_0_39_Result_BuildFct();
}


on envVar M_ASG_49_0_0_39_Result_3 // MediaFileInfo.Title
{
	putValue(M_ASG_49_0_0_39_Result_3_len, getValueSize(this));
	M_ASG_49_0_0_39_Result_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_ASG_49_0_0_39_Result_4_cnt
{
	word len;
	byte cnt;
	len = getValue(M_ASG_49_0_0_39_Result_4_len);
	cnt = getValue(M_ASG_49_0_0_39_Result_4_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_ASG_49_0_0_39_Result_4_len, 127);
		}
	}

	M_ASG_49_0_0_39_Result_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_ASG_49_0_0_39_Result_4_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 75)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Result_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 75);
		putValue(this, 75);
	}
	M_ASG_49_0_0_39_Result_BuildFct();
}


on envVar M_ASG_49_0_0_39_Result_4 // MediaFileInfo.Album
{
	putValue(M_ASG_49_0_0_39_Result_4_len, getValueSize(this));
	M_ASG_49_0_0_39_Result_BuildFct();
}

on envVar M_ASG_49_0_0_39_Processing // bus value of MediaFileInfo (39).
{
	// opcodes: Error-Processing-Result
	byte param1[229]; // Reserve1
	word len1;
	byte cnt1;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[229];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 229; i++ ) {
		superval[i] = 0;
	}
	getValue(M_ASG_49_0_0_39_Processing, superval);
	///////// Start param1 - STRING /////////
	getValue(M_ASG_49_0_0_39_Processing_1, param1);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(227>127) /* Max Fct-Katalog Laenge: 227*/
		{
			len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt1 = 1;
		}
		else
		{
			len1 = 227;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_ASG_49_0_0_39_Processing ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len1 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt1 = 0;
	}
	
	if(len1 > 227)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
		len1 = 227;
	
		if(len1 < 128) cnt1 = 0;
		else cnt1 = 1;
	}
	
	for(i = 0; i < len1; i++)
	{
		param1[i] = superval[currentPos++];
	}
	
	putValue(M_ASG_49_0_0_39_Processing_1_len, len1);
	putValue(M_ASG_49_0_0_39_Processing_1_cnt, cnt1);
	
	if(len1 > getValueSize(M_ASG_49_0_0_39_Processing_1))
		putValue(M_ASG_49_0_0_39_Processing_1, param1, len1);
	else
		putValue(M_ASG_49_0_0_39_Processing_1, param1, getValueSize(M_ASG_49_0_0_39_Processing_1));

}

// Updates the bus value field and other dependencies.
M_ASG_49_0_0_39_Processing_BuildFct()
{
	byte param1[229]; // Reserve1
	word len1;
	byte cnt1;

	int i;
	byte superval[229];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	getValue(M_ASG_49_0_0_39_Processing_1, param1);
	len1 = getValue(M_ASG_49_0_0_39_Processing_1_len);
	cnt1= getValue(M_ASG_49_0_0_39_Processing_1_cnt);
	
	/* check box aktiviert*/
	if (cnt1 == 1)
	{
		/* 0 bis 227 (MaxString - 1B oder 2B) */
		if(len1 >= 0 && len1 <= 227)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Processing_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 227);
			return;
		}
	}
	else if(cnt1 == 0) /*check box deaktiviert*/
	{
		if(len1 >= 0 && len1 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos]= len1 & 0x00ff;
			putValue(M_ASG_49_0_0_39_Processing_1_len, len1);
		}
		else if(len1 > 127 && len1 <= 227)
		{
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
			putValue(M_ASG_49_0_0_39_Processing_1_len, len1);
			putValue(M_ASG_49_0_0_39_Processing_1_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Processing_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 227);
			return;
		}
	}
	currentPos += cnt1+1;
	for(i = 0; i < len1; i++)
	{
		superval[currentPos++]= param1[i];
	}

	putValue(M_ASG_49_0_0_39_Processing, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  M_ASG_49_0_0_39_Processing_1_cnt
{
	word len;
	byte cnt;
	len = getValue(M_ASG_49_0_0_39_Processing_1_len);
	cnt = getValue(M_ASG_49_0_0_39_Processing_1_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_ASG_49_0_0_39_Processing_1_len, 127);
		}
	}

	M_ASG_49_0_0_39_Processing_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_ASG_49_0_0_39_Processing_1_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 227)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_ASG_49_0_0_39_Processing_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 227);
		putValue(this, 227);
	}
	M_ASG_49_0_0_39_Processing_BuildFct();
}


on envVar M_ASG_49_0_0_39_Processing_1 // MediaFileInfo.Reserve1
{
	putValue(M_ASG_49_0_0_39_Processing_1_len, getValueSize(this));
	M_ASG_49_0_0_39_Processing_BuildFct();
}

on envVar M_ASG_49_0_0_39_Start // bus value of MediaFileInfo (39).
{
	// opcodes: AbortResult-StartResult
	word param1; // Ref_MediaBrowser
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_39_Start);
	putValue(M_ASG_49_0_0_39_Start_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_39_Start_1_range // MediaFileInfo.Ref_MediaBrowser 
{
	@M_ASG_49_0_0_39_Start_1 = @M_ASG_49_0_0_39_Start_1_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_39_Start_1 // MediaFileInfo.Ref_MediaBrowser
{
	word superval;

	//Update Childvalue (Number)
	word thisval; // Ref_MediaBrowser
	float slider_value;

	slider_value = round(@M_ASG_49_0_0_39_Start_1, 1.0);
	@M_ASG_49_0_0_39_Start_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_ASG_49_0_0_39_Start);
	superval = thisval;
	putValue(M_ASG_49_0_0_39_Start,superval);
}

on envVar P_ASG_49_0_0_40Get_BTN
{
 if (P_ASG_49_0_0_40Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_40_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_40",MakeRGB(255,255,255));
       P_ASG_49_0_0_40Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_40_ID, DataGet_REQ); 
       P_ASG_49_0_0_40Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_40SetGet_BTN
{
    if (P_ASG_49_0_0_40SetGet_BTN_already_pressed == 0)
    {
       putValue(P_ASG_49_0_0_40_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_40",MakeRGB(255,255,255));
       P_ASG_49_0_0_40SetGet_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_ASG_49_0_0_40_ID, DataSetGet_REQ, getValue(P_ASG_49_0_0_40));
       P_ASG_49_0_0_40SetGet_BTN_already_pressed = 0;
    }
}
on envVar P_ASG_49_0_0_40 // bus value of PreferredList (40).
{
	// opcodes: Error-Status
	byte param1; // List
	// DATATYPE_UINTXX
	param1 = getValue(P_ASG_49_0_0_40);
	putValue(P_ASG_49_0_0_40_1, param1);
}

on envVar P_ASG_49_0_0_40_1 // PreferredList.List
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // List
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_ASG_49_0_0_40);
	superval = thisval;
	putValue(P_ASG_49_0_0_40,superval);
}

on envVar P_ASG_49_0_0_41Get_BTN
{
 if (P_ASG_49_0_0_41Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_41_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_41",MakeRGB(255,255,255));
       P_ASG_49_0_0_41Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_41_ID, DataGet_REQ); 
       P_ASG_49_0_0_41Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_41SetGet_BTN
{
    if (P_ASG_49_0_0_41SetGet_BTN_already_pressed == 0)
    {
       putValue(P_ASG_49_0_0_41_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_41",MakeRGB(255,255,255));
       P_ASG_49_0_0_41SetGet_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_ASG_49_0_0_41_ID, DataSetGet_REQ, getValue(P_ASG_49_0_0_41));
       P_ASG_49_0_0_41SetGet_BTN_already_pressed = 0;
    }
}
on envVar P_ASG_49_0_0_41 // bus value of SDS_State (41).
{
	// opcodes: Error-Status
	byte param1; // State
	// DATATYPE_UINTXX
	param1 = getValue(P_ASG_49_0_0_41);
	putValue(P_ASG_49_0_0_41_1, param1);
}

on envVar P_ASG_49_0_0_41_1 // SDS_State.State
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // State
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_ASG_49_0_0_41);
	superval = thisval;
	putValue(P_ASG_49_0_0_41,superval);
}

on envVar P_ASG_49_0_0_42Get_BTN
{
 if (P_ASG_49_0_0_42Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_42_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_42",MakeRGB(255,255,255));
       P_ASG_49_0_0_42Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_42_ID, DataGet_REQ); 
       P_ASG_49_0_0_42Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_42 // bus value of FunctionSynchronisation (42).
{
	// opcodes: Error-Status
	byte param1[6]; // FctList_1
	byte param2; // FctList_2
	byte param3; // FctList_3
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[8];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 8; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_42, superval);
	///////// Start param1 - 6/8BSTRING /////////
	for( i = 0; i < 6; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(P_ASG_49_0_0_42_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_42_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_ASG_49_0_0_42_3, param3);
}

// Updates the bus value field and other dependencies.
P_ASG_49_0_0_42_BuildFct()
{
	byte param1[6]; // FctList_1
	byte param2; // FctList_2
	byte param3; // FctList_3

	int i;
	byte superval[8];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_42_1, param1);
	@P_ASG_49_0_0_42_1_16 = (param1[2] & 1) > 0;
	@P_ASG_49_0_0_42_1_17 = (param1[2] & 2) > 0;
	@P_ASG_49_0_0_42_1_18 = (param1[2] & 4) > 0;
	@P_ASG_49_0_0_42_1_19 = (param1[2] & 8) > 0;
	@P_ASG_49_0_0_42_1_20 = (param1[2] & 16) > 0;
	@P_ASG_49_0_0_42_1_21 = (param1[2] & 32) > 0;
	@P_ASG_49_0_0_42_1_22 = (param1[2] & 64) > 0;
	@P_ASG_49_0_0_42_1_25 = (param1[3] & 2) > 0;
	@P_ASG_49_0_0_42_1_26 = (param1[3] & 4) > 0;
	@P_ASG_49_0_0_42_1_28 = (param1[3] & 16) > 0;
	@P_ASG_49_0_0_42_1_30 = (param1[3] & 64) > 0;
	@P_ASG_49_0_0_42_1_31 = (param1[3] & 128) > 0;
	@P_ASG_49_0_0_42_1_35 = (param1[4] & 8) > 0;
	@P_ASG_49_0_0_42_1_37 = (param1[4] & 32) > 0;
	@P_ASG_49_0_0_42_1_40 = (param1[5] & 1) > 0;
	@P_ASG_49_0_0_42_1_41 = (param1[5] & 2) > 0;
	@P_ASG_49_0_0_42_1_43 = (param1[5] & 8) > 0;
	@P_ASG_49_0_0_42_1_46 = (param1[5] & 64) > 0;
	@P_ASG_49_0_0_42_1_47 = (param1[5] & 128) > 0;
	for( i = 0; i < 6; i++)
	{
	 superval[currentPos++] = param1[i];
	}
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_ASG_49_0_0_42_2);
	@P_ASG_49_0_0_42_2_0 = (param2 & 1) > 0;
	@P_ASG_49_0_0_42_2_1 = (param2 & 2) > 0;
	@P_ASG_49_0_0_42_2_3 = (param2 & 8) > 0;
	@P_ASG_49_0_0_42_2_4 = (param2 & 16) > 0;
	@P_ASG_49_0_0_42_2_5 = (param2 & 32) > 0;
	@P_ASG_49_0_0_42_2_6 = (param2 & 64) > 0;
	@P_ASG_49_0_0_42_2_7 = (param2 & 128) > 0;
	superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_ASG_49_0_0_42_3);
	@P_ASG_49_0_0_42_3_1 = (param3 & 2) > 0;
	@P_ASG_49_0_0_42_3_4 = (param3 & 16) > 0;
	superval[currentPos++]=param3;
	putValue(P_ASG_49_0_0_42, superval, currentPos);
}


on envVar P_ASG_49_0_0_42_1_16
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[2] = thisval[2]&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_17
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[2] = thisval[2]&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_18
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[2] = thisval[2]&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_19
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[2] = thisval[2]&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_20
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[2] = thisval[2]&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_21
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[2] = thisval[2]&~(1<<5)|(bitval<<5);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_22
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[2] = thisval[2]&~(1<<6)|(bitval<<6);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_25
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[3] = thisval[3]&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_26
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[3] = thisval[3]&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_28
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[3] = thisval[3]&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_30
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[3] = thisval[3]&~(1<<6)|(bitval<<6);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_31
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[3] = thisval[3]&~(1<<7)|(bitval<<7);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_35
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[4] = thisval[4]&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_37
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[4] = thisval[4]&~(1<<5)|(bitval<<5);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_40
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[5] = thisval[5]&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_41
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[5] = thisval[5]&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_43
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[5] = thisval[5]&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_46
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[5] = thisval[5]&~(1<<6)|(bitval<<6);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1_47
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_ASG_49_0_0_42_1, thisval);
	thisval[5] = thisval[5]&~(1<<7)|(bitval<<7);
	putValue(P_ASG_49_0_0_42_1,thisval);
}

on envVar P_ASG_49_0_0_42_1 // FunctionSynchronisation.FctList_1
{
	P_ASG_49_0_0_42_BuildFct();
}

on envVar P_ASG_49_0_0_42_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_42_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_42_2,thisval);
}

on envVar P_ASG_49_0_0_42_2_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_42_2);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_42_2,thisval);
}

on envVar P_ASG_49_0_0_42_2_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_42_2);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_42_2,thisval);
}

on envVar P_ASG_49_0_0_42_2_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_42_2);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_42_2,thisval);
}

on envVar P_ASG_49_0_0_42_2_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_42_2);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_ASG_49_0_0_42_2,thisval);
}

on envVar P_ASG_49_0_0_42_2_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_42_2);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_ASG_49_0_0_42_2,thisval);
}

on envVar P_ASG_49_0_0_42_2_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_42_2);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_ASG_49_0_0_42_2,thisval);
}

on envVar P_ASG_49_0_0_42_2 // FunctionSynchronisation.FctList_2
{
	P_ASG_49_0_0_42_BuildFct();
}

on envVar P_ASG_49_0_0_42_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_3
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_42_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_42_3,thisval);
}

on envVar P_ASG_49_0_0_42_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_3
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_42_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_42_3,thisval);
}

on envVar P_ASG_49_0_0_42_3 // FunctionSynchronisation.FctList_3
{
	P_ASG_49_0_0_42_BuildFct();
}

on envVar P_ASG_49_0_0_43Get_BTN
{
 if (P_ASG_49_0_0_43Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_43_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_43",MakeRGB(255,255,255));
       P_ASG_49_0_0_43Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_43_ID, DataGet_REQ); 
       P_ASG_49_0_0_43Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_43SetGet_BTN
{
    if (P_ASG_49_0_0_43SetGet_BTN_already_pressed == 0)
    {
       putValue(P_ASG_49_0_0_43_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_43",MakeRGB(255,255,255));
       P_ASG_49_0_0_43SetGet_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_ASG_49_0_0_43_ID, DataSetGet_REQ, getValue(P_ASG_49_0_0_43));
       P_ASG_49_0_0_43SetGet_BTN_already_pressed = 0;
    }
}
on envVar P_ASG_49_0_0_43 // bus value of ASG_Capabilities (43).
{
	// opcodes: Error-Status
	byte param1; // PresentationCapabilities
	// DATATYPE_UINTXX
	param1 = getValue(P_ASG_49_0_0_43);
	putValue(P_ASG_49_0_0_43_1, param1);
}

on envVar P_ASG_49_0_0_43_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PresentationCapabilities
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_43_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_43_1,thisval);
}

on envVar P_ASG_49_0_0_43_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PresentationCapabilities
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_43_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_43_1,thisval);
}

on envVar P_ASG_49_0_0_43_1 // ASG_Capabilities.PresentationCapabilities
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // PresentationCapabilities
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_43_1_0, 1);
	else
		putValue(P_ASG_49_0_0_43_1_0, 0);
	if(thisval&(mask<<1))
		putValue(P_ASG_49_0_0_43_1_1, 1);
	else
		putValue(P_ASG_49_0_0_43_1_1, 0);

    // Update superval
	superval = getValue(P_ASG_49_0_0_43);
	superval = thisval;
	putValue(P_ASG_49_0_0_43,superval);
}

on envVar M_ASG_49_0_0_44AbortResult_BTN
{
    if (M_ASG_49_0_0_44AbortResult_BTN_already_pressed == 0)
    {
         putValue(M_ASG_49_0_0_44_ErrCode,0);
         SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_44",MakeRGB(255,255,255));
         M_ASG_49_0_0_44AbortResult_BTN_already_pressed = 1;
    }
    else
    {
         putValue(M_ASG_49_0_0_44_State, "AbortResult");
         Request_Void(LSGID, M_ASG_49_0_0_44_ID, AbortResult_REQ);
         M_ASG_49_0_0_44AbortResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_44StartResult_BTN
{
    byte temp[5];
    if (M_ASG_49_0_0_44StartResult_BTN_already_pressed == 0)
    {
        putValue(M_ASG_49_0_0_44_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_44",MakeRGB(255,255,255));
        M_ASG_49_0_0_44StartResult_BTN_already_pressed = 1;
    }
    else
    {
        getValue(M_ASG_49_0_0_44_Start, temp);
        Request_ByteSequence(LSGID, M_ASG_49_0_0_44_ID, StartResult_REQ, temp, getValueSize(M_ASG_49_0_0_44_Start));
        putValue(M_ASG_49_0_0_44_State, "Started");
        M_ASG_49_0_0_44StartResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_44_Result // bus value of GetNextListPos (44).
{
	// opcodes: Error-Processing-Result
	byte param1; // GetNextListPos_Result
	word param2; // currentPos
	word param3; // nextPos
	word param4; // absoluteListPos
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[7];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 7; i++ ) {
		superval[i] = 0;
	}
	getValue(M_ASG_49_0_0_44_Result, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_ASG_49_0_0_44_Result_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_ASG_49_0_0_44_Result_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_ASG_49_0_0_44_Result_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT16 /////////
	param4 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_ASG_49_0_0_44_Result_4, round((param4 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
M_ASG_49_0_0_44_Result_BuildFct()
{
	byte param1; // GetNextListPos_Result
	word param2; // currentPos
	word param3; // nextPos
	word param4; // absoluteListPos

	int i;
	byte superval[7];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(M_ASG_49_0_0_44_Result_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	@M_ASG_49_0_0_44_Result_2_range = round(@M_ASG_49_0_0_44_Result_2 + (0), 1.0); // slider value + min = real value
	param2 = round( (@M_ASG_49_0_0_44_Result_2 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param2&0x00ff;
	superval[currentPos++]=(param2&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@M_ASG_49_0_0_44_Result_3_range = round(@M_ASG_49_0_0_44_Result_3 + (0), 1.0); // slider value + min = real value
	param3 = round( (@M_ASG_49_0_0_44_Result_3 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param3&0x00ff;
	superval[currentPos++]=(param3&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@M_ASG_49_0_0_44_Result_4_range = round(@M_ASG_49_0_0_44_Result_4 + (0), 1.0); // slider value + min = real value
	param4 = round( (@M_ASG_49_0_0_44_Result_4 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param4&0x00ff;
	superval[currentPos++]=(param4&0xff00)>>8;
	putValue(M_ASG_49_0_0_44_Result, superval, currentPos);
}


on envVar M_ASG_49_0_0_44_Result_1 // GetNextListPos.GetNextListPos_Result
{
	M_ASG_49_0_0_44_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_44_Result_2_range // GetNextListPos.currentPos 
{
	@M_ASG_49_0_0_44_Result_2 = @M_ASG_49_0_0_44_Result_2_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_44_Result_2 // GetNextListPos.currentPos
{
	M_ASG_49_0_0_44_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_44_Result_3_range // GetNextListPos.nextPos 
{
	@M_ASG_49_0_0_44_Result_3 = @M_ASG_49_0_0_44_Result_3_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_44_Result_3 // GetNextListPos.nextPos
{
	M_ASG_49_0_0_44_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_44_Result_4_range // GetNextListPos.absoluteListPos 
{
	@M_ASG_49_0_0_44_Result_4 = @M_ASG_49_0_0_44_Result_4_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_44_Result_4 // GetNextListPos.absoluteListPos
{
	M_ASG_49_0_0_44_Result_BuildFct();
}

on envVar M_ASG_49_0_0_44_Processing // bus value of GetNextListPos (44).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	word param2; // Reserve2
	word param3; // Reserve3
	word param4; // Reserve4
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[7];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 7; i++ ) {
		superval[i] = 0;
	}
	getValue(M_ASG_49_0_0_44_Processing, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_ASG_49_0_0_44_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_ASG_49_0_0_44_Processing_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_ASG_49_0_0_44_Processing_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT16 /////////
	param4 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_ASG_49_0_0_44_Processing_4, round((param4 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
M_ASG_49_0_0_44_Processing_BuildFct()
{
	byte param1; // Reserve1
	word param2; // Reserve2
	word param3; // Reserve3
	word param4; // Reserve4

	int i;
	byte superval[7];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	@M_ASG_49_0_0_44_Processing_1_range = round(@M_ASG_49_0_0_44_Processing_1 + (0), 1.0); // slider value + min = real value
	param1 = 0; // underlying parameter has constant value 0.
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	@M_ASG_49_0_0_44_Processing_2_range = round(@M_ASG_49_0_0_44_Processing_2 + (0), 1.0); // slider value + min = real value
	param2 = 0; // underlying parameter has constant value 0.
	superval[currentPos++]=param2&0x00ff;
	superval[currentPos++]=(param2&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@M_ASG_49_0_0_44_Processing_3_range = round(@M_ASG_49_0_0_44_Processing_3 + (0), 1.0); // slider value + min = real value
	param3 = 0; // underlying parameter has constant value 0.
	superval[currentPos++]=param3&0x00ff;
	superval[currentPos++]=(param3&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@M_ASG_49_0_0_44_Processing_4_range = round(@M_ASG_49_0_0_44_Processing_4 + (0), 1.0); // slider value + min = real value
	param4 = 0; // underlying parameter has constant value 0.
	superval[currentPos++]=param4&0x00ff;
	superval[currentPos++]=(param4&0xff00)>>8;
	putValue(M_ASG_49_0_0_44_Processing, superval, currentPos);
}


// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_44_Processing_1_range // GetNextListPos.Reserve1 
{
	@M_ASG_49_0_0_44_Processing_1 = @M_ASG_49_0_0_44_Processing_1_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_44_Processing_1 // GetNextListPos.Reserve1
{
	M_ASG_49_0_0_44_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_44_Processing_2_range // GetNextListPos.Reserve2 
{
	@M_ASG_49_0_0_44_Processing_2 = @M_ASG_49_0_0_44_Processing_2_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_44_Processing_2 // GetNextListPos.Reserve2
{
	M_ASG_49_0_0_44_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_44_Processing_3_range // GetNextListPos.Reserve3 
{
	@M_ASG_49_0_0_44_Processing_3 = @M_ASG_49_0_0_44_Processing_3_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_44_Processing_3 // GetNextListPos.Reserve3
{
	M_ASG_49_0_0_44_Processing_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_44_Processing_4_range // GetNextListPos.Reserve4 
{
	@M_ASG_49_0_0_44_Processing_4 = @M_ASG_49_0_0_44_Processing_4_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_44_Processing_4 // GetNextListPos.Reserve4
{
	M_ASG_49_0_0_44_Processing_BuildFct();
}

on envVar M_ASG_49_0_0_44_Start // bus value of GetNextListPos (44).
{
	// opcodes: AbortResult-StartResult
	word param1; // currentPos
	int param2; // Offset
	byte param3; // ListType
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[5];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(M_ASG_49_0_0_44_Start, superval);
	///////// Start param1 - UINT16 /////////
	param1 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_ASG_49_0_0_44_Start_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_ASG_49_0_0_44_Start_2, round((param2 * 1.0) - (-32766) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(M_ASG_49_0_0_44_Start_3, param3);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_44_Start_1_range // GetNextListPos.currentPos 
{
	@M_ASG_49_0_0_44_Start_1 = @M_ASG_49_0_0_44_Start_1_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_44_Start_1 // GetNextListPos.currentPos
{
	byte superval[5];

	//Update Childvalue (Number)
	word thisval; // currentPos
	float slider_value;

	slider_value = round(@M_ASG_49_0_0_44_Start_1, 1.0);
	@M_ASG_49_0_0_44_Start_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_ASG_49_0_0_44_Start, superval);
	superval[0]=thisval&0x00ff;
	superval[1]=(thisval&0xff00)>>8;
	putValue(M_ASG_49_0_0_44_Start,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_44_Start_2_range // GetNextListPos.Offset 
{
	@M_ASG_49_0_0_44_Start_2 = @M_ASG_49_0_0_44_Start_2_range - (-32766); // slider = range - min
}

on envVar M_ASG_49_0_0_44_Start_2 // GetNextListPos.Offset
{
	byte superval[5];

	//Update Childvalue (Number)
	int thisval; // Offset
	float slider_value;

	slider_value = round(@M_ASG_49_0_0_44_Start_2, 1.0);
	@M_ASG_49_0_0_44_Start_2_range = slider_value + (-32766); // real value := slider value + range min.
	thisval = (int)round((slider_value + (-32766) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_ASG_49_0_0_44_Start, superval);
	superval[2]=thisval&0x00ff;
	superval[3]=(thisval&0xff00)>>8;
	putValue(M_ASG_49_0_0_44_Start,superval);
}

on envVar M_ASG_49_0_0_44_Start_3 // GetNextListPos.ListType
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // ListType
	thisval = getValue(this);

    // Update superval
	getValue(M_ASG_49_0_0_44_Start, superval);
	superval[4]=thisval;
	putValue(M_ASG_49_0_0_44_Start,superval);
}

on envVar M_ASG_49_0_0_45AbortResult_BTN
{
    if (M_ASG_49_0_0_45AbortResult_BTN_already_pressed == 0)
    {
         putValue(M_ASG_49_0_0_45_ErrCode,0);
         SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_45",MakeRGB(255,255,255));
         M_ASG_49_0_0_45AbortResult_BTN_already_pressed = 1;
    }
    else
    {
         putValue(M_ASG_49_0_0_45_State, "AbortResult");
         Request_Void(LSGID, M_ASG_49_0_0_45_ID, AbortResult_REQ);
         M_ASG_49_0_0_45AbortResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_45StartResult_BTN
{
    if (M_ASG_49_0_0_45StartResult_BTN_already_pressed == 0)
    {
        putValue(M_ASG_49_0_0_45_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_ASG_49_0_0_45",MakeRGB(255,255,255));
        M_ASG_49_0_0_45StartResult_BTN_already_pressed = 1;
    }
    else
    {
        Request_Int8(LSGID, M_ASG_49_0_0_45_ID, StartResult_REQ, getValue(M_ASG_49_0_0_45_Start));
        putValue(M_ASG_49_0_0_45_State, "Started");
        M_ASG_49_0_0_45StartResult_BTN_already_pressed = 0;
    }
}
on envVar M_ASG_49_0_0_45_Result // bus value of SwitchRadioMedia (45).
{
	// opcodes: Error-Processing-Result
	byte param1; // SwitchRadioMediaResult
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_45_Result);
	putValue(M_ASG_49_0_0_45_Result_1, param1);
}

on envVar M_ASG_49_0_0_45_Result_1 // SwitchRadioMedia.SwitchRadioMediaResult
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // SwitchRadioMediaResult
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_ASG_49_0_0_45_Result);
	superval = thisval;
	putValue(M_ASG_49_0_0_45_Result,superval);
}

on envVar M_ASG_49_0_0_45_Processing // bus value of SwitchRadioMedia (45).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_45_Processing);
	putValue(M_ASG_49_0_0_45_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_ASG_49_0_0_45_Processing_1_range // SwitchRadioMedia.Reserve1 
{
	@M_ASG_49_0_0_45_Processing_1 = @M_ASG_49_0_0_45_Processing_1_range - (0); // slider = range - min
}

on envVar M_ASG_49_0_0_45_Processing_1 // SwitchRadioMedia.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_ASG_49_0_0_45_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_ASG_49_0_0_45_Processing);
	superval = thisval;
	putValue(M_ASG_49_0_0_45_Processing,superval);
}

on envVar M_ASG_49_0_0_45_Start // bus value of SwitchRadioMedia (45).
{
	// opcodes: AbortResult-StartResult
	byte param1; // Source
	// DATATYPE_UINTXX
	param1 = getValue(M_ASG_49_0_0_45_Start);
	putValue(M_ASG_49_0_0_45_Start_1, param1);
}

on envVar M_ASG_49_0_0_45_Start_1 // SwitchRadioMedia.Source
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // Source
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_ASG_49_0_0_45_Start);
	superval = thisval;
	putValue(M_ASG_49_0_0_45_Start,superval);
}

on envVar P_ASG_49_0_0_46Get_BTN
{
 if (P_ASG_49_0_0_46Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_46_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_46",MakeRGB(255,255,255));
       P_ASG_49_0_0_46Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_46_ID, DataGet_REQ); 
       P_ASG_49_0_0_46Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_46 // bus value of MediaImportState (46).
{
	// opcodes: Error-Status
	byte param1; // SourceType
	byte param2; // Instance_ID
	byte param3; // State
	byte param4; // Progress
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[4];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 4; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_46, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_46_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_46_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_ASG_49_0_0_46_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_ASG_49_0_0_46_4, round((param4 * 1.0) - (0) + (0), 1.0));
}

on envVar P_ASG_49_0_0_46_1 // MediaImportState.SourceType
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // SourceType
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_46, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_46,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_46_2_range // MediaImportState.Instance_ID 
{
	@P_ASG_49_0_0_46_2 = @P_ASG_49_0_0_46_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_46_2 // MediaImportState.Instance_ID
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // Instance_ID
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_46_2, 1.0);
	@P_ASG_49_0_0_46_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_46, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_46,superval);
}

on envVar P_ASG_49_0_0_46_3 // MediaImportState.State
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // State
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_46, superval);
	superval[2]=thisval;
	putValue(P_ASG_49_0_0_46,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_46_4_range // MediaImportState.Progress 
{
	@P_ASG_49_0_0_46_4 = @P_ASG_49_0_0_46_4_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_46_4 // MediaImportState.Progress
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // Progress
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_46_4, 1.0);
	@P_ASG_49_0_0_46_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_46, superval);
	superval[3]=thisval;
	putValue(P_ASG_49_0_0_46,superval);
}

on envVar P_ASG_49_0_0_47Get_BTN
{
 if (P_ASG_49_0_0_47Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_47_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_47",MakeRGB(255,255,255));
       P_ASG_49_0_0_47Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_47_ID, DataGet_REQ); 
       P_ASG_49_0_0_47Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_47SetGet_BTN
{
	byte BAPTemp[4];
    if (P_ASG_49_0_0_47SetGet_BTN_already_pressed == 0)
    {
       putValue(P_ASG_49_0_0_47_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_47",MakeRGB(255,255,255));
       P_ASG_49_0_0_47SetGet_BTN_already_pressed = 1;
    }
    else
    {
       getValue(P_ASG_49_0_0_47, BAPTemp);
       Request_ByteSequence(LSGID, P_ASG_49_0_0_47_ID, DataSetGet_REQ, BAPTemp, getValueSize(P_ASG_49_0_0_47));
       P_ASG_49_0_0_47SetGet_BTN_already_pressed = 0;
    }
}
on envVar P_ASG_49_0_0_47 // bus value of CurrentVolumeExtended (47).
{
	// opcodes: Error-Status
	byte param1; // ChangingVolumeType
	byte param2; // VolumeState
	byte param3; // maxVolume
	byte param4; // GenericVolume
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[4];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 4; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_47, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_47_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_47_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_ASG_49_0_0_47_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_ASG_49_0_0_47_4, round((param4 * 1.0) - (0) + (0), 1.0));
}

on envVar P_ASG_49_0_0_47_1 // CurrentVolumeExtended.ChangingVolumeType
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // ChangingVolumeType
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_47, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_47,superval);
}

on envVar P_ASG_49_0_0_47_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // VolumeState
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_47_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_47_2,thisval);
}

on envVar P_ASG_49_0_0_47_2 // CurrentVolumeExtended.VolumeState
{
	byte superval[4];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // VolumeState
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_47_2_0, 1);
	else
		putValue(P_ASG_49_0_0_47_2_0, 0);

    // Update superval
	getValue(P_ASG_49_0_0_47, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_47,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_47_3_range // CurrentVolumeExtended.maxVolume 
{
	@P_ASG_49_0_0_47_3 = @P_ASG_49_0_0_47_3_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_47_3 // CurrentVolumeExtended.maxVolume
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // maxVolume
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_47_3, 1.0);
	@P_ASG_49_0_0_47_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_47, superval);
	superval[2]=thisval;
	putValue(P_ASG_49_0_0_47,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_47_4_range // CurrentVolumeExtended.GenericVolume 
{
	@P_ASG_49_0_0_47_4 = @P_ASG_49_0_0_47_4_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_47_4 // CurrentVolumeExtended.GenericVolume
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // GenericVolume
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_47_4, 1.0);
	@P_ASG_49_0_0_47_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_47, superval);
	superval[3]=thisval;
	putValue(P_ASG_49_0_0_47,superval);
}

on envVar P_ASG_49_0_0_48Get_BTN
{
 if (P_ASG_49_0_0_48Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_48_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_48",MakeRGB(255,255,255));
       P_ASG_49_0_0_48Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_48_ID, DataGet_REQ); 
       P_ASG_49_0_0_48Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_48 // bus value of CustomerDownloadState (48).
{
	// opcodes: Error-Status
	byte param1; // CustomerDownloadState
	byte param2; // ProgressCustomerDownload
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[2];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_48, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_48_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_48_2, round((param2 * 1.0) - (0) + (0), 1.0));
}

on envVar P_ASG_49_0_0_48_1 // CustomerDownloadState.CustomerDownloadState
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // CustomerDownloadState
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_48, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_48,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_48_2_range // CustomerDownloadState.ProgressCustomerDownload 
{
	@P_ASG_49_0_0_48_2 = @P_ASG_49_0_0_48_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_48_2 // CustomerDownloadState.ProgressCustomerDownload
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // ProgressCustomerDownload
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_48_2, 1.0);
	@P_ASG_49_0_0_48_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_48, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_48,superval);
}

on envVar P_ASG_49_0_0_49Get_BTN
{
 if (P_ASG_49_0_0_49Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_49_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_49",MakeRGB(255,255,255));
       P_ASG_49_0_0_49Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_49_ID, DataGet_REQ); 
       P_ASG_49_0_0_49Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_49 // bus value of OnlineMusic_State (49).
{
	// opcodes: Error-Status
	byte param1; // State
	byte param2; // BufferLevel
	word param3; // Dummy
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[4];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 4; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_49, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_49_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_49_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_49_3, round((param3 * 1.0) - (0) + (0), 1.0));
}

on envVar P_ASG_49_0_0_49_1 // OnlineMusic_State.State
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // State
	thisval = getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_49, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_49,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_49_2_range // OnlineMusic_State.BufferLevel 
{
	@P_ASG_49_0_0_49_2 = @P_ASG_49_0_0_49_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_49_2 // OnlineMusic_State.BufferLevel
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // BufferLevel
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_49_2, 1.0);
	@P_ASG_49_0_0_49_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_49, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_49,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_49_3_range // OnlineMusic_State.Dummy 
{
	@P_ASG_49_0_0_49_3 = @P_ASG_49_0_0_49_3_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_49_3 // OnlineMusic_State.Dummy
{
	byte superval[4];

	//Update Childvalue (Number)
	word thisval; // Dummy
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_49_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_49, superval);
	superval[2]=thisval&0x00ff;
	superval[3]=(thisval&0xff00)>>8;
	putValue(P_ASG_49_0_0_49,superval);
}

on envVar A_ASG_49_0_0_50Get_BTN
{
  byte data[6]; 
  byte stringValue[6];
  byte head[5];
  int i;
  int headLength;
  long tempValue;
  word currentPos;
  word startVal;
  word elementsVal;
  byte nibbleSetted;
  if (A_ASG_49_0_0_50Get_BTN_already_pressed == 0)
  {
     putValue(A_ASG_49_0_0_50_ErrCode,0);
     SetControlBackColor(panel_name,"errField_A_ASG_49_0_0_50",MakeRGB(255,255,255));
     A_ASG_49_0_0_50Get_BTN_already_pressed = 1;
  }
  else
  {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_ASG_49_0_0_50_1_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_ASG_49_0_0_50_2_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //head Parameter
        headLength = getValueSize(A_ASG_49_0_0_50_SetGet);
        getValue(A_ASG_49_0_0_50_SetGet,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }

     Request_ByteSequence(LSGID, A_ASG_49_0_0_50_ID, DataGet_REQ, data, currentPos);
     if(getValue(A_ASG_49_0_0_50_IntTlgEn)) //getValue(IT))
     {
       intertelegram_err(A_ASG_49_0_0_50_ID);
     }
     if(getValue(A_ASG_49_0_0_50_SegmEn))   //getvalue(SG)
     {
         sequence_err(A_ASG_49_0_0_50_ID,getValueSize(A_ASG_49_0_0_50_SetGet));
     }
     A_ASG_49_0_0_50Get_BTN_already_pressed = 0;
  }
}
A_ASG_49_0_0_50_SetGet_GenerateSetGet()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_ASG_49_0_0_50_SetGet_RecAdr) > 0x0F)
        putValue(A_ASG_49_0_0_50_SetGet_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_ASG_49_0_0_50_SetGet_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_ASG_49_0_0_50_SetGet_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_ASG_49_0_0_50_SetGet_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // reserverd:  Byte 0 Bit 6
    if( getValue(A_ASG_49_0_0_50_SetGet_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_ASG_49_0_0_50_SetGet_Start) & 0xFF;
        head[2] = (getValue(A_ASG_49_0_0_50_SetGet_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_ASG_49_0_0_50_SetGet_Elements) & 0xFF;
        head[4] = (getValue(A_ASG_49_0_0_50_SetGet_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_ASG_49_0_0_50_SetGet, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_ASG_49_0_0_50_SetGet_Start) & 0xFF;
        head[2] = getValue(A_ASG_49_0_0_50_SetGet_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_ASG_49_0_0_50_SetGet, head, 3); 
    }
}

on envVar A_ASG_49_0_0_50_SetGet_RecAdr
{
    A_ASG_49_0_0_50_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_50_SetGet_Shift
{
    A_ASG_49_0_0_50_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_50_SetGet_Direction
{
    A_ASG_49_0_0_50_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_50_SetGet_Start
{
    A_ASG_49_0_0_50_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_50_SetGet_Elements
{
    A_ASG_49_0_0_50_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_50_SetGet_IndexSize
{
    A_ASG_49_0_0_50_SetGet_GenerateSetGet();
}
on envVar A_ASG_49_0_0_50
{
    byte temp[6];
    byte head[5];
    getValue(A_ASG_49_0_0_50, head);
    putValue(A_ASG_49_0_0_50_RecAdr, 0x0F & head[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & head[0]) >0)
        putValue(A_ASG_49_0_0_50_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & head[0]) >0)
        putValue(A_ASG_49_0_0_50_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & head[0]) >0)
        putValue(A_ASG_49_0_0_50_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & head[0]) >0)
        putValue(A_ASG_49_0_0_50_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_50_IndexSize))
    {
        putValue(A_ASG_49_0_0_50_Start, ((head[2]<<8)| head[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_50_Elements, ((head[4]<<8)| head[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_50_Start, head[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_50_Elements, head[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_50_Changed
{
    byte temp[604];
    getValue(A_ASG_49_0_0_50_Changed, temp);
    putValue(A_ASG_49_0_0_50_Changed_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_50_Changed_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_Changed_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_50_Changed_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_Changed_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_ASG_49_0_0_50_Changed_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_Changed_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_50_Changed_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_Changed_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_50_Changed_IndexSize))
    {
        putValue(A_ASG_49_0_0_50_Changed_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_50_Changed_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_50_Changed_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_50_Changed_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_50_SetGet
{
    byte temp[6];
    getValue(A_ASG_49_0_0_50_SetGet, temp);
    putValue(A_ASG_49_0_0_50_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_50_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_50_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_50_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_50_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_50_SetGet_IndexSize))
    {
        putValue(A_ASG_49_0_0_50_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_50_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_50_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_50_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_ASG_49_0_0_50_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp6[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_ASG_49_0_0_50_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_ASG_49_0_0_50_ArrayDataList[i].Param1 = 0;
		A_ASG_49_0_0_50_ArrayDataList[i].Param2 = 0;
		A_ASG_49_0_0_50_ArrayDataList[i].Param3 = 0;
		for(j=0; j<49; j++)
			A_ASG_49_0_0_50_ArrayDataList[i].Param4[j] = 0;
		A_ASG_49_0_0_50_ArrayDataList[i].Param4_Length = 0;
		A_ASG_49_0_0_50_Data_4_LenList[i] = 0;
		for(j=0; j<31; j++)
			A_ASG_49_0_0_50_ArrayDataList[i].Param5[j] = 0;
		A_ASG_49_0_0_50_ArrayDataList[i].Param5_Length = 0;
		A_ASG_49_0_0_50_Data_5_LenList[i] = 0;
		A_ASG_49_0_0_50_ArrayDataList[i].Param6 = 0;
		for(j=0; j<61; j++)
			A_ASG_49_0_0_50_ArrayDataList[i].Param7[j] = 0;
		A_ASG_49_0_0_50_ArrayDataList[i].Param7_Length = 0;
		A_ASG_49_0_0_50_Data_7_LenList[i] = 0;
		for(j=0; j<2; j++)
			A_ASG_49_0_0_50_ArrayDataList[i].Param8[j] = 0;
		A_ASG_49_0_0_50_ArrayDataList[i].Param8_Length = 0;
		A_ASG_49_0_0_50_Data_8_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_ASG_49_0_0_50_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 65536) //ignore first line in *.csv file
					{
						A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //Attributes
						A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //PresetID
						A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //AlertType
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp6[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 65536)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Attributes
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //PresetID
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //Name
								if(paramPos < 48)
								{
									A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 5: //Frequency
								if(paramPos < 30)
								{
									A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 6: //AlertType
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //AlertName
								if(paramPos < 60)
								{
									A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param7[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param7_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 8: //Extension
								if(paramPos < 1)
								{
									A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param8[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_50_ArrayDataList[current_CSV_line-1].Param8_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_ASG_49_0_0_50_loadArray_Btn
{
	char filePath[255];
	if (A_ASG_49_0_0_50_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_50_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_ASG_49_0_0_50_generateData_Btn_already_pressed = 0;
		getValue(A_ASG_49_0_0_50_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_ASG_49_0_0_50_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_ASG_49_0_0_50_Data_1, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_50_Data_2, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_50_Data_3, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_50_Data_4, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param4, A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param4_Length);
	putValue(A_ASG_49_0_0_50_Data_5, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param5, A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param5_Length);
	putValue(A_ASG_49_0_0_50_Data_6, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param6);
	putValue(A_ASG_49_0_0_50_Data_7, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param7, A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param7_Length);
	putValue(A_ASG_49_0_0_50_Data_8, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param8, A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param8_Length);
}


on envVar A_ASG_49_0_0_50_generateData_Btn
{
	word i;
	dword elementsArray[12] = {2, 2, 1, 49, 2, 31, 2, 1, 61, 2, 2, 2};
	byte elementsTypeArray[12] = {0, 0, 0, 0xE, 0xF, 0xE, 0xF, 0, 0xE, 0xF, 0xE, 0xF};
	dword elementsMaxSizeArray[12] = {65535, 0xFFFF, 255, 0, 0, 0, 0, 0xFF, 0, 0, 0, 0};
	byte tempArray[10288995];
	if (A_ASG_49_0_0_50_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_50_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 50, 65535 );
		for(i = 0; i < 65535; i++)
		{
			memcpy(A_ASG_49_0_0_50_ArrayDataList[i], tempArray, (i * 157) );
			if(A_ASG_49_0_0_50_ArrayDataList[i].Param4_Length > 127 )
				A_ASG_49_0_0_50_Data_4_CntList[i] = 1;
			if(A_ASG_49_0_0_50_ArrayDataList[i].Param5_Length > 127 )
				A_ASG_49_0_0_50_Data_5_CntList[i] = 1;
			if(A_ASG_49_0_0_50_ArrayDataList[i].Param7_Length > 127 )
				A_ASG_49_0_0_50_Data_7_CntList[i] = 1;
			if(A_ASG_49_0_0_50_ArrayDataList[i].Param8_Length > 127 )
				A_ASG_49_0_0_50_Data_8_CntList[i] = 1;
		}
		A_ASG_49_0_0_50_generateData_Btn_already_pressed = 0;
	}
	putValue(A_ASG_49_0_0_50_Data_1, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_50_Data_2, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_50_Data_3, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_50_Data_4, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param4, A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param4_Length);
	putValue(A_ASG_49_0_0_50_Data_5, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param5, A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param5_Length);
	putValue(A_ASG_49_0_0_50_Data_6, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param6);
	putValue(A_ASG_49_0_0_50_Data_7, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param7, A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param7_Length);
	putValue(A_ASG_49_0_0_50_Data_8, A_ASG_49_0_0_50_ArrayDataList[ getValue( A_ASG_49_0_0_50_DataIndex) ].Param8, A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param8_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_ASG_49_0_0_50_DataIndex
{
    long index;
    long maxIndex = 65535-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_ASG_49_0_0_50_Data_1, A_ASG_49_0_0_50_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_50_Data_2, A_ASG_49_0_0_50_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_50_Data_3, A_ASG_49_0_0_50_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_50_Data_4_len, A_ASG_49_0_0_50_Data_4_LenList[index]);
    putValue(A_ASG_49_0_0_50_Data_4_cnt, A_ASG_49_0_0_50_Data_4_CntList[index]);
    putValue(A_ASG_49_0_0_50_Data_4, A_ASG_49_0_0_50_ArrayDataList[index].Param4, A_ASG_49_0_0_50_ArrayDataList[index].Param4_Length);
    putValue(A_ASG_49_0_0_50_Data_5_len, A_ASG_49_0_0_50_Data_5_LenList[index]);
    putValue(A_ASG_49_0_0_50_Data_5_cnt, A_ASG_49_0_0_50_Data_5_CntList[index]);
    putValue(A_ASG_49_0_0_50_Data_5, A_ASG_49_0_0_50_ArrayDataList[index].Param5, A_ASG_49_0_0_50_ArrayDataList[index].Param5_Length);
    putValue(A_ASG_49_0_0_50_Data_6, A_ASG_49_0_0_50_ArrayDataList[index].Param6);
    putValue(A_ASG_49_0_0_50_Data_7_len, A_ASG_49_0_0_50_Data_7_LenList[index]);
    putValue(A_ASG_49_0_0_50_Data_7_cnt, A_ASG_49_0_0_50_Data_7_CntList[index]);
    putValue(A_ASG_49_0_0_50_Data_7, A_ASG_49_0_0_50_ArrayDataList[index].Param7, A_ASG_49_0_0_50_ArrayDataList[index].Param7_Length);
    putValue(A_ASG_49_0_0_50_Data_8_len, A_ASG_49_0_0_50_Data_8_LenList[index]);
    putValue(A_ASG_49_0_0_50_Data_8_cnt, A_ASG_49_0_0_50_Data_8_CntList[index]);
    putValue(A_ASG_49_0_0_50_Data_8, A_ASG_49_0_0_50_ArrayDataList[index].Param8, A_ASG_49_0_0_50_ArrayDataList[index].Param8_Length);

}
on envVar A_ASG_49_0_0_50_DataIndex_Incr
{
    long index;
    if(A_ASG_49_0_0_50_DataIndex_Incr_already_pressed == 0)
    {
        A_ASG_49_0_0_50_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_50_DataIndex);
        index++;
        putValue(A_ASG_49_0_0_50_DataIndex, index);
        A_ASG_49_0_0_50_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_ASG_49_0_0_50_DataIndex_Decr
{
    long index;
    if(A_ASG_49_0_0_50_DataIndex_Decr_already_pressed == 0)
    {
        A_ASG_49_0_0_50_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_50_DataIndex);
        index--;
        putValue(A_ASG_49_0_0_50_DataIndex, index);
        A_ASG_49_0_0_50_DataIndex_Decr_already_pressed = 0;
    }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_50_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_50_SegmEn,0);
           intertelegram_err(A_ASG_49_0_0_50_ID);
       }
       else
       {
           intertelegram_err_off(A_ASG_49_0_0_50_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_50_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_50_IntTlgEn,0);
           sequence_err(A_ASG_49_0_0_50_ID,getValueSize(A_ASG_49_0_0_50_SegmEn));
       }
       else
       {
              sequence_err_off(A_ASG_49_0_0_50_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_ASG_49_0_0_50_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_ASG_49_0_0_50_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_ASG_49_0_0_50_Status",1);
 	}
}

A_ASG_49_0_0_50_DataInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[604];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_50_1, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_50_2, tempValue);
    //Einzelparameter: TotalNumListElements
    //voriger Parameter war ein first nibble, bei 2 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue =  (gBAP_Indication_data[currentPos++] & 0xFF);
    tempValue += (gBAP_Indication_data[currentPos++] & 0xFF) << 8;
    putValue(A_ASG_49_0_0_50_3, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_50, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_50, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_50_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 50");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_50_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_50_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_50_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 5 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_50_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 5 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_50_Data_4_CntList[i] = 1;
            A_ASG_49_0_0_50_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_50_Data_4_CntList[i] = 0;
            A_ASG_49_0_0_50_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_50_ArrayDataList[i].Param4_Length; j++)
        {
            A_ASG_49_0_0_50_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_50_Data_5_CntList[i] = 1;
            A_ASG_49_0_0_50_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_50_Data_5_CntList[i] = 0;
            A_ASG_49_0_0_50_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_50_ArrayDataList[i].Param5_Length; j++)
        {
            A_ASG_49_0_0_50_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 5 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_50_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 5 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_50_Data_7_CntList[i] = 1;
            A_ASG_49_0_0_50_ArrayDataList[i].Param7_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_50_Data_7_CntList[i] = 0;
            A_ASG_49_0_0_50_ArrayDataList[i].Param7_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_50_ArrayDataList[i].Param7_Length; j++)
        {
            A_ASG_49_0_0_50_ArrayDataList[i].Param7[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_50_Data_8_CntList[i] = 1;
            A_ASG_49_0_0_50_ArrayDataList[i].Param8_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_50_Data_8_CntList[i] = 0;
            A_ASG_49_0_0_50_ArrayDataList[i].Param8_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_50_ArrayDataList[i].Param8_Length; j++)
        {
            A_ASG_49_0_0_50_ArrayDataList[i].Param8[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_50_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_50_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 50");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_50_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_50_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_50_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 5 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_50_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal || 5 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_50_Data_4_CntList[i] = 1;
            A_ASG_49_0_0_50_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_50_Data_4_CntList[i] = 0;
            A_ASG_49_0_0_50_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_50_ArrayDataList[i].Param4_Length; j++)
        {
            A_ASG_49_0_0_50_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 4 == recordAddressVal || 5 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_50_Data_5_CntList[i] = 1;
            A_ASG_49_0_0_50_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_50_Data_5_CntList[i] = 0;
            A_ASG_49_0_0_50_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_50_ArrayDataList[i].Param5_Length; j++)
        {
            A_ASG_49_0_0_50_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 5 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_50_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 5 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_50_Data_7_CntList[i] = 1;
            A_ASG_49_0_0_50_ArrayDataList[i].Param7_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_50_Data_7_CntList[i] = 0;
            A_ASG_49_0_0_50_ArrayDataList[i].Param7_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_50_ArrayDataList[i].Param7_Length; j++)
        {
            A_ASG_49_0_0_50_ArrayDataList[i].Param7[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_50_Data_8_CntList[i] = 1;
            A_ASG_49_0_0_50_ArrayDataList[i].Param8_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_50_Data_8_CntList[i] = 0;
            A_ASG_49_0_0_50_ArrayDataList[i].Param8_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_50_ArrayDataList[i].Param8_Length; j++)
        {
            A_ASG_49_0_0_50_ArrayDataList[i].Param8[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_50_DataIndex);
    putValue(A_ASG_49_0_0_50_Data_1, A_ASG_49_0_0_50_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_50_Data_2, A_ASG_49_0_0_50_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_50_Data_3, A_ASG_49_0_0_50_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_50_Data_4_len, A_ASG_49_0_0_50_Data_4_LenList[index]);
    putValue(A_ASG_49_0_0_50_Data_4_cnt, A_ASG_49_0_0_50_Data_4_CntList[index]);
    putValue(A_ASG_49_0_0_50_Data_4, A_ASG_49_0_0_50_ArrayDataList[index].Param4, A_ASG_49_0_0_50_ArrayDataList[index].Param4_Length);
    putValue(A_ASG_49_0_0_50_Data_5_len, A_ASG_49_0_0_50_Data_5_LenList[index]);
    putValue(A_ASG_49_0_0_50_Data_5_cnt, A_ASG_49_0_0_50_Data_5_CntList[index]);
    putValue(A_ASG_49_0_0_50_Data_5, A_ASG_49_0_0_50_ArrayDataList[index].Param5, A_ASG_49_0_0_50_ArrayDataList[index].Param5_Length);
    putValue(A_ASG_49_0_0_50_Data_6, A_ASG_49_0_0_50_ArrayDataList[index].Param6);
    putValue(A_ASG_49_0_0_50_Data_7_len, A_ASG_49_0_0_50_Data_7_LenList[index]);
    putValue(A_ASG_49_0_0_50_Data_7_cnt, A_ASG_49_0_0_50_Data_7_CntList[index]);
    putValue(A_ASG_49_0_0_50_Data_7, A_ASG_49_0_0_50_ArrayDataList[index].Param7, A_ASG_49_0_0_50_ArrayDataList[index].Param7_Length);
    putValue(A_ASG_49_0_0_50_Data_8_len, A_ASG_49_0_0_50_Data_8_LenList[index]);
    putValue(A_ASG_49_0_0_50_Data_8_cnt, A_ASG_49_0_0_50_Data_8_CntList[index]);
    putValue(A_ASG_49_0_0_50_Data_8, A_ASG_49_0_0_50_ArrayDataList[index].Param8, A_ASG_49_0_0_50_ArrayDataList[index].Param8_Length);
}

A_ASG_49_0_0_50_ChangedInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[604];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_50_Changed, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_50_Changed, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_50_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 50");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_50_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_50_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 50");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_50_DataIndex);
}




on envVar A_ASG_49_0_0_50_1
{
	byte superval[604];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_50_2_range // SiriusAlertList.TAID 
{
	@A_ASG_49_0_0_50_2 = @A_ASG_49_0_0_50_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_50_2
{
	byte superval[604];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_50_2, 1.0);
	@A_ASG_49_0_0_50_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_50_3_range // SiriusAlertList.TotalNumListElements 
{
	@A_ASG_49_0_0_50_3 = @A_ASG_49_0_0_50_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_50_3
{
	byte superval[604];

	//Update Childvalue (Number)
	word thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_50_3, 1.0);
	@A_ASG_49_0_0_50_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_50_Data_1_range // SiriusAlertList.Pos 
{
	@A_ASG_49_0_0_50_Data_1 = @A_ASG_49_0_0_50_Data_1_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_50_Data_1
{
	byte superval[604];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_50_Data_1, 1.0);
	@A_ASG_49_0_0_50_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param1 = thisval;
}
on envVar A_ASG_49_0_0_50_Data_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_50_Data_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_ASG_49_0_0_50_Data_2,thisval);
}

on envVar A_ASG_49_0_0_50_Data_2_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_50_Data_2);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_ASG_49_0_0_50_Data_2,thisval);
}

on envVar A_ASG_49_0_0_50_Data_2_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_50_Data_2);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(A_ASG_49_0_0_50_Data_2,thisval);
}

on envVar A_ASG_49_0_0_50_Data_2_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_50_Data_2);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(A_ASG_49_0_0_50_Data_2,thisval);
}

on envVar A_ASG_49_0_0_50_Data_2_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_50_Data_2);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(A_ASG_49_0_0_50_Data_2,thisval);
}

on envVar A_ASG_49_0_0_50_Data_2_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_50_Data_2);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(A_ASG_49_0_0_50_Data_2,thisval);
}

on envVar A_ASG_49_0_0_50_Data_2_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_50_Data_2);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(A_ASG_49_0_0_50_Data_2,thisval);
}

on envVar A_ASG_49_0_0_50_Data_2
{
	byte superval[604];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	word thisval; // Attributes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_ASG_49_0_0_50_Data_2_0, 1);
	else
		putValue(A_ASG_49_0_0_50_Data_2_0, 0);
	if(thisval&(mask<<1))
		putValue(A_ASG_49_0_0_50_Data_2_1, 1);
	else
		putValue(A_ASG_49_0_0_50_Data_2_1, 0);
	if(thisval&(mask<<2))
		putValue(A_ASG_49_0_0_50_Data_2_2, 1);
	else
		putValue(A_ASG_49_0_0_50_Data_2_2, 0);
	if(thisval&(mask<<3))
		putValue(A_ASG_49_0_0_50_Data_2_3, 1);
	else
		putValue(A_ASG_49_0_0_50_Data_2_3, 0);
	if(thisval&(mask<<4))
		putValue(A_ASG_49_0_0_50_Data_2_4, 1);
	else
		putValue(A_ASG_49_0_0_50_Data_2_4, 0);
	if(thisval&(mask<<5))
		putValue(A_ASG_49_0_0_50_Data_2_5, 1);
	else
		putValue(A_ASG_49_0_0_50_Data_2_5, 0);
	if(thisval&(mask<<6))
		putValue(A_ASG_49_0_0_50_Data_2_6, 1);
	else
		putValue(A_ASG_49_0_0_50_Data_2_6, 0);
    A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param2 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_50_Data_3_range // SiriusAlertList.PresetID 
{
	@A_ASG_49_0_0_50_Data_3 = @A_ASG_49_0_0_50_Data_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_50_Data_3
{
	byte superval[604];

	//Update Childvalue (Number)
	byte thisval; // PresetID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_50_Data_3, 1.0);
	@A_ASG_49_0_0_50_Data_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_50_Data_4_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_50_Data_4_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_50_Data_4_CntList[ getValue(A_ASG_49_0_0_50_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_50_Data_4_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_50_Data_4_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_50_Data_4_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 48 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_50_Data_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 48);
		thisval = 48;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_50_Data_4_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param4_Length = thisval;
	A_ASG_49_0_0_50_Data_4_LenList[ getValue(A_ASG_49_0_0_50_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_50_Data_4_len, thisval);

}

on envVar A_ASG_49_0_0_50_Data_4
{
	byte superval[604];

	//Update Childvalue (String)
	word i;
	byte thisval[49];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param4[i] = thisval[i];
    A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param4_Length = getValueSize(this);
    A_ASG_49_0_0_50_Data_4_LenList[getValue(A_ASG_49_0_0_50_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_50_Data_4_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_50_Data_5_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_50_Data_5_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_50_Data_5_CntList[ getValue(A_ASG_49_0_0_50_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_50_Data_5_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_50_Data_5_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_50_Data_5_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 30 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_50_Data_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 30);
		thisval = 30;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_50_Data_5_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param5_Length = thisval;
	A_ASG_49_0_0_50_Data_5_LenList[ getValue(A_ASG_49_0_0_50_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_50_Data_5_len, thisval);

}

on envVar A_ASG_49_0_0_50_Data_5
{
	byte superval[604];

	//Update Childvalue (String)
	word i;
	byte thisval[31];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param5[i] = thisval[i];
    A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param5_Length = getValueSize(this);
    A_ASG_49_0_0_50_Data_5_LenList[getValue(A_ASG_49_0_0_50_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_50_Data_5_len, getValueSize(this));
}
on envVar A_ASG_49_0_0_50_Data_6
{
	byte superval[604];

	//Update Childvalue (Enum)
	byte thisval; // AlertType
	thisval = getValue(this);
    A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param6 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_50_Data_7_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_50_Data_7_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_50_Data_7_CntList[ getValue(A_ASG_49_0_0_50_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_50_Data_7_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_50_Data_7_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_50_Data_7_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 60 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_50_Data_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 60);
		thisval = 60;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_50_Data_7_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param7_Length = thisval;
	A_ASG_49_0_0_50_Data_7_LenList[ getValue(A_ASG_49_0_0_50_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_50_Data_7_len, thisval);

}

on envVar A_ASG_49_0_0_50_Data_7
{
	byte superval[604];

	//Update Childvalue (String)
	word i;
	byte thisval[61];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param7[i] = thisval[i];
    A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param7_Length = getValueSize(this);
    A_ASG_49_0_0_50_Data_7_LenList[getValue(A_ASG_49_0_0_50_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_50_Data_7_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_50_Data_8_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_50_Data_8_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_50_Data_8_CntList[ getValue(A_ASG_49_0_0_50_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_50_Data_8_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_50_Data_8_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_50_Data_8_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 1 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_50_Data_8 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 1);
		thisval = 1;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_50_Data_8_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param8_Length = thisval;
	A_ASG_49_0_0_50_Data_8_LenList[ getValue(A_ASG_49_0_0_50_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_50_Data_8_len, thisval);

}

on envVar A_ASG_49_0_0_50_Data_8
{
	byte superval[604];

	//Update Childvalue (String)
	word i;
	byte thisval[2];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param8[i] = thisval[i];
    A_ASG_49_0_0_50_ArrayDataList[getValue(A_ASG_49_0_0_50_DataIndex)].Param8_Length = getValueSize(this);
    A_ASG_49_0_0_50_Data_8_LenList[getValue(A_ASG_49_0_0_50_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_50_Data_8_len, getValueSize(this));
}
on envVar A_ASG_49_0_0_50_1_SetGet
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_50_2_SetGet_range // SiriusAlertList.TAID 
{
	@A_ASG_49_0_0_50_2_SetGet = @A_ASG_49_0_0_50_2_SetGet_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_50_2_SetGet
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_50_2_SetGet, 1.0);
	@A_ASG_49_0_0_50_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar P_ASG_49_0_0_51Get_BTN
{
 if (P_ASG_49_0_0_51Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_51_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_51",MakeRGB(255,255,255));
       P_ASG_49_0_0_51Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_51_ID, DataGet_REQ); 
       P_ASG_49_0_0_51Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_51 // bus value of CurrentStation_Handle2 (51).
{
	// opcodes: Error-Status
	word param1; // SiriusAlertList_FsgHandle
	word param2; // SiriusAlertList_FsgHandle_absolutePosition
	byte param3; // LastStationList_FsgHandle
	byte param4; // LastStationList_FsgHandle_absolutePosition
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[6];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_51, superval);
	///////// Start param1 - UINT16 /////////
	param1 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_51_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_51_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_ASG_49_0_0_51_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_ASG_49_0_0_51_4, round((param4 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_51_1_range // CurrentStation_Handle2.SiriusAlertList_FsgHandle 
{
	@P_ASG_49_0_0_51_1 = @P_ASG_49_0_0_51_1_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_51_1 // CurrentStation_Handle2.SiriusAlertList_FsgHandle
{
	byte superval[6];

	//Update Childvalue (Number)
	word thisval; // SiriusAlertList_FsgHandle
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_51_1, 1.0);
	@P_ASG_49_0_0_51_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_51, superval);
	superval[0]=thisval&0x00ff;
	superval[1]=(thisval&0xff00)>>8;
	putValue(P_ASG_49_0_0_51,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_51_2_range // CurrentStation_Handle2.SiriusAlertList_FsgHandle_absolutePosition 
{
	@P_ASG_49_0_0_51_2 = @P_ASG_49_0_0_51_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_51_2 // CurrentStation_Handle2.SiriusAlertList_FsgHandle_absolutePosition
{
	byte superval[6];

	//Update Childvalue (Number)
	word thisval; // SiriusAlertList_FsgHandle_absolutePosition
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_51_2, 1.0);
	@P_ASG_49_0_0_51_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_51, superval);
	superval[2]=thisval&0x00ff;
	superval[3]=(thisval&0xff00)>>8;
	putValue(P_ASG_49_0_0_51,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_51_3_range // CurrentStation_Handle2.LastStationList_FsgHandle 
{
	@P_ASG_49_0_0_51_3 = @P_ASG_49_0_0_51_3_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_51_3 // CurrentStation_Handle2.LastStationList_FsgHandle
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // LastStationList_FsgHandle
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_51_3, 1.0);
	@P_ASG_49_0_0_51_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_51, superval);
	superval[4]=thisval;
	putValue(P_ASG_49_0_0_51,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_51_4_range // CurrentStation_Handle2.LastStationList_FsgHandle_absolutePosition 
{
	@P_ASG_49_0_0_51_4 = @P_ASG_49_0_0_51_4_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_51_4 // CurrentStation_Handle2.LastStationList_FsgHandle_absolutePosition
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // LastStationList_FsgHandle_absolutePosition
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_51_4, 1.0);
	@P_ASG_49_0_0_51_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_51, superval);
	superval[5]=thisval;
	putValue(P_ASG_49_0_0_51,superval);
}

on envVar P_ASG_49_0_0_52Get_BTN
{
 if (P_ASG_49_0_0_52Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_52_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_52",MakeRGB(255,255,255));
       P_ASG_49_0_0_52Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_52_ID, DataGet_REQ); 
       P_ASG_49_0_0_52Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_52 // bus value of PlayPosition (52).
{
	// opcodes: Error-Status
	word param1; // TimePosition
	word param2; // TotalPlayTime
	byte param3; // Attributes
	byte param4; // BufferLevel
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[6];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_52, superval);
	///////// Start param1 - UINT16 /////////
	param1 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_52_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_52_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_ASG_49_0_0_52_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_ASG_49_0_0_52_4, round((param4 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_52_1_range // PlayPosition.TimePosition 
{
	@P_ASG_49_0_0_52_1 = @P_ASG_49_0_0_52_1_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_52_1 // PlayPosition.TimePosition
{
	byte superval[6];

	//Update Childvalue (Number)
	word thisval; // TimePosition
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_52_1, 1.0);
	@P_ASG_49_0_0_52_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_52, superval);
	superval[0]=thisval&0x00ff;
	superval[1]=(thisval&0xff00)>>8;
	putValue(P_ASG_49_0_0_52,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_52_2_range // PlayPosition.TotalPlayTime 
{
	@P_ASG_49_0_0_52_2 = @P_ASG_49_0_0_52_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_52_2 // PlayPosition.TotalPlayTime
{
	byte superval[6];

	//Update Childvalue (Number)
	word thisval; // TotalPlayTime
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_52_2, 1.0);
	@P_ASG_49_0_0_52_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_52, superval);
	superval[2]=thisval&0x00ff;
	superval[3]=(thisval&0xff00)>>8;
	putValue(P_ASG_49_0_0_52,superval);
}

on envVar P_ASG_49_0_0_52_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_52_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_52_3,thisval);
}

on envVar P_ASG_49_0_0_52_3 // PlayPosition.Attributes
{
	byte superval[6];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Attributes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_ASG_49_0_0_52_3_0, 1);
	else
		putValue(P_ASG_49_0_0_52_3_0, 0);

    // Update superval
	getValue(P_ASG_49_0_0_52, superval);
	superval[4]=thisval;
	putValue(P_ASG_49_0_0_52,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_52_4_range // PlayPosition.BufferLevel 
{
	@P_ASG_49_0_0_52_4 = @P_ASG_49_0_0_52_4_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_52_4 // PlayPosition.BufferLevel
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // BufferLevel
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_52_4, 1.0);
	@P_ASG_49_0_0_52_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_52, superval);
	superval[5]=thisval;
	putValue(P_ASG_49_0_0_52,superval);
}

on envVar P_ASG_49_0_0_53Get_BTN
{
 if (P_ASG_49_0_0_53Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_53_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_53",MakeRGB(255,255,255));
       P_ASG_49_0_0_53Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_53_ID, DataGet_REQ); 
       P_ASG_49_0_0_53Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_53 // bus value of SDS_RecognizerState (53).
{
	// opcodes: Error-Status
	byte param1; // InputLevel
	byte param2; // InputQuality
	byte param3; // Extension1
	byte param4; // Extension2
	byte param5; // Extension3
	byte param6; // Extension4
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[6];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_53, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_53_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_53_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_ASG_49_0_0_53_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_ASG_49_0_0_53_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_ASG_49_0_0_53_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_ASG_49_0_0_53_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_53_1_range // SDS_RecognizerState.InputLevel 
{
	@P_ASG_49_0_0_53_1 = @P_ASG_49_0_0_53_1_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_53_1 // SDS_RecognizerState.InputLevel
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // InputLevel
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_53_1, 1.0);
	@P_ASG_49_0_0_53_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_53, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_53,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_53_2_range // SDS_RecognizerState.InputQuality 
{
	@P_ASG_49_0_0_53_2 = @P_ASG_49_0_0_53_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_53_2 // SDS_RecognizerState.InputQuality
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // InputQuality
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_53_2, 1.0);
	@P_ASG_49_0_0_53_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_53, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_53,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_53_3_range // SDS_RecognizerState.Extension1 
{
	@P_ASG_49_0_0_53_3 = @P_ASG_49_0_0_53_3_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_53_3 // SDS_RecognizerState.Extension1
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_53_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_53, superval);
	superval[2]=thisval;
	putValue(P_ASG_49_0_0_53,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_53_4_range // SDS_RecognizerState.Extension2 
{
	@P_ASG_49_0_0_53_4 = @P_ASG_49_0_0_53_4_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_53_4 // SDS_RecognizerState.Extension2
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_53_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_53, superval);
	superval[3]=thisval;
	putValue(P_ASG_49_0_0_53,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_53_5_range // SDS_RecognizerState.Extension3 
{
	@P_ASG_49_0_0_53_5 = @P_ASG_49_0_0_53_5_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_53_5 // SDS_RecognizerState.Extension3
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension3
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_53_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_53, superval);
	superval[4]=thisval;
	putValue(P_ASG_49_0_0_53,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_53_6_range // SDS_RecognizerState.Extension4 
{
	@P_ASG_49_0_0_53_6 = @P_ASG_49_0_0_53_6_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_53_6 // SDS_RecognizerState.Extension4
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension4
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_53_6_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_53, superval);
	superval[5]=thisval;
	putValue(P_ASG_49_0_0_53,superval);
}

on envVar P_ASG_49_0_0_54Get_BTN
{
 if (P_ASG_49_0_0_54Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_54_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_54",MakeRGB(255,255,255));
       P_ASG_49_0_0_54Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_54_ID, DataGet_REQ); 
       P_ASG_49_0_0_54Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_54 // bus value of CurrentStationInfo2 (54).
{
	// opcodes: Error-Status
	byte param1[73]; // Information1
	word len1;
	byte cnt1;
	byte param2; // Info_Type1
	word param3; // Information1_ID
	byte param4[73]; // Information2
	word len4;
	byte cnt4;
	byte param5; // Info_Type2
	byte param6[73]; // Information3
	word len6;
	byte cnt6;
	byte param7; // Info_Type3
	byte param8[73]; // Information4
	word len8;
	byte cnt8;
	byte param9; // Info_Type4
	byte param10[73]; // Information5
	word len10;
	byte cnt10;
	byte param11; // Info_Type5
	byte param12[73]; // Information6
	word len12;
	byte cnt12;
	byte param13; // Info_Type6
	byte param14[73]; // Information7
	word len14;
	byte cnt14;
	byte param15; // Info_Type7
	byte param16[73]; // Information8
	word len16;
	byte cnt16;
	byte param17; // Info_Type8
	word param18; // StationInfoSwitches
	word param19; // StationProperties
	word param20; // Channel_ID
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[600];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 600; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_54, superval);
	///////// Start param1 - STRING /////////
	getValue(P_ASG_49_0_0_54_1, param1);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt1 = 1;
		}
		else
		{
			len1 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_54 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len1 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt1 = 0;
	}
	
	if(len1 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
		len1 = 72;
	
		if(len1 < 128) cnt1 = 0;
		else cnt1 = 1;
	}
	
	for(i = 0; i < len1; i++)
	{
		param1[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_54_1_len, len1);
	putValue(P_ASG_49_0_0_54_1_cnt, cnt1);
	
	if(len1 > getValueSize(P_ASG_49_0_0_54_1))
		putValue(P_ASG_49_0_0_54_1, param1, len1);
	else
		putValue(P_ASG_49_0_0_54_1, param1, getValueSize(P_ASG_49_0_0_54_1));

	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_54_2, param2);
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_54_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - STRING /////////
	getValue(P_ASG_49_0_0_54_4, param4);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len4 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt4 = 1;
		}
		else
		{
			len4 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_54 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len4 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt4 = 0;
	}
	
	if(len4 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len4, currentPos);
		len4 = 72;
	
		if(len4 < 128) cnt4 = 0;
		else cnt4 = 1;
	}
	
	for(i = 0; i < len4; i++)
	{
		param4[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_54_4_len, len4);
	putValue(P_ASG_49_0_0_54_4_cnt, cnt4);
	
	if(len4 > getValueSize(P_ASG_49_0_0_54_4))
		putValue(P_ASG_49_0_0_54_4, param4, len4);
	else
		putValue(P_ASG_49_0_0_54_4, param4, getValueSize(P_ASG_49_0_0_54_4));

	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_ASG_49_0_0_54_5, param5);
	///////// Start param6 - STRING /////////
	getValue(P_ASG_49_0_0_54_6, param6);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len6 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt6 = 1;
		}
		else
		{
			len6 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_54 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len6 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt6 = 0;
	}
	
	if(len6 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len6, currentPos);
		len6 = 72;
	
		if(len6 < 128) cnt6 = 0;
		else cnt6 = 1;
	}
	
	for(i = 0; i < len6; i++)
	{
		param6[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_54_6_len, len6);
	putValue(P_ASG_49_0_0_54_6_cnt, cnt6);
	
	if(len6 > getValueSize(P_ASG_49_0_0_54_6))
		putValue(P_ASG_49_0_0_54_6, param6, len6);
	else
		putValue(P_ASG_49_0_0_54_6, param6, getValueSize(P_ASG_49_0_0_54_6));

	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_ASG_49_0_0_54_7, param7);
	///////// Start param8 - STRING /////////
	getValue(P_ASG_49_0_0_54_8, param8);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len8 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt8 = 1;
		}
		else
		{
			len8 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_54 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len8 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt8 = 0;
	}
	
	if(len8 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len8, currentPos);
		len8 = 72;
	
		if(len8 < 128) cnt8 = 0;
		else cnt8 = 1;
	}
	
	for(i = 0; i < len8; i++)
	{
		param8[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_54_8_len, len8);
	putValue(P_ASG_49_0_0_54_8_cnt, cnt8);
	
	if(len8 > getValueSize(P_ASG_49_0_0_54_8))
		putValue(P_ASG_49_0_0_54_8, param8, len8);
	else
		putValue(P_ASG_49_0_0_54_8, param8, getValueSize(P_ASG_49_0_0_54_8));

	///////// Start param9 - UINT8 /////////
	param9 = superval[currentPos++];
	putValue(P_ASG_49_0_0_54_9, param9);
	///////// Start param10 - STRING /////////
	getValue(P_ASG_49_0_0_54_10, param10);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len10 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt10 = 1;
		}
		else
		{
			len10 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_54 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len10 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt10 = 0;
	}
	
	if(len10 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len10, currentPos);
		len10 = 72;
	
		if(len10 < 128) cnt10 = 0;
		else cnt10 = 1;
	}
	
	for(i = 0; i < len10; i++)
	{
		param10[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_54_10_len, len10);
	putValue(P_ASG_49_0_0_54_10_cnt, cnt10);
	
	if(len10 > getValueSize(P_ASG_49_0_0_54_10))
		putValue(P_ASG_49_0_0_54_10, param10, len10);
	else
		putValue(P_ASG_49_0_0_54_10, param10, getValueSize(P_ASG_49_0_0_54_10));

	///////// Start param11 - UINT8 /////////
	param11 = superval[currentPos++];
	putValue(P_ASG_49_0_0_54_11, param11);
	///////// Start param12 - STRING /////////
	getValue(P_ASG_49_0_0_54_12, param12);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len12 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt12 = 1;
		}
		else
		{
			len12 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_54 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len12 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt12 = 0;
	}
	
	if(len12 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len12, currentPos);
		len12 = 72;
	
		if(len12 < 128) cnt12 = 0;
		else cnt12 = 1;
	}
	
	for(i = 0; i < len12; i++)
	{
		param12[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_54_12_len, len12);
	putValue(P_ASG_49_0_0_54_12_cnt, cnt12);
	
	if(len12 > getValueSize(P_ASG_49_0_0_54_12))
		putValue(P_ASG_49_0_0_54_12, param12, len12);
	else
		putValue(P_ASG_49_0_0_54_12, param12, getValueSize(P_ASG_49_0_0_54_12));

	///////// Start param13 - UINT8 /////////
	param13 = superval[currentPos++];
	putValue(P_ASG_49_0_0_54_13, param13);
	///////// Start param14 - STRING /////////
	getValue(P_ASG_49_0_0_54_14, param14);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len14 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt14 = 1;
		}
		else
		{
			len14 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_54 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len14 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt14 = 0;
	}
	
	if(len14 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len14, currentPos);
		len14 = 72;
	
		if(len14 < 128) cnt14 = 0;
		else cnt14 = 1;
	}
	
	for(i = 0; i < len14; i++)
	{
		param14[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_54_14_len, len14);
	putValue(P_ASG_49_0_0_54_14_cnt, cnt14);
	
	if(len14 > getValueSize(P_ASG_49_0_0_54_14))
		putValue(P_ASG_49_0_0_54_14, param14, len14);
	else
		putValue(P_ASG_49_0_0_54_14, param14, getValueSize(P_ASG_49_0_0_54_14));

	///////// Start param15 - UINT8 /////////
	param15 = superval[currentPos++];
	putValue(P_ASG_49_0_0_54_15, param15);
	///////// Start param16 - STRING /////////
	getValue(P_ASG_49_0_0_54_16, param16);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(72>127) /* Max Fct-Katalog Laenge: 72*/
		{
			len16 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt16 = 1;
		}
		else
		{
			len16 = 72;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_54 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len16 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt16 = 0;
	}
	
	if(len16 > 72)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len16, currentPos);
		len16 = 72;
	
		if(len16 < 128) cnt16 = 0;
		else cnt16 = 1;
	}
	
	for(i = 0; i < len16; i++)
	{
		param16[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_54_16_len, len16);
	putValue(P_ASG_49_0_0_54_16_cnt, cnt16);
	
	if(len16 > getValueSize(P_ASG_49_0_0_54_16))
		putValue(P_ASG_49_0_0_54_16, param16, len16);
	else
		putValue(P_ASG_49_0_0_54_16, param16, getValueSize(P_ASG_49_0_0_54_16));

	///////// Start param17 - UINT8 /////////
	param17 = superval[currentPos++];
	putValue(P_ASG_49_0_0_54_17, param17);
	///////// Start param18 - UINT16 /////////
	param18 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_54_18, param18);
	///////// Start param19 - UINT16 /////////
	param19 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_54_19, param19);
	///////// Start param20 - UINT16 /////////
	param20 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_54_20, round((param20 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_ASG_49_0_0_54_BuildFct()
{
	byte param1[73]; // Information1
	word len1;
	byte cnt1;
	byte param2; // Info_Type1
	word param3; // Information1_ID
	byte param4[73]; // Information2
	word len4;
	byte cnt4;
	byte param5; // Info_Type2
	byte param6[73]; // Information3
	word len6;
	byte cnt6;
	byte param7; // Info_Type3
	byte param8[73]; // Information4
	word len8;
	byte cnt8;
	byte param9; // Info_Type4
	byte param10[73]; // Information5
	word len10;
	byte cnt10;
	byte param11; // Info_Type5
	byte param12[73]; // Information6
	word len12;
	byte cnt12;
	byte param13; // Info_Type6
	byte param14[73]; // Information7
	word len14;
	byte cnt14;
	byte param15; // Info_Type7
	byte param16[73]; // Information8
	word len16;
	byte cnt16;
	byte param17; // Info_Type8
	word param18; // StationInfoSwitches
	word param19; // StationProperties
	word param20; // Channel_ID

	int i;
	byte superval[600];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_54_1, param1);
	len1 = getValue(P_ASG_49_0_0_54_1_len);
	cnt1= getValue(P_ASG_49_0_0_54_1_cnt);
	
	/* check box aktiviert*/
	if (cnt1 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len1 >= 0 && len1 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 72);
			return;
		}
	}
	else if(cnt1 == 0) /*check box deaktiviert*/
	{
		if(len1 >= 0 && len1 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos]= len1 & 0x00ff;
			putValue(P_ASG_49_0_0_54_1_len, len1);
		}
		else if(len1 > 127 && len1 <= 72)
		{
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
			putValue(P_ASG_49_0_0_54_1_len, len1);
			putValue(P_ASG_49_0_0_54_1_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 72);
			return;
		}
	}
	currentPos += cnt1+1;
	for(i = 0; i < len1; i++)
	{
		superval[currentPos++]= param1[i];
	}

// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_ASG_49_0_0_54_2);
	superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_54_3_range = round(@P_ASG_49_0_0_54_3 + (0), 1.0); // slider value + min = real value
	param3 = round( (@P_ASG_49_0_0_54_3 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param3&0x00ff;
	superval[currentPos++]=(param3&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_54_4, param4);
	len4 = getValue(P_ASG_49_0_0_54_4_len);
	cnt4= getValue(P_ASG_49_0_0_54_4_cnt);
	
	/* check box aktiviert*/
	if (cnt4 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len4 >= 0 && len4 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
			superval[currentPos] = (len4&0x7f00) | 0x80;
			superval[currentPos+1] = len4 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 72);
			return;
		}
	}
	else if(cnt4 == 0) /*check box deaktiviert*/
	{
		if(len4 >= 0 && len4 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
			superval[currentPos]= len4 & 0x00ff;
			putValue(P_ASG_49_0_0_54_4_len, len4);
		}
		else if(len4 > 127 && len4 <= 72)
		{
			superval[currentPos] = (len4&0x7f00) | 0x80;
			superval[currentPos+1] = len4 & 0x00ff;
			putValue(P_ASG_49_0_0_54_4_len, len4);
			putValue(P_ASG_49_0_0_54_4_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 72);
			return;
		}
	}
	currentPos += cnt4+1;
	for(i = 0; i < len4; i++)
	{
		superval[currentPos++]= param4[i];
	}

// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_ASG_49_0_0_54_5);
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_54_6, param6);
	len6 = getValue(P_ASG_49_0_0_54_6_len);
	cnt6= getValue(P_ASG_49_0_0_54_6_cnt);
	
	/* check box aktiviert*/
	if (cnt6 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len6 >= 0 && len6 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
			superval[currentPos] = (len6&0x7f00) | 0x80;
			superval[currentPos+1] = len6 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 72);
			return;
		}
	}
	else if(cnt6 == 0) /*check box deaktiviert*/
	{
		if(len6 >= 0 && len6 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len6: %d", len6);
			superval[currentPos]= len6 & 0x00ff;
			putValue(P_ASG_49_0_0_54_6_len, len6);
		}
		else if(len6 > 127 && len6 <= 72)
		{
			superval[currentPos] = (len6&0x7f00) | 0x80;
			superval[currentPos+1] = len6 & 0x00ff;
			putValue(P_ASG_49_0_0_54_6_len, len6);
			putValue(P_ASG_49_0_0_54_6_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_6 ist ungueltig. Die max. erlaubte Laenge ist %d.", len6, 72);
			return;
		}
	}
	currentPos += cnt6+1;
	for(i = 0; i < len6; i++)
	{
		superval[currentPos++]= param6[i];
	}

// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_ASG_49_0_0_54_7);
	superval[currentPos++]=param7;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_54_8, param8);
	len8 = getValue(P_ASG_49_0_0_54_8_len);
	cnt8= getValue(P_ASG_49_0_0_54_8_cnt);
	
	/* check box aktiviert*/
	if (cnt8 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len8 >= 0 && len8 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
			superval[currentPos] = (len8&0x7f00) | 0x80;
			superval[currentPos+1] = len8 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 72);
			return;
		}
	}
	else if(cnt8 == 0) /*check box deaktiviert*/
	{
		if(len8 >= 0 && len8 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
			superval[currentPos]= len8 & 0x00ff;
			putValue(P_ASG_49_0_0_54_8_len, len8);
		}
		else if(len8 > 127 && len8 <= 72)
		{
			superval[currentPos] = (len8&0x7f00) | 0x80;
			superval[currentPos+1] = len8 & 0x00ff;
			putValue(P_ASG_49_0_0_54_8_len, len8);
			putValue(P_ASG_49_0_0_54_8_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 72);
			return;
		}
	}
	currentPos += cnt8+1;
	for(i = 0; i < len8; i++)
	{
		superval[currentPos++]= param8[i];
	}

// gen_BuildFunc_SetSuperVals 
	param9 = getValue(P_ASG_49_0_0_54_9);
	superval[currentPos++]=param9;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_54_10, param10);
	len10 = getValue(P_ASG_49_0_0_54_10_len);
	cnt10= getValue(P_ASG_49_0_0_54_10_cnt);
	
	/* check box aktiviert*/
	if (cnt10 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len10 >= 0 && len10 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len10: %d", len10);
			superval[currentPos] = (len10&0x7f00) | 0x80;
			superval[currentPos+1] = len10 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_10 ist ungueltig. Die max. erlaubte Laenge ist %d.", len10, 72);
			return;
		}
	}
	else if(cnt10 == 0) /*check box deaktiviert*/
	{
		if(len10 >= 0 && len10 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len10: %d", len10);
			superval[currentPos]= len10 & 0x00ff;
			putValue(P_ASG_49_0_0_54_10_len, len10);
		}
		else if(len10 > 127 && len10 <= 72)
		{
			superval[currentPos] = (len10&0x7f00) | 0x80;
			superval[currentPos+1] = len10 & 0x00ff;
			putValue(P_ASG_49_0_0_54_10_len, len10);
			putValue(P_ASG_49_0_0_54_10_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_10 ist ungueltig. Die max. erlaubte Laenge ist %d.", len10, 72);
			return;
		}
	}
	currentPos += cnt10+1;
	for(i = 0; i < len10; i++)
	{
		superval[currentPos++]= param10[i];
	}

// gen_BuildFunc_SetSuperVals 
	param11 = getValue(P_ASG_49_0_0_54_11);
	superval[currentPos++]=param11;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_54_12, param12);
	len12 = getValue(P_ASG_49_0_0_54_12_len);
	cnt12= getValue(P_ASG_49_0_0_54_12_cnt);
	
	/* check box aktiviert*/
	if (cnt12 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len12 >= 0 && len12 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len12: %d", len12);
			superval[currentPos] = (len12&0x7f00) | 0x80;
			superval[currentPos+1] = len12 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_12 ist ungueltig. Die max. erlaubte Laenge ist %d.", len12, 72);
			return;
		}
	}
	else if(cnt12 == 0) /*check box deaktiviert*/
	{
		if(len12 >= 0 && len12 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len12: %d", len12);
			superval[currentPos]= len12 & 0x00ff;
			putValue(P_ASG_49_0_0_54_12_len, len12);
		}
		else if(len12 > 127 && len12 <= 72)
		{
			superval[currentPos] = (len12&0x7f00) | 0x80;
			superval[currentPos+1] = len12 & 0x00ff;
			putValue(P_ASG_49_0_0_54_12_len, len12);
			putValue(P_ASG_49_0_0_54_12_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_12 ist ungueltig. Die max. erlaubte Laenge ist %d.", len12, 72);
			return;
		}
	}
	currentPos += cnt12+1;
	for(i = 0; i < len12; i++)
	{
		superval[currentPos++]= param12[i];
	}

// gen_BuildFunc_SetSuperVals 
	param13 = getValue(P_ASG_49_0_0_54_13);
	superval[currentPos++]=param13;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_54_14, param14);
	len14 = getValue(P_ASG_49_0_0_54_14_len);
	cnt14= getValue(P_ASG_49_0_0_54_14_cnt);
	
	/* check box aktiviert*/
	if (cnt14 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len14 >= 0 && len14 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len14: %d", len14);
			superval[currentPos] = (len14&0x7f00) | 0x80;
			superval[currentPos+1] = len14 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_14 ist ungueltig. Die max. erlaubte Laenge ist %d.", len14, 72);
			return;
		}
	}
	else if(cnt14 == 0) /*check box deaktiviert*/
	{
		if(len14 >= 0 && len14 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len14: %d", len14);
			superval[currentPos]= len14 & 0x00ff;
			putValue(P_ASG_49_0_0_54_14_len, len14);
		}
		else if(len14 > 127 && len14 <= 72)
		{
			superval[currentPos] = (len14&0x7f00) | 0x80;
			superval[currentPos+1] = len14 & 0x00ff;
			putValue(P_ASG_49_0_0_54_14_len, len14);
			putValue(P_ASG_49_0_0_54_14_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_14 ist ungueltig. Die max. erlaubte Laenge ist %d.", len14, 72);
			return;
		}
	}
	currentPos += cnt14+1;
	for(i = 0; i < len14; i++)
	{
		superval[currentPos++]= param14[i];
	}

// gen_BuildFunc_SetSuperVals 
	param15 = getValue(P_ASG_49_0_0_54_15);
	superval[currentPos++]=param15;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_54_16, param16);
	len16 = getValue(P_ASG_49_0_0_54_16_len);
	cnt16= getValue(P_ASG_49_0_0_54_16_cnt);
	
	/* check box aktiviert*/
	if (cnt16 == 1)
	{
		/* 0 bis 72 (MaxString - 1B oder 2B) */
		if(len16 >= 0 && len16 <= 72)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len16: %d", len16);
			superval[currentPos] = (len16&0x7f00) | 0x80;
			superval[currentPos+1] = len16 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_16 ist ungueltig. Die max. erlaubte Laenge ist %d.", len16, 72);
			return;
		}
	}
	else if(cnt16 == 0) /*check box deaktiviert*/
	{
		if(len16 >= 0 && len16 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len16: %d", len16);
			superval[currentPos]= len16 & 0x00ff;
			putValue(P_ASG_49_0_0_54_16_len, len16);
		}
		else if(len16 > 127 && len16 <= 72)
		{
			superval[currentPos] = (len16&0x7f00) | 0x80;
			superval[currentPos+1] = len16 & 0x00ff;
			putValue(P_ASG_49_0_0_54_16_len, len16);
			putValue(P_ASG_49_0_0_54_16_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_16 ist ungueltig. Die max. erlaubte Laenge ist %d.", len16, 72);
			return;
		}
	}
	currentPos += cnt16+1;
	for(i = 0; i < len16; i++)
	{
		superval[currentPos++]= param16[i];
	}

// gen_BuildFunc_SetSuperVals 
	param17 = getValue(P_ASG_49_0_0_54_17);
	superval[currentPos++]=param17;
// gen_BuildFunc_SetSuperVals 
	param18 = getValue(P_ASG_49_0_0_54_18);
	@P_ASG_49_0_0_54_18_0 = (param18 & 1) > 0;
	@P_ASG_49_0_0_54_18_1 = (param18 & 2) > 0;
	@P_ASG_49_0_0_54_18_2 = (param18 & 4) > 0;
	@P_ASG_49_0_0_54_18_3 = (param18 & 8) > 0;
	@P_ASG_49_0_0_54_18_4 = (param18 & 16) > 0;
	superval[currentPos++]=param18&0x00ff;
	superval[currentPos++]=(param18&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	param19 = getValue(P_ASG_49_0_0_54_19);
	@P_ASG_49_0_0_54_19_0 = (param19 & 1) > 0;
	@P_ASG_49_0_0_54_19_1 = (param19 & 2) > 0;
	@P_ASG_49_0_0_54_19_2 = (param19 & 4) > 0;
	@P_ASG_49_0_0_54_19_3 = (param19 & 8) > 0;
	@P_ASG_49_0_0_54_19_4 = (param19 & 16) > 0;
	@P_ASG_49_0_0_54_19_5 = (param19 & 32) > 0;
	@P_ASG_49_0_0_54_19_6 = (param19 & 64) > 0;
	superval[currentPos++]=param19&0x00ff;
	superval[currentPos++]=(param19&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_54_20_range = round(@P_ASG_49_0_0_54_20 + (0), 1.0); // slider value + min = real value
	param20 = round( (@P_ASG_49_0_0_54_20 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param20&0x00ff;
	superval[currentPos++]=(param20&0xff00)>>8;
	putValue(P_ASG_49_0_0_54, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_54_1_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_54_1_len);
	cnt = getValue(P_ASG_49_0_0_54_1_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_54_1_len, 127);
		}
	}

	P_ASG_49_0_0_54_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_54_1_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_54_BuildFct();
}


on envVar P_ASG_49_0_0_54_1 // CurrentStationInfo2.Information1
{
	putValue(P_ASG_49_0_0_54_1_len, getValueSize(this));
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_54_2 // CurrentStationInfo2.Info_Type1
{
	P_ASG_49_0_0_54_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_54_3_range // CurrentStationInfo2.Information1_ID 
{
	@P_ASG_49_0_0_54_3 = @P_ASG_49_0_0_54_3_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_54_3 // CurrentStationInfo2.Information1_ID
{
	P_ASG_49_0_0_54_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_54_4_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_54_4_len);
	cnt = getValue(P_ASG_49_0_0_54_4_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_54_4_len, 127);
		}
	}

	P_ASG_49_0_0_54_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_54_4_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_54_BuildFct();
}


on envVar P_ASG_49_0_0_54_4 // CurrentStationInfo2.Information2
{
	putValue(P_ASG_49_0_0_54_4_len, getValueSize(this));
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_54_5 // CurrentStationInfo2.Info_Type2
{
	P_ASG_49_0_0_54_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_54_6_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_54_6_len);
	cnt = getValue(P_ASG_49_0_0_54_6_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_54_6_len, 127);
		}
	}

	P_ASG_49_0_0_54_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_54_6_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_54_BuildFct();
}


on envVar P_ASG_49_0_0_54_6 // CurrentStationInfo2.Information3
{
	putValue(P_ASG_49_0_0_54_6_len, getValueSize(this));
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_54_7 // CurrentStationInfo2.Info_Type3
{
	P_ASG_49_0_0_54_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_54_8_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_54_8_len);
	cnt = getValue(P_ASG_49_0_0_54_8_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_54_8_len, 127);
		}
	}

	P_ASG_49_0_0_54_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_54_8_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_8 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_54_BuildFct();
}


on envVar P_ASG_49_0_0_54_8 // CurrentStationInfo2.Information4
{
	putValue(P_ASG_49_0_0_54_8_len, getValueSize(this));
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_54_9 // CurrentStationInfo2.Info_Type4
{
	P_ASG_49_0_0_54_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_54_10_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_54_10_len);
	cnt = getValue(P_ASG_49_0_0_54_10_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_54_10_len, 127);
		}
	}

	P_ASG_49_0_0_54_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_54_10_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_10 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_54_BuildFct();
}


on envVar P_ASG_49_0_0_54_10 // CurrentStationInfo2.Information5
{
	putValue(P_ASG_49_0_0_54_10_len, getValueSize(this));
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_54_11 // CurrentStationInfo2.Info_Type5
{
	P_ASG_49_0_0_54_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_54_12_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_54_12_len);
	cnt = getValue(P_ASG_49_0_0_54_12_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_54_12_len, 127);
		}
	}

	P_ASG_49_0_0_54_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_54_12_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_12 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_54_BuildFct();
}


on envVar P_ASG_49_0_0_54_12 // CurrentStationInfo2.Information6
{
	putValue(P_ASG_49_0_0_54_12_len, getValueSize(this));
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_54_13 // CurrentStationInfo2.Info_Type6
{
	P_ASG_49_0_0_54_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_54_14_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_54_14_len);
	cnt = getValue(P_ASG_49_0_0_54_14_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_54_14_len, 127);
		}
	}

	P_ASG_49_0_0_54_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_54_14_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_14 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_54_BuildFct();
}


on envVar P_ASG_49_0_0_54_14 // CurrentStationInfo2.Information7
{
	putValue(P_ASG_49_0_0_54_14_len, getValueSize(this));
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_54_15 // CurrentStationInfo2.Info_Type7
{
	P_ASG_49_0_0_54_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_54_16_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_54_16_len);
	cnt = getValue(P_ASG_49_0_0_54_16_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_54_16_len, 127);
		}
	}

	P_ASG_49_0_0_54_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_54_16_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 72)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_54_16 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 72);
		putValue(this, 72);
	}
	P_ASG_49_0_0_54_BuildFct();
}


on envVar P_ASG_49_0_0_54_16 // CurrentStationInfo2.Information8
{
	putValue(P_ASG_49_0_0_54_16_len, getValueSize(this));
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_54_17 // CurrentStationInfo2.Info_Type8
{
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_54_18_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationInfoSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_18);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_54_18,thisval);
}

on envVar P_ASG_49_0_0_54_18_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationInfoSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_18);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_54_18,thisval);
}

on envVar P_ASG_49_0_0_54_18_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationInfoSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_18);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_54_18,thisval);
}

on envVar P_ASG_49_0_0_54_18_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationInfoSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_18);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_54_18,thisval);
}

on envVar P_ASG_49_0_0_54_18_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationInfoSwitches
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_18);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_54_18,thisval);
}

on envVar P_ASG_49_0_0_54_18 // CurrentStationInfo2.StationInfoSwitches
{
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_54_19_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_19);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_ASG_49_0_0_54_19,thisval);
}

on envVar P_ASG_49_0_0_54_19_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_19);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_ASG_49_0_0_54_19,thisval);
}

on envVar P_ASG_49_0_0_54_19_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_19);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_ASG_49_0_0_54_19,thisval);
}

on envVar P_ASG_49_0_0_54_19_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_19);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_ASG_49_0_0_54_19,thisval);
}

on envVar P_ASG_49_0_0_54_19_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_19);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_ASG_49_0_0_54_19,thisval);
}

on envVar P_ASG_49_0_0_54_19_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_19);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_ASG_49_0_0_54_19,thisval);
}

on envVar P_ASG_49_0_0_54_19_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // StationProperties
	bitval= getValue(this);
	thisval = getValue(P_ASG_49_0_0_54_19);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_ASG_49_0_0_54_19,thisval);
}

on envVar P_ASG_49_0_0_54_19 // CurrentStationInfo2.StationProperties
{
	P_ASG_49_0_0_54_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_54_20_range // CurrentStationInfo2.Channel_ID 
{
	@P_ASG_49_0_0_54_20 = @P_ASG_49_0_0_54_20_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_54_20 // CurrentStationInfo2.Channel_ID
{
	P_ASG_49_0_0_54_BuildFct();
}

on envVar P_ASG_49_0_0_55Get_BTN
{
 if (P_ASG_49_0_0_55Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_55_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_55",MakeRGB(255,255,255));
       P_ASG_49_0_0_55Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_55_ID, DataGet_REQ); 
       P_ASG_49_0_0_55Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_55 // bus value of CurrentStation_Handle3 (55).
{
	// opcodes: Error-Status
	byte param1; // FavoriteList_FsgHandle
	byte param2; // FavoriteList_FsgHandle_absolutePosition
	byte param3; // Extension1
	byte param4; // Extension2
	byte param5; // Extension3
	byte param6; // Extension4
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[6];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_55, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_55_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_ASG_49_0_0_55_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_ASG_49_0_0_55_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_ASG_49_0_0_55_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_ASG_49_0_0_55_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_ASG_49_0_0_55_6, round((param6 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_55_1_range // CurrentStation_Handle3.FavoriteList_FsgHandle 
{
	@P_ASG_49_0_0_55_1 = @P_ASG_49_0_0_55_1_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_55_1 // CurrentStation_Handle3.FavoriteList_FsgHandle
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // FavoriteList_FsgHandle
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_55_1, 1.0);
	@P_ASG_49_0_0_55_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_55, superval);
	superval[0]=thisval;
	putValue(P_ASG_49_0_0_55,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_55_2_range // CurrentStation_Handle3.FavoriteList_FsgHandle_absolutePosition 
{
	@P_ASG_49_0_0_55_2 = @P_ASG_49_0_0_55_2_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_55_2 // CurrentStation_Handle3.FavoriteList_FsgHandle_absolutePosition
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // FavoriteList_FsgHandle_absolutePosition
	float slider_value;

	slider_value = round(@P_ASG_49_0_0_55_2, 1.0);
	@P_ASG_49_0_0_55_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_55, superval);
	superval[1]=thisval;
	putValue(P_ASG_49_0_0_55,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_55_3_range // CurrentStation_Handle3.Extension1 
{
	@P_ASG_49_0_0_55_3 = @P_ASG_49_0_0_55_3_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_55_3 // CurrentStation_Handle3.Extension1
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_55_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_55, superval);
	superval[2]=thisval;
	putValue(P_ASG_49_0_0_55,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_55_4_range // CurrentStation_Handle3.Extension2 
{
	@P_ASG_49_0_0_55_4 = @P_ASG_49_0_0_55_4_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_55_4 // CurrentStation_Handle3.Extension2
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_55_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_55, superval);
	superval[3]=thisval;
	putValue(P_ASG_49_0_0_55,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_55_5_range // CurrentStation_Handle3.Extension3 
{
	@P_ASG_49_0_0_55_5 = @P_ASG_49_0_0_55_5_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_55_5 // CurrentStation_Handle3.Extension3
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension3
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_55_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_55, superval);
	superval[4]=thisval;
	putValue(P_ASG_49_0_0_55,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_55_6_range // CurrentStation_Handle3.Extension4 
{
	@P_ASG_49_0_0_55_6 = @P_ASG_49_0_0_55_6_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_55_6 // CurrentStation_Handle3.Extension4
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension4
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_55_6_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_55, superval);
	superval[5]=thisval;
	putValue(P_ASG_49_0_0_55,superval);
}

on envVar A_ASG_49_0_0_56Get_BTN
{
  byte data[5]; 
  byte stringValue[5];
  byte head[5];
  int i;
  int headLength;
  long tempValue;
  word currentPos;
  word startVal;
  word elementsVal;
  byte nibbleSetted;
  if (A_ASG_49_0_0_56Get_BTN_already_pressed == 0)
  {
     putValue(A_ASG_49_0_0_56_ErrCode,0);
     SetControlBackColor(panel_name,"errField_A_ASG_49_0_0_56",MakeRGB(255,255,255));
     A_ASG_49_0_0_56Get_BTN_already_pressed = 1;
  }
  else
  {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_ASG_49_0_0_56_1_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_ASG_49_0_0_56_2_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //head Parameter
        headLength = getValueSize(A_ASG_49_0_0_56_SetGet);
        getValue(A_ASG_49_0_0_56_SetGet,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }

     Request_ByteSequence(LSGID, A_ASG_49_0_0_56_ID, DataGet_REQ, data, currentPos);
     if(getValue(A_ASG_49_0_0_56_IntTlgEn)) //getValue(IT))
     {
       intertelegram_err(A_ASG_49_0_0_56_ID);
     }
     if(getValue(A_ASG_49_0_0_56_SegmEn))   //getvalue(SG)
     {
         sequence_err(A_ASG_49_0_0_56_ID,getValueSize(A_ASG_49_0_0_56_SetGet));
     }
     A_ASG_49_0_0_56Get_BTN_already_pressed = 0;
  }
}
A_ASG_49_0_0_56_SetGet_GenerateSetGet()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_ASG_49_0_0_56_SetGet_RecAdr) > 0x0F)
        putValue(A_ASG_49_0_0_56_SetGet_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_ASG_49_0_0_56_SetGet_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_ASG_49_0_0_56_SetGet_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_ASG_49_0_0_56_SetGet_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // reserverd:  Byte 0 Bit 6
    if( getValue(A_ASG_49_0_0_56_SetGet_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_ASG_49_0_0_56_SetGet_Start) & 0xFF;
        head[2] = (getValue(A_ASG_49_0_0_56_SetGet_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_ASG_49_0_0_56_SetGet_Elements) & 0xFF;
        head[4] = (getValue(A_ASG_49_0_0_56_SetGet_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_ASG_49_0_0_56_SetGet, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_ASG_49_0_0_56_SetGet_Start) & 0xFF;
        head[2] = getValue(A_ASG_49_0_0_56_SetGet_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_ASG_49_0_0_56_SetGet, head, 3); 
    }
}

on envVar A_ASG_49_0_0_56_SetGet_RecAdr
{
    A_ASG_49_0_0_56_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_56_SetGet_Shift
{
    A_ASG_49_0_0_56_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_56_SetGet_Direction
{
    A_ASG_49_0_0_56_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_56_SetGet_Start
{
    A_ASG_49_0_0_56_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_56_SetGet_Elements
{
    A_ASG_49_0_0_56_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_56_SetGet_IndexSize
{
    A_ASG_49_0_0_56_SetGet_GenerateSetGet();
}
on envVar A_ASG_49_0_0_56
{
    byte temp[5];
    byte head[5];
    getValue(A_ASG_49_0_0_56, head);
    putValue(A_ASG_49_0_0_56_RecAdr, 0x0F & head[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & head[0]) >0)
        putValue(A_ASG_49_0_0_56_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & head[0]) >0)
        putValue(A_ASG_49_0_0_56_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & head[0]) >0)
        putValue(A_ASG_49_0_0_56_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & head[0]) >0)
        putValue(A_ASG_49_0_0_56_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_56_IndexSize))
    {
        putValue(A_ASG_49_0_0_56_Start, ((head[2]<<8)| head[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_56_Elements, ((head[4]<<8)| head[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_56_Start, head[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_56_Elements, head[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_56_Changed
{
    byte temp[345];
    getValue(A_ASG_49_0_0_56_Changed, temp);
    putValue(A_ASG_49_0_0_56_Changed_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_56_Changed_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_Changed_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_56_Changed_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_Changed_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_ASG_49_0_0_56_Changed_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_Changed_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_56_Changed_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_Changed_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_56_Changed_IndexSize))
    {
        putValue(A_ASG_49_0_0_56_Changed_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_56_Changed_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_56_Changed_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_56_Changed_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_56_SetGet
{
    byte temp[5];
    getValue(A_ASG_49_0_0_56_SetGet, temp);
    putValue(A_ASG_49_0_0_56_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_56_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_56_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_56_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_56_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_56_SetGet_IndexSize))
    {
        putValue(A_ASG_49_0_0_56_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_56_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_56_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_56_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_ASG_49_0_0_56_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_ASG_49_0_0_56_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_ASG_49_0_0_56_ArrayDataList[i].Param1 = 0;
		A_ASG_49_0_0_56_ArrayDataList[i].Param2 = 0;
		A_ASG_49_0_0_56_ArrayDataList[i].Param3 = 0;
		A_ASG_49_0_0_56_ArrayDataList[i].Param4 = 0;
		for(j=0; j<49; j++)
			A_ASG_49_0_0_56_ArrayDataList[i].Param5[j] = 0;
		A_ASG_49_0_0_56_ArrayDataList[i].Param5_Length = 0;
		A_ASG_49_0_0_56_Data_5_LenList[i] = 0;
		for(j=0; j<31; j++)
			A_ASG_49_0_0_56_ArrayDataList[i].Param6[j] = 0;
		A_ASG_49_0_0_56_ArrayDataList[i].Param6_Length = 0;
		A_ASG_49_0_0_56_Data_6_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_ASG_49_0_0_56_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
					{
						A_ASG_49_0_0_56_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_ASG_49_0_0_56_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //PresetIndex
						A_ASG_49_0_0_56_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //Waveband
						A_ASG_49_0_0_56_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //Attributes
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 256)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PresetIndex
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Waveband
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //Attributes
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Name
								if(paramPos < 48)
								{
									A_ASG_49_0_0_56_ArrayDataList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_56_ArrayDataList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 6: //Frequency
								if(paramPos < 30)
								{
									A_ASG_49_0_0_56_ArrayDataList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_56_ArrayDataList[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_ASG_49_0_0_56_loadArray_Btn
{
	char filePath[255];
	if (A_ASG_49_0_0_56_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_56_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_ASG_49_0_0_56_generateData_Btn_already_pressed = 0;
		getValue(A_ASG_49_0_0_56_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_ASG_49_0_0_56_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_ASG_49_0_0_56_Data_1, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_56_Data_2, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_56_Data_3, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_56_Data_4, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_56_Data_5, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param5, A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param5_Length);
	putValue(A_ASG_49_0_0_56_Data_6, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param6, A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param6_Length);
}


on envVar A_ASG_49_0_0_56_generateData_Btn
{
	word i;
	dword elementsArray[8] = {1, 1, 1, 2, 49, 2, 31, 2};
	byte elementsTypeArray[8] = {0, 0, 0, 0, 0xE, 0xF, 0xE, 0xF};
	dword elementsMaxSizeArray[8] = {255, 255, 0xFF, 0xFFFF, 0, 0, 0, 0};
	byte tempArray[22695];
	if (A_ASG_49_0_0_56_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_56_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 56, 255 );
		for(i = 0; i < 255; i++)
		{
			memcpy(A_ASG_49_0_0_56_ArrayDataList[i], tempArray, (i * 89) );
			if(A_ASG_49_0_0_56_ArrayDataList[i].Param5_Length > 127 )
				A_ASG_49_0_0_56_Data_5_CntList[i] = 1;
			if(A_ASG_49_0_0_56_ArrayDataList[i].Param6_Length > 127 )
				A_ASG_49_0_0_56_Data_6_CntList[i] = 1;
		}
		A_ASG_49_0_0_56_generateData_Btn_already_pressed = 0;
	}
	putValue(A_ASG_49_0_0_56_Data_1, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_56_Data_2, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_56_Data_3, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_56_Data_4, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_56_Data_5, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param5, A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param5_Length);
	putValue(A_ASG_49_0_0_56_Data_6, A_ASG_49_0_0_56_ArrayDataList[ getValue( A_ASG_49_0_0_56_DataIndex) ].Param6, A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param6_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_ASG_49_0_0_56_DataIndex
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_ASG_49_0_0_56_Data_1, A_ASG_49_0_0_56_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_56_Data_2, A_ASG_49_0_0_56_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_56_Data_3, A_ASG_49_0_0_56_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_56_Data_4, A_ASG_49_0_0_56_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_56_Data_5_len, A_ASG_49_0_0_56_Data_5_LenList[index]);
    putValue(A_ASG_49_0_0_56_Data_5_cnt, A_ASG_49_0_0_56_Data_5_CntList[index]);
    putValue(A_ASG_49_0_0_56_Data_5, A_ASG_49_0_0_56_ArrayDataList[index].Param5, A_ASG_49_0_0_56_ArrayDataList[index].Param5_Length);
    putValue(A_ASG_49_0_0_56_Data_6_len, A_ASG_49_0_0_56_Data_6_LenList[index]);
    putValue(A_ASG_49_0_0_56_Data_6_cnt, A_ASG_49_0_0_56_Data_6_CntList[index]);
    putValue(A_ASG_49_0_0_56_Data_6, A_ASG_49_0_0_56_ArrayDataList[index].Param6, A_ASG_49_0_0_56_ArrayDataList[index].Param6_Length);

}
on envVar A_ASG_49_0_0_56_DataIndex_Incr
{
    long index;
    if(A_ASG_49_0_0_56_DataIndex_Incr_already_pressed == 0)
    {
        A_ASG_49_0_0_56_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_56_DataIndex);
        index++;
        putValue(A_ASG_49_0_0_56_DataIndex, index);
        A_ASG_49_0_0_56_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_ASG_49_0_0_56_DataIndex_Decr
{
    long index;
    if(A_ASG_49_0_0_56_DataIndex_Decr_already_pressed == 0)
    {
        A_ASG_49_0_0_56_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_56_DataIndex);
        index--;
        putValue(A_ASG_49_0_0_56_DataIndex, index);
        A_ASG_49_0_0_56_DataIndex_Decr_already_pressed = 0;
    }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_56_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_56_SegmEn,0);
           intertelegram_err(A_ASG_49_0_0_56_ID);
       }
       else
       {
           intertelegram_err_off(A_ASG_49_0_0_56_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_56_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_56_IntTlgEn,0);
           sequence_err(A_ASG_49_0_0_56_ID,getValueSize(A_ASG_49_0_0_56_SegmEn));
       }
       else
       {
              sequence_err_off(A_ASG_49_0_0_56_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_ASG_49_0_0_56_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_ASG_49_0_0_56_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_ASG_49_0_0_56_Status",1);
 	}
}

A_ASG_49_0_0_56_DataInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[345];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_56_1, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_56_2, tempValue);
    //Einzelparameter: TotalNumListElements
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_ASG_49_0_0_56_3, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_56, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_56, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_56_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 56");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_56_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_56_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_56_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_56_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_56_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_56_Data_5_CntList[i] = 1;
            A_ASG_49_0_0_56_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_56_Data_5_CntList[i] = 0;
            A_ASG_49_0_0_56_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_56_ArrayDataList[i].Param5_Length; j++)
        {
            A_ASG_49_0_0_56_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_56_Data_6_CntList[i] = 1;
            A_ASG_49_0_0_56_ArrayDataList[i].Param6_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_56_Data_6_CntList[i] = 0;
            A_ASG_49_0_0_56_ArrayDataList[i].Param6_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_56_ArrayDataList[i].Param6_Length; j++)
        {
            A_ASG_49_0_0_56_ArrayDataList[i].Param6[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_56_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_56_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 56");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_56_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_56_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_56_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_56_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_56_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_56_Data_5_CntList[i] = 1;
            A_ASG_49_0_0_56_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_56_Data_5_CntList[i] = 0;
            A_ASG_49_0_0_56_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_56_ArrayDataList[i].Param5_Length; j++)
        {
            A_ASG_49_0_0_56_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_56_Data_6_CntList[i] = 1;
            A_ASG_49_0_0_56_ArrayDataList[i].Param6_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_56_Data_6_CntList[i] = 0;
            A_ASG_49_0_0_56_ArrayDataList[i].Param6_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_56_ArrayDataList[i].Param6_Length; j++)
        {
            A_ASG_49_0_0_56_ArrayDataList[i].Param6[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_56_DataIndex);
    putValue(A_ASG_49_0_0_56_Data_1, A_ASG_49_0_0_56_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_56_Data_2, A_ASG_49_0_0_56_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_56_Data_3, A_ASG_49_0_0_56_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_56_Data_4, A_ASG_49_0_0_56_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_56_Data_5_len, A_ASG_49_0_0_56_Data_5_LenList[index]);
    putValue(A_ASG_49_0_0_56_Data_5_cnt, A_ASG_49_0_0_56_Data_5_CntList[index]);
    putValue(A_ASG_49_0_0_56_Data_5, A_ASG_49_0_0_56_ArrayDataList[index].Param5, A_ASG_49_0_0_56_ArrayDataList[index].Param5_Length);
    putValue(A_ASG_49_0_0_56_Data_6_len, A_ASG_49_0_0_56_Data_6_LenList[index]);
    putValue(A_ASG_49_0_0_56_Data_6_cnt, A_ASG_49_0_0_56_Data_6_CntList[index]);
    putValue(A_ASG_49_0_0_56_Data_6, A_ASG_49_0_0_56_ArrayDataList[index].Param6, A_ASG_49_0_0_56_ArrayDataList[index].Param6_Length);
}

A_ASG_49_0_0_56_ChangedInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[345];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_56_Changed, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_56_Changed, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_56_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 56");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_56_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_56_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 56");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_56_DataIndex);
}




on envVar A_ASG_49_0_0_56_1
{
	byte superval[345];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_56_2_range // LastStationList.TAID 
{
	@A_ASG_49_0_0_56_2 = @A_ASG_49_0_0_56_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_56_2
{
	byte superval[345];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_56_2, 1.0);
	@A_ASG_49_0_0_56_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_56_3_range // LastStationList.TotalNumListElements 
{
	@A_ASG_49_0_0_56_3 = @A_ASG_49_0_0_56_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_56_3
{
	byte superval[345];

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_56_3, 1.0);
	@A_ASG_49_0_0_56_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_56_Data_1_range // LastStationList.Pos 
{
	@A_ASG_49_0_0_56_Data_1 = @A_ASG_49_0_0_56_Data_1_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_56_Data_1
{
	byte superval[345];

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_56_Data_1, 1.0);
	@A_ASG_49_0_0_56_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param1 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_56_Data_2_range // LastStationList.PresetIndex 
{
	@A_ASG_49_0_0_56_Data_2 = @A_ASG_49_0_0_56_Data_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_56_Data_2
{
	byte superval[345];

	//Update Childvalue (Number)
	byte thisval; // PresetIndex
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_56_Data_2, 1.0);
	@A_ASG_49_0_0_56_Data_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param2 = thisval;
}
on envVar A_ASG_49_0_0_56_Data_3
{
	byte superval[345];

	//Update Childvalue (Enum)
	byte thisval; // Waveband
	thisval = getValue(this);
    A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param3 = thisval;
}
on envVar A_ASG_49_0_0_56_Data_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_8
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<8)|(bitval<<8);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_9
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<9)|(bitval<<9);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_10
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<10)|(bitval<<10);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4_11
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_56_Data_4);
	thisval = thisval&~(1<<11)|(bitval<<11);
	putValue(A_ASG_49_0_0_56_Data_4,thisval);
}

on envVar A_ASG_49_0_0_56_Data_4
{
	byte superval[345];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	word thisval; // Attributes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_ASG_49_0_0_56_Data_4_0, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_0, 0);
	if(thisval&(mask<<1))
		putValue(A_ASG_49_0_0_56_Data_4_1, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_1, 0);
	if(thisval&(mask<<2))
		putValue(A_ASG_49_0_0_56_Data_4_2, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_2, 0);
	if(thisval&(mask<<3))
		putValue(A_ASG_49_0_0_56_Data_4_3, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_3, 0);
	if(thisval&(mask<<4))
		putValue(A_ASG_49_0_0_56_Data_4_4, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_4, 0);
	if(thisval&(mask<<5))
		putValue(A_ASG_49_0_0_56_Data_4_5, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_5, 0);
	if(thisval&(mask<<6))
		putValue(A_ASG_49_0_0_56_Data_4_6, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_6, 0);
	if(thisval&(mask<<7))
		putValue(A_ASG_49_0_0_56_Data_4_7, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_7, 0);
	if(thisval&(mask<<8))
		putValue(A_ASG_49_0_0_56_Data_4_8, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_8, 0);
	if(thisval&(mask<<9))
		putValue(A_ASG_49_0_0_56_Data_4_9, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_9, 0);
	if(thisval&(mask<<10))
		putValue(A_ASG_49_0_0_56_Data_4_10, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_10, 0);
	if(thisval&(mask<<11))
		putValue(A_ASG_49_0_0_56_Data_4_11, 1);
	else
		putValue(A_ASG_49_0_0_56_Data_4_11, 0);
    A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param4 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_56_Data_5_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_56_Data_5_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_56_Data_5_CntList[ getValue(A_ASG_49_0_0_56_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_56_Data_5_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_56_Data_5_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_56_Data_5_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 48 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_56_Data_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 48);
		thisval = 48;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_56_Data_5_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param5_Length = thisval;
	A_ASG_49_0_0_56_Data_5_LenList[ getValue(A_ASG_49_0_0_56_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_56_Data_5_len, thisval);

}

on envVar A_ASG_49_0_0_56_Data_5
{
	byte superval[345];

	//Update Childvalue (String)
	word i;
	byte thisval[49];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param5[i] = thisval[i];
    A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param5_Length = getValueSize(this);
    A_ASG_49_0_0_56_Data_5_LenList[getValue(A_ASG_49_0_0_56_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_56_Data_5_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_56_Data_6_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_56_Data_6_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_56_Data_6_CntList[ getValue(A_ASG_49_0_0_56_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_56_Data_6_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_56_Data_6_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_56_Data_6_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 30 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_56_Data_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 30);
		thisval = 30;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_56_Data_6_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param6_Length = thisval;
	A_ASG_49_0_0_56_Data_6_LenList[ getValue(A_ASG_49_0_0_56_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_56_Data_6_len, thisval);

}

on envVar A_ASG_49_0_0_56_Data_6
{
	byte superval[345];

	//Update Childvalue (String)
	word i;
	byte thisval[31];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param6[i] = thisval[i];
    A_ASG_49_0_0_56_ArrayDataList[getValue(A_ASG_49_0_0_56_DataIndex)].Param6_Length = getValueSize(this);
    A_ASG_49_0_0_56_Data_6_LenList[getValue(A_ASG_49_0_0_56_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_56_Data_6_len, getValueSize(this));
}
on envVar A_ASG_49_0_0_56_1_SetGet
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_56_2_SetGet_range // LastStationList.TAID 
{
	@A_ASG_49_0_0_56_2_SetGet = @A_ASG_49_0_0_56_2_SetGet_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_56_2_SetGet
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_56_2_SetGet, 1.0);
	@A_ASG_49_0_0_56_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar P_ASG_49_0_0_57Get_BTN
{
 if (P_ASG_49_0_0_57Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_57_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_57",MakeRGB(255,255,255));
       P_ASG_49_0_0_57Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_57_ID, DataGet_REQ); 
       P_ASG_49_0_0_57Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_57 // bus value of SiriusAlertInfo (57).
{
	// opcodes: Error-Status
	byte param1; // AlertType
	byte param2[61]; // AlertName
	word len2;
	byte cnt2;
	byte param3[49]; // StationName
	word len3;
	byte cnt3;
	word param4; // SiriusAlertList_Reference
	byte param5; // Extension1
	byte param6; // Extension2
	byte param7; // Extension3
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[116];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 116; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_57, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_ASG_49_0_0_57_1, param1);
	///////// Start param2 - STRING /////////
	getValue(P_ASG_49_0_0_57_2, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(60>127) /* Max Fct-Katalog Laenge: 60*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 60;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_57 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 60)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 60;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_57_2_len, len2);
	putValue(P_ASG_49_0_0_57_2_cnt, cnt2);
	
	if(len2 > getValueSize(P_ASG_49_0_0_57_2))
		putValue(P_ASG_49_0_0_57_2, param2, len2);
	else
		putValue(P_ASG_49_0_0_57_2, param2, getValueSize(P_ASG_49_0_0_57_2));

	///////// Start param3 - STRING /////////
	getValue(P_ASG_49_0_0_57_3, param3);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(48>127) /* Max Fct-Katalog Laenge: 48*/
		{
			len3 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt3 = 1;
		}
		else
		{
			len3 = 48;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_ASG_49_0_0_57 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len3 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt3 = 0;
	}
	
	if(len3 > 48)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len3, currentPos);
		len3 = 48;
	
		if(len3 < 128) cnt3 = 0;
		else cnt3 = 1;
	}
	
	for(i = 0; i < len3; i++)
	{
		param3[i] = superval[currentPos++];
	}
	
	putValue(P_ASG_49_0_0_57_3_len, len3);
	putValue(P_ASG_49_0_0_57_3_cnt, cnt3);
	
	if(len3 > getValueSize(P_ASG_49_0_0_57_3))
		putValue(P_ASG_49_0_0_57_3, param3, len3);
	else
		putValue(P_ASG_49_0_0_57_3, param3, getValueSize(P_ASG_49_0_0_57_3));

	///////// Start param4 - UINT16 /////////
	param4 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_ASG_49_0_0_57_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_ASG_49_0_0_57_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_ASG_49_0_0_57_6, round((param6 * 1.0) - (0) + (0), 1.0));
	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_ASG_49_0_0_57_7, round((param7 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_ASG_49_0_0_57_BuildFct()
{
	byte param1; // AlertType
	byte param2[61]; // AlertName
	word len2;
	byte cnt2;
	byte param3[49]; // StationName
	word len3;
	byte cnt3;
	word param4; // SiriusAlertList_Reference
	byte param5; // Extension1
	byte param6; // Extension2
	byte param7; // Extension3

	int i;
	byte superval[116];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_ASG_49_0_0_57_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_57_2, param2);
	len2 = getValue(P_ASG_49_0_0_57_2_len);
	cnt2= getValue(P_ASG_49_0_0_57_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 60 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 60)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_57_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 60);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(P_ASG_49_0_0_57_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 60)
		{
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(P_ASG_49_0_0_57_2_len, len2);
			putValue(P_ASG_49_0_0_57_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_57_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 60);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

// gen_BuildFunc_SetSuperVals 
	getValue(P_ASG_49_0_0_57_3, param3);
	len3 = getValue(P_ASG_49_0_0_57_3_len);
	cnt3= getValue(P_ASG_49_0_0_57_3_cnt);
	
	/* check box aktiviert*/
	if (cnt3 == 1)
	{
		/* 0 bis 48 (MaxString - 1B oder 2B) */
		if(len3 >= 0 && len3 <= 48)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len3: %d", len3);
			superval[currentPos] = (len3&0x7f00) | 0x80;
			superval[currentPos+1] = len3 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_57_3 ist ungueltig. Die max. erlaubte Laenge ist %d.", len3, 48);
			return;
		}
	}
	else if(cnt3 == 0) /*check box deaktiviert*/
	{
		if(len3 >= 0 && len3 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len3: %d", len3);
			superval[currentPos]= len3 & 0x00ff;
			putValue(P_ASG_49_0_0_57_3_len, len3);
		}
		else if(len3 > 127 && len3 <= 48)
		{
			superval[currentPos] = (len3&0x7f00) | 0x80;
			superval[currentPos+1] = len3 & 0x00ff;
			putValue(P_ASG_49_0_0_57_3_len, len3);
			putValue(P_ASG_49_0_0_57_3_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_57_3 ist ungueltig. Die max. erlaubte Laenge ist %d.", len3, 48);
			return;
		}
	}
	currentPos += cnt3+1;
	for(i = 0; i < len3; i++)
	{
		superval[currentPos++]= param3[i];
	}

// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_57_4_range = round(@P_ASG_49_0_0_57_4 + (0), 1.0); // slider value + min = real value
	param4 = round( (@P_ASG_49_0_0_57_4 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param4&0x00ff;
	superval[currentPos++]=(param4&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_57_5_range = round(@P_ASG_49_0_0_57_5 + (0), 1.0); // slider value + min = real value
	param5 = 0; // underlying parameter has constant value 0.
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_57_6_range = round(@P_ASG_49_0_0_57_6 + (0), 1.0); // slider value + min = real value
	param6 = 0; // underlying parameter has constant value 0.
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	@P_ASG_49_0_0_57_7_range = round(@P_ASG_49_0_0_57_7 + (0), 1.0); // slider value + min = real value
	param7 = 0; // underlying parameter has constant value 0.
	superval[currentPos++]=param7;
	putValue(P_ASG_49_0_0_57, superval, currentPos);
}


on envVar P_ASG_49_0_0_57_1 // SiriusAlertInfo.AlertType
{
	P_ASG_49_0_0_57_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_57_2_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_57_2_len);
	cnt = getValue(P_ASG_49_0_0_57_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_57_2_len, 127);
		}
	}

	P_ASG_49_0_0_57_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_57_2_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 60)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_57_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 60);
		putValue(this, 60);
	}
	P_ASG_49_0_0_57_BuildFct();
}


on envVar P_ASG_49_0_0_57_2 // SiriusAlertInfo.AlertName
{
	putValue(P_ASG_49_0_0_57_2_len, getValueSize(this));
	P_ASG_49_0_0_57_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_ASG_49_0_0_57_3_cnt
{
	word len;
	byte cnt;
	len = getValue(P_ASG_49_0_0_57_3_len);
	cnt = getValue(P_ASG_49_0_0_57_3_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_ASG_49_0_0_57_3_len, 127);
		}
	}

	P_ASG_49_0_0_57_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_ASG_49_0_0_57_3_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 48)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_ASG_49_0_0_57_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 48);
		putValue(this, 48);
	}
	P_ASG_49_0_0_57_BuildFct();
}


on envVar P_ASG_49_0_0_57_3 // SiriusAlertInfo.StationName
{
	putValue(P_ASG_49_0_0_57_3_len, getValueSize(this));
	P_ASG_49_0_0_57_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_57_4_range // SiriusAlertInfo.SiriusAlertList_Reference 
{
	@P_ASG_49_0_0_57_4 = @P_ASG_49_0_0_57_4_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_57_4 // SiriusAlertInfo.SiriusAlertList_Reference
{
	P_ASG_49_0_0_57_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_57_5_range // SiriusAlertInfo.Extension1 
{
	@P_ASG_49_0_0_57_5 = @P_ASG_49_0_0_57_5_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_57_5 // SiriusAlertInfo.Extension1
{
	P_ASG_49_0_0_57_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_57_6_range // SiriusAlertInfo.Extension2 
{
	@P_ASG_49_0_0_57_6 = @P_ASG_49_0_0_57_6_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_57_6 // SiriusAlertInfo.Extension2
{
	P_ASG_49_0_0_57_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_57_7_range // SiriusAlertInfo.Extension3 
{
	@P_ASG_49_0_0_57_7 = @P_ASG_49_0_0_57_7_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_57_7 // SiriusAlertInfo.Extension3
{
	P_ASG_49_0_0_57_BuildFct();
}

on envVar A_ASG_49_0_0_58Get_BTN
{
  byte data[5]; 
  byte stringValue[5];
  byte head[5];
  int i;
  int headLength;
  long tempValue;
  word currentPos;
  word startVal;
  word elementsVal;
  byte nibbleSetted;
  if (A_ASG_49_0_0_58Get_BTN_already_pressed == 0)
  {
     putValue(A_ASG_49_0_0_58_ErrCode,0);
     SetControlBackColor(panel_name,"errField_A_ASG_49_0_0_58",MakeRGB(255,255,255));
     A_ASG_49_0_0_58Get_BTN_already_pressed = 1;
  }
  else
  {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_ASG_49_0_0_58_1_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_ASG_49_0_0_58_2_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //head Parameter
        headLength = getValueSize(A_ASG_49_0_0_58_SetGet);
        getValue(A_ASG_49_0_0_58_SetGet,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }

     Request_ByteSequence(LSGID, A_ASG_49_0_0_58_ID, DataGet_REQ, data, currentPos);
     if(getValue(A_ASG_49_0_0_58_IntTlgEn)) //getValue(IT))
     {
       intertelegram_err(A_ASG_49_0_0_58_ID);
     }
     if(getValue(A_ASG_49_0_0_58_SegmEn))   //getvalue(SG)
     {
         sequence_err(A_ASG_49_0_0_58_ID,getValueSize(A_ASG_49_0_0_58_SetGet));
     }
     A_ASG_49_0_0_58Get_BTN_already_pressed = 0;
  }
}
A_ASG_49_0_0_58_SetGet_GenerateSetGet()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_ASG_49_0_0_58_SetGet_RecAdr) > 0x0F)
        putValue(A_ASG_49_0_0_58_SetGet_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_ASG_49_0_0_58_SetGet_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_ASG_49_0_0_58_SetGet_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_ASG_49_0_0_58_SetGet_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // reserverd:  Byte 0 Bit 6
    if( getValue(A_ASG_49_0_0_58_SetGet_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_ASG_49_0_0_58_SetGet_Start) & 0xFF;
        head[2] = (getValue(A_ASG_49_0_0_58_SetGet_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_ASG_49_0_0_58_SetGet_Elements) & 0xFF;
        head[4] = (getValue(A_ASG_49_0_0_58_SetGet_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_ASG_49_0_0_58_SetGet, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_ASG_49_0_0_58_SetGet_Start) & 0xFF;
        head[2] = getValue(A_ASG_49_0_0_58_SetGet_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_ASG_49_0_0_58_SetGet, head, 3); 
    }
}

on envVar A_ASG_49_0_0_58_SetGet_RecAdr
{
    A_ASG_49_0_0_58_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_58_SetGet_Shift
{
    A_ASG_49_0_0_58_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_58_SetGet_Direction
{
    A_ASG_49_0_0_58_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_58_SetGet_Start
{
    A_ASG_49_0_0_58_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_58_SetGet_Elements
{
    A_ASG_49_0_0_58_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_58_SetGet_IndexSize
{
    A_ASG_49_0_0_58_SetGet_GenerateSetGet();
}
on envVar A_ASG_49_0_0_58
{
    byte temp[5];
    byte head[5];
    getValue(A_ASG_49_0_0_58, head);
    putValue(A_ASG_49_0_0_58_RecAdr, 0x0F & head[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & head[0]) >0)
        putValue(A_ASG_49_0_0_58_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & head[0]) >0)
        putValue(A_ASG_49_0_0_58_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & head[0]) >0)
        putValue(A_ASG_49_0_0_58_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & head[0]) >0)
        putValue(A_ASG_49_0_0_58_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_58_IndexSize))
    {
        putValue(A_ASG_49_0_0_58_Start, ((head[2]<<8)| head[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_58_Elements, ((head[4]<<8)| head[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_58_Start, head[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_58_Elements, head[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_58_Changed
{
    byte temp[630];
    getValue(A_ASG_49_0_0_58_Changed, temp);
    putValue(A_ASG_49_0_0_58_Changed_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_58_Changed_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_Changed_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_58_Changed_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_Changed_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_ASG_49_0_0_58_Changed_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_Changed_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_58_Changed_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_Changed_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_58_Changed_IndexSize))
    {
        putValue(A_ASG_49_0_0_58_Changed_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_58_Changed_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_58_Changed_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_58_Changed_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_58_SetGet
{
    byte temp[5];
    getValue(A_ASG_49_0_0_58_SetGet, temp);
    putValue(A_ASG_49_0_0_58_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_58_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_58_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_58_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_58_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_58_SetGet_IndexSize))
    {
        putValue(A_ASG_49_0_0_58_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_58_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_58_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_58_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_ASG_49_0_0_58_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp5[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_ASG_49_0_0_58_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_ASG_49_0_0_58_ArrayDataList[i].Param1 = 0;
		A_ASG_49_0_0_58_ArrayDataList[i].Param2 = 0;
		A_ASG_49_0_0_58_ArrayDataList[i].Param3 = 0;
		for(j=0; j<17; j++)
			A_ASG_49_0_0_58_ArrayDataList[i].Param4[j] = 0;
		A_ASG_49_0_0_58_ArrayDataList[i].Param4_Length = 0;
		A_ASG_49_0_0_58_Data_4_LenList[i] = 0;
		A_ASG_49_0_0_58_ArrayDataList[i].Param5 = 0;
		for(j=0; j<602; j++)
			A_ASG_49_0_0_58_ArrayDataList[i].Param6[j] = 0;
		A_ASG_49_0_0_58_ArrayDataList[i].Param6_Length = 0;
		A_ASG_49_0_0_58_Data_6_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_ASG_49_0_0_58_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 255) //ignore first line in *.csv file
					{
						A_ASG_49_0_0_58_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_ASG_49_0_0_58_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //PictureType
						A_ASG_49_0_0_58_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //Handle
						A_ASG_49_0_0_58_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //TCP_Port
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp5[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 255)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PictureType
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Handle
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //IPv6_Address
								if(paramPos < 16)
								{
									A_ASG_49_0_0_58_ArrayDataList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_58_ArrayDataList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 5: //TCP_Port
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //URI
								if(paramPos < 600)
								{
									A_ASG_49_0_0_58_ArrayDataList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_58_ArrayDataList[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_ASG_49_0_0_58_loadArray_Btn
{
	char filePath[255];
	if (A_ASG_49_0_0_58_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_58_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_ASG_49_0_0_58_generateData_Btn_already_pressed = 0;
		getValue(A_ASG_49_0_0_58_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_ASG_49_0_0_58_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_ASG_49_0_0_58_Data_1, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_58_Data_2, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_58_Data_3, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_58_Data_4, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param4, A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param4_Length);
	putValue(A_ASG_49_0_0_58_Data_5, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param5);
	putValue(A_ASG_49_0_0_58_Data_6, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param6, A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param6_Length);
}


on envVar A_ASG_49_0_0_58_generateData_Btn
{
	word i;
	dword elementsArray[8] = {1, 1, 2, 17, 2, 2, 602, 2};
	byte elementsTypeArray[8] = {0, 0, 0, 0xE, 0xF, 0, 0xE, 0xF};
	dword elementsMaxSizeArray[8] = {255, 0xFF, 65535, 0, 0, 65535, 0, 0};
	byte tempArray[159766];
	if (A_ASG_49_0_0_58_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_58_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 58, 254 );
		for(i = 0; i < 254; i++)
		{
			memcpy(A_ASG_49_0_0_58_ArrayDataList[i], tempArray, (i * 629) );
			if(A_ASG_49_0_0_58_ArrayDataList[i].Param4_Length > 127 )
				A_ASG_49_0_0_58_Data_4_CntList[i] = 1;
			if(A_ASG_49_0_0_58_ArrayDataList[i].Param6_Length > 127 )
				A_ASG_49_0_0_58_Data_6_CntList[i] = 1;
		}
		A_ASG_49_0_0_58_generateData_Btn_already_pressed = 0;
	}
	putValue(A_ASG_49_0_0_58_Data_1, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_58_Data_2, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_58_Data_3, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_58_Data_4, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param4, A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param4_Length);
	putValue(A_ASG_49_0_0_58_Data_5, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param5);
	putValue(A_ASG_49_0_0_58_Data_6, A_ASG_49_0_0_58_ArrayDataList[ getValue( A_ASG_49_0_0_58_DataIndex) ].Param6, A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param6_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_ASG_49_0_0_58_DataIndex
{
    long index;
    long maxIndex = 254-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_ASG_49_0_0_58_Data_1, A_ASG_49_0_0_58_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_58_Data_2, A_ASG_49_0_0_58_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_58_Data_3, A_ASG_49_0_0_58_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_58_Data_4_len, A_ASG_49_0_0_58_Data_4_LenList[index]);
    putValue(A_ASG_49_0_0_58_Data_4_cnt, A_ASG_49_0_0_58_Data_4_CntList[index]);
    putValue(A_ASG_49_0_0_58_Data_4, A_ASG_49_0_0_58_ArrayDataList[index].Param4, A_ASG_49_0_0_58_ArrayDataList[index].Param4_Length);
    putValue(A_ASG_49_0_0_58_Data_5, A_ASG_49_0_0_58_ArrayDataList[index].Param5);
    putValue(A_ASG_49_0_0_58_Data_6_len, A_ASG_49_0_0_58_Data_6_LenList[index]);
    putValue(A_ASG_49_0_0_58_Data_6_cnt, A_ASG_49_0_0_58_Data_6_CntList[index]);
    putValue(A_ASG_49_0_0_58_Data_6, A_ASG_49_0_0_58_ArrayDataList[index].Param6, A_ASG_49_0_0_58_ArrayDataList[index].Param6_Length);

}
on envVar A_ASG_49_0_0_58_DataIndex_Incr
{
    long index;
    if(A_ASG_49_0_0_58_DataIndex_Incr_already_pressed == 0)
    {
        A_ASG_49_0_0_58_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_58_DataIndex);
        index++;
        putValue(A_ASG_49_0_0_58_DataIndex, index);
        A_ASG_49_0_0_58_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_ASG_49_0_0_58_DataIndex_Decr
{
    long index;
    if(A_ASG_49_0_0_58_DataIndex_Decr_already_pressed == 0)
    {
        A_ASG_49_0_0_58_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_58_DataIndex);
        index--;
        putValue(A_ASG_49_0_0_58_DataIndex, index);
        A_ASG_49_0_0_58_DataIndex_Decr_already_pressed = 0;
    }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_58_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_58_SegmEn,0);
           intertelegram_err(A_ASG_49_0_0_58_ID);
       }
       else
       {
           intertelegram_err_off(A_ASG_49_0_0_58_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_58_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_58_IntTlgEn,0);
           sequence_err(A_ASG_49_0_0_58_ID,getValueSize(A_ASG_49_0_0_58_SegmEn));
       }
       else
       {
              sequence_err_off(A_ASG_49_0_0_58_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_ASG_49_0_0_58_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_ASG_49_0_0_58_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_ASG_49_0_0_58_Status",1);
 	}
}

A_ASG_49_0_0_58_DataInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[630];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_58_1, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_58_2, tempValue);
    //Einzelparameter: TotalNumListElements
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_ASG_49_0_0_58_3, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_58, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_58, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_58_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 58");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_58_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_58_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_58_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_58_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_58_Data_4_CntList[i] = 1;
            A_ASG_49_0_0_58_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_58_Data_4_CntList[i] = 0;
            A_ASG_49_0_0_58_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_58_ArrayDataList[i].Param4_Length; j++)
        {
            A_ASG_49_0_0_58_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_58_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_58_Data_6_CntList[i] = 1;
            A_ASG_49_0_0_58_ArrayDataList[i].Param6_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_58_Data_6_CntList[i] = 0;
            A_ASG_49_0_0_58_ArrayDataList[i].Param6_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_58_ArrayDataList[i].Param6_Length; j++)
        {
            A_ASG_49_0_0_58_ArrayDataList[i].Param6[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_58_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_58_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 58");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_58_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_58_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_58_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_58_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_58_Data_4_CntList[i] = 1;
            A_ASG_49_0_0_58_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_58_Data_4_CntList[i] = 0;
            A_ASG_49_0_0_58_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_58_ArrayDataList[i].Param4_Length; j++)
        {
            A_ASG_49_0_0_58_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_58_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_58_Data_6_CntList[i] = 1;
            A_ASG_49_0_0_58_ArrayDataList[i].Param6_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_58_Data_6_CntList[i] = 0;
            A_ASG_49_0_0_58_ArrayDataList[i].Param6_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_58_ArrayDataList[i].Param6_Length; j++)
        {
            A_ASG_49_0_0_58_ArrayDataList[i].Param6[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_58_DataIndex);
    putValue(A_ASG_49_0_0_58_Data_1, A_ASG_49_0_0_58_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_58_Data_2, A_ASG_49_0_0_58_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_58_Data_3, A_ASG_49_0_0_58_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_58_Data_4_len, A_ASG_49_0_0_58_Data_4_LenList[index]);
    putValue(A_ASG_49_0_0_58_Data_4_cnt, A_ASG_49_0_0_58_Data_4_CntList[index]);
    putValue(A_ASG_49_0_0_58_Data_4, A_ASG_49_0_0_58_ArrayDataList[index].Param4, A_ASG_49_0_0_58_ArrayDataList[index].Param4_Length);
    putValue(A_ASG_49_0_0_58_Data_5, A_ASG_49_0_0_58_ArrayDataList[index].Param5);
    putValue(A_ASG_49_0_0_58_Data_6_len, A_ASG_49_0_0_58_Data_6_LenList[index]);
    putValue(A_ASG_49_0_0_58_Data_6_cnt, A_ASG_49_0_0_58_Data_6_CntList[index]);
    putValue(A_ASG_49_0_0_58_Data_6, A_ASG_49_0_0_58_ArrayDataList[index].Param6, A_ASG_49_0_0_58_ArrayDataList[index].Param6_Length);
}

A_ASG_49_0_0_58_ChangedInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[630];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_58_Changed, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_58_Changed, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_58_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 58");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_58_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_58_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 58");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_58_DataIndex);
}




on envVar A_ASG_49_0_0_58_1
{
	byte superval[630];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_58_2_range // Picture.TAID 
{
	@A_ASG_49_0_0_58_2 = @A_ASG_49_0_0_58_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_58_2
{
	byte superval[630];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_58_2, 1.0);
	@A_ASG_49_0_0_58_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_58_3_range // Picture.TotalNumListElements 
{
	@A_ASG_49_0_0_58_3 = @A_ASG_49_0_0_58_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_58_3
{
	byte superval[630];

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_58_3, 1.0);
	@A_ASG_49_0_0_58_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_58_Data_1_range // Picture.Pos 
{
	@A_ASG_49_0_0_58_Data_1 = @A_ASG_49_0_0_58_Data_1_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_58_Data_1
{
	byte superval[630];

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_58_Data_1, 1.0);
	@A_ASG_49_0_0_58_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param1 = thisval;
}
on envVar A_ASG_49_0_0_58_Data_2
{
	byte superval[630];

	//Update Childvalue (Enum)
	byte thisval; // PictureType
	thisval = getValue(this);
    A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param2 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_58_Data_3_range // Picture.Handle 
{
	@A_ASG_49_0_0_58_Data_3 = @A_ASG_49_0_0_58_Data_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_58_Data_3
{
	byte superval[630];

	//Update Childvalue (Number)
	word thisval; // Handle
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_58_Data_3, 1.0);
	@A_ASG_49_0_0_58_Data_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_58_Data_4_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_58_Data_4_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_58_Data_4_CntList[ getValue(A_ASG_49_0_0_58_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_58_Data_4_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_58_Data_4_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_58_Data_4_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 16 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_58_Data_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 16);
		thisval = 16;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_58_Data_4_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param4_Length = thisval;
	A_ASG_49_0_0_58_Data_4_LenList[ getValue(A_ASG_49_0_0_58_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_58_Data_4_len, thisval);

}

on envVar A_ASG_49_0_0_58_Data_4
{
	byte superval[630];

	//Update Childvalue (String)
	word i;
	byte thisval[17];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param4[i] = thisval[i];
    A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param4_Length = getValueSize(this);
    A_ASG_49_0_0_58_Data_4_LenList[getValue(A_ASG_49_0_0_58_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_58_Data_4_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_58_Data_5_range // Picture.TCP_Port 
{
	@A_ASG_49_0_0_58_Data_5 = @A_ASG_49_0_0_58_Data_5_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_58_Data_5
{
	byte superval[630];

	//Update Childvalue (Number)
	word thisval; // TCP_Port
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_58_Data_5, 1.0);
	@A_ASG_49_0_0_58_Data_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param5 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_58_Data_6_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_58_Data_6_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_58_Data_6_CntList[ getValue(A_ASG_49_0_0_58_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_58_Data_6_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_58_Data_6_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_58_Data_6_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 600 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_58_Data_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 600);
		thisval = 600;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_58_Data_6_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param6_Length = thisval;
	A_ASG_49_0_0_58_Data_6_LenList[ getValue(A_ASG_49_0_0_58_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_58_Data_6_len, thisval);

}

on envVar A_ASG_49_0_0_58_Data_6
{
	byte superval[630];

	//Update Childvalue (String)
	word i;
	byte thisval[602];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param6[i] = thisval[i];
    A_ASG_49_0_0_58_ArrayDataList[getValue(A_ASG_49_0_0_58_DataIndex)].Param6_Length = getValueSize(this);
    A_ASG_49_0_0_58_Data_6_LenList[getValue(A_ASG_49_0_0_58_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_58_Data_6_len, getValueSize(this));
}
on envVar A_ASG_49_0_0_58_1_SetGet
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_58_2_SetGet_range // Picture.TAID 
{
	@A_ASG_49_0_0_58_2_SetGet = @A_ASG_49_0_0_58_2_SetGet_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_58_2_SetGet
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_58_2_SetGet, 1.0);
	@A_ASG_49_0_0_58_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar A_ASG_49_0_0_59Get_BTN
{
  byte data[5]; 
  byte stringValue[5];
  byte head[5];
  int i;
  int headLength;
  long tempValue;
  word currentPos;
  word startVal;
  word elementsVal;
  byte nibbleSetted;
  if (A_ASG_49_0_0_59Get_BTN_already_pressed == 0)
  {
     putValue(A_ASG_49_0_0_59_ErrCode,0);
     SetControlBackColor(panel_name,"errField_A_ASG_49_0_0_59",MakeRGB(255,255,255));
     A_ASG_49_0_0_59Get_BTN_already_pressed = 1;
  }
  else
  {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_ASG_49_0_0_59_1_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_ASG_49_0_0_59_2_SetGet);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //head Parameter
        headLength = getValueSize(A_ASG_49_0_0_59_SetGet);
        getValue(A_ASG_49_0_0_59_SetGet,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }

     Request_ByteSequence(LSGID, A_ASG_49_0_0_59_ID, DataGet_REQ, data, currentPos);
     if(getValue(A_ASG_49_0_0_59_IntTlgEn)) //getValue(IT))
     {
       intertelegram_err(A_ASG_49_0_0_59_ID);
     }
     if(getValue(A_ASG_49_0_0_59_SegmEn))   //getvalue(SG)
     {
         sequence_err(A_ASG_49_0_0_59_ID,getValueSize(A_ASG_49_0_0_59_SetGet));
     }
     A_ASG_49_0_0_59Get_BTN_already_pressed = 0;
  }
}
A_ASG_49_0_0_59_SetGet_GenerateSetGet()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_ASG_49_0_0_59_SetGet_RecAdr) > 0x0F)
        putValue(A_ASG_49_0_0_59_SetGet_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_ASG_49_0_0_59_SetGet_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_ASG_49_0_0_59_SetGet_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_ASG_49_0_0_59_SetGet_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // reserverd:  Byte 0 Bit 6
    if( getValue(A_ASG_49_0_0_59_SetGet_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_ASG_49_0_0_59_SetGet_Start) & 0xFF;
        head[2] = (getValue(A_ASG_49_0_0_59_SetGet_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_ASG_49_0_0_59_SetGet_Elements) & 0xFF;
        head[4] = (getValue(A_ASG_49_0_0_59_SetGet_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_ASG_49_0_0_59_SetGet, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_ASG_49_0_0_59_SetGet_Start) & 0xFF;
        head[2] = getValue(A_ASG_49_0_0_59_SetGet_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_ASG_49_0_0_59_SetGet, head, 3); 
    }
}

on envVar A_ASG_49_0_0_59_SetGet_RecAdr
{
    A_ASG_49_0_0_59_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_59_SetGet_Shift
{
    A_ASG_49_0_0_59_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_59_SetGet_Direction
{
    A_ASG_49_0_0_59_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_59_SetGet_Start
{
    A_ASG_49_0_0_59_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_59_SetGet_Elements
{
    A_ASG_49_0_0_59_SetGet_GenerateSetGet();
}

on envVar A_ASG_49_0_0_59_SetGet_IndexSize
{
    A_ASG_49_0_0_59_SetGet_GenerateSetGet();
}
on envVar A_ASG_49_0_0_59
{
    byte temp[5];
    byte head[5];
    getValue(A_ASG_49_0_0_59, head);
    putValue(A_ASG_49_0_0_59_RecAdr, 0x0F & head[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & head[0]) >0)
        putValue(A_ASG_49_0_0_59_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & head[0]) >0)
        putValue(A_ASG_49_0_0_59_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & head[0]) >0)
        putValue(A_ASG_49_0_0_59_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & head[0]) >0)
        putValue(A_ASG_49_0_0_59_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_59_IndexSize))
    {
        putValue(A_ASG_49_0_0_59_Start, ((head[2]<<8)| head[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_59_Elements, ((head[4]<<8)| head[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_59_Start, head[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_59_Elements, head[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_59_Changed
{
    byte temp[345];
    getValue(A_ASG_49_0_0_59_Changed, temp);
    putValue(A_ASG_49_0_0_59_Changed_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_59_Changed_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_Changed_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_59_Changed_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_Changed_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_ASG_49_0_0_59_Changed_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_Changed_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_59_Changed_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_Changed_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_59_Changed_IndexSize))
    {
        putValue(A_ASG_49_0_0_59_Changed_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_59_Changed_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_59_Changed_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_59_Changed_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
on envVar A_ASG_49_0_0_59_SetGet
{
    byte temp[5];
    getValue(A_ASG_49_0_0_59_SetGet, temp);
    putValue(A_ASG_49_0_0_59_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_ASG_49_0_0_59_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_ASG_49_0_0_59_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_ASG_49_0_0_59_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_ASG_49_0_0_59_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_ASG_49_0_0_59_SetGet_IndexSize))
    {
        putValue(A_ASG_49_0_0_59_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_ASG_49_0_0_59_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_ASG_49_0_0_59_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_ASG_49_0_0_59_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_ASG_49_0_0_59_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp2[25];
	char temp3[25];
	char temp4[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_ASG_49_0_0_59_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_ASG_49_0_0_59_ArrayDataList[i].Param1 = 0;
		A_ASG_49_0_0_59_ArrayDataList[i].Param2 = 0;
		A_ASG_49_0_0_59_ArrayDataList[i].Param3 = 0;
		A_ASG_49_0_0_59_ArrayDataList[i].Param4 = 0;
		for(j=0; j<49; j++)
			A_ASG_49_0_0_59_ArrayDataList[i].Param5[j] = 0;
		A_ASG_49_0_0_59_ArrayDataList[i].Param5_Length = 0;
		A_ASG_49_0_0_59_Data_5_LenList[i] = 0;
		for(j=0; j<31; j++)
			A_ASG_49_0_0_59_ArrayDataList[i].Param6[j] = 0;
		A_ASG_49_0_0_59_ArrayDataList[i].Param6_Length = 0;
		A_ASG_49_0_0_59_Data_6_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_ASG_49_0_0_59_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 256) //ignore first line in *.csv file
					{
						A_ASG_49_0_0_59_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_ASG_49_0_0_59_ArrayDataList[current_CSV_line-1].Param2 = atol(temp2); //PresetIndex
						A_ASG_49_0_0_59_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //Waveband
						A_ASG_49_0_0_59_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //Attributes
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 256)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PresetIndex
								if( paramPos >= elCount(temp2) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp2[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 3: //Waveband
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //Attributes
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //Name
								if(paramPos < 48)
								{
									A_ASG_49_0_0_59_ArrayDataList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_59_ArrayDataList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 6: //Frequency
								if(paramPos < 30)
								{
									A_ASG_49_0_0_59_ArrayDataList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
									A_ASG_49_0_0_59_ArrayDataList[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_ASG_49_0_0_59_loadArray_Btn
{
	char filePath[255];
	if (A_ASG_49_0_0_59_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_59_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_ASG_49_0_0_59_generateData_Btn_already_pressed = 0;
		getValue(A_ASG_49_0_0_59_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_ASG_49_0_0_59_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_ASG_49_0_0_59_Data_1, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_59_Data_2, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_59_Data_3, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_59_Data_4, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_59_Data_5, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param5, A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param5_Length);
	putValue(A_ASG_49_0_0_59_Data_6, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param6, A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param6_Length);
}


on envVar A_ASG_49_0_0_59_generateData_Btn
{
	word i;
	dword elementsArray[8] = {1, 1, 1, 2, 49, 2, 31, 2};
	byte elementsTypeArray[8] = {0, 0, 0, 0, 0xE, 0xF, 0xE, 0xF};
	dword elementsMaxSizeArray[8] = {255, 255, 0xFF, 0xFFFF, 0, 0, 0, 0};
	byte tempArray[22695];
	if (A_ASG_49_0_0_59_generateData_Btn_already_pressed == 0)
	{
		A_ASG_49_0_0_59_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 59, 255 );
		for(i = 0; i < 255; i++)
		{
			memcpy(A_ASG_49_0_0_59_ArrayDataList[i], tempArray, (i * 89) );
			if(A_ASG_49_0_0_59_ArrayDataList[i].Param5_Length > 127 )
				A_ASG_49_0_0_59_Data_5_CntList[i] = 1;
			if(A_ASG_49_0_0_59_ArrayDataList[i].Param6_Length > 127 )
				A_ASG_49_0_0_59_Data_6_CntList[i] = 1;
		}
		A_ASG_49_0_0_59_generateData_Btn_already_pressed = 0;
	}
	putValue(A_ASG_49_0_0_59_Data_1, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param1);
	putValue(A_ASG_49_0_0_59_Data_2, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param2);
	putValue(A_ASG_49_0_0_59_Data_3, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param3);
	putValue(A_ASG_49_0_0_59_Data_4, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param4);
	putValue(A_ASG_49_0_0_59_Data_5, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param5, A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param5_Length);
	putValue(A_ASG_49_0_0_59_Data_6, A_ASG_49_0_0_59_ArrayDataList[ getValue( A_ASG_49_0_0_59_DataIndex) ].Param6, A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param6_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_ASG_49_0_0_59_DataIndex
{
    long index;
    long maxIndex = 255-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_ASG_49_0_0_59_Data_1, A_ASG_49_0_0_59_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_59_Data_2, A_ASG_49_0_0_59_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_59_Data_3, A_ASG_49_0_0_59_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_59_Data_4, A_ASG_49_0_0_59_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_59_Data_5_len, A_ASG_49_0_0_59_Data_5_LenList[index]);
    putValue(A_ASG_49_0_0_59_Data_5_cnt, A_ASG_49_0_0_59_Data_5_CntList[index]);
    putValue(A_ASG_49_0_0_59_Data_5, A_ASG_49_0_0_59_ArrayDataList[index].Param5, A_ASG_49_0_0_59_ArrayDataList[index].Param5_Length);
    putValue(A_ASG_49_0_0_59_Data_6_len, A_ASG_49_0_0_59_Data_6_LenList[index]);
    putValue(A_ASG_49_0_0_59_Data_6_cnt, A_ASG_49_0_0_59_Data_6_CntList[index]);
    putValue(A_ASG_49_0_0_59_Data_6, A_ASG_49_0_0_59_ArrayDataList[index].Param6, A_ASG_49_0_0_59_ArrayDataList[index].Param6_Length);

}
on envVar A_ASG_49_0_0_59_DataIndex_Incr
{
    long index;
    if(A_ASG_49_0_0_59_DataIndex_Incr_already_pressed == 0)
    {
        A_ASG_49_0_0_59_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_59_DataIndex);
        index++;
        putValue(A_ASG_49_0_0_59_DataIndex, index);
        A_ASG_49_0_0_59_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_ASG_49_0_0_59_DataIndex_Decr
{
    long index;
    if(A_ASG_49_0_0_59_DataIndex_Decr_already_pressed == 0)
    {
        A_ASG_49_0_0_59_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_ASG_49_0_0_59_DataIndex);
        index--;
        putValue(A_ASG_49_0_0_59_DataIndex, index);
        A_ASG_49_0_0_59_DataIndex_Decr_already_pressed = 0;
    }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_59_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_59_SegmEn,0);
           intertelegram_err(A_ASG_49_0_0_59_ID);
       }
       else
       {
           intertelegram_err_off(A_ASG_49_0_0_59_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_ASG_49_0_0_59_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_ASG_49_0_0_59_IntTlgEn,0);
           sequence_err(A_ASG_49_0_0_59_ID,getValueSize(A_ASG_49_0_0_59_SegmEn));
       }
       else
       {
              sequence_err_off(A_ASG_49_0_0_59_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_ASG_49_0_0_59_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_ASG_49_0_0_59_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_ASG_49_0_0_59_Status",1);
 	}
}

A_ASG_49_0_0_59_DataInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[345];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_59_1, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_ASG_49_0_0_59_2, tempValue);
    //Einzelparameter: TotalNumListElements
    //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
    if(nibbleSetted == 1) currentPos++;
    nibbleSetted = 0;
    tempValue = gBAP_Indication_data[currentPos++];
    putValue(A_ASG_49_0_0_59_3, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_59, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_59, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_59_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 59");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_59_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_59_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_59_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_59_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_59_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_59_Data_5_CntList[i] = 1;
            A_ASG_49_0_0_59_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_59_Data_5_CntList[i] = 0;
            A_ASG_49_0_0_59_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_59_ArrayDataList[i].Param5_Length; j++)
        {
            A_ASG_49_0_0_59_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_59_Data_6_CntList[i] = 1;
            A_ASG_49_0_0_59_ArrayDataList[i].Param6_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_59_Data_6_CntList[i] = 0;
            A_ASG_49_0_0_59_ArrayDataList[i].Param6_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_59_ArrayDataList[i].Param6_Length; j++)
        {
            A_ASG_49_0_0_59_ArrayDataList[i].Param6[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_59_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_59_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 59");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_ASG_49_0_0_59_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_ASG_49_0_0_59_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_59_ArrayDataList[i].Param2 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_59_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal )
      {
        //Sollte vor einem 2 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_ASG_49_0_0_59_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos++] & 0xFF) + ((gBAP_Indication_data[currentPos++] & 0xFF) <<8);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 2 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_59_Data_5_CntList[i] = 1;
            A_ASG_49_0_0_59_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_59_Data_5_CntList[i] = 0;
            A_ASG_49_0_0_59_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_59_ArrayDataList[i].Param5_Length; j++)
        {
            A_ASG_49_0_0_59_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 1 == recordAddressVal || 3 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_ASG_49_0_0_59_Data_6_CntList[i] = 1;
            A_ASG_49_0_0_59_ArrayDataList[i].Param6_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_ASG_49_0_0_59_Data_6_CntList[i] = 0;
            A_ASG_49_0_0_59_ArrayDataList[i].Param6_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_ASG_49_0_0_59_ArrayDataList[i].Param6_Length; j++)
        {
            A_ASG_49_0_0_59_ArrayDataList[i].Param6[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_59_DataIndex);
    putValue(A_ASG_49_0_0_59_Data_1, A_ASG_49_0_0_59_ArrayDataList[index].Param1);
    putValue(A_ASG_49_0_0_59_Data_2, A_ASG_49_0_0_59_ArrayDataList[index].Param2);
    putValue(A_ASG_49_0_0_59_Data_3, A_ASG_49_0_0_59_ArrayDataList[index].Param3);
    putValue(A_ASG_49_0_0_59_Data_4, A_ASG_49_0_0_59_ArrayDataList[index].Param4);
    putValue(A_ASG_49_0_0_59_Data_5_len, A_ASG_49_0_0_59_Data_5_LenList[index]);
    putValue(A_ASG_49_0_0_59_Data_5_cnt, A_ASG_49_0_0_59_Data_5_CntList[index]);
    putValue(A_ASG_49_0_0_59_Data_5, A_ASG_49_0_0_59_ArrayDataList[index].Param5, A_ASG_49_0_0_59_ArrayDataList[index].Param5_Length);
    putValue(A_ASG_49_0_0_59_Data_6_len, A_ASG_49_0_0_59_Data_6_LenList[index]);
    putValue(A_ASG_49_0_0_59_Data_6_cnt, A_ASG_49_0_0_59_Data_6_CntList[index]);
    putValue(A_ASG_49_0_0_59_Data_6, A_ASG_49_0_0_59_ArrayDataList[index].Param6, A_ASG_49_0_0_59_ArrayDataList[index].Param6_Length);
}

A_ASG_49_0_0_59_ChangedInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[345];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_ASG_49_0_0_59_Changed, head, 5);
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_ASG_49_0_0_59_Changed, head, 3);
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_ASG_49_0_0_59_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 59");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_ASG_49_0_0_59_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_ASG_49_0_0_59_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 59");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_ASG_49_0_0_59_DataIndex);
}




on envVar A_ASG_49_0_0_59_1
{
	byte superval[345];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_59_2_range // FavoriteList.TAID 
{
	@A_ASG_49_0_0_59_2 = @A_ASG_49_0_0_59_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_59_2
{
	byte superval[345];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_59_2, 1.0);
	@A_ASG_49_0_0_59_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_59_3_range // FavoriteList.TotalNumListElements 
{
	@A_ASG_49_0_0_59_3 = @A_ASG_49_0_0_59_3_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_59_3
{
	byte superval[345];

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_59_3, 1.0);
	@A_ASG_49_0_0_59_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_59_Data_1_range // FavoriteList.Pos 
{
	@A_ASG_49_0_0_59_Data_1 = @A_ASG_49_0_0_59_Data_1_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_59_Data_1
{
	byte superval[345];

	//Update Childvalue (Number)
	byte thisval; // Pos
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_59_Data_1, 1.0);
	@A_ASG_49_0_0_59_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param1 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_59_Data_2_range // FavoriteList.PresetIndex 
{
	@A_ASG_49_0_0_59_Data_2 = @A_ASG_49_0_0_59_Data_2_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_59_Data_2
{
	byte superval[345];

	//Update Childvalue (Number)
	byte thisval; // PresetIndex
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_59_Data_2, 1.0);
	@A_ASG_49_0_0_59_Data_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param2 = thisval;
}
on envVar A_ASG_49_0_0_59_Data_3
{
	byte superval[345];

	//Update Childvalue (Enum)
	byte thisval; // Waveband
	thisval = getValue(this);
    A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param3 = thisval;
}
on envVar A_ASG_49_0_0_59_Data_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_8
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<8)|(bitval<<8);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_9
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<9)|(bitval<<9);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_10
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<10)|(bitval<<10);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4_11
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // Attributes
	bitval= getValue(this);
	thisval = getValue(A_ASG_49_0_0_59_Data_4);
	thisval = thisval&~(1<<11)|(bitval<<11);
	putValue(A_ASG_49_0_0_59_Data_4,thisval);
}

on envVar A_ASG_49_0_0_59_Data_4
{
	byte superval[345];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	word thisval; // Attributes
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_ASG_49_0_0_59_Data_4_0, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_0, 0);
	if(thisval&(mask<<1))
		putValue(A_ASG_49_0_0_59_Data_4_1, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_1, 0);
	if(thisval&(mask<<2))
		putValue(A_ASG_49_0_0_59_Data_4_2, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_2, 0);
	if(thisval&(mask<<3))
		putValue(A_ASG_49_0_0_59_Data_4_3, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_3, 0);
	if(thisval&(mask<<4))
		putValue(A_ASG_49_0_0_59_Data_4_4, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_4, 0);
	if(thisval&(mask<<5))
		putValue(A_ASG_49_0_0_59_Data_4_5, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_5, 0);
	if(thisval&(mask<<6))
		putValue(A_ASG_49_0_0_59_Data_4_6, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_6, 0);
	if(thisval&(mask<<7))
		putValue(A_ASG_49_0_0_59_Data_4_7, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_7, 0);
	if(thisval&(mask<<8))
		putValue(A_ASG_49_0_0_59_Data_4_8, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_8, 0);
	if(thisval&(mask<<9))
		putValue(A_ASG_49_0_0_59_Data_4_9, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_9, 0);
	if(thisval&(mask<<10))
		putValue(A_ASG_49_0_0_59_Data_4_10, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_10, 0);
	if(thisval&(mask<<11))
		putValue(A_ASG_49_0_0_59_Data_4_11, 1);
	else
		putValue(A_ASG_49_0_0_59_Data_4_11, 0);
    A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param4 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_59_Data_5_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_59_Data_5_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_59_Data_5_CntList[ getValue(A_ASG_49_0_0_59_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_59_Data_5_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_59_Data_5_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_59_Data_5_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 48 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_59_Data_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 48);
		thisval = 48;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_59_Data_5_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param5_Length = thisval;
	A_ASG_49_0_0_59_Data_5_LenList[ getValue(A_ASG_49_0_0_59_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_59_Data_5_len, thisval);

}

on envVar A_ASG_49_0_0_59_Data_5
{
	byte superval[345];

	//Update Childvalue (String)
	word i;
	byte thisval[49];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param5[i] = thisval[i];
    A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param5_Length = getValueSize(this);
    A_ASG_49_0_0_59_Data_5_LenList[getValue(A_ASG_49_0_0_59_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_59_Data_5_len, getValueSize(this));
}

// Ueberwachung der CheckBox fuer String
on envVar  A_ASG_49_0_0_59_Data_6_cnt
{
	word len;
	byte cnt;
	len = getValue(A_ASG_49_0_0_59_Data_6_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_ASG_49_0_0_59_Data_6_CntList[ getValue(A_ASG_49_0_0_59_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_ASG_49_0_0_59_Data_6_len, 127);
		}
	}

}


on envVar A_ASG_49_0_0_59_Data_6_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_ASG_49_0_0_59_Data_6_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 30 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_ASG_49_0_0_59_Data_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 30);
		thisval = 30;
	}
	if( thisval >127)
	{
		putValue(A_ASG_49_0_0_59_Data_6_cnt, 1); /* Switch checkbox on */
	}

	A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param6_Length = thisval;
	A_ASG_49_0_0_59_Data_6_LenList[ getValue(A_ASG_49_0_0_59_DataIndex) ] = thisval;
	putValue(A_ASG_49_0_0_59_Data_6_len, thisval);

}

on envVar A_ASG_49_0_0_59_Data_6
{
	byte superval[345];

	//Update Childvalue (String)
	word i;
	byte thisval[31];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param6[i] = thisval[i];
    A_ASG_49_0_0_59_ArrayDataList[getValue(A_ASG_49_0_0_59_DataIndex)].Param6_Length = getValueSize(this);
    A_ASG_49_0_0_59_Data_6_LenList[getValue(A_ASG_49_0_0_59_DataIndex)]= getValueSize(this);
    putValue(A_ASG_49_0_0_59_Data_6_len, getValueSize(this));
}
on envVar A_ASG_49_0_0_59_1_SetGet
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_ASG_49_0_0_59_2_SetGet_range // FavoriteList.TAID 
{
	@A_ASG_49_0_0_59_2_SetGet = @A_ASG_49_0_0_59_2_SetGet_range - (0); // slider = range - min
}

on envVar A_ASG_49_0_0_59_2_SetGet
{
	byte superval[4];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_ASG_49_0_0_59_2_SetGet, 1.0);
	@A_ASG_49_0_0_59_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
on envVar P_ASG_49_0_0_60Get_BTN
{
 if (P_ASG_49_0_0_60Get_BTN_already_pressed == 0)
  {
       putValue(P_ASG_49_0_0_60_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_ASG_49_0_0_60",MakeRGB(255,255,255));
       P_ASG_49_0_0_60Get_BTN_already_pressed = 1;
 }
 else
 {
       Request_Void(LSGID, P_ASG_49_0_0_60_ID, DataGet_REQ); 
       P_ASG_49_0_0_60Get_BTN_already_pressed = 0;
 }
}
on envVar P_ASG_49_0_0_60 // bus value of Station_Track_Switch (60).
{
	// opcodes: Error-Status
	byte param1; // Event
	byte param2; // Direction
	byte param3; // PlayState
	byte param4; // Extension1
	byte param5; // Extension2
	byte param6; // Extension3
	byte param7; // Extension4
	byte param8; // Extension5
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[6];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 6; i++ ) {
		superval[i] = 0;
	}
	getValue(P_ASG_49_0_0_60, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_ASG_49_0_0_60_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_ASG_49_0_0_60_2, param2);
	///////// Start param3 - NIBBLE /////////
	param3 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_ASG_49_0_0_60_3, param3);
	///////// Start param4 - NIBBLE /////////
	param4 = superval[currentPos++] & 0x0f;
	putValue(P_ASG_49_0_0_60_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_ASG_49_0_0_60_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_ASG_49_0_0_60_6, round((param6 * 1.0) - (0) + (0), 1.0));
	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_ASG_49_0_0_60_7, round((param7 * 1.0) - (0) + (0), 1.0));
	///////// Start param8 - UINT8 /////////
	param8 = superval[currentPos++];
	putValue(P_ASG_49_0_0_60_8, round((param8 * 1.0) - (0) + (0), 1.0));
}

on envVar P_ASG_49_0_0_60_1 // Station_Track_Switch.Event
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // Event
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_60, superval);
	superval[0]= superval[0]&0x0f;
	superval[0]= superval[0]|(thisval<<4);
	putValue(P_ASG_49_0_0_60,superval);
}

on envVar P_ASG_49_0_0_60_2 // Station_Track_Switch.Direction
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // Direction
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_60, superval);
	superval[0]= superval[0]&0xf0;
	superval[0]= superval[0]|thisval;
	putValue(P_ASG_49_0_0_60,superval);
}

on envVar P_ASG_49_0_0_60_3 // Station_Track_Switch.PlayState
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // PlayState
	thisval = 0x0f & getValue(this);

    // Update superval
	getValue(P_ASG_49_0_0_60, superval);
	superval[1]= superval[1]&0x0f;
	superval[1]= superval[1]|(thisval<<4);
	putValue(P_ASG_49_0_0_60,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_60_4_range // Station_Track_Switch.Extension1 
{
	@P_ASG_49_0_0_60_4 = @P_ASG_49_0_0_60_4_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_60_4 // Station_Track_Switch.Extension1
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_60_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_60, superval);
	superval[1]= superval[1]&0xf0;
	superval[1]= superval[1]|thisval;
	putValue(P_ASG_49_0_0_60,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_60_5_range // Station_Track_Switch.Extension2 
{
	@P_ASG_49_0_0_60_5 = @P_ASG_49_0_0_60_5_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_60_5 // Station_Track_Switch.Extension2
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_60_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_60, superval);
	superval[2]=thisval;
	putValue(P_ASG_49_0_0_60,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_60_6_range // Station_Track_Switch.Extension3 
{
	@P_ASG_49_0_0_60_6 = @P_ASG_49_0_0_60_6_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_60_6 // Station_Track_Switch.Extension3
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension3
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_60_6_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_60, superval);
	superval[3]=thisval;
	putValue(P_ASG_49_0_0_60,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_60_7_range // Station_Track_Switch.Extension4 
{
	@P_ASG_49_0_0_60_7 = @P_ASG_49_0_0_60_7_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_60_7 // Station_Track_Switch.Extension4
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension4
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_60_7_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_60, superval);
	superval[4]=thisval;
	putValue(P_ASG_49_0_0_60,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_ASG_49_0_0_60_8_range // Station_Track_Switch.Extension5 
{
	@P_ASG_49_0_0_60_8 = @P_ASG_49_0_0_60_8_range - (0); // slider = range - min
}

on envVar P_ASG_49_0_0_60_8 // Station_Track_Switch.Extension5
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // Extension5
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_ASG_49_0_0_60_8_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_ASG_49_0_0_60, superval);
	superval[5]=thisval;
	putValue(P_ASG_49_0_0_60,superval);
}



/**
*
* Template-Funktion zum automatischen befuellen der Array-Daten, die in einer Arrayfunktion genutzt werden.
* Die Funktion wird durch den von BAPSimGen generierten Code aufgerufen.
*
* Parameter:
* - structArray: Muss mindestens nMax * Arraygroesse Bytes Platz haben, wird vom BAPSimGen automatisch generiert
* - structElementsSizeArray: Enthaelt die Groesseangabe jedes Array-Elements. Die Arraygroesse entspricht der Elementanzahl im Array.
*       Byte & Nibble = 1; Word = 2; usw. Bei Strings wird die maximale Stringlaenge angegeben.
* - structElementsTypeArray: Gibt den Datentyp eines Array-Elements zurueck. Die Arraygroesse entspricht der Elmentanzahl im Array.
*                               0x0 = Zahlenwert, also ein Slider, Enum, Bitfield,...
*                               0xE = String (darauf folgt immer eine 2, mit der Angabe der benutzen Bytes im String)
*                               0xF = Laenge der Nutzdaten des Strings, nur return Wert
* - fctID: Kann zur Fallunterscheidung der Funktions-IDs verwendet werden.
* - nMax: Array-Index
*
* Die Funktion kann im Switch-Case beliebig erweitert werden. Der Switch-Case wertet den Parameter fctID aus.
*           
*                    
**/
initStruct(byte structArray[], dword structElementsSizeArray[], byte structElementsTypeArray[], dword structElementsMaxSizeArray[], word fctID, word nMax )
{
    byte rand8;
    word rand16;
    word randSize;
    word index;           //indexNr die an die String Parameter angehaengt wird.
    dword destArraySize;   //groesse von structArray
    dword destStructSize;  //groesse eines "Structs" also destArraySize / Anzahl Elemente (nMax))
    dword rand32;    
    dword i;
    dword pos;    //aktuelle Position im structArray
    dword elpos;  //aktuelle Position in den structElementsXXXArray's
    
    destArraySize = elCount(structArray);
    destStructSize = destArraySize / nMax;    

    Switch(fctID){

        //Idee ist, die Arrays je nach Funcion-ID speziell initalisieren zu koennen.
        //hierbei koennten die Daten z.B. aus einer Datei eingelesen werden,
        //oder auch ueber spezielle init Funktionen mit festen Werten initialisiert werden.
        //Der Default-Fall befuellt das Array mit Random-Werten und Strings mit einem vordefinierten Wort (hier test,)

        default :
        {
            pos = 0; 
            for(i = 1; i <= nMax; i++)
            {
                //walk through the array
                
                elpos = 0;
                while(pos < (destStructSize * i) )
                {   
                    //check Element type
                    if( structElementsTypeArray[elpos] == 0x0)          
                    { //Params like int, word, etc.
                        //check element length
                        Switch(structElementsSizeArray[elpos])
                        {
                            case(1) : //byte / nibble
                                rand8 = random(structElementsMaxSizeArray[elpos]);
                                structArray[pos] = rand8;
                                pos++;
                                break;

                            case(2) : //word / int
                                rand16 = random(structElementsMaxSizeArray[elpos]);
                                int2byte(structArray, pos, rand16);
                                pos += 2;
                                break;

                            case (4) : //dword / long
                                rand32 = random(structElementsMaxSizeArray[elpos]);
                                long2byte(structArray, pos, rand32);
                                pos += 4;
                                break;                        
                         }
                    }
                    else if(structElementsTypeArray[elpos] == 0xE)          
                    { //String Params like byte[]
                        randSize = random(structElementsSizeArray[elpos]);
                        if(randSize < 2) randSize = 2; 
                        index = i-1;
                        setRandomString(structArray ,pos ,structElementsSizeArray[elpos], randSize, index);
                        pos += structElementsSizeArray[elpos];
                    }
                    else if(structElementsTypeArray[elpos] == 0xF)          
                    {
                        int2byte(structArray, pos, randSize);
                        pos += 2;
                        //write("Pos: %d Strlth: %d Type: %d ",pos-1,randSize,structElementsTypeArray[elpos]);
                    
                    }
                    elpos++;
                }
            }   
        break;
        }            
    }
}

long2Byte(byte in[], dword pos, dword value)
{
    if( (elCount(in)-pos) < 4)
        write("Array out ouf bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);
    in[++pos] = (value >> 16);
    in[++pos] = (value >> 24);
}

int2byte (byte in[],dword pos,word value)
{
    if( (elCount(in)-pos) < 2 )
        write("Array out of bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);        
}

setRandomString (byte in[], dword pos, word strSize, word randSize, word count)
{
    word endPos, endString, j;
    byte testString[4]={'t','e','s','t'};
    
    endPos = pos + strSize;
    endString = pos + randSize;
    j=0;
    
    int2ascii(in, pos, count);
    pos += 2;
    
    for(pos; pos < endPos ;pos ++)
    {
        if(j > 3 )
            j = 0;
        if(pos < endString)
            in[pos] = testString[j++];
        else
            in[pos] = 0x0;
    }
}

int2ascii (byte in[], dword pos, word value)
{
    //Konvertiert nur die erste und zweite Dezimalstelle, also Zahlen zw. 0 und 99.
    
    //auf 2 Stellen kuerzen
    value = value%100;
    //10er schreiben
    in[pos] = (value/10) + 48;    //  0x30 hex = 48 dez = ascii null
    //1er schreiben
    in[pos+1] = (value%10) + 48;  //  0x30 hex = 48 dez = ascii null
}

