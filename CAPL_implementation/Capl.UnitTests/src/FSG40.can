/*@!Encoding:1252*/
includes
{
  #include "../../_DLL/latest_BAP_DLL.cin"
}

variables
{
	//@BAPSIMGEN_VAR_SECTION_BEGIN

	/***************************************************/
	/*            BapSimGen FSG template               */
	/***************************************************/

	/************** Ausgabe Konsole (Traces) ***********/
	dword gBAP_Trace;
	dword gError_Trace;

	/************** Node Verwaltung ***************/
	//Power on/off
	byte gSG_PowerOnOff=0x01;     // wird mit Power_off/on gesetzt
	byte gBAP_Init=0;             // schon mal initialisiert?

	const Power_off = 0x00;	
	const Power_on	= 0x01;

	mstimer TaskTimer;				//real communication timer

	/************** Request **************/
	const Requestbuffer_lines = 100;
	const BAP_buffer_size = 4096;

	/************ Speichern von Requests im "Ringbuffer" ***********/
	int   gBAP_Requestbuffer_status	[Requestbuffer_lines];		             // 0: kein Eintrag, 1: pending
	dword gBAP_Request_header		[Requestbuffer_lines] [6];				 // beinhaltet auch skalare Daten
	dword gBAP_Request_data         [Requestbuffer_lines] [BAP_buffer_size]; // Ringbuffer fuer BAP-Request


	/************** Indication **************/
	// enthaelt die derzeitige Indication
	dword gBAP_Indication_header[6];	
	byte  gBAP_Indication_data[BAP_buffer_size];		

	/************** Konstanten ****************/

	//BAP Data Type 
	const Bap_void				=0;
	const Bap_uint8				=1;
	const Bap_uint16			=2;
	const Bap_uint32			=3;
	const Bap_byteSequence		=4;
    const Bap_fixedByteSequence =4;
    const Bap_error				=5;
    const Bap_acknowledge		=6;

	char Datatype_Text[7][20] =
	{
		"void", "uint8", "uint16", "uint32", "byteSequence", "error", "acknowledge"
	};
	
	//BAP request types
	const DataSetGet_REQ	= 0x00;
	const DataSet_REQ		= 0x01;
	const DataGet_REQ		= 0x02;
	const Data_REQ			= 0x03;
	const Changed_REQ		= 0x04;
	const Start_REQ			= 0x05;
	const StartResult_REQ	= 0x06;
	const AbortResult_REQ	= 0x07;
	const Processing_REQ	= 0x08;
	const Result_REQ		= 0x09;
	const DataAck_REQ       = 0x0A;
	const Ack_REQ           = 0x0B;
	const Invalid_REQ    	= 0x1F; // Kennzeichnung fuer einen ungueltigen Request
	const Error_REQ         = 0x20;

	char Requesttype_Text[33][30] =
	{
		"DataSetGet_REQ", "DataSet_REQ", "DataGet_REQ", "Data_REQ",			/* 00 .. 03 */
		"Changed_REQ", "Start_REQ", "StartResult_REQ", "AbortResult_REQ",   /* 04 .. 07 */
		"Processing_REQ", "Result_REQ", "DataAck_REQ", "Ack_REQ", 		/* 08 .. 0b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 0c .. 0f */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 10 .. 13 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 14 .. 17 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ", 		/* 18 .. 1b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",  		/* 1c .. 1f */
		"Error_REQ"	  														/* 20 */
	};
	
	//BAP indication types
	const Data_IND				= 0x00;
	const Reset_IND				= 0x01;
	const DataAck_IND			= 0x02;
	const Result_IND			= 0x03;
	const Processing_IND	    = 0x04;
	const Changed_IND			= 0x05;
	const DataSetGet_IND	    = 0x06;
	const DataSet_IND			= 0x07;
	const DataGet_IND			= 0x08;
	const Ack_IND				= 0x09;
	const Processing_CNF_IND	= 0x0A;
	const Start_IND				= 0x0B;
	const StartResult_IND		= 0x0C;
	const AbortResult_IND		= 0x0D;
	const Invalid_IND			= 0x1F; // Kennzeichnung fuer eine ungueltige Indication
	const Error_IND             = 0x20;

	char Indicationtype_Text[33][30] =
	{
		"Data_IND", "Reset_IND", "DataAck_IND", "Result_IND",				/* 00 .. 03 */
		"Processing_IND", "Changed_IND", "DataSetGet_IND", "DataSet_IND",	/* 04 .. 07 */
		"DataGet_IND", "Ack_IND", "Processing_CNF_IND", "Start_REQ",		/* 08 .. 0b */
		"StartResult_REQ", "AbortResult_REQ", "Invalid_REQ", "Invalid_REQ", /* 0c .. 0f */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 10 .. 13 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 14 .. 17 */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 18 .. 1b */
		"Invalid_REQ", "Invalid_REQ", "Invalid_REQ", "Invalid_REQ",			/* 1c .. 1f */
		"Error_REQ"	  														/* 20 */
	};	
	
	char Acknowledgetype_Text[24][30] =
	{
		"Property_SetGet_ACK", "Array_SetGet_ACK", "Property_Set_ACK", "Array_Set_ACK",				/* 00 .. 03 */
		"Method_Start_ACK", "Method_StartResult_ACK", "Method_AbortResult_ACK", "Property_Get_ACK",	/* 04 .. 07 */
		"Array_Get_ACK", "Cache_GetAll_ACK", "Property_Ack_ACK", "Property_Status_ACK",	   			/* 08 .. 0b */
		"Property_StatusAck_ACK", "Property_Error_ACK", "Array_Status_ACK", "Array_Changed_ACK",	/* 0c .. 0f */
		"Array_Error_ACK", "Method_Processing_ACK", "Method_Result_ACK", "Method_Error_ACK",  		/* 10 .. 13 */
		"Unknown_ACK", "Unknown_ACK", "Unknown_ACK", "Unknown_ACK"									/* 14 .. 17 */
	};

	/**************************** Global Function-ID's ******************************/

	byte already_pressed = 0;

	const FctID_GetAll									= 0x01;
	const FctID_BAP_Config								= 0x02;
	const FctID_FunctionList							= 0x03;
	const FctID_HeartBeat								= 0x04;
    
    char SGtype[4]="FSG";


	//// Begin: konfigurationsabhýngige Variablen, die als BAPCONFIG_VARS in Template definiert sind
	
	char  dbc_path[255]             = "BAP\\FSG40_Telefon_46\\bapdb\\BAP_only_MQB_MLBevo_v1.21.dbc";
	char  xml_path[255]             = "BAP\\FSG40_Telefon_46\\bapxml\\BAP_SW17_TEL_FSG_Telefon_v1.0.xml";
	dword NODE_INDEX                =  0;
	char  NODE_NAME[100]            = "Telephone";
	const LSGID                     = 40;
	char  panel_name[100]           = "FSG40_0";
	char  bapconfig_panel_name[100]    = "panel1";
	char  common_panel_name[100]    = "panel2";
	const TaskTime                  = 10;
	 const C_FSG_40_0_0_1_ID = 1;
	 char gCheckbox1[100] = "checkbox_C_FSG_40_0_0_1";
	 char gErrField1[100] = "errfield_C_FSG_40_0_0_1";
	 byte gC_FSG_40_0_0_1_ErrCode = 1;
	 const P_FSG_40_0_0_2_ID = 2;
	 byte P_FSG_40_0_0_2Reset_BTN_already_pressed = 0;
	 char gCheckbox2[100] = "checkbox_P_FSG_40_0_0_2";
	 char gErrField2[100] = "errfield_P_FSG_40_0_0_2";
	 byte gP_FSG_40_0_0_2_ErrCode = 1;
	 const P_FSG_40_0_0_3_ID = 3;
	 byte P_FSG_40_0_0_3Status_BTN_already_pressed = 0;
	 char gCheckbox3[100] = "checkbox_P_FSG_40_0_0_3";
	 char gErrField3[100] = "errfield_P_FSG_40_0_0_3";
	 byte gP_FSG_40_0_0_3_ErrCode = 1;
	 const P_FSG_40_0_0_4_ID = 4;
	 byte P_FSG_40_0_0_4Status_BTN_already_pressed = 0;
	 char gCheckbox4[100] = "checkbox_P_FSG_40_0_0_4";
	 char gErrField4[100] = "errfield_P_FSG_40_0_0_4";
	 byte gP_FSG_40_0_0_4_ErrCode = 1;
	 const P_FSG_40_0_0_14_ID = 14;
	 byte P_FSG_40_0_0_14Status_BTN_already_pressed = 0;
	 char gCheckbox14[100] = "checkbox_P_FSG_40_0_0_14";
	 char gErrField14[100] = "errfield_P_FSG_40_0_0_14";
	 byte gP_FSG_40_0_0_14_ErrCode = 1;
	 char gPanel14[100] = "panel_P_FSG_40_0_0_14";
	 const P_FSG_40_0_0_15_ID = 15;
	 byte P_FSG_40_0_0_15Status_BTN_already_pressed = 0;
	 char gCheckbox15[100] = "checkbox_P_FSG_40_0_0_15";
	 char gErrField15[100] = "errfield_P_FSG_40_0_0_15";
	 byte gP_FSG_40_0_0_15_ErrCode = 1;
	 char gPanel15[100] = "panel_P_FSG_40_0_0_15";
	 const P_FSG_40_0_0_16_ID = 16;
	 byte P_FSG_40_0_0_16Status_BTN_already_pressed = 0;
	 char gCheckbox16[100] = "checkbox_P_FSG_40_0_0_16";
	 char gErrField16[100] = "errfield_P_FSG_40_0_0_16";
	 byte gP_FSG_40_0_0_16_ErrCode = 1;
	 char gPanel16[100] = "panel_P_FSG_40_0_0_16";
	 const P_FSG_40_0_0_17_ID = 17;
	 byte P_FSG_40_0_0_17Status_BTN_already_pressed = 0;
	 char gCheckbox17[100] = "checkbox_P_FSG_40_0_0_17";
	 char gErrField17[100] = "errfield_P_FSG_40_0_0_17";
	 byte gP_FSG_40_0_0_17_ErrCode = 1;
	 char gPanel17[100] = "panel_P_FSG_40_0_0_17";
	 const P_FSG_40_0_0_18_ID = 18;
	 byte P_FSG_40_0_0_18Status_BTN_already_pressed = 0;
	 char gCheckbox18[100] = "checkbox_P_FSG_40_0_0_18";
	 char gErrField18[100] = "errfield_P_FSG_40_0_0_18";
	 byte gP_FSG_40_0_0_18_ErrCode = 1;
	 char gPanel18[100] = "panel_P_FSG_40_0_0_18";
	 const P_FSG_40_0_0_19_ID = 19;
	 byte P_FSG_40_0_0_19Status_BTN_already_pressed = 0;
	 char gCheckbox19[100] = "checkbox_P_FSG_40_0_0_19";
	 char gErrField19[100] = "errfield_P_FSG_40_0_0_19";
	 byte gP_FSG_40_0_0_19_ErrCode = 1;
	 char gPanel19[100] = "panel_P_FSG_40_0_0_19";
	 const P_FSG_40_0_0_20_ID = 20;
	 byte P_FSG_40_0_0_20Status_BTN_already_pressed = 0;
	 char gCheckbox20[100] = "checkbox_P_FSG_40_0_0_20";
	 char gErrField20[100] = "errfield_P_FSG_40_0_0_20";
	 byte gP_FSG_40_0_0_20_ErrCode = 1;
	 char gPanel20[100] = "panel_P_FSG_40_0_0_20";
	 const P_FSG_40_0_0_21_ID = 21;
	 byte P_FSG_40_0_0_21Status_BTN_already_pressed = 0;
	 char gCheckbox21[100] = "checkbox_P_FSG_40_0_0_21";
	 char gErrField21[100] = "errfield_P_FSG_40_0_0_21";
	 byte gP_FSG_40_0_0_21_ErrCode = 1;
	 char gPanel21[100] = "panel_P_FSG_40_0_0_21";
	 const P_FSG_40_0_0_22_ID = 22;
	 byte P_FSG_40_0_0_22Status_BTN_already_pressed = 0;
	 char gCheckbox22[100] = "checkbox_P_FSG_40_0_0_22";
	 char gErrField22[100] = "errfield_P_FSG_40_0_0_22";
	 byte gP_FSG_40_0_0_22_ErrCode = 1;
	 char gPanel22[100] = "panel_P_FSG_40_0_0_22";
	 const P_FSG_40_0_0_23_ID = 23;
	 byte P_FSG_40_0_0_23Status_BTN_already_pressed = 0;
	 char gCheckbox23[100] = "checkbox_P_FSG_40_0_0_23";
	 char gErrField23[100] = "errfield_P_FSG_40_0_0_23";
	 byte gP_FSG_40_0_0_23_ErrCode = 1;
	 char gPanel23[100] = "panel_P_FSG_40_0_0_23";
	 const P_FSG_40_0_0_24_ID = 24;
	 byte P_FSG_40_0_0_24Status_BTN_already_pressed = 0;
	 char gCheckbox24[100] = "checkbox_P_FSG_40_0_0_24";
	 char gErrField24[100] = "errfield_P_FSG_40_0_0_24";
	 byte gP_FSG_40_0_0_24_ErrCode = 1;
	 char gPanel24[100] = "panel_P_FSG_40_0_0_24";
	 const P_FSG_40_0_0_25_ID = 25;
	 byte P_FSG_40_0_0_25Status_BTN_already_pressed = 0;
	 char gCheckbox25[100] = "checkbox_P_FSG_40_0_0_25";
	 char gErrField25[100] = "errfield_P_FSG_40_0_0_25";
	 byte gP_FSG_40_0_0_25_ErrCode = 1;
	 char gPanel25[100] = "panel_P_FSG_40_0_0_25";
	 const M_FSG_40_0_0_26_ID = 26;
	 byte M_FSG_40_0_0_26Result_BTN_already_pressed = 0;
	 char gCheckbox26[100] = "checkbox_M_FSG_40_0_0_26";
	 char gErrField26[100] = "errfield_M_FSG_40_0_0_26";
	 byte gM_FSG_40_0_0_26_ErrCode = 1;
	 char gPanel26[100] = "panel_M_FSG_40_0_0_26";
	 const M_FSG_40_0_0_27_ID = 27;
	 byte M_FSG_40_0_0_27Result_BTN_already_pressed = 0;
	 char gCheckbox27[100] = "checkbox_M_FSG_40_0_0_27";
	 char gErrField27[100] = "errfield_M_FSG_40_0_0_27";
	 byte gM_FSG_40_0_0_27_ErrCode = 1;
	 char gPanel27[100] = "panel_M_FSG_40_0_0_27";
	 const M_FSG_40_0_0_28_ID = 28;
	 byte M_FSG_40_0_0_28Result_BTN_already_pressed = 0;
	 char gCheckbox28[100] = "checkbox_M_FSG_40_0_0_28";
	 char gErrField28[100] = "errfield_M_FSG_40_0_0_28";
	 byte gM_FSG_40_0_0_28_ErrCode = 1;
	 char gPanel28[100] = "panel_M_FSG_40_0_0_28";
	 const M_FSG_40_0_0_29_ID = 29;
	 byte M_FSG_40_0_0_29Result_BTN_already_pressed = 0;
	 char gCheckbox29[100] = "checkbox_M_FSG_40_0_0_29";
	 char gErrField29[100] = "errfield_M_FSG_40_0_0_29";
	 byte gM_FSG_40_0_0_29_ErrCode = 1;
	 char gPanel29[100] = "panel_M_FSG_40_0_0_29";
	 const M_FSG_40_0_0_30_ID = 30;
	 byte M_FSG_40_0_0_30Result_BTN_already_pressed = 0;
	 char gCheckbox30[100] = "checkbox_M_FSG_40_0_0_30";
	 char gErrField30[100] = "errfield_M_FSG_40_0_0_30";
	 byte gM_FSG_40_0_0_30_ErrCode = 1;
	 char gPanel30[100] = "panel_M_FSG_40_0_0_30";
	 const M_FSG_40_0_0_31_ID = 31;
	 byte M_FSG_40_0_0_31Result_BTN_already_pressed = 0;
	 char gCheckbox31[100] = "checkbox_M_FSG_40_0_0_31";
	 char gErrField31[100] = "errfield_M_FSG_40_0_0_31";
	 byte gM_FSG_40_0_0_31_ErrCode = 1;
	 char gPanel31[100] = "panel_M_FSG_40_0_0_31";
	 const M_FSG_40_0_0_32_ID = 32;
	 byte M_FSG_40_0_0_32Result_BTN_already_pressed = 0;
	 char gCheckbox32[100] = "checkbox_M_FSG_40_0_0_32";
	 char gErrField32[100] = "errfield_M_FSG_40_0_0_32";
	 byte gM_FSG_40_0_0_32_ErrCode = 1;
	 char gPanel32[100] = "panel_M_FSG_40_0_0_32";
	 const P_FSG_40_0_0_33_ID = 33;
	 byte P_FSG_40_0_0_33Status_BTN_already_pressed = 0;
	 char gCheckbox33[100] = "checkbox_P_FSG_40_0_0_33";
	 char gErrField33[100] = "errfield_P_FSG_40_0_0_33";
	 byte gP_FSG_40_0_0_33_ErrCode = 1;
	 char gPanel33[100] = "panel_P_FSG_40_0_0_33";
	 const P_FSG_40_0_0_34_ID = 34;
	 byte P_FSG_40_0_0_34Status_BTN_already_pressed = 0;
	 char gCheckbox34[100] = "checkbox_P_FSG_40_0_0_34";
	 char gErrField34[100] = "errfield_P_FSG_40_0_0_34";
	 byte gP_FSG_40_0_0_34_ErrCode = 1;
	 char gPanel34[100] = "panel_P_FSG_40_0_0_34";
	 const M_FSG_40_0_0_35_ID = 35;
	 byte M_FSG_40_0_0_35Result_BTN_already_pressed = 0;
	 char gCheckbox35[100] = "checkbox_M_FSG_40_0_0_35";
	 char gErrField35[100] = "errfield_M_FSG_40_0_0_35";
	 byte gM_FSG_40_0_0_35_ErrCode = 1;
	 char gPanel35[100] = "panel_M_FSG_40_0_0_35";
	 const M_FSG_40_0_0_36_ID = 36;
	 byte M_FSG_40_0_0_36Result_BTN_already_pressed = 0;
	 char gCheckbox36[100] = "checkbox_M_FSG_40_0_0_36";
	 char gErrField36[100] = "errfield_M_FSG_40_0_0_36";
	 byte gM_FSG_40_0_0_36_ErrCode = 1;
	 char gPanel36[100] = "panel_M_FSG_40_0_0_36";
	 const M_FSG_40_0_0_37_ID = 37;
	 byte M_FSG_40_0_0_37Result_BTN_already_pressed = 0;
	 char gCheckbox37[100] = "checkbox_M_FSG_40_0_0_37";
	 char gErrField37[100] = "errfield_M_FSG_40_0_0_37";
	 byte gM_FSG_40_0_0_37_ErrCode = 1;
	 char gPanel37[100] = "panel_M_FSG_40_0_0_37";
	 const M_FSG_40_0_0_38_ID = 38;
	 byte M_FSG_40_0_0_38Result_BTN_already_pressed = 0;
	 char gCheckbox38[100] = "checkbox_M_FSG_40_0_0_38";
	 char gErrField38[100] = "errfield_M_FSG_40_0_0_38";
	 byte gM_FSG_40_0_0_38_ErrCode = 1;
	 char gPanel38[100] = "panel_M_FSG_40_0_0_38";
	 const M_FSG_40_0_0_39_ID = 39;
	 byte M_FSG_40_0_0_39Result_BTN_already_pressed = 0;
	 char gCheckbox39[100] = "checkbox_M_FSG_40_0_0_39";
	 char gErrField39[100] = "errfield_M_FSG_40_0_0_39";
	 byte gM_FSG_40_0_0_39_ErrCode = 1;
	 char gPanel39[100] = "panel_M_FSG_40_0_0_39";
	 const M_FSG_40_0_0_40_ID = 40;
	 byte M_FSG_40_0_0_40Result_BTN_already_pressed = 0;
	 char gCheckbox40[100] = "checkbox_M_FSG_40_0_0_40";
	 char gErrField40[100] = "errfield_M_FSG_40_0_0_40";
	 byte gM_FSG_40_0_0_40_ErrCode = 1;
	 char gPanel40[100] = "panel_M_FSG_40_0_0_40";
	 const M_FSG_40_0_0_41_ID = 41;
	 byte M_FSG_40_0_0_41Result_BTN_already_pressed = 0;
	 char gCheckbox41[100] = "checkbox_M_FSG_40_0_0_41";
	 char gErrField41[100] = "errfield_M_FSG_40_0_0_41";
	 byte gM_FSG_40_0_0_41_ErrCode = 1;
	 char gPanel41[100] = "panel_M_FSG_40_0_0_41";
	 const P_FSG_40_0_0_42_ID = 42;
	 byte P_FSG_40_0_0_42Status_BTN_already_pressed = 0;
	 char gCheckbox42[100] = "checkbox_P_FSG_40_0_0_42";
	 char gErrField42[100] = "errfield_P_FSG_40_0_0_42";
	 byte gP_FSG_40_0_0_42_ErrCode = 1;
	 char gPanel42[100] = "panel_P_FSG_40_0_0_42";
	 const P_FSG_40_0_0_43_ID = 43;
	 byte P_FSG_40_0_0_43Status_BTN_already_pressed = 0;
	 char gCheckbox43[100] = "checkbox_P_FSG_40_0_0_43";
	 char gErrField43[100] = "errfield_P_FSG_40_0_0_43";
	 byte gP_FSG_40_0_0_43_ErrCode = 1;
	 char gPanel43[100] = "panel_P_FSG_40_0_0_43";
	 const P_FSG_40_0_0_44_ID = 44;
	 byte P_FSG_40_0_0_44Status_BTN_already_pressed = 0;
	 char gCheckbox44[100] = "checkbox_P_FSG_40_0_0_44";
	 char gErrField44[100] = "errfield_P_FSG_40_0_0_44";
	 byte gP_FSG_40_0_0_44_ErrCode = 1;
	 char gPanel44[100] = "panel_P_FSG_40_0_0_44";
	 const P_FSG_40_0_0_45_ID = 45;
	 byte P_FSG_40_0_0_45Status_BTN_already_pressed = 0;
	 char gCheckbox45[100] = "checkbox_P_FSG_40_0_0_45";
	 char gErrField45[100] = "errfield_P_FSG_40_0_0_45";
	 byte gP_FSG_40_0_0_45_ErrCode = 1;
	 char gPanel45[100] = "panel_P_FSG_40_0_0_45";
	 const A_FSG_40_0_0_46_ID = 46;
	 byte A_FSG_40_0_0_46Changed_BTN_already_pressed = 0;
	 byte A_FSG_40_0_0_46Status_BTN_already_pressed = 0;
	 char gCheckbox46[100] = "checkbox_A_FSG_40_0_0_46";
	 char gErrField46[100] = "errfield_A_FSG_40_0_0_46";
	 byte gA_FSG_40_0_0_46_ErrCode = 1;
	 char gPanel46[100] = "panel_A_FSG_40_0_0_46";
	 byte A_FSG_40_0_0_46_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_46_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_46_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_46_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_46_generateData_Btn_already_pressed = 0;
	 byte A_FSG_40_0_0_46_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_40_0_0_46_ArrayDataStruct {
		 word Param1;
		 byte Param2[100];
		 word Param2_Length;
		 byte Param3;
		 byte Param4[41];
		 word Param4_Length;
		 byte Param5;
		 byte Param6;
		 byte Param7;
		 byte Param8;
		 byte Param9;
		 byte Param10;
	 };
	 struct A_FSG_40_0_0_46_ArrayDataStruct A_FSG_40_0_0_46_ArrayDataList[60];
	 const A_FSG_40_0_0_46_ArrayDataList_Length = 60;
	 long A_FSG_40_0_0_46_Data_2_LenList[60];
	 byte A_FSG_40_0_0_46_Data_2_CntList[60];
	 long A_FSG_40_0_0_46_Data_2_SetGet_LenList[60];
	 byte A_FSG_40_0_0_46_Data_2_SetGet_CntList[60];
	 long A_FSG_40_0_0_46_Data_4_LenList[60];
	 byte A_FSG_40_0_0_46_Data_4_CntList[60];
	 long A_FSG_40_0_0_46_Data_4_SetGet_LenList[60];
	 byte A_FSG_40_0_0_46_Data_4_SetGet_CntList[60];
	 const A_FSG_40_0_0_47_ID = 47;
	 byte A_FSG_40_0_0_47Changed_BTN_already_pressed = 0;
	 byte A_FSG_40_0_0_47Status_BTN_already_pressed = 0;
	 char gCheckbox47[100] = "checkbox_A_FSG_40_0_0_47";
	 char gErrField47[100] = "errfield_A_FSG_40_0_0_47";
	 byte gA_FSG_40_0_0_47_ErrCode = 1;
	 char gPanel47[100] = "panel_A_FSG_40_0_0_47";
	 byte A_FSG_40_0_0_47_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_47_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_47_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_47_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_47_generateData_Btn_already_pressed = 0;
	 byte A_FSG_40_0_0_47_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_40_0_0_47_ArrayDataStruct {
		 word Param1;
		 byte Param2[100];
		 word Param2_Length;
		 byte Param3;
		 byte Param4[41];
		 word Param4_Length;
		 byte Param5;
		 byte Param6;
		 byte Param7;
		 byte Param8;
		 byte Param9;
		 byte Param10;
	 };
	 struct A_FSG_40_0_0_47_ArrayDataStruct A_FSG_40_0_0_47_ArrayDataList[60];
	 const A_FSG_40_0_0_47_ArrayDataList_Length = 60;
	 long A_FSG_40_0_0_47_Data_2_LenList[60];
	 byte A_FSG_40_0_0_47_Data_2_CntList[60];
	 long A_FSG_40_0_0_47_Data_2_SetGet_LenList[60];
	 byte A_FSG_40_0_0_47_Data_2_SetGet_CntList[60];
	 long A_FSG_40_0_0_47_Data_4_LenList[60];
	 byte A_FSG_40_0_0_47_Data_4_CntList[60];
	 long A_FSG_40_0_0_47_Data_4_SetGet_LenList[60];
	 byte A_FSG_40_0_0_47_Data_4_SetGet_CntList[60];
	 const A_FSG_40_0_0_48_ID = 48;
	 byte A_FSG_40_0_0_48Changed_BTN_already_pressed = 0;
	 byte A_FSG_40_0_0_48Status_BTN_already_pressed = 0;
	 char gCheckbox48[100] = "checkbox_A_FSG_40_0_0_48";
	 char gErrField48[100] = "errfield_A_FSG_40_0_0_48";
	 byte gA_FSG_40_0_0_48_ErrCode = 1;
	 char gPanel48[100] = "panel_A_FSG_40_0_0_48";
	 byte A_FSG_40_0_0_48_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_48_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_48_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_48_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_48_generateData_Btn_already_pressed = 0;
	 byte A_FSG_40_0_0_48_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_40_0_0_48_ArrayDataStruct {
		 word Param1;
		 byte Param2[100];
		 word Param2_Length;
		 byte Param3;
		 byte Param4[41];
		 word Param4_Length;
		 byte Param5;
		 byte Param6;
		 byte Param7;
		 byte Param8;
		 byte Param9;
		 byte Param10;
	 };
	 struct A_FSG_40_0_0_48_ArrayDataStruct A_FSG_40_0_0_48_ArrayDataList[60];
	 const A_FSG_40_0_0_48_ArrayDataList_Length = 60;
	 long A_FSG_40_0_0_48_Data_2_LenList[60];
	 byte A_FSG_40_0_0_48_Data_2_CntList[60];
	 long A_FSG_40_0_0_48_Data_2_SetGet_LenList[60];
	 byte A_FSG_40_0_0_48_Data_2_SetGet_CntList[60];
	 long A_FSG_40_0_0_48_Data_4_LenList[60];
	 byte A_FSG_40_0_0_48_Data_4_CntList[60];
	 long A_FSG_40_0_0_48_Data_4_SetGet_LenList[60];
	 byte A_FSG_40_0_0_48_Data_4_SetGet_CntList[60];
	 const A_FSG_40_0_0_49_ID = 49;
	 byte A_FSG_40_0_0_49Changed_BTN_already_pressed = 0;
	 byte A_FSG_40_0_0_49Status_BTN_already_pressed = 0;
	 char gCheckbox49[100] = "checkbox_A_FSG_40_0_0_49";
	 char gErrField49[100] = "errfield_A_FSG_40_0_0_49";
	 byte gA_FSG_40_0_0_49_ErrCode = 1;
	 char gPanel49[100] = "panel_A_FSG_40_0_0_49";
	 byte A_FSG_40_0_0_49_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_49_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_49_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_49_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_49_generateData_Btn_already_pressed = 0;
	 byte A_FSG_40_0_0_49_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_40_0_0_49_ArrayDataStruct {
		 word Param1;
		 byte Param2[100];
		 word Param2_Length;
		 byte Param3;
		 byte Param4;
		 byte Param5[41];
		 word Param5_Length;
		 byte Param6;
		 byte Param7;
		 byte Param8;
		 byte Param9;
		 byte Param10;
		 byte Param11;
	 };
	 struct A_FSG_40_0_0_49_ArrayDataStruct A_FSG_40_0_0_49_ArrayDataList[1023];
	 const A_FSG_40_0_0_49_ArrayDataList_Length = 1023;
	 long A_FSG_40_0_0_49_Data_2_LenList[1023];
	 byte A_FSG_40_0_0_49_Data_2_CntList[1023];
	 long A_FSG_40_0_0_49_Data_2_SetGet_LenList[1023];
	 byte A_FSG_40_0_0_49_Data_2_SetGet_CntList[1023];
	 long A_FSG_40_0_0_49_Data_5_LenList[1023];
	 byte A_FSG_40_0_0_49_Data_5_CntList[1023];
	 long A_FSG_40_0_0_49_Data_5_SetGet_LenList[1023];
	 byte A_FSG_40_0_0_49_Data_5_SetGet_CntList[1023];
	 const M_FSG_40_0_0_50_ID = 50;
	 byte M_FSG_40_0_0_50Result_BTN_already_pressed = 0;
	 char gCheckbox50[100] = "checkbox_M_FSG_40_0_0_50";
	 char gErrField50[100] = "errfield_M_FSG_40_0_0_50";
	 byte gM_FSG_40_0_0_50_ErrCode = 1;
	 char gPanel50[100] = "panel_M_FSG_40_0_0_50";
	 const P_FSG_40_0_0_51_ID = 51;
	 byte P_FSG_40_0_0_51Status_BTN_already_pressed = 0;
	 char gCheckbox51[100] = "checkbox_P_FSG_40_0_0_51";
	 char gErrField51[100] = "errfield_P_FSG_40_0_0_51";
	 byte gP_FSG_40_0_0_51_ErrCode = 1;
	 char gPanel51[100] = "panel_P_FSG_40_0_0_51";
	 const A_FSG_40_0_0_52_ID = 52;
	 byte A_FSG_40_0_0_52Changed_BTN_already_pressed = 0;
	 byte A_FSG_40_0_0_52Status_BTN_already_pressed = 0;
	 char gCheckbox52[100] = "checkbox_A_FSG_40_0_0_52";
	 char gErrField52[100] = "errfield_A_FSG_40_0_0_52";
	 byte gA_FSG_40_0_0_52_ErrCode = 1;
	 char gPanel52[100] = "panel_A_FSG_40_0_0_52";
	 byte A_FSG_40_0_0_52_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_52_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_52_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_52_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_52_generateData_Btn_already_pressed = 0;
	 byte A_FSG_40_0_0_52_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_40_0_0_52_ArrayDataStruct {
		 word Param1;
		 byte Param2[100];
		 word Param2_Length;
		 byte Param3;
		 byte Param4;
		 byte Param5;
		 byte Param6[410];
		 word Param6_Length;
		 byte Param7;
		 byte Param8;
		 byte Param9;
		 byte Param10;
	 };
	 struct A_FSG_40_0_0_52_ArrayDataStruct A_FSG_40_0_0_52_ArrayDataList[1500];
	 const A_FSG_40_0_0_52_ArrayDataList_Length = 1500;
	 long A_FSG_40_0_0_52_Data_2_LenList[1500];
	 byte A_FSG_40_0_0_52_Data_2_CntList[1500];
	 long A_FSG_40_0_0_52_Data_2_SetGet_LenList[1500];
	 byte A_FSG_40_0_0_52_Data_2_SetGet_CntList[1500];
	 long A_FSG_40_0_0_52_Data_6_LenList[1500];
	 byte A_FSG_40_0_0_52_Data_6_CntList[1500];
	 long A_FSG_40_0_0_52_Data_6_SetGet_LenList[1500];
	 byte A_FSG_40_0_0_52_Data_6_SetGet_CntList[1500];
	 const M_FSG_40_0_0_53_ID = 53;
	 byte M_FSG_40_0_0_53Result_BTN_already_pressed = 0;
	 char gCheckbox53[100] = "checkbox_M_FSG_40_0_0_53";
	 char gErrField53[100] = "errfield_M_FSG_40_0_0_53";
	 byte gM_FSG_40_0_0_53_ErrCode = 1;
	 char gPanel53[100] = "panel_M_FSG_40_0_0_53";
	 const M_FSG_40_0_0_54_ID = 54;
	 byte M_FSG_40_0_0_54Result_BTN_already_pressed = 0;
	 char gCheckbox54[100] = "checkbox_M_FSG_40_0_0_54";
	 char gErrField54[100] = "errfield_M_FSG_40_0_0_54";
	 byte gM_FSG_40_0_0_54_ErrCode = 1;
	 char gPanel54[100] = "panel_M_FSG_40_0_0_54";
	 const P_FSG_40_0_0_55_ID = 55;
	 byte P_FSG_40_0_0_55Status_BTN_already_pressed = 0;
	 char gCheckbox55[100] = "checkbox_P_FSG_40_0_0_55";
	 char gErrField55[100] = "errfield_P_FSG_40_0_0_55";
	 byte gP_FSG_40_0_0_55_ErrCode = 1;
	 char gPanel55[100] = "panel_P_FSG_40_0_0_55";
	 const P_FSG_40_0_0_56_ID = 56;
	 byte P_FSG_40_0_0_56Status_BTN_already_pressed = 0;
	 char gCheckbox56[100] = "checkbox_P_FSG_40_0_0_56";
	 char gErrField56[100] = "errfield_P_FSG_40_0_0_56";
	 byte gP_FSG_40_0_0_56_ErrCode = 1;
	 char gPanel56[100] = "panel_P_FSG_40_0_0_56";
	 const P_FSG_40_0_0_57_ID = 57;
	 byte P_FSG_40_0_0_57Status_BTN_already_pressed = 0;
	 char gCheckbox57[100] = "checkbox_P_FSG_40_0_0_57";
	 char gErrField57[100] = "errfield_P_FSG_40_0_0_57";
	 byte gP_FSG_40_0_0_57_ErrCode = 1;
	 char gPanel57[100] = "panel_P_FSG_40_0_0_57";
	 const P_FSG_40_0_0_58_ID = 58;
	 byte P_FSG_40_0_0_58Status_BTN_already_pressed = 0;
	 char gCheckbox58[100] = "checkbox_P_FSG_40_0_0_58";
	 char gErrField58[100] = "errfield_P_FSG_40_0_0_58";
	 byte gP_FSG_40_0_0_58_ErrCode = 1;
	 char gPanel58[100] = "panel_P_FSG_40_0_0_58";
	 const P_FSG_40_0_0_59_ID = 59;
	 byte P_FSG_40_0_0_59Status_BTN_already_pressed = 0;
	 char gCheckbox59[100] = "checkbox_P_FSG_40_0_0_59";
	 char gErrField59[100] = "errfield_P_FSG_40_0_0_59";
	 byte gP_FSG_40_0_0_59_ErrCode = 1;
	 char gPanel59[100] = "panel_P_FSG_40_0_0_59";
	 const A_FSG_40_0_0_60_ID = 60;
	 byte A_FSG_40_0_0_60Changed_BTN_already_pressed = 0;
	 byte A_FSG_40_0_0_60Status_BTN_already_pressed = 0;
	 char gCheckbox60[100] = "checkbox_A_FSG_40_0_0_60";
	 char gErrField60[100] = "errfield_A_FSG_40_0_0_60";
	 byte gA_FSG_40_0_0_60_ErrCode = 1;
	 char gPanel60[100] = "panel_A_FSG_40_0_0_60";
	 byte A_FSG_40_0_0_60_DataIndex_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_60_DataIndex_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_60_DataIndex_SetGet_Decr_already_pressed = 0;
	 byte A_FSG_40_0_0_60_DataIndex_SetGet_Incr_already_pressed = 0;
	 byte A_FSG_40_0_0_60_generateData_Btn_already_pressed = 0;
	 byte A_FSG_40_0_0_60_loadArray_Btn_already_pressed = 0;
	 _align(1) struct A_FSG_40_0_0_60_ArrayDataStruct {
		 word Param1;
		 byte Param2[100];
		 word Param2_Length;
		 byte Param3;
		 byte Param4[41];
		 word Param4_Length;
	 };
	 struct A_FSG_40_0_0_60_ArrayDataStruct A_FSG_40_0_0_60_ArrayDataList[60];
	 const A_FSG_40_0_0_60_ArrayDataList_Length = 60;
	 long A_FSG_40_0_0_60_Data_2_LenList[60];
	 byte A_FSG_40_0_0_60_Data_2_CntList[60];
	 long A_FSG_40_0_0_60_Data_2_SetGet_LenList[60];
	 byte A_FSG_40_0_0_60_Data_2_SetGet_CntList[60];
	 long A_FSG_40_0_0_60_Data_4_LenList[60];
	 byte A_FSG_40_0_0_60_Data_4_CntList[60];
	 long A_FSG_40_0_0_60_Data_4_SetGet_LenList[60];
	 byte A_FSG_40_0_0_60_Data_4_SetGet_CntList[60];
	 const P_FSG_40_0_0_61_ID = 61;
	 byte P_FSG_40_0_0_61Status_BTN_already_pressed = 0;
	 char gCheckbox61[100] = "checkbox_P_FSG_40_0_0_61";
	 char gErrField61[100] = "errfield_P_FSG_40_0_0_61";
	 byte gP_FSG_40_0_0_61_ErrCode = 1;
	 char gPanel61[100] = "panel_P_FSG_40_0_0_61";
	 const P_FSG_40_0_0_62_ID = 62;
	 byte P_FSG_40_0_0_62Status_BTN_already_pressed = 0;
	 char gCheckbox62[100] = "checkbox_P_FSG_40_0_0_62";
	 char gErrField62[100] = "errfield_P_FSG_40_0_0_62";
	 byte gP_FSG_40_0_0_62_ErrCode = 1;
	 char gPanel62[100] = "panel_P_FSG_40_0_0_62";
	 const M_FSG_40_0_0_63_ID = 63;
	 byte M_FSG_40_0_0_63Result_BTN_already_pressed = 0;
	 char gCheckbox63[100] = "checkbox_M_FSG_40_0_0_63";
	 char gErrField63[100] = "errfield_M_FSG_40_0_0_63";
	 byte gM_FSG_40_0_0_63_ErrCode = 1;
	 char gPanel63[100] = "panel_M_FSG_40_0_0_63";

     
	 msTimer disconnectingTimer;
	 msTimer disconnectingTimer_Methods; 
  char gDialTelNumber_string[40];  
  byte gDialTelNumber_data[40];
  char gDialName_string[100];
  byte gDialName_data[100];
  msTimer setDIALcallState;
  msTimer setcallInfo;
  int gcallID;
  int gCallState[7];
  int gCallType[7];
  int gcallIDActive;
  
  //CallState
  const idle=0x00;
  const ringing_waiting=0x01;
  const active=0x02;
  const dialing=0x03;
  const disconnecting=0x04;
  const onhold=0x05;
  const connected_CIB=0x06;
  const REMOTE_SIDE_BUSY=0x07;
  //const AUTOMATIC_REDIAL_ACTIVE=0x08;
  //const INCOMING_ON_HOLD=0x09;
  const INCOMING_ON_HOLD=0x08;
  const ecallconfirmationpending = 0xAA; // random value for checking emergency call state
  
  const CALL_INFO_NUMBER_LENGTH=40;
  const CALL_INFO_NAME_LENGTH=99;
  
  char gincomingcall_number [CALL_INFO_NUMBER_LENGTH];
  char gincomingcall_name [CALL_INFO_NAME_LENGTH];
  
  
  byte gHangupCall_CallID=0;
  const ALL_ACTIVE_CALLS	    	=0xFC;
  const ALL_HELD_CALLS			=0xFD;
  const ALL_ACTIVE_AND_HELD_CALLS	=0xFE;
  const ALL_CALLS			    	=0xFF;

  byte gHangupCall_Result=0;
  
  msTimer MPswapTimer;
  timer EmergencyCallTimer; // timer in seconds !!
  
  
  _align(1)struct Telefon_CombinedNumbers_ArrayDataStruct
  {
    word  Param1;
	  char  Param2[100];
	  word  Param2_Length;
	  byte  Param3;
	  byte  Param4;    
	  char  Param5[41];
	  word  Param5_Length;
	  byte  Param6;
	  byte  Param7;
	  byte  Param8;
	  byte  Param9;
	  byte  Param10;
	  byte  Param11;
  };
  
      const BAP_BUFFERSIZE = 4096;
  const Max_Array_Size = 1024;
  const TRUE = 1;
  const FALSE = 0;
    struct  Telefon_CombinedNumbers_ArrayDataStruct   Telefon_CombinedNumbers[Max_Array_Size];
  
     ///////////////////// Listen Variablen /////////////////////
  
  byte   Telefon_CombinedNumbers_TotalListNum             = 0;
  char  gTelefon_CombinedNumbers_Path[255]                = "";
  const  Telefon_CombinedNumbers_Length                   = 255;
  int    Telefon_Phonebook_TotalListNum                   = 0;
  char  gTelefon_Phonebook_Path[255]                      = "";
  const  Telefon_Phonebook__Length                        = 255;
  byte   Telefon_FavoriteList_TotalListNum                = 0;
  char  gTelefon_FavoriteList_Path[255]                   = "";
  const  Telefon_FavoriteList_Length                      = 255;
  
     ///////////////////// Logische Kanäle /////////////////////  
  
  byte   Telefon_CombinedNumbers_Log_Channel;
  byte   Telefon_Phonebook_Log_Channel;
  byte   Telefon_FavoriteList_Log_Channel;
  
    ///////////////////// Array Variablen /////////////////////  
  
  byte   Data_Telefon_CombinedNumbers[BAP_BUFFERSIZE];
  int       j_Telefon_CombinedNumbers = 0; 
  byte   Data_Telefon_Phonebook[BAP_BUFFERSIZE];
  int       j_Telefon_Phonebook = 0;
  byte   Data_Telefon_FavoriteList[BAP_BUFFERSIZE];
  int       j_Telefon_FavoriteList = 0;
  
    ///////////////////// Delay Timer /////////////////////
  
  mstimer Delay_Telefon_CombinedNumbers;
  mstimer Delay_Telefon_Phonebook;
  mstimer Delay_Telefon_FavoriteList;
  
  ///////////////////// Mix Variablen /////////////////////
  
    // Telefon
  byte TelNumberQuantity;
  
    byte Telefon_Source         = 0;
	
	// CallType 
  
  const unknownCall=0x00;
  const singleVoiceCall=0x01;
  const dataCall=0x02;
  const faxCall=0x03;
  const emergencyCall=0x04;
  const conferenceVoiceCall=0x05;
  const infoCall=0x06;
  const serviceCall=0x07;
  const ACNCall=0x08;
  
  byte areAllOnHold = 0;
  

	//// End konfigurationsabhýngige Variablen 
	
	/// Begin: Definition der BUS-Schnittstellen
	
	// FLEXRAY NOT ENABLED!
	
	// ETHERNET NOT ENABLED! 
	
	//// End Bus Schnittstellen

}

on preStart
{
    char Version[200];
    char Path[255];

    /***** Erzeugen der Ausgabeconsolen *****/  
    gBAP_Trace=writecreate("BAP-Trace");        //write-window for BAP-cummunication
    writeclear(gBAP_Trace);                     //clear BAP-window in write-window
    
    gError_Trace=writecreate("Error");          //error-window for BAP-cummunication
    writeclear(gError_Trace);                   //clear error-window in write-window
    
    writeclear(1);                              //clear CAPL-window in write-window
    
    /**** Versionsstring von DLL holen und auf Bildschirm ausgeben ***/ 
    BAP150_GetVersions(Version, 200);
    writelineEx(gBAP_Trace, 0, "Versionx:%s", Version);
                                            
    NODE_INDEX = BAP150_CreateNode();
    writelineEx(gBAP_Trace, 0, "FSG %d Nodeindex:%d", LSGID, Version);
    
    /**** Laden der CANoe Datenbank *****/
    getAbsFilePath(dbc_path, Path, 255);
    writelineEx(gBAP_Trace, 0, "Load BAP_DBC-File: %s", Path);
    if(BAP150_LoadDBC(NODE_INDEX, 1, Path)  != 0) {        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
    }

    /**** Laden des BAP XML Files ****/
    getAbsFilePath(xml_path, Path, 255);
    writelineEx(gBAP_Trace, 0, "Load BAP-XML-File: %s", Path);
    if (BAP150_LoadConfig(NODE_INDEX, Path) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Laden: %s !", Path);
    }

    if (BAP150_AddCanMap(NODE_INDEX, 1, 1) != 0) {
        writelineEx(gError_Trace, 0, "Fehler beim Mappen!");
    }   
    
    // FLEXRAY NOT ENABLED!
}

DisableFctCtrl ()
{
  	EnableControl(panel_name, common_panel_name, 0);
	EnableControl(panel_name,gErrField1,0);
	EnableControl(panel_name,gErrField2,0);
	EnableControl(panel_name,gErrField3,0);
	EnableControl(panel_name,gErrField4,0);
	EnableControl(panel_name,gErrField14,0);
	EnableControl(panel_name,gPanel14,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_14",0);
	EnableControl(panel_name,gErrField15,0);
	EnableControl(panel_name,gPanel15,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_15",0);
	EnableControl(panel_name,gErrField16,0);
	EnableControl(panel_name,gPanel16,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_16",0);
	EnableControl(panel_name,gErrField17,0);
	EnableControl(panel_name,gPanel17,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_17",0);
	EnableControl(panel_name,gErrField18,0);
	EnableControl(panel_name,gPanel18,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_18",0);
	EnableControl(panel_name,gErrField19,0);
	EnableControl(panel_name,gPanel19,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_19",0);
	EnableControl(panel_name,gErrField20,0);
	EnableControl(panel_name,gPanel20,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_20",0);
	EnableControl(panel_name,gErrField21,0);
	EnableControl(panel_name,gPanel21,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_21",0);
	EnableControl(panel_name,gErrField22,0);
	EnableControl(panel_name,gPanel22,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_22",0);
	EnableControl(panel_name,gErrField23,0);
	EnableControl(panel_name,gPanel23,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_23",0);
	EnableControl(panel_name,gErrField24,0);
	EnableControl(panel_name,gPanel24,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_24",0);
	EnableControl(panel_name,gErrField25,0);
	EnableControl(panel_name,gPanel25,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_25",0);
	EnableControl(panel_name,gErrField26,0);
	EnableControl(panel_name,gPanel26,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Start",0);
	EnableControl(panel_name,gErrField27,0);
	EnableControl(panel_name,gPanel27,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Start",0);
	EnableControl(panel_name,gErrField28,0);
	EnableControl(panel_name,gPanel28,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Start",0);
	EnableControl(panel_name,gErrField29,0);
	EnableControl(panel_name,gPanel29,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Start",0);
	EnableControl(panel_name,gErrField30,0);
	EnableControl(panel_name,gPanel30,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Start",0);
	EnableControl(panel_name,gErrField31,0);
	EnableControl(panel_name,gPanel31,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Start",0);
	EnableControl(panel_name,gErrField32,0);
	EnableControl(panel_name,gPanel32,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Start",0);
	EnableControl(panel_name,gErrField33,0);
	EnableControl(panel_name,gPanel33,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_33",0);
	EnableControl(panel_name,gErrField34,0);
	EnableControl(panel_name,gPanel34,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_34",0);
	EnableControl(panel_name,gErrField35,0);
	EnableControl(panel_name,gPanel35,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Start",0);
	EnableControl(panel_name,gErrField36,0);
	EnableControl(panel_name,gPanel36,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Start",0);
	EnableControl(panel_name,gErrField37,0);
	EnableControl(panel_name,gPanel37,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Start",0);
	EnableControl(panel_name,gErrField38,0);
	EnableControl(panel_name,gPanel38,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Start",0);
	EnableControl(panel_name,gErrField39,0);
	EnableControl(panel_name,gPanel39,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Start",0);
	EnableControl(panel_name,gErrField40,0);
	EnableControl(panel_name,gPanel40,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Start",0);
	EnableControl(panel_name,gErrField41,0);
	EnableControl(panel_name,gPanel41,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Start",0);
	EnableControl(panel_name,gErrField42,0);
	EnableControl(panel_name,gPanel42,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_42",0);
	EnableControl(panel_name,gErrField43,0);
	EnableControl(panel_name,gPanel43,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_43",0);
	EnableControl(panel_name,gErrField44,0);
	EnableControl(panel_name,gPanel44,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_44",0);
	EnableControl(panel_name,gErrField45,0);
	EnableControl(panel_name,gPanel45,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_45",0);
	EnableControl(panel_name,gErrField46,0);
	EnableControl(panel_name,gPanel46,0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_46",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Status",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_46_SetGet",0);
	EnableControl(panel_name,gErrField47,0);
	EnableControl(panel_name,gPanel47,0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_47",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Status",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_47_SetGet",0);
	EnableControl(panel_name,gErrField48,0);
	EnableControl(panel_name,gPanel48,0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_48",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Status",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_48_SetGet",0);
	EnableControl(panel_name,gErrField49,0);
	EnableControl(panel_name,gPanel49,0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_49",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Status",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_49_SetGet",0);
	EnableControl(panel_name,gErrField50,0);
	EnableControl(panel_name,gPanel50,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Start",0);
	EnableControl(panel_name,gErrField51,0);
	EnableControl(panel_name,gPanel51,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_51",0);
	EnableControl(panel_name,gErrField52,0);
	EnableControl(panel_name,gPanel52,0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_52",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Status",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_52_SetGet",0);
	EnableControl(panel_name,gErrField53,0);
	EnableControl(panel_name,gPanel53,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Start",0);
	EnableControl(panel_name,gErrField54,0);
	EnableControl(panel_name,gPanel54,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Start",0);
	EnableControl(panel_name,gErrField55,0);
	EnableControl(panel_name,gPanel55,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_55",0);
	EnableControl(panel_name,gErrField56,0);
	EnableControl(panel_name,gPanel56,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_56",0);
	EnableControl(panel_name,gErrField57,0);
	EnableControl(panel_name,gPanel57,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_57",0);
	EnableControl(panel_name,gErrField58,0);
	EnableControl(panel_name,gPanel58,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_58",0);
	EnableControl(panel_name,gErrField59,0);
	EnableControl(panel_name,gPanel59,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_59",0);
	EnableControl(panel_name,gErrField60,0);
	EnableControl(panel_name,gPanel60,0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_60",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Status",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Changed",0);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_60_SetGet",0);
	EnableControl(panel_name,gErrField61,0);
	EnableControl(panel_name,gPanel61,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_61",0);
	EnableControl(panel_name,gErrField62,0);
	EnableControl(panel_name,gPanel62,0);
	EnableControl(panel_name,"panel_P_FSG_40_0_0_62",0);
	EnableControl(panel_name,gErrField63,0);
	EnableControl(panel_name,gPanel63,0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Result",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Processing",0);
	EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Start",0);

}

EnableFctCtrl ()
{
  	EnableControl(panel_name, common_panel_name, 1);
	if(getValue(P_FSG_40_0_0_14_FctLstItemEn)){
		 EnableControl(panel_name,gPanel14,1);
		 EnableControl(panel_name,gErrField14,1);
	}
	if(getValue(P_FSG_40_0_0_15_FctLstItemEn)){
		 EnableControl(panel_name,gPanel15,1);
		 EnableControl(panel_name,gErrField15,1);
	}
	if(getValue(P_FSG_40_0_0_16_FctLstItemEn)){
		 EnableControl(panel_name,gPanel16,1);
		 EnableControl(panel_name,gErrField16,1);
	}
	if(getValue(P_FSG_40_0_0_17_FctLstItemEn)){
		 EnableControl(panel_name,gPanel17,1);
		 EnableControl(panel_name,gErrField17,1);
	}
	if(getValue(P_FSG_40_0_0_18_FctLstItemEn)){
		 EnableControl(panel_name,gPanel18,1);
		 EnableControl(panel_name,gErrField18,1);
	}
	if(getValue(P_FSG_40_0_0_19_FctLstItemEn)){
		 EnableControl(panel_name,gPanel19,1);
		 EnableControl(panel_name,gErrField19,1);
	}
	if(getValue(P_FSG_40_0_0_20_FctLstItemEn)){
		 EnableControl(panel_name,gPanel20,1);
		 EnableControl(panel_name,gErrField20,1);
	}
	if(getValue(P_FSG_40_0_0_21_FctLstItemEn)){
		 EnableControl(panel_name,gPanel21,1);
		 EnableControl(panel_name,gErrField21,1);
	}
	if(getValue(P_FSG_40_0_0_22_FctLstItemEn)){
		 EnableControl(panel_name,gPanel22,1);
		 EnableControl(panel_name,gErrField22,1);
	}
	if(getValue(P_FSG_40_0_0_23_FctLstItemEn)){
		 EnableControl(panel_name,gPanel23,1);
		 EnableControl(panel_name,gErrField23,1);
	}
	if(getValue(P_FSG_40_0_0_24_FctLstItemEn)){
		 EnableControl(panel_name,gPanel24,1);
		 EnableControl(panel_name,gErrField24,1);
	}
	if(getValue(P_FSG_40_0_0_25_FctLstItemEn)){
		 EnableControl(panel_name,gPanel25,1);
		 EnableControl(panel_name,gErrField25,1);
	}
	if(getValue(M_FSG_40_0_0_26_FctLstItemEn)){
		 EnableControl(panel_name,gPanel26,1);
		 EnableControl(panel_name,gErrField26,1);
	}
	if(getValue(M_FSG_40_0_0_27_FctLstItemEn)){
		 EnableControl(panel_name,gPanel27,1);
		 EnableControl(panel_name,gErrField27,1);
	}
	if(getValue(M_FSG_40_0_0_28_FctLstItemEn)){
		 EnableControl(panel_name,gPanel28,1);
		 EnableControl(panel_name,gErrField28,1);
	}
	if(getValue(M_FSG_40_0_0_29_FctLstItemEn)){
		 EnableControl(panel_name,gPanel29,1);
		 EnableControl(panel_name,gErrField29,1);
	}
	if(getValue(M_FSG_40_0_0_30_FctLstItemEn)){
		 EnableControl(panel_name,gPanel30,1);
		 EnableControl(panel_name,gErrField30,1);
	}
	if(getValue(M_FSG_40_0_0_31_FctLstItemEn)){
		 EnableControl(panel_name,gPanel31,1);
		 EnableControl(panel_name,gErrField31,1);
	}
	if(getValue(M_FSG_40_0_0_32_FctLstItemEn)){
		 EnableControl(panel_name,gPanel32,1);
		 EnableControl(panel_name,gErrField32,1);
	}
	if(getValue(P_FSG_40_0_0_33_FctLstItemEn)){
		 EnableControl(panel_name,gPanel33,1);
		 EnableControl(panel_name,gErrField33,1);
	}
	if(getValue(P_FSG_40_0_0_34_FctLstItemEn)){
		 EnableControl(panel_name,gPanel34,1);
		 EnableControl(panel_name,gErrField34,1);
	}
	if(getValue(M_FSG_40_0_0_35_FctLstItemEn)){
		 EnableControl(panel_name,gPanel35,1);
		 EnableControl(panel_name,gErrField35,1);
	}
	if(getValue(M_FSG_40_0_0_36_FctLstItemEn)){
		 EnableControl(panel_name,gPanel36,1);
		 EnableControl(panel_name,gErrField36,1);
	}
	if(getValue(M_FSG_40_0_0_37_FctLstItemEn)){
		 EnableControl(panel_name,gPanel37,1);
		 EnableControl(panel_name,gErrField37,1);
	}
	if(getValue(M_FSG_40_0_0_38_FctLstItemEn)){
		 EnableControl(panel_name,gPanel38,1);
		 EnableControl(panel_name,gErrField38,1);
	}
	if(getValue(M_FSG_40_0_0_39_FctLstItemEn)){
		 EnableControl(panel_name,gPanel39,1);
		 EnableControl(panel_name,gErrField39,1);
	}
	if(getValue(M_FSG_40_0_0_40_FctLstItemEn)){
		 EnableControl(panel_name,gPanel40,1);
		 EnableControl(panel_name,gErrField40,1);
	}
	if(getValue(M_FSG_40_0_0_41_FctLstItemEn)){
		 EnableControl(panel_name,gPanel41,1);
		 EnableControl(panel_name,gErrField41,1);
	}
	if(getValue(P_FSG_40_0_0_42_FctLstItemEn)){
		 EnableControl(panel_name,gPanel42,1);
		 EnableControl(panel_name,gErrField42,1);
	}
	if(getValue(P_FSG_40_0_0_43_FctLstItemEn)){
		 EnableControl(panel_name,gPanel43,1);
		 EnableControl(panel_name,gErrField43,1);
	}
	if(getValue(P_FSG_40_0_0_44_FctLstItemEn)){
		 EnableControl(panel_name,gPanel44,1);
		 EnableControl(panel_name,gErrField44,1);
	}
	if(getValue(P_FSG_40_0_0_45_FctLstItemEn)){
		 EnableControl(panel_name,gPanel45,1);
		 EnableControl(panel_name,gErrField45,1);
	}
	if(getValue(A_FSG_40_0_0_46_FctLstItemEn)){
		 EnableControl(panel_name,gPanel46,1);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Status",1);
		 EnableControl(panel_name,gErrField46,1);
	}
	if(getValue(A_FSG_40_0_0_47_FctLstItemEn)){
		 EnableControl(panel_name,gPanel47,1);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Status",1);
		 EnableControl(panel_name,gErrField47,1);
	}
	if(getValue(A_FSG_40_0_0_48_FctLstItemEn)){
		 EnableControl(panel_name,gPanel48,1);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Status",1);
		 EnableControl(panel_name,gErrField48,1);
	}
	if(getValue(A_FSG_40_0_0_49_FctLstItemEn)){
		 EnableControl(panel_name,gPanel49,1);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Status",1);
		 EnableControl(panel_name,gErrField49,1);
	}
	if(getValue(M_FSG_40_0_0_50_FctLstItemEn)){
		 EnableControl(panel_name,gPanel50,1);
		 EnableControl(panel_name,gErrField50,1);
	}
	if(getValue(P_FSG_40_0_0_51_FctLstItemEn)){
		 EnableControl(panel_name,gPanel51,1);
		 EnableControl(panel_name,gErrField51,1);
	}
	if(getValue(A_FSG_40_0_0_52_FctLstItemEn)){
		 EnableControl(panel_name,gPanel52,1);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Status",1);
		 EnableControl(panel_name,gErrField52,1);
	}
	if(getValue(M_FSG_40_0_0_53_FctLstItemEn)){
		 EnableControl(panel_name,gPanel53,1);
		 EnableControl(panel_name,gErrField53,1);
	}
	if(getValue(M_FSG_40_0_0_54_FctLstItemEn)){
		 EnableControl(panel_name,gPanel54,1);
		 EnableControl(panel_name,gErrField54,1);
	}
	if(getValue(P_FSG_40_0_0_55_FctLstItemEn)){
		 EnableControl(panel_name,gPanel55,1);
		 EnableControl(panel_name,gErrField55,1);
	}
	if(getValue(P_FSG_40_0_0_56_FctLstItemEn)){
		 EnableControl(panel_name,gPanel56,1);
		 EnableControl(panel_name,gErrField56,1);
	}
	if(getValue(P_FSG_40_0_0_57_FctLstItemEn)){
		 EnableControl(panel_name,gPanel57,1);
		 EnableControl(panel_name,gErrField57,1);
	}
	if(getValue(P_FSG_40_0_0_58_FctLstItemEn)){
		 EnableControl(panel_name,gPanel58,1);
		 EnableControl(panel_name,gErrField58,1);
	}
	if(getValue(P_FSG_40_0_0_59_FctLstItemEn)){
		 EnableControl(panel_name,gPanel59,1);
		 EnableControl(panel_name,gErrField59,1);
	}
	if(getValue(A_FSG_40_0_0_60_FctLstItemEn)){
		 EnableControl(panel_name,gPanel60,1);
	EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Status",1);
		 EnableControl(panel_name,gErrField60,1);
	}
	if(getValue(P_FSG_40_0_0_61_FctLstItemEn)){
		 EnableControl(panel_name,gPanel61,1);
		 EnableControl(panel_name,gErrField61,1);
	}
	if(getValue(P_FSG_40_0_0_62_FctLstItemEn)){
		 EnableControl(panel_name,gPanel62,1);
		 EnableControl(panel_name,gErrField62,1);
	}
	if(getValue(M_FSG_40_0_0_63_FctLstItemEn)){
		 EnableControl(panel_name,gPanel63,1);
		 EnableControl(panel_name,gErrField63,1);
	}

}

DisableConfigCtrl ()
{
  	EnableControl(panel_name, bapconfig_panel_name, 0);
	EnableControl(panel_name, "panel1_edit", 0);
//	EnableControl(panel_name,gCheckbox1,0);
//	if(!getValue(C_FSG_40_0_0_1_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox1,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox2,0);
//	if(!getValue(P_FSG_40_0_0_2_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox2,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox3,0);
//	if(!getValue(P_FSG_40_0_0_3_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox3,MakeRGB(200,200,200));
//	}
	EnableControl(panel_name, "panel_P_FSG_40_0_0_4", 0);
//	EnableControl(panel_name,gCheckbox4,0);
//	if(!getValue(P_FSG_40_0_0_4_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox4,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox14,0);
//	if(!getValue(P_FSG_40_0_0_14_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox14,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox15,0);
//	if(!getValue(P_FSG_40_0_0_15_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox15,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox16,0);
//	if(!getValue(P_FSG_40_0_0_16_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox16,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox17,0);
//	if(!getValue(P_FSG_40_0_0_17_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox17,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox18,0);
//	if(!getValue(P_FSG_40_0_0_18_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox18,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox19,0);
//	if(!getValue(P_FSG_40_0_0_19_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox19,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox20,0);
//	if(!getValue(P_FSG_40_0_0_20_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox20,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox21,0);
//	if(!getValue(P_FSG_40_0_0_21_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox21,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox22,0);
//	if(!getValue(P_FSG_40_0_0_22_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox22,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox23,0);
//	if(!getValue(P_FSG_40_0_0_23_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox23,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox24,0);
//	if(!getValue(P_FSG_40_0_0_24_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox24,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox25,0);
//	if(!getValue(P_FSG_40_0_0_25_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox25,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox26,0);
//	if(!getValue(M_FSG_40_0_0_26_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox26,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox27,0);
//	if(!getValue(M_FSG_40_0_0_27_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox27,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox28,0);
//	if(!getValue(M_FSG_40_0_0_28_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox28,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox29,0);
//	if(!getValue(M_FSG_40_0_0_29_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox29,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox30,0);
//	if(!getValue(M_FSG_40_0_0_30_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox30,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox31,0);
//	if(!getValue(M_FSG_40_0_0_31_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox31,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox32,0);
//	if(!getValue(M_FSG_40_0_0_32_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox32,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox33,0);
//	if(!getValue(P_FSG_40_0_0_33_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox33,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox34,0);
//	if(!getValue(P_FSG_40_0_0_34_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox34,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox35,0);
//	if(!getValue(M_FSG_40_0_0_35_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox35,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox36,0);
//	if(!getValue(M_FSG_40_0_0_36_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox36,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox37,0);
//	if(!getValue(M_FSG_40_0_0_37_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox37,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox38,0);
//	if(!getValue(M_FSG_40_0_0_38_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox38,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox39,0);
//	if(!getValue(M_FSG_40_0_0_39_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox39,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox40,0);
//	if(!getValue(M_FSG_40_0_0_40_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox40,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox41,0);
//	if(!getValue(M_FSG_40_0_0_41_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox41,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox42,0);
//	if(!getValue(P_FSG_40_0_0_42_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox42,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox43,0);
//	if(!getValue(P_FSG_40_0_0_43_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox43,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox44,0);
//	if(!getValue(P_FSG_40_0_0_44_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox44,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox45,0);
//	if(!getValue(P_FSG_40_0_0_45_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox45,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox46,0);
//	if(!getValue(A_FSG_40_0_0_46_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox46,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox47,0);
//	if(!getValue(A_FSG_40_0_0_47_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox47,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox48,0);
//	if(!getValue(A_FSG_40_0_0_48_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox48,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox49,0);
//	if(!getValue(A_FSG_40_0_0_49_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox49,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox50,0);
//	if(!getValue(M_FSG_40_0_0_50_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox50,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox51,0);
//	if(!getValue(P_FSG_40_0_0_51_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox51,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox52,0);
//	if(!getValue(A_FSG_40_0_0_52_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox52,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox53,0);
//	if(!getValue(M_FSG_40_0_0_53_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox53,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox54,0);
//	if(!getValue(M_FSG_40_0_0_54_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox54,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox55,0);
//	if(!getValue(P_FSG_40_0_0_55_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox55,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox56,0);
//	if(!getValue(P_FSG_40_0_0_56_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox56,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox57,0);
//	if(!getValue(P_FSG_40_0_0_57_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox57,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox58,0);
//	if(!getValue(P_FSG_40_0_0_58_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox58,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox59,0);
//	if(!getValue(P_FSG_40_0_0_59_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox59,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox60,0);
//	if(!getValue(A_FSG_40_0_0_60_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox60,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox61,0);
//	if(!getValue(P_FSG_40_0_0_61_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox61,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox62,0);
//	if(!getValue(P_FSG_40_0_0_62_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox62,MakeRGB(200,200,200));
//	}
//	EnableControl(panel_name,gCheckbox63,0);
//	if(!getValue(M_FSG_40_0_0_63_FctLstItemEn)){
//		 SetControlBackColor(panel_name,gCheckbox63,MakeRGB(200,200,200));
//	}

}

EnableConfigCtrl ()
{
  	EnableControl(panel_name, bapconfig_panel_name, 1);
	EnableControl(panel_name, "panel1_edit", 1);
	if(getValue(C_FSG_40_0_0_1_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox1, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox1, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_2_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox2, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox2, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_3_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox3, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox3, MakeRGB(250,0,0));
	}
	EnableControl(panel_name, "panel_P_FSG_40_0_0_4", 1);
	if(getValue(P_FSG_40_0_0_4_FctLstItemEn))
	{
		setControlForeColor(panel_name, gCheckbox4, MakeRGB(0,240,0));
	}
	else
	{
		setControlForeColor(panel_name, gCheckbox4, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_14_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_14",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_14",1);
		setControlForeColor(panel_name, gCheckbox14, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_14",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_14",0);
		setControlForeColor(panel_name, gCheckbox14, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_15_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_15",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_15",1);
		setControlForeColor(panel_name, gCheckbox15, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_15",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_15",0);
		setControlForeColor(panel_name, gCheckbox15, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_16_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_16",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_16",1);
		setControlForeColor(panel_name, gCheckbox16, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_16",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_16",0);
		setControlForeColor(panel_name, gCheckbox16, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_17_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_17",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_17",1);
		setControlForeColor(panel_name, gCheckbox17, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_17",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_17",0);
		setControlForeColor(panel_name, gCheckbox17, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_18_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_18",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_18",1);
		setControlForeColor(panel_name, gCheckbox18, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_18",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_18",0);
		setControlForeColor(panel_name, gCheckbox18, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_19_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_19",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_19",1);
		setControlForeColor(panel_name, gCheckbox19, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_19",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_19",0);
		setControlForeColor(panel_name, gCheckbox19, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_20_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_20",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_20",1);
		setControlForeColor(panel_name, gCheckbox20, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_20",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_20",0);
		setControlForeColor(panel_name, gCheckbox20, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_21_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_21",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_21",1);
		setControlForeColor(panel_name, gCheckbox21, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_21",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_21",0);
		setControlForeColor(panel_name, gCheckbox21, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_22_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_22",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_22",1);
		setControlForeColor(panel_name, gCheckbox22, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_22",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_22",0);
		setControlForeColor(panel_name, gCheckbox22, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_23_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_23",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_23",1);
		setControlForeColor(panel_name, gCheckbox23, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_23",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_23",0);
		setControlForeColor(panel_name, gCheckbox23, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_24_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_24",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_24",1);
		setControlForeColor(panel_name, gCheckbox24, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_24",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_24",0);
		setControlForeColor(panel_name, gCheckbox24, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_25_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_25",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_25",1);
		setControlForeColor(panel_name, gCheckbox25, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_25",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_25",0);
		setControlForeColor(panel_name, gCheckbox25, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_26_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_26",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_26",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Start",1);
		setControlForeColor(panel_name, gCheckbox26, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_26",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_26",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Start",0);
		setControlForeColor(panel_name, gCheckbox26, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_27_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_27",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_27",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Start",1);
		setControlForeColor(panel_name, gCheckbox27, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_27",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_27",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Start",0);
		setControlForeColor(panel_name, gCheckbox27, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_28_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_28",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_28",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Start",1);
		setControlForeColor(panel_name, gCheckbox28, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_28",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_28",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Start",0);
		setControlForeColor(panel_name, gCheckbox28, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_29_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_29",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_29",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Start",1);
		setControlForeColor(panel_name, gCheckbox29, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_29",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_29",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Start",0);
		setControlForeColor(panel_name, gCheckbox29, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_30_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_30",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_30",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Start",1);
		setControlForeColor(panel_name, gCheckbox30, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_30",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_30",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Start",0);
		setControlForeColor(panel_name, gCheckbox30, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_31_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_31",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_31",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Start",1);
		setControlForeColor(panel_name, gCheckbox31, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_31",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_31",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Start",0);
		setControlForeColor(panel_name, gCheckbox31, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_32_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_32",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_32",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Start",1);
		setControlForeColor(panel_name, gCheckbox32, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_32",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_32",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Start",0);
		setControlForeColor(panel_name, gCheckbox32, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_33_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_33",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_33",1);
		setControlForeColor(panel_name, gCheckbox33, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_33",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_33",0);
		setControlForeColor(panel_name, gCheckbox33, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_34_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_34",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_34",1);
		setControlForeColor(panel_name, gCheckbox34, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_34",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_34",0);
		setControlForeColor(panel_name, gCheckbox34, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_35_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_35",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_35",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Start",1);
		setControlForeColor(panel_name, gCheckbox35, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_35",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_35",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Start",0);
		setControlForeColor(panel_name, gCheckbox35, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_36_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_36",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_36",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Start",1);
		setControlForeColor(panel_name, gCheckbox36, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_36",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_36",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Start",0);
		setControlForeColor(panel_name, gCheckbox36, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_37_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_37",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_37",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Start",1);
		setControlForeColor(panel_name, gCheckbox37, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_37",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_37",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Start",0);
		setControlForeColor(panel_name, gCheckbox37, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_38_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_38",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_38",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Start",1);
		setControlForeColor(panel_name, gCheckbox38, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_38",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_38",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Start",0);
		setControlForeColor(panel_name, gCheckbox38, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_39_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_39",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_39",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Start",1);
		setControlForeColor(panel_name, gCheckbox39, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_39",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_39",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Start",0);
		setControlForeColor(panel_name, gCheckbox39, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_40_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_40",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_40",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Start",1);
		setControlForeColor(panel_name, gCheckbox40, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_40",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_40",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Start",0);
		setControlForeColor(panel_name, gCheckbox40, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_41_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_41",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_41",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Start",1);
		setControlForeColor(panel_name, gCheckbox41, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_41",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_41",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Start",0);
		setControlForeColor(panel_name, gCheckbox41, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_42_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_42",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_42",1);
		setControlForeColor(panel_name, gCheckbox42, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_42",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_42",0);
		setControlForeColor(panel_name, gCheckbox42, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_43_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_43",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_43",1);
		setControlForeColor(panel_name, gCheckbox43, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_43",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_43",0);
		setControlForeColor(panel_name, gCheckbox43, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_44_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_44",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_44",1);
		setControlForeColor(panel_name, gCheckbox44, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_44",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_44",0);
		setControlForeColor(panel_name, gCheckbox44, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_45_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_45",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_45",1);
		setControlForeColor(panel_name, gCheckbox45, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_45",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_45",0);
		setControlForeColor(panel_name, gCheckbox45, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_40_0_0_46_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_46",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_46",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_46_SetGet",1);
		setControlForeColor(panel_name, gCheckbox46, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_46",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_46",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_46_SetGet",0);
		setControlForeColor(panel_name, gCheckbox46, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_40_0_0_47_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_47",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_47",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_47_SetGet",1);
		setControlForeColor(panel_name, gCheckbox47, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_47",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_47",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_47_SetGet",0);
		setControlForeColor(panel_name, gCheckbox47, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_40_0_0_48_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_48",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_48",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_48_SetGet",1);
		setControlForeColor(panel_name, gCheckbox48, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_48",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_48",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_48_SetGet",0);
		setControlForeColor(panel_name, gCheckbox48, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_40_0_0_49_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_49",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_49",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_49_SetGet",1);
		setControlForeColor(panel_name, gCheckbox49, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_49",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_49",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_49_SetGet",0);
		setControlForeColor(panel_name, gCheckbox49, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_50_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_50",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_50",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Start",1);
		setControlForeColor(panel_name, gCheckbox50, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_50",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_50",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Start",0);
		setControlForeColor(panel_name, gCheckbox50, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_51_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_51",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_51",1);
		setControlForeColor(panel_name, gCheckbox51, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_51",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_51",0);
		setControlForeColor(panel_name, gCheckbox51, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_40_0_0_52_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_52",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_52",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_52_SetGet",1);
		setControlForeColor(panel_name, gCheckbox52, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_52",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_52",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_52_SetGet",0);
		setControlForeColor(panel_name, gCheckbox52, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_53_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_53",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_53",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Start",1);
		setControlForeColor(panel_name, gCheckbox53, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_53",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_53",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Start",0);
		setControlForeColor(panel_name, gCheckbox53, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_54_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_54",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_54",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Start",1);
		setControlForeColor(panel_name, gCheckbox54, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_54",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_54",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Start",0);
		setControlForeColor(panel_name, gCheckbox54, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_55_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_55",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_55",1);
		setControlForeColor(panel_name, gCheckbox55, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_55",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_55",0);
		setControlForeColor(panel_name, gCheckbox55, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_56_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_56",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_56",1);
		setControlForeColor(panel_name, gCheckbox56, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_56",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_56",0);
		setControlForeColor(panel_name, gCheckbox56, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_57_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_57",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_57",1);
		setControlForeColor(panel_name, gCheckbox57, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_57",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_57",0);
		setControlForeColor(panel_name, gCheckbox57, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_58_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_58",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_58",1);
		setControlForeColor(panel_name, gCheckbox58, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_58",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_58",0);
		setControlForeColor(panel_name, gCheckbox58, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_59_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_59",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_59",1);
		setControlForeColor(panel_name, gCheckbox59, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_59",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_59",0);
		setControlForeColor(panel_name, gCheckbox59, MakeRGB(250,0,0));
	}
	if(getValue(A_FSG_40_0_0_60_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_60",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Status",1);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_60",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Changed",1);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_60_SetGet",1);
		setControlForeColor(panel_name, gCheckbox60, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_A_FSG_40_0_0_60",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Status",0);
		EnableControl(panel_name,"errfield_A_FSG_40_0_0_60",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Changed",0);
		EnableControl(panel_name,"panel_A_FSG_40_0_0_60_SetGet",0);
		setControlForeColor(panel_name, gCheckbox60, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_61_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_61",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_61",1);
		setControlForeColor(panel_name, gCheckbox61, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_61",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_61",0);
		setControlForeColor(panel_name, gCheckbox61, MakeRGB(250,0,0));
	}
	if(getValue(P_FSG_40_0_0_62_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_62",1);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_62",1);
		setControlForeColor(panel_name, gCheckbox62, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_P_FSG_40_0_0_62",0);
		EnableControl(panel_name,"errfield_P_FSG_40_0_0_62",0);
		setControlForeColor(panel_name, gCheckbox62, MakeRGB(250,0,0));
	}
	if(getValue(M_FSG_40_0_0_63_FctLstItemEn))
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_63",1);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_63",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Processing",1);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Start",1);
		setControlForeColor(panel_name, gCheckbox63, MakeRGB(0,240,0));
	}
	else
	{
		EnableControl(panel_name, "panel_M_FSG_40_0_0_63",0);
		EnableControl(panel_name,"errfield_M_FSG_40_0_0_63",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Processing",0);
		EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Start",0);
		setControlForeColor(panel_name, gCheckbox63, MakeRGB(250,0,0));
	}

}

resetErrfieldColor()
{
  	setControlBackColor(panel_name, "errfield_C_FSG_40_0_0_1", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_2", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_3", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_4", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_14", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_15", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_16", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_17", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_18", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_19", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_20", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_21", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_22", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_23", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_24", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_25", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_26", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_27", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_28", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_29", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_30", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_31", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_32", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_33", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_34", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_35", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_36", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_37", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_38", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_39", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_40", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_41", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_42", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_43", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_44", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_45", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_46", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_47", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_48", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_49", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_50", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_51", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_52", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_53", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_54", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_55", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_56", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_57", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_58", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_59", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_60", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_61", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_62", MakeRGB(255,255,255));
	setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_63", MakeRGB(255,255,255));

}

CANoe_Shutdown ()
{
	// Timer: cancel real CAN-communication timer
	canceltimer(TaskTimer);
	// Ruecksetzen der Hintergrundfarbe der Error-Felder
	resetErrfieldColor();
	// Deaktivierung aller Panel Elemente 
	EnableConfigCtrl();
}

on timer TaskTimer
{
	/*** Aufruf des BAP Task in DLL fuer NODE_INDEX ***/
	BAP150_Task(NODE_INDEX);	

	/*** Pollen ueber die anstehenden Indications (Lesen aus DLL, Auslesen eines Puffers der DLL) ***/
	BAP_DLL_Indication();	
	
	/*** Pollen ueber die anstehenden Requests (Schreiben in DLL, dort werden evt. Sendeauftraege gesetzt) ***/
	BAP_DLL_Request();
	
	/*** Abarbeiten der ausstehenden Sendeauftraege innerhalb der BAP DLL und Versenden ueber CANoe ***/
	if (getValue(KCAN__NMH_ICAS1_Gateway_CommActive))
	{
		BAP_CAN_TX_Request();
	}

	/*** Der Empfang von CAN Daten geschieht ueber on message CAN message Mechanismen ***/
	// keine Funktion hier

	/*** Retriggern des Timers mit 10 ms ***/
	setTimer(TaskTimer, TaskTime); // @TODO bei anderer Taskzeit muss hier modifiziert werden
}

BAP_DLL_Indication()	//function to get received BAP-data from DLL (at BAL-interface)
{
	int i, length, datalength, temp;
	byte Indication_data[BAP_buffer_size];		// indication data from DLL
	dword Indication_header[6];					// indication header from DLL
	byte BAP_data_type;

	// init local variables
	length=0;
	datalength=0;
	temp=0;
	BAP_data_type=0;

	for(i = 0; i < 6; i++)
		Indication_header[i]=0;

	for(i = 0; i < BAP_buffer_size; i++)
		Indication_data[i]=0;

	// BAP-Stack needs this information for successful BAP150_GetIndication 
	Indication_header[4]=BAP_buffer_size;

	while (BAP150_GetInd(NODE_INDEX, Indication_header, Indication_data) == 0)
	{		
		//read header and write in global variable
		for (i = 0; i < 6; i++) {
			gBAP_Indication_header[i]=Indication_header[i];	
		}

		// nur Bytesequneces haben Datenanteil
		if (gBAP_Indication_header[3] == Bap_byteSequence)
		{
			for (i = 0; i < BAP_buffer_size; i++) {
				gBAP_Indication_data[i]=Indication_data[i];	
			}
		}	
		// Verarbeiten der Indication
		Process_Current_Indication();

		// Vorbereiten fuer naechsten Durchlauf 
		Indication_header[4]=BAP_buffer_size;
	} 
}

setBitInFctList(word fctid, byte fctList[])
{
    byte byteNo ;
    byte bitno ;
    byte fctValue ;

    byteNo = fctid / 8;
    bitno = fctid % 8;
    fctValue = 0x80 >> bitno;
    fctList[byteNo] |= fctValue;
}

float round (float value, float step)
{
	return _floor(value / step + 0.5) * step;
}

ChangeConfig(long paramIndex,long config[])
{

        byte temp ;
        temp = BAP150_ChangeConfig(NODE_INDEX, paramIndex, config);
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP150_ChangeConfig for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP150_ChangeConfig error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        
}

PrintIndicationError(char reason[])
{
	writelineEx(gError_Trace, 0, "%s - %s lsgId:%d fctid:%d indType:%d dataType:%s",
		reason, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]]);
}

initBapConfig()
{
        long config[3];
    config[0] = LSGID;
    config[1] = 0;
    config[2] = getValue(BAPCFG_FSG_40_0_0_ProtocolMajor);
    ChangeConfig(0x0012,config);
    config[2] = getValue(BAPCFG_FSG_40_0_0_ProtocolMinor);
    ChangeConfig(0x0013,config);
    config[2] = getValue(BAPCFG_FSG_40_0_0_LsgClassMajor);
    ChangeConfig(0x0010,config);
    config[2] = getValue(BAPCFG_FSG_40_0_0_LsgClassMinor);
    ChangeConfig(0x0011,config);
    config[2] = getValue(BAPCFG_FSG_40_0_0_DFMajor);
    ChangeConfig(0x0014,config);
    config[2] = getValue(BAPCFG_FSG_40_0_0_DFMinor);
    ChangeConfig(0x0015,config);
    
}

initFctList()
{
    byte fctList[8]={0,0,0,0,0,0,0,0};
    int i;
    dword request[6];
    byte errorCode;

    fctList[0]=0;
    fctList[1]=0;
    fctList[2]=0;
    fctList[3]=0;
    fctList[4]=0;
    fctList[5]=0;
    fctList[6]=0;
    fctList[7]=0;

    /*if(getValue(P_FSG_44_0_13_FunctionListId))
    {
        setBitInFctList(P_FSG_44_0_13_ID, fctList);
    }*/
           if(getValue(M_FSG_40_0_0_29_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_29_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_28_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_28_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_59_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_59_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_27_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_27_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_58_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_58_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_26_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_26_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_57_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_57_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_25_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_25_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_56_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_56_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_24_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_24_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_55_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_55_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_23_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_23_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_54_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_54_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_22_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_22_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_53_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_53_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_21_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_21_ID, fctList);
       }
       if(getValue(A_FSG_40_0_0_52_FctLstItemEn))
       {
           setBitInFctList(A_FSG_40_0_0_52_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_20_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_20_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_51_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_51_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_50_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_50_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_19_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_19_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_18_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_18_ID, fctList);
       }
       if(getValue(A_FSG_40_0_0_49_FctLstItemEn))
       {
           setBitInFctList(A_FSG_40_0_0_49_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_17_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_17_ID, fctList);
       }
       if(getValue(A_FSG_40_0_0_48_FctLstItemEn))
       {
           setBitInFctList(A_FSG_40_0_0_48_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_16_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_16_ID, fctList);
       }
       if(getValue(A_FSG_40_0_0_47_FctLstItemEn))
       {
           setBitInFctList(A_FSG_40_0_0_47_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_4_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_4_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_15_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_15_ID, fctList);
       }
       if(getValue(A_FSG_40_0_0_46_FctLstItemEn))
       {
           setBitInFctList(A_FSG_40_0_0_46_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_3_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_3_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_14_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_14_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_45_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_45_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_2_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_2_ID, fctList);
       }
       if(getValue(C_FSG_40_0_0_1_FctLstItemEn))
       {
           setBitInFctList(C_FSG_40_0_0_1_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_44_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_44_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_43_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_43_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_42_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_42_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_41_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_41_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_40_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_40_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_39_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_39_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_38_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_38_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_37_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_37_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_36_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_36_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_35_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_35_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_34_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_34_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_33_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_33_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_32_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_32_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_63_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_63_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_31_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_31_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_62_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_62_ID, fctList);
       }
       if(getValue(M_FSG_40_0_0_30_FctLstItemEn))
       {
           setBitInFctList(M_FSG_40_0_0_30_ID, fctList);
       }
       if(getValue(P_FSG_40_0_0_61_FctLstItemEn))
       {
           setBitInFctList(P_FSG_40_0_0_61_ID, fctList);
       }
       if(getValue(A_FSG_40_0_0_60_FctLstItemEn))
       {
           setBitInFctList(A_FSG_40_0_0_60_ID, fctList);
       }


    for(i=0;i<8;i++){
        writelineEx(gBAP_Trace, 0, "fctList[%d]: 0x%02x ",i,fctList[i]);
    }

    request [0]=LSGID;
    request [1]=3;
    request [3]= Bap_byteSequence;
    request [4]= 8;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,fctList);
    if(errorCode)
        writelineEx(gError_Trace, 0, "BAP150_InitSendBuf(Functionlist) returns 0x%02x ",errorCode);
}

initHeartbeat()
{
       long data[2];
   data[0]=LSGID;
   if( getValue(P_FSG_40_0_0_4_FctLstItemEn) )
      data[1]=getValue(P_FSG_40_0_0_4);
   else
      data[1]=0;
   ChangeConfig(0x00,data);
   InitSendBuf_int8(P_FSG_40_0_0_4_ID, data[1]);

}

BapOnOff(byte _on)
{
    int length, temp;

    /***** Einschalten ******/
    if(_on==1){
        // soll der BAP Stack wieder initlialisiert werden?                                 
        if(gBAP_Init==0){
            gBAP_Init=1;
            temp=BAP150_Init(NODE_INDEX, LSGID);
            if(temp==0)
                writelineEx(gBAP_Trace, 0, "BAP_Init for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
            else
                writelineEx(gError_Trace, 0, "BAP_Init error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);         
        }

        // Initialisierung aller Variablen
        Initialize_Variables();                     

        // Aktivierung aller Panelelemente
		EnableFctCtrl();
        //EnableControl(panel_name, bapconfig_panel_name, 0); // @TODO
		//DisableConfigCtrl();


        //BAP-Shutdown
        temp = BAP150_Shutdown(NODE_INDEX, LSGID);
        if(temp==0)
            writelineEx(gBAP_Trace, 0, "BAP_Shutdown for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP_Shutdown error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX); 

        initBapConfig();
        initFctList();
        initHeartbeat();

        temp = BAP150_Start(NODE_INDEX, LSGID);             
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP_Start for %s succesful (LSG %d, NODE_INDEX %d)", NODE_NAME, LSGID, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP_Start error 0x%X for %s (LSG %d, NODE_INDEX %d)", temp, NODE_NAME, LSGID, NODE_INDEX);        
    
        // setze den Timer fuer den zyklischen Aufruf des CANoe-"Tasks"
        setTimer(TaskTimer, 10);                
    
        //  BAPFsg_ProcessDebug(NODE_INDEX,DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID, DEBUG_SWITCH_ON);    
    }
    else{ /***** Ausschalten ****/
        
        BAP150_Shutdown(NODE_INDEX,LSGID);
        
        CANoe_Shutdown();
        
        // ETHERNET NOT ENABLED! (CALL_FCT_CLOSE_UPD_SOCKET_TOKEN)
    }
  P_FSG_40_0_0_4_FctEn();
}

Initialize_Variables()	//initialize/reset all global variables
{
	int temp, i;
	byte  InitSend_data[BAP_buffer_size];	// InitSend data for DLL
	dword InitSend_header[6];	// InitSend header for DLL
    byte Default_Processing[2];

	/**** Request Buffer Geschichten initialisieren ****/
	for (i = 0; i < Requestbuffer_lines; i++)
	{
		gBAP_Requestbuffer_status[i] = 0;
	}	
	for (i = 0; i < BAP_buffer_size; i++)
	{
		InitSend_data[i] = 0;
	}
    
    for (i = 0; i < 2; i++)
	{
		Default_Processing[i] = 0;
	}

    putValue(M_FSG_40_0_0_63_Processing, Default_Processing);

	// @TODO nur FSG relevant
	/**** Es ist notwendig mittels InitSendbuffer alle Properties im FSG zu initialisieren ****/
           InitSend_header[0] = LSGID;       
       InitSend_header[1] = 14; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 2;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_14,InitSend_data);
       putValue(P_FSG_40_0_0_14,InitSend_data, 2);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_14)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 15; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 3;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_15,InitSend_data);
       putValue(P_FSG_40_0_0_15,InitSend_data, 3);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_15)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 16; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 8;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_16,InitSend_data);
       putValue(P_FSG_40_0_0_16,InitSend_data, 8);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_16)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 17; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 1 + @P_FSG_40_0_0_17_1_len; //50;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_17,InitSend_data);
       putValue(P_FSG_40_0_0_17,InitSend_data, 50);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_17)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 18; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 3;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_18,InitSend_data);
       putValue(P_FSG_40_0_0_18,InitSend_data, 3);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_18)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 19; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_40_0_0_19);
	 putValue(P_FSG_40_0_0_19, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 20; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 1 + 1 + @P_FSG_40_0_0_20_2_len + 1 + 1 + @P_FSG_40_0_0_20_4_len;//82;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_20,InitSend_data);
       putValue(P_FSG_40_0_0_20,InitSend_data, 82);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_20)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 21; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_40_0_0_21);
	 putValue(P_FSG_40_0_0_21, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 22; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 16;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_22,InitSend_data);
       putValue(P_FSG_40_0_0_22,InitSend_data, 16);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_22)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 23; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 1 + @P_FSG_40_0_0_23_1_len + 1 + @P_FSG_40_0_0_23_2_len + 1 + 1 + @P_FSG_40_0_0_23_4_len + 1 + @P_FSG_40_0_0_23_5_len + 1 + 1 + @P_FSG_40_0_0_23_7_len + 1 + @P_FSG_40_0_0_23_8_len + 1 + 1 + @P_FSG_40_0_0_23_10_len + 1 + @P_FSG_40_0_0_23_11_len + 1 + 1 + @P_FSG_40_0_0_23_13_len + 1 + @P_FSG_40_0_0_23_14_len + 1 + 1 + @P_FSG_40_0_0_23_16_len + 1 + @P_FSG_40_0_0_23_17_len + 1 + 1 + @P_FSG_40_0_0_23_19_len + 1 + @P_FSG_40_0_0_23_20_len + 1; //994;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_23,InitSend_data);
       putValue(P_FSG_40_0_0_23,InitSend_data, 994);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_23)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 24; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 14;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_24,InitSend_data);
       putValue(P_FSG_40_0_0_24,InitSend_data, 14);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_24)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 25; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_40_0_0_25);
	 putValue(P_FSG_40_0_0_25, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 33; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_40_0_0_33);
	 putValue(P_FSG_40_0_0_33, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 34; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_40_0_0_34);
	 putValue(P_FSG_40_0_0_34, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 42; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_40_0_0_42);
	 putValue(P_FSG_40_0_0_42, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 43; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 5;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_43,InitSend_data);
       putValue(P_FSG_40_0_0_43,InitSend_data, 5);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_43)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 44; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 9;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_44,InitSend_data);
       putValue(P_FSG_40_0_0_44,InitSend_data, 9);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_44)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 45; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 4;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_45,InitSend_data);
       putValue(P_FSG_40_0_0_45,InitSend_data, 4);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_45)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 51; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 3;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_51,InitSend_data);
       putValue(P_FSG_40_0_0_51,InitSend_data, 3);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_51)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 55; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 4;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_55,InitSend_data);
       putValue(P_FSG_40_0_0_55,InitSend_data, 4);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_55)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 56; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_40_0_0_56);
	 putValue(P_FSG_40_0_0_56, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 57; 
       InitSend_header[3] = Bap_uint8;
       InitSend_header[4] = 1;
       InitSend_header[5] = getValue(P_FSG_40_0_0_57);
	 putValue(P_FSG_40_0_0_57, InitSend_header[5]);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 58; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 2 + @P_FSG_40_0_0_58_2_len + 1 + @P_FSG_40_0_0_58_3_len + 1 + 1;//144;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_58,InitSend_data);
       putValue(P_FSG_40_0_0_58,InitSend_data, 144);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_58)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 59; 
       InitSend_header[3] = Bap_fixedByteSequence;
       InitSend_header[4] = 3;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_59,InitSend_data);
       putValue(P_FSG_40_0_0_59,InitSend_data, 3);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_59)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 61; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 10;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_61,InitSend_data);
       putValue(P_FSG_40_0_0_61,InitSend_data, 10);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_61)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);
       InitSend_header[0] = LSGID;       
       InitSend_header[1] = 62; 
       InitSend_header[3] = Bap_byteSequence;
       InitSend_header[4] = 8;
       InitSend_header[5] = 0;
       getValue(P_FSG_40_0_0_62,InitSend_data);
       putValue(P_FSG_40_0_0_62,InitSend_data, 8);
       temp = Bap150_InitSendBuf(NODE_INDEX, InitSend_header, InitSend_data);
       for (i=0; i<(getValueSize(P_FSG_40_0_0_62)); i++) 
       {
           InitSend_data[i] = 0;
       }
       if(temp != 0)
           writelineEx(gError_Trace, 0, "BAP150_InitSendBuf error 0x%X for %s (LSG %d, FCTID %d)", temp, NODE_NAME, LSGID, InitSend_header[1]);

}

on start
{
	// noch nicht eingeschaltet
	gSG_PowerOnOff=0;
	// noch nicht initialisiert
	gBAP_Init=0;
	// open the panel, nur fuer CANoe-Version >= 5.1 erlaubt
	//openPanel(panel_name);
	// deaktiviere alle aktiven Panel Elemente, ausser AN/AUSS
  
  putValue(Node_Index_FSG_40, NODE_INDEX); // CG: für BAPControl
  
  CANoe_Shutdown();
    
// ETHERNET AND FLEXRAY NOT ENABLED!
  
  ///Defaultwerte setzen für timestamps CallDurationSync & AutomaticeRedialExtendedInfo
  putValue(P_FSG_40_0_0_24_1,0xFFFF);
  putValue(P_FSG_40_0_0_24_2,0xFFFF);
  putValue(P_FSG_40_0_0_24_3,0xFFFF);
  putValue(P_FSG_40_0_0_24_4,0xFFFF);
  putValue(P_FSG_40_0_0_24_5,0xFFFF);
  putValue(P_FSG_40_0_0_24_6,0xFFFF);
  putValue(P_FSG_40_0_0_24_7,0xFFFF);
  putValue(P_FSG_40_0_0_58_1,0xFFFF);
}

BAP_CAN_TX_Request()	//Function to send BAP-data over CAN
{
   int i;
   byte TX_Data[8];				// CAN-data
   byte TX_Data_FR[10];    		// FlexRay-Data
   dword TX_Header[3];			// CAN-header
   message 0x100 TX_Message;	// dummy-message, Adresse wird noch modifiziert
   
   byte send_result;
   
   // ONLY CAN IS ENABLED! 
   		TX_Header[2] = 8; // max-Length of TX_Data

		// Pollen ueber die Queue, die von der DLL zur Verfuegung gestellt wird
		// Diese Daten muessen ueber den CAN Bus gesendet werden
	   	while (BAP150_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) {	
			TX_Message.CAN = TX_Header[0]; 		//CAN channel
			TX_Message.ID =TX_Header[1]; 			//Can ID
			TX_Message.DLC = TX_Header[2]; 		// received length
			
			for (i=0; i<TX_Message.DLC; i++) {	//CAN data-bytes
		  		TX_Message.byte(i) = TX_Data[i];
		  	}
		  	
		  	output(TX_Message);					//send CAN message
		  	
		  	//Versions Output
		  	if(TX_Data[0] == 0x40 && TX_Data[1] == 0x00 && TX_Header[2] == 4)
		  	{
		    	writelineEx(gBAP_Trace, 0,"Major Version: %i, Minor Version: %i", TX_Data[2], TX_Data[3]);
		  	}       
		  	TX_Header[2] = 8; // max-Length of TX_Data
	   	} 
   // ONLY CAN IS ENABLED!
   // FLEXRAY NOT ENABLED! (TX_FR_TOKEN)
   // ETHERNET NOT ENABLED! (TX_IP_TOKEN)
}

ringbuffer_write (byte lsgID, byte fctID, byte request, byte dataType, word length, dword singleData, byte data[])
{
	int bufferline, i;

	bufferline = getNextWriteIndex();	//get next free position in ring-buffer

	if (bufferline == -1) 
	{
		writelineEx(gError_Trace, 0, "Crititcal Error: No free buffer found!");
		return;
	}
		
	gBAP_Request_header[bufferline][0] = lsgID;	// LSG
	gBAP_Request_header[bufferline][1] = fctID;	// FCT
	gBAP_Request_header[bufferline][3] = dataType; // dataType
    //writelineEx(gBAP_Trace, 0, "Write request in buffer FSG NODEINDEX:%d lsgid:%d fctid:%d requesttype:%d datatype:%d length:%d", 
    //        NODE_INDEX,lsgID,fctID,request,dataType,length);


	switch (dataType)
	{
		case Bap_void:
			gBAP_Request_header[bufferline][2] = request;	// request
			gBAP_Request_header[bufferline][4] = 0;	// length
				// Void
			// @TODO?		
			break;
		case Bap_uint8:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten		
			break;
		case Bap_uint16:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten
			break;			
		case Bap_uint32:
			gBAP_Request_header[bufferline][2] = request;		// request
			gBAP_Request_header[bufferline][5] = singleData;	// Daten		
			break;	
		case Bap_byteSequence:
			gBAP_Request_header[bufferline][2] = request;	// request
			gBAP_Request_header[bufferline][4] = length;	// length
			// Daten der ByteSequence kopieren
			for(i = 0; i < BAP_buffer_size; i++)									
				gBAP_Request_data[bufferline][i] = data[i];
		case Bap_error:
			gBAP_Request_header[bufferline][5] = singleData;	// Errorcode						
			break;
		default:
			break;
	}

			

}

Request_void (byte lsgID, byte fctID, byte request)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_void, 0, 0, dataArray);	
}

Request_int8 (byte lsgID, byte fctID, byte request, dword data)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_uint8, 0, data, dataArray);

}

Request_int16 (byte lsgID, byte fctID, byte request, dword data)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_uint16, 0, data, dataArray);

}

Request_int32 (byte lsgID, byte fctID, byte request, dword data)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, request, Bap_uint32, 0, data, dataArray);
}

Request_byteSequence (byte lsgID, byte fctID, byte request, byte data[], word length)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	// Fuellen des Arrays
	for(i=0;i<length;i++) dataArray [i]=data[i];

	ringbuffer_write (lsgID, fctID, request, Bap_byteSequence, length, 0, dataArray);
}

Request_error (byte lsgID, byte fctID, byte errorCode)
{
	int i;
	byte dataArray [BAP_buffer_size];

	// Initialisieren eines Arrays
	for(i=0;i<BAP_buffer_size;i++) dataArray [i]=0;

	ringbuffer_write (lsgID, fctID, Error_REQ, Bap_error, 0, errorCode, dataArray);
}

InitSendBuf_int8 (byte fctID, dword data)
{
    dword request[6];
    int errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint8;
    request [5]= data;

    errorCode=
    BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int8 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
    
}

InitSendBuf_int16 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint16;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int16 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_int32 (byte fctID, dword data)
{
    dword request[6];
    byte errorCode;
    byte  InitSend_data[1];

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [5]= data;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,InitSend_data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_int32 error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

InitSendBuf_byteSequence (byte fctID, byte data[], word length)
{
    dword request[6];
    byte errorCode;

    request [0]= LSGID;
    request [1]= fctID;
    request [3]= Bap_uint32;
    request [4]= length;

    errorCode=BAP150_InitSendBuf(NODE_INDEX,request,data);
    
    if(errorCode)
        writelineEx(gError_Trace, 0, "InitSendBuf_byteSequence error 0x%X for %s (LSG %d, FCTID %d)", errorCode, NODE_NAME, LSGID, fctID);
}

DisplayRequestErrorCode(dword fctID, dword errCode)
{
       switch(fctID)
   {
       case C_FSG_40_0_0_1_ID:
           gC_FSG_40_0_0_1_ErrCode = 0;
           putValue(C_FSG_40_0_0_1_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_C_FSG_40_0_0_1", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_2_ID:
           gP_FSG_40_0_0_2_ErrCode = 0;
           putValue(P_FSG_40_0_0_2_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_2", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_3_ID:
           gP_FSG_40_0_0_3_ErrCode = 0;
           putValue(P_FSG_40_0_0_3_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_3", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_4_ID:
           gP_FSG_40_0_0_4_ErrCode = 0;
           putValue(P_FSG_40_0_0_4_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_4", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_14_ID:
           gP_FSG_40_0_0_14_ErrCode = 0;
           putValue(P_FSG_40_0_0_14_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_14", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_15_ID:
           gP_FSG_40_0_0_15_ErrCode = 0;
           putValue(P_FSG_40_0_0_15_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_15", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_16_ID:
           gP_FSG_40_0_0_16_ErrCode = 0;
           putValue(P_FSG_40_0_0_16_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_16", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_17_ID:
           gP_FSG_40_0_0_17_ErrCode = 0;
           putValue(P_FSG_40_0_0_17_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_17", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_18_ID:
           gP_FSG_40_0_0_18_ErrCode = 0;
           putValue(P_FSG_40_0_0_18_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_18", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_19_ID:
           gP_FSG_40_0_0_19_ErrCode = 0;
           putValue(P_FSG_40_0_0_19_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_19", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_20_ID:
           gP_FSG_40_0_0_20_ErrCode = 0;
           putValue(P_FSG_40_0_0_20_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_20", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_21_ID:
           gP_FSG_40_0_0_21_ErrCode = 0;
           putValue(P_FSG_40_0_0_21_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_21", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_22_ID:
           gP_FSG_40_0_0_22_ErrCode = 0;
           putValue(P_FSG_40_0_0_22_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_22", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_23_ID:
           gP_FSG_40_0_0_23_ErrCode = 0;
           putValue(P_FSG_40_0_0_23_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_23", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_24_ID:
           gP_FSG_40_0_0_24_ErrCode = 0;
           putValue(P_FSG_40_0_0_24_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_24", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_25_ID:
           gP_FSG_40_0_0_25_ErrCode = 0;
           putValue(P_FSG_40_0_0_25_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_25", MakeRGB(255,79,79));
       break;
       case M_FSG_40_0_0_26_ID:
           gM_FSG_40_0_0_26_ErrCode = 0;
           putValue(M_FSG_40_0_0_26_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_26", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_26_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_27_ID:
           gM_FSG_40_0_0_27_ErrCode = 0;
           putValue(M_FSG_40_0_0_27_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_27", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_27_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_28_ID:
           gM_FSG_40_0_0_28_ErrCode = 0;
           putValue(M_FSG_40_0_0_28_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_28", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_28_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_29_ID:
           gM_FSG_40_0_0_29_ErrCode = 0;
           putValue(M_FSG_40_0_0_29_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_29", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_29_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_30_ID:
           gM_FSG_40_0_0_30_ErrCode = 0;
           putValue(M_FSG_40_0_0_30_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_30", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_30_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_31_ID:
           gM_FSG_40_0_0_31_ErrCode = 0;
           putValue(M_FSG_40_0_0_31_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_31", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_31_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_32_ID:
           gM_FSG_40_0_0_32_ErrCode = 0;
           putValue(M_FSG_40_0_0_32_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_32", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_32_State,  "ReqErr");
       break;
       case P_FSG_40_0_0_33_ID:
           gP_FSG_40_0_0_33_ErrCode = 0;
           putValue(P_FSG_40_0_0_33_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_33", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_34_ID:
           gP_FSG_40_0_0_34_ErrCode = 0;
           putValue(P_FSG_40_0_0_34_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_34", MakeRGB(255,79,79));
       break;
       case M_FSG_40_0_0_35_ID:
           gM_FSG_40_0_0_35_ErrCode = 0;
           putValue(M_FSG_40_0_0_35_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_35", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_35_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_36_ID:
           gM_FSG_40_0_0_36_ErrCode = 0;
           putValue(M_FSG_40_0_0_36_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_36", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_36_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_37_ID:
           gM_FSG_40_0_0_37_ErrCode = 0;
           putValue(M_FSG_40_0_0_37_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_37", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_37_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_38_ID:
           gM_FSG_40_0_0_38_ErrCode = 0;
           putValue(M_FSG_40_0_0_38_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_38", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_38_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_39_ID:
           gM_FSG_40_0_0_39_ErrCode = 0;
           putValue(M_FSG_40_0_0_39_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_39", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_39_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_40_ID:
           gM_FSG_40_0_0_40_ErrCode = 0;
           putValue(M_FSG_40_0_0_40_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_40", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_40_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_41_ID:
           gM_FSG_40_0_0_41_ErrCode = 0;
           putValue(M_FSG_40_0_0_41_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_41", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_41_State,  "ReqErr");
       break;
       case P_FSG_40_0_0_42_ID:
           gP_FSG_40_0_0_42_ErrCode = 0;
           putValue(P_FSG_40_0_0_42_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_42", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_43_ID:
           gP_FSG_40_0_0_43_ErrCode = 0;
           putValue(P_FSG_40_0_0_43_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_43", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_44_ID:
           gP_FSG_40_0_0_44_ErrCode = 0;
           putValue(P_FSG_40_0_0_44_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_44", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_45_ID:
           gP_FSG_40_0_0_45_ErrCode = 0;
           putValue(P_FSG_40_0_0_45_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_45", MakeRGB(255,79,79));
       break;
       case A_FSG_40_0_0_46_ID:
           gA_FSG_40_0_0_46_ErrCode = 0;
           putValue(A_FSG_40_0_0_46_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_46", MakeRGB(255,79,79));
       break;
       case A_FSG_40_0_0_47_ID:
           gA_FSG_40_0_0_47_ErrCode = 0;
           putValue(A_FSG_40_0_0_47_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_47", MakeRGB(255,79,79));
       break;
       case A_FSG_40_0_0_48_ID:
           gA_FSG_40_0_0_48_ErrCode = 0;
           putValue(A_FSG_40_0_0_48_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_48", MakeRGB(255,79,79));
       break;
       case A_FSG_40_0_0_49_ID:
           gA_FSG_40_0_0_49_ErrCode = 0;
           putValue(A_FSG_40_0_0_49_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_49", MakeRGB(255,79,79));
       break;
       case M_FSG_40_0_0_50_ID:
           gM_FSG_40_0_0_50_ErrCode = 0;
           putValue(M_FSG_40_0_0_50_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_50", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_50_State,  "ReqErr");
       break;
       case P_FSG_40_0_0_51_ID:
           gP_FSG_40_0_0_51_ErrCode = 0;
           putValue(P_FSG_40_0_0_51_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_51", MakeRGB(255,79,79));
       break;
       case A_FSG_40_0_0_52_ID:
           gA_FSG_40_0_0_52_ErrCode = 0;
           putValue(A_FSG_40_0_0_52_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_52", MakeRGB(255,79,79));
       break;
       case M_FSG_40_0_0_53_ID:
           gM_FSG_40_0_0_53_ErrCode = 0;
           putValue(M_FSG_40_0_0_53_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_53", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_53_State,  "ReqErr");
       break;
       case M_FSG_40_0_0_54_ID:
           gM_FSG_40_0_0_54_ErrCode = 0;
           putValue(M_FSG_40_0_0_54_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_54", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_54_State,  "ReqErr");
       break;
       case P_FSG_40_0_0_55_ID:
           gP_FSG_40_0_0_55_ErrCode = 0;
           putValue(P_FSG_40_0_0_55_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_55", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_56_ID:
           gP_FSG_40_0_0_56_ErrCode = 0;
           putValue(P_FSG_40_0_0_56_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_56", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_57_ID:
           gP_FSG_40_0_0_57_ErrCode = 0;
           putValue(P_FSG_40_0_0_57_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_57", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_58_ID:
           gP_FSG_40_0_0_58_ErrCode = 0;
           putValue(P_FSG_40_0_0_58_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_58", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_59_ID:
           gP_FSG_40_0_0_59_ErrCode = 0;
           putValue(P_FSG_40_0_0_59_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_59", MakeRGB(255,79,79));
       break;
       case A_FSG_40_0_0_60_ID:
           gA_FSG_40_0_0_60_ErrCode = 0;
           putValue(A_FSG_40_0_0_60_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_60", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_61_ID:
           gP_FSG_40_0_0_61_ErrCode = 0;
           putValue(P_FSG_40_0_0_61_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_61", MakeRGB(255,79,79));
       break;
       case P_FSG_40_0_0_62_ID:
           gP_FSG_40_0_0_62_ErrCode = 0;
           putValue(P_FSG_40_0_0_62_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_62", MakeRGB(255,79,79));
       break;
       case M_FSG_40_0_0_63_ID:
           gM_FSG_40_0_0_63_ErrCode = 0;
           putValue(M_FSG_40_0_0_63_ErrCode,  errCode);
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_63", MakeRGB(255,79,79));
           putValue(M_FSG_40_0_0_63_State,  "ReqErr");
       break;
       default:
           writelineEx(gError_Trace, 0, "%s%d/%d Unknown Functionid in  displayErrorCode", SGtype, LSGID,fctID);
   }

}

BAP_DLL_Request ()
{
    int i;
    int l=0;
    byte temp;
    byte Request_data[4096];    //Request data for DLL
    dword Request_header[6];    //Request header for DLL
    byte dataValid;
    int nextElementToRead;
    
    // defaultmaessig ist senden OK
    dataValid = 1;

    // loeschen der Daten "Container"
    for(i=0;i<6;i++)
        Request_header[i]=0;
    for(i=0;i<BAP_buffer_size;i++)
        Request_data[i]=0;

    
    // Verarbeiten aller noch offenen Requests  
    while ((nextElementToRead = getNextReadIndex()) != -1) 
    {
        // Fuer alle Datentypen gleich
        Request_header[0]=gBAP_Request_header [nextElementToRead][0];       //LSG-ID
        Request_header[1]=gBAP_Request_header [nextElementToRead][1];       //Function-ID
        Request_header[2]=gBAP_Request_header [nextElementToRead][2];       //request type
        Request_header[3]=gBAP_Request_header [nextElementToRead][3];       //BAP data type

        switch(gBAP_Request_header[nextElementToRead][3]){
            case Bap_uint32:
                l=2;
            case Bap_uint16:
                l++;
            case Bap_uint8:
            case Bap_error: // Request (2) wird dabei ignoriert
                l++;
            case Bap_void:  // Datenfeld (5) wird dabei ignoriert
                Request_header[4]=l;                                                //  not used
                Request_header[5]=gBAP_Request_header [nextElementToRead][5];       // Daten
            break;
            case Bap_byteSequence:                                  
                Request_header[4]=gBAP_Request_header [nextElementToRead][4];       // length
                Request_header[5]=0;                                                // not used

                // data-array for BAP-DLL funcion 'BAP_Request'
                for(i=0;i<BAP_buffer_size;i++)
                    Request_data[i]=gBAP_Request_data [nextElementToRead][i];
                break;          
            default:
                writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Request_header[nextElementToRead][3]);
                dataValid = 0;
            break;          
        }
        
        if(dataValid){
            // wie heisst der Request?
            writelineEx(gBAP_Trace, 0, "%s%d/%d BAP_Request %s datatype:%s length:%d", SGtype, Request_header[0],Request_header[1],Requesttype_Text[Request_header[2]],Datatype_Text[Request_header[3]],Request_header[4]);
            temp = BAP150_Request(NODE_INDEX, Request_header, Request_data);    //send data to BAP-DLL  
            // BAP-Request failed
            if(temp != 0){
                // Fehlercode: Request failed
                writelineEx(gError_Trace, 0, "%s%d/%d Error during BAP_Request errorcode: 0x%X", SGtype, Request_header[0],Request_header[1],temp);
                DisplayRequestErrorCode(Request_header[1],temp);
            } 
        }

    }
} 

int getNextReadIndex ()
{
	int i, ret;
	// der Puffer wird nach dem naechsten zu lesenden Eintrag durchsucht
	// Existiert keiner wird -1 zurueckgegeben
	ret = -1;

	for (i = 0; i < Requestbuffer_lines; i++)
	{
		if (gBAP_Requestbuffer_status[i] == 1)
		{
			// zum verschicken
			ret = i;
			// und wieder freigeben
			gBAP_Requestbuffer_status[i] = 0;
			break;
		}
	}

	return (ret);
}

int getNextWriteIndex ()
{
	int i, ret;
	// der Puffer wird nach dem naechsten freien Eintrag durchsucht
	// Existiert keiner wird -1 zurueckgegeben
	ret = -1;

	for (i = 0; i < Requestbuffer_lines; i++)
	{
		if (gBAP_Requestbuffer_status[i] == 0)
		{
			// zum schreiben
			ret = i;
			// belegen
			gBAP_Requestbuffer_status[i] = 1;
			break;
		}
	}

	return (ret);
}

//gBAP_Indication_header[0])  // LSGID
//gBAP_Indication_header[1]) // FCTID
//gBAP_Indication_header[2]) // IndType
//gBAP_Indication_header[3]) // Datentyp

M_FSG_40_0_0_29_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_29_ID, Processing_REQ, getValue(M_FSG_40_0_0_29_Processing));
}
M_FSG_40_0_0_28_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_28_ID, Processing_REQ, getValue(M_FSG_40_0_0_28_Processing));
}
M_FSG_40_0_0_27_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_27_ID, Processing_REQ, getValue(M_FSG_40_0_0_27_Processing));
}
M_FSG_40_0_0_26_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_26_ID, Processing_REQ, getValue(M_FSG_40_0_0_26_Processing));
}
M_FSG_40_0_0_54_ProcessingRequest ()
{
   byte temp[BAP_buffer_size];
   getValue(M_FSG_40_0_0_54_Processing, temp);
   Request_byteSequence(LSGID, M_FSG_40_0_0_54_ID, Processing_REQ, temp, getValueSize(M_FSG_40_0_0_54_Processing));
}
M_FSG_40_0_0_53_ProcessingRequest ()
{
   byte temp[BAP_buffer_size];
   getValue(M_FSG_40_0_0_53_Processing, temp);
   Request_byteSequence(LSGID, M_FSG_40_0_0_53_ID, Processing_REQ, temp, getValueSize(M_FSG_40_0_0_53_Processing));
}
M_FSG_40_0_0_50_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_50_ID, Processing_REQ, getValue(M_FSG_40_0_0_50_Processing));
}
M_FSG_40_0_0_41_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_41_ID, Processing_REQ, getValue(M_FSG_40_0_0_41_Processing));
}
M_FSG_40_0_0_40_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_40_ID, Processing_REQ, getValue(M_FSG_40_0_0_40_Processing));
}
M_FSG_40_0_0_39_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_39_ID, Processing_REQ, getValue(M_FSG_40_0_0_39_Processing));
}
M_FSG_40_0_0_38_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_38_ID, Processing_REQ, getValue(M_FSG_40_0_0_38_Processing));
}
M_FSG_40_0_0_37_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_37_ID, Processing_REQ, getValue(M_FSG_40_0_0_37_Processing));
}
M_FSG_40_0_0_36_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_36_ID, Processing_REQ, getValue(M_FSG_40_0_0_36_Processing));
}
M_FSG_40_0_0_35_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_35_ID, Processing_REQ, getValue(M_FSG_40_0_0_35_Processing));
}
M_FSG_40_0_0_32_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_32_ID, Processing_REQ, getValue(M_FSG_40_0_0_32_Processing));
}
M_FSG_40_0_0_63_ProcessingRequest ()
{
   byte temp[BAP_buffer_size];
   getValue(M_FSG_40_0_0_63_Processing, temp);
   Request_byteSequence(LSGID, M_FSG_40_0_0_63_ID, Processing_REQ, temp, getValueSize(M_FSG_40_0_0_63_Processing));
}
M_FSG_40_0_0_31_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_31_ID, Processing_REQ, getValue(M_FSG_40_0_0_31_Processing));
}
M_FSG_40_0_0_30_ProcessingRequest ()
{
   Request_Int8(LSGID, M_FSG_40_0_0_30_ID, Processing_REQ, getValue(M_FSG_40_0_0_30_Processing));
}


Process_Current_Indication ()
{
byte BAPTemp[994];
   int telNumberLength;
   char telNumber[40];
   int i,length;
   
   int rxsize;
   int txsize;
   byte temp[BAP_buffer_size];
   char buffer[BAP_buffer_size];
   if(strncmp(Datatype_Text[gBAP_Indication_header[3]], "acknowledge", 4)!=0) 
       writelineEx(gBAP_Trace, 0, "NodeIndex: %d: CurrentIndication %s lsgid:%d fctid:%d indType:%s dataType=%s length=%d",
               NODE_INDEX, SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   else 
       writelineEx(gBAP_Trace, 0, "Internal acknowledge %s-%d fctid:%d indType:%s dataType=%s length=%d",
               SGtype, gBAP_Indication_header[0], gBAP_Indication_header[1], Acknowledgetype_Text[gBAP_Indication_header[5]], Datatype_Text[gBAP_Indication_header[3]], gBAP_Indication_header[4]);
   switch(gBAP_Indication_header[0])  // LSGID
   {
   case LSGID:
       switch(gBAP_Indication_header[1]) // FCTID
       {
    case P_FSG_40_0_0_14_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_14_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_14", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_14_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_15_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_15_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_15", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_15_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_16_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_16_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_16", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_16_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_17_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_17_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_17", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_17_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_18_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_18_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_18", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_18_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_19_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_19_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_19", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_19_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_20_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_20_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_20", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_20_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_21_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_21_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_21", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_21_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_22_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_22_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_22", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_22_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_23_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_23_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_23", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_23_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_24_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_24_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_24", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_24_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_25_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_25_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_25", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_25_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_FSG_40_0_0_26_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_26_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_26_ID,getValue(M_FSG_40_0_0_26_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_26_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_26_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_26", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_26_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_26_ID,getValue(M_FSG_40_0_0_26_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_26_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_26_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_26", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_26_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_26_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_26_ID, getValue(M_FSG_40_0_0_26_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_26_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_26_ID, getValue(M_FSG_40_0_0_26_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_40_0_0_26_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_40_0_0_26_ID, Processing_REQ, temp, getValueSize(M_FSG_40_0_0_26_Processing));
                            M_FSG_40_0_0_26_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_26", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_40_0_0_26_ErrCode = 0;
                putValue(M_FSG_40_0_0_26_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_26", MakeRGB(255,79,79));  
                gM_FSG_40_0_0_26_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_27_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_uint8:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_27_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_27_ID,getValue(M_FSG_40_0_0_27_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_27_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_27_Start, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_27", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_27_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_27_ID,getValue(M_FSG_40_0_0_27_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_27_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_27_Start, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_27", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_27_State, "Aborted");
                            // Fehler als Quittierung schicken
                            //if (getValue(M_FSG_40_0_0_27_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_27_ID, getValue(M_FSG_40_0_0_27_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_27_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_27_ID, getValue(M_FSG_40_0_0_27_ErrCode));
                            }
                            // Processing schicken
                           //Request_Int8(LSGID, M_FSG_40_0_0_27_ID, Processing_REQ, getValue(M_FSG_40_0_0_27_Processing));
                            M_FSG_40_0_0_27_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_27", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_40_0_0_27_ErrCode = 0;
                putValue(M_FSG_40_0_0_27_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_27", MakeRGB(255,79,79));  
                gM_FSG_40_0_0_27_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_28_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_uint8:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_28_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_28_ID,getValue(M_FSG_40_0_0_28_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_28_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_28_Start, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_28", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_28_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_28_ID,getValue(M_FSG_40_0_0_28_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_28_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_28_Start, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_28", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_28_State, "Aborted");
                            // Fehler als Quittierung schicken
                            //if (getValue(M_FSG_40_0_0_28_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_28_ID, getValue(M_FSG_40_0_0_28_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_28_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_28_ID, getValue(M_FSG_40_0_0_28_ErrCode));
                            }
                            // Processing schicken
                           //Request_Int8(LSGID, M_FSG_40_0_0_28_ID, Processing_REQ, getValue(M_FSG_40_0_0_28_Processing));
                            M_FSG_40_0_0_28_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_28", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_40_0_0_28_ErrCode = 0;
                putValue(M_FSG_40_0_0_28_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_28", MakeRGB(255,79,79));  
                gM_FSG_40_0_0_28_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_29_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_uint8:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_29_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_29_ID,getValue(M_FSG_40_0_0_29_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_29_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_29_Start, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_29", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_29_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_29_ID,getValue(M_FSG_40_0_0_29_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_29_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_29_Start, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_29", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_29_State, "Aborted");
                            // Fehler als Quittierung schicken
                            //if (getValue(M_FSG_40_0_0_29_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_29_ID, getValue(M_FSG_40_0_0_29_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_29_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_29_ID, getValue(M_FSG_40_0_0_29_ErrCode));
                            }
                            // Processing schicken
                           //Request_Int8(LSGID, M_FSG_40_0_0_29_ID, Processing_REQ, getValue(M_FSG_40_0_0_29_Processing));
                            M_FSG_40_0_0_29_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_29", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_40_0_0_29_ErrCode = 0;
                putValue(M_FSG_40_0_0_29_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_29", MakeRGB(255,79,79));  
                gM_FSG_40_0_0_29_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_30_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_30_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_30_ID,getValue(M_FSG_40_0_0_30_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_30_State, "Running");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_30", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_30_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_30_ID,getValue(M_FSG_40_0_0_30_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_30_State, "Started");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_30", MakeRGB(255,255,255));  
                            break;
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_30_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_30_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_30_ID, getValue(M_FSG_40_0_0_30_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_30_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_30_ID, getValue(M_FSG_40_0_0_30_ErrCode));
                            }
                            // Processing schicken
                           //Request_Void(LSGID, M_FSG_40_0_0_30_ID, Processing_REQ);
                            M_FSG_40_0_0_30_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_30", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                putValue(M_FSG_40_0_0_30_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_30", MakeRGB(255,79,79));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_31_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_31_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_31_ID,getValue(M_FSG_40_0_0_31_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_31_State, "Running");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_31", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_31_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_31_ID,getValue(M_FSG_40_0_0_31_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_31_State, "Started");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_31", MakeRGB(255,255,255));  
                            break;
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_31_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_31_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_31_ID, getValue(M_FSG_40_0_0_31_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_31_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_31_ID, getValue(M_FSG_40_0_0_31_ErrCode));
                            }
                            // Processing schicken
                           //Request_Void(LSGID, M_FSG_40_0_0_31_ID, Processing_REQ);
                            M_FSG_40_0_0_31_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_31", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                putValue(M_FSG_40_0_0_31_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_31", MakeRGB(255,79,79));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_32_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_32_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_32_ID,getValue(M_FSG_40_0_0_32_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_32_State, "Running");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_32", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_32_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_32_ID,getValue(M_FSG_40_0_0_32_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_32_State, "Started");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_32", MakeRGB(255,255,255));  
                            break;
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_32_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_32_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_32_ID, getValue(M_FSG_40_0_0_32_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_32_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_32_ID, getValue(M_FSG_40_0_0_32_ErrCode));
                            }
                            // Processing schicken
                           //Request_Void(LSGID, M_FSG_40_0_0_32_ID, Processing_REQ);
                            M_FSG_40_0_0_32_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_32", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                putValue(M_FSG_40_0_0_32_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_32", MakeRGB(255,79,79));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_FSG_40_0_0_33_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_40_0_0_33_ErrEn)) { 
                               Request_error(LSGID,P_FSG_40_0_0_33_ID,getValue(P_FSG_40_0_0_33_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_40_0_0_33, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_33", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_40_0_0_33_ErrEn)) { 
                               Request_error(LSGID,P_FSG_40_0_0_33_ID,getValue(P_FSG_40_0_0_33_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_40_0_0_33, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_33", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_40_0_0_33_ID, Data_REQ, getValue(P_FSG_40_0_0_33));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_40_0_0_33_ErrCode = 0;
                putValue(P_FSG_40_0_0_33_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_33", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_33_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_40_0_0_34_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_40_0_0_34_ErrEn)) { 
                               Request_error(LSGID,P_FSG_40_0_0_34_ID,getValue(P_FSG_40_0_0_34_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_40_0_0_34, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_34", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_40_0_0_34_ErrEn)) { 
                               Request_error(LSGID,P_FSG_40_0_0_34_ID,getValue(P_FSG_40_0_0_34_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_40_0_0_34, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_34", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_40_0_0_34_ID, Data_REQ, getValue(P_FSG_40_0_0_34));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_40_0_0_34_ErrCode = 0;
                putValue(P_FSG_40_0_0_34_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_34", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_34_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case M_FSG_40_0_0_35_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_35_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_35_ID,getValue(M_FSG_40_0_0_35_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_35_State, "Running");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_35", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_35_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_35_ID,getValue(M_FSG_40_0_0_35_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_35_State, "Started");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_35", MakeRGB(255,255,255));  
                            break;
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_35_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_35_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_35_ID, getValue(M_FSG_40_0_0_35_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_35_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_35_ID, getValue(M_FSG_40_0_0_35_ErrCode));
                            }
                            // Processing schicken
                           //Request_Void(LSGID, M_FSG_40_0_0_35_ID, Processing_REQ);
                            M_FSG_40_0_0_35_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_35", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                putValue(M_FSG_40_0_0_35_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_35", MakeRGB(255,79,79));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_36_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_36_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_36_ID,getValue(M_FSG_40_0_0_36_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_36_State, "Running");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_36", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_36_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_36_ID,getValue(M_FSG_40_0_0_36_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_36_State, "Started");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_36", MakeRGB(255,255,255));  
                            break;
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_36_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_36_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_36_ID, getValue(M_FSG_40_0_0_36_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_36_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_36_ID, getValue(M_FSG_40_0_0_36_ErrCode));
                            }
                            // Processing schicken
                           //Request_Void(LSGID, M_FSG_40_0_0_36_ID, Processing_REQ);
                            M_FSG_40_0_0_36_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_36", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                putValue(M_FSG_40_0_0_36_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_36", MakeRGB(255,79,79));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_37_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_37_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_37_ID,getValue(M_FSG_40_0_0_37_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_37_State, "Running");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_37", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_37_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_37_ID,getValue(M_FSG_40_0_0_37_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_37_State, "Started");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_37", MakeRGB(255,255,255));  
                            break;
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_37_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_37_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_37_ID, getValue(M_FSG_40_0_0_37_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_37_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_37_ID, getValue(M_FSG_40_0_0_37_ErrCode));
                            }
                            // Processing schicken
                           //Request_Void(LSGID, M_FSG_40_0_0_37_ID, Processing_REQ);
                            M_FSG_40_0_0_37_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_37", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                putValue(M_FSG_40_0_0_37_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_37", MakeRGB(255,79,79));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_38_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_38_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_38_ID,getValue(M_FSG_40_0_0_38_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_38_State, "Running");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_38", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_38_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_38_ID,getValue(M_FSG_40_0_0_38_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_38_State, "Started");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_38", MakeRGB(255,255,255));  
                            break;
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_38_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_38_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_38_ID, getValue(M_FSG_40_0_0_38_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_38_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_38_ID, getValue(M_FSG_40_0_0_38_ErrCode));
                            }
                            // Processing schicken
                           //Request_Void(LSGID, M_FSG_40_0_0_38_ID, Processing_REQ);
                            M_FSG_40_0_0_38_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_38", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                putValue(M_FSG_40_0_0_38_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_38", MakeRGB(255,79,79));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_39_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_39_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_39_ID,getValue(M_FSG_40_0_0_39_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_39_State, "Running");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_39", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_39_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_39_ID,getValue(M_FSG_40_0_0_39_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_39_State, "Started");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_39", MakeRGB(255,255,255));  
                            break;
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_39_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_39_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_39_ID, getValue(M_FSG_40_0_0_39_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_39_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_39_ID, getValue(M_FSG_40_0_0_39_ErrCode));
                            }
                            // Processing schicken
                           //Request_Void(LSGID, M_FSG_40_0_0_39_ID, Processing_REQ);
                            M_FSG_40_0_0_39_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_39", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                putValue(M_FSG_40_0_0_39_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_39", MakeRGB(255,79,79));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_40_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_40_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_40_ID,getValue(M_FSG_40_0_0_40_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_40_State, "Running");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_40", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_40_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_40_ID,getValue(M_FSG_40_0_0_40_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_40_State, "Started");
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_40", MakeRGB(255,255,255));  
                            break;
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_40_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_40_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_40_ID, getValue(M_FSG_40_0_0_40_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_40_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_40_ID, getValue(M_FSG_40_0_0_40_ErrCode));
                            }
                            // Processing schicken
                           //Request_Void(LSGID, M_FSG_40_0_0_40_ID, Processing_REQ);
                            M_FSG_40_0_0_40_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_40", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                putValue(M_FSG_40_0_0_40_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_40", MakeRGB(255,79,79));  
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_41_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_uint8:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_41_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_41_ID,getValue(M_FSG_40_0_0_41_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_41_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_41_Start, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_41", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_41_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_41_ID,getValue(M_FSG_40_0_0_41_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_41_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_41_Start, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_41", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_41_State, "Aborted");
                            // Fehler als Quittierung schicken
                            //if (getValue(M_FSG_40_0_0_41_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_41_ID, getValue(M_FSG_40_0_0_41_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_41_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_41_ID, getValue(M_FSG_40_0_0_41_ErrCode));
                            }
                            // Processing schicken
                           //Request_Int8(LSGID, M_FSG_40_0_0_41_ID, Processing_REQ, getValue(M_FSG_40_0_0_41_Processing));
                            M_FSG_40_0_0_41_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_41", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_40_0_0_41_ErrCode = 0;
                putValue(M_FSG_40_0_0_41_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_41", MakeRGB(255,79,79));  
                gM_FSG_40_0_0_41_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_FSG_40_0_0_42_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_42_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_42", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_42_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_43_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_43_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_43", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_43_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_44_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_44_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_44", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_44_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_45_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_40_0_0_45_ErrEn)) { 
                           Request_error(LSGID,P_FSG_40_0_0_45_ID,getValue(P_FSG_40_0_0_45_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_40_0_0_45, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_45", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_40_0_0_45_ErrEn)) { 
                           Request_error(LSGID,P_FSG_40_0_0_45_ID,getValue(P_FSG_40_0_0_45_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_40_0_0_45, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_45", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_40_0_0_45, temp);
                        Request_byteSequence(LSGID, P_FSG_40_0_0_45_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_40_0_0_45_ErrCode = 0;
                putValue(P_FSG_40_0_0_45_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_45", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_45_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_40_0_0_46_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_46_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_46_ID,getValue(A_FSG_40_0_0_46_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_46_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_46_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_46", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_40_0_0_46_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_46_ID,getValue(A_FSG_40_0_0_46_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_46_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_46_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_46", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_46, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_46_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_46));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_46Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_46Status_BTN, 0);
                    A_FSG_40_0_0_46_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_46_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_46_ID,getValue(A_FSG_40_0_0_46_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_46_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_46_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_46", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_46, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_46_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_46));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_46Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_46Status_BTN, 0);
                    A_FSG_40_0_0_46_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_40_0_0_46_ErrCode = 0;
                putValue(A_FSG_40_0_0_46_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_46", MakeRGB(255,79,79));  
                gA_FSG_40_0_0_46_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_40_0_0_47_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_47_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_47_ID,getValue(A_FSG_40_0_0_47_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_47_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_47_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_47", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_40_0_0_47_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_47_ID,getValue(A_FSG_40_0_0_47_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_47_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_47_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_47", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_47, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_47_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_47));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_47Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_47Status_BTN, 0);
                    A_FSG_40_0_0_47_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_47_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_47_ID,getValue(A_FSG_40_0_0_47_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_47_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_47_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_47", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_47, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_47_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_47));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_47Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_47Status_BTN, 0);
                    A_FSG_40_0_0_47_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_40_0_0_47_ErrCode = 0;
                putValue(A_FSG_40_0_0_47_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_47", MakeRGB(255,79,79));  
                gA_FSG_40_0_0_47_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_40_0_0_48_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_48_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_48_ID,getValue(A_FSG_40_0_0_48_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_48_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_48_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_48", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_40_0_0_48_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_48_ID,getValue(A_FSG_40_0_0_48_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_48_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_48_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_48", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_48, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_48_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_48));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_48Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_48Status_BTN, 0);
                    A_FSG_40_0_0_48_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_48_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_48_ID,getValue(A_FSG_40_0_0_48_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_48_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_48_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_48", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_48, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_48_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_48));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_48Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_48Status_BTN, 0);
                    A_FSG_40_0_0_48_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_40_0_0_48_ErrCode = 0;
                putValue(A_FSG_40_0_0_48_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_48", MakeRGB(255,79,79));  
                gA_FSG_40_0_0_48_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_40_0_0_49_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_49_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_49_ID,getValue(A_FSG_40_0_0_49_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_49_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_49_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_49", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_40_0_0_49_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_49_ID,getValue(A_FSG_40_0_0_49_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_49_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_49_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_49", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_49, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_49_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_49));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_49Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_49Status_BTN, 0);
                    //A_FSG_40_0_0_49_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_49_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_49_ID,getValue(A_FSG_40_0_0_49_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_49_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_49_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_49", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_49, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_49_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_49));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_49Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_49Status_BTN, 0);
                    //A_FSG_40_0_0_49_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_40_0_0_49_ErrCode = 0;
                putValue(A_FSG_40_0_0_49_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_49", MakeRGB(255,79,79));  
                gA_FSG_40_0_0_49_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_FSG_40_0_0_50_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_uint8:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_50_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_50_ID,getValue(M_FSG_40_0_0_50_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_50_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_50_Start, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_50", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_50_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_50_ID,getValue(M_FSG_40_0_0_50_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_50_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_50_Start, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_50", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_50_State, "Aborted");
                            // Fehler als Quittierung schicken
                            //if (getValue(M_FSG_40_0_0_50_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_50_ID, getValue(M_FSG_40_0_0_50_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_50_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_50_ID, getValue(M_FSG_40_0_0_50_ErrCode));
                            }
                            // Processing schicken
                           //Request_Int8(LSGID, M_FSG_40_0_0_50_ID, Processing_REQ, getValue(M_FSG_40_0_0_50_Processing));
                            M_FSG_40_0_0_50_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_50", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_40_0_0_50_ErrCode = 0;
                putValue(M_FSG_40_0_0_50_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_50", MakeRGB(255,79,79));  
                gM_FSG_40_0_0_50_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_FSG_40_0_0_51_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_51_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_51", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_51_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_40_0_0_52_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_52_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_52_ID,getValue(A_FSG_40_0_0_52_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_52_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_52_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_52", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_40_0_0_52_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_52_ID,getValue(A_FSG_40_0_0_52_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_52_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_52_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_52", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_52, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_52_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_52));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_52Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_52Status_BTN, 0);
                    //A_FSG_40_0_0_52_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_52_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_52_ID,getValue(A_FSG_40_0_0_52_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_52_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_52_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_52", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_52, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_52_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_52));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_52Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_52Status_BTN, 0);
                     //A_FSG_40_0_0_52_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_40_0_0_52_ErrCode = 0;
                putValue(A_FSG_40_0_0_52_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_52", MakeRGB(255,79,79));  
                gA_FSG_40_0_0_52_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_FSG_40_0_0_53_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_53_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_53_ID,getValue(M_FSG_40_0_0_53_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_53_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_53_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_53", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_53_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_53_ID,getValue(M_FSG_40_0_0_53_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_53_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_53_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_53", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_53_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_53_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_53_ID, getValue(M_FSG_40_0_0_53_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_53_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_53_ID, getValue(M_FSG_40_0_0_53_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_40_0_0_53_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_40_0_0_53_ID, Processing_REQ, temp, getValueSize(M_FSG_40_0_0_53_Processing));
                            M_FSG_40_0_0_53_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_53", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_40_0_0_53_ErrCode = 0;
                putValue(M_FSG_40_0_0_53_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_53", MakeRGB(255,79,79));  
                gM_FSG_40_0_0_53_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case M_FSG_40_0_0_54_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_54_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_54_ID,getValue(M_FSG_40_0_0_54_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_54_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_54_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_54", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_54_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_54_ID,getValue(M_FSG_40_0_0_54_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_54_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_54_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_54", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_54_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_54_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_54_ID, getValue(M_FSG_40_0_0_54_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_54_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_54_ID, getValue(M_FSG_40_0_0_54_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_40_0_0_54_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_40_0_0_54_ID, Processing_REQ, temp, getValueSize(M_FSG_40_0_0_54_Processing));
                            M_FSG_40_0_0_54_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_54", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_40_0_0_54_ErrCode = 0;
                putValue(M_FSG_40_0_0_54_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_54", MakeRGB(255,79,79));  
                gM_FSG_40_0_0_54_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
    case P_FSG_40_0_0_55_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_byteSequence:
                switch (gBAP_Indication_header[2]) // IndType
                {
                    case DataSet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_40_0_0_55_ErrEn)) { 
                           Request_error(LSGID,P_FSG_40_0_0_55_ID,getValue(P_FSG_40_0_0_55_ErrCode)); 
                           break;
                        }
                        // Daten setzen
                        putValue(P_FSG_40_0_0_55, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_55", MakeRGB(255,255,255));  
                        break;
                    case DataSetGet_IND: // Indicationtyp pruefen
                       if (getValue(P_FSG_40_0_0_55_ErrEn)) { 
                           Request_error(LSGID,P_FSG_40_0_0_55_ID,getValue(P_FSG_40_0_0_55_ErrCode)); 
                           break;
                        }
                        // Daten setzen
						getValue(P_FSG_40_0_0_55, temp);
						gBAP_Indication_data[0]=temp[0];
						gBAP_Indication_data[1]=temp[1];
                        putValue(P_FSG_40_0_0_55, gBAP_Indication_data, gBAP_Indication_header[4]);
                        setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_55", MakeRGB(255,255,255));  
                        // und antworten
                        getValue(P_FSG_40_0_0_55, temp);
                        Request_byteSequence(LSGID, P_FSG_40_0_0_55_ID, Data_REQ, temp, gBAP_Indication_header[4]);
                        break;
                    default:
                            PrintIndicationError("Illegal IndType");
                        break;
                }
                break;
            case Bap_error:
                gP_FSG_40_0_0_55_ErrCode = 0;
                putValue(P_FSG_40_0_0_55_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_55", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_55_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_56_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_40_0_0_56_ErrEn)) { 
                               Request_error(LSGID,P_FSG_40_0_0_56_ID,getValue(P_FSG_40_0_0_56_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_40_0_0_56, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_56", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_40_0_0_56_ErrEn)) { 
                               Request_error(LSGID,P_FSG_40_0_0_56_ID,getValue(P_FSG_40_0_0_56_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_40_0_0_56, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_56", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_40_0_0_56_ID, Data_REQ, getValue(P_FSG_40_0_0_56));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_40_0_0_56_ErrCode = 0;
                putValue(P_FSG_40_0_0_56_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_56", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_56_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_40_0_0_57_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_uint8:
                    switch(gBAP_Indication_header[2]) // IndType
                    {
                        case DataSet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_40_0_0_57_ErrEn)) { 
                               Request_error(LSGID,P_FSG_40_0_0_57_ID,getValue(P_FSG_40_0_0_57_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_40_0_0_57, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_57", MakeRGB(255,255,255));  
                            break;                              
                        case DataSetGet_IND: // Indicationtyp pruefen
                            if (getValue(P_FSG_40_0_0_57_ErrEn)) { 
                               Request_error(LSGID,P_FSG_40_0_0_57_ID,getValue(P_FSG_40_0_0_57_ErrCode)); 
                               break;
                            }
                            // Daten setzen
                            putValue(P_FSG_40_0_0_57, gBAP_Indication_header[5]);
                            setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_57", MakeRGB(255,255,255));  
                            // und antworten
                            Request_Int8(LSGID, P_FSG_40_0_0_57_ID, Data_REQ, getValue(P_FSG_40_0_0_57));
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gP_FSG_40_0_0_57_ErrCode = 0;
                putValue(P_FSG_40_0_0_57_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_57", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_57_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
        }
    break;
    case P_FSG_40_0_0_58_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_58_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_58", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_58_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_59_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_59_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_59", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_59_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case A_FSG_40_0_0_60_ID: 
    switch(gBAP_Indication_header[3]) // Datentyp
    {
        case Bap_byteSequence:
            switch (gBAP_Indication_header[2]) // IndType
            {
                case DataSet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_60_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_60_ID,getValue(A_FSG_40_0_0_60_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_60_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_60_SetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_60", MakeRGB(255,255,255));  
                    break;
                case DataGet_IND:
                    if (getValue(A_FSG_40_0_0_60_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_60_ID,getValue(A_FSG_40_0_0_60_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_60_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_60_GetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_60", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_60, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_60_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_60));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_60Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_60Status_BTN, 0);
                    //A_FSG_40_0_0_60_SendStatus();
                    break;
                case DataSetGet_IND: // Indicationtyp pruefen
                    if (getValue(A_FSG_40_0_0_60_ErrEn)) { 
                               Request_error(LSGID,A_FSG_40_0_0_60_ID,getValue(A_FSG_40_0_0_60_ErrCode)); 
                               break;
                    }
                    // Daten setzen
                    //putValue(A_FSG_40_0_0_60_SetGet, gBAP_Indication_data, gBAP_Indication_header[4]);
                        A_FSG_40_0_0_60_SetGetInd();
                    setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_60", MakeRGB(255,255,255));  
                    // und antworten
                    //getValue(A_FSG_40_0_0_60, temp);
                    //Request_byteSequence(LSGID, A_FSG_40_0_0_60_ID, Data_REQ, temp, getValueSize(A_FSG_40_0_0_60));
                    //Button fuer Status betaetigen => antwort status wird geschickt, code sparen
                    //putValue(A_FSG_40_0_0_60Status_BTN, 1);
                    //putValue(A_FSG_40_0_0_60Status_BTN, 0);
                    //A_FSG_40_0_0_60_SendStatus();
                    break;
                default:
                    PrintIndicationError("Illegal IndType");
                    break;
            }
            break;
            case Bap_error:
                gA_FSG_40_0_0_60_ErrCode = 0;
                putValue(A_FSG_40_0_0_60_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_A_FSG_40_0_0_60", MakeRGB(255,79,79));  
                gA_FSG_40_0_0_60_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_61_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_61_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_61", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_61_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case P_FSG_40_0_0_62_ID: 
        switch(gBAP_Indication_header[3]) // Datentyp 
        {
            case Bap_error:
                gP_FSG_40_0_0_62_ErrCode = 0;
                setControlBackColor(panel_name, "errfield_P_FSG_40_0_0_62", MakeRGB(255,79,79));  
                gP_FSG_40_0_0_62_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                PrintIndicationError("Illegal DataType");
                break;
        }
    break;
    case M_FSG_40_0_0_63_ID: 
            switch(gBAP_Indication_header[3]) // Datentyp
            {
                case Bap_byteSequence:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case StartResult_IND: 
                            if (getValue(M_FSG_40_0_0_63_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_63_ID,getValue(M_FSG_40_0_0_63_ErrCode)); 
                               break;
                            }
                           // running
                            putValue(M_FSG_40_0_0_63_State, "Running");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_63_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            
                            
                            // get call ID from Call Functions indication 
                            gcallID = gBAP_Indication_data[1] >>4;
                         
                           
                            telNumberLength = gBAP_Indication_data[4];
                                
                                for(i=0;i<elcount(gDialTelNumber_string);i++)
                                {
                                gDialTelNumber_string[i] = 0;
                                gDialTelNumber_data[i] = 0;
                                }
                                for (i=0; i<telNumberLength; i++)
                                { 
                                  gDialTelNumber_string[i]=gBAP_Indication_data[i+5];
                                  gDialTelNumber_data[i]=gBAP_Indication_data[i+5];                              
                                }
                          
                                
                                
                            if(gBAP_Indication_data[0] == 0x00 || gBAP_Indication_data[0] == 0x01) // if Start-Result - "Dial Number" or "DialService" received
                            {
                              if(tel_number_emergency(gDialTelNumber_string,0) == 0)
                              {                               
                              gcallID = searchFREEcallID(dialing);
                              searchandSetNameNr(gcallID);
                             // setcallINFO();
                              settimer(setcallInfo,10);
                             // setcallState();
                              settimer(setDIALcallState,50);
                              }
                              else
                              {
                                setcallState(gcallID,ecallconfirmationpending); 
                                sendCallStateStatus();
                                settimer (EmergencyCallTimer,10); // 10 seconds waiting for confirmation or cancel
                              }                              
                            }
                            
                             
                            if(gBAP_Indication_data[0] == 0x2) // if Start-Result - "Confirm emergency call" received
                            {
                                                
                              if (gBAP_Indication_data[2] == 0x1) //cancel emergency call 
                               {
                                putvalue(P_FSG_40_0_0_22_23,0); // bit 7 = 0  -> eCallConfirmationPending = False 
                                sendCallStateStatus();
                               }
                              
                              if (gBAP_Indication_data[2] == 0x0) // confirm emergeny call
                              {
                               gcallID = searchFREEcallID(dialing);
                               getvalue(env_FSG_DialNumber_TelNumber,gDialTelNumber_string);
                               SetNameandNumber(gcallID,"",gDialTelNumber_string);    //set call info for emergency call : 112 or 911 , name should be empty
                                
                               setcallType(gcallID,4); //4-emergency call // set "emergency call" call type //
                               setcallState(gcallID,dialing); // set "dialing" call state
                               putvalue(P_FSG_40_0_0_22_23,0); // bit 7 = 0  -> eCallConfirmationPending = False 
                               sendCallStateStatus();
                              }

                            }
                            
                            
                            
                           if(gBAP_Indication_data[0] == 0x3) // if Start-Result - "Hang up" received
                            {
                              if (gcallID == 0xC)
                              {
                                for(i=0;i<7;i++)
                                    {															//check call-states for active call
                                			if(gCallState[i]==active )
                                      {
                                        gcallID=i;
                                        setcallState(gcallID,disconnecting);// set "disconecting " call state 
                                        sendCallStateStatus();
                                      }
                                    }
                                settimer(disconnectingTimer_Methods ,1500);
                              }
                              else if (gcallID == 0xD)
                              {
                                for(i=0;i<7;i++)
                                    {															//check call-states for held call
                                			if(gCallState[i]==onhold )
                                      {
                                        gcallID=i;
                                        setcallState(gcallID,disconnecting);// set "disconecting " call state 
                                        sendCallStateStatus();
                                      }
                                    }
                                settimer(disconnectingTimer_Methods ,1500);
                              }
                              else if (gcallID == 0xE)
                              {
                                for(i=0;i<7;i++)
                                    {															//check call-states for active and held calls
                                			if(gCallState[i]==onhold || gCallState[i]==active)
                                      {
                                        gcallID=i;
                                        setcallState(gcallID,disconnecting);// set "disconecting " call state 
                                        sendCallStateStatus();
                                      }
                                    }
                                settimer(disconnectingTimer_Methods ,1500);
                              }
                              else if (gcallID == 0xF)
                              {
                                for(i=0;i<7;i++)
                                    {															//check call-states for all calls
                                        gcallID=i;
                                        setcallState(gcallID,disconnecting);// set "disconecting " call state 
                                        sendCallStateStatus();
                                    }
                                settimer(disconnectingTimer_Methods ,1500);
                              }
                              else
                                {
                              setcallState(gcallID,disconnecting);// set "disconecting " call state                             
                              sendCallStateStatus(); 
                              setTimer(disconnectingTimer, 1500); // set "idle" call state after 1,5 seconds
                                }
                            }
                            
                             if(gBAP_Indication_data[0] == 0x4) // if Start-Result - "Accept Call" received
                            {  
                              
                              for(i=0;i<7;i++)
                                    {			
                                      if(gCallState[i]==active && getValue(M_FSG_40_0_0_63_Result_2) == 0)
                                      {
                                      gcallID=i;
                                        setcallState(gcallID,onhold); // set " OnHold " call state
                                        sendCallStateStatus();
                                      }

                                    }  
                                    
                                    for(i=0;i<7;i++)
                                    {			
                                    //check call-states for incoming call
                                			if(gCallState[i]==ringing_waiting && getValue(M_FSG_40_0_0_63_Result_2) == 0)
                                			{
                                        gcallID=i;
                                        setcallState(gcallID,active); // set " Active " call state
                                        sendCallStateStatus();
                                        gcallIDActive=gcallID; // store CallID for Active Call
                                        P_FSG_40_0_0_22_BuildFct();
                                        getValue(P_FSG_40_0_0_22, BAPTemp);
                                        Request_ByteSequence(LSGID, P_FSG_40_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_22));
                                		    //break;
                                      }
                                    }  
                               
                            }
                          
                              if(gBAP_Indication_data[0] == 0x5) // if Start-Result - "Call Hold" received
                            {
                              for(i=0;i<7;i++){
		                            	if(gCallState[i]==active)
                                  {                                    
                                     gcallID = i; 
                                     setcallState(gcallID,onhold); // set " on Hold " call state
                                     sendCallStateStatus();
                                     //break;
                                  }
                              }
                                                     
                            }
                            
                                if(gBAP_Indication_data[0] == 0x6) // if Start-Result - "Resume Call" received
                            {  
                               for(i=0;i<7;i++)
                                {
                                    if(gCallState[i]==onhold)
                                    {                
                                        areAllOnHold = 1;
                                    }
                
                                    else if(gCallState[i]!=onhold && gCallState[i]!=idle)
                                    {            
                                        areAllOnHold = 0;
                                        break;
                                    }
                                }
                               for(i=0;i<7;i++)
                              {
		                            	if(gCallState[i]==onhold)
                                  {    
                                     gcallID = i; 
                                     setcallState(gcallID,active); // set " Active " call state  
                                     sendCallStateStatus();
                                     gcallIDActive=gcallID; // store CallID for Active Call

                                     //break;
                                  }
                                }
                                
                                areAllOnHold = 0;
                            }
                            
                                if(gBAP_Indication_data[0] == 0x7) // if Start-Result - "MPReleaseActiveCallAcceptWaitingCall" received
                            {
                            for(i=0;i<7;i++)
                            {  
                              if((gCallState[i]==active || gCallState[i]==onhold) &&
                                  gCallType[i]!=conferenceVoiceCall)
                                  {                                      
                                     gcallID = i; 
                                     setcallState(gcallID,disconnecting); // set " on Hold " call state
                                     sendCallStateStatus();
                                     setTimer(disconnectingTimer, 1500); // set "idle" call state after 1,5 seconds
                                  }
                                  
                               else if((gCallState[i]==active || gCallState[i]==onhold) &&
                                        gCallType[i]==conferenceVoiceCall)
                                  {                                      
                                     gcallID = i; 
                                     setcallState(gcallID,idle); // set "idle" call state
                                     setcallType(gcallID, unknownCall);
                                     call_options_disable();
                                     sendCallStateStatus();
                                     
                                  }
                                  
                              if(gCallState[i]==ringing_waiting)
                                  {                                    
                                     gcallID = i; 
                                     setcallState(gcallID,active); // set " Active " call state
                                     sendCallStateStatus();
                                  }
                            }
                            
                            }
                            
                              
                                if(gBAP_Indication_data[0] == 0x8) // if Start-Result - "MPSwap" received ///nu gasesc in MSC
                            {                              
                               settimer(MPswapTimer,500);
                            }
                            
                            
                                 if(gBAP_Indication_data[0] == 0x9) // if Start-Result - "MPCallHoldAcceptWaitingCall" received
                            {
                            for(i=0;i<7;i++)
                            {  
                              if(gCallState[i]==active)
                                  {                                    
                                     gcallID = i; 
                                     setcallState(gcallID,onhold); // set " on Hold " call state
                                     sendCallStateStatus();
                                  }
                              if(gCallState[i]==ringing_waiting)
                                  {                                    
                                     gcallID = i; 
                                     setcallState(gcallID,active); // set " Active " call state
                                     sendCallStateStatus();
                                  }
                            }
                                  
                            }
                            
                               if(gBAP_Indication_data[0] == 0x0A) // if Start-Result - "MPReleaseAllCallsAcceptWaitingCall" received ///nu gasesc in MSC
                            {
                               putValue(P_FSG_40_0_0_22_1,5); // set " on hold " call state for call id 0 // de facut handling automat intre call id
                               putValue(P_FSG_40_0_0_22_4,2); // set " idle " call state for call id 1
                               P_FSG_40_0_0_22_BuildFct();
                               getValue(P_FSG_40_0_0_22, BAPTemp);
                               Request_ByteSequence(LSGID, P_FSG_40_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_22));
                            }
                            
                                if(gBAP_Indication_data[0] == 0x0B) // if Start-Result - "MPSetWaitingCallOnHold" received ///nu gasesc in MSC
                            {
                               putValue(P_FSG_40_0_0_22_1,5); // set " on hold " call state for call id 0 // de facut handling automat intre call id
                               putValue(P_FSG_40_0_0_22_4,2); // set " idle " call state for call id 1
                               P_FSG_40_0_0_22_BuildFct();
                               getValue(P_FSG_40_0_0_22, BAPTemp);
                               Request_ByteSequence(LSGID, P_FSG_40_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_22));
                            }
                                  
                                if(gBAP_Indication_data[0] == 0x0C) // if Start-Result - "CCJoin" received 
                            {
          
                              for(i=0;i<7;i++)
                              {
		                            	if(gCallState[i]==onhold)
                                  {    
                                     gcallID = i; 
                                     setcallType(gcallID,conferenceVoiceCall);
                                     setcallState(gcallID,active); // set " Active " call state
                                     sendCallStateStatus();
                                     
                                  }
                                  
                                  if(gCallState[i]==active)
                                  {    
                                     gcallID = i; 
                                     setcallType(gcallID,conferenceVoiceCall);
                                     setcallState(gcallID,active); // set " Active " call state
                                     sendCallStateStatus();
                                  }
                              }
                              
                              if(areAllActiveInConference() == 1)
                              {
                                  setAllActiveInConferenceBits();
                              }
                              
                               P_FSG_40_0_0_22_BuildFct();
                               getValue(P_FSG_40_0_0_22, BAPTemp);
                               Request_ByteSequence(LSGID, P_FSG_40_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_22));
                            }                                
                                 
                                  if(gBAP_Indication_data[0] == 0x0D) // if Start-Result - "CCSplit" received ///nu gasesc in MSC
                            {
                               putValue(P_FSG_40_0_0_22_1,5); // set " on hold " call state for call id 0 // de facut handling automat intre call id
                               putValue(P_FSG_40_0_0_22_4,2); // set " idle " call state for call id 1
                               P_FSG_40_0_0_22_BuildFct();
                               getValue(P_FSG_40_0_0_22, BAPTemp);
                               Request_ByteSequence(LSGID, P_FSG_40_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_22));
                            }                           
                            
                            
                                  if(gBAP_Indication_data[0] == 0x0E) // if Start-Result - "SelectAudioSink" received ///nu gasesc in MSC
                            {
                               putValue(P_FSG_40_0_0_22_1,5); // set " on hold " call state for call id 0 // de facut handling automat intre call id
                               putValue(P_FSG_40_0_0_22_4,2); // set " idle " call state for call id 1
                               P_FSG_40_0_0_22_BuildFct();
                               getValue(P_FSG_40_0_0_22, BAPTemp);
                               Request_ByteSequence(LSGID, P_FSG_40_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_22));
                            } 
                                    
                          
                                  if(gBAP_Indication_data[0] == 0x0F) // if Start-Result - "RejectCallWithMessage" received ///nu gasesc in MSC
                            {
                               putValue(P_FSG_40_0_0_22_1,5); // set " on hold " call state for call id 0 // de facut handling automat intre call id
                               putValue(P_FSG_40_0_0_22_4,2); // set " idle " call state for call id 1
                               P_FSG_40_0_0_22_BuildFct();
                               getValue(P_FSG_40_0_0_22, BAPTemp);
                               Request_ByteSequence(LSGID, P_FSG_40_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_22));
                            }       
                                    
                                    
                                    
                                    
                                    
                            //write("gBAP_Indication_header=%x",gBAP_Indication_data[0]);
                                    
                            //write("gBAP_Indication_header=%x",gBAP_Indication_data[0]);
                             
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_63", MakeRGB(255,255,255));  
                            break;
                        case Start_IND:
                            if (getValue(M_FSG_40_0_0_63_ErrEn)) { 
                               Request_error(LSGID,M_FSG_40_0_0_63_ID,getValue(M_FSG_40_0_0_63_ErrCode)); 
                               break;
                            }
                            putValue(M_FSG_40_0_0_63_State, "Started");
                            // Daten setzen
                            putValue(M_FSG_40_0_0_63_Start, gBAP_Indication_data, gBAP_Indication_header[4]);
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_63", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
              case Bap_void:
                    switch (gBAP_Indication_header[2]) // IndType
                    {
                        case AbortResult_IND:
                            putValue(M_FSG_40_0_0_63_State, "Aborted");
                            //if (getValue(M_FSG_40_0_0_63_ErrEn)) 
                            { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_63_ID, getValue(M_FSG_40_0_0_63_ErrCode));
                            }
                            break;
                        case Processing_CNF_IND:    
                            if (getValue(M_FSG_40_0_0_63_ErrEn)) { 
                               // Fehler als Quittierung schicken
                               Request_Error(LSGID, M_FSG_40_0_0_63_ID, getValue(M_FSG_40_0_0_63_ErrCode));
                               break;
                            }
                            // Processing schicken
                            //getValue(M_FSG_40_0_0_63_Processing, temp);
                            //Request_byteSequence(LSGID, M_FSG_40_0_0_63_ID, Processing_REQ, temp, getValueSize(M_FSG_40_0_0_63_Processing));
                            M_FSG_40_0_0_63_ProcessingRequest();
                            setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_63", MakeRGB(255,255,255));  
                            break;
                        default:
                            PrintIndicationError("Illegal IndType");
                            break;
                    }
                    break;
            case Bap_error:
                gM_FSG_40_0_0_63_ErrCode = 0;
                putValue(M_FSG_40_0_0_63_ErrCode,  gBAP_Indication_header[5]);
                setControlBackColor(panel_name, "errfield_M_FSG_40_0_0_63", MakeRGB(255,79,79));  
                gM_FSG_40_0_0_63_ErrCode = 1;
                break;
            case Bap_acknowledge:
                break;
            default:
                    PrintIndicationError("Illegal DataType");
                    break;
            }
    break;
       default:
           writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal Fct: lsgid:%d fctid:%d indType:%d",
           NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], gBAP_Indication_header[2]);
           break;
       }
       break;
   default:
       writelineEx(gError_Trace, 0, "NodeIndex: %d: Illegal LSGID: lsgid:%d fctid:%d indType:%s", NODE_INDEX, gBAP_Indication_header[0], gBAP_Indication_header[1], Indicationtype_Text[gBAP_Indication_header[2]]);
       break;
   }
}

oN timer setcallInfo
{
     setcallINFO();
}

on timer setDIALcallState
{
  setcallState(gcallID,3); // SET dial call state for gcallID
  sendCallStateStatus();
}

on timer disconnectingTimer
{
  byte BAPTemp[994];
   byte emptyString[1];
   int ID,i;
  
 for(i=0;i<7;i++)
 { 
   if(gCallState[i]==disconnecting)
    { ID=i;
      setcallState(ID,0); // set "idle " call state after "disconnecting" state -- Hang up Method
      //write("gcallID= %x",gcallID);
      gcallID=i;
      call_options_disable (); // disable all call options
      cleancallINFO(ID);
      cleancallType(ID); 
      sendCallStateStatus();
    }  
 }
}

void cleancallType(int callID)
{byte BAPTemp[994];
    
   if(callID == 0)
  {
    putValue(P_FSG_40_0_0_22_2,0); // clear call type  - ID 0
  }
   if(callID == 1)
  {
    putValue(P_FSG_40_0_0_22_5,0); //  clear call type - ID 1
  }
   if(callID == 2)
  {
    putValue(P_FSG_40_0_0_22_8,0); //  clear call type - ID 2
  }
   if(callID == 3)
  {
    putValue(P_FSG_40_0_0_22_11,0); //  clear call type - ID 3
  }
   if(callID == 4)
  {
    putValue(P_FSG_40_0_0_22_14,0); //  clear call type - ID 4
  }
   if(callID == 5)
  {
    putValue(P_FSG_40_0_0_22_17,0); //  clear call type - ID 5
  }
   if(callID == 6)
  {
    putValue(P_FSG_40_0_0_22_20,0); //  clear call type - ID 6
  }
  
}

void cleancallINFO(int gcallID)
{  
  byte BAPTemp[994];
  byte emptyString[1];
  
   if(gcallID == 0)
  {
  putvalue(P_FSG_40_0_0_23_2, emptyString,0);  // clear TelNumber0
  putvalue(P_FSG_40_0_0_23_2_len,0);
  putvalue(P_FSG_40_0_0_23_1,emptyString,0);   // clear PbName0
  putvalue(P_FSG_40_0_0_23_1_len,0);
 
  }
    if(gcallID == 1)
  {
  putvalue(P_FSG_40_0_0_23_5, emptyString,0); // clear TelNumber1
  putvalue(P_FSG_40_0_0_23_5_len,0);
  putvalue(P_FSG_40_0_0_23_4, emptyString,0); // clear PbName1
  putvalue(P_FSG_40_0_0_23_4_len,0);
  }
    if(gcallID == 2)
  {
  putvalue(P_FSG_40_0_0_23_8, emptyString,0); // clear TelNumber2
  putvalue(P_FSG_40_0_0_23_8_len,0);
  putvalue(P_FSG_40_0_0_23_7, emptyString,0); // clear PbName2
  putvalue(P_FSG_40_0_0_23_7_len,0);
  }
    if(gcallID == 3)
  {
  putvalue(P_FSG_40_0_0_23_11,emptyString,0); // clear TelNumber3
  putvalue(P_FSG_40_0_0_23_11_len,0);
  putvalue(P_FSG_40_0_0_23_10, emptyString,0);// clear PbName3
  putvalue(P_FSG_40_0_0_23_10_len,0);
  }
    if(gcallID == 4)
  {
  putvalue(P_FSG_40_0_0_23_14, emptyString,0); // clear TelNumber4
  putvalue(P_FSG_40_0_0_23_14_len,0);
  putvalue(P_FSG_40_0_0_23_13, emptyString,0); // clear PbName4
  putvalue(P_FSG_40_0_0_23_13_len,0);
 
  }
    if(gcallID == 5)
  {
  putvalue(P_FSG_40_0_0_23_17, emptyString,0); // clear TelNumber5
  putvalue(P_FSG_40_0_0_23_17_len,0);
  putvalue(P_FSG_40_0_0_23_16, emptyString,0); // clear PbName5
  putvalue(P_FSG_40_0_0_23_16_len,0);
  }
    if(gcallID == 6)
  {
  putvalue(P_FSG_40_0_0_23_20, emptyString,0); // clear TelNumber6
  putvalue(P_FSG_40_0_0_23_20_len,0);
  putvalue(P_FSG_40_0_0_23_19, emptyString,0); // clear PbName6
  putvalue(P_FSG_40_0_0_23_19_len,0);
  }
  
  
    P_FSG_40_0_0_23_BuildFct();
    getValue(P_FSG_40_0_0_23, BAPTemp);
    Request_ByteSequence(LSGID, P_FSG_40_0_0_23_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_23));
}


void setcallINFO()
 { byte BAPTemp[994];

     getValue(P_FSG_40_0_0_23, BAPTemp);
     Request_ByteSequence(LSGID, P_FSG_40_0_0_23_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_23));
 }

void setcallState(int callID, int callState)
{byte BAPTemp[994];
     
  
     if(callState == ecallconfirmationpending)
       putValue(P_FSG_40_0_0_22_23,128); //bit 7 =1 in eCallConfirmationPending
    else
  
    {
  
   if(callID == 0)
  {
    putValue(P_FSG_40_0_0_22_1,callState); // set call state - ID 0
  }
   if(callID == 1)
  {
    putValue(P_FSG_40_0_0_22_4,callState); //  set call state - ID 1
  }
   if(callID == 2)
  {
    putValue(P_FSG_40_0_0_22_7,callState); //  set call state - ID 2
  }
   if(callID == 3)
  {
    putValue(P_FSG_40_0_0_22_10,callState); //  set call state - ID 3
  }
   if(callID == 4)
  {
    putValue(P_FSG_40_0_0_22_13,callState); //  set call state - ID 4
  }
   if(callID == 5)
  {
    putValue(P_FSG_40_0_0_22_16,callState); //  set call state - ID 5
  }
   if(callID == 6)
  {
    putValue(P_FSG_40_0_0_22_19,callState); //  set call state - ID 6
  }
  
    updateCallState();
    updateCallType();
    updateCallOptions(callID, callState); 
  
      }
   
}

void setcallType(int callID, int calltype)
{byte BAPTemp[994];
    
   if(callID == 0)
  {
    putValue(P_FSG_40_0_0_22_2,calltype); // set call type - ID 0
  }
   if(callID == 1)
  {
    putValue(P_FSG_40_0_0_22_5,calltype); //  set call type - ID 1
  }
   if(callID == 2)
  {
    putValue(P_FSG_40_0_0_22_8,calltype); //  set call type - ID 2
  }
   if(callID == 3)
  {
    putValue(P_FSG_40_0_0_22_11,calltype); //  set call type - ID 3
  }
   if(callID == 4)
  {
    putValue(P_FSG_40_0_0_22_14,calltype); //  set call type - ID 4
  }
   if(callID == 5)
  {
    putValue(P_FSG_40_0_0_22_17,calltype); //  set call type - ID 5
  }
   if(callID == 6)
  {
    putValue(P_FSG_40_0_0_22_20,calltype); //  set call type - ID 6
  }
  
//    P_FSG_40_0_0_22_BuildFct();
//    getValue(P_FSG_40_0_0_22, BAPTemp);
//    Request_ByteSequence(LSGID, P_FSG_40_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_22));                      
  
}


void searchandSetNameNr(int callID)
{
  int i,j,t,length_name=0,length_number=0;
  byte BAPTemp[994];
  char tempTelNR[40]; 
  char tempName[6];
 
  
  for(i=0; i < Telefon_CombinedNumbers_Length ;i++)
  {  
    if(strstr(Telefon_CombinedNumbers[i].Param5,gDialTelNumber_string)!=-1) // compare DialedNumber with number stored in combined
     { 
        for(t=0;t<elcount(gDialName_string);t++) // if number matched clear variables for Name
            	{
                gDialName_string [t]=0;
              	gDialName_data   [t]=0;
              }
       //     ********************
      
     
      for(j=0;j<A_FSG_40_0_0_49_ArrayDataList[i].Param2_length;j++) // if number matched get the Name 
              { //write("gDialName_string=%x",Telefon_CombinedNumbers[i].Param2[j]);
                gDialName_string[j] = Telefon_CombinedNumbers[i].Param2[j];
////               gDialName_string[j] = Telefon_CombinedNumbers[i].Param2[j];
//             //  snprintf(tempName,elcount(tempName),"%s",Telefon_CombinedNumbers[i].Param2[j]);
//            //    write("tempname=%s",tempName);
                gDialName_data[j] = A_FSG_40_0_0_49_ArrayDataList[i].Param2[j];
           //     write("gDialName_data=%x",gDialName_data[j]);
              }
      break;
      }
  }
  
 
// write("gDialName_string=%s",gDialName_string);
//  write("Namefound:%s",gDialName_string);
//   write("tempTelNR:%s",Telefon_CombinedNumbers[i].Param5);
//   write("gDialTelNumber:%s",gDialTelNumber_string);

  if(j==0) // if tel number not found get Name from Methods panel // if Name is empty - length == 0 --> set only tel Number
   length_name = strlen (gDialName_string) ;
  else
  length_name=j;
  
   //write("length_name:%d",length_name);
  length_number=strlen(gDialTelNumber_string);
  //write("length_number:%d",length_number);
  
   if(callID == 0)
  {
  putvalue(P_FSG_40_0_0_23_2, gDialTelNumber_data,length_number); //TelNumber0
  putvalue(P_FSG_40_0_0_23_1, gDialName_data,length_name); //PbName0
 
  }
    if(callID == 1)
  {
  putvalue(P_FSG_40_0_0_23_5, gDialTelNumber_data,length_number); //TelNumber1
  putvalue(P_FSG_40_0_0_23_4, gDialName_data,length_name); //PbName1 
  }
    if(callID == 2)
  {
  putvalue(P_FSG_40_0_0_23_8, gDialTelNumber_data,length_number); //TelNumber2
  putvalue(P_FSG_40_0_0_23_7, gDialName_data,length_name); //PbName2
  }
    if(callID == 3)
  {
  putvalue(P_FSG_40_0_0_23_11, gDialTelNumber_data,length_number); //TelNumber3
  putvalue(P_FSG_40_0_0_23_10, gDialName_data,length_name); //PbName3
  }
    if(callID == 4)
  {
  putvalue(P_FSG_40_0_0_23_14, gDialTelNumber_data,length_number); //TelNumber4 
  putvalue(P_FSG_40_0_0_23_13, gDialName_data,length_name); //PbName4
  }
    if(callID == 5)
  {
  putvalue(P_FSG_40_0_0_23_17, gDialTelNumber_data,length_number); //TelNumber5
  putvalue(P_FSG_40_0_0_23_16, gDialName_data,length_name); //PbName5
  }
    if(callID == 6)
  {
  putvalue(P_FSG_40_0_0_23_20, gDialTelNumber_data,length_number); //TelNumber6
  putvalue(P_FSG_40_0_0_23_19, gDialName_data,length_name); //PbName6
  }
  
   P_FSG_40_0_0_23_BuildFct();
   settimer(setcallInfo,1);
  
  
}

on message BAP_Telefon_ASG_02
{
   int i, temp;
   byte RX_Data[8];            // received CAN-DATA
   dword RX_Header[3];         // received CAN-Header
   if(gSG_PowerOnOff==Power_on){
       RX_Header[0]=this.CAN;
       RX_Header[1]=this.ID;
       RX_Header[2]=this.DLC; // received length
       for (i=0; i<this.DLC; i++) {
           RX_Data[i]=this.byte(i);
       }
	   
	   Telefon_Source = 2;
	   
	   //MR61529 - start
        //temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
         switch ((RX_Data[1] & 0x0F))
        {
        //getAll
        case 1: //error
                if (getValue(C_FSG_40_0_0_0_1_ErrEn)==0x01)
                Request_error(LSGID,FctID_GetAll,getValue(C_FSG_40_0_0_0_1_ErrCode)); 
                
                else if (getValue(C_FSG_40_0_0_0_1_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 2: //error
                if (getValue(P_FSG_40_0_0_0_2_ErrEn)==0x01)
                Request_error(LSGID,FctID_BAP_Config,getValue(P_FSG_40_0_0_0_2_ErrCode)); 

                else if (getValue(P_FSG_40_0_0_0_2_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 3: //error
                if (getValue(P_FSG_40_0_0_0_3_ErrEn)==0x01)
                Request_error(LSGID,FctID_FunctionList,getValue(P_FSG_40_0_0_0_3_ErrCode)); 
                
                else if (getValue(P_FSG_40_0_0_0_3_FctEn) == 0x01)
       		temp=BAP150_CAN_SetRxDat(NODE_INDEX, RX_Header, RX_Data);
       		break;
             
        
        default: temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	//send recieved CAN-data with CAN-header to BAP-DLL
                break;
        }
	   
       //temp=BAP150_CAN_SetRxDat(NODE_INDEX, RX_Header, RX_Data);
   }
}

on message BAP_Telefon_ASG_01
{
   int i, temp;
   byte RX_Data[8];            // received CAN-DATA
   dword RX_Header[3];         // received CAN-Header
   if(gSG_PowerOnOff==Power_on){
       RX_Header[0]=this.CAN;
       RX_Header[1]=this.ID;
       RX_Header[2]=this.DLC; // received length
       for (i=0; i<this.DLC; i++) {
           RX_Data[i]=this.byte(i);
       }
	   
	   Telefon_Source = 1;
	   
	   //MR61529 - start
        //temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);
         switch ((RX_Data[1] & 0x0F))
        {
        //getAll
        case 1: //error
                if (getValue(C_FSG_40_0_0_0_1_ErrEn)==0x01)
                Request_error(LSGID,FctID_GetAll,getValue(C_FSG_40_0_0_0_1_ErrCode)); 
                
                else if (getValue(C_FSG_40_0_0_0_1_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 2: //error
                if (getValue(P_FSG_40_0_0_0_2_ErrEn)==0x01)
                Request_error(LSGID,FctID_BAP_Config,getValue(P_FSG_40_0_0_0_2_ErrCode)); 

                else if (getValue(P_FSG_40_0_0_0_2_FctEn) == 0x01)
                temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 3: //error
                if (getValue(P_FSG_40_0_0_0_3_ErrEn)==0x01)
                Request_error(LSGID,FctID_FunctionList,getValue(P_FSG_40_0_0_0_3_ErrCode)); 
                
                else if (getValue(P_FSG_40_0_0_0_3_FctEn) == 0x01)
       		temp=BAP150_CAN_SetRxDat(NODE_INDEX, RX_Header, RX_Data);
       		break;
             
        
        default: temp=BAP150_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	//send recieved CAN-data with CAN-header to BAP-DLL
                break;
        }
		
       //temp=BAP150_CAN_SetRxDat(NODE_INDEX, RX_Header, RX_Data);
   }
}

on message BAP_Telefon_FSG_01
{
   int i, temp;
   byte buffer[8];
   byte RX_Data[8];            // received CAN-DATA
   dword RX_Header[3];         // received CAN-Header
   if(gSG_PowerOnOff==Power_on)
    {
       RX_Header[0]=this.CAN;
       RX_Header[1]=this.ID;
       RX_Header[2]=this.DLC; // received length
       for (i=0; i<this.DLC; i++) 
       {
           RX_Data[i]=this.byte(i);
       }
    }
}

on message BAP_Telefon_FSG_02
{
   int i, temp;
   byte buffer[8];
   byte RX_Data[8];            // received CAN-DATA
   dword RX_Header[3];         // received CAN-Header
   if(gSG_PowerOnOff==Power_on)
    {
       RX_Header[0]=this.CAN;
       RX_Header[1]=this.ID;
       RX_Header[2]=this.DLC; // received length
       for (i=0; i<this.DLC; i++) 
       {
           RX_Data[i]=this.byte(i);
       }
 }
}

on message Diagnose_01
{
  byte second, minute, hour;
  
  if (@P_FSG_40_0_0_24_UseDiagValues == 1)
  {
    second = @EnvUH_Sekunde;
    minute = @EnvUH_Minute;
    hour = @EnvUH_Stunde;
    
    @P_FSG_40_0_0_24_1 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_2 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_3 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_4 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_5 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_6 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
    @P_FSG_40_0_0_24_7 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
  }
  
  if (@P_FSG_40_0_0_58_UseDiagValues == 1)
  {
    second = @EnvUH_Sekunde;
    minute = @EnvUH_Minute;
    hour = @EnvUH_Stunde;
    
    @P_FSG_40_0_0_58_1 = @EnvUH_Sekunde + @EnvUH_Minute*64 + @EnvUH_Stunde*4096;
  }
}

intertelegram_err(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=1;
    data[3]=940;
    ChangeConfig(0x0020,data);
}

sequence_err(long fctId, long size)
{
    long data[5];
    long lastSeg;

    lastSeg = size-5;

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=lastSeg/7+1;
    data[3]=1;
    data[4]=(lastSeg/7+4) & 15;
    ChangeConfig(0x0021,data);
}

intertelegram_err_off(long fctId)
{
    long data[4];
    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    ChangeConfig(0x0020,data);
}

sequence_err_off(long fctId)
{
    long data[5];

    data[0]=LSGID;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    data[4]=0;
    ChangeConfig(0x0021,data);
}

// START OF BUS CONFIG PANEL CAPL

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_BUS_SELECTOR_PANEL_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_CAN_FRAME_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_FR_FRAME_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_ETHERNET_FRAME_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ENABLE_IP_FORMAT_TOKEN)

// ETHERNET AND FLEXRAY NOT ENABLED! (ON_ENVVAR_BUSTYPE_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_ETHERNET_APPLY_BTN_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_ETHERNET_RESET_BTN_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_IP_INTERFACE_LIST_TOKEN)

// ETHERNET NOT ENABLED! (ON_ENVVAR_IP_FORMAT_TOKEN)

// ETHERNET NOT ENABLED! (ON_UDP_RECEIVE_FROM_TOKEN)

// ETHERNET NOT ENABLED!

on envVar ON_OFF_FSG40_0
{
   BapOnOff(getvalue(this));
   gSG_PowerOnOff=getvalue(ON_OFF_FSG40_0);
}
on envVar BAPCFG_FSG_40_0_0_DFMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 9, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_40_0_0_DFMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 10, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_40_0_0_LsgClassMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 5, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_40_0_0_LsgClassMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 6, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_40_0_0_ProtocolMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 7, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
on envVar BAPCFG_FSG_40_0_0_ProtocolMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = LSGID;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP150_ChangeConfig(NODE_INDEX, 8, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID C_FSG_40_0_0_1_ID
on envVar C_FSG_40_0_0_1_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_C_FSG_40_0_0_1", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_C_FSG_40_0_0_1", MakeRGB(250,0,0));
       }
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_40_0_0_2_ID
on envVar P_FSG_40_0_0_2_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_2", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_2", MakeRGB(250,0,0));
       }
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_2_ErrCode
{
       if(gP_FSG_40_0_0_2_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_2", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_2_ErrCode = 1;
}
// Setzen der Schriftfarbe bei Zustandswechsel der FCTID P_FSG_40_0_0_3_ID
on envVar P_FSG_40_0_0_3_FctLstItemEn
{
       if(getValue(this)) 
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_3", MakeRGB(0,240,0));
       }
       else
       {
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_3", MakeRGB(250,0,0));
       }
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_3_ErrCode
{
       if(gP_FSG_40_0_0_3_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_3", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_3_ErrCode = 1;
}
// De-Aktivierung der Eingabefelder der HB-FCT P_FSG_40_0_0_4
on envVar P_FSG_40_0_0_4_FctLstItemEn
{
       if(getValue(this)) 
       {
//           EnableControl(panel_name,"panel_FSG_40_0_0_4",1);
//           EnableControl(panel_name,"${ERRFIELD}",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_4_HBEn",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_4", MakeRGB(0,240,0));
       }
       else
       {
//           EnableControl(panel_name,"panel_FSG_40_0_0_4",0);
//           EnableControl(panel_name,"${ERRFIELD}",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_4_HBEn",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_4", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_4_FctEn
{
  P_FSG_40_0_0_4_FctEn();
}
P_FSG_40_0_0_4_FctEn()
{
	long data[2];
	if(getValue(P_FSG_40_0_0_4_FctEn)>0)
	{
		data[0] = 40;
		data[1] = getValue(P_FSG_40_0_0_4);
		write("enable HB");
	}
	else
	{
		data[0] = 40;
		data[1] = 0;
		write("disable HB");
	}
	Bap150_ChangeConfig(NODE_INDEX, 0x00, data);
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_4_ErrCode
{
       if(gP_FSG_40_0_0_4_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_4", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_4_ErrCode = 1;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_14_ErrCode
{
       if(gP_FSG_40_0_0_14_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_14", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_14_ErrCode = 1;
}
on envVar P_FSG_40_0_0_14Status_BTN
{
	byte BAPTemp[2];
   if (P_FSG_40_0_0_14Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_40_0_0_14_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_14",MakeRGB(255,255,255));
      P_FSG_40_0_0_14Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_40_0_0_14, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_40_0_0_14_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_14));
      P_FSG_40_0_0_14Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_40_0_0_14_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_14_ID;
    data[2]=getValue(P_FSG_40_0_0_14_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_14
on envVar P_FSG_40_0_0_14_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_14",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_14",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_14",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_14", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_14",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_14",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_14",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_14", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_14 // bus value of FSG_Setup (14).
{
	// opcodes: Error-Status
	byte param1; // PhoneCharacteristics
	byte param2; // MobileConnectionType
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[2];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_14, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_40_0_0_14_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_40_0_0_14_2, param2);
}

on envVar P_FSG_40_0_0_14_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PhoneCharacteristics
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_14_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_14_1,thisval);
}

on envVar P_FSG_40_0_0_14_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PhoneCharacteristics
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_14_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_14_1,thisval);
}

on envVar P_FSG_40_0_0_14_1_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PhoneCharacteristics
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_14_1);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_14_1,thisval);
}

on envVar P_FSG_40_0_0_14_1_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PhoneCharacteristics
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_14_1);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_14_1,thisval);
}

on envVar P_FSG_40_0_0_14_1_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PhoneCharacteristics
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_14_1);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_14_1,thisval);
}

on envVar P_FSG_40_0_0_14_1_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PhoneCharacteristics
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_14_1);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_14_1,thisval);
}

on envVar P_FSG_40_0_0_14_1_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PhoneCharacteristics
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_14_1);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_14_1,thisval);
}

on envVar P_FSG_40_0_0_14_1 // FSG_Setup.PhoneCharacteristics
{
	byte superval[2];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // PhoneCharacteristics
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_40_0_0_14_1_0, 1);
	else
		putValue(P_FSG_40_0_0_14_1_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_40_0_0_14_1_1, 1);
	else
		putValue(P_FSG_40_0_0_14_1_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_40_0_0_14_1_2, 1);
	else
		putValue(P_FSG_40_0_0_14_1_2, 0);
	if(thisval&(mask<<3))
		putValue(P_FSG_40_0_0_14_1_3, 1);
	else
		putValue(P_FSG_40_0_0_14_1_3, 0);
	if(thisval&(mask<<4))
		putValue(P_FSG_40_0_0_14_1_4, 1);
	else
		putValue(P_FSG_40_0_0_14_1_4, 0);
	if(thisval&(mask<<5))
		putValue(P_FSG_40_0_0_14_1_5, 1);
	else
		putValue(P_FSG_40_0_0_14_1_5, 0);
	if(thisval&(mask<<6))
		putValue(P_FSG_40_0_0_14_1_6, 1);
	else
		putValue(P_FSG_40_0_0_14_1_6, 0);

    // Update superval
	getValue(P_FSG_40_0_0_14, superval);
	superval[0]=thisval;
	putValue(P_FSG_40_0_0_14,superval);
}

on envVar P_FSG_40_0_0_14_2 // FSG_Setup.MobileConnectionType
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // MobileConnectionType
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_40_0_0_14, superval);
	superval[1]=thisval;
	putValue(P_FSG_40_0_0_14,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_15_ErrCode
{
       if(gP_FSG_40_0_0_15_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_15", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_15_ErrCode = 1;
}
on envVar P_FSG_40_0_0_15Status_BTN
{
	byte BAPTemp[3];
   if (P_FSG_40_0_0_15Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_40_0_0_15_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_15",MakeRGB(255,255,255));
      P_FSG_40_0_0_15Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_40_0_0_15, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_40_0_0_15_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_15));
      P_FSG_40_0_0_15Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_40_0_0_15_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_15_ID;
    data[2]=getValue(P_FSG_40_0_0_15_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_15
on envVar P_FSG_40_0_0_15_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_15",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_15",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_15",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_15", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_15",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_15",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_15",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_15", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_15 // bus value of FSG_OperationState (15).
{
	// opcodes: Error-Status
	byte param1; // OP_State
	byte param2; // Tel_State
	byte param3; // PrivacyMode
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[3];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_15, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_40_0_0_15_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_40_0_0_15_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_40_0_0_15_3, param3);
}

on envVar P_FSG_40_0_0_15_1 // FSG_OperationState.OP_State
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // OP_State
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_40_0_0_15, superval);
	superval[0]=thisval;
	putValue(P_FSG_40_0_0_15,superval);
}

on envVar P_FSG_40_0_0_15_2 // FSG_OperationState.Tel_State
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // Tel_State
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_40_0_0_15, superval);
	superval[1]=thisval;
	putValue(P_FSG_40_0_0_15,superval);
}

on envVar P_FSG_40_0_0_15_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PrivacyMode
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_15_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_15_3,thisval);
}

on envVar P_FSG_40_0_0_15_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PrivacyMode
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_15_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_15_3,thisval);
}

on envVar P_FSG_40_0_0_15_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PrivacyMode
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_15_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_15_3,thisval);
}

on envVar P_FSG_40_0_0_15_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // PrivacyMode
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_15_3);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_15_3,thisval);
}

on envVar P_FSG_40_0_0_15_3 // FSG_OperationState.PrivacyMode
{
	byte superval[3];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // PrivacyMode
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_40_0_0_15_3_0, 1);
	else
		putValue(P_FSG_40_0_0_15_3_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_40_0_0_15_3_1, 1);
	else
		putValue(P_FSG_40_0_0_15_3_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_40_0_0_15_3_2, 1);
	else
		putValue(P_FSG_40_0_0_15_3_2, 0);
	if(thisval&(mask<<3))
		putValue(P_FSG_40_0_0_15_3_3, 1);
	else
		putValue(P_FSG_40_0_0_15_3_3, 0);

    // Update superval
	getValue(P_FSG_40_0_0_15, superval);
	superval[2]=thisval;
	putValue(P_FSG_40_0_0_15,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_16_ErrCode
{
       if(gP_FSG_40_0_0_16_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_16", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_16_ErrCode = 1;
}
on envVar P_FSG_40_0_0_16Status_BTN
{
	byte BAPTemp[8];
    if (P_FSG_40_0_0_16Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_40_0_0_16_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_16",MakeRGB(255,255,255));
        P_FSG_40_0_0_16Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_40_0_0_16_BuildFct();
        getValue(P_FSG_40_0_0_16, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_16_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_16));
        if(getValue(P_FSG_40_0_0_16_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_40_0_0_16_ID);
        }
        if(getValue(P_FSG_40_0_0_16_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_40_0_0_16_ID,elCount(BAPTemp));
        }
       P_FSG_40_0_0_16Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_16_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_16_ID;
    data[2]=getValue(P_FSG_40_0_0_16_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_16
on envVar P_FSG_40_0_0_16_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_16",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_16",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_16",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_16", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_16",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_16",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_16",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_16", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_16_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_16_SegmEn,0);
           intertelegram_err(P_FSG_40_0_0_16_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_40_0_0_16_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_16_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_16_IntTlgEn,0);
           sequence_err(P_FSG_40_0_0_16_ID,getValueSize(P_FSG_40_0_0_16_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_40_0_0_16_ID);
       }
}
on envVar P_FSG_40_0_0_16 // bus value of MobileServiceSupport (16).
{
	// opcodes: Error-Status
	byte param1[8]; // FctList
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[8];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 8; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_16, superval);
	///////// Start param1 - 6/8BSTRING /////////
	for( i = 0; i < 8; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(P_FSG_40_0_0_16_1, param1);
}

// Updates the bus value field and other dependencies.
P_FSG_40_0_0_16_BuildFct()
{
	byte param1[8]; // FctList

	int i;
	byte superval[8];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	getValue(P_FSG_40_0_0_16_1, param1);
	@P_FSG_40_0_0_16_1_17 = (param1[2] & 64) > 0;
	@P_FSG_40_0_0_16_1_18 = (param1[2] & 32) > 0;
	@P_FSG_40_0_0_16_1_19 = (param1[2] & 16) > 0;
	@P_FSG_40_0_0_16_1_20 = (param1[2] & 8) > 0;
	@P_FSG_40_0_0_16_1_21 = (param1[2] & 4) > 0;
	@P_FSG_40_0_0_16_1_22 = (param1[2] & 2) > 0;
	@P_FSG_40_0_0_16_1_23 = (param1[2] & 1) > 0;
	@P_FSG_40_0_0_16_1_24 = (param1[3] & 128) > 0;
	@P_FSG_40_0_0_16_1_25 = (param1[3] & 64) > 0;
	@P_FSG_40_0_0_16_1_26 = (param1[3] & 32) > 0;
	@P_FSG_40_0_0_16_1_27 = (param1[3] & 16) > 0;
	@P_FSG_40_0_0_16_1_28 = (param1[3] & 8) > 0;
	@P_FSG_40_0_0_16_1_29 = (param1[3] & 4) > 0;
	@P_FSG_40_0_0_16_1_30 = (param1[3] & 2) > 0;
	@P_FSG_40_0_0_16_1_31 = (param1[3] & 1) > 0;
	@P_FSG_40_0_0_16_1_32 = (param1[4] & 128) > 0;
	@P_FSG_40_0_0_16_1_33 = (param1[4] & 64) > 0;
	@P_FSG_40_0_0_16_1_34 = (param1[4] & 32) > 0;
	@P_FSG_40_0_0_16_1_35 = (param1[4] & 16) > 0;
	@P_FSG_40_0_0_16_1_36 = (param1[4] & 8) > 0;
	@P_FSG_40_0_0_16_1_37 = (param1[4] & 4) > 0;
	@P_FSG_40_0_0_16_1_38 = (param1[4] & 2) > 0;
	@P_FSG_40_0_0_16_1_39 = (param1[4] & 1) > 0;
	@P_FSG_40_0_0_16_1_40 = (param1[5] & 128) > 0;
	@P_FSG_40_0_0_16_1_41 = (param1[5] & 64) > 0;
	@P_FSG_40_0_0_16_1_42 = (param1[5] & 32) > 0;
	@P_FSG_40_0_0_16_1_43 = (param1[5] & 16) > 0;
	@P_FSG_40_0_0_16_1_44 = (param1[5] & 8) > 0;
	@P_FSG_40_0_0_16_1_45 = (param1[5] & 4) > 0;
	@P_FSG_40_0_0_16_1_46 = (param1[5] & 2) > 0;
	@P_FSG_40_0_0_16_1_47 = (param1[5] & 1) > 0;
	@P_FSG_40_0_0_16_1_48 = (param1[6] & 128) > 0;
	@P_FSG_40_0_0_16_1_49 = (param1[6] & 64) > 0;
	@P_FSG_40_0_0_16_1_50 = (param1[6] & 32) > 0;
	@P_FSG_40_0_0_16_1_51 = (param1[6] & 16) > 0;
	@P_FSG_40_0_0_16_1_52 = (param1[6] & 8) > 0;
	@P_FSG_40_0_0_16_1_53 = (param1[6] & 4) > 0;
	@P_FSG_40_0_0_16_1_54 = (param1[6] & 2) > 0;
	@P_FSG_40_0_0_16_1_55 = (param1[6] & 1) > 0;
	@P_FSG_40_0_0_16_1_56 = (param1[7] & 128) > 0;
	@P_FSG_40_0_0_16_1_57 = (param1[7] & 64) > 0;
	@P_FSG_40_0_0_16_1_58 = (param1[7] & 32) > 0;
	@P_FSG_40_0_0_16_1_59 = (param1[7] & 16) > 0;
	@P_FSG_40_0_0_16_1_60 = (param1[7] & 8) > 0;
	@P_FSG_40_0_0_16_1_61 = (param1[7] & 4) > 0;
	@P_FSG_40_0_0_16_1_62 = (param1[7] & 2) > 0;
	@P_FSG_40_0_0_16_1_63 = (param1[7] & 1) > 0;
	for( i = 0; i < 8; i++)
	{
	 superval[currentPos++] = param1[i];
	}
	putValue(P_FSG_40_0_0_16, superval, currentPos);
}


on envVar P_FSG_40_0_0_16_1_17
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[2] = thisval[2]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_18
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[2] = thisval[2]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_19
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[2] = thisval[2]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_20
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[2] = thisval[2]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_21
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[2] = thisval[2]&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_22
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[2] = thisval[2]&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_23
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[2] = thisval[2]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_24
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[3] = thisval[3]&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_25
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[3] = thisval[3]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_26
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[3] = thisval[3]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_27
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[3] = thisval[3]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_28
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[3] = thisval[3]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_29
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[3] = thisval[3]&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_30
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[3] = thisval[3]&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_31
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[3] = thisval[3]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_32
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[4] = thisval[4]&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_33
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[4] = thisval[4]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_34
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[4] = thisval[4]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_35
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[4] = thisval[4]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_36
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[4] = thisval[4]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_37
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[4] = thisval[4]&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_38
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[4] = thisval[4]&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_39
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[4] = thisval[4]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_40
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[5] = thisval[5]&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_41
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[5] = thisval[5]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_42
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[5] = thisval[5]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_43
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[5] = thisval[5]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_44
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[5] = thisval[5]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_45
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[5] = thisval[5]&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_46
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[5] = thisval[5]&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_47
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[5] = thisval[5]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_48
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[6] = thisval[6]&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_49
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[6] = thisval[6]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_50
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[6] = thisval[6]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_51
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[6] = thisval[6]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_52
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[6] = thisval[6]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_53
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[6] = thisval[6]&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_54
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[6] = thisval[6]&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_55
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[6] = thisval[6]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_56
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[7] = thisval[7]&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_57
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[7] = thisval[7]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_58
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[7] = thisval[7]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_59
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[7] = thisval[7]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_60
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[7] = thisval[7]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_61
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[7] = thisval[7]&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_62
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[7] = thisval[7]&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1_63
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[8]; // FctList
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_16_1, thisval);
	thisval[7] = thisval[7]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_16_1,thisval);
}

on envVar P_FSG_40_0_0_16_1 // MobileServiceSupport.FctList
{
	P_FSG_40_0_0_16_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_17_ErrCode
{
       if(gP_FSG_40_0_0_17_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_17", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_17_ErrCode = 1;
}
on envVar P_FSG_40_0_0_17Status_BTN
{
	byte BAPTemp[50];
    if (P_FSG_40_0_0_17Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_40_0_0_17_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_17",MakeRGB(255,255,255));
        P_FSG_40_0_0_17Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_40_0_0_17_BuildFct();
        getValue(P_FSG_40_0_0_17, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_17_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_17));
        if(getValue(P_FSG_40_0_0_17_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_40_0_0_17_ID);
        }
        if(getValue(P_FSG_40_0_0_17_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_40_0_0_17_ID,elCount(BAPTemp));
        }
       P_FSG_40_0_0_17Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_17_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_17_ID;
    data[2]=getValue(P_FSG_40_0_0_17_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_17
on envVar P_FSG_40_0_0_17_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_17",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_17",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_17",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_17", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_17",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_17",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_17",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_17", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_17_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_17_SegmEn,0);
           intertelegram_err(P_FSG_40_0_0_17_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_40_0_0_17_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_17_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_17_IntTlgEn,0);
           sequence_err(P_FSG_40_0_0_17_ID,getValueSize(P_FSG_40_0_0_17_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_40_0_0_17_ID);
       }
}
on envVar P_FSG_40_0_0_17 // bus value of ActiveUser (17).
{
	// opcodes: Error-Status
	byte param1[50]; // UserName
	word len1;
	byte cnt1;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[50];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 50; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_17, superval);
	///////// Start param1 - STRING /////////
	//getValue(P_FSG_40_0_0_17_1, param1);
  getValue(P_FSG_40_0_0_17_1_Hex, param1);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(49>127) /* Max Fct-Katalog Laenge: 49*/
		{
			len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt1 = 1;
		}
		else
		{
			len1 = 49;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_17 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len1 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt1 = 0;
	}
	
	if(len1 > 49)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
		len1 = 49;
	
		if(len1 < 128) cnt1 = 0;
		else cnt1 = 1;
	}
	
	for(i = 0; i < len1; i++)
	{
		param1[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_17_1_len, len1);
	putValue(P_FSG_40_0_0_17_1_cnt, cnt1);
	
  if(len1 > getValueSize(P_FSG_40_0_0_17_1_Hex))
		putValue(P_FSG_40_0_0_17_1_Hex, param1, len1);
	else
		putValue(P_FSG_40_0_0_17_1_Hex, param1, getValueSize(P_FSG_40_0_0_17_1_Hex));
  
	/*if(len1 > getValueSize(P_FSG_40_0_0_17_1))
		putValue(P_FSG_40_0_0_17_1, param1, len1);
	else
		putValue(P_FSG_40_0_0_17_1, param1, getValueSize(P_FSG_40_0_0_17_1));*/

}

// Updates the bus value field and other dependencies.
P_FSG_40_0_0_17_BuildFct()
{
	byte param1[50]; // UserName
	word len1;
	byte cnt1;

	int i;
	byte superval[50];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_17_1, param1);
  getValue(P_FSG_40_0_0_17_1_Hex, param1);
	len1 = getValue(P_FSG_40_0_0_17_1_len);
	cnt1= getValue(P_FSG_40_0_0_17_1_cnt);
	
	/* check box aktiviert*/
	if (cnt1 == 1)
	{
		/* 0 bis 49 (MaxString - 1B oder 2B) */
		if(len1 >= 0 && len1 <= 49)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_17_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 49);
			return;
		}
	}
	else if(cnt1 == 0) /*check box deaktiviert*/
	{
		if(len1 >= 0 && len1 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos]= len1 & 0x00ff;
			putValue(P_FSG_40_0_0_17_1_len, len1);
		}
		else if(len1 > 127 && len1 <= 49)
		{
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
			putValue(P_FSG_40_0_0_17_1_len, len1);
			putValue(P_FSG_40_0_0_17_1_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_17_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 49);
			return;
		}
	}
	currentPos += cnt1+1;
	for(i = 0; i < len1; i++)
	{
		superval[currentPos++]= param1[i];
	}

	putValue(P_FSG_40_0_0_17, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_17_1_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_17_1_len);
	cnt = getValue(P_FSG_40_0_0_17_1_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_17_1_len, 127);
		}
	}

	P_FSG_40_0_0_17_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_17_1_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 49)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_17_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 49);
		putValue(this, 49);
	}
	P_FSG_40_0_0_17_BuildFct();
}


on envVar P_FSG_40_0_0_17_1 // ActiveUser.UserName
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_17_1_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_17_1_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_17_1_len, getValueSize(this));
	P_FSG_40_0_0_17_BuildFct();*/
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_18_ErrCode
{
       if(gP_FSG_40_0_0_18_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_18", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_18_ErrCode = 1;
}
on envVar P_FSG_40_0_0_18Status_BTN
{
	byte BAPTemp[3];
   if (P_FSG_40_0_0_18Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_40_0_0_18_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_18",MakeRGB(255,255,255));
      P_FSG_40_0_0_18Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_40_0_0_18, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_40_0_0_18_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_18));
      P_FSG_40_0_0_18Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_40_0_0_18_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_18_ID;
    data[2]=getValue(P_FSG_40_0_0_18_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_18
on envVar P_FSG_40_0_0_18_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_18",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_18",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_18",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_18", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_18",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_18",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_18",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_18", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_18 // bus value of RegisterState (18).
{
	// opcodes: Error-Status
	byte param1; // RegisterState
	byte param2; // NetworkType
	byte param3; // PacketDataNetworkType
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[3];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_18, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_40_0_0_18_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_40_0_0_18_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_40_0_0_18_3, param3);
}

on envVar P_FSG_40_0_0_18_1 // RegisterState.RegisterState
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // RegisterState
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_40_0_0_18, superval);
	superval[0]=thisval;
	putValue(P_FSG_40_0_0_18,superval);
}

on envVar P_FSG_40_0_0_18_2 // RegisterState.NetworkType
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // NetworkType
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_40_0_0_18, superval);
	superval[1]=thisval;
	putValue(P_FSG_40_0_0_18,superval);
}

on envVar P_FSG_40_0_0_18_3 // RegisterState.PacketDataNetworkType
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // PacketDataNetworkType
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_40_0_0_18, superval);
	superval[2]=thisval;
	putValue(P_FSG_40_0_0_18,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_19_ErrCode
{
       if(gP_FSG_40_0_0_19_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_19", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_19_ErrCode = 1;
}
on envVar P_FSG_40_0_0_19Status_BTN
{
    if (P_FSG_40_0_0_19Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_40_0_0_19_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_19",MakeRGB(255,255,255));
       P_FSG_40_0_0_19Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_40_0_0_19_ID, Data_REQ, getValue(P_FSG_40_0_0_19));
      P_FSG_40_0_0_19Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_19_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_19_ID;
    data[2]=getValue(P_FSG_40_0_0_19_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_19
on envVar P_FSG_40_0_0_19_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_19",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_19",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_19",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_19", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_19",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_19",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_19",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_19", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_19 // bus value of LockState (19).
{
	// opcodes: Error-Status
	byte param1; // LockState
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_40_0_0_19);
	putValue(P_FSG_40_0_0_19_1, param1);
}

on envVar P_FSG_40_0_0_19_1 // LockState.LockState
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // LockState
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_40_0_0_19);
	superval = thisval;
	putValue(P_FSG_40_0_0_19,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_20_ErrCode
{
       if(gP_FSG_40_0_0_20_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_20", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_20_ErrCode = 1;
}
on envVar P_FSG_40_0_0_20Status_BTN
{
	byte BAPTemp[82];
    if (P_FSG_40_0_0_20Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_40_0_0_20_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_20",MakeRGB(255,255,255));
        P_FSG_40_0_0_20Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_40_0_0_20_BuildFct();
        getValue(P_FSG_40_0_0_20, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_20_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_20));
        if(getValue(P_FSG_40_0_0_20_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_40_0_0_20_ID);
        }
        if(getValue(P_FSG_40_0_0_20_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_40_0_0_20_ID,elCount(BAPTemp));
        }
       P_FSG_40_0_0_20Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_20_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_20_ID;
    data[2]=getValue(P_FSG_40_0_0_20_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_20
on envVar P_FSG_40_0_0_20_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_20",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_20",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_20",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_20", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_20",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_20",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_20",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_20", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_20_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_20_SegmEn,0);
           intertelegram_err(P_FSG_40_0_0_20_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_40_0_0_20_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_20_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_20_IntTlgEn,0);
           sequence_err(P_FSG_40_0_0_20_ID,getValueSize(P_FSG_40_0_0_20_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_40_0_0_20_ID);
       }
}
on envVar P_FSG_40_0_0_20 // bus value of NetworkProvider (20).
{
	// opcodes: Error-Status
	byte param1; // NetworkProviderState
	byte param2[40]; // NetworkProviderName
	word len2;
	byte cnt2;
	byte param3; // ServiceProviderState
	byte param4[40]; // ServiceProviderName
	word len4;
	byte cnt4;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[82];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 82; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_20, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_40_0_0_20_1, param1);
	///////// Start param2 - STRING /////////
	//getValue(P_FSG_40_0_0_20_2, param2);
  getValue(P_FSG_40_0_0_20_2_Hex, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(39>127) /* Max Fct-Katalog Laenge: 39*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 39;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_20 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 39)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 39;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_20_2_len, len2);
	putValue(P_FSG_40_0_0_20_2_cnt, cnt2);
	
	if(len2 > getValueSize(P_FSG_40_0_0_20_2))
		putValue(P_FSG_40_0_0_20_2, param2, len2);
	else
		putValue(P_FSG_40_0_0_20_2, param2, getValueSize(P_FSG_40_0_0_20_2));

	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_40_0_0_20_3, param3);
	///////// Start param4 - STRING /////////
	//getValue(P_FSG_40_0_0_20_4, param4);
  getValue(P_FSG_40_0_0_20_4_Hex, param4);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(39>127) /* Max Fct-Katalog Laenge: 39*/
		{
			len4 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt4 = 1;
		}
		else
		{
			len4 = 39;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_20 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len4 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt4 = 0;
	}
	
	if(len4 > 39)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len4, currentPos);
		len4 = 39;
	
		if(len4 < 128) cnt4 = 0;
		else cnt4 = 1;
	}
	
	for(i = 0; i < len4; i++)
	{
		param4[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_20_4_len, len4);
	putValue(P_FSG_40_0_0_20_4_cnt, cnt4);
	
  if(len4 > getValueSize(P_FSG_40_0_0_20_4_Hex))
		putValue(P_FSG_40_0_0_20_4_Hex, param4, len4);
	else
		putValue(P_FSG_40_0_0_20_4_Hex, param4, getValueSize(P_FSG_40_0_0_20_4_Hex));
  
	/*if(len4 > getValueSize(P_FSG_40_0_0_20_4))
		putValue(P_FSG_40_0_0_20_4, param4, len4);
	else
		putValue(P_FSG_40_0_0_20_4, param4, getValueSize(P_FSG_40_0_0_20_4));*/

}

// Updates the bus value field and other dependencies.
P_FSG_40_0_0_20_BuildFct()
{
	byte param1; // NetworkProviderState
	byte param2[40]; // NetworkProviderName
	word len2;
	byte cnt2;
	byte param3; // ServiceProviderState
	byte param4[40]; // ServiceProviderName
	word len4;
	byte cnt4;

	int i;
	byte superval[82];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_FSG_40_0_0_20_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_20_2, param2);
  getValue(P_FSG_40_0_0_20_2_Hex, param2);
	len2 = getValue(P_FSG_40_0_0_20_2_len);
	cnt2= getValue(P_FSG_40_0_0_20_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 39 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 39)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_20_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 39);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(P_FSG_40_0_0_20_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 39)
		{
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(P_FSG_40_0_0_20_2_len, len2);
			putValue(P_FSG_40_0_0_20_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_20_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 39);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_40_0_0_20_3);
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_20_4, param4);
  getValue(P_FSG_40_0_0_20_4_Hex, param4);
	len4 = getValue(P_FSG_40_0_0_20_4_len);
	cnt4= getValue(P_FSG_40_0_0_20_4_cnt);
	
	/* check box aktiviert*/
	if (cnt4 == 1)
	{
		/* 0 bis 39 (MaxString - 1B oder 2B) */
		if(len4 >= 0 && len4 <= 39)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
			superval[currentPos] = (len4&0x7f00) | 0x80;
			superval[currentPos+1] = len4 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_20_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 39);
			return;
		}
	}
	else if(cnt4 == 0) /*check box deaktiviert*/
	{
		if(len4 >= 0 && len4 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
			superval[currentPos]= len4 & 0x00ff;
			putValue(P_FSG_40_0_0_20_4_len, len4);
		}
		else if(len4 > 127 && len4 <= 39)
		{
			superval[currentPos] = (len4&0x7f00) | 0x80;
			superval[currentPos+1] = len4 & 0x00ff;
			putValue(P_FSG_40_0_0_20_4_len, len4);
			putValue(P_FSG_40_0_0_20_4_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_20_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 39);
			return;
		}
	}
	currentPos += cnt4+1;
	for(i = 0; i < len4; i++)
	{
		superval[currentPos++]= param4[i];
	}

	putValue(P_FSG_40_0_0_20, superval, currentPos);
}


on envVar P_FSG_40_0_0_20_1 // NetworkProvider.NetworkProviderState
{
	P_FSG_40_0_0_20_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_20_2_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_20_2_len);
	cnt = getValue(P_FSG_40_0_0_20_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_20_2_len, 127);
		}
	}

	P_FSG_40_0_0_20_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_20_2_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 39)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_20_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 39);
		putValue(this, 39);
	}
	P_FSG_40_0_0_20_BuildFct();
}


on envVar P_FSG_40_0_0_20_2 // NetworkProvider.NetworkProviderName
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_20_2_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_20_2_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_20_2_len, getValueSize(this));
	P_FSG_40_0_0_20_BuildFct();*/
}

on envVar P_FSG_40_0_0_20_3 // NetworkProvider.ServiceProviderState
{
	P_FSG_40_0_0_20_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_20_4_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_20_4_len);
	cnt = getValue(P_FSG_40_0_0_20_4_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_20_4_len, 127);
		}
	}

	P_FSG_40_0_0_20_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_20_4_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 39)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_20_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 39);
		putValue(this, 39);
	}
	P_FSG_40_0_0_20_BuildFct();
}


on envVar P_FSG_40_0_0_20_4 // NetworkProvider.ServiceProviderName
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_20_4_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_20_4_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_20_4_len, getValueSize(this));
	P_FSG_40_0_0_20_BuildFct();*/
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_21_ErrCode
{
       if(gP_FSG_40_0_0_21_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_21", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_21_ErrCode = 1;
}
on envVar P_FSG_40_0_0_21Status_BTN
{
    if (P_FSG_40_0_0_21Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_40_0_0_21_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_21",MakeRGB(255,255,255));
       P_FSG_40_0_0_21Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_40_0_0_21_ID, Data_REQ, getValue(P_FSG_40_0_0_21));
      P_FSG_40_0_0_21Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_21_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_21_ID;
    data[2]=getValue(P_FSG_40_0_0_21_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_21
on envVar P_FSG_40_0_0_21_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_21",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_21",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_21",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_21", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_21",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_21",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_21",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_21", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_21 // bus value of SignalQuality (21).
{
	// opcodes: Error-Status
	byte param1; // Quality
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_40_0_0_21);
	putValue(P_FSG_40_0_0_21_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_21_1_range // SignalQuality.Quality 
{
	@P_FSG_40_0_0_21_1 = @P_FSG_40_0_0_21_1_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_21_1 // SignalQuality.Quality
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Quality
	float slider_value;

	slider_value = round(@P_FSG_40_0_0_21_1, 1.0);
	@P_FSG_40_0_0_21_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(P_FSG_40_0_0_21);
	superval = thisval;
	putValue(P_FSG_40_0_0_21,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_22_ErrCode
{
       if(gP_FSG_40_0_0_22_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_22", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_22_ErrCode = 1;
}
on envVar P_FSG_40_0_0_22Status_BTN
{
	byte BAPTemp[16];
    if (P_FSG_40_0_0_22Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_40_0_0_22_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_22",MakeRGB(255,255,255));
        P_FSG_40_0_0_22Status_BTN_already_pressed = 1;
    }
    else
    {
	updateCallState();
    updateCallType();
		P_FSG_40_0_0_22_BuildFct();
        getValue(P_FSG_40_0_0_22, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_22));
        if(getValue(P_FSG_40_0_0_22_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_40_0_0_22_ID);
        }
        if(getValue(P_FSG_40_0_0_22_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_40_0_0_22_ID,elCount(BAPTemp));
        }
       P_FSG_40_0_0_22Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_22_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_22_ID;
    data[2]=getValue(P_FSG_40_0_0_22_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_22
on envVar P_FSG_40_0_0_22_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_22",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_22",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_22",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_22", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_22",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_22",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_22",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_22", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_22_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_22_SegmEn,0);
           intertelegram_err(P_FSG_40_0_0_22_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_40_0_0_22_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_22_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_22_IntTlgEn,0);
           sequence_err(P_FSG_40_0_0_22_ID,getValueSize(P_FSG_40_0_0_22_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_40_0_0_22_ID);
       }
}
on envVar P_FSG_40_0_0_22 // bus value of CallState (22).
{
	// opcodes: Error-Status
	byte param1; // CallState0
	byte param2; // CallType0
	byte param3; // CallOptions0
	byte param4; // CallState1
	byte param5; // CallType1
	byte param6; // CallOptions1
	byte param7; // CallState2
	byte param8; // CallType2
	byte param9; // CallOptions2
	byte param10; // CallState3
	byte param11; // CallType3
	byte param12; // CallOptions3
	byte param13; // CallState4
	byte param14; // CallType4
	byte param15; // CallOptions4
	byte param16; // CallState5
	byte param17; // CallType5
	byte param18; // CallOptions5
	byte param19; // CallState6
	byte param20; // CallType6
	byte param21; // CallOptions6
	byte param22; // CallIncomingDiverted
	byte param23; // CallOutgoingDiverted_eCallConfirmationPending
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[16];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 16; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_22, superval);
	///////// Start param1 - NIBBLE /////////
	param1 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_40_0_0_22_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_40_0_0_22_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_40_0_0_22_3, param3);
	///////// Start param4 - NIBBLE /////////
	param4 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_40_0_0_22_4, param4);
	///////// Start param5 - NIBBLE /////////
	param5 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_40_0_0_22_5, param5);
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_40_0_0_22_6, param6);
	///////// Start param7 - NIBBLE /////////
	param7 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_40_0_0_22_7, param7);
	///////// Start param8 - NIBBLE /////////
	param8 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_40_0_0_22_8, param8);
	///////// Start param9 - UINT8 /////////
	param9 = superval[currentPos++];
	putValue(P_FSG_40_0_0_22_9, param9);
	///////// Start param10 - NIBBLE /////////
	param10 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_40_0_0_22_10, param10);
	///////// Start param11 - NIBBLE /////////
	param11 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_40_0_0_22_11, param11);
	///////// Start param12 - UINT8 /////////
	param12 = superval[currentPos++];
	putValue(P_FSG_40_0_0_22_12, param12);
	///////// Start param13 - NIBBLE /////////
	param13 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_40_0_0_22_13, param13);
	///////// Start param14 - NIBBLE /////////
	param14 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_40_0_0_22_14, param14);
	///////// Start param15 - UINT8 /////////
	param15 = superval[currentPos++];
	putValue(P_FSG_40_0_0_22_15, param15);
	///////// Start param16 - NIBBLE /////////
	param16 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_40_0_0_22_16, param16);
	///////// Start param17 - NIBBLE /////////
	param17 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_40_0_0_22_17, param17);
	///////// Start param18 - UINT8 /////////
	param18 = superval[currentPos++];
	putValue(P_FSG_40_0_0_22_18, param18);
	///////// Start param19 - NIBBLE /////////
	param19 = (superval[currentPos] & 0xf0)>>4;
	putValue(P_FSG_40_0_0_22_19, param19);
	///////// Start param20 - NIBBLE /////////
	param20 = superval[currentPos++] & 0x0f;
	putValue(P_FSG_40_0_0_22_20, param20);
	///////// Start param21 - UINT8 /////////
	param21 = superval[currentPos++];
	putValue(P_FSG_40_0_0_22_21, param21);
	///////// Start param22 - UINT8 /////////
	param22 = superval[currentPos++];
	putValue(P_FSG_40_0_0_22_22, param22);
	///////// Start param23 - UINT8 /////////
	param23 = superval[currentPos++];
	putValue(P_FSG_40_0_0_22_23, param23);
}

// Updates the bus value field and other dependencies.
P_FSG_40_0_0_22_BuildFct()
{
	byte param1; // CallState0
	byte param2; // CallType0
	byte param3; // CallOptions0
	byte param4; // CallState1
	byte param5; // CallType1
	byte param6; // CallOptions1
	byte param7; // CallState2
	byte param8; // CallType2
	byte param9; // CallOptions2
	byte param10; // CallState3
	byte param11; // CallType3
	byte param12; // CallOptions3
	byte param13; // CallState4
	byte param14; // CallType4
	byte param15; // CallOptions4
	byte param16; // CallState5
	byte param17; // CallType5
	byte param18; // CallOptions5
	byte param19; // CallState6
	byte param20; // CallType6
	byte param21; // CallOptions6
	byte param22; // CallIncomingDiverted
	byte param23; // CallOutgoingDiverted_eCallConfirmationPending

	int i;
	byte superval[16];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_FSG_40_0_0_22_1);
	param1 = param1 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param1<<4);
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_40_0_0_22_2);
	param2 = param2 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param2;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_40_0_0_22_3);
	@P_FSG_40_0_0_22_3_0 = (param3 & 1) > 0;
	@P_FSG_40_0_0_22_3_1 = (param3 & 2) > 0;
	@P_FSG_40_0_0_22_3_2 = (param3 & 4) > 0;
	@P_FSG_40_0_0_22_3_3 = (param3 & 8) > 0;
	@P_FSG_40_0_0_22_3_4 = (param3 & 16) > 0;
	@P_FSG_40_0_0_22_3_5 = (param3 & 32) > 0;
	@P_FSG_40_0_0_22_3_6 = (param3 & 64) > 0;
	@P_FSG_40_0_0_22_3_7 = (param3 & 128) > 0;
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_40_0_0_22_4);
	param4 = param4 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param4<<4);
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_FSG_40_0_0_22_5);
	param5 = param5 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param5;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param6 = getValue(P_FSG_40_0_0_22_6);
	@P_FSG_40_0_0_22_6_0 = (param6 & 1) > 0;
	@P_FSG_40_0_0_22_6_1 = (param6 & 2) > 0;
	@P_FSG_40_0_0_22_6_2 = (param6 & 4) > 0;
	@P_FSG_40_0_0_22_6_3 = (param6 & 8) > 0;
	@P_FSG_40_0_0_22_6_4 = (param6 & 16) > 0;
	@P_FSG_40_0_0_22_6_5 = (param6 & 32) > 0;
	@P_FSG_40_0_0_22_6_6 = (param6 & 64) > 0;
	@P_FSG_40_0_0_22_6_7 = (param6 & 128) > 0;
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_FSG_40_0_0_22_7);
	param7 = param7 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param7<<4);
// gen_BuildFunc_SetSuperVals 
	param8 = getValue(P_FSG_40_0_0_22_8);
	param8 = param8 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param8;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param9 = getValue(P_FSG_40_0_0_22_9);
	@P_FSG_40_0_0_22_9_0 = (param9 & 1) > 0;
	@P_FSG_40_0_0_22_9_1 = (param9 & 2) > 0;
	@P_FSG_40_0_0_22_9_2 = (param9 & 4) > 0;
	@P_FSG_40_0_0_22_9_3 = (param9 & 8) > 0;
	@P_FSG_40_0_0_22_9_4 = (param9 & 16) > 0;
	@P_FSG_40_0_0_22_9_5 = (param9 & 32) > 0;
	@P_FSG_40_0_0_22_9_6 = (param9 & 64) > 0;
	@P_FSG_40_0_0_22_9_7 = (param9 & 128) > 0;
	superval[currentPos++]=param9;
// gen_BuildFunc_SetSuperVals 
	param10 = getValue(P_FSG_40_0_0_22_10);
	param10 = param10 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param10<<4);
// gen_BuildFunc_SetSuperVals 
	param11 = getValue(P_FSG_40_0_0_22_11);
	param11 = param11 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param11;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param12 = getValue(P_FSG_40_0_0_22_12);
	@P_FSG_40_0_0_22_12_0 = (param12 & 1) > 0;
	@P_FSG_40_0_0_22_12_1 = (param12 & 2) > 0;
	@P_FSG_40_0_0_22_12_2 = (param12 & 4) > 0;
	@P_FSG_40_0_0_22_12_3 = (param12 & 8) > 0;
	@P_FSG_40_0_0_22_12_4 = (param12 & 16) > 0;
	@P_FSG_40_0_0_22_12_5 = (param12 & 32) > 0;
	@P_FSG_40_0_0_22_12_6 = (param12 & 64) > 0;
	@P_FSG_40_0_0_22_12_7 = (param12 & 128) > 0;
	superval[currentPos++]=param12;
// gen_BuildFunc_SetSuperVals 
	param13 = getValue(P_FSG_40_0_0_22_13);
	param13 = param13 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param13<<4);
// gen_BuildFunc_SetSuperVals 
	param14 = getValue(P_FSG_40_0_0_22_14);
	param14 = param14 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param14;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param15 = getValue(P_FSG_40_0_0_22_15);
	@P_FSG_40_0_0_22_15_0 = (param15 & 1) > 0;
	@P_FSG_40_0_0_22_15_1 = (param15 & 2) > 0;
	@P_FSG_40_0_0_22_15_2 = (param15 & 4) > 0;
	@P_FSG_40_0_0_22_15_3 = (param15 & 8) > 0;
	@P_FSG_40_0_0_22_15_4 = (param15 & 16) > 0;
	@P_FSG_40_0_0_22_15_5 = (param15 & 32) > 0;
	@P_FSG_40_0_0_22_15_6 = (param15 & 64) > 0;
	@P_FSG_40_0_0_22_15_7 = (param15 & 128) > 0;
	superval[currentPos++]=param15;
// gen_BuildFunc_SetSuperVals 
	param16 = getValue(P_FSG_40_0_0_22_16);
	param16 = param16 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param16<<4);
// gen_BuildFunc_SetSuperVals 
	param17 = getValue(P_FSG_40_0_0_22_17);
	param17 = param17 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param17;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param18 = getValue(P_FSG_40_0_0_22_18);
	@P_FSG_40_0_0_22_18_0 = (param18 & 1) > 0;
	@P_FSG_40_0_0_22_18_1 = (param18 & 2) > 0;
	@P_FSG_40_0_0_22_18_2 = (param18 & 4) > 0;
	@P_FSG_40_0_0_22_18_3 = (param18 & 8) > 0;
	@P_FSG_40_0_0_22_18_4 = (param18 & 16) > 0;
	@P_FSG_40_0_0_22_18_5 = (param18 & 32) > 0;
	@P_FSG_40_0_0_22_18_6 = (param18 & 64) > 0;
	@P_FSG_40_0_0_22_18_7 = (param18 & 128) > 0;
	superval[currentPos++]=param18;
// gen_BuildFunc_SetSuperVals 
	param19 = getValue(P_FSG_40_0_0_22_19);
	param19 = param19 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param19<<4);
// gen_BuildFunc_SetSuperVals 
	param20 = getValue(P_FSG_40_0_0_22_20);
	param20 = param20 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param20;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param21 = getValue(P_FSG_40_0_0_22_21);
	@P_FSG_40_0_0_22_21_0 = (param21 & 1) > 0;
	@P_FSG_40_0_0_22_21_1 = (param21 & 2) > 0;
	@P_FSG_40_0_0_22_21_2 = (param21 & 4) > 0;
	@P_FSG_40_0_0_22_21_3 = (param21 & 8) > 0;
	@P_FSG_40_0_0_22_21_4 = (param21 & 16) > 0;
	@P_FSG_40_0_0_22_21_5 = (param21 & 32) > 0;
	@P_FSG_40_0_0_22_21_6 = (param21 & 64) > 0;
	@P_FSG_40_0_0_22_21_7 = (param21 & 128) > 0;
	superval[currentPos++]=param21;
// gen_BuildFunc_SetSuperVals 
	param22 = getValue(P_FSG_40_0_0_22_22);
	@P_FSG_40_0_0_22_22_0 = (param22 & 1) > 0;
	@P_FSG_40_0_0_22_22_1 = (param22 & 2) > 0;
	@P_FSG_40_0_0_22_22_2 = (param22 & 4) > 0;
	@P_FSG_40_0_0_22_22_3 = (param22 & 8) > 0;
	@P_FSG_40_0_0_22_22_4 = (param22 & 16) > 0;
	@P_FSG_40_0_0_22_22_5 = (param22 & 32) > 0;
	@P_FSG_40_0_0_22_22_6 = (param22 & 64) > 0;
	superval[currentPos++]=param22;
// gen_BuildFunc_SetSuperVals 
	param23 = getValue(P_FSG_40_0_0_22_23);
	@P_FSG_40_0_0_22_23_0 = (param23 & 1) > 0;
	@P_FSG_40_0_0_22_23_1 = (param23 & 2) > 0;
	@P_FSG_40_0_0_22_23_2 = (param23 & 4) > 0;
	@P_FSG_40_0_0_22_23_3 = (param23 & 8) > 0;
	@P_FSG_40_0_0_22_23_4 = (param23 & 16) > 0;
	@P_FSG_40_0_0_22_23_5 = (param23 & 32) > 0;
	@P_FSG_40_0_0_22_23_6 = (param23 & 64) > 0;
	@P_FSG_40_0_0_22_23_7 = (param23 & 128) > 0;
	superval[currentPos++]=param23;
	putValue(P_FSG_40_0_0_22, superval, currentPos);
}


on envVar P_FSG_40_0_0_22_1 // CallState.CallState0
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_2 // CallState.CallType0
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions0
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_22_3,thisval);
}

on envVar P_FSG_40_0_0_22_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions0
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_3);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_22_3,thisval);
}

on envVar P_FSG_40_0_0_22_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions0
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_22_3,thisval);
}

on envVar P_FSG_40_0_0_22_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions0
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_3);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_22_3,thisval);
}

on envVar P_FSG_40_0_0_22_3_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions0
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_22_3,thisval);
}

on envVar P_FSG_40_0_0_22_3_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions0
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_3);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_22_3,thisval);
}

on envVar P_FSG_40_0_0_22_3_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions0
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_3);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_22_3,thisval);
}

on envVar P_FSG_40_0_0_22_3_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions0
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_3);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_22_3,thisval);
}

on envVar P_FSG_40_0_0_22_3 // CallState.CallOptions0
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_4 // CallState.CallState1
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_5 // CallState.CallType1
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_6_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions1
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_6);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_22_6,thisval);
}

on envVar P_FSG_40_0_0_22_6_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions1
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_6);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_22_6,thisval);
}

on envVar P_FSG_40_0_0_22_6_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions1
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_6);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_22_6,thisval);
}

on envVar P_FSG_40_0_0_22_6_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions1
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_6);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_22_6,thisval);
}

on envVar P_FSG_40_0_0_22_6_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions1
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_6);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_22_6,thisval);
}

on envVar P_FSG_40_0_0_22_6_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions1
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_6);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_22_6,thisval);
}

on envVar P_FSG_40_0_0_22_6_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions1
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_6);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_22_6,thisval);
}

on envVar P_FSG_40_0_0_22_6_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions1
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_6);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_22_6,thisval);
}

on envVar P_FSG_40_0_0_22_6 // CallState.CallOptions1
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_7 // CallState.CallState2
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_8 // CallState.CallType2
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_9_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_9);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_22_9,thisval);
}

on envVar P_FSG_40_0_0_22_9_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_9);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_22_9,thisval);
}

on envVar P_FSG_40_0_0_22_9_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_9);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_22_9,thisval);
}

on envVar P_FSG_40_0_0_22_9_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_9);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_22_9,thisval);
}

on envVar P_FSG_40_0_0_22_9_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_9);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_22_9,thisval);
}

on envVar P_FSG_40_0_0_22_9_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_9);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_22_9,thisval);
}

on envVar P_FSG_40_0_0_22_9_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_9);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_22_9,thisval);
}

on envVar P_FSG_40_0_0_22_9_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_9);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_22_9,thisval);
}

on envVar P_FSG_40_0_0_22_9 // CallState.CallOptions2
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_10 // CallState.CallState3
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_11 // CallState.CallType3
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_12_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_12);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_22_12,thisval);
}

on envVar P_FSG_40_0_0_22_12_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_12);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_22_12,thisval);
}

on envVar P_FSG_40_0_0_22_12_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_12);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_22_12,thisval);
}

on envVar P_FSG_40_0_0_22_12_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_12);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_22_12,thisval);
}

on envVar P_FSG_40_0_0_22_12_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_12);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_22_12,thisval);
}

on envVar P_FSG_40_0_0_22_12_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_12);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_22_12,thisval);
}

on envVar P_FSG_40_0_0_22_12_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_12);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_22_12,thisval);
}

on envVar P_FSG_40_0_0_22_12_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_12);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_22_12,thisval);
}

on envVar P_FSG_40_0_0_22_12 // CallState.CallOptions3
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_13 // CallState.CallState4
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_14 // CallState.CallType4
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_15_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions4
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_15);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_22_15,thisval);
}

on envVar P_FSG_40_0_0_22_15_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions4
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_15);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_22_15,thisval);
}

on envVar P_FSG_40_0_0_22_15_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions4
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_15);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_22_15,thisval);
}

on envVar P_FSG_40_0_0_22_15_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions4
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_15);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_22_15,thisval);
}

on envVar P_FSG_40_0_0_22_15_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions4
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_15);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_22_15,thisval);
}

on envVar P_FSG_40_0_0_22_15_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions4
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_15);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_22_15,thisval);
}

on envVar P_FSG_40_0_0_22_15_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions4
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_15);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_22_15,thisval);
}

on envVar P_FSG_40_0_0_22_15_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions4
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_15);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_22_15,thisval);
}

on envVar P_FSG_40_0_0_22_15 // CallState.CallOptions4
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_16 // CallState.CallState5
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_17 // CallState.CallType5
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_18_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions5
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_18);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_22_18,thisval);
}

on envVar P_FSG_40_0_0_22_18_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions5
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_18);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_22_18,thisval);
}

on envVar P_FSG_40_0_0_22_18_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions5
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_18);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_22_18,thisval);
}

on envVar P_FSG_40_0_0_22_18_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions5
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_18);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_22_18,thisval);
}

on envVar P_FSG_40_0_0_22_18_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions5
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_18);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_22_18,thisval);
}

on envVar P_FSG_40_0_0_22_18_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions5
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_18);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_22_18,thisval);
}

on envVar P_FSG_40_0_0_22_18_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions5
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_18);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_22_18,thisval);
}

on envVar P_FSG_40_0_0_22_18_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions5
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_18);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_22_18,thisval);
}

on envVar P_FSG_40_0_0_22_18 // CallState.CallOptions5
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_19 // CallState.CallState6
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_20 // CallState.CallType6
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_21_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions6
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_21);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_22_21,thisval);
}

on envVar P_FSG_40_0_0_22_21_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions6
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_21);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_22_21,thisval);
}

on envVar P_FSG_40_0_0_22_21_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions6
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_21);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_22_21,thisval);
}

on envVar P_FSG_40_0_0_22_21_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions6
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_21);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_22_21,thisval);
}

on envVar P_FSG_40_0_0_22_21_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions6
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_21);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_22_21,thisval);
}

on envVar P_FSG_40_0_0_22_21_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions6
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_21);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_22_21,thisval);
}

on envVar P_FSG_40_0_0_22_21_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions6
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_21);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_22_21,thisval);
}

on envVar P_FSG_40_0_0_22_21_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions6
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_21);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_22_21,thisval);
}

on envVar P_FSG_40_0_0_22_21 // CallState.CallOptions6
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_22_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallIncomingDiverted
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_22);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_22_22,thisval);
}

on envVar P_FSG_40_0_0_22_22_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallIncomingDiverted
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_22);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_22_22,thisval);
}

on envVar P_FSG_40_0_0_22_22_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallIncomingDiverted
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_22);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_22_22,thisval);
}

on envVar P_FSG_40_0_0_22_22_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallIncomingDiverted
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_22);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_22_22,thisval);
}

on envVar P_FSG_40_0_0_22_22_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallIncomingDiverted
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_22);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_22_22,thisval);
}

on envVar P_FSG_40_0_0_22_22_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallIncomingDiverted
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_22);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_22_22,thisval);
}

on envVar P_FSG_40_0_0_22_22_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallIncomingDiverted
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_22);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_22_22,thisval);
}

on envVar P_FSG_40_0_0_22_22 // CallState.CallIncomingDiverted
{
	P_FSG_40_0_0_22_BuildFct();
}

on envVar P_FSG_40_0_0_22_23_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOutgoingDiverted_eCallConfirmationPending
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_23);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_22_23,thisval);
}

on envVar P_FSG_40_0_0_22_23_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOutgoingDiverted_eCallConfirmationPending
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_23);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_22_23,thisval);
}

on envVar P_FSG_40_0_0_22_23_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOutgoingDiverted_eCallConfirmationPending
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_23);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_22_23,thisval);
}

on envVar P_FSG_40_0_0_22_23_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOutgoingDiverted_eCallConfirmationPending
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_23);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_22_23,thisval);
}

on envVar P_FSG_40_0_0_22_23_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOutgoingDiverted_eCallConfirmationPending
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_23);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_22_23,thisval);
}

on envVar P_FSG_40_0_0_22_23_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOutgoingDiverted_eCallConfirmationPending
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_23);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_22_23,thisval);
}

on envVar P_FSG_40_0_0_22_23_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOutgoingDiverted_eCallConfirmationPending
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_23);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_22_23,thisval);
}

on envVar P_FSG_40_0_0_22_23_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOutgoingDiverted_eCallConfirmationPending
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_22_23);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_22_23,thisval);
}

on envVar P_FSG_40_0_0_22_23 // CallState.CallOutgoingDiverted_eCallConfirmationPending
{
	P_FSG_40_0_0_22_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_23_ErrCode
{
       if(gP_FSG_40_0_0_23_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_23", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_23_ErrCode = 1;
}
on envVar P_FSG_40_0_0_23Status_BTN
{
	byte BAPTemp[994];
    if (P_FSG_40_0_0_23Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_40_0_0_23_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_23",MakeRGB(255,255,255));
        P_FSG_40_0_0_23Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_40_0_0_23_BuildFct();
        getValue(P_FSG_40_0_0_23, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_23_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_23));
        if(getValue(P_FSG_40_0_0_23_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_40_0_0_23_ID);
        }
        if(getValue(P_FSG_40_0_0_23_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_40_0_0_23_ID,elCount(BAPTemp));
        }
       P_FSG_40_0_0_23Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_23_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_23_ID;
    data[2]=getValue(P_FSG_40_0_0_23_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_23
on envVar P_FSG_40_0_0_23_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_23",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_23",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_23",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_23", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_23",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_23",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_23",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_23", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_23_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_23_SegmEn,0);
           intertelegram_err(P_FSG_40_0_0_23_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_40_0_0_23_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_23_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_23_IntTlgEn,0);
           sequence_err(P_FSG_40_0_0_23_ID,getValueSize(P_FSG_40_0_0_23_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_40_0_0_23_ID);
       }
}
on envVar P_FSG_40_0_0_23 // bus value of CallInfo (23).
{
	// opcodes: Error-Status
	byte param1[100]; // PbName0
	word len1;
	byte cnt1;
	byte param2[41]; // TelNumber0
	word len2;
	byte cnt2;
	byte param3; // Category0
	byte param4[100]; // PbName1
	word len4;
	byte cnt4;
	byte param5[41]; // TelNumber1
	word len5;
	byte cnt5;
	byte param6; // Category1
	byte param7[100]; // PbName2
	word len7;
	byte cnt7;
	byte param8[41]; // TelNumber2
	word len8;
	byte cnt8;
	byte param9; // Category2
	byte param10[100]; // PbName3
	word len10;
	byte cnt10;
	byte param11[41]; // TelNumber3
	word len11;
	byte cnt11;
	byte param12; // Category3
	byte param13[100]; // PbName4
	word len13;
	byte cnt13;
	byte param14[41]; // TelNumber4
	word len14;
	byte cnt14;
	byte param15; // Category4
	byte param16[100]; // PbName5
	word len16;
	byte cnt16;
	byte param17[41]; // TelNumber5
	word len17;
	byte cnt17;
	byte param18; // Category5
	byte param19[100]; // PbName6
	word len19;
	byte cnt19;
	byte param20[41]; // TelNumber6
	word len20;
	byte cnt20;
	byte param21; // Category6
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[994];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 994; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_23, superval);
	///////// Start param1 - STRING /////////
	//getValue(P_FSG_40_0_0_23_1, param1);
  getValue(P_FSG_40_0_0_23_1_Hex, param1);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(99>127) /* Max Fct-Katalog Laenge: 99*/
		{
			len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt1 = 1;
		}
		else
		{
			len1 = 99;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len1 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt1 = 0;
	}
	
	if(len1 > 99)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
		len1 = 99;
	
		if(len1 < 128) cnt1 = 0;
		else cnt1 = 1;
	}
	
	for(i = 0; i < len1; i++)
	{
		param1[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_1_len, len1);
	putValue(P_FSG_40_0_0_23_1_cnt, cnt1);
	
  if(len1 > getValueSize(P_FSG_40_0_0_23_1_Hex))
		putValue(P_FSG_40_0_0_23_1_Hex, param1, len1);
	else
		putValue(P_FSG_40_0_0_23_1_Hex, param1, getValueSize(P_FSG_40_0_0_23_1_Hex));
  
	/*if(len1 > getValueSize(P_FSG_40_0_0_23_1))
		putValue(P_FSG_40_0_0_23_1, param1, len1);
	else
		putValue(P_FSG_40_0_0_23_1, param1, getValueSize(P_FSG_40_0_0_23_1));*/

	///////// Start param2 - STRING /////////
	//getValue(P_FSG_40_0_0_23_2, param2);
  getValue(P_FSG_40_0_0_23_2, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(40>127) /* Max Fct-Katalog Laenge: 40*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 40;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 40)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 40;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_2_len, len2);
	putValue(P_FSG_40_0_0_23_2_cnt, cnt2);
	
  if(len2 > getValueSize(P_FSG_40_0_0_23_2_Hex))
		putValue(P_FSG_40_0_0_23_2_Hex, param2, len2);
	else
		putValue(P_FSG_40_0_0_23_2_Hex, param2, getValueSize(P_FSG_40_0_0_23_2_Hex));
  
	/*if(len2 > getValueSize(P_FSG_40_0_0_23_2))
		putValue(P_FSG_40_0_0_23_2, param2, len2);
	else
		putValue(P_FSG_40_0_0_23_2, param2, getValueSize(P_FSG_40_0_0_23_2));*/

	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_40_0_0_23_3, param3);
	///////// Start param4 - STRING /////////
	//getValue(P_FSG_40_0_0_23_4, param4);
  getValue(P_FSG_40_0_0_23_4, param4);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(99>127) /* Max Fct-Katalog Laenge: 99*/
		{
			len4 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt4 = 1;
		}
		else
		{
			len4 = 99;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len4 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt4 = 0;
	}
	
	if(len4 > 99)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len4, currentPos);
		len4 = 99;
	
		if(len4 < 128) cnt4 = 0;
		else cnt4 = 1;
	}
	
	for(i = 0; i < len4; i++)
	{
		param4[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_4_len, len4);
	putValue(P_FSG_40_0_0_23_4_cnt, cnt4);
	
  if(len4 > getValueSize(P_FSG_40_0_0_23_4_Hex))
		putValue(P_FSG_40_0_0_23_4_Hex, param4, len4);
	else
		putValue(P_FSG_40_0_0_23_4_Hex, param4, getValueSize(P_FSG_40_0_0_23_4_Hex));
  
	/*if(len4 > getValueSize(P_FSG_40_0_0_23_4))
		putValue(P_FSG_40_0_0_23_4, param4, len4);
	else
		putValue(P_FSG_40_0_0_23_4, param4, getValueSize(P_FSG_40_0_0_23_4));*/

	///////// Start param5 - STRING /////////
	//getValue(P_FSG_40_0_0_23_5, param5);
  getValue(P_FSG_40_0_0_23_5_Hex, param5);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(40>127) /* Max Fct-Katalog Laenge: 40*/
		{
			len5 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt5 = 1;
		}
		else
		{
			len5 = 40;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len5 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt5 = 0;
	}
	
	if(len5 > 40)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len5, currentPos);
		len5 = 40;
	
		if(len5 < 128) cnt5 = 0;
		else cnt5 = 1;
	}
	
	for(i = 0; i < len5; i++)
	{
		param5[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_5_len, len5);
	putValue(P_FSG_40_0_0_23_5_cnt, cnt5);
	
  if(len5 > getValueSize(P_FSG_40_0_0_23_5_Hex))
		putValue(P_FSG_40_0_0_23_5_Hex, param5, len5);
	else
		putValue(P_FSG_40_0_0_23_5_Hex, param5, getValueSize(P_FSG_40_0_0_23_5_Hex));
  
	/*if(len5 > getValueSize(P_FSG_40_0_0_23_5))
		putValue(P_FSG_40_0_0_23_5, param5, len5);
	else
		putValue(P_FSG_40_0_0_23_5, param5, getValueSize(P_FSG_40_0_0_23_5));*/

	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_40_0_0_23_6, param6);
	///////// Start param7 - STRING /////////
	//getValue(P_FSG_40_0_0_23_7, param7);
  getValue(P_FSG_40_0_0_23_7_Hex, param7);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(99>127) /* Max Fct-Katalog Laenge: 99*/
		{
			len7 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt7 = 1;
		}
		else
		{
			len7 = 99;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len7 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt7 = 0;
	}
	
	if(len7 > 99)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len7, currentPos);
		len7 = 99;
	
		if(len7 < 128) cnt7 = 0;
		else cnt7 = 1;
	}
	
	for(i = 0; i < len7; i++)
	{
		param7[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_7_len, len7);
	putValue(P_FSG_40_0_0_23_7_cnt, cnt7);
	
  if(len7 > getValueSize(P_FSG_40_0_0_23_7_Hex))
		putValue(P_FSG_40_0_0_23_7_Hex, param7, len7);
	else
		putValue(P_FSG_40_0_0_23_7_Hex, param7, getValueSize(P_FSG_40_0_0_23_7_Hex));
  
	/*if(len7 > getValueSize(P_FSG_40_0_0_23_7))
		putValue(P_FSG_40_0_0_23_7, param7, len7);
	else
		putValue(P_FSG_40_0_0_23_7, param7, getValueSize(P_FSG_40_0_0_23_7));*/

	///////// Start param8 - STRING /////////
	//getValue(P_FSG_40_0_0_23_8, param8);
  getValue(P_FSG_40_0_0_23_8_Hex, param8);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(40>127) /* Max Fct-Katalog Laenge: 40*/
		{
			len8 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt8 = 1;
		}
		else
		{
			len8 = 40;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len8 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt8 = 0;
	}
	
	if(len8 > 40)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len8, currentPos);
		len8 = 40;
	
		if(len8 < 128) cnt8 = 0;
		else cnt8 = 1;
	}
	
	for(i = 0; i < len8; i++)
	{
		param8[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_8_len, len8);
	putValue(P_FSG_40_0_0_23_8_cnt, cnt8);
	
  if(len8 > getValueSize(P_FSG_40_0_0_23_8_Hex))
		putValue(P_FSG_40_0_0_23_8_Hex, param8, len8);
	else
		putValue(P_FSG_40_0_0_23_8_Hex, param8, getValueSize(P_FSG_40_0_0_23_8_Hex));
  
	/*if(len8 > getValueSize(P_FSG_40_0_0_23_8))
		putValue(P_FSG_40_0_0_23_8, param8, len8);
	else
		putValue(P_FSG_40_0_0_23_8, param8, getValueSize(P_FSG_40_0_0_23_8));*/

	///////// Start param9 - UINT8 /////////
	param9 = superval[currentPos++];
	putValue(P_FSG_40_0_0_23_9, param9);
	///////// Start param10 - STRING /////////
	//getValue(P_FSG_40_0_0_23_10, param10);
  getValue(P_FSG_40_0_0_23_10_Hex, param10);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(99>127) /* Max Fct-Katalog Laenge: 99*/
		{
			len10 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt10 = 1;
		}
		else
		{
			len10 = 99;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len10 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt10 = 0;
	}
	
	if(len10 > 99)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len10, currentPos);
		len10 = 99;
	
		if(len10 < 128) cnt10 = 0;
		else cnt10 = 1;
	}
	
	for(i = 0; i < len10; i++)
	{
		param10[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_10_len, len10);
	putValue(P_FSG_40_0_0_23_10_cnt, cnt10);
	
  if(len10 > getValueSize(P_FSG_40_0_0_23_10_Hex))
		putValue(P_FSG_40_0_0_23_10_Hex, param10, len10);
	else
		putValue(P_FSG_40_0_0_23_10_Hex, param10, getValueSize(P_FSG_40_0_0_23_10_Hex));
  
	/*if(len10 > getValueSize(P_FSG_40_0_0_23_10))
		putValue(P_FSG_40_0_0_23_10, param10, len10);
	else
		putValue(P_FSG_40_0_0_23_10, param10, getValueSize(P_FSG_40_0_0_23_10));*/

	///////// Start param11 - STRING /////////
	//getValue(P_FSG_40_0_0_23_11, param11);
  getValue(P_FSG_40_0_0_23_11_Hex, param11);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(40>127) /* Max Fct-Katalog Laenge: 40*/
		{
			len11 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt11 = 1;
		}
		else
		{
			len11 = 40;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len11 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt11 = 0;
	}
	
	if(len11 > 40)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len11, currentPos);
		len11 = 40;
	
		if(len11 < 128) cnt11 = 0;
		else cnt11 = 1;
	}
	
	for(i = 0; i < len11; i++)
	{
		param11[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_11_len, len11);
	putValue(P_FSG_40_0_0_23_11_cnt, cnt11);
	
  if(len11 > getValueSize(P_FSG_40_0_0_23_11_Hex))
		putValue(P_FSG_40_0_0_23_11_Hex, param11, len11);
	else
		putValue(P_FSG_40_0_0_23_11_Hex, param11, getValueSize(P_FSG_40_0_0_23_11_Hex));
  
	/*if(len11 > getValueSize(P_FSG_40_0_0_23_11))
		putValue(P_FSG_40_0_0_23_11, param11, len11);
	else
		putValue(P_FSG_40_0_0_23_11, param11, getValueSize(P_FSG_40_0_0_23_11));*/

	///////// Start param12 - UINT8 /////////
	param12 = superval[currentPos++];
	putValue(P_FSG_40_0_0_23_12, param12);
	///////// Start param13 - STRING /////////
	//getValue(P_FSG_40_0_0_23_13, param13);
  getValue(P_FSG_40_0_0_23_13_Hex, param13);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(99>127) /* Max Fct-Katalog Laenge: 99*/
		{
			len13 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt13 = 1;
		}
		else
		{
			len13 = 99;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len13 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt13 = 0;
	}
	
	if(len13 > 99)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len13, currentPos);
		len13 = 99;
	
		if(len13 < 128) cnt13 = 0;
		else cnt13 = 1;
	}
	
	for(i = 0; i < len13; i++)
	{
		param13[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_13_len, len13);
	putValue(P_FSG_40_0_0_23_13_cnt, cnt13);
	
  if(len13 > getValueSize(P_FSG_40_0_0_23_13_Hex))
		putValue(P_FSG_40_0_0_23_13_Hex, param13, len13);
	else
		putValue(P_FSG_40_0_0_23_13_Hex, param13, getValueSize(P_FSG_40_0_0_23_13_Hex));
  
	/*if(len13 > getValueSize(P_FSG_40_0_0_23_13))
		putValue(P_FSG_40_0_0_23_13, param13, len13);
	else
		putValue(P_FSG_40_0_0_23_13, param13, getValueSize(P_FSG_40_0_0_23_13));*/

	///////// Start param14 - STRING /////////
	//getValue(P_FSG_40_0_0_23_14, param14);
  getValue(P_FSG_40_0_0_23_14_Hex, param14);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(40>127) /* Max Fct-Katalog Laenge: 40*/
		{
			len14 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt14 = 1;
		}
		else
		{
			len14 = 40;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len14 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt14 = 0;
	}
	
	if(len14 > 40)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len14, currentPos);
		len14 = 40;
	
		if(len14 < 128) cnt14 = 0;
		else cnt14 = 1;
	}
	
	for(i = 0; i < len14; i++)
	{
		param14[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_14_len, len14);
	putValue(P_FSG_40_0_0_23_14_cnt, cnt14);
	
  if(len14 > getValueSize(P_FSG_40_0_0_23_14_Hex))
		putValue(P_FSG_40_0_0_23_14_Hex, param14, len14);
	else
		putValue(P_FSG_40_0_0_23_14_Hex, param14, getValueSize(P_FSG_40_0_0_23_14_Hex));
  
	/*if(len14 > getValueSize(P_FSG_40_0_0_23_14))
		putValue(P_FSG_40_0_0_23_14, param14, len14);
	else
		putValue(P_FSG_40_0_0_23_14, param14, getValueSize(P_FSG_40_0_0_23_14));*/

	///////// Start param15 - UINT8 /////////
	param15 = superval[currentPos++];
	putValue(P_FSG_40_0_0_23_15, param15);
	///////// Start param16 - STRING /////////
	//getValue(P_FSG_40_0_0_23_16, param16);
  getValue(P_FSG_40_0_0_23_16_Hex, param16);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(99>127) /* Max Fct-Katalog Laenge: 99*/
		{
			len16 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt16 = 1;
		}
		else
		{
			len16 = 99;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len16 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt16 = 0;
	}
	
	if(len16 > 99)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len16, currentPos);
		len16 = 99;
	
		if(len16 < 128) cnt16 = 0;
		else cnt16 = 1;
	}
	
	for(i = 0; i < len16; i++)
	{
		param16[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_16_len, len16);
	putValue(P_FSG_40_0_0_23_16_cnt, cnt16);
	
  if(len16 > getValueSize(P_FSG_40_0_0_23_16_Hex))
		putValue(P_FSG_40_0_0_23_16_Hex, param16, len16);
	else
		putValue(P_FSG_40_0_0_23_16_Hex, param16, getValueSize(P_FSG_40_0_0_23_16_Hex));
  
	/*if(len16 > getValueSize(P_FSG_40_0_0_23_16))
		putValue(P_FSG_40_0_0_23_16, param16, len16);
	else
		putValue(P_FSG_40_0_0_23_16, param16, getValueSize(P_FSG_40_0_0_23_16));*/

	///////// Start param17 - STRING /////////
	//getValue(P_FSG_40_0_0_23_17, param17);
  getValue(P_FSG_40_0_0_23_17_Hex, param17);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(40>127) /* Max Fct-Katalog Laenge: 40*/
		{
			len17 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt17 = 1;
		}
		else
		{
			len17 = 40;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len17 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt17 = 0;
	}
	
	if(len17 > 40)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len17, currentPos);
		len17 = 40;
	
		if(len17 < 128) cnt17 = 0;
		else cnt17 = 1;
	}
	
	for(i = 0; i < len17; i++)
	{
		param17[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_17_len, len17);
	putValue(P_FSG_40_0_0_23_17_cnt, cnt17);
	
  if(len17 > getValueSize(P_FSG_40_0_0_23_17_Hex))
		putValue(P_FSG_40_0_0_23_17_Hex, param17, len17);
	else
		putValue(P_FSG_40_0_0_23_17_Hex, param17, getValueSize(P_FSG_40_0_0_23_17_Hex));
  
	/*if(len17 > getValueSize(P_FSG_40_0_0_23_17))
		putValue(P_FSG_40_0_0_23_17, param17, len17);
	else
		putValue(P_FSG_40_0_0_23_17, param17, getValueSize(P_FSG_40_0_0_23_17));*/

	///////// Start param18 - UINT8 /////////
	param18 = superval[currentPos++];
	putValue(P_FSG_40_0_0_23_18, param18);
	///////// Start param19 - STRING /////////
	//getValue(P_FSG_40_0_0_23_19, param19);
  getValue(P_FSG_40_0_0_23_19_Hex, param19);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(99>127) /* Max Fct-Katalog Laenge: 99*/
		{
			len19 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt19 = 1;
		}
		else
		{
			len19 = 99;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len19 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt19 = 0;
	}
	
	if(len19 > 99)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len19, currentPos);
		len19 = 99;
	
		if(len19 < 128) cnt19 = 0;
		else cnt19 = 1;
	}
	
	for(i = 0; i < len19; i++)
	{
		param19[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_19_len, len19);
	putValue(P_FSG_40_0_0_23_19_cnt, cnt19);
	
  if(len19 > getValueSize(P_FSG_40_0_0_23_19_Hex))
		putValue(P_FSG_40_0_0_23_19_Hex, param19, len19);
	else
		putValue(P_FSG_40_0_0_23_19_Hex, param19, getValueSize(P_FSG_40_0_0_23_19_Hex));
  
	/*if(len19 > getValueSize(P_FSG_40_0_0_23_19))
		putValue(P_FSG_40_0_0_23_19, param19, len19);
	else
		putValue(P_FSG_40_0_0_23_19, param19, getValueSize(P_FSG_40_0_0_23_19));*/

	///////// Start param20 - STRING /////////
	//getValue(P_FSG_40_0_0_23_20, param20);
  getValue(P_FSG_40_0_0_23_20_Hex, param20);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(40>127) /* Max Fct-Katalog Laenge: 40*/
		{
			len20 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt20 = 1;
		}
		else
		{
			len20 = 40;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_23 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len20 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt20 = 0;
	}
	
	if(len20 > 40)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len20, currentPos);
		len20 = 40;
	
		if(len20 < 128) cnt20 = 0;
		else cnt20 = 1;
	}
	
	for(i = 0; i < len20; i++)
	{
		param20[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_23_20_len, len20);
	putValue(P_FSG_40_0_0_23_20_cnt, cnt20);
	
  if(len20 > getValueSize(P_FSG_40_0_0_23_20_Hex))
		putValue(P_FSG_40_0_0_23_20_Hex, param20, len20);
	else
		putValue(P_FSG_40_0_0_23_20_Hex, param20, getValueSize(P_FSG_40_0_0_23_20_Hex));
  
	/*if(len20 > getValueSize(P_FSG_40_0_0_23_20))
		putValue(P_FSG_40_0_0_23_20, param20, len20);
	else
		putValue(P_FSG_40_0_0_23_20, param20, getValueSize(P_FSG_40_0_0_23_20));*/

	///////// Start param21 - UINT8 /////////
	param21 = superval[currentPos++];
	putValue(P_FSG_40_0_0_23_21, param21);
}

// Updates the bus value field and other dependencies.
P_FSG_40_0_0_23_BuildFct()
{
	byte param1[100]; // PbName0
	word len1;
	byte cnt1;
	byte param2[41]; // TelNumber0
	word len2;
	byte cnt2;
	byte param3; // Category0
	byte param4[100]; // PbName1
	word len4;
	byte cnt4;
	byte param5[41]; // TelNumber1
	word len5;
	byte cnt5;
	byte param6; // Category1
	byte param7[100]; // PbName2
	word len7;
	byte cnt7;
	byte param8[41]; // TelNumber2
	word len8;
	byte cnt8;
	byte param9; // Category2
	byte param10[100]; // PbName3
	word len10;
	byte cnt10;
	byte param11[41]; // TelNumber3
	word len11;
	byte cnt11;
	byte param12; // Category3
	byte param13[100]; // PbName4
	word len13;
	byte cnt13;
	byte param14[41]; // TelNumber4
	word len14;
	byte cnt14;
	byte param15; // Category4
	byte param16[100]; // PbName5
	word len16;
	byte cnt16;
	byte param17[41]; // TelNumber5
	word len17;
	byte cnt17;
	byte param18; // Category5
	byte param19[100]; // PbName6
	word len19;
	byte cnt19;
	byte param20[41]; // TelNumber6
	word len20;
	byte cnt20;
	byte param21; // Category6

	int i;
	byte superval[994];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_1, param1);
  getValue(P_FSG_40_0_0_23_1_Hex, param1);
	len1 = getValue(P_FSG_40_0_0_23_1_len);
	cnt1= getValue(P_FSG_40_0_0_23_1_cnt);
	
	/* check box aktiviert*/
	if (cnt1 == 1)
	{
		/* 0 bis 99 (MaxString - 1B oder 2B) */
		if(len1 >= 0 && len1 <= 99)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 99);
			return;
		}
	}
	else if(cnt1 == 0) /*check box deaktiviert*/
	{
		if(len1 >= 0 && len1 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos]= len1 & 0x00ff;
			putValue(P_FSG_40_0_0_23_1_len, len1);
		}
		else if(len1 > 127 && len1 <= 99)
		{
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
			putValue(P_FSG_40_0_0_23_1_len, len1);
			putValue(P_FSG_40_0_0_23_1_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 99);
			return;
		}
	}
	currentPos += cnt1+1;
	for(i = 0; i < len1; i++)
	{
		superval[currentPos++]= param1[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_2, param2);
  getValue(P_FSG_40_0_0_23_2_Hex, param2);
	len2 = getValue(P_FSG_40_0_0_23_2_len);
	cnt2= getValue(P_FSG_40_0_0_23_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 40 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 40)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 40);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(P_FSG_40_0_0_23_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 40)
		{
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(P_FSG_40_0_0_23_2_len, len2);
			putValue(P_FSG_40_0_0_23_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 40);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_40_0_0_23_3);
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_4, param4);
  getValue(P_FSG_40_0_0_23_4_Hex, param4);
	len4 = getValue(P_FSG_40_0_0_23_4_len);
	cnt4= getValue(P_FSG_40_0_0_23_4_cnt);
	
	/* check box aktiviert*/
	if (cnt4 == 1)
	{
		/* 0 bis 99 (MaxString - 1B oder 2B) */
		if(len4 >= 0 && len4 <= 99)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
			superval[currentPos] = (len4&0x7f00) | 0x80;
			superval[currentPos+1] = len4 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 99);
			return;
		}
	}
	else if(cnt4 == 0) /*check box deaktiviert*/
	{
		if(len4 >= 0 && len4 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len4: %d", len4);
			superval[currentPos]= len4 & 0x00ff;
			putValue(P_FSG_40_0_0_23_4_len, len4);
		}
		else if(len4 > 127 && len4 <= 99)
		{
			superval[currentPos] = (len4&0x7f00) | 0x80;
			superval[currentPos+1] = len4 & 0x00ff;
			putValue(P_FSG_40_0_0_23_4_len, len4);
			putValue(P_FSG_40_0_0_23_4_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_4 ist ungueltig. Die max. erlaubte Laenge ist %d.", len4, 99);
			return;
		}
	}
	currentPos += cnt4+1;
	for(i = 0; i < len4; i++)
	{
		superval[currentPos++]= param4[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_5, param5);
  getValue(P_FSG_40_0_0_23_5_Hex, param5);
	len5 = getValue(P_FSG_40_0_0_23_5_len);
	cnt5= getValue(P_FSG_40_0_0_23_5_cnt);
	
	/* check box aktiviert*/
	if (cnt5 == 1)
	{
		/* 0 bis 40 (MaxString - 1B oder 2B) */
		if(len5 >= 0 && len5 <= 40)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len5: %d", len5);
			superval[currentPos] = (len5&0x7f00) | 0x80;
			superval[currentPos+1] = len5 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_5 ist ungueltig. Die max. erlaubte Laenge ist %d.", len5, 40);
			return;
		}
	}
	else if(cnt5 == 0) /*check box deaktiviert*/
	{
		if(len5 >= 0 && len5 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len5: %d", len5);
			superval[currentPos]= len5 & 0x00ff;
			putValue(P_FSG_40_0_0_23_5_len, len5);
		}
		else if(len5 > 127 && len5 <= 40)
		{
			superval[currentPos] = (len5&0x7f00) | 0x80;
			superval[currentPos+1] = len5 & 0x00ff;
			putValue(P_FSG_40_0_0_23_5_len, len5);
			putValue(P_FSG_40_0_0_23_5_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_5 ist ungueltig. Die max. erlaubte Laenge ist %d.", len5, 40);
			return;
		}
	}
	currentPos += cnt5+1;
	for(i = 0; i < len5; i++)
	{
		superval[currentPos++]= param5[i];
	}

// gen_BuildFunc_SetSuperVals 
	param6 = getValue(P_FSG_40_0_0_23_6);
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_7, param7);
  getValue(P_FSG_40_0_0_23_7_Hex, param7);
	len7 = getValue(P_FSG_40_0_0_23_7_len);
	cnt7= getValue(P_FSG_40_0_0_23_7_cnt);
	
	/* check box aktiviert*/
	if (cnt7 == 1)
	{
		/* 0 bis 99 (MaxString - 1B oder 2B) */
		if(len7 >= 0 && len7 <= 99)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
			superval[currentPos] = (len7&0x7f00) | 0x80;
			superval[currentPos+1] = len7 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 99);
			return;
		}
	}
	else if(cnt7 == 0) /*check box deaktiviert*/
	{
		if(len7 >= 0 && len7 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
			superval[currentPos]= len7 & 0x00ff;
			putValue(P_FSG_40_0_0_23_7_len, len7);
		}
		else if(len7 > 127 && len7 <= 99)
		{
			superval[currentPos] = (len7&0x7f00) | 0x80;
			superval[currentPos+1] = len7 & 0x00ff;
			putValue(P_FSG_40_0_0_23_7_len, len7);
			putValue(P_FSG_40_0_0_23_7_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 99);
			return;
		}
	}
	currentPos += cnt7+1;
	for(i = 0; i < len7; i++)
	{
		superval[currentPos++]= param7[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_8, param8);
  getValue(P_FSG_40_0_0_23_8_Hex, param8);
	len8 = getValue(P_FSG_40_0_0_23_8_len);
	cnt8= getValue(P_FSG_40_0_0_23_8_cnt);
	
	/* check box aktiviert*/
	if (cnt8 == 1)
	{
		/* 0 bis 40 (MaxString - 1B oder 2B) */
		if(len8 >= 0 && len8 <= 40)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
			superval[currentPos] = (len8&0x7f00) | 0x80;
			superval[currentPos+1] = len8 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 40);
			return;
		}
	}
	else if(cnt8 == 0) /*check box deaktiviert*/
	{
		if(len8 >= 0 && len8 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
			superval[currentPos]= len8 & 0x00ff;
			putValue(P_FSG_40_0_0_23_8_len, len8);
		}
		else if(len8 > 127 && len8 <= 40)
		{
			superval[currentPos] = (len8&0x7f00) | 0x80;
			superval[currentPos+1] = len8 & 0x00ff;
			putValue(P_FSG_40_0_0_23_8_len, len8);
			putValue(P_FSG_40_0_0_23_8_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 40);
			return;
		}
	}
	currentPos += cnt8+1;
	for(i = 0; i < len8; i++)
	{
		superval[currentPos++]= param8[i];
	}

// gen_BuildFunc_SetSuperVals 
	param9 = getValue(P_FSG_40_0_0_23_9);
	superval[currentPos++]=param9;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_10, param10);
  getValue(P_FSG_40_0_0_23_10_Hex, param10);
	len10 = getValue(P_FSG_40_0_0_23_10_len);
	cnt10= getValue(P_FSG_40_0_0_23_10_cnt);
	
	/* check box aktiviert*/
	if (cnt10 == 1)
	{
		/* 0 bis 99 (MaxString - 1B oder 2B) */
		if(len10 >= 0 && len10 <= 99)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len10: %d", len10);
			superval[currentPos] = (len10&0x7f00) | 0x80;
			superval[currentPos+1] = len10 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_10 ist ungueltig. Die max. erlaubte Laenge ist %d.", len10, 99);
			return;
		}
	}
	else if(cnt10 == 0) /*check box deaktiviert*/
	{
		if(len10 >= 0 && len10 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len10: %d", len10);
			superval[currentPos]= len10 & 0x00ff;
			putValue(P_FSG_40_0_0_23_10_len, len10);
		}
		else if(len10 > 127 && len10 <= 99)
		{
			superval[currentPos] = (len10&0x7f00) | 0x80;
			superval[currentPos+1] = len10 & 0x00ff;
			putValue(P_FSG_40_0_0_23_10_len, len10);
			putValue(P_FSG_40_0_0_23_10_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_10 ist ungueltig. Die max. erlaubte Laenge ist %d.", len10, 99);
			return;
		}
	}
	currentPos += cnt10+1;
	for(i = 0; i < len10; i++)
	{
		superval[currentPos++]= param10[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_11, param11);
  getValue(P_FSG_40_0_0_23_11_Hex, param11);
	len11 = getValue(P_FSG_40_0_0_23_11_len);
	cnt11= getValue(P_FSG_40_0_0_23_11_cnt);
	
	/* check box aktiviert*/
	if (cnt11 == 1)
	{
		/* 0 bis 40 (MaxString - 1B oder 2B) */
		if(len11 >= 0 && len11 <= 40)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len11: %d", len11);
			superval[currentPos] = (len11&0x7f00) | 0x80;
			superval[currentPos+1] = len11 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_11 ist ungueltig. Die max. erlaubte Laenge ist %d.", len11, 40);
			return;
		}
	}
	else if(cnt11 == 0) /*check box deaktiviert*/
	{
		if(len11 >= 0 && len11 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len11: %d", len11);
			superval[currentPos]= len11 & 0x00ff;
			putValue(P_FSG_40_0_0_23_11_len, len11);
		}
		else if(len11 > 127 && len11 <= 40)
		{
			superval[currentPos] = (len11&0x7f00) | 0x80;
			superval[currentPos+1] = len11 & 0x00ff;
			putValue(P_FSG_40_0_0_23_11_len, len11);
			putValue(P_FSG_40_0_0_23_11_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_11 ist ungueltig. Die max. erlaubte Laenge ist %d.", len11, 40);
			return;
		}
	}
	currentPos += cnt11+1;
	for(i = 0; i < len11; i++)
	{
		superval[currentPos++]= param11[i];
	}

// gen_BuildFunc_SetSuperVals 
	param12 = getValue(P_FSG_40_0_0_23_12);
	superval[currentPos++]=param12;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_13, param13);
  getValue(P_FSG_40_0_0_23_13_Hex, param13);
	len13 = getValue(P_FSG_40_0_0_23_13_len);
	cnt13= getValue(P_FSG_40_0_0_23_13_cnt);
	
	/* check box aktiviert*/
	if (cnt13 == 1)
	{
		/* 0 bis 99 (MaxString - 1B oder 2B) */
		if(len13 >= 0 && len13 <= 99)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len13: %d", len13);
			superval[currentPos] = (len13&0x7f00) | 0x80;
			superval[currentPos+1] = len13 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_13 ist ungueltig. Die max. erlaubte Laenge ist %d.", len13, 99);
			return;
		}
	}
	else if(cnt13 == 0) /*check box deaktiviert*/
	{
		if(len13 >= 0 && len13 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len13: %d", len13);
			superval[currentPos]= len13 & 0x00ff;
			putValue(P_FSG_40_0_0_23_13_len, len13);
		}
		else if(len13 > 127 && len13 <= 99)
		{
			superval[currentPos] = (len13&0x7f00) | 0x80;
			superval[currentPos+1] = len13 & 0x00ff;
			putValue(P_FSG_40_0_0_23_13_len, len13);
			putValue(P_FSG_40_0_0_23_13_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_13 ist ungueltig. Die max. erlaubte Laenge ist %d.", len13, 99);
			return;
		}
	}
	currentPos += cnt13+1;
	for(i = 0; i < len13; i++)
	{
		superval[currentPos++]= param13[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_14, param14);
  getValue(P_FSG_40_0_0_23_14_Hex, param14);
	len14 = getValue(P_FSG_40_0_0_23_14_len);
	cnt14= getValue(P_FSG_40_0_0_23_14_cnt);
	
	/* check box aktiviert*/
	if (cnt14 == 1)
	{
		/* 0 bis 40 (MaxString - 1B oder 2B) */
		if(len14 >= 0 && len14 <= 40)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len14: %d", len14);
			superval[currentPos] = (len14&0x7f00) | 0x80;
			superval[currentPos+1] = len14 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_14 ist ungueltig. Die max. erlaubte Laenge ist %d.", len14, 40);
			return;
		}
	}
	else if(cnt14 == 0) /*check box deaktiviert*/
	{
		if(len14 >= 0 && len14 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len14: %d", len14);
			superval[currentPos]= len14 & 0x00ff;
			putValue(P_FSG_40_0_0_23_14_len, len14);
		}
		else if(len14 > 127 && len14 <= 40)
		{
			superval[currentPos] = (len14&0x7f00) | 0x80;
			superval[currentPos+1] = len14 & 0x00ff;
			putValue(P_FSG_40_0_0_23_14_len, len14);
			putValue(P_FSG_40_0_0_23_14_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_14 ist ungueltig. Die max. erlaubte Laenge ist %d.", len14, 40);
			return;
		}
	}
	currentPos += cnt14+1;
	for(i = 0; i < len14; i++)
	{
		superval[currentPos++]= param14[i];
	}

// gen_BuildFunc_SetSuperVals 
	param15 = getValue(P_FSG_40_0_0_23_15);
	superval[currentPos++]=param15;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_16, param16);
  getValue(P_FSG_40_0_0_23_16_Hex, param16);
	len16 = getValue(P_FSG_40_0_0_23_16_len);
	cnt16= getValue(P_FSG_40_0_0_23_16_cnt);
	
	/* check box aktiviert*/
	if (cnt16 == 1)
	{
		/* 0 bis 99 (MaxString - 1B oder 2B) */
		if(len16 >= 0 && len16 <= 99)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len16: %d", len16);
			superval[currentPos] = (len16&0x7f00) | 0x80;
			superval[currentPos+1] = len16 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_16 ist ungueltig. Die max. erlaubte Laenge ist %d.", len16, 99);
			return;
		}
	}
	else if(cnt16 == 0) /*check box deaktiviert*/
	{
		if(len16 >= 0 && len16 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len16: %d", len16);
			superval[currentPos]= len16 & 0x00ff;
			putValue(P_FSG_40_0_0_23_16_len, len16);
		}
		else if(len16 > 127 && len16 <= 99)
		{
			superval[currentPos] = (len16&0x7f00) | 0x80;
			superval[currentPos+1] = len16 & 0x00ff;
			putValue(P_FSG_40_0_0_23_16_len, len16);
			putValue(P_FSG_40_0_0_23_16_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_16 ist ungueltig. Die max. erlaubte Laenge ist %d.", len16, 99);
			return;
		}
	}
	currentPos += cnt16+1;
	for(i = 0; i < len16; i++)
	{
		superval[currentPos++]= param16[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_17, param17);
  getValue(P_FSG_40_0_0_23_17_Hex, param17);
	len17 = getValue(P_FSG_40_0_0_23_17_len);
	cnt17= getValue(P_FSG_40_0_0_23_17_cnt);
	
	/* check box aktiviert*/
	if (cnt17 == 1)
	{
		/* 0 bis 40 (MaxString - 1B oder 2B) */
		if(len17 >= 0 && len17 <= 40)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len17: %d", len17);
			superval[currentPos] = (len17&0x7f00) | 0x80;
			superval[currentPos+1] = len17 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_17 ist ungueltig. Die max. erlaubte Laenge ist %d.", len17, 40);
			return;
		}
	}
	else if(cnt17 == 0) /*check box deaktiviert*/
	{
		if(len17 >= 0 && len17 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len17: %d", len17);
			superval[currentPos]= len17 & 0x00ff;
			putValue(P_FSG_40_0_0_23_17_len, len17);
		}
		else if(len17 > 127 && len17 <= 40)
		{
			superval[currentPos] = (len17&0x7f00) | 0x80;
			superval[currentPos+1] = len17 & 0x00ff;
			putValue(P_FSG_40_0_0_23_17_len, len17);
			putValue(P_FSG_40_0_0_23_17_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_17 ist ungueltig. Die max. erlaubte Laenge ist %d.", len17, 40);
			return;
		}
	}
	currentPos += cnt17+1;
	for(i = 0; i < len17; i++)
	{
		superval[currentPos++]= param17[i];
	}

// gen_BuildFunc_SetSuperVals 
	param18 = getValue(P_FSG_40_0_0_23_18);
	superval[currentPos++]=param18;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_19, param19);
  getValue(P_FSG_40_0_0_23_19_Hex, param19);
	len19 = getValue(P_FSG_40_0_0_23_19_len);
	cnt19= getValue(P_FSG_40_0_0_23_19_cnt);
	
	/* check box aktiviert*/
	if (cnt19 == 1)
	{
		/* 0 bis 99 (MaxString - 1B oder 2B) */
		if(len19 >= 0 && len19 <= 99)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len19: %d", len19);
			superval[currentPos] = (len19&0x7f00) | 0x80;
			superval[currentPos+1] = len19 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_19 ist ungueltig. Die max. erlaubte Laenge ist %d.", len19, 99);
			return;
		}
	}
	else if(cnt19 == 0) /*check box deaktiviert*/
	{
		if(len19 >= 0 && len19 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len19: %d", len19);
			superval[currentPos]= len19 & 0x00ff;
			putValue(P_FSG_40_0_0_23_19_len, len19);
		}
		else if(len19 > 127 && len19 <= 99)
		{
			superval[currentPos] = (len19&0x7f00) | 0x80;
			superval[currentPos+1] = len19 & 0x00ff;
			putValue(P_FSG_40_0_0_23_19_len, len19);
			putValue(P_FSG_40_0_0_23_19_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_19 ist ungueltig. Die max. erlaubte Laenge ist %d.", len19, 99);
			return;
		}
	}
	currentPos += cnt19+1;
	for(i = 0; i < len19; i++)
	{
		superval[currentPos++]= param19[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_23_20, param20);
  getValue(P_FSG_40_0_0_23_20_Hex, param20);
	len20 = getValue(P_FSG_40_0_0_23_20_len);
	cnt20= getValue(P_FSG_40_0_0_23_20_cnt);
	
	/* check box aktiviert*/
	if (cnt20 == 1)
	{
		/* 0 bis 40 (MaxString - 1B oder 2B) */
		if(len20 >= 0 && len20 <= 40)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len20: %d", len20);
			superval[currentPos] = (len20&0x7f00) | 0x80;
			superval[currentPos+1] = len20 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_20 ist ungueltig. Die max. erlaubte Laenge ist %d.", len20, 40);
			return;
		}
	}
	else if(cnt20 == 0) /*check box deaktiviert*/
	{
		if(len20 >= 0 && len20 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len20: %d", len20);
			superval[currentPos]= len20 & 0x00ff;
			putValue(P_FSG_40_0_0_23_20_len, len20);
		}
		else if(len20 > 127 && len20 <= 40)
		{
			superval[currentPos] = (len20&0x7f00) | 0x80;
			superval[currentPos+1] = len20 & 0x00ff;
			putValue(P_FSG_40_0_0_23_20_len, len20);
			putValue(P_FSG_40_0_0_23_20_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_20 ist ungueltig. Die max. erlaubte Laenge ist %d.", len20, 40);
			return;
		}
	}
	currentPos += cnt20+1;
	for(i = 0; i < len20; i++)
	{
		superval[currentPos++]= param20[i];
	}

// gen_BuildFunc_SetSuperVals 
	param21 = getValue(P_FSG_40_0_0_23_21);
	superval[currentPos++]=param21;
	putValue(P_FSG_40_0_0_23, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_1_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_1_len);
	cnt = getValue(P_FSG_40_0_0_23_1_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_1_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_1_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 99)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 99);
		putValue(this, 99);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_1 // CallInfo.PbName0
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_1_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_1_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_1_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_2_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_2_len);
	cnt = getValue(P_FSG_40_0_0_23_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_2_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_2_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 40)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 40);
		putValue(this, 40);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_2 // CallInfo.TelNumber0
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_2_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_2_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_2_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}

on envVar P_FSG_40_0_0_23_3 // CallInfo.Category0
{
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_4_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_4_len);
	cnt = getValue(P_FSG_40_0_0_23_4_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_4_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_4_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 99)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 99);
		putValue(this, 99);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_4 // CallInfo.PbName1
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_4_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_4_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_4_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_5_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_5_len);
	cnt = getValue(P_FSG_40_0_0_23_5_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_5_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_5_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 40)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 40);
		putValue(this, 40);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_5 // CallInfo.TelNumber1
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_5_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_5_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_5_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}

on envVar P_FSG_40_0_0_23_6 // CallInfo.Category1
{
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_7_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_7_len);
	cnt = getValue(P_FSG_40_0_0_23_7_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_7_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_7_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 99)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 99);
		putValue(this, 99);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_7 // CallInfo.PbName2
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_7_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_7_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_7_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_8_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_8_len);
	cnt = getValue(P_FSG_40_0_0_23_8_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_8_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_8_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 40)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_8 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 40);
		putValue(this, 40);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_8 // CallInfo.TelNumber2
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_8_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_8_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_8_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}

on envVar P_FSG_40_0_0_23_9 // CallInfo.Category2
{
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_10_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_10_len);
	cnt = getValue(P_FSG_40_0_0_23_10_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_10_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_10_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 99)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_10 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 99);
		putValue(this, 99);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_10 // CallInfo.PbName3
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_10_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_10_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_10_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_11_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_11_len);
	cnt = getValue(P_FSG_40_0_0_23_11_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_11_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_11_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 40)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_11 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 40);
		putValue(this, 40);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_11 // CallInfo.TelNumber3
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_11_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_11_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_11_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}

on envVar P_FSG_40_0_0_23_12 // CallInfo.Category3
{
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_13_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_13_len);
	cnt = getValue(P_FSG_40_0_0_23_13_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_13_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_13_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 99)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_13 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 99);
		putValue(this, 99);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_13 // CallInfo.PbName4
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_13_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_13_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_13_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_14_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_14_len);
	cnt = getValue(P_FSG_40_0_0_23_14_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_14_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_14_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 40)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_14 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 40);
		putValue(this, 40);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_14 // CallInfo.TelNumber4
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_14_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_14_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_14_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}

on envVar P_FSG_40_0_0_23_15 // CallInfo.Category4
{
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_16_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_16_len);
	cnt = getValue(P_FSG_40_0_0_23_16_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_16_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_16_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 99)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_16 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 99);
		putValue(this, 99);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_16 // CallInfo.PbName5
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_16_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_16_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_16_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_17_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_17_len);
	cnt = getValue(P_FSG_40_0_0_23_17_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_17_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_17_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 40)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_17 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 40);
		putValue(this, 40);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_17 // CallInfo.TelNumber5
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_17_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_17_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_17_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}

on envVar P_FSG_40_0_0_23_18 // CallInfo.Category5
{
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_19_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_19_len);
	cnt = getValue(P_FSG_40_0_0_23_19_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_19_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_19_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 99)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_19 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 99);
		putValue(this, 99);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_19 // CallInfo.PbName6
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_19_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_19_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_19_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_23_20_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_23_20_len);
	cnt = getValue(P_FSG_40_0_0_23_20_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_23_20_len, 127);
		}
	}

	P_FSG_40_0_0_23_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_23_20_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 40)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_23_20 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 40);
		putValue(this, 40);
	}
	P_FSG_40_0_0_23_BuildFct();
}


on envVar P_FSG_40_0_0_23_20 // CallInfo.TelNumber6
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_23_20_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_23_20_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_23_20_len, getValueSize(this));*/
	P_FSG_40_0_0_23_BuildFct();
}

on envVar P_FSG_40_0_0_23_21 // CallInfo.Category6
{
	P_FSG_40_0_0_23_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_24_ErrCode
{
       if(gP_FSG_40_0_0_24_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_24", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_24_ErrCode = 1;
}
on envVar P_FSG_40_0_0_24Status_BTN
{
	byte BAPTemp[14];
    if (P_FSG_40_0_0_24Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_40_0_0_24_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_24",MakeRGB(255,255,255));
        P_FSG_40_0_0_24Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_40_0_0_24_BuildFct();
        getValue(P_FSG_40_0_0_24, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_24_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_24));
        if(getValue(P_FSG_40_0_0_24_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_40_0_0_24_ID);
        }
        if(getValue(P_FSG_40_0_0_24_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_40_0_0_24_ID,elCount(BAPTemp));
        }
       P_FSG_40_0_0_24Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_24_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_24_ID;
    data[2]=getValue(P_FSG_40_0_0_24_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_24
on envVar P_FSG_40_0_0_24_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_24",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_24",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_24",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_24", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_24",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_24",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_24",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_24", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_24_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_24_SegmEn,0);
           intertelegram_err(P_FSG_40_0_0_24_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_40_0_0_24_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_24_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_24_IntTlgEn,0);
           sequence_err(P_FSG_40_0_0_24_ID,getValueSize(P_FSG_40_0_0_24_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_40_0_0_24_ID);
       }
}
on envVar P_FSG_40_0_0_24 // bus value of CallDurationSync (24).
{
	// opcodes: Error-Status
	word param1; // TimeStampCall0
	word param2; // TimeStampCall1
	word param3; // TimeStampCall2
	word param4; // TimeStampCall3
	word param5; // TimeStampCall4
	word param6; // TimeStampCall5
	word param7; // TimeStampCall6
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[14];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 14; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_24, superval);
	///////// Start param1 - UINT16 /////////
	param1 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_24_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_24_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_24_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT16 /////////
	param4 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_24_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT16 /////////
	param5 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_24_5, round((param5 * 1.0) - (0) + (0), 1.0));
	///////// Start param6 - UINT16 /////////
	param6 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_24_6, round((param6 * 1.0) - (0) + (0), 1.0));
	///////// Start param7 - UINT16 /////////
	param7 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_24_7, round((param7 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_FSG_40_0_0_24_BuildFct()
{
	word param1; // TimeStampCall0
	word param2; // TimeStampCall1
	word param3; // TimeStampCall2
	word param4; // TimeStampCall3
	word param5; // TimeStampCall4
	word param6; // TimeStampCall5
	word param7; // TimeStampCall6

	int i;
	byte superval[14];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_40_0_0_24_1_range = round(@P_FSG_40_0_0_24_1 + (0), 1.0); // slider value + min = real value
	param1 = round( (@P_FSG_40_0_0_24_1 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param1&0x00ff;
	superval[currentPos++]=(param1&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_40_0_0_24_2_range = round(@P_FSG_40_0_0_24_2 + (0), 1.0); // slider value + min = real value
	param2 = round( (@P_FSG_40_0_0_24_2 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param2&0x00ff;
	superval[currentPos++]=(param2&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_40_0_0_24_3_range = round(@P_FSG_40_0_0_24_3 + (0), 1.0); // slider value + min = real value
	param3 = round( (@P_FSG_40_0_0_24_3 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param3&0x00ff;
	superval[currentPos++]=(param3&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_40_0_0_24_4_range = round(@P_FSG_40_0_0_24_4 + (0), 1.0); // slider value + min = real value
	param4 = round( (@P_FSG_40_0_0_24_4 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param4&0x00ff;
	superval[currentPos++]=(param4&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_40_0_0_24_5_range = round(@P_FSG_40_0_0_24_5 + (0), 1.0); // slider value + min = real value
	param5 = round( (@P_FSG_40_0_0_24_5 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param5&0x00ff;
	superval[currentPos++]=(param5&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_40_0_0_24_6_range = round(@P_FSG_40_0_0_24_6 + (0), 1.0); // slider value + min = real value
	param6 = round( (@P_FSG_40_0_0_24_6 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param6&0x00ff;
	superval[currentPos++]=(param6&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_40_0_0_24_7_range = round(@P_FSG_40_0_0_24_7 + (0), 1.0); // slider value + min = real value
	param7 = round( (@P_FSG_40_0_0_24_7 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param7&0x00ff;
	superval[currentPos++]=(param7&0xff00)>>8;
	putValue(P_FSG_40_0_0_24, superval, currentPos);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_24_1_range // CallDurationSync.TimeStampCall0 
{
	@P_FSG_40_0_0_24_1 = @P_FSG_40_0_0_24_1_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_24_1 // CallDurationSync.TimeStampCall0
{
	P_FSG_40_0_0_24_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_24_2_range // CallDurationSync.TimeStampCall1 
{
	@P_FSG_40_0_0_24_2 = @P_FSG_40_0_0_24_2_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_24_2 // CallDurationSync.TimeStampCall1
{
	P_FSG_40_0_0_24_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_24_3_range // CallDurationSync.TimeStampCall2 
{
	@P_FSG_40_0_0_24_3 = @P_FSG_40_0_0_24_3_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_24_3 // CallDurationSync.TimeStampCall2
{
	P_FSG_40_0_0_24_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_24_4_range // CallDurationSync.TimeStampCall3 
{
	@P_FSG_40_0_0_24_4 = @P_FSG_40_0_0_24_4_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_24_4 // CallDurationSync.TimeStampCall3
{
	P_FSG_40_0_0_24_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_24_5_range // CallDurationSync.TimeStampCall4 
{
	@P_FSG_40_0_0_24_5 = @P_FSG_40_0_0_24_5_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_24_5 // CallDurationSync.TimeStampCall4
{
	P_FSG_40_0_0_24_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_24_6_range // CallDurationSync.TimeStampCall5 
{
	@P_FSG_40_0_0_24_6 = @P_FSG_40_0_0_24_6_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_24_6 // CallDurationSync.TimeStampCall5
{
	P_FSG_40_0_0_24_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_24_7_range // CallDurationSync.TimeStampCall6 
{
	@P_FSG_40_0_0_24_7 = @P_FSG_40_0_0_24_7_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_24_7 // CallDurationSync.TimeStampCall6
{
	P_FSG_40_0_0_24_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_25_ErrCode
{
       if(gP_FSG_40_0_0_25_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_25", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_25_ErrCode = 1;
}
on envVar P_FSG_40_0_0_25Status_BTN
{
    if (P_FSG_40_0_0_25Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_40_0_0_25_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_25",MakeRGB(255,255,255));
       P_FSG_40_0_0_25Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_40_0_0_25_ID, Data_REQ, getValue(P_FSG_40_0_0_25));
      P_FSG_40_0_0_25Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_25_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_25_ID;
    data[2]=getValue(P_FSG_40_0_0_25_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_25
on envVar P_FSG_40_0_0_25_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_25",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_25",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_25",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_25", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_25",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_25",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_25",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_25", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_25 // bus value of DisconnectReason (25).
{
	// opcodes: Error-Status
	byte param1; // DisconnectReason
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_40_0_0_25);
	putValue(P_FSG_40_0_0_25_1, param1);
}

on envVar P_FSG_40_0_0_25_1 // DisconnectReason.DisconnectReason
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // DisconnectReason
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_40_0_0_25);
	superval = thisval;
	putValue(P_FSG_40_0_0_25,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_26_ErrCode
{
       if(gM_FSG_40_0_0_26_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_26", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_26_ErrCode = 1;
}
on envVar M_FSG_40_0_0_26Result_BTN
{
  if (M_FSG_40_0_0_26Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_26_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_26",MakeRGB(255,255,255));
     M_FSG_40_0_0_26Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_26_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_26_ID, Result_REQ, getValue(M_FSG_40_0_0_26_Result));
     M_FSG_40_0_0_26Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_26_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_26_ID;
    data[2]=getValue(M_FSG_40_0_0_26_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_26
on envVar M_FSG_40_0_0_26_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_26",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_26",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_26",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_26", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_26",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_26",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_26",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_26_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_26", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_26_Result // bus value of DialNumber (26).
{
	// opcodes: Error-Processing-Result
	byte param1; // DialNumber_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_26_Result);
	putValue(M_FSG_40_0_0_26_Result_1, param1);
}

on envVar M_FSG_40_0_0_26_Result_1 // DialNumber.DialNumber_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // DialNumber_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_26_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_26_Result,superval);
}

on envVar M_FSG_40_0_0_26_Processing // bus value of DialNumber (26).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_26_Processing);
	putValue(M_FSG_40_0_0_26_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_26_Processing_1_range // DialNumber.Reserve1 
{
	@M_FSG_40_0_0_26_Processing_1 = @M_FSG_40_0_0_26_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_26_Processing_1 // DialNumber.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_26_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_26_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_26_Processing,superval);
}

on envVar M_FSG_40_0_0_26_Start // bus value of DialNumber (26).
{
	// opcodes: AbortResult-StartResult
	byte param1[41]; // TelNumber
	word len1;
	byte cnt1;
	byte param2[150]; // Name
	word len2;
	byte cnt2;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[191];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 191; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_40_0_0_26_Start, superval);
	///////// Start param1 - STRING /////////
	getValue(M_FSG_40_0_0_26_Start_1, param1);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(40>127) /* Max Fct-Katalog Laenge: 40*/
		{
			len1 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt1 = 1;
		}
		else
		{
			len1 = 40;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_40_0_0_26_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len1 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt1 = 0;
	}
	
	if(len1 > 40)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len1, currentPos);
		len1 = 40;
	
		if(len1 < 128) cnt1 = 0;
		else cnt1 = 1;
	}
	
	for(i = 0; i < len1; i++)
	{
		param1[i] = superval[currentPos++];
	}
	
	putValue(M_FSG_40_0_0_26_Start_1_len, len1);
	putValue(M_FSG_40_0_0_26_Start_1_cnt, cnt1);
	
	if(len1 > getValueSize(M_FSG_40_0_0_26_Start_1))
		putValue(M_FSG_40_0_0_26_Start_1, param1, len1);
	else
		putValue(M_FSG_40_0_0_26_Start_1, param1, getValueSize(M_FSG_40_0_0_26_Start_1));

	///////// Start param2 - STRING /////////
	//getValue(M_FSG_40_0_0_26_Start_2, param2);
  getValue(M_FSG_40_0_0_26_Start_2_Hex, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(148>127) /* Max Fct-Katalog Laenge: 148*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 148;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_40_0_0_26_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 148)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 148;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(M_FSG_40_0_0_26_Start_2_len, len2);
	putValue(M_FSG_40_0_0_26_Start_2_cnt, cnt2);
	
  if(len2 > getValueSize(M_FSG_40_0_0_26_Start_2_Hex))
		putValue(M_FSG_40_0_0_26_Start_2_Hex, param2, len2);
	else
		putValue(M_FSG_40_0_0_26_Start_2_Hex, param2, getValueSize(M_FSG_40_0_0_26_Start_2_Hex));
  
	/*if(len2 > getValueSize(M_FSG_40_0_0_26_Start_2))
		putValue(M_FSG_40_0_0_26_Start_2, param2, len2);
	else
		putValue(M_FSG_40_0_0_26_Start_2, param2, getValueSize(M_FSG_40_0_0_26_Start_2));*/

}

// Updates the bus value field and other dependencies.
M_FSG_40_0_0_26_Start_BuildFct()
{
	byte param1[41]; // TelNumber
	word len1;
	byte cnt1;
	byte param2[150]; // Name
	word len2;
	byte cnt2;

	int i;
	byte superval[191];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	getValue(M_FSG_40_0_0_26_Start_1, param1);
	len1 = getValue(M_FSG_40_0_0_26_Start_1_len);
	cnt1= getValue(M_FSG_40_0_0_26_Start_1_cnt);
	
	/* check box aktiviert*/
	if (cnt1 == 1)
	{
		/* 0 bis 40 (MaxString - 1B oder 2B) */
		if(len1 >= 0 && len1 <= 40)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_26_Start_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 40);
			return;
		}
	}
	else if(cnt1 == 0) /*check box deaktiviert*/
	{
		if(len1 >= 0 && len1 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len1: %d", len1);
			superval[currentPos]= len1 & 0x00ff;
			putValue(M_FSG_40_0_0_26_Start_1_len, len1);
		}
		else if(len1 > 127 && len1 <= 40)
		{
			superval[currentPos] = (len1&0x7f00) | 0x80;
			superval[currentPos+1] = len1 & 0x00ff;
			putValue(M_FSG_40_0_0_26_Start_1_len, len1);
			putValue(M_FSG_40_0_0_26_Start_1_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_26_Start_1 ist ungueltig. Die max. erlaubte Laenge ist %d.", len1, 40);
			return;
		}
	}
	currentPos += cnt1+1;
	for(i = 0; i < len1; i++)
	{
		superval[currentPos++]= param1[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(M_FSG_40_0_0_26_Start_2, param2);
  getValue(M_FSG_40_0_0_26_Start_2_Hex, param2);
	len2 = getValue(M_FSG_40_0_0_26_Start_2_len);
	cnt2= getValue(M_FSG_40_0_0_26_Start_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 148 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 148)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_26_Start_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 148);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(M_FSG_40_0_0_26_Start_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 148)
		{
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(M_FSG_40_0_0_26_Start_2_len, len2);
			putValue(M_FSG_40_0_0_26_Start_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_26_Start_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 148);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

	putValue(M_FSG_40_0_0_26_Start, superval, currentPos);
}



// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_40_0_0_26_Start_1_cnt
{
	word len;
	byte cnt;
	len = getValue(M_FSG_40_0_0_26_Start_1_len);
	cnt = getValue(M_FSG_40_0_0_26_Start_1_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_FSG_40_0_0_26_Start_1_len, 127);
		}
	}

	M_FSG_40_0_0_26_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_40_0_0_26_Start_1_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 40)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_26_Start_1 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 40);
		putValue(this, 40);
	}
	M_FSG_40_0_0_26_Start_BuildFct();
}


on envVar M_FSG_40_0_0_26_Start_1 // DialNumber.TelNumber
{
	putValue(M_FSG_40_0_0_26_Start_1_len, getValueSize(this));
	M_FSG_40_0_0_26_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_40_0_0_26_Start_2_cnt
{
	word len;
	byte cnt;
	len = getValue(M_FSG_40_0_0_26_Start_2_len);
	cnt = getValue(M_FSG_40_0_0_26_Start_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_FSG_40_0_0_26_Start_2_len, 127);
		}
	}

	M_FSG_40_0_0_26_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_40_0_0_26_Start_2_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 148)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_26_Start_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 148);
		putValue(this, 148);
	}
	M_FSG_40_0_0_26_Start_BuildFct();
}


on envVar M_FSG_40_0_0_26_Start_2 // DialNumber.Name
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(M_FSG_40_0_0_26_Start_2_Hex,string_buffer_mod,string_length_mod);
  putValue(M_FSG_40_0_0_26_Start_2_len, string_length_mod);
  
	/*putValue(M_FSG_40_0_0_26_Start_2_len, getValueSize(this));
	M_FSG_40_0_0_26_Start_BuildFct();*/
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_27_ErrCode
{
       if(gM_FSG_40_0_0_27_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_27", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_27_ErrCode = 1;
}
on envVar M_FSG_40_0_0_27Result_BTN
{
  if (M_FSG_40_0_0_27Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_27_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_27",MakeRGB(255,255,255));
     M_FSG_40_0_0_27Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_27_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_27_ID, Result_REQ, getValue(M_FSG_40_0_0_27_Result));
     M_FSG_40_0_0_27Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_27_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_27_ID;
    data[2]=getValue(M_FSG_40_0_0_27_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_27
on envVar M_FSG_40_0_0_27_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_27",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_27",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_27",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_27", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_27",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_27",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_27",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_27_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_27", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_27_Result // bus value of DialService (27).
{
	// opcodes: Error-Processing-Result
	byte param1; // DialService_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_27_Result);
	putValue(M_FSG_40_0_0_27_Result_1, param1);
}

on envVar M_FSG_40_0_0_27_Result_1 // DialService.DialService_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // DialService_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_27_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_27_Result,superval);
}

on envVar M_FSG_40_0_0_27_Processing // bus value of DialService (27).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_27_Processing);
	putValue(M_FSG_40_0_0_27_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_27_Processing_1_range // DialService.Reserve1 
{
	@M_FSG_40_0_0_27_Processing_1 = @M_FSG_40_0_0_27_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_27_Processing_1 // DialService.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_27_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_27_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_27_Processing,superval);
}

on envVar M_FSG_40_0_0_27_Start // bus value of DialService (27).
{
	// opcodes: AbortResult-StartResult
	byte param1; // ServiceType
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_27_Start);
	putValue(M_FSG_40_0_0_27_Start_1, param1);
}

on envVar M_FSG_40_0_0_27_Start_1 // DialService.ServiceType
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // ServiceType
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_27_Start);
	superval = thisval;
	putValue(M_FSG_40_0_0_27_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_28_ErrCode
{
       if(gM_FSG_40_0_0_28_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_28", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_28_ErrCode = 1;
}
on envVar M_FSG_40_0_0_28Result_BTN
{
  if (M_FSG_40_0_0_28Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_28_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_28",MakeRGB(255,255,255));
     M_FSG_40_0_0_28Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_28_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_28_ID, Result_REQ, getValue(M_FSG_40_0_0_28_Result));
     M_FSG_40_0_0_28Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_28_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_28_ID;
    data[2]=getValue(M_FSG_40_0_0_28_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_28
on envVar M_FSG_40_0_0_28_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_28",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_28",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_28",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_28", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_28",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_28",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_28",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_28_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_28", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_28_Result // bus value of ConfirmEmergencyCall (28).
{
	// opcodes: Error-Processing-Result
	byte param1; // ConfirmErmergencyCall_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_28_Result);
	putValue(M_FSG_40_0_0_28_Result_1, param1);
}

on envVar M_FSG_40_0_0_28_Result_1 // ConfirmEmergencyCall.ConfirmErmergencyCall_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // ConfirmErmergencyCall_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_28_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_28_Result,superval);
}

on envVar M_FSG_40_0_0_28_Processing // bus value of ConfirmEmergencyCall (28).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_28_Processing);
	putValue(M_FSG_40_0_0_28_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_28_Processing_1_range // ConfirmEmergencyCall.Reserve1 
{
	@M_FSG_40_0_0_28_Processing_1 = @M_FSG_40_0_0_28_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_28_Processing_1 // ConfirmEmergencyCall.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_28_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_28_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_28_Processing,superval);
}

on envVar M_FSG_40_0_0_28_Start // bus value of ConfirmEmergencyCall (28).
{
	// opcodes: StartResult
	byte param1; // Control
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_28_Start);
	putValue(M_FSG_40_0_0_28_Start_1, param1);
}

on envVar M_FSG_40_0_0_28_Start_1 // ConfirmEmergencyCall.Control
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // Control
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_28_Start);
	superval = thisval;
	putValue(M_FSG_40_0_0_28_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_29_ErrCode
{
       if(gM_FSG_40_0_0_29_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_29", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_29_ErrCode = 1;
}
on envVar M_FSG_40_0_0_29Result_BTN
{
  if (M_FSG_40_0_0_29Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_29_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_29",MakeRGB(255,255,255));
     M_FSG_40_0_0_29Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_29_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_29_ID, Result_REQ, getValue(M_FSG_40_0_0_29_Result));
     M_FSG_40_0_0_29Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_29_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_29_ID;
    data[2]=getValue(M_FSG_40_0_0_29_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_29
on envVar M_FSG_40_0_0_29_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_29",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_29",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_29",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_29", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_29",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_29",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_29",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_29_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_29", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_29_Result // bus value of HangupCall (29).
{
	// opcodes: Error-Processing-Result
	byte param1; // HangupCall_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_29_Result);
	putValue(M_FSG_40_0_0_29_Result_1, param1);
}

on envVar M_FSG_40_0_0_29_Result_1 // HangupCall.HangupCall_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // HangupCall_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_29_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_29_Result,superval);
}

on envVar M_FSG_40_0_0_29_Processing // bus value of HangupCall (29).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_29_Processing);
	putValue(M_FSG_40_0_0_29_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_29_Processing_1_range // HangupCall.Reserve1 
{
	@M_FSG_40_0_0_29_Processing_1 = @M_FSG_40_0_0_29_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_29_Processing_1 // HangupCall.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_29_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_29_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_29_Processing,superval);
}

on envVar M_FSG_40_0_0_29_Start // bus value of HangupCall (29).
{
	// opcodes: StartResult
	byte param1; // CallID
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_29_Start);
	putValue(M_FSG_40_0_0_29_Start_1, param1);
}

on envVar M_FSG_40_0_0_29_Start_1 // HangupCall.CallID
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // CallID
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_29_Start);
	superval = thisval;
	putValue(M_FSG_40_0_0_29_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_30_ErrCode
{
       if(gM_FSG_40_0_0_30_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_30", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_30_ErrCode = 1;
}
on envVar M_FSG_40_0_0_30Result_BTN
{
  if (M_FSG_40_0_0_30Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_30_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_30",MakeRGB(255,255,255));
     M_FSG_40_0_0_30Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_30_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_30_ID, Result_REQ, getValue(M_FSG_40_0_0_30_Result));
     M_FSG_40_0_0_30Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_30_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_30_ID;
    data[2]=getValue(M_FSG_40_0_0_30_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_30
on envVar M_FSG_40_0_0_30_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_30",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_30",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_30",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_30", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_30",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_30",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_30",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_30_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_30", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_30_Result // bus value of AcceptCall (30).
{
	// opcodes: Error-Processing-Result
	byte param1; // AcceptCall_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_30_Result);
	putValue(M_FSG_40_0_0_30_Result_1, param1);
}

on envVar M_FSG_40_0_0_30_Result_1 // AcceptCall.AcceptCall_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // AcceptCall_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_30_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_30_Result,superval);
}

on envVar M_FSG_40_0_0_30_Processing // bus value of AcceptCall (30).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_30_Processing);
	putValue(M_FSG_40_0_0_30_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_30_Processing_1_range // AcceptCall.Reserve1 
{
	@M_FSG_40_0_0_30_Processing_1 = @M_FSG_40_0_0_30_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_30_Processing_1 // AcceptCall.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_30_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_30_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_30_Processing,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_31_ErrCode
{
       if(gM_FSG_40_0_0_31_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_31", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_31_ErrCode = 1;
}
on envVar M_FSG_40_0_0_31Result_BTN
{
  if (M_FSG_40_0_0_31Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_31_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_31",MakeRGB(255,255,255));
     M_FSG_40_0_0_31Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_31_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_31_ID, Result_REQ, getValue(M_FSG_40_0_0_31_Result));
     M_FSG_40_0_0_31Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_31_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_31_ID;
    data[2]=getValue(M_FSG_40_0_0_31_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_31
on envVar M_FSG_40_0_0_31_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_31",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_31",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_31",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_31", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_31",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_31",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_31",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_31_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_31", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_31_Result // bus value of CallHold (31).
{
	// opcodes: Error-Processing-Result
	byte param1; // CallHold_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_31_Result);
	putValue(M_FSG_40_0_0_31_Result_1, param1);
}

on envVar M_FSG_40_0_0_31_Result_1 // CallHold.CallHold_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // CallHold_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_31_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_31_Result,superval);
}

on envVar M_FSG_40_0_0_31_Processing // bus value of CallHold (31).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_31_Processing);
	putValue(M_FSG_40_0_0_31_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_31_Processing_1_range // CallHold.Reserve1 
{
	@M_FSG_40_0_0_31_Processing_1 = @M_FSG_40_0_0_31_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_31_Processing_1 // CallHold.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_31_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_31_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_31_Processing,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_32_ErrCode
{
       if(gM_FSG_40_0_0_32_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_32", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_32_ErrCode = 1;
}
on envVar M_FSG_40_0_0_32Result_BTN
{
  if (M_FSG_40_0_0_32Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_32_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_32",MakeRGB(255,255,255));
     M_FSG_40_0_0_32Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_32_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_32_ID, Result_REQ, getValue(M_FSG_40_0_0_32_Result));
     M_FSG_40_0_0_32Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_32_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_32_ID;
    data[2]=getValue(M_FSG_40_0_0_32_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_32
on envVar M_FSG_40_0_0_32_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_32",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_32",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_32",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_32", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_32",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_32",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_32",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_32_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_32", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_32_Result // bus value of ResumeCall (32).
{
	// opcodes: Error-Processing-Result
	byte param1; // ResumeCall_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_32_Result);
	putValue(M_FSG_40_0_0_32_Result_1, param1);
}

on envVar M_FSG_40_0_0_32_Result_1 // ResumeCall.ResumeCall_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // ResumeCall_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_32_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_32_Result,superval);
}

on envVar M_FSG_40_0_0_32_Processing // bus value of ResumeCall (32).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_32_Processing);
	putValue(M_FSG_40_0_0_32_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_32_Processing_1_range // ResumeCall.Reserve1 
{
	@M_FSG_40_0_0_32_Processing_1 = @M_FSG_40_0_0_32_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_32_Processing_1 // ResumeCall.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_32_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_32_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_32_Processing,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_33_ErrCode
{
       if(gP_FSG_40_0_0_33_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_33", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_33_ErrCode = 1;
}
on envVar P_FSG_40_0_0_33Status_BTN
{
    if (P_FSG_40_0_0_33Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_40_0_0_33_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_33",MakeRGB(255,255,255));
       P_FSG_40_0_0_33Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_40_0_0_33_ID, Data_REQ, getValue(P_FSG_40_0_0_33));
      P_FSG_40_0_0_33Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_33_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_33_ID;
    data[2]=getValue(P_FSG_40_0_0_33_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_33
on envVar P_FSG_40_0_0_33_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_33",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_33",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_33",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_33", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_33",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_33",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_33",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_33", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_33 // bus value of HandsFreeOnOff (33).
{
	// opcodes: Error-Status
	byte param1; // HandsFreeOnOff
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_40_0_0_33);
	putValue(P_FSG_40_0_0_33_1, param1);
}

on envVar P_FSG_40_0_0_33_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // HandsFreeOnOff
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_33_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_33_1,thisval);
}

on envVar P_FSG_40_0_0_33_1 // HandsFreeOnOff.HandsFreeOnOff
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // HandsFreeOnOff
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_40_0_0_33_1_0, 1);
	else
		putValue(P_FSG_40_0_0_33_1_0, 0);

    // Update superval
	superval = getValue(P_FSG_40_0_0_33);
	superval = thisval;
	putValue(P_FSG_40_0_0_33,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_34_ErrCode
{
       if(gP_FSG_40_0_0_34_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_34", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_34_ErrCode = 1;
}
on envVar P_FSG_40_0_0_34Status_BTN
{
    if (P_FSG_40_0_0_34Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_40_0_0_34_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_34",MakeRGB(255,255,255));
       P_FSG_40_0_0_34Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_40_0_0_34_ID, Data_REQ, getValue(P_FSG_40_0_0_34));
      P_FSG_40_0_0_34Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_34_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_34_ID;
    data[2]=getValue(P_FSG_40_0_0_34_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_34
on envVar P_FSG_40_0_0_34_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_34",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_34",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_34",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_34", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_34",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_34",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_34",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_34", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_34 // bus value of MicroMuteOnOff (34).
{
	// opcodes: Error-Status
	byte param1; // MicroMuteOnOff
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_40_0_0_34);
	putValue(P_FSG_40_0_0_34_1, param1);
}

on envVar P_FSG_40_0_0_34_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // MicroMuteOnOff
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_34_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_34_1,thisval);
}

on envVar P_FSG_40_0_0_34_1 // MicroMuteOnOff.MicroMuteOnOff
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // MicroMuteOnOff
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_40_0_0_34_1_0, 1);
	else
		putValue(P_FSG_40_0_0_34_1_0, 0);

    // Update superval
	superval = getValue(P_FSG_40_0_0_34);
	superval = thisval;
	putValue(P_FSG_40_0_0_34,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_35_ErrCode
{
       if(gM_FSG_40_0_0_35_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_35", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_35_ErrCode = 1;
}
on envVar M_FSG_40_0_0_35Result_BTN
{
  if (M_FSG_40_0_0_35Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_35_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_35",MakeRGB(255,255,255));
     M_FSG_40_0_0_35Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_35_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_35_ID, Result_REQ, getValue(M_FSG_40_0_0_35_Result));
     M_FSG_40_0_0_35Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_35_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_35_ID;
    data[2]=getValue(M_FSG_40_0_0_35_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_35
on envVar M_FSG_40_0_0_35_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_35",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_35",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_35",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_35", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_35",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_35",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_35",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_35_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_35", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_35_Result // bus value of MPRelActiveCallAcceptWC (35).
{
	// opcodes: Error-Processing-Result
	byte param1; // MPRACAWC_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_35_Result);
	putValue(M_FSG_40_0_0_35_Result_1, param1);
}

on envVar M_FSG_40_0_0_35_Result_1 // MPRelActiveCallAcceptWC.MPRACAWC_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // MPRACAWC_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_35_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_35_Result,superval);
}

on envVar M_FSG_40_0_0_35_Processing // bus value of MPRelActiveCallAcceptWC (35).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_35_Processing);
	putValue(M_FSG_40_0_0_35_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_35_Processing_1_range // MPRelActiveCallAcceptWC.Reserve1 
{
	@M_FSG_40_0_0_35_Processing_1 = @M_FSG_40_0_0_35_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_35_Processing_1 // MPRelActiveCallAcceptWC.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_35_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_35_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_35_Processing,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_36_ErrCode
{
       if(gM_FSG_40_0_0_36_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_36", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_36_ErrCode = 1;
}
on envVar M_FSG_40_0_0_36Result_BTN
{
  if (M_FSG_40_0_0_36Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_36_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_36",MakeRGB(255,255,255));
     M_FSG_40_0_0_36Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_36_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_36_ID, Result_REQ, getValue(M_FSG_40_0_0_36_Result));
     M_FSG_40_0_0_36Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_36_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_36_ID;
    data[2]=getValue(M_FSG_40_0_0_36_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_36
on envVar M_FSG_40_0_0_36_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_36",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_36",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_36",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_36", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_36",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_36",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_36",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_36_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_36", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_36_Result // bus value of MPSwap (36).
{
	// opcodes: Error-Processing-Result
	byte param1; // MPSwap_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_36_Result);
	putValue(M_FSG_40_0_0_36_Result_1, param1);
}

on envVar M_FSG_40_0_0_36_Result_1 // MPSwap.MPSwap_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // MPSwap_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_36_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_36_Result,superval);
}

on envVar M_FSG_40_0_0_36_Processing // bus value of MPSwap (36).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_36_Processing);
	putValue(M_FSG_40_0_0_36_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_36_Processing_1_range // MPSwap.Reserve1 
{
	@M_FSG_40_0_0_36_Processing_1 = @M_FSG_40_0_0_36_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_36_Processing_1 // MPSwap.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_36_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_36_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_36_Processing,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_37_ErrCode
{
       if(gM_FSG_40_0_0_37_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_37", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_37_ErrCode = 1;
}
on envVar M_FSG_40_0_0_37Result_BTN
{
  if (M_FSG_40_0_0_37Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_37_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_37",MakeRGB(255,255,255));
     M_FSG_40_0_0_37Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_37_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_37_ID, Result_REQ, getValue(M_FSG_40_0_0_37_Result));
     M_FSG_40_0_0_37Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_37_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_37_ID;
    data[2]=getValue(M_FSG_40_0_0_37_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_37
on envVar M_FSG_40_0_0_37_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_37",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_37",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_37",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_37", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_37",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_37",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_37",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_37_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_37", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_37_Result // bus value of MPCallHoldAcceptWC (37).
{
	// opcodes: Error-Processing-Result
	byte param1; // MPCHAWC_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_37_Result);
	putValue(M_FSG_40_0_0_37_Result_1, param1);
}

on envVar M_FSG_40_0_0_37_Result_1 // MPCallHoldAcceptWC.MPCHAWC_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // MPCHAWC_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_37_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_37_Result,superval);
}

on envVar M_FSG_40_0_0_37_Processing // bus value of MPCallHoldAcceptWC (37).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_37_Processing);
	putValue(M_FSG_40_0_0_37_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_37_Processing_1_range // MPCallHoldAcceptWC.Reserve1 
{
	@M_FSG_40_0_0_37_Processing_1 = @M_FSG_40_0_0_37_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_37_Processing_1 // MPCallHoldAcceptWC.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_37_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_37_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_37_Processing,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_38_ErrCode
{
       if(gM_FSG_40_0_0_38_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_38", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_38_ErrCode = 1;
}
on envVar M_FSG_40_0_0_38Result_BTN
{
  if (M_FSG_40_0_0_38Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_38_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_38",MakeRGB(255,255,255));
     M_FSG_40_0_0_38Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_38_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_38_ID, Result_REQ, getValue(M_FSG_40_0_0_38_Result));
     M_FSG_40_0_0_38Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_38_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_38_ID;
    data[2]=getValue(M_FSG_40_0_0_38_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_38
on envVar M_FSG_40_0_0_38_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_38",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_38",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_38",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_38", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_38",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_38",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_38",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_38_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_38", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_38_Result // bus value of MPRelAllCallsAcceptWC (38).
{
	// opcodes: Error-Processing-Result
	byte param1; // MPRACAWC_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_38_Result);
	putValue(M_FSG_40_0_0_38_Result_1, param1);
}

on envVar M_FSG_40_0_0_38_Result_1 // MPRelAllCallsAcceptWC.MPRACAWC_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // MPRACAWC_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_38_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_38_Result,superval);
}

on envVar M_FSG_40_0_0_38_Processing // bus value of MPRelAllCallsAcceptWC (38).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_38_Processing);
	putValue(M_FSG_40_0_0_38_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_38_Processing_1_range // MPRelAllCallsAcceptWC.Reserve1 
{
	@M_FSG_40_0_0_38_Processing_1 = @M_FSG_40_0_0_38_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_38_Processing_1 // MPRelAllCallsAcceptWC.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_38_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_38_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_38_Processing,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_39_ErrCode
{
       if(gM_FSG_40_0_0_39_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_39", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_39_ErrCode = 1;
}
on envVar M_FSG_40_0_0_39Result_BTN
{
  if (M_FSG_40_0_0_39Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_39_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_39",MakeRGB(255,255,255));
     M_FSG_40_0_0_39Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_39_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_39_ID, Result_REQ, getValue(M_FSG_40_0_0_39_Result));
     M_FSG_40_0_0_39Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_39_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_39_ID;
    data[2]=getValue(M_FSG_40_0_0_39_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_39
on envVar M_FSG_40_0_0_39_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_39",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_39",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_39",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_39", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_39",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_39",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_39",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_39_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_39", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_39_Result // bus value of MPSetWaitingCallOnHold (39).
{
	// opcodes: Error-Processing-Result
	byte param1; // MPSWCOH_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_39_Result);
	putValue(M_FSG_40_0_0_39_Result_1, param1);
}

on envVar M_FSG_40_0_0_39_Result_1 // MPSetWaitingCallOnHold.MPSWCOH_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // MPSWCOH_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_39_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_39_Result,superval);
}

on envVar M_FSG_40_0_0_39_Processing // bus value of MPSetWaitingCallOnHold (39).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_39_Processing);
	putValue(M_FSG_40_0_0_39_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_39_Processing_1_range // MPSetWaitingCallOnHold.Reserve1 
{
	@M_FSG_40_0_0_39_Processing_1 = @M_FSG_40_0_0_39_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_39_Processing_1 // MPSetWaitingCallOnHold.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_39_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_39_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_39_Processing,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_40_ErrCode
{
       if(gM_FSG_40_0_0_40_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_40", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_40_ErrCode = 1;
}
on envVar M_FSG_40_0_0_40Result_BTN
{
  if (M_FSG_40_0_0_40Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_40_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_40",MakeRGB(255,255,255));
     M_FSG_40_0_0_40Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_40_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_40_ID, Result_REQ, getValue(M_FSG_40_0_0_40_Result));
     M_FSG_40_0_0_40Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_40_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_40_ID;
    data[2]=getValue(M_FSG_40_0_0_40_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_40
on envVar M_FSG_40_0_0_40_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_40",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_40",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_40",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_40", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_40",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_40",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_40",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_40_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_40", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_40_Result // bus value of CCJoin (40).
{
	// opcodes: Error-Processing-Result
	byte param1; // CCJoin_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_40_Result);
	putValue(M_FSG_40_0_0_40_Result_1, param1);
}

on envVar M_FSG_40_0_0_40_Result_1 // CCJoin.CCJoin_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // CCJoin_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_40_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_40_Result,superval);
}

on envVar M_FSG_40_0_0_40_Processing // bus value of CCJoin (40).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_40_Processing);
	putValue(M_FSG_40_0_0_40_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_40_Processing_1_range // CCJoin.Reserve1 
{
	@M_FSG_40_0_0_40_Processing_1 = @M_FSG_40_0_0_40_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_40_Processing_1 // CCJoin.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_40_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_40_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_40_Processing,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_41_ErrCode
{
       if(gM_FSG_40_0_0_41_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_41", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_41_ErrCode = 1;
}
on envVar M_FSG_40_0_0_41Result_BTN
{
  if (M_FSG_40_0_0_41Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_41_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_41",MakeRGB(255,255,255));
     M_FSG_40_0_0_41Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_41_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_41_ID, Result_REQ, getValue(M_FSG_40_0_0_41_Result));
     M_FSG_40_0_0_41Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_41_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_41_ID;
    data[2]=getValue(M_FSG_40_0_0_41_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_41
on envVar M_FSG_40_0_0_41_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_41",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_41",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_41",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_41", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_41",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_41",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_41",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_41_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_41", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_41_Result // bus value of CCSplit (41).
{
	// opcodes: Error-Processing-Result
	byte param1; // CCSplit_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_41_Result);
	putValue(M_FSG_40_0_0_41_Result_1, param1);
}

on envVar M_FSG_40_0_0_41_Result_1 // CCSplit.CCSplit_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // CCSplit_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_41_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_41_Result,superval);
}

on envVar M_FSG_40_0_0_41_Processing // bus value of CCSplit (41).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_41_Processing);
	putValue(M_FSG_40_0_0_41_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_41_Processing_1_range // CCSplit.Reserve1 
{
	@M_FSG_40_0_0_41_Processing_1 = @M_FSG_40_0_0_41_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_41_Processing_1 // CCSplit.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_41_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_41_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_41_Processing,superval);
}

on envVar M_FSG_40_0_0_41_Start // bus value of CCSplit (41).
{
	// opcodes: StartResult
	byte param1; // CallID
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_41_Start);
	putValue(M_FSG_40_0_0_41_Start_1, param1);
}

on envVar M_FSG_40_0_0_41_Start_1 // CCSplit.CallID
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // CallID
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_41_Start);
	superval = thisval;
	putValue(M_FSG_40_0_0_41_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_42_ErrCode
{
       if(gP_FSG_40_0_0_42_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_42", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_42_ErrCode = 1;
}
on envVar P_FSG_40_0_0_42Status_BTN
{
    if (P_FSG_40_0_0_42Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_40_0_0_42_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_42",MakeRGB(255,255,255));
       P_FSG_40_0_0_42Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_40_0_0_42_ID, Data_REQ, getValue(P_FSG_40_0_0_42));
      P_FSG_40_0_0_42Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_42_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_42_ID;
    data[2]=getValue(P_FSG_40_0_0_42_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_42
on envVar P_FSG_40_0_0_42_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_42",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_42",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_42",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_42", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_42",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_42",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_42",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_42", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_42 // bus value of Keypad (42).
{
	// opcodes: Error-Status
	byte param1; // KeyStatus
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_40_0_0_42);
	putValue(P_FSG_40_0_0_42_1, param1);
}

on envVar P_FSG_40_0_0_42_1 // Keypad.KeyStatus
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // KeyStatus
	thisval = getValue(this);

    // Update superval
	superval = getValue(P_FSG_40_0_0_42);
	superval = thisval;
	putValue(P_FSG_40_0_0_42,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_43_ErrCode
{
       if(gP_FSG_40_0_0_43_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_43", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_43_ErrCode = 1;
}
on envVar P_FSG_40_0_0_43Status_BTN
{
	byte BAPTemp[5];
   if (P_FSG_40_0_0_43Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_40_0_0_43_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_43",MakeRGB(255,255,255));
      P_FSG_40_0_0_43Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_40_0_0_43, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_40_0_0_43_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_43));
      P_FSG_40_0_0_43Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_40_0_0_43_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_43_ID;
    data[2]=getValue(P_FSG_40_0_0_43_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_43
on envVar P_FSG_40_0_0_43_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_43",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_43",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_43",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_43", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_43",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_43",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_43",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_43", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_43 // bus value of MobileBatteryLevel (43).
{
	// opcodes: Error-Status
	byte param1; // ChargeLevel_Mobile1
	byte param2; // ChargeLevel_Mobile2
	byte param3; // ChargeLevel_Handset1
	byte param4; // ChargeLevel_Handset2
	byte param5; // WarningLevel
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[5];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_43, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_40_0_0_43_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_40_0_0_43_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_40_0_0_43_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_40_0_0_43_4, round((param4 * 1.0) - (0) + (0), 1.0));
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_40_0_0_43_5, param5);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_43_1_range // MobileBatteryLevel.ChargeLevel_Mobile1 
{
	@P_FSG_40_0_0_43_1 = @P_FSG_40_0_0_43_1_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_43_1 // MobileBatteryLevel.ChargeLevel_Mobile1
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // ChargeLevel_Mobile1
	float slider_value;

	slider_value = round(@P_FSG_40_0_0_43_1, 1.0);
	@P_FSG_40_0_0_43_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_40_0_0_43, superval);
	superval[0]=thisval;
	putValue(P_FSG_40_0_0_43,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_43_2_range // MobileBatteryLevel.ChargeLevel_Mobile2 
{
	@P_FSG_40_0_0_43_2 = @P_FSG_40_0_0_43_2_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_43_2 // MobileBatteryLevel.ChargeLevel_Mobile2
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // ChargeLevel_Mobile2
	float slider_value;

	slider_value = round(@P_FSG_40_0_0_43_2, 1.0);
	@P_FSG_40_0_0_43_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_40_0_0_43, superval);
	superval[1]=thisval;
	putValue(P_FSG_40_0_0_43,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_43_3_range // MobileBatteryLevel.ChargeLevel_Handset1 
{
	@P_FSG_40_0_0_43_3 = @P_FSG_40_0_0_43_3_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_43_3 // MobileBatteryLevel.ChargeLevel_Handset1
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // ChargeLevel_Handset1
	float slider_value;

	slider_value = round(@P_FSG_40_0_0_43_3, 1.0);
	@P_FSG_40_0_0_43_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_40_0_0_43, superval);
	superval[2]=thisval;
	putValue(P_FSG_40_0_0_43,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_43_4_range // MobileBatteryLevel.ChargeLevel_Handset2 
{
	@P_FSG_40_0_0_43_4 = @P_FSG_40_0_0_43_4_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_43_4 // MobileBatteryLevel.ChargeLevel_Handset2
{
	byte superval[5];

	//Update Childvalue (Number)
	byte thisval; // ChargeLevel_Handset2
	float slider_value;

	slider_value = round(@P_FSG_40_0_0_43_4, 1.0);
	@P_FSG_40_0_0_43_4_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_40_0_0_43, superval);
	superval[3]=thisval;
	putValue(P_FSG_40_0_0_43,superval);
}

on envVar P_FSG_40_0_0_43_5_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // WarningLevel
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_43_5);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_43_5,thisval);
}

on envVar P_FSG_40_0_0_43_5_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // WarningLevel
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_43_5);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_43_5,thisval);
}

on envVar P_FSG_40_0_0_43_5_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // WarningLevel
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_43_5);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_43_5,thisval);
}

on envVar P_FSG_40_0_0_43_5_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // WarningLevel
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_43_5);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_43_5,thisval);
}

on envVar P_FSG_40_0_0_43_5 // MobileBatteryLevel.WarningLevel
{
	byte superval[5];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // WarningLevel
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_40_0_0_43_5_0, 1);
	else
		putValue(P_FSG_40_0_0_43_5_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_40_0_0_43_5_1, 1);
	else
		putValue(P_FSG_40_0_0_43_5_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_40_0_0_43_5_2, 1);
	else
		putValue(P_FSG_40_0_0_43_5_2, 0);
	if(thisval&(mask<<3))
		putValue(P_FSG_40_0_0_43_5_3, 1);
	else
		putValue(P_FSG_40_0_0_43_5_3, 0);

    // Update superval
	getValue(P_FSG_40_0_0_43, superval);
	superval[4]=thisval;
	putValue(P_FSG_40_0_0_43,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_44_ErrCode
{
       if(gP_FSG_40_0_0_44_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_44", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_44_ErrCode = 1;
}
on envVar P_FSG_40_0_0_44Status_BTN
{
	byte BAPTemp[9];
    if (P_FSG_40_0_0_44Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_40_0_0_44_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_44",MakeRGB(255,255,255));
        P_FSG_40_0_0_44Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_40_0_0_44_BuildFct();
        getValue(P_FSG_40_0_0_44, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_44_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_44));
        if(getValue(P_FSG_40_0_0_44_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_40_0_0_44_ID);
        }
        if(getValue(P_FSG_40_0_0_44_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_40_0_0_44_ID,elCount(BAPTemp));
        }
       P_FSG_40_0_0_44Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_44_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_44_ID;
    data[2]=getValue(P_FSG_40_0_0_44_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_44
on envVar P_FSG_40_0_0_44_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_44",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_44",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_44",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_44", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_44",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_44",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_44",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_44", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_44_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_44_SegmEn,0);
           intertelegram_err(P_FSG_40_0_0_44_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_40_0_0_44_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_44_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_44_IntTlgEn,0);
           sequence_err(P_FSG_40_0_0_44_ID,getValueSize(P_FSG_40_0_0_44_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_40_0_0_44_ID);
       }
}
on envVar P_FSG_40_0_0_44 // bus value of DataConnectionIndication (44).
{
	// opcodes: Error-Status
	byte param1; // ConnectionIndication
	dword param2; // DataVolumeUplink
	dword param3; // DataVolumeDownlink
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[9];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 9; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_44, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_40_0_0_44_1, param1);
	///////// Start param2 - UINT32 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8)|(superval[currentPos++]<<16)|(superval[currentPos++]<<24);
	putValue(P_FSG_40_0_0_44_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT32 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8)|(superval[currentPos++]<<16)|(superval[currentPos++]<<24);
	putValue(P_FSG_40_0_0_44_3, round((param3 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
P_FSG_40_0_0_44_BuildFct()
{
	byte param1; // ConnectionIndication
	dword param2; // DataVolumeUplink
	dword param3; // DataVolumeDownlink

	int i;
	byte superval[9];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_FSG_40_0_0_44_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_40_0_0_44_2_range = round(@P_FSG_40_0_0_44_2 + (0), 1.0); // slider value + min = real value
	param2 = round( (@P_FSG_40_0_0_44_2 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]= param2&0x000000ff;
	superval[currentPos++]=(param2&0x0000ff00)>>8;
	superval[currentPos++]=(param2&0x00ff0000)>>16;
	superval[currentPos++]=(param2&0xff000000)>>24;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_40_0_0_44_3_range = round(@P_FSG_40_0_0_44_3 + (0), 1.0); // slider value + min = real value
	param3 = round( (@P_FSG_40_0_0_44_3 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]= param3&0x000000ff;
	superval[currentPos++]=(param3&0x0000ff00)>>8;
	superval[currentPos++]=(param3&0x00ff0000)>>16;
	superval[currentPos++]=(param3&0xff000000)>>24;
	putValue(P_FSG_40_0_0_44, superval, currentPos);
}


on envVar P_FSG_40_0_0_44_1 // DataConnectionIndication.ConnectionIndication
{
	P_FSG_40_0_0_44_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_44_2_range // DataConnectionIndication.DataVolumeUplink 
{
	@P_FSG_40_0_0_44_2 = @P_FSG_40_0_0_44_2_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_44_2 // DataConnectionIndication.DataVolumeUplink
{
	P_FSG_40_0_0_44_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_44_3_range // DataConnectionIndication.DataVolumeDownlink 
{
	@P_FSG_40_0_0_44_3 = @P_FSG_40_0_0_44_3_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_44_3 // DataConnectionIndication.DataVolumeDownlink
{
	P_FSG_40_0_0_44_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_45_ErrCode
{
       if(gP_FSG_40_0_0_45_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_45", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_45_ErrCode = 1;
}
on envVar P_FSG_40_0_0_45Status_BTN
{
	byte BAPTemp[4];
   if (P_FSG_40_0_0_45Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_40_0_0_45_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_45",MakeRGB(255,255,255));
      P_FSG_40_0_0_45Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_40_0_0_45, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_40_0_0_45_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_45));
      P_FSG_40_0_0_45Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_40_0_0_45_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_45_ID;
    data[2]=getValue(P_FSG_40_0_0_45_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_45
on envVar P_FSG_40_0_0_45_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_45",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_45",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_45",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_45", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_45",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_45",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_45",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_45", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_45 // bus value of MissedCallIndication (45).
{
	// opcodes: Error-Status
	word param1; // MissedCalls
	word param2; // MissedNumbers
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[4];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 4; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_45, superval);
	///////// Start param1 - UINT16 /////////
	param1 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_45_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_45_2, round((param2 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_45_1_range // MissedCallIndication.MissedCalls 
{
	@P_FSG_40_0_0_45_1 = @P_FSG_40_0_0_45_1_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_45_1 // MissedCallIndication.MissedCalls
{
	byte superval[4];

	//Update Childvalue (Number)
	word thisval; // MissedCalls
	float slider_value;

	slider_value = round(@P_FSG_40_0_0_45_1, 1.0);
	@P_FSG_40_0_0_45_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_40_0_0_45, superval);
	superval[0]=thisval&0x00ff;
	superval[1]=(thisval&0xff00)>>8;
	putValue(P_FSG_40_0_0_45,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_45_2_range // MissedCallIndication.MissedNumbers 
{
	@P_FSG_40_0_0_45_2 = @P_FSG_40_0_0_45_2_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_45_2 // MissedCallIndication.MissedNumbers
{
	byte superval[4];

	//Update Childvalue (Number)
	word thisval; // MissedNumbers
	float slider_value;

	slider_value = round(@P_FSG_40_0_0_45_2, 1.0);
	@P_FSG_40_0_0_45_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_40_0_0_45, superval);
	superval[2]=thisval&0x00ff;
	superval[3]=(thisval&0xff00)>>8;
	putValue(P_FSG_40_0_0_45,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_40_0_0_46_ErrCode
{
       if(gA_FSG_40_0_0_46_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_46", MakeRGB(255,255,255));
       }
       gA_FSG_40_0_0_46_ErrCode = 1;
}
on envVar A_FSG_40_0_0_46Changed_BTN
{
    byte data[607]; 
    byte stringValue[607];
    byte head[5];
    int i;
    int headLength;
    long tempValue;
    word currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_40_0_0_46Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_46_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_46",MakeRGB(255,255,255));
        A_FSG_40_0_0_46Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_46_Changed);
        getValue(A_FSG_40_0_0_46_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_46_Changed_Start);
     elementsVal = getValue(A_FSG_40_0_0_46_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_46_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 46");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_46_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_46_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 46");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_40_0_0_46_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_40_0_0_46_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_40_0_0_46_ID);
       }
       if(getValue(A_FSG_40_0_0_46_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_40_0_0_46_ID,getValueSize(A_FSG_40_0_0_46_Changed));
       }
        A_FSG_40_0_0_46Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_46Status_BTN
{
    byte data[607 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[607];
    byte head[5];
    int i = 0;
    int j = 0;
    long StringLength = 0;
    int headLength;
    long tempValue;
    word currentPos;

    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_40_0_0_46Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_46_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_46",MakeRGB(255,255,255));
        A_FSG_40_0_0_46Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_46_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_46_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_46_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_46);
        getValue(A_FSG_40_0_0_46,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_46_Start);
     elementsVal = getValue(A_FSG_40_0_0_46_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_46_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 46");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 1 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_46_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_46_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 1 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_46_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_46_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_46_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_46_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 46");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 1 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_46_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_46_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 1 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_46_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_46_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_40_0_0_46, data);
        Request_ByteSequence(LSGID, A_FSG_40_0_0_46_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_40_0_0_46_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_40_0_0_46_ID);
        }
        if(getValue(A_FSG_40_0_0_46_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_40_0_0_46_ID,getValueSize(A_FSG_40_0_0_46));
        }
        A_FSG_40_0_0_46Status_BTN_already_pressed = 0;
    }
}
A_FSG_40_0_0_46_SendStatus()
{
    word currentPos;
    word headLength;
    int i;
    int j;
    word StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[607];
    byte stringValue[607];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_46_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_46_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_46_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_46);
        getValue(A_FSG_40_0_0_46,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_46_Start);
     elementsVal = getValue(A_FSG_40_0_0_46_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_46_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 46");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 1 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_46_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_46_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 1 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_46_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_46_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_46_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_46_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 46");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 1 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_46_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_46_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 1 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_46_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_46_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_46_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_46_RecAdr ) || 2 == getValue( A_FSG_40_0_0_46_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_46_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_40_0_0_46_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_40_0_0_46
{
    byte temp[607];
    getValue(A_FSG_40_0_0_46, temp);
    putValue(A_FSG_40_0_0_46_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_46_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_46_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_46_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_46_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_40_0_0_46_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_40_0_0_46_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_46_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_46_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_46_IndexSize))
    {
        putValue(A_FSG_40_0_0_46_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_40_0_0_46_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_40_0_0_46_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_40_0_0_46_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_40_0_0_46_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_46_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_46_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_46_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_46_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_46_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_46_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_46_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_46_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_46_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_46_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_46_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_46_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_46_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_40_0_0_46, head, headLength); 
}

on envVar A_FSG_40_0_0_46_RecAdr
{
    A_FSG_40_0_0_46_GenerateStatus();
}

on envVar A_FSG_40_0_0_46_Shift
{
    A_FSG_40_0_0_46_GenerateStatus();
}

on envVar A_FSG_40_0_0_46_Direction
{
    A_FSG_40_0_0_46_GenerateStatus();
}

on envVar A_FSG_40_0_0_46_Start
{
    A_FSG_40_0_0_46_GenerateStatus();
}

on envVar A_FSG_40_0_0_46_Elements
{
    A_FSG_40_0_0_46_GenerateStatus();
}

on envVar A_FSG_40_0_0_46_IndexSize
{
    A_FSG_40_0_0_46_GenerateStatus();
}
on envVar A_FSG_40_0_0_46_TransPos
{
    A_FSG_40_0_0_46_GenerateStatus();
}
A_FSG_40_0_0_46_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_46_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_46_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_46_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_46_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_46_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_46_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_46_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_46_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_46_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_46_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_46_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_40_0_0_46_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_46_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_46_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_40_0_0_46_Changed, head, 3); 
    }
}

on envVar A_FSG_40_0_0_46_Changed_RecAdr
{
    A_FSG_40_0_0_46_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_46_Changed_Shift
{
    A_FSG_40_0_0_46_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_46_Changed_Direction
{
    A_FSG_40_0_0_46_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_46_Changed_Start
{
    A_FSG_40_0_0_46_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_46_Changed_Elements
{
    A_FSG_40_0_0_46_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_46_Changed_IndexSize
{
    A_FSG_40_0_0_46_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_46_Changed_TransPos
{
    A_FSG_40_0_0_46_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_46_SetGet
{
    byte temp[607];
    getValue(A_FSG_40_0_0_46_SetGet, temp);
    putValue(A_FSG_40_0_0_46_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_46_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_46_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_46_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_46_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_46_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_46_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_46_SetGet_IndexSize))
    {
        putValue(A_FSG_40_0_0_46_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_40_0_0_46_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_40_0_0_46_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_40_0_0_46_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_40_0_0_46_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp3[25];
	char temp5[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_40_0_0_46_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_40_0_0_46_ArrayDataList[i].Param1 = 0;
		for(j=0; j<100; j++)
			A_FSG_40_0_0_46_ArrayDataList[i].Param2[j] = 0;
		A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length = 0;
		A_FSG_40_0_0_46_Data_2_LenList[i] = 0;
		A_FSG_40_0_0_46_ArrayDataList[i].Param3 = 0;
		for(j=0; j<41; j++)
			A_FSG_40_0_0_46_ArrayDataList[i].Param4[j] = 0;
		A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length = 0;
		A_FSG_40_0_0_46_Data_4_LenList[i] = 0;
		A_FSG_40_0_0_46_ArrayDataList[i].Param5 = 0;
		A_FSG_40_0_0_46_ArrayDataList[i].Param6 = 0;
		A_FSG_40_0_0_46_ArrayDataList[i].Param7 = 0;
		A_FSG_40_0_0_46_ArrayDataList[i].Param8 = 0;
		A_FSG_40_0_0_46_ArrayDataList[i].Param9 = 0;
		A_FSG_40_0_0_46_ArrayDataList[i].Param10 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_40_0_0_46_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 61) //ignore first line in *.csv file
					{
						A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //NumberType
						A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //Day
						A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //Month
						A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param7 = atol(temp7); //Year
						A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param8 = atol(temp8); //Hour
						A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param9 = atol(temp9); //Minute
						A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param10 = atol(temp10); //Second
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp3[i]=0;
							temp5[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 61)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PbName
								if(paramPos < 99)
								{
									A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //NumberType
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //TelNumber
								if(paramPos < 40)
								{
									A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_46_ArrayDataList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 5: //Day
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //Month
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //Year
								if( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //Hour
								if( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //Minute
								if( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //Second
								if( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_40_0_0_46_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_40_0_0_46_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_46_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_40_0_0_46_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_40_0_0_46_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_40_0_0_46_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_40_0_0_46_Data_1, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_46_Data_2, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param2, A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_46_Data_3, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_46_Data_4, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param4, A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param4_Length);
	putValue(A_FSG_40_0_0_46_Data_5, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param5);
	putValue(A_FSG_40_0_0_46_Data_6, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param6);
	putValue(A_FSG_40_0_0_46_Data_7, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param7);
	putValue(A_FSG_40_0_0_46_Data_8, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param8);
	putValue(A_FSG_40_0_0_46_Data_9, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param9);
	putValue(A_FSG_40_0_0_46_Data_10, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param10);
}


on envVar A_FSG_40_0_0_46_generateData_Btn
{
	word i;
	dword elementsArray[12] = {2, 100, 2, 1, 41, 2, 1, 1, 1, 1, 1, 1};
	byte elementsTypeArray[12] = {0, 0xE, 0xF, 0, 0xE, 0xF, 0, 0, 0, 0, 0, 0};
	dword elementsMaxSizeArray[12] = {65535, 0, 0, 0xFF, 0, 0, 254, 11, 99, 23, 59, 59};
	byte tempArray[9240];
	if (A_FSG_40_0_0_46_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_46_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 46, 60 );
		for(i = 0; i < 60; i++)
		{
			memcpy(A_FSG_40_0_0_46_ArrayDataList[i], tempArray, (i * 154) );
			if(A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length > 127 )
				A_FSG_40_0_0_46_Data_2_CntList[i] = 1;
			if(A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length > 127 )
				A_FSG_40_0_0_46_Data_4_CntList[i] = 1;
		}
		A_FSG_40_0_0_46_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_40_0_0_46_Data_1, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_46_Data_2, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param2, A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_46_Data_3, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_46_Data_4, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param4, A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param4_Length);
	putValue(A_FSG_40_0_0_46_Data_5, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param5);
	putValue(A_FSG_40_0_0_46_Data_6, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param6);
	putValue(A_FSG_40_0_0_46_Data_7, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param7);
	putValue(A_FSG_40_0_0_46_Data_8, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param8);
	putValue(A_FSG_40_0_0_46_Data_9, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param9);
	putValue(A_FSG_40_0_0_46_Data_10, A_FSG_40_0_0_46_ArrayDataList[ getValue( A_FSG_40_0_0_46_DataIndex) ].Param10);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_40_0_0_46_DataIndex
{
    long index;
    long maxIndex = 60-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_46_Data_1, A_FSG_40_0_0_46_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_46_Data_2_len, A_FSG_40_0_0_46_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_46_Data_2_cnt, A_FSG_40_0_0_46_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_46_Data_2, A_FSG_40_0_0_46_ArrayDataList[index].Param2, A_FSG_40_0_0_46_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_46_Data_3, A_FSG_40_0_0_46_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_46_Data_4_len, A_FSG_40_0_0_46_Data_4_LenList[index]);
    putValue(A_FSG_40_0_0_46_Data_4_cnt, A_FSG_40_0_0_46_Data_4_CntList[index]);
    putValue(A_FSG_40_0_0_46_Data_4, A_FSG_40_0_0_46_ArrayDataList[index].Param4, A_FSG_40_0_0_46_ArrayDataList[index].Param4_Length);
    putValue(A_FSG_40_0_0_46_Data_5, A_FSG_40_0_0_46_ArrayDataList[index].Param5);
    putValue(A_FSG_40_0_0_46_Data_6, A_FSG_40_0_0_46_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_46_Data_7, A_FSG_40_0_0_46_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_46_Data_8, A_FSG_40_0_0_46_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_46_Data_9, A_FSG_40_0_0_46_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_46_Data_10, A_FSG_40_0_0_46_ArrayDataList[index].Param10);

}
on envVar A_FSG_40_0_0_46_DataIndex_Incr
{
    long index;
    if(A_FSG_40_0_0_46_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_46_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_46_DataIndex);
        index++;
        putValue(A_FSG_40_0_0_46_DataIndex, index);
        A_FSG_40_0_0_46_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_46_DataIndex_Decr
{
    long index;
    if(A_FSG_40_0_0_46_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_46_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_46_DataIndex);
        index--;
        putValue(A_FSG_40_0_0_46_DataIndex, index);
        A_FSG_40_0_0_46_DataIndex_Decr_already_pressed = 0;
    }
}
// HME generateCaplOnEnv (3160)
on envVar A_FSG_40_0_0_46_DataIndex_SetGet
{
    long index;
    long maxIndex = 60-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_46_Data_1_SetGet, A_FSG_40_0_0_46_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_46_Data_2_SetGet_len, A_FSG_40_0_0_46_Data_2_SetGet_LenList[index]);
    putValue(A_FSG_40_0_0_46_Data_2_SetGet_cnt, A_FSG_40_0_0_46_Data_2_SetGet_CntList[index]);
    putValue(A_FSG_40_0_0_46_Data_2_SetGet, A_FSG_40_0_0_46_ArrayDataList[index].Param2, A_FSG_40_0_0_46_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_46_Data_3_SetGet, A_FSG_40_0_0_46_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_46_Data_4_SetGet_len, A_FSG_40_0_0_46_Data_4_SetGet_LenList[index]);
    putValue(A_FSG_40_0_0_46_Data_4_SetGet_cnt, A_FSG_40_0_0_46_Data_4_SetGet_CntList[index]);
    putValue(A_FSG_40_0_0_46_Data_4_SetGet, A_FSG_40_0_0_46_ArrayDataList[index].Param4, A_FSG_40_0_0_46_ArrayDataList[index].Param4_Length);
    putValue(A_FSG_40_0_0_46_Data_5_SetGet, A_FSG_40_0_0_46_ArrayDataList[index].Param5);
    putValue(A_FSG_40_0_0_46_Data_6_SetGet, A_FSG_40_0_0_46_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_46_Data_7_SetGet, A_FSG_40_0_0_46_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_46_Data_8_SetGet, A_FSG_40_0_0_46_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_46_Data_9_SetGet, A_FSG_40_0_0_46_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_46_Data_10_SetGet, A_FSG_40_0_0_46_ArrayDataList[index].Param10);

}
on envVar A_FSG_40_0_0_46_DataIndex_SetGet_Incr
{
    long index;
    if(A_FSG_40_0_0_46_DataIndex_SetGet_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_46_DataIndex_SetGet_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_46_DataIndex_SetGet);
        index++;
        putValue(A_FSG_40_0_0_46_DataIndex_SetGet, index);
        A_FSG_40_0_0_46_DataIndex_SetGet_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_46_DataIndex_SetGet_Decr
{
    long index;
    if(A_FSG_40_0_0_46_DataIndex_SetGet_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_46_DataIndex_SetGet_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_46_DataIndex_SetGet);
        index--;
        putValue(A_FSG_40_0_0_46_DataIndex_SetGet, index);
        A_FSG_40_0_0_46_DataIndex_SetGet_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_46_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_40_0_0_46_ID;
    data[2]=getValue(A_FSG_40_0_0_46_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_40_0_0_46
on envVar A_FSG_40_0_0_46_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_46",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_46",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_46",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_46_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_46", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_46",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_46",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_46",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_46_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_46", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_46_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_46_SegmEn,0);
           intertelegram_err(A_FSG_40_0_0_46_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_40_0_0_46_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_46_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_46_IntTlgEn,0);
           sequence_err(A_FSG_40_0_0_46_ID,getValueSize(A_FSG_40_0_0_46_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_40_0_0_46_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_40_0_0_46_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_40_0_0_46_Status",1);
 	}
}



A_FSG_40_0_0_46_SetInd () { /* leere Function*/ }

A_FSG_40_0_0_46_SetGetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[607];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_46_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_46_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_46_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_46_AT))
                {
                    putValue(A_FSG_40_0_0_46,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_46_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_46_AT))
            {
                putValue(A_FSG_40_0_0_46,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_46_AT))
        {
            putValue(A_FSG_40_0_0_46_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_46_Start, startVal);
            putValue(A_FSG_40_0_0_46_Elements, elementsVal);
            putValue(A_FSG_40_0_0_46_TransPos, transmitPosVal);
        }
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_FSG_40_0_0_46_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 46");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_40_0_0_46_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_40_0_0_46_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_46_Data_2_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_46_Data_2_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length; j++)
        {
            A_FSG_40_0_0_46_ArrayDataList[i].Param2[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_46_Data_4_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_46_Data_4_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length; j++)
        {
            A_FSG_40_0_0_46_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_FSG_40_0_0_46_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_FSG_40_0_0_46_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 46");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_40_0_0_46_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_40_0_0_46_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_46_Data_2_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_46_Data_2_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_46_ArrayDataList[i].Param2_Length; j++)
        {
            A_FSG_40_0_0_46_ArrayDataList[i].Param2[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_46_Data_4_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_46_Data_4_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_46_ArrayDataList[i].Param4_Length; j++)
        {
            A_FSG_40_0_0_46_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_46_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_FSG_40_0_0_46_DataIndex);
    putValue(A_FSG_40_0_0_46_Data_1, A_FSG_40_0_0_46_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_46_Data_2_len, A_FSG_40_0_0_46_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_46_Data_2_cnt, A_FSG_40_0_0_46_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_46_Data_2, A_FSG_40_0_0_46_ArrayDataList[index].Param2, A_FSG_40_0_0_46_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_46_Data_3, A_FSG_40_0_0_46_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_46_Data_4_len, A_FSG_40_0_0_46_Data_4_LenList[index]);
    putValue(A_FSG_40_0_0_46_Data_4_cnt, A_FSG_40_0_0_46_Data_4_CntList[index]);
    putValue(A_FSG_40_0_0_46_Data_4, A_FSG_40_0_0_46_ArrayDataList[index].Param4, A_FSG_40_0_0_46_ArrayDataList[index].Param4_Length);
    putValue(A_FSG_40_0_0_46_Data_5, A_FSG_40_0_0_46_ArrayDataList[index].Param5);
    putValue(A_FSG_40_0_0_46_Data_6, A_FSG_40_0_0_46_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_46_Data_7, A_FSG_40_0_0_46_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_46_Data_8, A_FSG_40_0_0_46_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_46_Data_9, A_FSG_40_0_0_46_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_46_Data_10, A_FSG_40_0_0_46_ArrayDataList[index].Param10);
}

A_FSG_40_0_0_46_GetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[607];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_46_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_46_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_46_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_46_AT))
                {
                    putValue(A_FSG_40_0_0_46,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_46_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_46_AT))
            {
                putValue(A_FSG_40_0_0_46,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_46_AT))
        {
            putValue(A_FSG_40_0_0_46_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_46_Start, startVal);
            putValue(A_FSG_40_0_0_46_Elements, elementsVal);
            putValue(A_FSG_40_0_0_46_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_40_0_0_46_1
{
	byte superval[607];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_2_range // MissedCalls.TAID 
{
	@A_FSG_40_0_0_46_2 = @A_FSG_40_0_0_46_2_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_2
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_2, 1.0);
	@A_FSG_40_0_0_46_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_3_range // MissedCalls.TotalNumListElements 
{
	@A_FSG_40_0_0_46_3 = @A_FSG_40_0_0_46_3_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_3
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_3, 1.0);
	@A_FSG_40_0_0_46_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_1_range // MissedCalls.Pos 
{
	@A_FSG_40_0_0_46_Data_1 = @A_FSG_40_0_0_46_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_1
{
	byte superval[607];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_1, 1.0);
	@A_FSG_40_0_0_46_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_46_Data_2_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_46_Data_2_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_46_Data_2_CntList[ getValue(A_FSG_40_0_0_46_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_46_Data_2_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_46_Data_2_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_46_Data_2_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_46_Data_2_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param2_Length = thisval;
	A_FSG_40_0_0_46_Data_2_LenList[ getValue(A_FSG_40_0_0_46_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_46_Data_2_len, thisval);

}

on envVar A_FSG_40_0_0_46_Data_2
{
	byte superval[607];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param2[i] = thisval[i];
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_46_Data_2_LenList[getValue(A_FSG_40_0_0_46_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_46_Data_2_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_46_Data_3
{
	byte superval[607];

	//Update Childvalue (Enum)
	byte thisval; // NumberType
	thisval = getValue(this);
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_46_Data_4_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_46_Data_4_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_46_Data_4_CntList[ getValue(A_FSG_40_0_0_46_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_46_Data_4_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_46_Data_4_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_46_Data_4_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 40 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 40);
		thisval = 40;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_46_Data_4_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param4_Length = thisval;
	A_FSG_40_0_0_46_Data_4_LenList[ getValue(A_FSG_40_0_0_46_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_46_Data_4_len, thisval);

}

on envVar A_FSG_40_0_0_46_Data_4
{
	byte superval[607];

	//Update Childvalue (String)
	word i;
	byte thisval[41];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param4[i] = thisval[i];
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param4_Length = getValueSize(this);
    A_FSG_40_0_0_46_Data_4_LenList[getValue(A_FSG_40_0_0_46_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_46_Data_4_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_5_range // MissedCalls.Day 
{
	@A_FSG_40_0_0_46_Data_5 = @A_FSG_40_0_0_46_Data_5_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_5
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Day
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_5, 1.0);
	@A_FSG_40_0_0_46_Data_5_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param5 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_6_range // MissedCalls.Month 
{
	@A_FSG_40_0_0_46_Data_6 = @A_FSG_40_0_0_46_Data_6_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_6
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Month
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_6, 1.0);
	@A_FSG_40_0_0_46_Data_6_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param6 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_7_range // MissedCalls.Year 
{
	@A_FSG_40_0_0_46_Data_7 = @A_FSG_40_0_0_46_Data_7_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_7
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Year
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_7, 1.0);
	@A_FSG_40_0_0_46_Data_7_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param7 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_8_range // MissedCalls.Hour 
{
	@A_FSG_40_0_0_46_Data_8 = @A_FSG_40_0_0_46_Data_8_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_8
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_8, 1.0);
	@A_FSG_40_0_0_46_Data_8_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param8 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_9_range // MissedCalls.Minute 
{
	@A_FSG_40_0_0_46_Data_9 = @A_FSG_40_0_0_46_Data_9_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_9
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_9, 1.0);
	@A_FSG_40_0_0_46_Data_9_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param9 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_10_range // MissedCalls.Second 
{
	@A_FSG_40_0_0_46_Data_10 = @A_FSG_40_0_0_46_Data_10_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_10
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Second
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_10, 1.0);
	@A_FSG_40_0_0_46_Data_10_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex)].Param10 = thisval;
}
on envVar A_FSG_40_0_0_46_1_SetGet
{
	byte superval[8];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_2_SetGet_range // MissedCalls.TAID 
{
	@A_FSG_40_0_0_46_2_SetGet = @A_FSG_40_0_0_46_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_2_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_2_SetGet, 1.0);
	@A_FSG_40_0_0_46_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_1_SetGet_range // MissedCalls.Pos 
{
	@A_FSG_40_0_0_46_Data_1_SetGet = @A_FSG_40_0_0_46_Data_1_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_1_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_1_SetGet, 1.0);
	@A_FSG_40_0_0_46_Data_1_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_46_Data_2_SetGet_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_46_Data_2_SetGet_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_46_Data_2_SetGet_CntList[ getValue(A_FSG_40_0_0_46_DataIndex_SetGet) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_46_Data_2_SetGet_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_46_Data_2_SetGet_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_46_Data_2_SetGet_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_2_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_46_Data_2_SetGet_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param2_Length = thisval;
	A_FSG_40_0_0_46_Data_2_SetGet_LenList[ getValue(A_FSG_40_0_0_46_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_40_0_0_46_Data_2_SetGet_len, thisval);

}

on envVar A_FSG_40_0_0_46_Data_2_SetGet
{
	byte superval[8];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param2[i] = thisval[i];
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_46_Data_2_SetGet_LenList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_40_0_0_46_Data_2_SetGet_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_46_Data_3_SetGet
{
	byte superval[8];

	//Update Childvalue (Enum)
	byte thisval; // NumberType
	thisval = getValue(this);
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_46_Data_4_SetGet_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_46_Data_4_SetGet_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_46_Data_4_SetGet_CntList[ getValue(A_FSG_40_0_0_46_DataIndex_SetGet) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_46_Data_4_SetGet_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_46_Data_4_SetGet_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_46_Data_4_SetGet_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 40 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_46_Data_4_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 40);
		thisval = 40;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_46_Data_4_SetGet_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param4_Length = thisval;
	A_FSG_40_0_0_46_Data_4_SetGet_LenList[ getValue(A_FSG_40_0_0_46_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_40_0_0_46_Data_4_SetGet_len, thisval);

}

on envVar A_FSG_40_0_0_46_Data_4_SetGet
{
	byte superval[8];

	//Update Childvalue (String)
	word i;
	byte thisval[41];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param4[i] = thisval[i];
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param4_Length = getValueSize(this);
    A_FSG_40_0_0_46_Data_4_SetGet_LenList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_40_0_0_46_Data_4_SetGet_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_5_SetGet_range // MissedCalls.Day 
{
	@A_FSG_40_0_0_46_Data_5_SetGet = @A_FSG_40_0_0_46_Data_5_SetGet_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_5_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Day
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_5_SetGet, 1.0);
	@A_FSG_40_0_0_46_Data_5_SetGet_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param5 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_6_SetGet_range // MissedCalls.Month 
{
	@A_FSG_40_0_0_46_Data_6_SetGet = @A_FSG_40_0_0_46_Data_6_SetGet_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_6_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Month
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_6_SetGet, 1.0);
	@A_FSG_40_0_0_46_Data_6_SetGet_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param6 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_7_SetGet_range // MissedCalls.Year 
{
	@A_FSG_40_0_0_46_Data_7_SetGet = @A_FSG_40_0_0_46_Data_7_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_7_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Year
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_7_SetGet, 1.0);
	@A_FSG_40_0_0_46_Data_7_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param7 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_8_SetGet_range // MissedCalls.Hour 
{
	@A_FSG_40_0_0_46_Data_8_SetGet = @A_FSG_40_0_0_46_Data_8_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_8_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_8_SetGet, 1.0);
	@A_FSG_40_0_0_46_Data_8_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param8 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_9_SetGet_range // MissedCalls.Minute 
{
	@A_FSG_40_0_0_46_Data_9_SetGet = @A_FSG_40_0_0_46_Data_9_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_9_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_9_SetGet, 1.0);
	@A_FSG_40_0_0_46_Data_9_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param9 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_46_Data_10_SetGet_range // MissedCalls.Second 
{
	@A_FSG_40_0_0_46_Data_10_SetGet = @A_FSG_40_0_0_46_Data_10_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_46_Data_10_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Second
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_46_Data_10_SetGet, 1.0);
	@A_FSG_40_0_0_46_Data_10_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_46_ArrayDataList[getValue(A_FSG_40_0_0_46_DataIndex_SetGet)].Param10 = thisval;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_40_0_0_47_ErrCode
{
       if(gA_FSG_40_0_0_47_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_47", MakeRGB(255,255,255));
       }
       gA_FSG_40_0_0_47_ErrCode = 1;
}
on envVar A_FSG_40_0_0_47Changed_BTN
{
    byte data[607]; 
    byte stringValue[607];
    byte head[5];
    int i;
    int headLength;
    long tempValue;
    word currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_40_0_0_47Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_47_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_47",MakeRGB(255,255,255));
        A_FSG_40_0_0_47Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_47_Changed);
        getValue(A_FSG_40_0_0_47_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_47_Changed_Start);
     elementsVal = getValue(A_FSG_40_0_0_47_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_47_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 47");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_47_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_47_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 47");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_40_0_0_47_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_40_0_0_47_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_40_0_0_47_ID);
       }
       if(getValue(A_FSG_40_0_0_47_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_40_0_0_47_ID,getValueSize(A_FSG_40_0_0_47_Changed));
       }
        A_FSG_40_0_0_47Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_47Status_BTN
{
    byte data[607 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[607];
    byte head[5];
    int i = 0;
    int j = 0;
    long StringLength = 0;
    int headLength;
    long tempValue;
    word currentPos;

    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_40_0_0_47Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_47_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_47",MakeRGB(255,255,255));
        A_FSG_40_0_0_47Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_47_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_47_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_47_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_47);
        getValue(A_FSG_40_0_0_47,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_47_Start);
     elementsVal = getValue(A_FSG_40_0_0_47_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_47_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 47");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 1 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_47_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_47_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 1 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_47_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_47_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_47_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_47_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 47");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 1 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_47_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_47_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 1 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_47_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_47_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_40_0_0_47, data);
        Request_ByteSequence(LSGID, A_FSG_40_0_0_47_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_40_0_0_47_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_40_0_0_47_ID);
        }
        if(getValue(A_FSG_40_0_0_47_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_40_0_0_47_ID,getValueSize(A_FSG_40_0_0_47));
        }
        A_FSG_40_0_0_47Status_BTN_already_pressed = 0;
    }
}
A_FSG_40_0_0_47_SendStatus()
{
    word currentPos;
    word headLength;
    int i;
    int j;
    word StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[607];
    byte stringValue[607];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_47_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_47_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_47_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_47);
        getValue(A_FSG_40_0_0_47,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_47_Start);
     elementsVal = getValue(A_FSG_40_0_0_47_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_47_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 47");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 1 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_47_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_47_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 1 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_47_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_47_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_47_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_47_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 47");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 1 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_47_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_47_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 1 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_47_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_47_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_47_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_47_RecAdr ) || 2 == getValue( A_FSG_40_0_0_47_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_47_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_40_0_0_47_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_40_0_0_47
{
    byte temp[607];
    getValue(A_FSG_40_0_0_47, temp);
    putValue(A_FSG_40_0_0_47_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_47_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_47_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_47_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_47_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_40_0_0_47_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_40_0_0_47_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_47_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_47_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_47_IndexSize))
    {
        putValue(A_FSG_40_0_0_47_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_40_0_0_47_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_40_0_0_47_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_40_0_0_47_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_40_0_0_47_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_47_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_47_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_47_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_47_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_47_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_47_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_47_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_47_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_47_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_47_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_47_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_47_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_47_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_40_0_0_47, head, headLength); 
}

on envVar A_FSG_40_0_0_47_RecAdr
{
    A_FSG_40_0_0_47_GenerateStatus();
}

on envVar A_FSG_40_0_0_47_Shift
{
    A_FSG_40_0_0_47_GenerateStatus();
}

on envVar A_FSG_40_0_0_47_Direction
{
    A_FSG_40_0_0_47_GenerateStatus();
}

on envVar A_FSG_40_0_0_47_Start
{
    A_FSG_40_0_0_47_GenerateStatus();
}

on envVar A_FSG_40_0_0_47_Elements
{
    A_FSG_40_0_0_47_GenerateStatus();
}

on envVar A_FSG_40_0_0_47_IndexSize
{
    A_FSG_40_0_0_47_GenerateStatus();
}
on envVar A_FSG_40_0_0_47_TransPos
{
    A_FSG_40_0_0_47_GenerateStatus();
}
A_FSG_40_0_0_47_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_47_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_47_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_47_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_47_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_47_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_47_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_47_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_47_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_47_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_47_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_47_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_40_0_0_47_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_47_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_47_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_40_0_0_47_Changed, head, 3); 
    }
}

on envVar A_FSG_40_0_0_47_Changed_RecAdr
{
    A_FSG_40_0_0_47_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_47_Changed_Shift
{
    A_FSG_40_0_0_47_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_47_Changed_Direction
{
    A_FSG_40_0_0_47_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_47_Changed_Start
{
    A_FSG_40_0_0_47_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_47_Changed_Elements
{
    A_FSG_40_0_0_47_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_47_Changed_IndexSize
{
    A_FSG_40_0_0_47_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_47_Changed_TransPos
{
    A_FSG_40_0_0_47_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_47_SetGet
{
    byte temp[607];
    getValue(A_FSG_40_0_0_47_SetGet, temp);
    putValue(A_FSG_40_0_0_47_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_47_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_47_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_47_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_47_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_47_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_47_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_47_SetGet_IndexSize))
    {
        putValue(A_FSG_40_0_0_47_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_40_0_0_47_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_40_0_0_47_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_40_0_0_47_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_40_0_0_47_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp3[25];
	char temp5[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_40_0_0_47_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_40_0_0_47_ArrayDataList[i].Param1 = 0;
		for(j=0; j<100; j++)
			A_FSG_40_0_0_47_ArrayDataList[i].Param2[j] = 0;
		A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length = 0;
		A_FSG_40_0_0_47_Data_2_LenList[i] = 0;
		A_FSG_40_0_0_47_ArrayDataList[i].Param3 = 0;
		for(j=0; j<41; j++)
			A_FSG_40_0_0_47_ArrayDataList[i].Param4[j] = 0;
		A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length = 0;
		A_FSG_40_0_0_47_Data_4_LenList[i] = 0;
		A_FSG_40_0_0_47_ArrayDataList[i].Param5 = 0;
		A_FSG_40_0_0_47_ArrayDataList[i].Param6 = 0;
		A_FSG_40_0_0_47_ArrayDataList[i].Param7 = 0;
		A_FSG_40_0_0_47_ArrayDataList[i].Param8 = 0;
		A_FSG_40_0_0_47_ArrayDataList[i].Param9 = 0;
		A_FSG_40_0_0_47_ArrayDataList[i].Param10 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_40_0_0_47_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 61) //ignore first line in *.csv file
					{
						A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //NumberType
						A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //Day
						A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //Month
						A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param7 = atol(temp7); //Year
						A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param8 = atol(temp8); //Hour
						A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param9 = atol(temp9); //Minute
						A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param10 = atol(temp10); //Second
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp3[i]=0;
							temp5[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 61)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PbName
								if(paramPos < 99)
								{
									A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //NumberType
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //TelNumber
								if(paramPos < 40)
								{
									A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_47_ArrayDataList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 5: //Day
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //Month
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //Year
								if( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //Hour
								if( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //Minute
								if( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //Second
								if( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_40_0_0_47_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_40_0_0_47_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_47_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_40_0_0_47_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_40_0_0_47_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_40_0_0_47_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_40_0_0_47_Data_1, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_47_Data_2, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param2, A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_47_Data_3, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_47_Data_4, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param4, A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param4_Length);
	putValue(A_FSG_40_0_0_47_Data_5, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param5);
	putValue(A_FSG_40_0_0_47_Data_6, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param6);
	putValue(A_FSG_40_0_0_47_Data_7, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param7);
	putValue(A_FSG_40_0_0_47_Data_8, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param8);
	putValue(A_FSG_40_0_0_47_Data_9, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param9);
	putValue(A_FSG_40_0_0_47_Data_10, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param10);
}


on envVar A_FSG_40_0_0_47_generateData_Btn
{
	word i;
	dword elementsArray[12] = {2, 100, 2, 1, 41, 2, 1, 1, 1, 1, 1, 1};
	byte elementsTypeArray[12] = {0, 0xE, 0xF, 0, 0xE, 0xF, 0, 0, 0, 0, 0, 0};
	dword elementsMaxSizeArray[12] = {65535, 0, 0, 0xFF, 0, 0, 254, 11, 99, 23, 59, 59};
	byte tempArray[9240];
	if (A_FSG_40_0_0_47_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_47_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 47, 60 );
		for(i = 0; i < 60; i++)
		{
			memcpy(A_FSG_40_0_0_47_ArrayDataList[i], tempArray, (i * 154) );
			if(A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length > 127 )
				A_FSG_40_0_0_47_Data_2_CntList[i] = 1;
			if(A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length > 127 )
				A_FSG_40_0_0_47_Data_4_CntList[i] = 1;
		}
		A_FSG_40_0_0_47_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_40_0_0_47_Data_1, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_47_Data_2, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param2, A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_47_Data_3, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_47_Data_4, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param4, A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param4_Length);
	putValue(A_FSG_40_0_0_47_Data_5, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param5);
	putValue(A_FSG_40_0_0_47_Data_6, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param6);
	putValue(A_FSG_40_0_0_47_Data_7, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param7);
	putValue(A_FSG_40_0_0_47_Data_8, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param8);
	putValue(A_FSG_40_0_0_47_Data_9, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param9);
	putValue(A_FSG_40_0_0_47_Data_10, A_FSG_40_0_0_47_ArrayDataList[ getValue( A_FSG_40_0_0_47_DataIndex) ].Param10);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_40_0_0_47_DataIndex
{
    long index;
    long maxIndex = 60-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_47_Data_1, A_FSG_40_0_0_47_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_47_Data_2_len, A_FSG_40_0_0_47_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_47_Data_2_cnt, A_FSG_40_0_0_47_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_47_Data_2, A_FSG_40_0_0_47_ArrayDataList[index].Param2, A_FSG_40_0_0_47_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_47_Data_3, A_FSG_40_0_0_47_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_47_Data_4_len, A_FSG_40_0_0_47_Data_4_LenList[index]);
    putValue(A_FSG_40_0_0_47_Data_4_cnt, A_FSG_40_0_0_47_Data_4_CntList[index]);
    putValue(A_FSG_40_0_0_47_Data_4, A_FSG_40_0_0_47_ArrayDataList[index].Param4, A_FSG_40_0_0_47_ArrayDataList[index].Param4_Length);
    putValue(A_FSG_40_0_0_47_Data_5, A_FSG_40_0_0_47_ArrayDataList[index].Param5);
    putValue(A_FSG_40_0_0_47_Data_6, A_FSG_40_0_0_47_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_47_Data_7, A_FSG_40_0_0_47_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_47_Data_8, A_FSG_40_0_0_47_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_47_Data_9, A_FSG_40_0_0_47_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_47_Data_10, A_FSG_40_0_0_47_ArrayDataList[index].Param10);

}
on envVar A_FSG_40_0_0_47_DataIndex_Incr
{
    long index;
    if(A_FSG_40_0_0_47_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_47_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_47_DataIndex);
        index++;
        putValue(A_FSG_40_0_0_47_DataIndex, index);
        A_FSG_40_0_0_47_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_47_DataIndex_Decr
{
    long index;
    if(A_FSG_40_0_0_47_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_47_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_47_DataIndex);
        index--;
        putValue(A_FSG_40_0_0_47_DataIndex, index);
        A_FSG_40_0_0_47_DataIndex_Decr_already_pressed = 0;
    }
}
// HME generateCaplOnEnv (3160)
on envVar A_FSG_40_0_0_47_DataIndex_SetGet
{
    long index;
    long maxIndex = 60-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_47_Data_1_SetGet, A_FSG_40_0_0_47_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_47_Data_2_SetGet_len, A_FSG_40_0_0_47_Data_2_SetGet_LenList[index]);
    putValue(A_FSG_40_0_0_47_Data_2_SetGet_cnt, A_FSG_40_0_0_47_Data_2_SetGet_CntList[index]);
    putValue(A_FSG_40_0_0_47_Data_2_SetGet, A_FSG_40_0_0_47_ArrayDataList[index].Param2, A_FSG_40_0_0_47_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_47_Data_3_SetGet, A_FSG_40_0_0_47_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_47_Data_4_SetGet_len, A_FSG_40_0_0_47_Data_4_SetGet_LenList[index]);
    putValue(A_FSG_40_0_0_47_Data_4_SetGet_cnt, A_FSG_40_0_0_47_Data_4_SetGet_CntList[index]);
    putValue(A_FSG_40_0_0_47_Data_4_SetGet, A_FSG_40_0_0_47_ArrayDataList[index].Param4, A_FSG_40_0_0_47_ArrayDataList[index].Param4_Length);
    putValue(A_FSG_40_0_0_47_Data_5_SetGet, A_FSG_40_0_0_47_ArrayDataList[index].Param5);
    putValue(A_FSG_40_0_0_47_Data_6_SetGet, A_FSG_40_0_0_47_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_47_Data_7_SetGet, A_FSG_40_0_0_47_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_47_Data_8_SetGet, A_FSG_40_0_0_47_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_47_Data_9_SetGet, A_FSG_40_0_0_47_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_47_Data_10_SetGet, A_FSG_40_0_0_47_ArrayDataList[index].Param10);

}
on envVar A_FSG_40_0_0_47_DataIndex_SetGet_Incr
{
    long index;
    if(A_FSG_40_0_0_47_DataIndex_SetGet_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_47_DataIndex_SetGet_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_47_DataIndex_SetGet);
        index++;
        putValue(A_FSG_40_0_0_47_DataIndex_SetGet, index);
        A_FSG_40_0_0_47_DataIndex_SetGet_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_47_DataIndex_SetGet_Decr
{
    long index;
    if(A_FSG_40_0_0_47_DataIndex_SetGet_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_47_DataIndex_SetGet_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_47_DataIndex_SetGet);
        index--;
        putValue(A_FSG_40_0_0_47_DataIndex_SetGet, index);
        A_FSG_40_0_0_47_DataIndex_SetGet_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_47_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_40_0_0_47_ID;
    data[2]=getValue(A_FSG_40_0_0_47_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_40_0_0_47
on envVar A_FSG_40_0_0_47_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_47",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_47",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_47",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_47_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_47", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_47",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_47",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_47",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_47_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_47", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_47_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_47_SegmEn,0);
           intertelegram_err(A_FSG_40_0_0_47_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_40_0_0_47_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_47_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_47_IntTlgEn,0);
           sequence_err(A_FSG_40_0_0_47_ID,getValueSize(A_FSG_40_0_0_47_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_40_0_0_47_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_40_0_0_47_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_40_0_0_47_Status",1);
 	}
}



A_FSG_40_0_0_47_SetInd () { /* leere Function*/ }

A_FSG_40_0_0_47_SetGetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[607];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_47_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_47_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_47_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_47_AT))
                {
                    putValue(A_FSG_40_0_0_47,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_47_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_47_AT))
            {
                putValue(A_FSG_40_0_0_47,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_47_AT))
        {
            putValue(A_FSG_40_0_0_47_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_47_Start, startVal);
            putValue(A_FSG_40_0_0_47_Elements, elementsVal);
            putValue(A_FSG_40_0_0_47_TransPos, transmitPosVal);
        }
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_FSG_40_0_0_47_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 47");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_40_0_0_47_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_40_0_0_47_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_47_Data_2_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_47_Data_2_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length; j++)
        {
            A_FSG_40_0_0_47_ArrayDataList[i].Param2[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_47_Data_4_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_47_Data_4_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length; j++)
        {
            A_FSG_40_0_0_47_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_FSG_40_0_0_47_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_FSG_40_0_0_47_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 47");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_40_0_0_47_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_40_0_0_47_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_47_Data_2_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_47_Data_2_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_47_ArrayDataList[i].Param2_Length; j++)
        {
            A_FSG_40_0_0_47_ArrayDataList[i].Param2[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_47_Data_4_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_47_Data_4_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_47_ArrayDataList[i].Param4_Length; j++)
        {
            A_FSG_40_0_0_47_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_47_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_FSG_40_0_0_47_DataIndex);
    putValue(A_FSG_40_0_0_47_Data_1, A_FSG_40_0_0_47_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_47_Data_2_len, A_FSG_40_0_0_47_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_47_Data_2_cnt, A_FSG_40_0_0_47_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_47_Data_2, A_FSG_40_0_0_47_ArrayDataList[index].Param2, A_FSG_40_0_0_47_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_47_Data_3, A_FSG_40_0_0_47_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_47_Data_4_len, A_FSG_40_0_0_47_Data_4_LenList[index]);
    putValue(A_FSG_40_0_0_47_Data_4_cnt, A_FSG_40_0_0_47_Data_4_CntList[index]);
    putValue(A_FSG_40_0_0_47_Data_4, A_FSG_40_0_0_47_ArrayDataList[index].Param4, A_FSG_40_0_0_47_ArrayDataList[index].Param4_Length);
    putValue(A_FSG_40_0_0_47_Data_5, A_FSG_40_0_0_47_ArrayDataList[index].Param5);
    putValue(A_FSG_40_0_0_47_Data_6, A_FSG_40_0_0_47_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_47_Data_7, A_FSG_40_0_0_47_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_47_Data_8, A_FSG_40_0_0_47_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_47_Data_9, A_FSG_40_0_0_47_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_47_Data_10, A_FSG_40_0_0_47_ArrayDataList[index].Param10);
}

A_FSG_40_0_0_47_GetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[607];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_47_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_47_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_47_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_47_AT))
                {
                    putValue(A_FSG_40_0_0_47,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_47_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_47_AT))
            {
                putValue(A_FSG_40_0_0_47,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_47_AT))
        {
            putValue(A_FSG_40_0_0_47_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_47_Start, startVal);
            putValue(A_FSG_40_0_0_47_Elements, elementsVal);
            putValue(A_FSG_40_0_0_47_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_40_0_0_47_1
{
	byte superval[607];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_2_range // ReceivedCalls.TAID 
{
	@A_FSG_40_0_0_47_2 = @A_FSG_40_0_0_47_2_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_2
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_2, 1.0);
	@A_FSG_40_0_0_47_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_3_range // ReceivedCalls.TotalNumListElements 
{
	@A_FSG_40_0_0_47_3 = @A_FSG_40_0_0_47_3_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_3
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_3, 1.0);
	@A_FSG_40_0_0_47_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_1_range // ReceivedCalls.Pos 
{
	@A_FSG_40_0_0_47_Data_1 = @A_FSG_40_0_0_47_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_1
{
	byte superval[607];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_1, 1.0);
	@A_FSG_40_0_0_47_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_47_Data_2_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_47_Data_2_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_47_Data_2_CntList[ getValue(A_FSG_40_0_0_47_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_47_Data_2_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_47_Data_2_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_47_Data_2_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_47_Data_2_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param2_Length = thisval;
	A_FSG_40_0_0_47_Data_2_LenList[ getValue(A_FSG_40_0_0_47_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_47_Data_2_len, thisval);

}

on envVar A_FSG_40_0_0_47_Data_2
{
	byte superval[607];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param2[i] = thisval[i];
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_47_Data_2_LenList[getValue(A_FSG_40_0_0_47_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_47_Data_2_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_47_Data_3
{
	byte superval[607];

	//Update Childvalue (Enum)
	byte thisval; // NumberType
	thisval = getValue(this);
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_47_Data_4_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_47_Data_4_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_47_Data_4_CntList[ getValue(A_FSG_40_0_0_47_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_47_Data_4_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_47_Data_4_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_47_Data_4_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 40 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 40);
		thisval = 40;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_47_Data_4_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param4_Length = thisval;
	A_FSG_40_0_0_47_Data_4_LenList[ getValue(A_FSG_40_0_0_47_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_47_Data_4_len, thisval);

}

on envVar A_FSG_40_0_0_47_Data_4
{
	byte superval[607];

	//Update Childvalue (String)
	word i;
	byte thisval[41];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param4[i] = thisval[i];
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param4_Length = getValueSize(this);
    A_FSG_40_0_0_47_Data_4_LenList[getValue(A_FSG_40_0_0_47_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_47_Data_4_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_5_range // ReceivedCalls.Day 
{
	@A_FSG_40_0_0_47_Data_5 = @A_FSG_40_0_0_47_Data_5_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_5
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Day
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_5, 1.0);
	@A_FSG_40_0_0_47_Data_5_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param5 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_6_range // ReceivedCalls.Month 
{
	@A_FSG_40_0_0_47_Data_6 = @A_FSG_40_0_0_47_Data_6_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_6
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Month
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_6, 1.0);
	@A_FSG_40_0_0_47_Data_6_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param6 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_7_range // ReceivedCalls.Year 
{
	@A_FSG_40_0_0_47_Data_7 = @A_FSG_40_0_0_47_Data_7_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_7
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Year
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_7, 1.0);
	@A_FSG_40_0_0_47_Data_7_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param7 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_8_range // ReceivedCalls.Hour 
{
	@A_FSG_40_0_0_47_Data_8 = @A_FSG_40_0_0_47_Data_8_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_8
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_8, 1.0);
	@A_FSG_40_0_0_47_Data_8_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param8 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_9_range // ReceivedCalls.Minute 
{
	@A_FSG_40_0_0_47_Data_9 = @A_FSG_40_0_0_47_Data_9_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_9
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_9, 1.0);
	@A_FSG_40_0_0_47_Data_9_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param9 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_10_range // ReceivedCalls.Second 
{
	@A_FSG_40_0_0_47_Data_10 = @A_FSG_40_0_0_47_Data_10_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_10
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Second
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_10, 1.0);
	@A_FSG_40_0_0_47_Data_10_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex)].Param10 = thisval;
}
on envVar A_FSG_40_0_0_47_1_SetGet
{
	byte superval[8];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_2_SetGet_range // ReceivedCalls.TAID 
{
	@A_FSG_40_0_0_47_2_SetGet = @A_FSG_40_0_0_47_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_2_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_2_SetGet, 1.0);
	@A_FSG_40_0_0_47_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_1_SetGet_range // ReceivedCalls.Pos 
{
	@A_FSG_40_0_0_47_Data_1_SetGet = @A_FSG_40_0_0_47_Data_1_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_1_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_1_SetGet, 1.0);
	@A_FSG_40_0_0_47_Data_1_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_47_Data_2_SetGet_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_47_Data_2_SetGet_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_47_Data_2_SetGet_CntList[ getValue(A_FSG_40_0_0_47_DataIndex_SetGet) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_47_Data_2_SetGet_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_47_Data_2_SetGet_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_47_Data_2_SetGet_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_2_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_47_Data_2_SetGet_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param2_Length = thisval;
	A_FSG_40_0_0_47_Data_2_SetGet_LenList[ getValue(A_FSG_40_0_0_47_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_40_0_0_47_Data_2_SetGet_len, thisval);

}

on envVar A_FSG_40_0_0_47_Data_2_SetGet
{
	byte superval[8];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param2[i] = thisval[i];
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_47_Data_2_SetGet_LenList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_40_0_0_47_Data_2_SetGet_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_47_Data_3_SetGet
{
	byte superval[8];

	//Update Childvalue (Enum)
	byte thisval; // NumberType
	thisval = getValue(this);
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_47_Data_4_SetGet_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_47_Data_4_SetGet_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_47_Data_4_SetGet_CntList[ getValue(A_FSG_40_0_0_47_DataIndex_SetGet) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_47_Data_4_SetGet_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_47_Data_4_SetGet_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_47_Data_4_SetGet_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 40 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_47_Data_4_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 40);
		thisval = 40;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_47_Data_4_SetGet_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param4_Length = thisval;
	A_FSG_40_0_0_47_Data_4_SetGet_LenList[ getValue(A_FSG_40_0_0_47_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_40_0_0_47_Data_4_SetGet_len, thisval);

}

on envVar A_FSG_40_0_0_47_Data_4_SetGet
{
	byte superval[8];

	//Update Childvalue (String)
	word i;
	byte thisval[41];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param4[i] = thisval[i];
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param4_Length = getValueSize(this);
    A_FSG_40_0_0_47_Data_4_SetGet_LenList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_40_0_0_47_Data_4_SetGet_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_5_SetGet_range // ReceivedCalls.Day 
{
	@A_FSG_40_0_0_47_Data_5_SetGet = @A_FSG_40_0_0_47_Data_5_SetGet_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_5_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Day
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_5_SetGet, 1.0);
	@A_FSG_40_0_0_47_Data_5_SetGet_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param5 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_6_SetGet_range // ReceivedCalls.Month 
{
	@A_FSG_40_0_0_47_Data_6_SetGet = @A_FSG_40_0_0_47_Data_6_SetGet_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_6_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Month
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_6_SetGet, 1.0);
	@A_FSG_40_0_0_47_Data_6_SetGet_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param6 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_7_SetGet_range // ReceivedCalls.Year 
{
	@A_FSG_40_0_0_47_Data_7_SetGet = @A_FSG_40_0_0_47_Data_7_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_7_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Year
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_7_SetGet, 1.0);
	@A_FSG_40_0_0_47_Data_7_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param7 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_8_SetGet_range // ReceivedCalls.Hour 
{
	@A_FSG_40_0_0_47_Data_8_SetGet = @A_FSG_40_0_0_47_Data_8_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_8_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_8_SetGet, 1.0);
	@A_FSG_40_0_0_47_Data_8_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param8 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_9_SetGet_range // ReceivedCalls.Minute 
{
	@A_FSG_40_0_0_47_Data_9_SetGet = @A_FSG_40_0_0_47_Data_9_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_9_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_9_SetGet, 1.0);
	@A_FSG_40_0_0_47_Data_9_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param9 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_47_Data_10_SetGet_range // ReceivedCalls.Second 
{
	@A_FSG_40_0_0_47_Data_10_SetGet = @A_FSG_40_0_0_47_Data_10_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_47_Data_10_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Second
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_47_Data_10_SetGet, 1.0);
	@A_FSG_40_0_0_47_Data_10_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_47_ArrayDataList[getValue(A_FSG_40_0_0_47_DataIndex_SetGet)].Param10 = thisval;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_40_0_0_48_ErrCode
{
       if(gA_FSG_40_0_0_48_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_48", MakeRGB(255,255,255));
       }
       gA_FSG_40_0_0_48_ErrCode = 1;
}
on envVar A_FSG_40_0_0_48Changed_BTN
{
    byte data[607]; 
    byte stringValue[607];
    byte head[5];
    int i;
    int headLength;
    long tempValue;
    word currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_40_0_0_48Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_48_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_48",MakeRGB(255,255,255));
        A_FSG_40_0_0_48Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_48_Changed);
        getValue(A_FSG_40_0_0_48_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_48_Changed_Start);
     elementsVal = getValue(A_FSG_40_0_0_48_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_48_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 48");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_48_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_48_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 48");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_40_0_0_48_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_40_0_0_48_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_40_0_0_48_ID);
       }
       if(getValue(A_FSG_40_0_0_48_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_40_0_0_48_ID,getValueSize(A_FSG_40_0_0_48_Changed));
       }
        A_FSG_40_0_0_48Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_48Status_BTN
{
    byte data[607 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[607];
    byte head[5];
    int i = 0;
    int j = 0;
    long StringLength = 0;
    int headLength;
    long tempValue;
    word currentPos;

    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_40_0_0_48Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_48_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_48",MakeRGB(255,255,255));
        A_FSG_40_0_0_48Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_48_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_48_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_48_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_48);
        getValue(A_FSG_40_0_0_48,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_48_Start);
     elementsVal = getValue(A_FSG_40_0_0_48_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_48_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 48");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 1 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_48_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_48_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 1 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_48_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_48_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_48_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_48_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 48");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 1 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_48_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_48_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 1 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_48_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_48_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_40_0_0_48, data);
        Request_ByteSequence(LSGID, A_FSG_40_0_0_48_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_40_0_0_48_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_40_0_0_48_ID);
        }
        if(getValue(A_FSG_40_0_0_48_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_40_0_0_48_ID,getValueSize(A_FSG_40_0_0_48));
        }
        A_FSG_40_0_0_48Status_BTN_already_pressed = 0;
    }
}
A_FSG_40_0_0_48_SendStatus()
{
    word currentPos;
    word headLength;
    int i;
    int j;
    word StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[607];
    byte stringValue[607];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_48_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_48_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_48_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_48);
        getValue(A_FSG_40_0_0_48,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_48_Start);
     elementsVal = getValue(A_FSG_40_0_0_48_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_48_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 48");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 1 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_48_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_48_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 1 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_48_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_48_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_48_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_48_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 48");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 1 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_48_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_48_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 1 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_48_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_48_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_48_ArrayDataList[i].Param4[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param5 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_48_RecAdr ) || 2 == getValue( A_FSG_40_0_0_48_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_48_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_40_0_0_48_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_40_0_0_48
{
    byte temp[607];
    getValue(A_FSG_40_0_0_48, temp);
    putValue(A_FSG_40_0_0_48_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_48_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_48_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_48_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_48_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_40_0_0_48_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_40_0_0_48_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_48_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_48_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_48_IndexSize))
    {
        putValue(A_FSG_40_0_0_48_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_40_0_0_48_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_40_0_0_48_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_40_0_0_48_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_40_0_0_48_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_48_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_48_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_48_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_48_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_48_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_48_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_48_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_48_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_48_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_48_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_48_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_48_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_48_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_40_0_0_48, head, headLength); 
}

on envVar A_FSG_40_0_0_48_RecAdr
{
    A_FSG_40_0_0_48_GenerateStatus();
}

on envVar A_FSG_40_0_0_48_Shift
{
    A_FSG_40_0_0_48_GenerateStatus();
}

on envVar A_FSG_40_0_0_48_Direction
{
    A_FSG_40_0_0_48_GenerateStatus();
}

on envVar A_FSG_40_0_0_48_Start
{
    A_FSG_40_0_0_48_GenerateStatus();
}

on envVar A_FSG_40_0_0_48_Elements
{
    A_FSG_40_0_0_48_GenerateStatus();
}

on envVar A_FSG_40_0_0_48_IndexSize
{
    A_FSG_40_0_0_48_GenerateStatus();
}
on envVar A_FSG_40_0_0_48_TransPos
{
    A_FSG_40_0_0_48_GenerateStatus();
}
A_FSG_40_0_0_48_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_48_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_48_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_48_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_48_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_48_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_48_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_48_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_48_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_48_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_48_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_48_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_40_0_0_48_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_48_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_48_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_40_0_0_48_Changed, head, 3); 
    }
}

on envVar A_FSG_40_0_0_48_Changed_RecAdr
{
    A_FSG_40_0_0_48_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_48_Changed_Shift
{
    A_FSG_40_0_0_48_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_48_Changed_Direction
{
    A_FSG_40_0_0_48_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_48_Changed_Start
{
    A_FSG_40_0_0_48_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_48_Changed_Elements
{
    A_FSG_40_0_0_48_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_48_Changed_IndexSize
{
    A_FSG_40_0_0_48_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_48_Changed_TransPos
{
    A_FSG_40_0_0_48_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_48_SetGet
{
    byte temp[607];
    getValue(A_FSG_40_0_0_48_SetGet, temp);
    putValue(A_FSG_40_0_0_48_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_48_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_48_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_48_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_48_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_48_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_48_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_48_SetGet_IndexSize))
    {
        putValue(A_FSG_40_0_0_48_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_40_0_0_48_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_40_0_0_48_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_40_0_0_48_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_40_0_0_48_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp3[25];
	char temp5[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_40_0_0_48_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_40_0_0_48_ArrayDataList[i].Param1 = 0;
		for(j=0; j<100; j++)
			A_FSG_40_0_0_48_ArrayDataList[i].Param2[j] = 0;
		A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length = 0;
		A_FSG_40_0_0_48_Data_2_LenList[i] = 0;
		A_FSG_40_0_0_48_ArrayDataList[i].Param3 = 0;
		for(j=0; j<41; j++)
			A_FSG_40_0_0_48_ArrayDataList[i].Param4[j] = 0;
		A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length = 0;
		A_FSG_40_0_0_48_Data_4_LenList[i] = 0;
		A_FSG_40_0_0_48_ArrayDataList[i].Param5 = 0;
		A_FSG_40_0_0_48_ArrayDataList[i].Param6 = 0;
		A_FSG_40_0_0_48_ArrayDataList[i].Param7 = 0;
		A_FSG_40_0_0_48_ArrayDataList[i].Param8 = 0;
		A_FSG_40_0_0_48_ArrayDataList[i].Param9 = 0;
		A_FSG_40_0_0_48_ArrayDataList[i].Param10 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_40_0_0_48_fileSelector, CSV_filename);
	CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 61) //ignore first line in *.csv file
					{
						A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //NumberType
						A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //Day
						A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //Month
						A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param7 = atol(temp7); //Year
						A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param8 = atol(temp8); //Hour
						A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param9 = atol(temp9); //Minute
						A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param10 = atol(temp10); //Second
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp3[i]=0;
							temp5[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 61)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PbName
								if(paramPos < 99)
								{
									A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //NumberType
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //TelNumber
								if(paramPos < 40)
								{
									A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_48_ArrayDataList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 5: //Day
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //Month
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //Year
								if( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //Hour
								if( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //Minute
								if( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //Second
								if( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_40_0_0_48_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_40_0_0_48_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_48_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_40_0_0_48_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_40_0_0_48_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_40_0_0_48_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_40_0_0_48_Data_1, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_48_Data_2, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param2, A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_48_Data_3, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_48_Data_4, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param4, A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param4_Length);
	putValue(A_FSG_40_0_0_48_Data_5, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param5);
	putValue(A_FSG_40_0_0_48_Data_6, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param6);
	putValue(A_FSG_40_0_0_48_Data_7, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param7);
	putValue(A_FSG_40_0_0_48_Data_8, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param8);
	putValue(A_FSG_40_0_0_48_Data_9, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param9);
	putValue(A_FSG_40_0_0_48_Data_10, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param10);
}


on envVar A_FSG_40_0_0_48_generateData_Btn
{
	word i;
	dword elementsArray[12] = {2, 100, 2, 1, 41, 2, 1, 1, 1, 1, 1, 1};
	byte elementsTypeArray[12] = {0, 0xE, 0xF, 0, 0xE, 0xF, 0, 0, 0, 0, 0, 0};
	dword elementsMaxSizeArray[12] = {65535, 0, 0, 0xFF, 0, 0, 254, 11, 99, 23, 59, 59};
	byte tempArray[9240];
	if (A_FSG_40_0_0_48_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_48_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 48, 60 );
		for(i = 0; i < 60; i++)
		{
			memcpy(A_FSG_40_0_0_48_ArrayDataList[i], tempArray, (i * 154) );
			if(A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length > 127 )
				A_FSG_40_0_0_48_Data_2_CntList[i] = 1;
			if(A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length > 127 )
				A_FSG_40_0_0_48_Data_4_CntList[i] = 1;
		}
		A_FSG_40_0_0_48_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_40_0_0_48_Data_1, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_48_Data_2, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param2, A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_48_Data_3, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_48_Data_4, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param4, A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param4_Length);
	putValue(A_FSG_40_0_0_48_Data_5, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param5);
	putValue(A_FSG_40_0_0_48_Data_6, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param6);
	putValue(A_FSG_40_0_0_48_Data_7, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param7);
	putValue(A_FSG_40_0_0_48_Data_8, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param8);
	putValue(A_FSG_40_0_0_48_Data_9, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param9);
	putValue(A_FSG_40_0_0_48_Data_10, A_FSG_40_0_0_48_ArrayDataList[ getValue( A_FSG_40_0_0_48_DataIndex) ].Param10);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_40_0_0_48_DataIndex
{
    long index;
    long maxIndex = 60-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_48_Data_1, A_FSG_40_0_0_48_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_48_Data_2_len, A_FSG_40_0_0_48_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_48_Data_2_cnt, A_FSG_40_0_0_48_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_48_Data_2, A_FSG_40_0_0_48_ArrayDataList[index].Param2, A_FSG_40_0_0_48_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_48_Data_3, A_FSG_40_0_0_48_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_48_Data_4_len, A_FSG_40_0_0_48_Data_4_LenList[index]);
    putValue(A_FSG_40_0_0_48_Data_4_cnt, A_FSG_40_0_0_48_Data_4_CntList[index]);
    putValue(A_FSG_40_0_0_48_Data_4, A_FSG_40_0_0_48_ArrayDataList[index].Param4, A_FSG_40_0_0_48_ArrayDataList[index].Param4_Length);
    putValue(A_FSG_40_0_0_48_Data_5, A_FSG_40_0_0_48_ArrayDataList[index].Param5);
    putValue(A_FSG_40_0_0_48_Data_6, A_FSG_40_0_0_48_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_48_Data_7, A_FSG_40_0_0_48_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_48_Data_8, A_FSG_40_0_0_48_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_48_Data_9, A_FSG_40_0_0_48_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_48_Data_10, A_FSG_40_0_0_48_ArrayDataList[index].Param10);

}
on envVar A_FSG_40_0_0_48_DataIndex_Incr
{
    long index;
    if(A_FSG_40_0_0_48_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_48_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_48_DataIndex);
        index++;
        putValue(A_FSG_40_0_0_48_DataIndex, index);
        A_FSG_40_0_0_48_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_48_DataIndex_Decr
{
    long index;
    if(A_FSG_40_0_0_48_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_48_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_48_DataIndex);
        index--;
        putValue(A_FSG_40_0_0_48_DataIndex, index);
        A_FSG_40_0_0_48_DataIndex_Decr_already_pressed = 0;
    }
}
// HME generateCaplOnEnv (3160)
on envVar A_FSG_40_0_0_48_DataIndex_SetGet
{
    long index;
    long maxIndex = 60-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_48_Data_1_SetGet, A_FSG_40_0_0_48_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_48_Data_2_SetGet_len, A_FSG_40_0_0_48_Data_2_SetGet_LenList[index]);
    putValue(A_FSG_40_0_0_48_Data_2_SetGet_cnt, A_FSG_40_0_0_48_Data_2_SetGet_CntList[index]);
    putValue(A_FSG_40_0_0_48_Data_2_SetGet, A_FSG_40_0_0_48_ArrayDataList[index].Param2, A_FSG_40_0_0_48_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_48_Data_3_SetGet, A_FSG_40_0_0_48_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_48_Data_4_SetGet_len, A_FSG_40_0_0_48_Data_4_SetGet_LenList[index]);
    putValue(A_FSG_40_0_0_48_Data_4_SetGet_cnt, A_FSG_40_0_0_48_Data_4_SetGet_CntList[index]);
    putValue(A_FSG_40_0_0_48_Data_4_SetGet, A_FSG_40_0_0_48_ArrayDataList[index].Param4, A_FSG_40_0_0_48_ArrayDataList[index].Param4_Length);
    putValue(A_FSG_40_0_0_48_Data_5_SetGet, A_FSG_40_0_0_48_ArrayDataList[index].Param5);
    putValue(A_FSG_40_0_0_48_Data_6_SetGet, A_FSG_40_0_0_48_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_48_Data_7_SetGet, A_FSG_40_0_0_48_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_48_Data_8_SetGet, A_FSG_40_0_0_48_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_48_Data_9_SetGet, A_FSG_40_0_0_48_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_48_Data_10_SetGet, A_FSG_40_0_0_48_ArrayDataList[index].Param10);

}
on envVar A_FSG_40_0_0_48_DataIndex_SetGet_Incr
{
    long index;
    if(A_FSG_40_0_0_48_DataIndex_SetGet_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_48_DataIndex_SetGet_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_48_DataIndex_SetGet);
        index++;
        putValue(A_FSG_40_0_0_48_DataIndex_SetGet, index);
        A_FSG_40_0_0_48_DataIndex_SetGet_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_48_DataIndex_SetGet_Decr
{
    long index;
    if(A_FSG_40_0_0_48_DataIndex_SetGet_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_48_DataIndex_SetGet_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_48_DataIndex_SetGet);
        index--;
        putValue(A_FSG_40_0_0_48_DataIndex_SetGet, index);
        A_FSG_40_0_0_48_DataIndex_SetGet_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_48_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_40_0_0_48_ID;
    data[2]=getValue(A_FSG_40_0_0_48_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_40_0_0_48
on envVar A_FSG_40_0_0_48_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_48",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_48",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_48",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_48_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_48", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_48",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_48",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_48",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_48_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_48", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_48_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_48_SegmEn,0);
           intertelegram_err(A_FSG_40_0_0_48_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_40_0_0_48_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_48_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_48_IntTlgEn,0);
           sequence_err(A_FSG_40_0_0_48_ID,getValueSize(A_FSG_40_0_0_48_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_40_0_0_48_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_40_0_0_48_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_40_0_0_48_Status",1);
 	}
}



A_FSG_40_0_0_48_SetInd () { /* leere Function*/ }

A_FSG_40_0_0_48_SetGetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[607];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_48_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_48_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_48_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_48_AT))
                {
                    putValue(A_FSG_40_0_0_48,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_48_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_48_AT))
            {
                putValue(A_FSG_40_0_0_48,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_48_AT))
        {
            putValue(A_FSG_40_0_0_48_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_48_Start, startVal);
            putValue(A_FSG_40_0_0_48_Elements, elementsVal);
            putValue(A_FSG_40_0_0_48_TransPos, transmitPosVal);
        }
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_FSG_40_0_0_48_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 48");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_40_0_0_48_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_40_0_0_48_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_48_Data_2_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_48_Data_2_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length; j++)
        {
            A_FSG_40_0_0_48_ArrayDataList[i].Param2[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_48_Data_4_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_48_Data_4_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length; j++)
        {
            A_FSG_40_0_0_48_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_FSG_40_0_0_48_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_FSG_40_0_0_48_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 48");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_40_0_0_48_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_40_0_0_48_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_48_Data_2_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_48_Data_2_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_48_ArrayDataList[i].Param2_Length; j++)
        {
            A_FSG_40_0_0_48_ArrayDataList[i].Param2[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_48_Data_4_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_48_Data_4_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_48_ArrayDataList[i].Param4_Length; j++)
        {
            A_FSG_40_0_0_48_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param5 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_48_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_FSG_40_0_0_48_DataIndex);
    putValue(A_FSG_40_0_0_48_Data_1, A_FSG_40_0_0_48_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_48_Data_2_len, A_FSG_40_0_0_48_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_48_Data_2_cnt, A_FSG_40_0_0_48_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_48_Data_2, A_FSG_40_0_0_48_ArrayDataList[index].Param2, A_FSG_40_0_0_48_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_48_Data_3, A_FSG_40_0_0_48_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_48_Data_4_len, A_FSG_40_0_0_48_Data_4_LenList[index]);
    putValue(A_FSG_40_0_0_48_Data_4_cnt, A_FSG_40_0_0_48_Data_4_CntList[index]);
    putValue(A_FSG_40_0_0_48_Data_4, A_FSG_40_0_0_48_ArrayDataList[index].Param4, A_FSG_40_0_0_48_ArrayDataList[index].Param4_Length);
    putValue(A_FSG_40_0_0_48_Data_5, A_FSG_40_0_0_48_ArrayDataList[index].Param5);
    putValue(A_FSG_40_0_0_48_Data_6, A_FSG_40_0_0_48_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_48_Data_7, A_FSG_40_0_0_48_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_48_Data_8, A_FSG_40_0_0_48_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_48_Data_9, A_FSG_40_0_0_48_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_48_Data_10, A_FSG_40_0_0_48_ArrayDataList[index].Param10);
}

A_FSG_40_0_0_48_GetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[607];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_48_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_48_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_48_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_48_AT))
                {
                    putValue(A_FSG_40_0_0_48,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_48_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_48_AT))
            {
                putValue(A_FSG_40_0_0_48,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_48_AT))
        {
            putValue(A_FSG_40_0_0_48_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_48_Start, startVal);
            putValue(A_FSG_40_0_0_48_Elements, elementsVal);
            putValue(A_FSG_40_0_0_48_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_40_0_0_48_1
{
	byte superval[607];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_2_range // DialedNumbers.TAID 
{
	@A_FSG_40_0_0_48_2 = @A_FSG_40_0_0_48_2_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_2
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_2, 1.0);
	@A_FSG_40_0_0_48_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_3_range // DialedNumbers.TotalNumListElements 
{
	@A_FSG_40_0_0_48_3 = @A_FSG_40_0_0_48_3_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_3
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_3, 1.0);
	@A_FSG_40_0_0_48_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_1_range // DialedNumbers.Pos 
{
	@A_FSG_40_0_0_48_Data_1 = @A_FSG_40_0_0_48_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_1
{
	byte superval[607];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_1, 1.0);
	@A_FSG_40_0_0_48_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_48_Data_2_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_48_Data_2_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_48_Data_2_CntList[ getValue(A_FSG_40_0_0_48_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_48_Data_2_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_48_Data_2_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_48_Data_2_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_48_Data_2_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param2_Length = thisval;
	A_FSG_40_0_0_48_Data_2_LenList[ getValue(A_FSG_40_0_0_48_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_48_Data_2_len, thisval);

}

on envVar A_FSG_40_0_0_48_Data_2
{
	byte superval[607];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param2[i] = thisval[i];
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_48_Data_2_LenList[getValue(A_FSG_40_0_0_48_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_48_Data_2_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_48_Data_3
{
	byte superval[607];

	//Update Childvalue (Enum)
	byte thisval; // NumberType
	thisval = getValue(this);
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_48_Data_4_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_48_Data_4_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_48_Data_4_CntList[ getValue(A_FSG_40_0_0_48_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_48_Data_4_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_48_Data_4_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_48_Data_4_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 40 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 40);
		thisval = 40;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_48_Data_4_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param4_Length = thisval;
	A_FSG_40_0_0_48_Data_4_LenList[ getValue(A_FSG_40_0_0_48_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_48_Data_4_len, thisval);

}

on envVar A_FSG_40_0_0_48_Data_4
{
	byte superval[607];

	//Update Childvalue (String)
	word i;
	byte thisval[41];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param4[i] = thisval[i];
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param4_Length = getValueSize(this);
    A_FSG_40_0_0_48_Data_4_LenList[getValue(A_FSG_40_0_0_48_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_48_Data_4_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_5_range // DialedNumbers.Day 
{
	@A_FSG_40_0_0_48_Data_5 = @A_FSG_40_0_0_48_Data_5_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_5
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Day
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_5, 1.0);
	@A_FSG_40_0_0_48_Data_5_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param5 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_6_range // DialedNumbers.Month 
{
	@A_FSG_40_0_0_48_Data_6 = @A_FSG_40_0_0_48_Data_6_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_6
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Month
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_6, 1.0);
	@A_FSG_40_0_0_48_Data_6_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param6 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_7_range // DialedNumbers.Year 
{
	@A_FSG_40_0_0_48_Data_7 = @A_FSG_40_0_0_48_Data_7_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_7
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Year
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_7, 1.0);
	@A_FSG_40_0_0_48_Data_7_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param7 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_8_range // DialedNumbers.Hour 
{
	@A_FSG_40_0_0_48_Data_8 = @A_FSG_40_0_0_48_Data_8_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_8
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_8, 1.0);
	@A_FSG_40_0_0_48_Data_8_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param8 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_9_range // DialedNumbers.Minute 
{
	@A_FSG_40_0_0_48_Data_9 = @A_FSG_40_0_0_48_Data_9_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_9
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_9, 1.0);
	@A_FSG_40_0_0_48_Data_9_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param9 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_10_range // DialedNumbers.Second 
{
	@A_FSG_40_0_0_48_Data_10 = @A_FSG_40_0_0_48_Data_10_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_10
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Second
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_10, 1.0);
	@A_FSG_40_0_0_48_Data_10_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex)].Param10 = thisval;
}
on envVar A_FSG_40_0_0_48_1_SetGet
{
	byte superval[8];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_2_SetGet_range // DialedNumbers.TAID 
{
	@A_FSG_40_0_0_48_2_SetGet = @A_FSG_40_0_0_48_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_2_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_2_SetGet, 1.0);
	@A_FSG_40_0_0_48_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_1_SetGet_range // DialedNumbers.Pos 
{
	@A_FSG_40_0_0_48_Data_1_SetGet = @A_FSG_40_0_0_48_Data_1_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_1_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_1_SetGet, 1.0);
	@A_FSG_40_0_0_48_Data_1_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_48_Data_2_SetGet_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_48_Data_2_SetGet_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_48_Data_2_SetGet_CntList[ getValue(A_FSG_40_0_0_48_DataIndex_SetGet) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_48_Data_2_SetGet_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_48_Data_2_SetGet_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_48_Data_2_SetGet_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_2_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_48_Data_2_SetGet_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param2_Length = thisval;
	A_FSG_40_0_0_48_Data_2_SetGet_LenList[ getValue(A_FSG_40_0_0_48_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_40_0_0_48_Data_2_SetGet_len, thisval);

}

on envVar A_FSG_40_0_0_48_Data_2_SetGet
{
	byte superval[8];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param2[i] = thisval[i];
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_48_Data_2_SetGet_LenList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_40_0_0_48_Data_2_SetGet_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_48_Data_3_SetGet
{
	byte superval[8];

	//Update Childvalue (Enum)
	byte thisval; // NumberType
	thisval = getValue(this);
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_48_Data_4_SetGet_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_48_Data_4_SetGet_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_48_Data_4_SetGet_CntList[ getValue(A_FSG_40_0_0_48_DataIndex_SetGet) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_48_Data_4_SetGet_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_48_Data_4_SetGet_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_48_Data_4_SetGet_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 40 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_48_Data_4_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 40);
		thisval = 40;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_48_Data_4_SetGet_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param4_Length = thisval;
	A_FSG_40_0_0_48_Data_4_SetGet_LenList[ getValue(A_FSG_40_0_0_48_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_40_0_0_48_Data_4_SetGet_len, thisval);

}

on envVar A_FSG_40_0_0_48_Data_4_SetGet
{
	byte superval[8];

	//Update Childvalue (String)
	word i;
	byte thisval[41];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param4[i] = thisval[i];
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param4_Length = getValueSize(this);
    A_FSG_40_0_0_48_Data_4_SetGet_LenList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_40_0_0_48_Data_4_SetGet_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_5_SetGet_range // DialedNumbers.Day 
{
	@A_FSG_40_0_0_48_Data_5_SetGet = @A_FSG_40_0_0_48_Data_5_SetGet_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_5_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Day
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_5_SetGet, 1.0);
	@A_FSG_40_0_0_48_Data_5_SetGet_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param5 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_6_SetGet_range // DialedNumbers.Month 
{
	@A_FSG_40_0_0_48_Data_6_SetGet = @A_FSG_40_0_0_48_Data_6_SetGet_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_6_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Month
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_6_SetGet, 1.0);
	@A_FSG_40_0_0_48_Data_6_SetGet_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param6 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_7_SetGet_range // DialedNumbers.Year 
{
	@A_FSG_40_0_0_48_Data_7_SetGet = @A_FSG_40_0_0_48_Data_7_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_7_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Year
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_7_SetGet, 1.0);
	@A_FSG_40_0_0_48_Data_7_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param7 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_8_SetGet_range // DialedNumbers.Hour 
{
	@A_FSG_40_0_0_48_Data_8_SetGet = @A_FSG_40_0_0_48_Data_8_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_8_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_8_SetGet, 1.0);
	@A_FSG_40_0_0_48_Data_8_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param8 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_9_SetGet_range // DialedNumbers.Minute 
{
	@A_FSG_40_0_0_48_Data_9_SetGet = @A_FSG_40_0_0_48_Data_9_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_9_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_9_SetGet, 1.0);
	@A_FSG_40_0_0_48_Data_9_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param9 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_48_Data_10_SetGet_range // DialedNumbers.Second 
{
	@A_FSG_40_0_0_48_Data_10_SetGet = @A_FSG_40_0_0_48_Data_10_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_48_Data_10_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Second
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_48_Data_10_SetGet, 1.0);
	@A_FSG_40_0_0_48_Data_10_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_48_ArrayDataList[getValue(A_FSG_40_0_0_48_DataIndex_SetGet)].Param10 = thisval;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_40_0_0_49_ErrCode
{
       if(gA_FSG_40_0_0_49_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_49", MakeRGB(255,255,255));
       }
       gA_FSG_40_0_0_49_ErrCode = 1;
}
on envVar A_FSG_40_0_0_49Changed_BTN
{
    byte data[607]; 
    byte stringValue[607];
    byte head[5];
    int i;
    int headLength;
    long tempValue;
    word currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_40_0_0_49Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_49_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_49",MakeRGB(255,255,255));
        A_FSG_40_0_0_49Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_49_Changed);
        getValue(A_FSG_40_0_0_49_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_49_Changed_Start);
     elementsVal = getValue(A_FSG_40_0_0_49_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_49_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 49");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_49_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_49_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 49");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_40_0_0_49_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_40_0_0_49_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_40_0_0_49_ID);
       }
       if(getValue(A_FSG_40_0_0_49_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_40_0_0_49_ID,getValueSize(A_FSG_40_0_0_49_Changed));
       }
        A_FSG_40_0_0_49Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_49Status_BTN
{
    byte data[607 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[607];
    byte head[5];
    int i = 0;
    int j = 0;
    long StringLength = 0;
    int headLength;
    long tempValue;
    word currentPos;

    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_40_0_0_49Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_49_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_49",MakeRGB(255,255,255));
        A_FSG_40_0_0_49Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_49_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_49_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_49_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_49);
        getValue(A_FSG_40_0_0_49,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_49_Start);
     elementsVal = getValue(A_FSG_40_0_0_49_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_49_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 49");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_49_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_49_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param3) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param3 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable CallMode:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_49_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_49_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param5[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param10 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param11 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_49_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_49_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 49");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_49_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_49_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param3) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param3 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable CallMode:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_49_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_49_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param5[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param10 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param11 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_40_0_0_49, data);
        Request_ByteSequence(LSGID, A_FSG_40_0_0_49_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_40_0_0_49_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_40_0_0_49_ID);
        }
        if(getValue(A_FSG_40_0_0_49_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_40_0_0_49_ID,getValueSize(A_FSG_40_0_0_49));
        }
        A_FSG_40_0_0_49Status_BTN_already_pressed = 0;
    }
}
A_FSG_40_0_0_49_SendStatus()
{
    word currentPos;
    word headLength;
    int i;
    int j;
    word StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[607];
    byte stringValue[607];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_49_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_49_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_49_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_49);
        getValue(A_FSG_40_0_0_49,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_49_Start);
     elementsVal = getValue(A_FSG_40_0_0_49_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_49_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 49");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_49_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_49_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param3) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param3 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable CallMode:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_49_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_49_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param5[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param10 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param11 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_49_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_49_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 49");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_49_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_49_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param3) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param3 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable CallMode:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 1 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_49_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_49_Data_5_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_49_Data_5_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_5 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_49_ArrayDataList[i].Param5[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Day:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param6 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Month:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param7 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Year:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param8 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Hour:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Minute:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param10 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable Second:
      if( 0 || 0 == getValue( A_FSG_40_0_0_49_RecAdr ) || 2 == getValue( A_FSG_40_0_0_49_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_49_ArrayDataList[i].Param11 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_40_0_0_49_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_40_0_0_49
{
    byte temp[607];
    getValue(A_FSG_40_0_0_49, temp);
    putValue(A_FSG_40_0_0_49_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_49_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_49_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_49_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_49_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_40_0_0_49_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_40_0_0_49_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_49_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_49_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_49_IndexSize))
    {
        putValue(A_FSG_40_0_0_49_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_40_0_0_49_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_40_0_0_49_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_40_0_0_49_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_40_0_0_49_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_49_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_49_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_49_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_49_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_49_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_49_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_49_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_49_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_49_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_49_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_49_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_49_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_49_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_40_0_0_49, head, headLength); 
}

on envVar A_FSG_40_0_0_49_RecAdr
{
    A_FSG_40_0_0_49_GenerateStatus();
}

on envVar A_FSG_40_0_0_49_Shift
{
    A_FSG_40_0_0_49_GenerateStatus();
}

on envVar A_FSG_40_0_0_49_Direction
{
    A_FSG_40_0_0_49_GenerateStatus();
}

on envVar A_FSG_40_0_0_49_Start
{
    A_FSG_40_0_0_49_GenerateStatus();
}

on envVar A_FSG_40_0_0_49_Elements
{
    A_FSG_40_0_0_49_GenerateStatus();
}

on envVar A_FSG_40_0_0_49_IndexSize
{
    A_FSG_40_0_0_49_GenerateStatus();
}
on envVar A_FSG_40_0_0_49_TransPos
{
    A_FSG_40_0_0_49_GenerateStatus();
}
A_FSG_40_0_0_49_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_49_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_49_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_49_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_49_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_49_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_49_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_49_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_49_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_49_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_49_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_49_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_40_0_0_49_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_49_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_49_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_40_0_0_49_Changed, head, 3); 
    }
}

on envVar A_FSG_40_0_0_49_Changed_RecAdr
{
    A_FSG_40_0_0_49_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_49_Changed_Shift
{
    A_FSG_40_0_0_49_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_49_Changed_Direction
{
    A_FSG_40_0_0_49_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_49_Changed_Start
{
    A_FSG_40_0_0_49_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_49_Changed_Elements
{
    A_FSG_40_0_0_49_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_49_Changed_IndexSize
{
    A_FSG_40_0_0_49_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_49_Changed_TransPos
{
    A_FSG_40_0_0_49_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_49_SetGet
{
    byte temp[607];
    getValue(A_FSG_40_0_0_49_SetGet, temp);
    putValue(A_FSG_40_0_0_49_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_49_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_49_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_49_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_49_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_49_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_49_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_49_SetGet_IndexSize))
    {
        putValue(A_FSG_40_0_0_49_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_40_0_0_49_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_40_0_0_49_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_40_0_0_49_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_40_0_0_49_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp3[25];
	char temp4[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];
	char temp11[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_40_0_0_49_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_40_0_0_49_ArrayDataList[i].Param1 = 0;
		for(j=0; j<100; j++)
			A_FSG_40_0_0_49_ArrayDataList[i].Param2[j] = 0;
		A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length = 0;
		A_FSG_40_0_0_49_Data_2_LenList[i] = 0;
		A_FSG_40_0_0_49_ArrayDataList[i].Param3 = 0;
		A_FSG_40_0_0_49_ArrayDataList[i].Param4 = 0;
		for(j=0; j<41; j++)
			A_FSG_40_0_0_49_ArrayDataList[i].Param5[j] = 0;
		A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length = 0;
		A_FSG_40_0_0_49_Data_5_LenList[i] = 0;
		A_FSG_40_0_0_49_ArrayDataList[i].Param6 = 0;
		A_FSG_40_0_0_49_ArrayDataList[i].Param7 = 0;
		A_FSG_40_0_0_49_ArrayDataList[i].Param8 = 0;
		A_FSG_40_0_0_49_ArrayDataList[i].Param9 = 0;
		A_FSG_40_0_0_49_ArrayDataList[i].Param10 = 0;
		A_FSG_40_0_0_49_ArrayDataList[i].Param11 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_40_0_0_49_fileSelector,gListPath);
  
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 181) //ignore first line in *.csv file
					{
						A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //NumberType
						A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //CallMode
						A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param6 = atol(temp6); //Day
						A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param7 = atol(temp7); //Month
						A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param8 = atol(temp8); //Year
						A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param9 = atol(temp9); //Hour
						A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param10 = atol(temp10); //Minute
						A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param11 = atol(temp11); //Second
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
							temp11[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 181)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PbName
								if(paramPos < 99)
								{
									A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //NumberType
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //CallMode
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //TelNumber
								if(paramPos < 40)
								{
									A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 6: //Day
								if( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //Month
								if( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //Year
								if( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //Hour
								if( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //Minute
								if( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 11: //Second
								if( paramPos >= elCount(temp11) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp11[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_40_0_0_49_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_40_0_0_49_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_49_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_40_0_0_49_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_40_0_0_49_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_40_0_0_49_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_40_0_0_49_Data_1, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_49_Data_2, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param2, A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_49_Data_3, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_49_Data_4, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param4);
	putValue(A_FSG_40_0_0_49_Data_5, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param5, A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param5_Length);
	putValue(A_FSG_40_0_0_49_Data_6, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param6);
	putValue(A_FSG_40_0_0_49_Data_7, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param7);
	putValue(A_FSG_40_0_0_49_Data_8, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param8);
	putValue(A_FSG_40_0_0_49_Data_9, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param9);
	putValue(A_FSG_40_0_0_49_Data_10, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param10);
	putValue(A_FSG_40_0_0_49_Data_11, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param11);
}


on envVar A_FSG_40_0_0_49_generateData_Btn
{
	word i;
	dword elementsArray[13] = {2, 100, 2, 1, 1, 41, 2, 1, 1, 1, 1, 1, 1};
	byte elementsTypeArray[13] = {0, 0xE, 0xF, 0, 0, 0xE, 0xF, 0, 0, 0, 0, 0, 0};
	dword elementsMaxSizeArray[13] = {65535, 0, 0, 0xF, 0xF, 0, 0, 254, 11, 99, 23, 59, 59};
	byte tempArray[27900];
	if (A_FSG_40_0_0_49_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_49_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 49, 1023 );
		for(i = 0; i < 1023; i++)
		{
			memcpy(A_FSG_40_0_0_49_ArrayDataList[i], tempArray, (i * 155) );
			if(A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length > 127 )
				A_FSG_40_0_0_49_Data_2_CntList[i] = 1;
			if(A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length > 127 )
				A_FSG_40_0_0_49_Data_5_CntList[i] = 1;
		}
		A_FSG_40_0_0_49_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_40_0_0_49_Data_1, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_49_Data_2, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param2, A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_49_Data_3, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_49_Data_4, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param4);
	putValue(A_FSG_40_0_0_49_Data_5, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param5, A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param5_Length);
	putValue(A_FSG_40_0_0_49_Data_6, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param6);
	putValue(A_FSG_40_0_0_49_Data_7, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param7);
	putValue(A_FSG_40_0_0_49_Data_8, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param8);
	putValue(A_FSG_40_0_0_49_Data_9, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param9);
	putValue(A_FSG_40_0_0_49_Data_10, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param10);
	putValue(A_FSG_40_0_0_49_Data_11, A_FSG_40_0_0_49_ArrayDataList[ getValue( A_FSG_40_0_0_49_DataIndex) ].Param11);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_40_0_0_49_DataIndex
{
    long index;
    long maxIndex = 1023-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_49_Data_1, A_FSG_40_0_0_49_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_49_Data_2_len, A_FSG_40_0_0_49_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_49_Data_2_cnt, A_FSG_40_0_0_49_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_49_Data_2, A_FSG_40_0_0_49_ArrayDataList[index].Param2, A_FSG_40_0_0_49_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_49_Data_3, A_FSG_40_0_0_49_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_49_Data_4, A_FSG_40_0_0_49_ArrayDataList[index].Param4);
    putValue(A_FSG_40_0_0_49_Data_5_len, A_FSG_40_0_0_49_Data_5_LenList[index]);
    putValue(A_FSG_40_0_0_49_Data_5_cnt, A_FSG_40_0_0_49_Data_5_CntList[index]);
    putValue(A_FSG_40_0_0_49_Data_5, A_FSG_40_0_0_49_ArrayDataList[index].Param5, A_FSG_40_0_0_49_ArrayDataList[index].Param5_Length);
    putValue(A_FSG_40_0_0_49_Data_6, A_FSG_40_0_0_49_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_49_Data_7, A_FSG_40_0_0_49_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_49_Data_8, A_FSG_40_0_0_49_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_49_Data_9, A_FSG_40_0_0_49_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_49_Data_10, A_FSG_40_0_0_49_ArrayDataList[index].Param10);
    putValue(A_FSG_40_0_0_49_Data_11, A_FSG_40_0_0_49_ArrayDataList[index].Param11);

}
on envVar A_FSG_40_0_0_49_DataIndex_Incr
{
    long index;
    if(A_FSG_40_0_0_49_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_49_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_49_DataIndex);
        index++;
        putValue(A_FSG_40_0_0_49_DataIndex, index);
        A_FSG_40_0_0_49_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_49_DataIndex_Decr
{
    long index;
    if(A_FSG_40_0_0_49_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_49_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_49_DataIndex);
        index--;
        putValue(A_FSG_40_0_0_49_DataIndex, index);
        A_FSG_40_0_0_49_DataIndex_Decr_already_pressed = 0;
    }
}
// HME generateCaplOnEnv (3160)
on envVar A_FSG_40_0_0_49_DataIndex_SetGet
{
    long index;
    long maxIndex = 1023-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_49_Data_1_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_49_Data_2_SetGet_len, A_FSG_40_0_0_49_Data_2_SetGet_LenList[index]);
    putValue(A_FSG_40_0_0_49_Data_2_SetGet_cnt, A_FSG_40_0_0_49_Data_2_SetGet_CntList[index]);
    putValue(A_FSG_40_0_0_49_Data_2_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param2, A_FSG_40_0_0_49_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_49_Data_3_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_49_Data_4_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param4);
    putValue(A_FSG_40_0_0_49_Data_5_SetGet_len, A_FSG_40_0_0_49_Data_5_SetGet_LenList[index]);
    putValue(A_FSG_40_0_0_49_Data_5_SetGet_cnt, A_FSG_40_0_0_49_Data_5_SetGet_CntList[index]);
    putValue(A_FSG_40_0_0_49_Data_5_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param5, A_FSG_40_0_0_49_ArrayDataList[index].Param5_Length);
    putValue(A_FSG_40_0_0_49_Data_6_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_49_Data_7_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_49_Data_8_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_49_Data_9_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_49_Data_10_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param10);
    putValue(A_FSG_40_0_0_49_Data_11_SetGet, A_FSG_40_0_0_49_ArrayDataList[index].Param11);

}
on envVar A_FSG_40_0_0_49_DataIndex_SetGet_Incr
{
    long index;
    if(A_FSG_40_0_0_49_DataIndex_SetGet_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_49_DataIndex_SetGet_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_49_DataIndex_SetGet);
        index++;
        putValue(A_FSG_40_0_0_49_DataIndex_SetGet, index);
        A_FSG_40_0_0_49_DataIndex_SetGet_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_49_DataIndex_SetGet_Decr
{
    long index;
    if(A_FSG_40_0_0_49_DataIndex_SetGet_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_49_DataIndex_SetGet_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_49_DataIndex_SetGet);
        index--;
        putValue(A_FSG_40_0_0_49_DataIndex_SetGet, index);
        A_FSG_40_0_0_49_DataIndex_SetGet_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_49_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_40_0_0_49_ID;
    data[2]=getValue(A_FSG_40_0_0_49_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_40_0_0_49
on envVar A_FSG_40_0_0_49_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_49",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_49",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_49",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_49_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_49", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_49",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_49",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_49",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_49_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_49", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_49_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_49_SegmEn,0);
           intertelegram_err(A_FSG_40_0_0_49_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_40_0_0_49_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_49_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_49_IntTlgEn,0);
           sequence_err(A_FSG_40_0_0_49_ID,getValueSize(A_FSG_40_0_0_49_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_40_0_0_49_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_40_0_0_49_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_40_0_0_49_Status",1);
 	}
}



A_FSG_40_0_0_49_SetInd () { /* leere Function*/ }

A_FSG_40_0_0_49_SetGetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[607];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_49_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_49_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_49_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_49_AT))
                {
                    putValue(A_FSG_40_0_0_49,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_49_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_49_AT))
            {
                putValue(A_FSG_40_0_0_49,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_49_AT))
        {
            putValue(A_FSG_40_0_0_49_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_49_Start, startVal);
            putValue(A_FSG_40_0_0_49_Elements, elementsVal);
            putValue(A_FSG_40_0_0_49_TransPos, transmitPosVal);
        }
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_FSG_40_0_0_49_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 49");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_40_0_0_49_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_40_0_0_49_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_49_Data_2_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_49_Data_2_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length; j++)
        {
            A_FSG_40_0_0_49_ArrayDataList[i].Param2[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_40_0_0_49_ArrayDataList[i].Param3= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_40_0_0_49_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_40_0_0_49_ArrayDataList[i].Param4= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_40_0_0_49_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_49_Data_5_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_49_Data_5_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length; j++)
        {
            A_FSG_40_0_0_49_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param11 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_FSG_40_0_0_49_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_FSG_40_0_0_49_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 49");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_40_0_0_49_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_40_0_0_49_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_49_Data_2_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_49_Data_2_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_49_ArrayDataList[i].Param2_Length; j++)
        {
            A_FSG_40_0_0_49_ArrayDataList[i].Param2[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_40_0_0_49_ArrayDataList[i].Param3= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_40_0_0_49_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        if(nibbleSetted == 1)
        {
            // second nibble, Increment und nibbleSetted reseten
            A_FSG_40_0_0_49_ArrayDataList[i].Param4= gBAP_Indication_data[currentPos] & 0x0F;
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
        // first nibble, kein Increment, nibbleSetted setzen
            A_FSG_40_0_0_49_ArrayDataList[i].Param4 = (gBAP_Indication_data[currentPos]>>4) & 0x0F;
            nibbleSetted = 1;
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_49_Data_5_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_49_Data_5_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_49_ArrayDataList[i].Param5_Length; j++)
        {
            A_FSG_40_0_0_49_ArrayDataList[i].Param5[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param6 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param7 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param8 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param9 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param10 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_49_ArrayDataList[i].Param11 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_FSG_40_0_0_49_DataIndex);
    putValue(A_FSG_40_0_0_49_Data_1, A_FSG_40_0_0_49_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_49_Data_2_len, A_FSG_40_0_0_49_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_49_Data_2_cnt, A_FSG_40_0_0_49_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_49_Data_2, A_FSG_40_0_0_49_ArrayDataList[index].Param2, A_FSG_40_0_0_49_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_49_Data_3, A_FSG_40_0_0_49_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_49_Data_4, A_FSG_40_0_0_49_ArrayDataList[index].Param4);
    putValue(A_FSG_40_0_0_49_Data_5_len, A_FSG_40_0_0_49_Data_5_LenList[index]);
    putValue(A_FSG_40_0_0_49_Data_5_cnt, A_FSG_40_0_0_49_Data_5_CntList[index]);
    putValue(A_FSG_40_0_0_49_Data_5, A_FSG_40_0_0_49_ArrayDataList[index].Param5, A_FSG_40_0_0_49_ArrayDataList[index].Param5_Length);
    putValue(A_FSG_40_0_0_49_Data_6, A_FSG_40_0_0_49_ArrayDataList[index].Param6);
    putValue(A_FSG_40_0_0_49_Data_7, A_FSG_40_0_0_49_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_49_Data_8, A_FSG_40_0_0_49_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_49_Data_9, A_FSG_40_0_0_49_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_49_Data_10, A_FSG_40_0_0_49_ArrayDataList[index].Param10);
    putValue(A_FSG_40_0_0_49_Data_11, A_FSG_40_0_0_49_ArrayDataList[index].Param11);
}

A_FSG_40_0_0_49_GetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[607];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_49_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_49_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_49_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_49_AT))
                {
                    putValue(A_FSG_40_0_0_49,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_49_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_49_AT))
            {
                putValue(A_FSG_40_0_0_49,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_49_AT))
        {
            putValue(A_FSG_40_0_0_49_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_49_Start, startVal);
            putValue(A_FSG_40_0_0_49_Elements, elementsVal);
            putValue(A_FSG_40_0_0_49_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_40_0_0_49_1
{
	byte superval[607];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_2_range // CombinedNumbers.TAID 
{
	@A_FSG_40_0_0_49_2 = @A_FSG_40_0_0_49_2_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_2
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_2, 1.0);
	@A_FSG_40_0_0_49_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_3_range // CombinedNumbers.TotalNumListElements 
{
	@A_FSG_40_0_0_49_3 = @A_FSG_40_0_0_49_3_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_3
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_3, 1.0);
	@A_FSG_40_0_0_49_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_1_range // CombinedNumbers.Pos 
{
	@A_FSG_40_0_0_49_Data_1 = @A_FSG_40_0_0_49_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_1
{
	byte superval[607];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_1, 1.0);
	@A_FSG_40_0_0_49_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_49_Data_2_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_49_Data_2_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_49_Data_2_CntList[ getValue(A_FSG_40_0_0_49_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_49_Data_2_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_49_Data_2_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_49_Data_2_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_49_Data_2_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param2_Length = thisval;
	A_FSG_40_0_0_49_Data_2_LenList[ getValue(A_FSG_40_0_0_49_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_49_Data_2_len, thisval);

}

on envVar A_FSG_40_0_0_49_Data_2
{
	byte superval[607];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param2[i] = thisval[i];
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_49_Data_2_LenList[getValue(A_FSG_40_0_0_49_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_49_Data_2_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_49_Data_3
{
	byte superval[607];

	//Update Childvalue (Enum)
	byte thisval; // NumberType
	thisval = 0x0f & getValue(this);
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param3 = thisval;
}
on envVar A_FSG_40_0_0_49_Data_4
{
	byte superval[607];

	//Update Childvalue (Enum)
	byte thisval; // CallMode
	thisval = 0x0f & getValue(this);
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param4 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_49_Data_5_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_49_Data_5_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_49_Data_5_CntList[ getValue(A_FSG_40_0_0_49_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_49_Data_5_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_49_Data_5_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_49_Data_5_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 40 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_5 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 40);
		thisval = 40;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_49_Data_5_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param5_Length = thisval;
	A_FSG_40_0_0_49_Data_5_LenList[ getValue(A_FSG_40_0_0_49_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_49_Data_5_len, thisval);

}

on envVar A_FSG_40_0_0_49_Data_5
{
	byte superval[607];

	//Update Childvalue (String)
	word i;
	byte thisval[41];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param5[i] = thisval[i];
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param5_Length = getValueSize(this);
    A_FSG_40_0_0_49_Data_5_LenList[getValue(A_FSG_40_0_0_49_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_49_Data_5_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_6_range // CombinedNumbers.Day 
{
	@A_FSG_40_0_0_49_Data_6 = @A_FSG_40_0_0_49_Data_6_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_6
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Day
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_6, 1.0);
	@A_FSG_40_0_0_49_Data_6_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param6 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_7_range // CombinedNumbers.Month 
{
	@A_FSG_40_0_0_49_Data_7 = @A_FSG_40_0_0_49_Data_7_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_7
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Month
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_7, 1.0);
	@A_FSG_40_0_0_49_Data_7_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param7 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_8_range // CombinedNumbers.Year 
{
	@A_FSG_40_0_0_49_Data_8 = @A_FSG_40_0_0_49_Data_8_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_8
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Year
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_8, 1.0);
	@A_FSG_40_0_0_49_Data_8_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param8 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_9_range // CombinedNumbers.Hour 
{
	@A_FSG_40_0_0_49_Data_9 = @A_FSG_40_0_0_49_Data_9_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_9
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_9, 1.0);
	@A_FSG_40_0_0_49_Data_9_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param9 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_10_range // CombinedNumbers.Minute 
{
	@A_FSG_40_0_0_49_Data_10 = @A_FSG_40_0_0_49_Data_10_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_10
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_10, 1.0);
	@A_FSG_40_0_0_49_Data_10_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param10 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_11_range // CombinedNumbers.Second 
{
	@A_FSG_40_0_0_49_Data_11 = @A_FSG_40_0_0_49_Data_11_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_11
{
	byte superval[607];

	//Update Childvalue (Number)
	byte thisval; // Second
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_11, 1.0);
	@A_FSG_40_0_0_49_Data_11_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex)].Param11 = thisval;
}
on envVar A_FSG_40_0_0_49_1_SetGet
{
	byte superval[8];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_2_SetGet_range // CombinedNumbers.TAID 
{
	@A_FSG_40_0_0_49_2_SetGet = @A_FSG_40_0_0_49_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_2_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_2_SetGet, 1.0);
	@A_FSG_40_0_0_49_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_1_SetGet_range // CombinedNumbers.Pos 
{
	@A_FSG_40_0_0_49_Data_1_SetGet = @A_FSG_40_0_0_49_Data_1_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_1_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_1_SetGet, 1.0);
	@A_FSG_40_0_0_49_Data_1_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_49_Data_2_SetGet_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_49_Data_2_SetGet_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_49_Data_2_SetGet_CntList[ getValue(A_FSG_40_0_0_49_DataIndex_SetGet) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_49_Data_2_SetGet_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_49_Data_2_SetGet_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_49_Data_2_SetGet_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_2_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_49_Data_2_SetGet_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param2_Length = thisval;
	A_FSG_40_0_0_49_Data_2_SetGet_LenList[ getValue(A_FSG_40_0_0_49_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_40_0_0_49_Data_2_SetGet_len, thisval);

}

on envVar A_FSG_40_0_0_49_Data_2_SetGet
{
	byte superval[8];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param2[i] = thisval[i];
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_49_Data_2_SetGet_LenList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_40_0_0_49_Data_2_SetGet_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_49_Data_3_SetGet
{
	byte superval[8];

	//Update Childvalue (Enum)
	byte thisval; // NumberType
	thisval = 0x0f & getValue(this);
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param3 = thisval;
}
on envVar A_FSG_40_0_0_49_Data_4_SetGet
{
	byte superval[8];

	//Update Childvalue (Enum)
	byte thisval; // CallMode
	thisval = 0x0f & getValue(this);
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param4 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_49_Data_5_SetGet_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_49_Data_5_SetGet_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_49_Data_5_SetGet_CntList[ getValue(A_FSG_40_0_0_49_DataIndex_SetGet) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_49_Data_5_SetGet_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_49_Data_5_SetGet_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_49_Data_5_SetGet_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 40 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_49_Data_5_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 40);
		thisval = 40;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_49_Data_5_SetGet_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param5_Length = thisval;
	A_FSG_40_0_0_49_Data_5_SetGet_LenList[ getValue(A_FSG_40_0_0_49_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_40_0_0_49_Data_5_SetGet_len, thisval);

}

on envVar A_FSG_40_0_0_49_Data_5_SetGet
{
	byte superval[8];

	//Update Childvalue (String)
	word i;
	byte thisval[41];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param5[i] = thisval[i];
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param5_Length = getValueSize(this);
    A_FSG_40_0_0_49_Data_5_SetGet_LenList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_40_0_0_49_Data_5_SetGet_len, getValueSize(this));
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_6_SetGet_range // CombinedNumbers.Day 
{
	@A_FSG_40_0_0_49_Data_6_SetGet = @A_FSG_40_0_0_49_Data_6_SetGet_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_6_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Day
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_6_SetGet, 1.0);
	@A_FSG_40_0_0_49_Data_6_SetGet_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param6 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_7_SetGet_range // CombinedNumbers.Month 
{
	@A_FSG_40_0_0_49_Data_7_SetGet = @A_FSG_40_0_0_49_Data_7_SetGet_range - (1); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_7_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Month
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_7_SetGet, 1.0);
	@A_FSG_40_0_0_49_Data_7_SetGet_range = slider_value + (1); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (1) - (1)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param7 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_8_SetGet_range // CombinedNumbers.Year 
{
	@A_FSG_40_0_0_49_Data_8_SetGet = @A_FSG_40_0_0_49_Data_8_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_8_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Year
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_8_SetGet, 1.0);
	@A_FSG_40_0_0_49_Data_8_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param8 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_9_SetGet_range // CombinedNumbers.Hour 
{
	@A_FSG_40_0_0_49_Data_9_SetGet = @A_FSG_40_0_0_49_Data_9_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_9_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Hour
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_9_SetGet, 1.0);
	@A_FSG_40_0_0_49_Data_9_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param9 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_10_SetGet_range // CombinedNumbers.Minute 
{
	@A_FSG_40_0_0_49_Data_10_SetGet = @A_FSG_40_0_0_49_Data_10_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_10_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Minute
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_10_SetGet, 1.0);
	@A_FSG_40_0_0_49_Data_10_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param10 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_49_Data_11_SetGet_range // CombinedNumbers.Second 
{
	@A_FSG_40_0_0_49_Data_11_SetGet = @A_FSG_40_0_0_49_Data_11_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_49_Data_11_SetGet
{
	byte superval[8];

	//Update Childvalue (Number)
	byte thisval; // Second
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_49_Data_11_SetGet, 1.0);
	@A_FSG_40_0_0_49_Data_11_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_49_ArrayDataList[getValue(A_FSG_40_0_0_49_DataIndex_SetGet)].Param11 = thisval;
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_50_ErrCode
{
       if(gM_FSG_40_0_0_50_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_50", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_50_ErrCode = 1;
}
on envVar M_FSG_40_0_0_50Result_BTN
{
  if (M_FSG_40_0_0_50Result_BTN_already_pressed == 0)
  {
     putValue(M_FSG_40_0_0_50_ErrCode,0);
     SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_50",MakeRGB(255,255,255));
     M_FSG_40_0_0_50Result_BTN_already_pressed = 1;
  }
  else
  {
     putValue(M_FSG_40_0_0_50_State, "Result");
     Request_Int8(LSGID, M_FSG_40_0_0_50_ID, Result_REQ, getValue(M_FSG_40_0_0_50_Result));
     M_FSG_40_0_0_50Result_BTN_already_pressed = 0;
  }
}
on envVar M_FSG_40_0_0_50_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_50_ID;
    data[2]=getValue(M_FSG_40_0_0_50_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_50
on envVar M_FSG_40_0_0_50_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_50",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_50",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_50",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_50", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_50",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_50",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_50",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_50_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_50", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_50_Result // bus value of CallStackDeleteAll (50).
{
	// opcodes: Error-Processing-Result
	byte param1; // CallStackDeleteAll_Result
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_50_Result);
	putValue(M_FSG_40_0_0_50_Result_1, param1);
}

on envVar M_FSG_40_0_0_50_Result_1 // CallStackDeleteAll.CallStackDeleteAll_Result
{
	byte superval;

	//Update Childvalue (Enum)
	byte thisval; // CallStackDeleteAll_Result
	thisval = getValue(this);

    // Update superval
	superval = getValue(M_FSG_40_0_0_50_Result);
	superval = thisval;
	putValue(M_FSG_40_0_0_50_Result,superval);
}

on envVar M_FSG_40_0_0_50_Processing // bus value of CallStackDeleteAll (50).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_50_Processing);
	putValue(M_FSG_40_0_0_50_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_50_Processing_1_range // CallStackDeleteAll.Reserve1 
{
	@M_FSG_40_0_0_50_Processing_1 = @M_FSG_40_0_0_50_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_50_Processing_1 // CallStackDeleteAll.Reserve1
{
	byte superval;

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_50_Processing_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	superval = getValue(M_FSG_40_0_0_50_Processing);
	superval = thisval;
	putValue(M_FSG_40_0_0_50_Processing,superval);
}

on envVar M_FSG_40_0_0_50_Start // bus value of CallStackDeleteAll (50).
{
	// opcodes: StartResult
	byte param1; // Storage
	// DATATYPE_UINTXX
	param1 = getValue(M_FSG_40_0_0_50_Start);
	putValue(M_FSG_40_0_0_50_Start_1, param1);
}

on envVar M_FSG_40_0_0_50_Start_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Storage
	bitval= getValue(this);
	thisval = getValue(M_FSG_40_0_0_50_Start_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(M_FSG_40_0_0_50_Start_1,thisval);
}

on envVar M_FSG_40_0_0_50_Start_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Storage
	bitval= getValue(this);
	thisval = getValue(M_FSG_40_0_0_50_Start_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(M_FSG_40_0_0_50_Start_1,thisval);
}

on envVar M_FSG_40_0_0_50_Start_1_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // Storage
	bitval= getValue(this);
	thisval = getValue(M_FSG_40_0_0_50_Start_1);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(M_FSG_40_0_0_50_Start_1,thisval);
}

on envVar M_FSG_40_0_0_50_Start_1 // CallStackDeleteAll.Storage
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Storage
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(M_FSG_40_0_0_50_Start_1_0, 1);
	else
		putValue(M_FSG_40_0_0_50_Start_1_0, 0);
	if(thisval&(mask<<1))
		putValue(M_FSG_40_0_0_50_Start_1_1, 1);
	else
		putValue(M_FSG_40_0_0_50_Start_1_1, 0);
	if(thisval&(mask<<2))
		putValue(M_FSG_40_0_0_50_Start_1_2, 1);
	else
		putValue(M_FSG_40_0_0_50_Start_1_2, 0);

    // Update superval
	superval = getValue(M_FSG_40_0_0_50_Start);
	superval = thisval;
	putValue(M_FSG_40_0_0_50_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_51_ErrCode
{
       if(gP_FSG_40_0_0_51_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_51", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_51_ErrCode = 1;
}
on envVar P_FSG_40_0_0_51Status_BTN
{
	byte BAPTemp[3];
   if (P_FSG_40_0_0_51Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_40_0_0_51_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_51",MakeRGB(255,255,255));
      P_FSG_40_0_0_51Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_40_0_0_51, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_40_0_0_51_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_51));
      P_FSG_40_0_0_51Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_40_0_0_51_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_51_ID;
    data[2]=getValue(P_FSG_40_0_0_51_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_51
on envVar P_FSG_40_0_0_51_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_51",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_51",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_51",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_51", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_51",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_51",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_51",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_51", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_51 // bus value of PbState (51).
{
	// opcodes: Error-Status
	byte param1; // DownloadState
	word param2; // PbEntriesUHV
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[3];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_51, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_40_0_0_51_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_51_2, round((param2 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_40_0_0_51_1 // PbState.DownloadState
{
	byte superval[3];

	//Update Childvalue (Enum)
	byte thisval; // DownloadState
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_40_0_0_51, superval);
	superval[0]=thisval;
	putValue(P_FSG_40_0_0_51,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_51_2_range // PbState.PbEntriesUHV 
{
	@P_FSG_40_0_0_51_2 = @P_FSG_40_0_0_51_2_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_51_2 // PbState.PbEntriesUHV
{
	byte superval[3];

	//Update Childvalue (Number)
	word thisval; // PbEntriesUHV
	float slider_value;

	slider_value = round(@P_FSG_40_0_0_51_2, 1.0);
	@P_FSG_40_0_0_51_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_40_0_0_51, superval);
	superval[1]=thisval&0x00ff;
	superval[2]=(thisval&0xff00)>>8;
	putValue(P_FSG_40_0_0_51,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_40_0_0_52_ErrCode
{
       if(gA_FSG_40_0_0_52_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_52", MakeRGB(255,255,255));
       }
       gA_FSG_40_0_0_52_ErrCode = 1;
}
on envVar A_FSG_40_0_0_52Changed_BTN
{
    byte data[2076]; 
    byte stringValue[2076];
    byte head[5];
    int i;
    int headLength;
    long tempValue;
    word currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_40_0_0_52Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_52_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_52",MakeRGB(255,255,255));
        A_FSG_40_0_0_52Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_52_Changed);
        getValue(A_FSG_40_0_0_52_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_52_Changed_Start);
     elementsVal = getValue(A_FSG_40_0_0_52_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_52_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_40_0_0_52_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_40_0_0_52_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_40_0_0_52_ID);
       }
       if(getValue(A_FSG_40_0_0_52_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_40_0_0_52_ID,getValueSize(A_FSG_40_0_0_52_Changed));
       }
        A_FSG_40_0_0_52Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_52Status_BTN
{
    byte data[2076 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[2076];
    byte head[5];
    int i = 0;
    int j = 0;
    long StringLength = 0;
    int headLength;
    long tempValue;
    word currentPos;

    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_40_0_0_52Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_52_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_52",MakeRGB(255,255,255));
        A_FSG_40_0_0_52Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_52_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_52_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_52_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_52);
        getValue(A_FSG_40_0_0_52,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_52_Start);
     elementsVal = getValue(A_FSG_40_0_0_52_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_52_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_52_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_52_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Storage:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable AnyVoiceTag:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumberQuantity:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumber(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_52_ArrayDataList[i].Param6_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_52_Data_6_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 410-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 410-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_52_Data_6_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 410-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 410-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param6[j];
        }
       }
      // Check if the current value of RecAdr enables the variable VoiceTag(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Reserve(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param8) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param8 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable AdressIndication:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_52_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_52_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_52_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_52_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Storage:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable AnyVoiceTag:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumberQuantity:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumber(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_52_ArrayDataList[i].Param6_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_52_Data_6_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 410-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 410-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_52_Data_6_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 410-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 410-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param6[j];
        }
       }
      // Check if the current value of RecAdr enables the variable VoiceTag(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Reserve(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param8) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param8 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable AdressIndication:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_40_0_0_52, data);
        Request_ByteSequence(LSGID, A_FSG_40_0_0_52_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_40_0_0_52_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_40_0_0_52_ID);
        }
        if(getValue(A_FSG_40_0_0_52_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_40_0_0_52_ID,getValueSize(A_FSG_40_0_0_52));
        }
        A_FSG_40_0_0_52Status_BTN_already_pressed = 0;
    }
}
A_FSG_40_0_0_52_SendStatus()
{
    word currentPos;
    word headLength;
    int i;
    int j;
    word StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[2076];
    byte stringValue[2076];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_52_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_52_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_52_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (tempValue ) & 0xFF;
        data[currentPos++] = (tempValue >> 8) & 0xFF;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_52);
        getValue(A_FSG_40_0_0_52,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_52_Start);
     elementsVal = getValue(A_FSG_40_0_0_52_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_52_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_52_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_52_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Storage:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable AnyVoiceTag:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumberQuantity:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumber(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_52_ArrayDataList[i].Param6_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_52_Data_6_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 410-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 410-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_52_Data_6_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 410-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 410-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param6[j];
        }
       }
      // Check if the current value of RecAdr enables the variable VoiceTag(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Reserve(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param8) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param8 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable AdressIndication:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_52_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_52_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 52");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable PbName:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_52_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_52_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_52_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable Storage:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable AnyVoiceTag:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param4) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param4 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumberQuantity:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param5) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param5 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable TelNumber(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_52_ArrayDataList[i].Param6_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_52_Data_6_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 410-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 410-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_52_Data_6_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 410-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_6 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 410-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_52_ArrayDataList[i].Param6[j];
        }
       }
      // Check if the current value of RecAdr enables the variable VoiceTag(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param7) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param7 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable Reserve(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        if(nibbleSetted == 1)
        {
            // nibble ist 2. Nibble, increment nach Parameter setzen
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param8) & 0x0F | (data[currentPos] &0xF0);
            currentPos++;
            nibbleSetted = 0;
        }
        else
        {
            // nibble ist 1. Nibble, kein increment
            data[currentPos] = (A_FSG_40_0_0_52_ArrayDataList[i].Param8 <<4 ) & 0xF0;
            nibbleSetted = 1;
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType(n):
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 2 == getValue( A_FSG_40_0_0_52_RecAdr ) || 3 == getValue( A_FSG_40_0_0_52_RecAdr ) || 4 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param9 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable AdressIndication:
      if( 0 || 0 == getValue( A_FSG_40_0_0_52_RecAdr ) || 1 == getValue( A_FSG_40_0_0_52_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_52_ArrayDataList[i].Param10 ) & 0xFF;
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_40_0_0_52_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_40_0_0_52
{
    byte temp[2076];
    getValue(A_FSG_40_0_0_52, temp);
    putValue(A_FSG_40_0_0_52_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_52_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_52_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_52_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_52_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_40_0_0_52_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_40_0_0_52_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_52_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_52_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_52_IndexSize))
    {
        putValue(A_FSG_40_0_0_52_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_40_0_0_52_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_40_0_0_52_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_40_0_0_52_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_40_0_0_52_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_52_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_52_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_52_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_52_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_52_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_52_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_52_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_52_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_52_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_52_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_52_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_52_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_52_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_40_0_0_52, head, headLength); 
}

on envVar A_FSG_40_0_0_52_RecAdr
{
    A_FSG_40_0_0_52_GenerateStatus();
}

on envVar A_FSG_40_0_0_52_Shift
{
    A_FSG_40_0_0_52_GenerateStatus();
}

on envVar A_FSG_40_0_0_52_Direction
{
    A_FSG_40_0_0_52_GenerateStatus();
}

on envVar A_FSG_40_0_0_52_Start
{
    A_FSG_40_0_0_52_GenerateStatus();
}

on envVar A_FSG_40_0_0_52_Elements
{
    A_FSG_40_0_0_52_GenerateStatus();
}

on envVar A_FSG_40_0_0_52_IndexSize
{
    A_FSG_40_0_0_52_GenerateStatus();
}
on envVar A_FSG_40_0_0_52_TransPos
{
    A_FSG_40_0_0_52_GenerateStatus();
}
A_FSG_40_0_0_52_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_52_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_52_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_52_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_52_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_52_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_52_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_52_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_52_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_52_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_52_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_52_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_40_0_0_52_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_52_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_52_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_40_0_0_52_Changed, head, 3); 
    }
}

on envVar A_FSG_40_0_0_52_Changed_RecAdr
{
    A_FSG_40_0_0_52_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_52_Changed_Shift
{
    A_FSG_40_0_0_52_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_52_Changed_Direction
{
    A_FSG_40_0_0_52_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_52_Changed_Start
{
    A_FSG_40_0_0_52_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_52_Changed_Elements
{
    A_FSG_40_0_0_52_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_52_Changed_IndexSize
{
    A_FSG_40_0_0_52_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_52_Changed_TransPos
{
    A_FSG_40_0_0_52_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_52_SetGet
{
    byte temp[2076];
    getValue(A_FSG_40_0_0_52_SetGet, temp);
    putValue(A_FSG_40_0_0_52_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_52_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_52_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_52_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_52_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_52_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_52_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_52_SetGet_IndexSize))
    {
        putValue(A_FSG_40_0_0_52_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_40_0_0_52_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_40_0_0_52_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_40_0_0_52_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_40_0_0_52_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp3[25];
	char temp4[25];
	char temp5[25];
	char temp7[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_40_0_0_52_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_40_0_0_52_ArrayDataList[i].Param1 = 0;
		for(j=0; j<100; j++)
			A_FSG_40_0_0_52_ArrayDataList[i].Param2[j] = 0;
		A_FSG_40_0_0_52_ArrayDataList[i].Param2_Length = 0;
		A_FSG_40_0_0_52_Data_2_LenList[i] = 0;
		A_FSG_40_0_0_52_ArrayDataList[i].Param3 = 0;
		A_FSG_40_0_0_52_ArrayDataList[i].Param4 = 0;
		A_FSG_40_0_0_52_ArrayDataList[i].Param5 = 0;
		for(j=0; j<410; j++)
			A_FSG_40_0_0_52_ArrayDataList[i].Param6[j] = 0;
		A_FSG_40_0_0_52_ArrayDataList[i].Param6_Length = 0;
		A_FSG_40_0_0_52_Data_6_LenList[i] = 0;
		A_FSG_40_0_0_52_ArrayDataList[i].Param7 = 0;
		A_FSG_40_0_0_52_ArrayDataList[i].Param8 = 0;
		A_FSG_40_0_0_52_ArrayDataList[i].Param9 = 0;
		A_FSG_40_0_0_52_ArrayDataList[i].Param10 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_40_0_0_52_fileSelector,gListPath);
  
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 1501) //ignore first line in *.csv file
					{
						A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //Storage
						A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param4 = atol(temp4); //AnyVoiceTag
						A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param5 = atol(temp5); //TelNumberQuantity
						A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param7 = atol(temp7); //VoiceTag(n)
						A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param8 = atol(temp8); //Reserve(n)
						A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param9 = atol(temp9); //NumberType(n)
						A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param10 = atol(temp10); //AdressIndication
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp3[i]=0;
							temp4[i]=0;
							temp5[i]=0;
							temp7[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 1501)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //PbName
								if(paramPos < 99)
								{
									A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //Storage
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //AnyVoiceTag
								if( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //TelNumberQuantity
								if( paramPos >= elCount(temp5) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp5[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 6: //TelNumber(n)
								if(paramPos < 408)
								{
									A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param6[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_52_ArrayDataList[current_CSV_line-1].Param6_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 7: //VoiceTag(n)
								if( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //Reserve(n)
								if( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //NumberType(n)
								if( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //AdressIndication
								if( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_40_0_0_52_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_40_0_0_52_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_52_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_40_0_0_52_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_40_0_0_52_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_40_0_0_52_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_40_0_0_52_Data_1, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_52_Data_2, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param2, A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_52_Data_3, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_52_Data_4, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param4);
	putValue(A_FSG_40_0_0_52_Data_5, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param5);
	putValue(A_FSG_40_0_0_52_Data_6, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param6, A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param6_Length);
	putValue(A_FSG_40_0_0_52_Data_7, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param7);
	putValue(A_FSG_40_0_0_52_Data_8, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param8);
	putValue(A_FSG_40_0_0_52_Data_9, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param9);
	putValue(A_FSG_40_0_0_52_Data_10, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param10);
}


on envVar A_FSG_40_0_0_52_generateData_Btn
{
	word i;
	dword elementsArray[12] = {2, 100, 2, 1, 1, 1, 410, 2, 1, 1, 1, 1};
	byte elementsTypeArray[12] = {0, 0xE, 0xF, 0, 0, 0, 0xE, 0xF, 0, 0, 0, 0};
	dword elementsMaxSizeArray[12] = {65535, 0, 0, 0xFF, 0xF, 10, 0, 0, 0xF, 0xF, 0xFF, 0xFF};
	byte tempArray[784500];
	if (A_FSG_40_0_0_52_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_52_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 52, 1500 );
		for(i = 0; i < 1500; i++)
		{
			memcpy(A_FSG_40_0_0_52_ArrayDataList[i], tempArray, (i * 523) );
			if(A_FSG_40_0_0_52_ArrayDataList[i].Param2_Length > 127 )
				A_FSG_40_0_0_52_Data_2_CntList[i] = 1;
			if(A_FSG_40_0_0_52_ArrayDataList[i].Param6_Length > 127 )
				A_FSG_40_0_0_52_Data_6_CntList[i] = 1;
		}
		A_FSG_40_0_0_52_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_40_0_0_52_Data_1, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_52_Data_2, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param2, A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_52_Data_3, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_52_Data_4, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param4);
	putValue(A_FSG_40_0_0_52_Data_5, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param5);
	putValue(A_FSG_40_0_0_52_Data_6, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param6, A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param6_Length);
	putValue(A_FSG_40_0_0_52_Data_7, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param7);
	putValue(A_FSG_40_0_0_52_Data_8, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param8);
	putValue(A_FSG_40_0_0_52_Data_9, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param9);
	putValue(A_FSG_40_0_0_52_Data_10, A_FSG_40_0_0_52_ArrayDataList[ getValue( A_FSG_40_0_0_52_DataIndex) ].Param10);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_40_0_0_52_DataIndex
{
    long index;
    long maxIndex = 1500-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_52_Data_1, A_FSG_40_0_0_52_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_52_Data_2_len, A_FSG_40_0_0_52_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_52_Data_2_cnt, A_FSG_40_0_0_52_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_52_Data_2, A_FSG_40_0_0_52_ArrayDataList[index].Param2, A_FSG_40_0_0_52_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_52_Data_3, A_FSG_40_0_0_52_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_52_Data_4, A_FSG_40_0_0_52_ArrayDataList[index].Param4);
    putValue(A_FSG_40_0_0_52_Data_5, A_FSG_40_0_0_52_ArrayDataList[index].Param5);
    putValue(A_FSG_40_0_0_52_Data_6_len, A_FSG_40_0_0_52_Data_6_LenList[index]);
    putValue(A_FSG_40_0_0_52_Data_6_cnt, A_FSG_40_0_0_52_Data_6_CntList[index]);
    putValue(A_FSG_40_0_0_52_Data_6, A_FSG_40_0_0_52_ArrayDataList[index].Param6, A_FSG_40_0_0_52_ArrayDataList[index].Param6_Length);
    putValue(A_FSG_40_0_0_52_Data_7, A_FSG_40_0_0_52_ArrayDataList[index].Param7);
    putValue(A_FSG_40_0_0_52_Data_8, A_FSG_40_0_0_52_ArrayDataList[index].Param8);
    putValue(A_FSG_40_0_0_52_Data_9, A_FSG_40_0_0_52_ArrayDataList[index].Param9);
    putValue(A_FSG_40_0_0_52_Data_10, A_FSG_40_0_0_52_ArrayDataList[index].Param10);

}
on envVar A_FSG_40_0_0_52_DataIndex_Incr
{
    long index;
    if(A_FSG_40_0_0_52_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_52_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_52_DataIndex);
        index++;
        putValue(A_FSG_40_0_0_52_DataIndex, index);
        A_FSG_40_0_0_52_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_52_DataIndex_Decr
{
    long index;
    if(A_FSG_40_0_0_52_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_52_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_52_DataIndex);
        index--;
        putValue(A_FSG_40_0_0_52_DataIndex, index);
        A_FSG_40_0_0_52_DataIndex_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_52_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_40_0_0_52_ID;
    data[2]=getValue(A_FSG_40_0_0_52_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_40_0_0_52
on envVar A_FSG_40_0_0_52_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_52",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_52",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_52",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_52_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_52", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_52",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_52",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_52",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_52_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_52", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_52_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_52_SegmEn,0);
           intertelegram_err(A_FSG_40_0_0_52_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_40_0_0_52_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_52_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_52_IntTlgEn,0);
           sequence_err(A_FSG_40_0_0_52_ID,getValueSize(A_FSG_40_0_0_52_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_40_0_0_52_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_40_0_0_52_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_40_0_0_52_Status",1);
 	}
}



A_FSG_40_0_0_52_SetInd () { /* leere Function*/ }

A_FSG_40_0_0_52_SetGetInd () { /* leere Function*/ }

A_FSG_40_0_0_52_GetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[2076];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_52_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_52_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_52_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_52_AT))
                {
                    putValue(A_FSG_40_0_0_52,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_52_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_52_AT))
            {
                putValue(A_FSG_40_0_0_52,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_52_AT))
        {
            putValue(A_FSG_40_0_0_52_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_52_Start, startVal);
            putValue(A_FSG_40_0_0_52_Elements, elementsVal);
            putValue(A_FSG_40_0_0_52_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_40_0_0_52_1
{
	byte superval[2076];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_52_2_range // Phonebook.TAID 
{
	@A_FSG_40_0_0_52_2 = @A_FSG_40_0_0_52_2_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_52_2
{
	byte superval[2076];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_52_2, 1.0);
	@A_FSG_40_0_0_52_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_52_3_range // Phonebook.TotalNumListElements 
{
	@A_FSG_40_0_0_52_3 = @A_FSG_40_0_0_52_3_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_52_3
{
	byte superval[2076];

	//Update Childvalue (Number)
	word thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_52_3, 1.0);
	@A_FSG_40_0_0_52_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_52_Data_1_range // Phonebook.Pos 
{
	@A_FSG_40_0_0_52_Data_1 = @A_FSG_40_0_0_52_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_52_Data_1
{
	byte superval[2076];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_52_Data_1, 1.0);
	@A_FSG_40_0_0_52_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_52_Data_2_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_52_Data_2_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_52_Data_2_CntList[ getValue(A_FSG_40_0_0_52_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_52_Data_2_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_52_Data_2_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_52_Data_2_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_52_Data_2_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param2_Length = thisval;
	A_FSG_40_0_0_52_Data_2_LenList[ getValue(A_FSG_40_0_0_52_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_52_Data_2_len, thisval);

}

on envVar A_FSG_40_0_0_52_Data_2
{
	byte superval[2076];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param2[i] = thisval[i];
    A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_52_Data_2_LenList[getValue(A_FSG_40_0_0_52_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_52_Data_2_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_52_Data_3
{
	byte superval[2076];

	//Update Childvalue (Enum)
	byte thisval; // Storage
	thisval = getValue(this);
    A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param3 = thisval;
}
on envVar A_FSG_40_0_0_52_Data_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AnyVoiceTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_40_0_0_52_Data_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_FSG_40_0_0_52_Data_4,thisval);
}

on envVar A_FSG_40_0_0_52_Data_4_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AnyVoiceTag
	bitval= getValue(this);
	thisval = getValue(A_FSG_40_0_0_52_Data_4);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_FSG_40_0_0_52_Data_4,thisval);
}

on envVar A_FSG_40_0_0_52_Data_4
{
	byte superval[2076];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // AnyVoiceTag
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_FSG_40_0_0_52_Data_4_0, 1);
	else
		putValue(A_FSG_40_0_0_52_Data_4_0, 0);
	if(thisval&(mask<<1))
		putValue(A_FSG_40_0_0_52_Data_4_1, 1);
	else
		putValue(A_FSG_40_0_0_52_Data_4_1, 0);
    A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param4 = thisval;
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_52_Data_5_range // Phonebook.TelNumberQuantity 
{
	@A_FSG_40_0_0_52_Data_5 = @A_FSG_40_0_0_52_Data_5_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_52_Data_5
{
	byte superval[2076];

	//Update Childvalue (Number)
	byte thisval; // TelNumberQuantity
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_52_Data_5, 1.0);
	@A_FSG_40_0_0_52_Data_5_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param5 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_52_Data_6_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_52_Data_6_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_52_Data_6_CntList[ getValue(A_FSG_40_0_0_52_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_52_Data_6_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_52_Data_6_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_52_Data_6_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 408 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_52_Data_6 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 408);
		thisval = 408;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_52_Data_6_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param6_Length = thisval;
	A_FSG_40_0_0_52_Data_6_LenList[ getValue(A_FSG_40_0_0_52_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_52_Data_6_len, thisval);

}

on envVar A_FSG_40_0_0_52_Data_6
{
	byte superval[2076];

	//Update Childvalue (String)
	word i;
	byte thisval[410];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param6[i] = thisval[i];
    A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param6_Length = getValueSize(this);
    A_FSG_40_0_0_52_Data_6_LenList[getValue(A_FSG_40_0_0_52_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_52_Data_6_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_52_Data_7_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // VoiceTag(n)
	bitval= getValue(this);
	thisval = getValue(A_FSG_40_0_0_52_Data_7);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_FSG_40_0_0_52_Data_7,thisval);
}

on envVar A_FSG_40_0_0_52_Data_7
{
	byte superval[2076];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // VoiceTag(n)
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_FSG_40_0_0_52_Data_7_0, 1);
	else
		putValue(A_FSG_40_0_0_52_Data_7_0, 0);
    A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param7 = thisval;
}
on envVar A_FSG_40_0_0_52_Data_8
{
	byte superval[2076];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // Reserve(n)
	thisval = getValue(this);
    A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param8 = thisval;
}
on envVar A_FSG_40_0_0_52_Data_9
{
	byte superval[2076];

	//Update Childvalue (Enum)
	byte thisval; // NumberType(n)
	thisval = getValue(this);
    A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param9 = thisval;
}
on envVar A_FSG_40_0_0_52_Data_10_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AdressIndication
	bitval= getValue(this);
	thisval = getValue(A_FSG_40_0_0_52_Data_10);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(A_FSG_40_0_0_52_Data_10,thisval);
}

on envVar A_FSG_40_0_0_52_Data_10_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AdressIndication
	bitval= getValue(this);
	thisval = getValue(A_FSG_40_0_0_52_Data_10);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(A_FSG_40_0_0_52_Data_10,thisval);
}

on envVar A_FSG_40_0_0_52_Data_10_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AdressIndication
	bitval= getValue(this);
	thisval = getValue(A_FSG_40_0_0_52_Data_10);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(A_FSG_40_0_0_52_Data_10,thisval);
}

on envVar A_FSG_40_0_0_52_Data_10_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AdressIndication
	bitval= getValue(this);
	thisval = getValue(A_FSG_40_0_0_52_Data_10);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(A_FSG_40_0_0_52_Data_10,thisval);
}

on envVar A_FSG_40_0_0_52_Data_10_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AdressIndication
	bitval= getValue(this);
	thisval = getValue(A_FSG_40_0_0_52_Data_10);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(A_FSG_40_0_0_52_Data_10,thisval);
}

on envVar A_FSG_40_0_0_52_Data_10_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AdressIndication
	bitval= getValue(this);
	thisval = getValue(A_FSG_40_0_0_52_Data_10);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(A_FSG_40_0_0_52_Data_10,thisval);
}

on envVar A_FSG_40_0_0_52_Data_10
{
	byte superval[2076];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // AdressIndication
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(A_FSG_40_0_0_52_Data_10_0, 1);
	else
		putValue(A_FSG_40_0_0_52_Data_10_0, 0);
	if(thisval&(mask<<1))
		putValue(A_FSG_40_0_0_52_Data_10_1, 1);
	else
		putValue(A_FSG_40_0_0_52_Data_10_1, 0);
	if(thisval&(mask<<2))
		putValue(A_FSG_40_0_0_52_Data_10_2, 1);
	else
		putValue(A_FSG_40_0_0_52_Data_10_2, 0);
	if(thisval&(mask<<3))
		putValue(A_FSG_40_0_0_52_Data_10_3, 1);
	else
		putValue(A_FSG_40_0_0_52_Data_10_3, 0);
	if(thisval&(mask<<4))
		putValue(A_FSG_40_0_0_52_Data_10_4, 1);
	else
		putValue(A_FSG_40_0_0_52_Data_10_4, 0);
	if(thisval&(mask<<5))
		putValue(A_FSG_40_0_0_52_Data_10_5, 1);
	else
		putValue(A_FSG_40_0_0_52_Data_10_5, 0);
    A_FSG_40_0_0_52_ArrayDataList[getValue(A_FSG_40_0_0_52_DataIndex)].Param10 = thisval;
}
on envVar A_FSG_40_0_0_52_1_SetGet
{
	byte superval[6];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_52_2_SetGet_range // Phonebook.TAID 
{
	@A_FSG_40_0_0_52_2_SetGet = @A_FSG_40_0_0_52_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_52_2_SetGet
{
	byte superval[6];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_52_2_SetGet, 1.0);
	@A_FSG_40_0_0_52_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_53_ErrCode
{
       if(gM_FSG_40_0_0_53_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_53", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_53_ErrCode = 1;
}
on envVar M_FSG_40_0_0_53Result_BTN
{
    byte temp[5];
    if (M_FSG_40_0_0_53Result_BTN_already_pressed == 0)
    {
        putValue(M_FSG_40_0_0_53_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_53",MakeRGB(255,255,255));
        M_FSG_40_0_0_53Result_BTN_already_pressed = 1;
    }
    else
    {
        putValue(M_FSG_40_0_0_53_State, "Result");
        getValue(M_FSG_40_0_0_53_Result, temp);
        Request_ByteSequence(LSGID, M_FSG_40_0_0_53_ID, Result_REQ, temp, getValueSize(M_FSG_40_0_0_53_Result));
        M_FSG_40_0_0_53Result_BTN_already_pressed = 0;
    }
}
on envVar M_FSG_40_0_0_53_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_53_ID;
    data[2]=getValue(M_FSG_40_0_0_53_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_53
on envVar M_FSG_40_0_0_53_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_53",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_53",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_53",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_53", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_53",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_53",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_53",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_53_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_53", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_53_Result // bus value of PbSpeller (53).
{
	// opcodes: Error-Processing-Result
	byte param1; // PbSpeller_Result
	word param2; // MatchingEntries
	word param3; // Pos
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[5];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_40_0_0_53_Result, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_40_0_0_53_Result_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_40_0_0_53_Result_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_40_0_0_53_Result_3, round((param3 * 1.0) - (0) + (0), 1.0));
}

on envVar M_FSG_40_0_0_53_Result_1 // PbSpeller.PbSpeller_Result
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // PbSpeller_Result
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_40_0_0_53_Result, superval);
	superval[0]=thisval;
	putValue(M_FSG_40_0_0_53_Result,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_53_Result_2_range // PbSpeller.MatchingEntries 
{
	@M_FSG_40_0_0_53_Result_2 = @M_FSG_40_0_0_53_Result_2_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_53_Result_2 // PbSpeller.MatchingEntries
{
	byte superval[5];

	//Update Childvalue (Number)
	word thisval; // MatchingEntries
	float slider_value;

	slider_value = round(@M_FSG_40_0_0_53_Result_2, 1.0);
	@M_FSG_40_0_0_53_Result_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_40_0_0_53_Result, superval);
	superval[1]=thisval&0x00ff;
	superval[2]=(thisval&0xff00)>>8;
	putValue(M_FSG_40_0_0_53_Result,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_53_Result_3_range // PbSpeller.Pos 
{
	@M_FSG_40_0_0_53_Result_3 = @M_FSG_40_0_0_53_Result_3_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_53_Result_3 // PbSpeller.Pos
{
	byte superval[5];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@M_FSG_40_0_0_53_Result_3, 1.0);
	@M_FSG_40_0_0_53_Result_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_40_0_0_53_Result, superval);
	superval[3]=thisval&0x00ff;
	superval[4]=(thisval&0xff00)>>8;
	putValue(M_FSG_40_0_0_53_Result,superval);
}

on envVar M_FSG_40_0_0_53_Processing // bus value of PbSpeller (53).
{
	// opcodes: Error-Processing-Result
	byte param1[5]; // Reserve1
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[5];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_40_0_0_53_Processing, superval);
	///////// Start param1 - STRING (fixedBytesequnece)/////////
	for( i = 0; i < 5; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(M_FSG_40_0_0_53_Processing_1, param1, 5);
}

on envVar M_FSG_40_0_0_53_Processing_1 // PbSpeller.Reserve1
{
	byte superval[5];

	//Update Childvalue (String)
	word i;
	byte thisval[5];
	getValue(this, thisval);

    // Update superval
	getValue(M_FSG_40_0_0_53_Processing, superval);
	for( i = 0; i < 5; i++ )
	{
		superval[i+0] = thisval[i];
	}
	putValue(M_FSG_40_0_0_53_Processing,superval);
}

on envVar M_FSG_40_0_0_53_Start // bus value of PbSpeller (53).
{
	// opcodes: StartResult
	byte param1; // Mode
	byte param2[50]; // SearchString
	word len2;
	byte cnt2;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[51];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 51; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_40_0_0_53_Start, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_40_0_0_53_Start_1, param1);
	///////// Start param2 - STRING /////////
	//getValue(M_FSG_40_0_0_53_Start_2, param2);
  getValue(M_FSG_40_0_0_53_Start_2_Hex, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(49>127) /* Max Fct-Katalog Laenge: 49*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 49;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_40_0_0_53_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 49)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 49;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(M_FSG_40_0_0_53_Start_2_len, len2);
	putValue(M_FSG_40_0_0_53_Start_2_cnt, cnt2);
	
  if(len2 > getValueSize(M_FSG_40_0_0_53_Start_2_Hex))
		putValue(M_FSG_40_0_0_53_Start_2_Hex, param2, len2);
	else
		putValue(M_FSG_40_0_0_53_Start_2_Hex, param2, getValueSize(M_FSG_40_0_0_53_Start_2_Hex));
  
	/*if(len2 > getValueSize(M_FSG_40_0_0_53_Start_2))
		putValue(M_FSG_40_0_0_53_Start_2, param2, len2);
	else
		putValue(M_FSG_40_0_0_53_Start_2, param2, getValueSize(M_FSG_40_0_0_53_Start_2));*/

}

// Updates the bus value field and other dependencies.
M_FSG_40_0_0_53_Start_BuildFct()
{
	byte param1; // Mode
	byte param2[50]; // SearchString
	word len2;
	byte cnt2;

	int i;
	byte superval[51];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(M_FSG_40_0_0_53_Start_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	//getValue(M_FSG_40_0_0_53_Start_2, param2);
  getValue(M_FSG_40_0_0_53_Start_2_Hex, param2);
	len2 = getValue(M_FSG_40_0_0_53_Start_2_len);
	cnt2= getValue(M_FSG_40_0_0_53_Start_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 49 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 49)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_53_Start_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 49);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(M_FSG_40_0_0_53_Start_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 49)
		{
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(M_FSG_40_0_0_53_Start_2_len, len2);
			putValue(M_FSG_40_0_0_53_Start_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_53_Start_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 49);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

	putValue(M_FSG_40_0_0_53_Start, superval, currentPos);
}


on envVar M_FSG_40_0_0_53_Start_1 // PbSpeller.Mode
{
	M_FSG_40_0_0_53_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_40_0_0_53_Start_2_cnt
{
	word len;
	byte cnt;
	len = getValue(M_FSG_40_0_0_53_Start_2_len);
	cnt = getValue(M_FSG_40_0_0_53_Start_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_FSG_40_0_0_53_Start_2_len, 127);
		}
	}

	M_FSG_40_0_0_53_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_40_0_0_53_Start_2_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 49)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_53_Start_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 49);
		putValue(this, 49);
	}
	M_FSG_40_0_0_53_Start_BuildFct();
}


on envVar M_FSG_40_0_0_53_Start_2 // PbSpeller.SearchString
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(M_FSG_40_0_0_53_Start_2_Hex,string_buffer_mod,string_length_mod);
  putValue(M_FSG_40_0_0_53_Start_2_len, string_length_mod);
  
	/*putValue(M_FSG_40_0_0_53_Start_2_len, getValueSize(this));
	M_FSG_40_0_0_53_Start_BuildFct();*/
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_54_ErrCode
{
       if(gM_FSG_40_0_0_54_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_54", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_54_ErrCode = 1;
}
on envVar M_FSG_40_0_0_54Result_BTN
{
    byte temp[7];
    if (M_FSG_40_0_0_54Result_BTN_already_pressed == 0)
    {
        putValue(M_FSG_40_0_0_54_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_54",MakeRGB(255,255,255));
        M_FSG_40_0_0_54Result_BTN_already_pressed = 1;
    }
    else
    {
		 M_FSG_40_0_0_54_Result_BuildFct();
        putValue(M_FSG_40_0_0_54_State, "Result");
        getValue(M_FSG_40_0_0_54_Result, temp);
        Request_ByteSequence(LSGID, M_FSG_40_0_0_54_ID, Result_REQ, temp, getValueSize(M_FSG_40_0_0_54_Result));
        if(getValue(M_FSG_40_0_0_54_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(M_FSG_40_0_0_54_ID);
        }
        if(getValue(M_FSG_40_0_0_54_SegmEn))   //getvalue(SG)
        {
            sequence_err(M_FSG_40_0_0_54_ID,getValueSize(M_FSG_40_0_0_54_SegmEn));
        }
        M_FSG_40_0_0_54Result_BTN_already_pressed = 0;
    }
}
on envVar M_FSG_40_0_0_54_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_54_ID;
    data[2]=getValue(M_FSG_40_0_0_54_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_54
on envVar M_FSG_40_0_0_54_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_54",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_54",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_54",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_54", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_54",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_54",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_54",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_54_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_54", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar M_FSG_40_0_0_54_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(M_FSG_40_0_0_54_SegmEn,0);
           intertelegram_err(M_FSG_40_0_0_54_ID);
       }
       else
       {
           intertelegram_err_off(M_FSG_40_0_0_54_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar M_FSG_40_0_0_54_SegmEn
{
       if(getValue(this)) 
       {
           putValue(M_FSG_40_0_0_54_IntTlgEn,0);
           sequence_err(M_FSG_40_0_0_54_ID,getValueSize(M_FSG_40_0_0_54_SegmEn));
       }
       else
       {
              sequence_err_off(M_FSG_40_0_0_54_ID);
       }
}
on envVar M_FSG_40_0_0_54_Result // bus value of GetNextListPos (54).
{
	// opcodes: Error-Processing-Result
	byte param1; // GetNextListPos_Result
	word param2; // currentPos
	word param3; // nextPos
	word param4; // absoluteListPos
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[7];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 7; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_40_0_0_54_Result, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_40_0_0_54_Result_1, param1);
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_40_0_0_54_Result_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_40_0_0_54_Result_3, round((param3 * 1.0) - (0) + (0), 1.0));
	///////// Start param4 - UINT16 /////////
	param4 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_40_0_0_54_Result_4, round((param4 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
M_FSG_40_0_0_54_Result_BuildFct()
{
	byte param1; // GetNextListPos_Result
	word param2; // currentPos
	word param3; // nextPos
	word param4; // absoluteListPos

	int i;
	byte superval[7];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(M_FSG_40_0_0_54_Result_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	@M_FSG_40_0_0_54_Result_2_range = round(@M_FSG_40_0_0_54_Result_2 + (0), 1.0); // slider value + min = real value
	param2 = round( (@M_FSG_40_0_0_54_Result_2 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param2&0x00ff;
	superval[currentPos++]=(param2&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@M_FSG_40_0_0_54_Result_3_range = round(@M_FSG_40_0_0_54_Result_3 + (0), 1.0); // slider value + min = real value
	param3 = round( (@M_FSG_40_0_0_54_Result_3 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param3&0x00ff;
	superval[currentPos++]=(param3&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	@M_FSG_40_0_0_54_Result_4_range = round(@M_FSG_40_0_0_54_Result_4 + (0), 1.0); // slider value + min = real value
	param4 = round( (@M_FSG_40_0_0_54_Result_4 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param4&0x00ff;
	superval[currentPos++]=(param4&0xff00)>>8;
	putValue(M_FSG_40_0_0_54_Result, superval, currentPos);
}


on envVar M_FSG_40_0_0_54_Result_1 // GetNextListPos.GetNextListPos_Result
{
	M_FSG_40_0_0_54_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_54_Result_2_range // GetNextListPos.currentPos 
{
	@M_FSG_40_0_0_54_Result_2 = @M_FSG_40_0_0_54_Result_2_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_54_Result_2 // GetNextListPos.currentPos
{
	M_FSG_40_0_0_54_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_54_Result_3_range // GetNextListPos.nextPos 
{
	@M_FSG_40_0_0_54_Result_3 = @M_FSG_40_0_0_54_Result_3_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_54_Result_3 // GetNextListPos.nextPos
{
	M_FSG_40_0_0_54_Result_BuildFct();
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_54_Result_4_range // GetNextListPos.absoluteListPos 
{
	@M_FSG_40_0_0_54_Result_4 = @M_FSG_40_0_0_54_Result_4_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_54_Result_4 // GetNextListPos.absoluteListPos
{
	M_FSG_40_0_0_54_Result_BuildFct();
}

on envVar M_FSG_40_0_0_54_Processing // bus value of GetNextListPos (54).
{
	// opcodes: Error-Processing-Result
	byte param1; // Reserve1
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[7];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 7; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_40_0_0_54_Processing, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_40_0_0_54_Processing_1, round((param1 * 1.0) - (0) + (0), 1.0));
}

// Updates the bus value field and other dependencies.
M_FSG_40_0_0_54_Processing_BuildFct()
{
	byte param1; // Reserve1

	int i;
	byte superval[7];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	@M_FSG_40_0_0_54_Processing_1_range = round(@M_FSG_40_0_0_54_Processing_1 + (0), 1.0); // slider value + min = real value
	param1 = 0; // underlying parameter has constant value 0.
	superval[currentPos++]=param1;
	putValue(M_FSG_40_0_0_54_Processing, superval, currentPos);
}


// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_54_Processing_1_range // GetNextListPos.Reserve1 
{
	@M_FSG_40_0_0_54_Processing_1 = @M_FSG_40_0_0_54_Processing_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_54_Processing_1 // GetNextListPos.Reserve1
{
	M_FSG_40_0_0_54_Processing_BuildFct();
}

on envVar M_FSG_40_0_0_54_Start // bus value of GetNextListPos (54).
{
	// opcodes: AbortResult-StartResult
	word param1; // currentPos
	word param2; // Offset
	byte param3; // ListType
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[5];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 5; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_40_0_0_54_Start, superval);
	///////// Start param1 - UINT16 /////////
	param1 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_40_0_0_54_Start_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - UINT16 /////////
	param2 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(M_FSG_40_0_0_54_Start_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(M_FSG_40_0_0_54_Start_3, param3);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_54_Start_1_range // GetNextListPos.currentPos 
{
	@M_FSG_40_0_0_54_Start_1 = @M_FSG_40_0_0_54_Start_1_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_54_Start_1 // GetNextListPos.currentPos
{
	byte superval[5];

	//Update Childvalue (Number)
	word thisval; // currentPos
	float slider_value;

	slider_value = round(@M_FSG_40_0_0_54_Start_1, 1.0);
	@M_FSG_40_0_0_54_Start_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_40_0_0_54_Start, superval);
	superval[0]=thisval&0x00ff;
	superval[1]=(thisval&0xff00)>>8;
	putValue(M_FSG_40_0_0_54_Start,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_54_Start_2_range // GetNextListPos.Offset 
{
	@M_FSG_40_0_0_54_Start_2 = @M_FSG_40_0_0_54_Start_2_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_54_Start_2 // GetNextListPos.Offset
{
	byte superval[5];

	//Update Childvalue (Number)
	word thisval; // Offset
	float slider_value;

	slider_value = round(@M_FSG_40_0_0_54_Start_2, 1.0);
	@M_FSG_40_0_0_54_Start_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_40_0_0_54_Start, superval);
	superval[2]=thisval&0x00ff;
	superval[3]=(thisval&0xff00)>>8;
	putValue(M_FSG_40_0_0_54_Start,superval);
}

on envVar M_FSG_40_0_0_54_Start_3 // GetNextListPos.ListType
{
	byte superval[5];

	//Update Childvalue (Enum)
	byte thisval; // ListType
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_40_0_0_54_Start, superval);
	superval[4]=thisval;
	putValue(M_FSG_40_0_0_54_Start,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_55_ErrCode
{
       if(gP_FSG_40_0_0_55_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_55", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_55_ErrCode = 1;
}
on envVar P_FSG_40_0_0_55Status_BTN
{
	byte BAPTemp[4];
   if (P_FSG_40_0_0_55Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_40_0_0_55_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_55",MakeRGB(255,255,255));
      P_FSG_40_0_0_55Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_40_0_0_55, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_40_0_0_55_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_55));
      P_FSG_40_0_0_55Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_40_0_0_55_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_55_ID;
    data[2]=getValue(P_FSG_40_0_0_55_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_55
on envVar P_FSG_40_0_0_55_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_55",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_55",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_55",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_55", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_55",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_55",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_55",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_55", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_55 // bus value of SMSState (55).
{
	// opcodes: Error-Status
	byte param1; // SIMReady
	byte param2; // StorageState
	word param3; // NumberOfNewSMS
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[4];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 4; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_55, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_40_0_0_55_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_40_0_0_55_2, param2);
	///////// Start param3 - UINT16 /////////
	param3 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_55_3, round((param3 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_40_0_0_55_1 // SMSState.SIMReady
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // SIMReady
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_40_0_0_55, superval);
	superval[0]=thisval;
	putValue(P_FSG_40_0_0_55,superval);
}

on envVar P_FSG_40_0_0_55_2 // SMSState.StorageState
{
	byte superval[4];

	//Update Childvalue (Enum)
	byte thisval; // StorageState
	thisval = getValue(this);

    // Update superval
	getValue(P_FSG_40_0_0_55, superval);
	superval[1]=thisval;
	putValue(P_FSG_40_0_0_55,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_55_3_range // SMSState.NumberOfNewSMS 
{
	@P_FSG_40_0_0_55_3 = @P_FSG_40_0_0_55_3_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_55_3 // SMSState.NumberOfNewSMS
{
	byte superval[4];

	//Update Childvalue (Number)
	word thisval; // NumberOfNewSMS
	float slider_value;

	slider_value = round(@P_FSG_40_0_0_55_3, 1.0);
	@P_FSG_40_0_0_55_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_40_0_0_55, superval);
	superval[2]=thisval&0x00ff;
	superval[3]=(thisval&0xff00)>>8;
	putValue(P_FSG_40_0_0_55,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_56_ErrCode
{
       if(gP_FSG_40_0_0_56_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_56", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_56_ErrCode = 1;
}
on envVar P_FSG_40_0_0_56Status_BTN
{
    if (P_FSG_40_0_0_56Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_40_0_0_56_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_56",MakeRGB(255,255,255));
       P_FSG_40_0_0_56Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_40_0_0_56_ID, Data_REQ, getValue(P_FSG_40_0_0_56));
      P_FSG_40_0_0_56Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_56_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_56_ID;
    data[2]=getValue(P_FSG_40_0_0_56_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_56
on envVar P_FSG_40_0_0_56_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_56",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_56",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_56",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_56", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_56",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_56",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_56",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_56", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_56 // bus value of RingToneMuteOnOff (56).
{
	// opcodes: Error-Status
	byte param1; // RingToneMuteOnOff
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_40_0_0_56);
	putValue(P_FSG_40_0_0_56_1, param1);
}

on envVar P_FSG_40_0_0_56_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // RingToneMuteOnOff
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_56_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_56_1,thisval);
}

on envVar P_FSG_40_0_0_56_1 // RingToneMuteOnOff.RingToneMuteOnOff
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // RingToneMuteOnOff
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_40_0_0_56_1_0, 1);
	else
		putValue(P_FSG_40_0_0_56_1_0, 0);

    // Update superval
	superval = getValue(P_FSG_40_0_0_56);
	superval = thisval;
	putValue(P_FSG_40_0_0_56,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_57_ErrCode
{
       if(gP_FSG_40_0_0_57_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_57", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_57_ErrCode = 1;
}
on envVar P_FSG_40_0_0_57Status_BTN
{
    if (P_FSG_40_0_0_57Status_BTN_already_pressed == 0)
    {
       putValue(P_FSG_40_0_0_57_ErrCode,0);
       SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_57",MakeRGB(255,255,255));
       P_FSG_40_0_0_57Status_BTN_already_pressed = 1;
    }
    else
    {
       Request_Int8(LSGID, P_FSG_40_0_0_57_ID, Data_REQ, getValue(P_FSG_40_0_0_57));
      P_FSG_40_0_0_57Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_57_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_57_ID;
    data[2]=getValue(P_FSG_40_0_0_57_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_57
on envVar P_FSG_40_0_0_57_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_57",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_57",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_57",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_57", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_57",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_57",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_57",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_57", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_57 // bus value of AutomaticRedial (57).
{
	// opcodes: Error-Status
	byte param1; // AutomaticRedialState
	// DATATYPE_UINTXX
	param1 = getValue(P_FSG_40_0_0_57);
	putValue(P_FSG_40_0_0_57_1, param1);
}

on envVar P_FSG_40_0_0_57_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // AutomaticRedialState
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_57_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_57_1,thisval);
}

on envVar P_FSG_40_0_0_57_1 // AutomaticRedial.AutomaticRedialState
{
	byte superval;

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // AutomaticRedialState
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_40_0_0_57_1_0, 1);
	else
		putValue(P_FSG_40_0_0_57_1_0, 0);

    // Update superval
	superval = getValue(P_FSG_40_0_0_57);
	superval = thisval;
	putValue(P_FSG_40_0_0_57,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_58_ErrCode
{
       if(gP_FSG_40_0_0_58_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_58", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_58_ErrCode = 1;
}
on envVar P_FSG_40_0_0_58Status_BTN
{
	byte BAPTemp[144];
    if (P_FSG_40_0_0_58Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_40_0_0_58_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_58",MakeRGB(255,255,255));
        P_FSG_40_0_0_58Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_40_0_0_58_BuildFct();
        getValue(P_FSG_40_0_0_58, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_58_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_58));
        if(getValue(P_FSG_40_0_0_58_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_40_0_0_58_ID);
        }
        if(getValue(P_FSG_40_0_0_58_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_40_0_0_58_ID,elCount(BAPTemp));
        }
       P_FSG_40_0_0_58Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_58_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_58_ID;
    data[2]=getValue(P_FSG_40_0_0_58_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_58
on envVar P_FSG_40_0_0_58_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_58",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_58",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_58",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_58", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_58",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_58",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_58",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_58", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_58_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_58_SegmEn,0);
           intertelegram_err(P_FSG_40_0_0_58_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_40_0_0_58_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_58_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_58_IntTlgEn,0);
           sequence_err(P_FSG_40_0_0_58_ID,getValueSize(P_FSG_40_0_0_58_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_40_0_0_58_ID);
       }
}
on envVar P_FSG_40_0_0_58 // bus value of AutomaticRedialExtendedInfo (58).
{
	// opcodes: Error-Status
	word param1; // Redial_TimeStamp
	byte param2[100]; // PbName
	word len2;
	byte cnt2;
	byte param3[41]; // TelNumber
	word len3;
	byte cnt3;
	byte param4; // Category
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[144];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 144; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_58, superval);
	///////// Start param1 - UINT16 /////////
	param1 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_58_1, round((param1 * 1.0) - (0) + (0), 1.0));
	///////// Start param2 - STRING /////////
	getValue(P_FSG_40_0_0_58_2, param2);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(99>127) /* Max Fct-Katalog Laenge: 99*/
		{
			len2 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt2 = 1;
		}
		else
		{
			len2 = 99;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_58 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len2 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt2 = 0;
	}
	
	if(len2 > 99)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len2, currentPos);
		len2 = 99;
	
		if(len2 < 128) cnt2 = 0;
		else cnt2 = 1;
	}
	
	for(i = 0; i < len2; i++)
	{
		param2[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_58_2_len, len2);
	putValue(P_FSG_40_0_0_58_2_cnt, cnt2);
	
  if(len2 > getValueSize(P_FSG_40_0_0_58_2_Hex))
		putValue(P_FSG_40_0_0_58_2_Hex, param2, len2);
	else
		putValue(P_FSG_40_0_0_58_2_Hex, param2, getValueSize(P_FSG_40_0_0_58_2_Hex));
  
	/*if(len2 > getValueSize(P_FSG_40_0_0_58_2))
		putValue(P_FSG_40_0_0_58_2, param2, len2);
	else
		putValue(P_FSG_40_0_0_58_2, param2, getValueSize(P_FSG_40_0_0_58_2));*/

	///////// Start param3 - STRING /////////
	//getValue(P_FSG_40_0_0_58_3, param3);
  getValue(P_FSG_40_0_0_58_3_Hex, param3);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(40>127) /* Max Fct-Katalog Laenge: 40*/
		{
			len3 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt3 = 1;
		}
		else
		{
			len3 = 40;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in P_FSG_40_0_0_58 ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len3 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt3 = 0;
	}
	
	if(len3 > 40)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len3, currentPos);
		len3 = 40;
	
		if(len3 < 128) cnt3 = 0;
		else cnt3 = 1;
	}
	
	for(i = 0; i < len3; i++)
	{
		param3[i] = superval[currentPos++];
	}
	
	putValue(P_FSG_40_0_0_58_3_len, len3);
	putValue(P_FSG_40_0_0_58_3_cnt, cnt3);
	
  if(len3 > getValueSize(P_FSG_40_0_0_58_3_Hex))
		putValue(P_FSG_40_0_0_58_3_Hex, param3, len3);
	else
		putValue(P_FSG_40_0_0_58_3_Hex, param3, getValueSize(P_FSG_40_0_0_58_3_Hex));
  
	/*if(len3 > getValueSize(P_FSG_40_0_0_58_3))
		putValue(P_FSG_40_0_0_58_3, param3, len3);
	else
		putValue(P_FSG_40_0_0_58_3, param3, getValueSize(P_FSG_40_0_0_58_3));*/

	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_40_0_0_58_4, param4);
}

// Updates the bus value field and other dependencies.
P_FSG_40_0_0_58_BuildFct()
{
	word param1; // Redial_TimeStamp
	byte param2[100]; // PbName
	word len2;
	byte cnt2;
	byte param3[41]; // TelNumber
	word len3;
	byte cnt3;
	byte param4; // Category

	int i;
	byte superval[144];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	@P_FSG_40_0_0_58_1_range = round(@P_FSG_40_0_0_58_1 + (0), 1.0); // slider value + min = real value
	param1 = round( (@P_FSG_40_0_0_58_1 + (0) - (0)) / (1.0), 1.0); // (slider value + min - offset) / step = busvalue
	superval[currentPos++]=param1&0x00ff;
	superval[currentPos++]=(param1&0xff00)>>8;
// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_58_2, param2);
  getValue(P_FSG_40_0_0_58_2_Hex, param2);
	len2 = getValue(P_FSG_40_0_0_58_2_len);
	cnt2= getValue(P_FSG_40_0_0_58_2_cnt);
	
	/* check box aktiviert*/
	if (cnt2 == 1)
	{
		/* 0 bis 99 (MaxString - 1B oder 2B) */
		if(len2 >= 0 && len2 <= 99)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_58_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 99);
			return;
		}
	}
	else if(cnt2 == 0) /*check box deaktiviert*/
	{
		if(len2 >= 0 && len2 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len2: %d", len2);
			superval[currentPos]= len2 & 0x00ff;
			putValue(P_FSG_40_0_0_58_2_len, len2);
		}
		else if(len2 > 127 && len2 <= 99)
		{
			superval[currentPos] = (len2&0x7f00) | 0x80;
			superval[currentPos+1] = len2 & 0x00ff;
			putValue(P_FSG_40_0_0_58_2_len, len2);
			putValue(P_FSG_40_0_0_58_2_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_58_2 ist ungueltig. Die max. erlaubte Laenge ist %d.", len2, 99);
			return;
		}
	}
	currentPos += cnt2+1;
	for(i = 0; i < len2; i++)
	{
		superval[currentPos++]= param2[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(P_FSG_40_0_0_58_3, param3);
  getValue(P_FSG_40_0_0_58_3_Hex, param3);
	len3 = getValue(P_FSG_40_0_0_58_3_len);
	cnt3= getValue(P_FSG_40_0_0_58_3_cnt);
	
	/* check box aktiviert*/
	if (cnt3 == 1)
	{
		/* 0 bis 40 (MaxString - 1B oder 2B) */
		if(len3 >= 0 && len3 <= 40)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len3: %d", len3);
			superval[currentPos] = (len3&0x7f00) | 0x80;
			superval[currentPos+1] = len3 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_58_3 ist ungueltig. Die max. erlaubte Laenge ist %d.", len3, 40);
			return;
		}
	}
	else if(cnt3 == 0) /*check box deaktiviert*/
	{
		if(len3 >= 0 && len3 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len3: %d", len3);
			superval[currentPos]= len3 & 0x00ff;
			putValue(P_FSG_40_0_0_58_3_len, len3);
		}
		else if(len3 > 127 && len3 <= 40)
		{
			superval[currentPos] = (len3&0x7f00) | 0x80;
			superval[currentPos+1] = len3 & 0x00ff;
			putValue(P_FSG_40_0_0_58_3_len, len3);
			putValue(P_FSG_40_0_0_58_3_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_58_3 ist ungueltig. Die max. erlaubte Laenge ist %d.", len3, 40);
			return;
		}
	}
	currentPos += cnt3+1;
	for(i = 0; i < len3; i++)
	{
		superval[currentPos++]= param3[i];
	}

// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_40_0_0_58_4);
	superval[currentPos++]=param4;
	putValue(P_FSG_40_0_0_58, superval, currentPos);
}


// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_58_1_range // AutomaticRedialExtendedInfo.Redial_TimeStamp 
{
	@P_FSG_40_0_0_58_1 = @P_FSG_40_0_0_58_1_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_58_1 // AutomaticRedialExtendedInfo.Redial_TimeStamp
{
	P_FSG_40_0_0_58_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_58_2_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_58_2_len);
	cnt = getValue(P_FSG_40_0_0_58_2_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_58_2_len, 127);
		}
	}

	P_FSG_40_0_0_58_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_58_2_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 99)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_58_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 99);
		putValue(this, 99);
	}
	P_FSG_40_0_0_58_BuildFct();
}


on envVar P_FSG_40_0_0_58_2 // AutomaticRedialExtendedInfo.PbName
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_58_2_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_58_2_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_58_2_len, getValueSize(this));
	P_FSG_40_0_0_58_BuildFct();*/
}


// Ueberwachung der CheckBox fuer String
on envVar  P_FSG_40_0_0_58_3_cnt
{
	word len;
	byte cnt;
	len = getValue(P_FSG_40_0_0_58_3_len);
	cnt = getValue(P_FSG_40_0_0_58_3_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(P_FSG_40_0_0_58_3_len, 127);
		}
	}

	P_FSG_40_0_0_58_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar P_FSG_40_0_0_58_3_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 40)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von P_FSG_40_0_0_58_3 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 40);
		putValue(this, 40);
	}
	P_FSG_40_0_0_58_BuildFct();
}


on envVar P_FSG_40_0_0_58_3 // AutomaticRedialExtendedInfo.TelNumber
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(P_FSG_40_0_0_58_3_Hex,string_buffer_mod,string_length_mod);
  putValue(P_FSG_40_0_0_58_3_len, string_length_mod);
  
	/*putValue(P_FSG_40_0_0_58_3_len, getValueSize(this));
	P_FSG_40_0_0_58_BuildFct();*/
}

on envVar P_FSG_40_0_0_58_4 // AutomaticRedialExtendedInfo.Category
{
	P_FSG_40_0_0_58_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_59_ErrCode
{
       if(gP_FSG_40_0_0_59_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_59", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_59_ErrCode = 1;
}
on envVar P_FSG_40_0_0_59Status_BTN
{
	byte BAPTemp[3];
   if (P_FSG_40_0_0_59Status_BTN_already_pressed == 0)
   {
      putValue(P_FSG_40_0_0_59_ErrCode,0);
      SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_59",MakeRGB(255,255,255));
      P_FSG_40_0_0_59Status_BTN_already_pressed = 1;
   }
   else
   {
      getValue(P_FSG_40_0_0_59, BAPTemp);
      Request_ByteSequence(LSGID, P_FSG_40_0_0_59_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_59));
      P_FSG_40_0_0_59Status_BTN_already_pressed = 0;
   }
}
on envVar P_FSG_40_0_0_59_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_59_ID;
    data[2]=getValue(P_FSG_40_0_0_59_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_59
on envVar P_FSG_40_0_0_59_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_59",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_59",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_59",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_59", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_59",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_59",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_59",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_59", MakeRGB(250,0,0));
       }
}
on envVar P_FSG_40_0_0_59 // bus value of SupportedServiceNumbers (59).
{
	// opcodes: Error-Status
	byte param1; // ServiceNumbers
	byte param2; // Extension_1
	byte param3; // Extension_2
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[3];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 3; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_59, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_40_0_0_59_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_40_0_0_59_2, round((param2 * 1.0) - (0) + (0), 1.0));
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_40_0_0_59_3, round((param3 * 1.0) - (0) + (0), 1.0));
}

on envVar P_FSG_40_0_0_59_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ServiceNumbers
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_59_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_59_1,thisval);
}

on envVar P_FSG_40_0_0_59_1_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ServiceNumbers
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_59_1);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_59_1,thisval);
}

on envVar P_FSG_40_0_0_59_1_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ServiceNumbers
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_59_1);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_59_1,thisval);
}

on envVar P_FSG_40_0_0_59_1_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // ServiceNumbers
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_59_1);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_59_1,thisval);
}

on envVar P_FSG_40_0_0_59_1 // SupportedServiceNumbers.ServiceNumbers
{
	byte superval[3];

	//Update Childvalue (BitField)
	byte mask=0x01;
	int i = 0;
	byte thisval; // ServiceNumbers
	thisval = getValue(this);
	if(thisval&(mask<<0))
		putValue(P_FSG_40_0_0_59_1_0, 1);
	else
		putValue(P_FSG_40_0_0_59_1_0, 0);
	if(thisval&(mask<<1))
		putValue(P_FSG_40_0_0_59_1_1, 1);
	else
		putValue(P_FSG_40_0_0_59_1_1, 0);
	if(thisval&(mask<<2))
		putValue(P_FSG_40_0_0_59_1_2, 1);
	else
		putValue(P_FSG_40_0_0_59_1_2, 0);
	if(thisval&(mask<<3))
		putValue(P_FSG_40_0_0_59_1_3, 1);
	else
		putValue(P_FSG_40_0_0_59_1_3, 0);

    // Update superval
	getValue(P_FSG_40_0_0_59, superval);
	superval[0]=thisval;
	putValue(P_FSG_40_0_0_59,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_59_2_range // SupportedServiceNumbers.Extension_1 
{
	@P_FSG_40_0_0_59_2 = @P_FSG_40_0_0_59_2_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_59_2 // SupportedServiceNumbers.Extension_1
{
	byte superval[3];

	//Update Childvalue (Number)
	byte thisval; // Extension_1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_40_0_0_59_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_40_0_0_59, superval);
	superval[1]=thisval;
	putValue(P_FSG_40_0_0_59,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar P_FSG_40_0_0_59_3_range // SupportedServiceNumbers.Extension_2 
{
	@P_FSG_40_0_0_59_3 = @P_FSG_40_0_0_59_3_range - (0); // slider = range - min
}

on envVar P_FSG_40_0_0_59_3 // SupportedServiceNumbers.Extension_2
{
	byte superval[3];

	//Update Childvalue (Number)
	byte thisval; // Extension_2
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@P_FSG_40_0_0_59_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(P_FSG_40_0_0_59, superval);
	superval[2]=thisval;
	putValue(P_FSG_40_0_0_59,superval);
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar A_FSG_40_0_0_60_ErrCode
{
       if(gA_FSG_40_0_0_60_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_A_FSG_40_0_0_60", MakeRGB(255,255,255));
       }
       gA_FSG_40_0_0_60_ErrCode = 1;
}
on envVar A_FSG_40_0_0_60Changed_BTN
{
    byte data[583]; 
    byte stringValue[583];
    byte head[5];
    int i;
    int headLength;
    long tempValue;
    word currentPos;
    word startVal;
    word elementsVal;
  byte nibbleSetted;
    if (A_FSG_40_0_0_60Changed_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_60_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_60",MakeRGB(255,255,255));
        A_FSG_40_0_0_60Changed_BTN_already_pressed = 1;
    }
    else 
    {
        currentPos = 0;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_60_Changed);
        getValue(A_FSG_40_0_0_60_Changed,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_60_Changed_Start);
     elementsVal = getValue(A_FSG_40_0_0_60_Changed_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_60_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 60");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_60_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_60_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 60");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

       Request_ByteSequence(LSGID, A_FSG_40_0_0_60_ID, Changed_REQ, data, currentPos);
       if(getValue(A_FSG_40_0_0_60_IntTlgEn)) //getValue(IT))
       {
           intertelegram_err(A_FSG_40_0_0_60_ID);
       }
       if(getValue(A_FSG_40_0_0_60_SegmEn))   //getvalue(SG)
       {
             sequence_err(A_FSG_40_0_0_60_ID,getValueSize(A_FSG_40_0_0_60_Changed));
       }
        A_FSG_40_0_0_60Changed_BTN_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_60Status_BTN
{
    byte data[583 + 5]; // array header (3 or 5 bytes), followed by payload.
    byte stringValue[583];
    byte head[5];
    int i = 0;
    int j = 0;
    long StringLength = 0;
    int headLength;
    long tempValue;
    word currentPos;

    word startVal;
    word elementsVal;
    byte nibbleSetted;
    if (A_FSG_40_0_0_60Status_BTN_already_pressed == 0)
    {
        putValue(A_FSG_40_0_0_60_ErrCode,0);
        SetControlBackColor(panel_name,"errField_A_FSG_40_0_0_60",MakeRGB(255,255,255));
        A_FSG_40_0_0_60Status_BTN_already_pressed = 1;
    }
    else
    {
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_60_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_60_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_60_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_60);
        getValue(A_FSG_40_0_0_60,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_60_Start);
     elementsVal = getValue(A_FSG_40_0_0_60_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_60_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 60");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_60_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable Name:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 1 == getValue( A_FSG_40_0_0_60_RecAdr ) || 2 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_60_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_60_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 1 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_60_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 2 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_60_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_60_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param4[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_60_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_60_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 60");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_60_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable Name:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 1 == getValue( A_FSG_40_0_0_60_RecAdr ) || 2 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_60_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_60_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 1 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_60_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 2 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_60_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_60_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param4[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }

        //getValue(A_FSG_40_0_0_60, data);
        Request_ByteSequence(LSGID, A_FSG_40_0_0_60_ID, Data_REQ, data,currentPos);
        if(getValue(A_FSG_40_0_0_60_IntTlgEn)) //getValue(IT))
        {
            intertelegram_err(A_FSG_40_0_0_60_ID);
        }
        if(getValue(A_FSG_40_0_0_60_SegmEn))   //getvalue(SG)
        {
            sequence_err(A_FSG_40_0_0_60_ID,getValueSize(A_FSG_40_0_0_60));
        }
        A_FSG_40_0_0_60Status_BTN_already_pressed = 0;
    }
}
A_FSG_40_0_0_60_SendStatus()
{
    word currentPos;
    word headLength;
    int i;
    int j;
    word StringLength;
    long tempValue;
    word startVal;
    word elementsVal;
    byte data[583];
    byte stringValue[583];
    byte head[5];
    byte nibbleSetted;
    nibbleSetted = 0;
        currentPos = 0;
        //Einzelparameter: ASG_ID
        tempValue = getValue(A_FSG_40_0_0_60_1);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TAID
        tempValue = getValue(A_FSG_40_0_0_60_2);
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        data[currentPos] = (tempValue &0x0F) | (data[currentPos] &0xF0);
        currentPos++;
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        data[currentPos] = (tempValue<<4) &0xF0;
        nibbleSetted = 1;
    }
        //Einzelparameter: TotalNumListElements
        tempValue = getValue(A_FSG_40_0_0_60_3);
        //voriger Parameter war ein first nibble, bei 1 Byte Werten Position incr
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = tempValue;
        //head Parameter
        headLength = getValueSize(A_FSG_40_0_0_60);
        getValue(A_FSG_40_0_0_60,head);
        for(i=0; i< headLength; i++)
        {
            data[currentPos++] = head[i];
        }
    //data Parameter
     startVal = getValue(A_FSG_40_0_0_60_Start);
     elementsVal = getValue(A_FSG_40_0_0_60_Elements);
     nibbleSetted = 0;
    if( (head[0]&0x20) == 0)
    {
     if( (head[0] & 0x10) > 0)
     {
        startVal++;
     }
     for( i = startVal ; i < startVal + elementsVal ; i++)
     {
       if( i < 0 || i >= A_FSG_40_0_0_60_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 60");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_60_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable Name:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 1 == getValue( A_FSG_40_0_0_60_RecAdr ) || 2 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_60_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_60_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 1 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_60_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 2 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_60_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_60_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param4[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    else
    {
     if( (head[0] & 0x10) > 0)
     {
        if(startVal != 0) startVal--;
        else
        {
           startVal = A_FSG_40_0_0_60_ArrayDataList_Length -1;
        }
     }
     for( i = startVal ; i > startVal - elementsVal ; i--)
     {
       if( i < 0 || i >= A_FSG_40_0_0_60_ArrayDataList_Length )
       {
         write("Array index ausserhalb der Grenzen, Fct: 60");
         break;
       }
      if(nibbleSetted == 1) currentPos++;
      nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param1 & 0xFF;
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param1 & 0xFF;
           data[currentPos++] = (A_FSG_40_0_0_60_ArrayDataList[i].Param1 >> 8) & 0xFF;
        }
     }
      // Check if the current value of RecAdr enables the variable Name:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 1 == getValue( A_FSG_40_0_0_60_RecAdr ) || 2 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_60_Data_2_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 100-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 100-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_60_Data_2_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 100-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_2 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 100-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param2[j];
        }
       }
      // Check if the current value of RecAdr enables the variable NumberType:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 1 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        data[currentPos++] = (A_FSG_40_0_0_60_ArrayDataList[i].Param3 ) & 0xFF;
       }
      // Check if the current value of RecAdr enables the variable TelNumber:
      if( 0 || 0 == getValue( A_FSG_40_0_0_60_RecAdr ) || 2 == getValue( A_FSG_40_0_0_60_RecAdr ) )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        StringLength =A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length;
		/* Pruefung ob die Laenge-Checkbox aktiv ist */
		if (1 == A_FSG_40_0_0_60_Data_4_CntList[i] )
		{
			if(StringLength >= 0 && StringLength <= 32767 && StringLength <= 41-2)
			{
				data[currentPos++] = ( (StringLength >> 8) & 0x7F ) | 0x80; //2Byte Flag (Bit 8) setzen + HighByte (erste 7 bit)
				data[currentPos++] = StringLength &0xFF;
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d.", StringLength, i, 41-2);
				return;
			}
		}
		else if(0 == A_FSG_40_0_0_60_Data_4_CntList[i] ) /*check box deaktiviert*/
		{
			if(StringLength >= 0 && StringLength <= 127 && StringLength <= 41-1)
			{
				data[currentPos++] = StringLength & 0x7F; //Bit 8 = 0
			}
			else
			{
				writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_4 mit Record Nr. %d ist ungueltig. Die max. erlaubte Laenge ist %d. ", StringLength, i, 41-1);
				return;
			}
		}
        for(j=0; j < StringLength ; j++)
        {
            data[currentPos++] = A_FSG_40_0_0_60_ArrayDataList[i].Param4[j];
        }
       }
    //sollte der letzte Parameter ein first nibble gewesen sein, muss noch 1 increment durchgefuehrt werden
    if( nibbleSetted==1) currentPos++;
    nibbleSetted = 0;
     }
    }
    Request_byteSequence(LSGID, A_FSG_40_0_0_60_ID, Data_REQ, data, currentPos);
}
on envVar A_FSG_40_0_0_60
{
    byte temp[583];
    getValue(A_FSG_40_0_0_60, temp);
    putValue(A_FSG_40_0_0_60_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_60_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_60_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_60_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_60_Direction, 0); //Direction = Bit 5 von Byte 0
    if ( (0x40 & temp[0]) >0)
        putValue(A_FSG_40_0_0_60_TransPos, 1); //Transmission Pos = Bit 6 von Byte 0
    else
        putValue(A_FSG_40_0_0_60_TransPos, 0); //Transmission Pos = Bit 6 von Byte 0
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_60_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_60_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_60_IndexSize))
    {
        putValue(A_FSG_40_0_0_60_Start, ((temp[2]<<8)| temp[1]) ); // Array Start index, 2 Byte.
        putValue(A_FSG_40_0_0_60_Elements, ((temp[4]<<8)| temp[3]) ); // Array element count, 2 Byte.
    }
    else
    {
        putValue(A_FSG_40_0_0_60_Start, temp[1]); // Array Start index, 1 Byte.
        putValue(A_FSG_40_0_0_60_Elements, temp[2]); // Array element count, 1 Byte.
    }
}
A_FSG_40_0_0_60_GenerateStatus()
{
    byte head[5];
    int i = 0;
    int headLength;
    long tempValue;
    int currentPos;
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_60_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_60_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_60_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_60_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_60_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_60_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_60_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_60_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_60_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_60_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_60_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        headLength = 5;
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_60_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_60_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        headLength = 3;
    }

    currentPos = 0;

    putValue(A_FSG_40_0_0_60, head, headLength); 
}

on envVar A_FSG_40_0_0_60_RecAdr
{
    A_FSG_40_0_0_60_GenerateStatus();
}

on envVar A_FSG_40_0_0_60_Shift
{
    A_FSG_40_0_0_60_GenerateStatus();
}

on envVar A_FSG_40_0_0_60_Direction
{
    A_FSG_40_0_0_60_GenerateStatus();
}

on envVar A_FSG_40_0_0_60_Start
{
    A_FSG_40_0_0_60_GenerateStatus();
}

on envVar A_FSG_40_0_0_60_Elements
{
    A_FSG_40_0_0_60_GenerateStatus();
}

on envVar A_FSG_40_0_0_60_IndexSize
{
    A_FSG_40_0_0_60_GenerateStatus();
}
on envVar A_FSG_40_0_0_60_TransPos
{
    A_FSG_40_0_0_60_GenerateStatus();
}
A_FSG_40_0_0_60_Changed_GenerateChanged()
{
    byte head[5];
    //Record Address in Byte 0 Bit 0-3 kopieren - MAX Wert = 0x0F
    if(getValue(A_FSG_40_0_0_60_Changed_RecAdr) > 0x0F)
        putValue(A_FSG_40_0_0_60_Changed_RecAdr , 0x0F);
    head[0] = (head[0] & 0xF0) | getValue(A_FSG_40_0_0_60_Changed_RecAdr);
    //Shift Bit in Byte 0 Bit 4 kopieren
    if( getValue(A_FSG_40_0_0_60_Changed_Shift) > 0) head[0] = head[0] | 0x10;
    else head[0] = head[0] & 0xEF;
    // Direction Bit in Byte 0 Bit 5 kopieren
    if( getValue(A_FSG_40_0_0_60_Changed_Direction) > 0) head[0] = head[0] | 0x20;
    else head[0] = head[0] & 0xDF;
    // TransmissionPos Bit in Byte 0 Bit 6 kopieren
    if( getValue(A_FSG_40_0_0_60_Changed_TransPos) > 0) head[0] = head[0] | 0x40;
    else head[0] = head[0] & 0xBF;
    if( getValue(A_FSG_40_0_0_60_Changed_IndexSize) > 0)
    {
        // 5 Byte Header
        head[0] = head[0] | 0x80;
        head[1] =  getValue(A_FSG_40_0_0_60_Changed_Start) & 0xFF;
        head[2] = (getValue(A_FSG_40_0_0_60_Changed_Start) >> 8 ) & 0xFF;
        head[3] =  getValue(A_FSG_40_0_0_60_Changed_Elements) & 0xFF;
        head[4] = (getValue(A_FSG_40_0_0_60_Changed_Elements)  >> 8 ) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 5
        putValue(A_FSG_40_0_0_60_Changed, head, 5); 
    }
    else 
    {
        // 3 Byte Header
        head[0] = head[0] & 0x7F;
        head[1] = getValue(A_FSG_40_0_0_60_Changed_Start) & 0xFF;
        head[2] = getValue(A_FSG_40_0_0_60_Changed_Elements) & 0xFF;
        //ToDo: DATA - derzeit einfach laenge = 3
        putValue(A_FSG_40_0_0_60_Changed, head, 3); 
    }
}

on envVar A_FSG_40_0_0_60_Changed_RecAdr
{
    A_FSG_40_0_0_60_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_60_Changed_Shift
{
    A_FSG_40_0_0_60_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_60_Changed_Direction
{
    A_FSG_40_0_0_60_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_60_Changed_Start
{
    A_FSG_40_0_0_60_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_60_Changed_Elements
{
    A_FSG_40_0_0_60_Changed_GenerateChanged();
}

on envVar A_FSG_40_0_0_60_Changed_IndexSize
{
    A_FSG_40_0_0_60_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_60_Changed_TransPos
{
    A_FSG_40_0_0_60_Changed_GenerateChanged();
}
on envVar A_FSG_40_0_0_60_SetGet
{
    byte temp[583];
    getValue(A_FSG_40_0_0_60_SetGet, temp);
    putValue(A_FSG_40_0_0_60_SetGet_RecAdr, 0x0F & temp[0]); //Record Address = Bit 0-3 von Byte 0
    if ( (0x10 & temp[0]) >0)
        putValue(A_FSG_40_0_0_60_SetGet_Shift, 1); //Shift = Bit 4 von Byte 0
    else
        putValue(A_FSG_40_0_0_60_SetGet_Shift, 0); //Shift = Bit 4 von Byte 0
    if ( (0x20 & temp[0]) >0)
        putValue(A_FSG_40_0_0_60_SetGet_Direction, 1); //Direction = Bit 5 von Byte 0
    else
        putValue(A_FSG_40_0_0_60_SetGet_Direction, 0); //Direction = Bit 5 von Byte 0
    // Bit 6 von Byte 0 = reserved
    if ( (0x80 & temp[0]) >0)
        putValue(A_FSG_40_0_0_60_SetGet_IndexSize, 1); //IndexSize = Bit 7 von Byte 0
    else
        putValue(A_FSG_40_0_0_60_SetGet_IndexSize, 0); //IndexSize = Bit 7 von Byte 0
    if(getValue(A_FSG_40_0_0_60_SetGet_IndexSize))
    {
        putValue(A_FSG_40_0_0_60_SetGet_Start, ((temp[2]<<8)| temp[1]) ); //Start Wert, 2 Byte lang
        putValue(A_FSG_40_0_0_60_SetGet_Elements, ((temp[4]<<8)| temp[3]) ); //Elements Wert, 2 Byte lang
    }
    else
    {
        putValue(A_FSG_40_0_0_60_SetGet_Start, temp[1]); //Start Wert, 1 Byte lang
        putValue(A_FSG_40_0_0_60_SetGet_Elements, temp[2]); //Start Wert, 1 Byte lang
    }
}
A_FSG_40_0_0_60_LoadArray()
{
	/********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  char gListPath[255] = "";

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
	char temp3[25];

	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
	for(i = 0; i < A_FSG_40_0_0_60_ArrayDataList_Length; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		A_FSG_40_0_0_60_ArrayDataList[i].Param1 = 0;
		for(j=0; j<100; j++)
			A_FSG_40_0_0_60_ArrayDataList[i].Param2[j] = 0;
		A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length = 0;
		A_FSG_40_0_0_60_Data_2_LenList[i] = 0;
		A_FSG_40_0_0_60_ArrayDataList[i].Param3 = 0;
		for(j=0; j<41; j++)
			A_FSG_40_0_0_60_ArrayDataList[i].Param4[j] = 0;
		A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length = 0;
		A_FSG_40_0_0_60_Data_4_LenList[i] = 0;
	}

	/********* Laden der CSV-Datei ***********/
	getValue(A_FSG_40_0_0_60_fileSelector,gListPath);
  
  for(i = 0; i < strlen(gListPath); i++)
  {
    if (gListPath[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings auftelien
  substr_cpy(CSV_filepath, gListPath, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gListPath, (pos+1), -1, elcount(CSV_filename)); 
  
	setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "LastDestList"
		{
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if(buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{
					if(current_CSV_line > 0 && current_CSV_line < 61) //ignore first line in *.csv file
					{
						A_FSG_40_0_0_60_ArrayDataList[current_CSV_line-1].Param1 = atol(temp1); //Pos
						A_FSG_40_0_0_60_ArrayDataList[current_CSV_line-1].Param3 = atol(temp3); //NumberType
						for(i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
							temp3[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
					element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if(current_CSV_line > 0 && current_CSV_line < 61)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 2: //Name
								if(paramPos < 99)
								{
									A_FSG_40_0_0_60_ArrayDataList[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_60_ArrayDataList[current_CSV_line-1].Param2_Length = paramPos +1;
								}
								paramPos++;
						break;
						case 3: //NumberType
								if( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 4: //TelNumber
								if(paramPos < 40)
								{
									A_FSG_40_0_0_60_ArrayDataList[current_CSV_line-1].Param4[paramPos] = buffer_byte[filePos];
									A_FSG_40_0_0_60_ArrayDataList[current_CSV_line-1].Param4_Length = paramPos +1;
								}
								paramPos++;
						break;
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
				paramPos=0; //reset value
			}
		}

		if(fileClose (CSVfileHandle) !=0) //close *.csv file
			writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
}

on envVar A_FSG_40_0_0_60_loadArray_Btn
{
	char filePath[255];
	if (A_FSG_40_0_0_60_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_60_generateData_Btn_already_pressed = 1;
	}
	else
	{
		A_FSG_40_0_0_60_generateData_Btn_already_pressed = 0;
		getValue(A_FSG_40_0_0_60_fileSelector, filePath);
		if(0 == strlen(filePath))
		{
			writelineEx(gBAP_Trace, 0, "Invalid file path!");
		}
		else
		{
			A_FSG_40_0_0_60_LoadArray();
			writelineEx(gBAP_Trace, 0, "Load array from CSV file: %s", filePath);
		}
	}
	putValue(A_FSG_40_0_0_60_Data_1, A_FSG_40_0_0_60_ArrayDataList[ getValue( A_FSG_40_0_0_60_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_60_Data_2, A_FSG_40_0_0_60_ArrayDataList[ getValue( A_FSG_40_0_0_60_DataIndex) ].Param2, A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_60_Data_3, A_FSG_40_0_0_60_ArrayDataList[ getValue( A_FSG_40_0_0_60_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_60_Data_4, A_FSG_40_0_0_60_ArrayDataList[ getValue( A_FSG_40_0_0_60_DataIndex) ].Param4, A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param4_Length);
}


on envVar A_FSG_40_0_0_60_generateData_Btn
{
	word i;
	dword elementsArray[6] = {2, 100, 2, 1, 41, 2};
	byte elementsTypeArray[6] = {0, 0xE, 0xF, 0, 0xE, 0xF};
	dword elementsMaxSizeArray[6] = {65535, 0, 0, 0xFF, 0, 0};
	byte tempArray[8880];
	if (A_FSG_40_0_0_60_generateData_Btn_already_pressed == 0)
	{
		A_FSG_40_0_0_60_generateData_Btn_already_pressed = 1;
	}
	else
	{
		initStruct(tempArray, elementsArray, elementsTypeArray, elementsMaxSizeArray, 60, 60 );
		for(i = 0; i < 60; i++)
		{
			memcpy(A_FSG_40_0_0_60_ArrayDataList[i], tempArray, (i * 148) );
			if(A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length > 127 )
				A_FSG_40_0_0_60_Data_2_CntList[i] = 1;
			if(A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length > 127 )
				A_FSG_40_0_0_60_Data_4_CntList[i] = 1;
		}
		A_FSG_40_0_0_60_generateData_Btn_already_pressed = 0;
	}
	putValue(A_FSG_40_0_0_60_Data_1, A_FSG_40_0_0_60_ArrayDataList[ getValue( A_FSG_40_0_0_60_DataIndex) ].Param1);
	putValue(A_FSG_40_0_0_60_Data_2, A_FSG_40_0_0_60_ArrayDataList[ getValue( A_FSG_40_0_0_60_DataIndex) ].Param2, A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param2_Length);
	putValue(A_FSG_40_0_0_60_Data_3, A_FSG_40_0_0_60_ArrayDataList[ getValue( A_FSG_40_0_0_60_DataIndex) ].Param3);
	putValue(A_FSG_40_0_0_60_Data_4, A_FSG_40_0_0_60_ArrayDataList[ getValue( A_FSG_40_0_0_60_DataIndex) ].Param4, A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param4_Length);
}
// HME generateCaplOnEnv (3131)
on envVar A_FSG_40_0_0_60_DataIndex
{
    long index;
    long maxIndex = 60-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_60_Data_1, A_FSG_40_0_0_60_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_60_Data_2_len, A_FSG_40_0_0_60_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_60_Data_2_cnt, A_FSG_40_0_0_60_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_60_Data_2, A_FSG_40_0_0_60_ArrayDataList[index].Param2, A_FSG_40_0_0_60_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_60_Data_3, A_FSG_40_0_0_60_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_60_Data_4_len, A_FSG_40_0_0_60_Data_4_LenList[index]);
    putValue(A_FSG_40_0_0_60_Data_4_cnt, A_FSG_40_0_0_60_Data_4_CntList[index]);
    putValue(A_FSG_40_0_0_60_Data_4, A_FSG_40_0_0_60_ArrayDataList[index].Param4, A_FSG_40_0_0_60_ArrayDataList[index].Param4_Length);

}
on envVar A_FSG_40_0_0_60_DataIndex_Incr
{
    long index;
    if(A_FSG_40_0_0_60_DataIndex_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_60_DataIndex_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_60_DataIndex);
        index++;
        putValue(A_FSG_40_0_0_60_DataIndex, index);
        A_FSG_40_0_0_60_DataIndex_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_60_DataIndex_Decr
{
    long index;
    if(A_FSG_40_0_0_60_DataIndex_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_60_DataIndex_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_60_DataIndex);
        index--;
        putValue(A_FSG_40_0_0_60_DataIndex, index);
        A_FSG_40_0_0_60_DataIndex_Decr_already_pressed = 0;
    }
}
// HME generateCaplOnEnv (3160)
on envVar A_FSG_40_0_0_60_DataIndex_SetGet
{
    long index;
    long maxIndex = 60-1;
    index = getValue(this);
    if(index >= maxIndex) index = maxIndex;
    else if(index < 0) index = 0;
    putValue(this, index);
    putValue(A_FSG_40_0_0_60_Data_1_SetGet, A_FSG_40_0_0_60_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_60_Data_2_SetGet_len, A_FSG_40_0_0_60_Data_2_SetGet_LenList[index]);
    putValue(A_FSG_40_0_0_60_Data_2_SetGet_cnt, A_FSG_40_0_0_60_Data_2_SetGet_CntList[index]);
    putValue(A_FSG_40_0_0_60_Data_2_SetGet, A_FSG_40_0_0_60_ArrayDataList[index].Param2, A_FSG_40_0_0_60_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_60_Data_3_SetGet, A_FSG_40_0_0_60_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_60_Data_4_SetGet_len, A_FSG_40_0_0_60_Data_4_SetGet_LenList[index]);
    putValue(A_FSG_40_0_0_60_Data_4_SetGet_cnt, A_FSG_40_0_0_60_Data_4_SetGet_CntList[index]);
    putValue(A_FSG_40_0_0_60_Data_4_SetGet, A_FSG_40_0_0_60_ArrayDataList[index].Param4, A_FSG_40_0_0_60_ArrayDataList[index].Param4_Length);

}
on envVar A_FSG_40_0_0_60_DataIndex_SetGet_Incr
{
    long index;
    if(A_FSG_40_0_0_60_DataIndex_SetGet_Incr_already_pressed == 0)
    {
        A_FSG_40_0_0_60_DataIndex_SetGet_Incr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_60_DataIndex_SetGet);
        index++;
        putValue(A_FSG_40_0_0_60_DataIndex_SetGet, index);
        A_FSG_40_0_0_60_DataIndex_SetGet_Incr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_60_DataIndex_SetGet_Decr
{
    long index;
    if(A_FSG_40_0_0_60_DataIndex_SetGet_Decr_already_pressed == 0)
    {
        A_FSG_40_0_0_60_DataIndex_SetGet_Decr_already_pressed = 1;
    }
    else
    {
        index = getValue(A_FSG_40_0_0_60_DataIndex_SetGet);
        index--;
        putValue(A_FSG_40_0_0_60_DataIndex_SetGet, index);
        A_FSG_40_0_0_60_DataIndex_SetGet_Decr_already_pressed = 0;
    }
}
on envVar A_FSG_40_0_0_60_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=A_FSG_40_0_0_60_ID;
    data[2]=getValue(A_FSG_40_0_0_60_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID A_FSG_40_0_0_60
on envVar A_FSG_40_0_0_60_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_60",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Status",1);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_60",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_60",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Changed",1);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_60_SetGet",1);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_60", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_60",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Status",0);
           EnableControl(panel_name,"errfield_A_FSG_40_0_0_60",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_60",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Changed",0);
           EnableControl(panel_name,"panel_A_FSG_40_0_0_60_SetGet",0);
           setControlForeColor(panel_name, "checkbox_A_FSG_40_0_0_60", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_60_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_60_SegmEn,0);
           intertelegram_err(A_FSG_40_0_0_60_ID);
       }
       else
       {
           intertelegram_err_off(A_FSG_40_0_0_60_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar A_FSG_40_0_0_60_SegmEn
{
       if(getValue(this)) 
       {
           putValue(A_FSG_40_0_0_60_IntTlgEn,0);
           sequence_err(A_FSG_40_0_0_60_ID,getValueSize(A_FSG_40_0_0_60_SegmEn));
       }
       else
       {
              sequence_err_off(A_FSG_40_0_0_60_ID);
       }
}

// [XL] Ueberwachung der CheckBox fuer AT
on envVar A_FSG_40_0_0_60_AT
{
	if(getValue(this))
	{
		EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Status",0);
	}
	else
	{
   	EnableControl(panel_name,"panel_A_FSG_40_0_0_60_Status",1);
 	}
}



A_FSG_40_0_0_60_SetInd () { /* leere Function*/ }

A_FSG_40_0_0_60_SetGetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[583];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_60_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_60_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_60_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_60_AT))
                {
                    putValue(A_FSG_40_0_0_60,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_60_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_60_AT))
            {
                putValue(A_FSG_40_0_0_60,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_60_AT))
        {
            putValue(A_FSG_40_0_0_60_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_60_Start, startVal);
            putValue(A_FSG_40_0_0_60_Elements, elementsVal);
            putValue(A_FSG_40_0_0_60_TransPos, transmitPosVal);
        }
    }
    //data Parameter
     nibbleSetted = 0;
    if( (head[0] & 0x20) == 0) { // array header: increasing indices (Direction = 0).
      if( (head[0] & 0x10) > 0) { // array header: first element is one after specified start element (Shift = 1, Direction = 0).
        startVal++;
      }
      for ( i = startVal ; i < startVal + elementsVal ; i++) {
        if ( i < 0 || i >= A_FSG_40_0_0_60_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 60");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_40_0_0_60_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_40_0_0_60_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_60_Data_2_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_60_Data_2_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length; j++)
        {
            A_FSG_40_0_0_60_ArrayDataList[i].Param2[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_60_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_60_Data_4_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_60_Data_4_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length; j++)
        {
            A_FSG_40_0_0_60_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    } else { // array header: decreasing indices (Direction = 1).
      if( (head[0] & 0x10) > 0) { // array header: first element is one before specified start element (Shift = 1, Direction = 1).
        if(startVal != 0) {          startVal--;
        } else {
          startVal = A_FSG_40_0_0_60_ArrayDataList_Length -1;
        }
      }
      for ( i = startVal ; i > startVal - elementsVal ; i--) {
        if ( i < 0 || i >= A_FSG_40_0_0_60_ArrayDataList_Length ) {
          write("Array index ausserhalb der Grenzen, Fct: 60");
          break;
        }
        if(nibbleSetted == 1) currentPos++;
        nibbleSetted = 0;
     if( (head[0]&0x40) == 0){ /* Transmit_Pos = 0, keine Positionsdaten */ }
     else
     {
        if( (head[0]&0x80) == 0)
        {
           //IndexSize = 0, Pos als 1 Byte Wert
           A_FSG_40_0_0_60_ArrayDataList[i].Param1 = gBAP_Indication_data[currentPos++];
        }
        else
        {
           //IndexSize = 1, Pos als 2 Byte Wert
           A_FSG_40_0_0_60_ArrayDataList[i].Param1 = ( gBAP_Indication_data[currentPos++] &0xFF) + ((gBAP_Indication_data[currentPos++] &0xFF)<<8);
        }
     }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_60_Data_2_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_60_Data_2_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_60_ArrayDataList[i].Param2_Length; j++)
        {
            A_FSG_40_0_0_60_ArrayDataList[i].Param2[j] = gBAP_Indication_data[currentPos++];
        }
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 1 == recordAddressVal )
      {
        //Sollte vor einem 1 Byte Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        A_FSG_40_0_0_60_ArrayDataList[i].Param3 = (gBAP_Indication_data[currentPos++] & 0xFF);
      }
      // 0 - es kann vorkommen, dass das if leer ist dies wuerde zum Fehler fuehren. => automatische generierung der 0
      if( 0 || 0 == recordAddressVal || 2 == recordAddressVal )
      {
        //Sollte vor einem String Wert 1 Nibble kommen, muss der index um 1 incrementiert werden!
        if( nibbleSetted==1) currentPos++;
        nibbleSetted = 0;
        if((gBAP_Indication_data[currentPos] & 0x80) >= 1)
        {
        	 A_FSG_40_0_0_60_Data_4_SetGet_CntList[i] = 1;
            A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length = ( (gBAP_Indication_data[currentPos++] & 0x7F) << 8) + (gBAP_Indication_data[currentPos++] & 0xFF);
        }
        else
        {
        	 A_FSG_40_0_0_60_Data_4_SetGet_CntList[i] = 0;
            A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length = gBAP_Indication_data[currentPos++] & 0x7F;
        }
        for(j = 0; j < A_FSG_40_0_0_60_ArrayDataList[i].Param4_Length; j++)
        {
            A_FSG_40_0_0_60_ArrayDataList[i].Param4[j] = gBAP_Indication_data[currentPos++];
        }
      }
      } // for
    }
    nibbleSetted = 0;
index = getValue(A_FSG_40_0_0_60_DataIndex);
    putValue(A_FSG_40_0_0_60_Data_1, A_FSG_40_0_0_60_ArrayDataList[index].Param1);
    putValue(A_FSG_40_0_0_60_Data_2_len, A_FSG_40_0_0_60_Data_2_LenList[index]);
    putValue(A_FSG_40_0_0_60_Data_2_cnt, A_FSG_40_0_0_60_Data_2_CntList[index]);
    putValue(A_FSG_40_0_0_60_Data_2, A_FSG_40_0_0_60_ArrayDataList[index].Param2, A_FSG_40_0_0_60_ArrayDataList[index].Param2_Length);
    putValue(A_FSG_40_0_0_60_Data_3, A_FSG_40_0_0_60_ArrayDataList[index].Param3);
    putValue(A_FSG_40_0_0_60_Data_4_len, A_FSG_40_0_0_60_Data_4_LenList[index]);
    putValue(A_FSG_40_0_0_60_Data_4_cnt, A_FSG_40_0_0_60_Data_4_CntList[index]);
    putValue(A_FSG_40_0_0_60_Data_4, A_FSG_40_0_0_60_ArrayDataList[index].Param4, A_FSG_40_0_0_60_ArrayDataList[index].Param4_Length);
}

A_FSG_40_0_0_60_GetInd()
{
    int currentPos;
    byte head[5];
    byte stringTempValue[583];
    int i;
    int j;
    int startVal;
    int elementsVal;
    byte recordAddressVal;
    byte transmitPosVal;
    long tempValue;
    long index;
    byte nibbleSetted;
    currentPos = 0;
    nibbleSetted = 0;
    //Einzelparameter: ASG_ID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_60_1_SetGet, tempValue);
    //Einzelparameter: TAID
    if(nibbleSetted == 1)
    {
        //voriger Parameter war ein Nibble, => second nibble, Pos incr und Flag zuruecksetzen
        tempValue = (gBAP_Indication_data[currentPos++] &0xF);
        nibbleSetted = 0;
    }
    else
    {
        //first nibble, kein increment, Flag setzen
        tempValue = ((gBAP_Indication_data[currentPos]>>4) &0xF);
        nibbleSetted = 1;
    }
    putValue(A_FSG_40_0_0_60_2_SetGet, tempValue);
    //head Parameter
    if(gBAP_Indication_header[4] >= (3+currentPos))
    {
        if( (gBAP_Indication_data[currentPos] & 0x80) > 0)
            if(gBAP_Indication_header[4] >= (5+currentPos))
            {
                for(i = 0; i < 5; i++) head[i] = gBAP_Indication_data[currentPos++];
                putValue(A_FSG_40_0_0_60_SetGet, head, 5);
                if(getValue(A_FSG_40_0_0_60_AT))
                {
                    putValue(A_FSG_40_0_0_60,head,5);
                }
                startVal = (head[2]<<8) | head[1];
                elementsVal = (head[4]<<8) | head[3];
            }
            else write("received Data Error");
        else
        {
            for(i = 0; i < 3; i++) head[i] = gBAP_Indication_data[currentPos++];
            putValue(A_FSG_40_0_0_60_SetGet, head, 3);
            if(getValue(A_FSG_40_0_0_60_AT))
            {
                putValue(A_FSG_40_0_0_60,head,3);
            }
                startVal = head[1];
                elementsVal = head[2];
        }
        recordAddressVal = head[0] & 0x0F;
        transmitPosVal = head[0] & 0x40;
        if(getValue(A_FSG_40_0_0_60_AT))
        {
            putValue(A_FSG_40_0_0_60_RecAdr,recordAddressVal);
            putValue(A_FSG_40_0_0_60_Start, startVal);
            putValue(A_FSG_40_0_0_60_Elements, elementsVal);
            putValue(A_FSG_40_0_0_60_TransPos, transmitPosVal);
        }
    }
}

on envVar A_FSG_40_0_0_60_1
{
	byte superval[583];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_60_2_range // FavoriteList.TAID 
{
	@A_FSG_40_0_0_60_2 = @A_FSG_40_0_0_60_2_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_60_2
{
	byte superval[583];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_60_2, 1.0);
	@A_FSG_40_0_0_60_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_60_3_range // FavoriteList.TotalNumListElements 
{
	@A_FSG_40_0_0_60_3 = @A_FSG_40_0_0_60_3_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_60_3
{
	byte superval[583];

	//Update Childvalue (Number)
	byte thisval; // TotalNumListElements
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_60_3, 1.0);
	@A_FSG_40_0_0_60_3_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_60_Data_1_range // FavoriteList.Pos 
{
	@A_FSG_40_0_0_60_Data_1 = @A_FSG_40_0_0_60_Data_1_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_60_Data_1
{
	byte superval[583];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_60_Data_1, 1.0);
	@A_FSG_40_0_0_60_Data_1_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_60_Data_2_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_60_Data_2_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_60_Data_2_CntList[ getValue(A_FSG_40_0_0_60_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_60_Data_2_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_60_Data_2_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_60_Data_2_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_2 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_60_Data_2_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param2_Length = thisval;
	A_FSG_40_0_0_60_Data_2_LenList[ getValue(A_FSG_40_0_0_60_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_60_Data_2_len, thisval);

}

on envVar A_FSG_40_0_0_60_Data_2
{
	byte superval[583];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param2[i] = thisval[i];
    A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_60_Data_2_LenList[getValue(A_FSG_40_0_0_60_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_60_Data_2_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_60_Data_3
{
	byte superval[583];

	//Update Childvalue (Enum)
	byte thisval; // NumberType
	thisval = getValue(this);
    A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_60_Data_4_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_60_Data_4_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_60_Data_4_CntList[ getValue(A_FSG_40_0_0_60_DataIndex) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_60_Data_4_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_60_Data_4_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_60_Data_4_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 40 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_4 ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 40);
		thisval = 40;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_60_Data_4_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param4_Length = thisval;
	A_FSG_40_0_0_60_Data_4_LenList[ getValue(A_FSG_40_0_0_60_DataIndex) ] = thisval;
	putValue(A_FSG_40_0_0_60_Data_4_len, thisval);

}

on envVar A_FSG_40_0_0_60_Data_4
{
	byte superval[583];

	//Update Childvalue (String)
	word i;
	byte thisval[41];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param4[i] = thisval[i];
    A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex)].Param4_Length = getValueSize(this);
    A_FSG_40_0_0_60_Data_4_LenList[getValue(A_FSG_40_0_0_60_DataIndex)]= getValueSize(this);
    putValue(A_FSG_40_0_0_60_Data_4_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_60_1_SetGet
{
	byte superval[152];

	//Update Childvalue (Enum)
	byte thisval; // ASG_ID
	thisval = 0x0f & getValue(this);
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_60_2_SetGet_range // FavoriteList.TAID 
{
	@A_FSG_40_0_0_60_2_SetGet = @A_FSG_40_0_0_60_2_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_60_2_SetGet
{
	byte superval[152];

	//Update Childvalue (Number)
	byte thisval; // TAID
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_60_2_SetGet, 1.0);
	@A_FSG_40_0_0_60_2_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
}
// Ueberwachung der Darstellungsvariable der Range.
on envVar A_FSG_40_0_0_60_Data_1_SetGet_range // FavoriteList.Pos 
{
	@A_FSG_40_0_0_60_Data_1_SetGet = @A_FSG_40_0_0_60_Data_1_SetGet_range - (0); // slider = range - min
}

on envVar A_FSG_40_0_0_60_Data_1_SetGet
{
	byte superval[152];

	//Update Childvalue (Number)
	word thisval; // Pos
	float slider_value;

	slider_value = round(@A_FSG_40_0_0_60_Data_1_SetGet, 1.0);
	@A_FSG_40_0_0_60_Data_1_SetGet_range = slider_value + (0); // real value := slider value + range min.
	thisval = (word)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.
    A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex_SetGet)].Param1 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_60_Data_2_SetGet_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_60_Data_2_SetGet_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_60_Data_2_SetGet_CntList[ getValue(A_FSG_40_0_0_60_DataIndex_SetGet) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_60_Data_2_SetGet_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_60_Data_2_SetGet_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_60_Data_2_SetGet_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 99 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_2_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 99);
		thisval = 99;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_60_Data_2_SetGet_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex_SetGet)].Param2_Length = thisval;
	A_FSG_40_0_0_60_Data_2_SetGet_LenList[ getValue(A_FSG_40_0_0_60_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_40_0_0_60_Data_2_SetGet_len, thisval);

}

on envVar A_FSG_40_0_0_60_Data_2_SetGet
{
	byte superval[152];

	//Update Childvalue (String)
	word i;
	byte thisval[100];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex_SetGet)].Param2[i] = thisval[i];
    A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex_SetGet)].Param2_Length = getValueSize(this);
    A_FSG_40_0_0_60_Data_2_SetGet_LenList[getValue(A_FSG_40_0_0_60_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_40_0_0_60_Data_2_SetGet_len, getValueSize(this));
}
on envVar A_FSG_40_0_0_60_Data_3_SetGet
{
	byte superval[152];

	//Update Childvalue (Enum)
	byte thisval; // NumberType
	thisval = getValue(this);
    A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex_SetGet)].Param3 = thisval;
}

// Ueberwachung der CheckBox fuer String
on envVar  A_FSG_40_0_0_60_Data_4_SetGet_cnt
{
	word len;
	byte cnt;
	len = getValue(A_FSG_40_0_0_60_Data_4_SetGet_len);
	cnt = getValue(this);

    /* Cnt Wert im Array aktualisieren */
	 A_FSG_40_0_0_60_Data_4_SetGet_CntList[ getValue(A_FSG_40_0_0_60_DataIndex_SetGet) ] = cnt;

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if(cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(A_FSG_40_0_0_60_Data_4_SetGet_len, 127);
		}
	}

}


on envVar A_FSG_40_0_0_60_Data_4_SetGet_len
{
	long thisval;
	byte cnt;
	thisval = getValue(this);
	cnt = getValue(A_FSG_40_0_0_60_Data_4_SetGet_cnt);

	/* wenn die Laenge ausserhalb des erlaubten Bereich liegt, wird diese begrenzt */
	if(thisval > 40 || thisval < 0 )
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von A_FSG_40_0_0_60_Data_4_SetGet ist ungueltig. Die max. erlaubte Laenge ist %d. ", thisval, 40);
		thisval = 40;
	}
	if( thisval >127)
	{
		putValue(A_FSG_40_0_0_60_Data_4_SetGet_cnt, 1); /* Switch checkbox on */
	}

	A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex_SetGet)].Param4_Length = thisval;
	A_FSG_40_0_0_60_Data_4_SetGet_LenList[ getValue(A_FSG_40_0_0_60_DataIndex_SetGet) ] = thisval;
	putValue(A_FSG_40_0_0_60_Data_4_SetGet_len, thisval);

}

on envVar A_FSG_40_0_0_60_Data_4_SetGet
{
	byte superval[152];

	//Update Childvalue (String)
	word i;
	byte thisval[41];
	getValue(this, thisval);
    for(i = 0; i < getValueSize(this); i++)
        A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex_SetGet)].Param4[i] = thisval[i];
    A_FSG_40_0_0_60_ArrayDataList[getValue(A_FSG_40_0_0_60_DataIndex_SetGet)].Param4_Length = getValueSize(this);
    A_FSG_40_0_0_60_Data_4_SetGet_LenList[getValue(A_FSG_40_0_0_60_DataIndex_SetGet)]= getValueSize(this);
    putValue(A_FSG_40_0_0_60_Data_4_SetGet_len, getValueSize(this));
}
// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_61_ErrCode
{
       if(gP_FSG_40_0_0_61_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_61", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_61_ErrCode = 1;
}
on envVar P_FSG_40_0_0_61Status_BTN
{
	byte BAPTemp[10];
    if (P_FSG_40_0_0_61Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_40_0_0_61_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_61",MakeRGB(255,255,255));
        P_FSG_40_0_0_61Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_40_0_0_61_BuildFct();
        getValue(P_FSG_40_0_0_61, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_61_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_61));
        if(getValue(P_FSG_40_0_0_61_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_40_0_0_61_ID);
        }
        if(getValue(P_FSG_40_0_0_61_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_40_0_0_61_ID,elCount(BAPTemp));
        }
       P_FSG_40_0_0_61Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_61_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_61_ID;
    data[2]=getValue(P_FSG_40_0_0_61_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_61
on envVar P_FSG_40_0_0_61_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_61",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_61",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_61",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_61", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_61",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_61",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_61",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_61", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_61_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_61_SegmEn,0);
           intertelegram_err(P_FSG_40_0_0_61_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_40_0_0_61_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_61_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_61_IntTlgEn,0);
           sequence_err(P_FSG_40_0_0_61_ID,getValueSize(P_FSG_40_0_0_61_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_40_0_0_61_ID);
       }
}
on envVar P_FSG_40_0_0_61 // bus value of CallOptions_Extended (61).
{
	// opcodes: Error-Status
	byte param1; // CallOptions_Extended0
	byte param2; // CallOptions_Extended1
	byte param3; // CallOptions_Extended2
	byte param4; // CallOptions_Extended3
	byte param5; // CallOptions_Extended4
	byte param6; // CallOptions_Extended5
	byte param7; // CallOptions_Extended6
	byte param8; // CurrentAudioSink
	word param9; // AvailableAudioSinks
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[10];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 10; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_61, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(P_FSG_40_0_0_61_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_40_0_0_61_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_40_0_0_61_3, param3);
	///////// Start param4 - UINT8 /////////
	param4 = superval[currentPos++];
	putValue(P_FSG_40_0_0_61_4, param4);
	///////// Start param5 - UINT8 /////////
	param5 = superval[currentPos++];
	putValue(P_FSG_40_0_0_61_5, param5);
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(P_FSG_40_0_0_61_6, param6);
	///////// Start param7 - UINT8 /////////
	param7 = superval[currentPos++];
	putValue(P_FSG_40_0_0_61_7, param7);
	///////// Start param8 - UINT8 /////////
	param8 = superval[currentPos++];
	putValue(P_FSG_40_0_0_61_8, param8);
	///////// Start param9 - UINT16 /////////
	param9 = superval[currentPos++]|(superval[currentPos++]<<8);
	putValue(P_FSG_40_0_0_61_9, param9);
}

// Updates the bus value field and other dependencies.
P_FSG_40_0_0_61_BuildFct()
{
	byte param1; // CallOptions_Extended0
	byte param2; // CallOptions_Extended1
	byte param3; // CallOptions_Extended2
	byte param4; // CallOptions_Extended3
	byte param5; // CallOptions_Extended4
	byte param6; // CallOptions_Extended5
	byte param7; // CallOptions_Extended6
	byte param8; // CurrentAudioSink
	word param9; // AvailableAudioSinks

	int i;
	byte superval[10];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(P_FSG_40_0_0_61_1);
	@P_FSG_40_0_0_61_1_0 = (param1 & 1) > 0;
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_40_0_0_61_2);
	@P_FSG_40_0_0_61_2_0 = (param2 & 1) > 0;
	superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_40_0_0_61_3);
	@P_FSG_40_0_0_61_3_0 = (param3 & 1) > 0;
	superval[currentPos++]=param3;
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(P_FSG_40_0_0_61_4);
	@P_FSG_40_0_0_61_4_0 = (param4 & 1) > 0;
	superval[currentPos++]=param4;
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(P_FSG_40_0_0_61_5);
	@P_FSG_40_0_0_61_5_0 = (param5 & 1) > 0;
	superval[currentPos++]=param5;
// gen_BuildFunc_SetSuperVals 
	param6 = getValue(P_FSG_40_0_0_61_6);
	@P_FSG_40_0_0_61_6_0 = (param6 & 1) > 0;
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	param7 = getValue(P_FSG_40_0_0_61_7);
	@P_FSG_40_0_0_61_7_0 = (param7 & 1) > 0;
	superval[currentPos++]=param7;
// gen_BuildFunc_SetSuperVals 
	param8 = getValue(P_FSG_40_0_0_61_8);
	superval[currentPos++]=param8;
// gen_BuildFunc_SetSuperVals 
	param9 = getValue(P_FSG_40_0_0_61_9);
	@P_FSG_40_0_0_61_9_0 = (param9 & 1) > 0;
	@P_FSG_40_0_0_61_9_1 = (param9 & 2) > 0;
	@P_FSG_40_0_0_61_9_2 = (param9 & 4) > 0;
	@P_FSG_40_0_0_61_9_3 = (param9 & 8) > 0;
	@P_FSG_40_0_0_61_9_4 = (param9 & 16) > 0;
	@P_FSG_40_0_0_61_9_5 = (param9 & 32) > 0;
	@P_FSG_40_0_0_61_9_6 = (param9 & 64) > 0;
	@P_FSG_40_0_0_61_9_7 = (param9 & 128) > 0;
	@P_FSG_40_0_0_61_9_8 = (param9 & 256) > 0;
	superval[currentPos++]=param9&0x00ff;
	superval[currentPos++]=(param9&0xff00)>>8;
	putValue(P_FSG_40_0_0_61, superval, currentPos);
}


on envVar P_FSG_40_0_0_61_1_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions_Extended0
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_1);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_61_1,thisval);
}

on envVar P_FSG_40_0_0_61_1 // CallOptions_Extended.CallOptions_Extended0
{
	P_FSG_40_0_0_61_BuildFct();
}

on envVar P_FSG_40_0_0_61_2_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions_Extended1
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_61_2,thisval);
}

on envVar P_FSG_40_0_0_61_2 // CallOptions_Extended.CallOptions_Extended1
{
	P_FSG_40_0_0_61_BuildFct();
}

on envVar P_FSG_40_0_0_61_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions_Extended2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_3);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_61_3,thisval);
}

on envVar P_FSG_40_0_0_61_3 // CallOptions_Extended.CallOptions_Extended2
{
	P_FSG_40_0_0_61_BuildFct();
}

on envVar P_FSG_40_0_0_61_4_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions_Extended3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_4);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_61_4,thisval);
}

on envVar P_FSG_40_0_0_61_4 // CallOptions_Extended.CallOptions_Extended3
{
	P_FSG_40_0_0_61_BuildFct();
}

on envVar P_FSG_40_0_0_61_5_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions_Extended4
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_5);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_61_5,thisval);
}

on envVar P_FSG_40_0_0_61_5 // CallOptions_Extended.CallOptions_Extended4
{
	P_FSG_40_0_0_61_BuildFct();
}

on envVar P_FSG_40_0_0_61_6_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions_Extended5
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_6);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_61_6,thisval);
}

on envVar P_FSG_40_0_0_61_6 // CallOptions_Extended.CallOptions_Extended5
{
	P_FSG_40_0_0_61_BuildFct();
}

on envVar P_FSG_40_0_0_61_7_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // CallOptions_Extended6
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_7);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_61_7,thisval);
}

on envVar P_FSG_40_0_0_61_7 // CallOptions_Extended.CallOptions_Extended6
{
	P_FSG_40_0_0_61_BuildFct();
}

on envVar P_FSG_40_0_0_61_8 // CallOptions_Extended.CurrentAudioSink
{
	P_FSG_40_0_0_61_BuildFct();
}

on envVar P_FSG_40_0_0_61_9_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // AvailableAudioSinks
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_9);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_61_9,thisval);
}

on envVar P_FSG_40_0_0_61_9_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // AvailableAudioSinks
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_9);
	thisval = thisval&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_61_9,thisval);
}

on envVar P_FSG_40_0_0_61_9_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // AvailableAudioSinks
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_9);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_61_9,thisval);
}

on envVar P_FSG_40_0_0_61_9_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // AvailableAudioSinks
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_9);
	thisval = thisval&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_61_9,thisval);
}

on envVar P_FSG_40_0_0_61_9_4
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // AvailableAudioSinks
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_9);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_61_9,thisval);
}

on envVar P_FSG_40_0_0_61_9_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // AvailableAudioSinks
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_9);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_61_9,thisval);
}

on envVar P_FSG_40_0_0_61_9_6
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // AvailableAudioSinks
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_9);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_61_9,thisval);
}

on envVar P_FSG_40_0_0_61_9_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // AvailableAudioSinks
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_9);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_61_9,thisval);
}

on envVar P_FSG_40_0_0_61_9_8
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	word thisval; // AvailableAudioSinks
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_61_9);
	thisval = thisval&~(1<<8)|(bitval<<8);
	putValue(P_FSG_40_0_0_61_9,thisval);
}

on envVar P_FSG_40_0_0_61_9 // CallOptions_Extended.AvailableAudioSinks
{
	P_FSG_40_0_0_61_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar P_FSG_40_0_0_62_ErrCode
{
       if(gP_FSG_40_0_0_62_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_P_FSG_40_0_0_62", MakeRGB(255,255,255));
       }
       gP_FSG_40_0_0_62_ErrCode = 1;
}
on envVar P_FSG_40_0_0_62Status_BTN
{
	byte BAPTemp[8];
    if (P_FSG_40_0_0_62Status_BTN_already_pressed == 0)
    {
        putValue(P_FSG_40_0_0_62_ErrCode,0);
        SetControlBackColor(panel_name,"errField_P_FSG_40_0_0_62",MakeRGB(255,255,255));
        P_FSG_40_0_0_62Status_BTN_already_pressed = 1;
    }
    else
    {
		P_FSG_40_0_0_62_BuildFct();
        getValue(P_FSG_40_0_0_62, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_62_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_62));
        if(getValue(P_FSG_40_0_0_62_IntTlgEn)) //getValue(IT))
        {
           intertelegram_err(P_FSG_40_0_0_62_ID);
        }
        if(getValue(P_FSG_40_0_0_62_SegmEn))   //getvalue(SG)
        {
           sequence_err(P_FSG_40_0_0_62_ID,elCount(BAPTemp));
        }
       P_FSG_40_0_0_62Status_BTN_already_pressed = 0;
    }
}
on envVar P_FSG_40_0_0_62_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=P_FSG_40_0_0_62_ID;
    data[2]=getValue(P_FSG_40_0_0_62_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID P_FSG_40_0_0_62
on envVar P_FSG_40_0_0_62_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_62",1);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_62",1);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_62",1);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_62", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_62",0);
           EnableControl(panel_name,"errfield_P_FSG_40_0_0_62",0);
           EnableControl(panel_name,"panel_P_FSG_40_0_0_62",0);
           setControlForeColor(panel_name, "checkbox_P_FSG_40_0_0_62", MakeRGB(250,0,0));
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_62_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_62_SegmEn,0);
           intertelegram_err(P_FSG_40_0_0_62_ID);
       }
       else
       {
           intertelegram_err_off(P_FSG_40_0_0_62_ID);
       }
}
// Man darf gleichzeitig nur Checkbox fuer SegmError oder IntertelegramError aktiviert werden
on envVar P_FSG_40_0_0_62_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_62_IntTlgEn,0);
           sequence_err(P_FSG_40_0_0_62_ID,getValueSize(P_FSG_40_0_0_62_SegmEn));
       }
       else
       {
              sequence_err_off(P_FSG_40_0_0_62_ID);
       }
}
on envVar P_FSG_40_0_0_62 // bus value of FunctionSynchronisation (62).
{
	// opcodes: Error-Status
	byte param1[6]; // FctList_1
	byte param2; // FctList_2
	byte param3; // FctList_3
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[8];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 8; i++ ) {
		superval[i] = 0;
	}
	getValue(P_FSG_40_0_0_62, superval);
	///////// Start param1 - 6/8BSTRING /////////
	for( i = 0; i < 6; i++ )
	{
		param1[i] = superval[currentPos++];
	}
	putValue(P_FSG_40_0_0_62_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(P_FSG_40_0_0_62_2, param2);
	///////// Start param3 - UINT8 /////////
	param3 = superval[currentPos++];
	putValue(P_FSG_40_0_0_62_3, param3);
}

// Updates the bus value field and other dependencies.
P_FSG_40_0_0_62_BuildFct()
{
	byte param1[6]; // FctList_1
	byte param2; // FctList_2
	byte param3; // FctList_3

	int i;
	byte superval[8];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	getValue(P_FSG_40_0_0_62_1, param1);
	@P_FSG_40_0_0_62_1_16 = (param1[2] & 128) > 0;
	@P_FSG_40_0_0_62_1_17 = (param1[2] & 64) > 0;
	@P_FSG_40_0_0_62_1_18 = (param1[2] & 32) > 0;
	@P_FSG_40_0_0_62_1_19 = (param1[2] & 16) > 0;
	@P_FSG_40_0_0_62_1_20 = (param1[2] & 8) > 0;
	@P_FSG_40_0_0_62_1_21 = (param1[2] & 4) > 0;
	@P_FSG_40_0_0_62_1_22 = (param1[2] & 2) > 0;
	@P_FSG_40_0_0_62_1_23 = (param1[2] & 1) > 0;
	@P_FSG_40_0_0_62_1_24 = (param1[3] & 128) > 0;
	@P_FSG_40_0_0_62_1_25 = (param1[3] & 64) > 0;
	@P_FSG_40_0_0_62_1_33 = (param1[4] & 64) > 0;
	@P_FSG_40_0_0_62_1_34 = (param1[4] & 32) > 0;
	@P_FSG_40_0_0_62_1_42 = (param1[5] & 32) > 0;
	@P_FSG_40_0_0_62_1_43 = (param1[5] & 16) > 0;
	@P_FSG_40_0_0_62_1_44 = (param1[5] & 8) > 0;
	@P_FSG_40_0_0_62_1_45 = (param1[5] & 4) > 0;
	for( i = 0; i < 6; i++)
	{
	 superval[currentPos++] = param1[i];
	}
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(P_FSG_40_0_0_62_2);
	@P_FSG_40_0_0_62_2_3 = (param2 & 16) > 0;
	@P_FSG_40_0_0_62_2_7 = (param2 & 1) > 0;
	superval[currentPos++]=param2;
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(P_FSG_40_0_0_62_3);
	@P_FSG_40_0_0_62_3_0 = (param3 & 128) > 0;
	@P_FSG_40_0_0_62_3_1 = (param3 & 64) > 0;
	@P_FSG_40_0_0_62_3_2 = (param3 & 32) > 0;
	@P_FSG_40_0_0_62_3_3 = (param3 & 16) > 0;
	@P_FSG_40_0_0_62_3_5 = (param3 & 4) > 0;
	superval[currentPos++]=param3;
	putValue(P_FSG_40_0_0_62, superval, currentPos);
}

on envVar P_FSG_40_0_0_62_1_16
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[2] = thisval[2]&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_17
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[2] = thisval[2]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_18
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[2] = thisval[2]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_19
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[2] = thisval[2]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_20
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[2] = thisval[2]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_21
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[2] = thisval[2]&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_22
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[2] = thisval[2]&~(1<<1)|(bitval<<1);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_23
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[2] = thisval[2]&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_24
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[3] = thisval[3]&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_25
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[3] = thisval[3]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_33
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[4] = thisval[4]&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_34
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[4] = thisval[4]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_42
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[5] = thisval[5]&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_43
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[5] = thisval[5]&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_44
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[5] = thisval[5]&~(1<<3)|(bitval<<3);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1_45
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval[6]; // FctList_1
	bitval= getValue(this);
	getValue(P_FSG_40_0_0_62_1, thisval);
	thisval[5] = thisval[5]&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_62_1,thisval);
}

on envVar P_FSG_40_0_0_62_1 // FunctionSynchronisation.FctList_1
{
	P_FSG_40_0_0_62_BuildFct();
}

on envVar P_FSG_40_0_0_62_2_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_62_2);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_62_2,thisval);
}

on envVar P_FSG_40_0_0_62_2_7
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_2
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_62_2);
	thisval = thisval&~(1<<0)|(bitval<<0);
	putValue(P_FSG_40_0_0_62_2,thisval);
}

on envVar P_FSG_40_0_0_62_2 // FunctionSynchronisation.FctList_2
{
	P_FSG_40_0_0_62_BuildFct();
}

on envVar P_FSG_40_0_0_62_3_0
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_62_3);
	thisval = thisval&~(1<<7)|(bitval<<7);
	putValue(P_FSG_40_0_0_62_3,thisval);
}

on envVar P_FSG_40_0_0_62_3_1
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_62_3);
	thisval = thisval&~(1<<6)|(bitval<<6);
	putValue(P_FSG_40_0_0_62_3,thisval);
}

on envVar P_FSG_40_0_0_62_3_2
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_62_3);
	thisval = thisval&~(1<<5)|(bitval<<5);
	putValue(P_FSG_40_0_0_62_3,thisval);
}

on envVar P_FSG_40_0_0_62_3_3
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_62_3);
	thisval = thisval&~(1<<4)|(bitval<<4);
	putValue(P_FSG_40_0_0_62_3,thisval);
}

on envVar P_FSG_40_0_0_62_3_5
{
	byte bitval;
	//thisval steht hier fuer den bitfield-wert, 
	//aus Generierungsgruenden hier keine einheitliche Bezeichnung moeglich.
	byte thisval; // FctList_3
	bitval= getValue(this);
	thisval = getValue(P_FSG_40_0_0_62_3);
	thisval = thisval&~(1<<2)|(bitval<<2);
	putValue(P_FSG_40_0_0_62_3,thisval);
}

on envVar P_FSG_40_0_0_62_3 // FunctionSynchronisation.FctList_3
{
	P_FSG_40_0_0_62_BuildFct();
}

// Ruecksetzen des Fehlerstatus durch manuelle Fehlereingabe
on envVar M_FSG_40_0_0_63_ErrCode
{
       if(gM_FSG_40_0_0_63_ErrCode) 
       {
           setControlBackColor(panel_name,"errfield_M_FSG_40_0_0_63", MakeRGB(255,255,255));
       }
       gM_FSG_40_0_0_63_ErrCode = 1;
}
on envVar M_FSG_40_0_0_63Result_BTN
{
    byte temp[2];
    if (M_FSG_40_0_0_63Result_BTN_already_pressed == 0)
    {
        putValue(M_FSG_40_0_0_63_ErrCode,0);
        SetControlBackColor(panel_name,"errField_M_FSG_40_0_0_63",MakeRGB(255,255,255));
        M_FSG_40_0_0_63Result_BTN_already_pressed = 1;
    }
    else
    {
        putValue(M_FSG_40_0_0_63_State, "Result");
        getValue(M_FSG_40_0_0_63_Result, temp);
        Request_ByteSequence(LSGID, M_FSG_40_0_0_63_ID, Result_REQ, temp, getValueSize(M_FSG_40_0_0_63_Result));
        M_FSG_40_0_0_63Result_BTN_already_pressed = 0;
    }
}
on envVar M_FSG_40_0_0_63_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=M_FSG_40_0_0_63_ID;
    data[2]=getValue(M_FSG_40_0_0_63_FctEn);
    ChangeConfig(0x0031,data);
}
// De-Aktivierung der Eingabefelder der FCTID M_FSG_40_0_0_63
on envVar M_FSG_40_0_0_63_FctLstItemEn
{
       if(getValue(this)) 
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_63",1);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_63",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_63",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Processing",1);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Start",1);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_63", MakeRGB(0,240,0));
       }
       else
       {
           EnableControl(panel_name,"panel_FSG_40_0_0_63",0);
           EnableControl(panel_name,"errfield_M_FSG_40_0_0_63",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_63",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Processing",0);
           EnableControl(panel_name,"panel_M_FSG_40_0_0_63_Start",0);
           setControlForeColor(panel_name, "checkbox_M_FSG_40_0_0_63", MakeRGB(250,0,0));
       }
}
on envVar M_FSG_40_0_0_63_Result // bus value of CallFunctions (63).
{
	// opcodes: Error-Processing-Result
	byte param1; // CallFunction
	byte param2; // CallFunctions_Result
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[2];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_40_0_0_63_Result, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_40_0_0_63_Result_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(M_FSG_40_0_0_63_Result_2, param2);
}

on envVar M_FSG_40_0_0_63_Result_1 // CallFunctions.CallFunction
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // CallFunction
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_40_0_0_63_Result, superval);
	superval[0]=thisval;
	putValue(M_FSG_40_0_0_63_Result,superval);
}

on envVar M_FSG_40_0_0_63_Result_2 // CallFunctions.CallFunctions_Result
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // CallFunctions_Result
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_40_0_0_63_Result, superval);
	superval[1]=thisval;
	putValue(M_FSG_40_0_0_63_Result,superval);
}

on envVar M_FSG_40_0_0_63_Processing // bus value of CallFunctions (63).
{
	// opcodes: Error-Processing-Result
	byte param1; // CallFunction
	byte param2; // Reserve1
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[2];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 2; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_40_0_0_63_Processing, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_40_0_0_63_Processing_1, param1);
	///////// Start param2 - UINT8 /////////
	param2 = superval[currentPos++];
	putValue(M_FSG_40_0_0_63_Processing_2, round((param2 * 1.0) - (0) + (0), 1.0));
}

on envVar M_FSG_40_0_0_63_Processing_1 // CallFunctions.CallFunction
{
	byte superval[2];

	//Update Childvalue (Enum)
	byte thisval; // CallFunction
	thisval = getValue(this);

    // Update superval
	getValue(M_FSG_40_0_0_63_Processing, superval);
	superval[0]=thisval;
	putValue(M_FSG_40_0_0_63_Processing,superval);
}

// Ueberwachung der Darstellungsvariable der Range.
on envVar M_FSG_40_0_0_63_Processing_2_range // CallFunctions.Reserve1 
{
	@M_FSG_40_0_0_63_Processing_2 = @M_FSG_40_0_0_63_Processing_2_range - (0); // slider = range - min
}

on envVar M_FSG_40_0_0_63_Processing_2 // CallFunctions.Reserve1
{
	byte superval[2];

	//Update Childvalue (Number)
	byte thisval; // Reserve1
	float slider_value;

	slider_value = 0; // Konstanter Parameter.
	@M_FSG_40_0_0_63_Processing_2_range = slider_value + (0); // real value := slider value + range min.
	thisval = (byte)round((slider_value + (0) - (0)) / (1.0), 1); // bus value := (slider value + min - offset) / step.

    // Update superval
	getValue(M_FSG_40_0_0_63_Processing, superval);
	superval[1]=thisval;
	putValue(M_FSG_40_0_0_63_Processing,superval);
}

on envVar M_FSG_40_0_0_63_Start // bus value of CallFunctions (63).
{
	// opcodes: AbortResult-StartResult
	byte param1; // CallFunction
	byte param2; // CallID
	byte param3; // MessageID
	byte param4; // ServiceType
	byte param5; // Control
	byte param6; // SelectedAudioSink
	byte param7[41]; // TelNumber
	word len7;
	byte cnt7;
	byte param8[150]; // Name
	word len8;
	byte cnt8;
	// DATATYPE_BYTESEQUENCE / DATATYPE_FIXEDBYTESEQUENCE
	int i;
	byte superval[195];
	int currentPos;
	currentPos = 0;
	for( i = 0; i < 195; i++ ) {
		superval[i] = 0;
	}
	getValue(M_FSG_40_0_0_63_Start, superval);
	///////// Start param1 - UINT8 /////////
	param1 = superval[currentPos++];
	putValue(M_FSG_40_0_0_63_Start_1, param1);
	///////// Start param2 - NIBBLE /////////
	param2 = (superval[currentPos] & 0xf0)>>4;
	putValue(M_FSG_40_0_0_63_Start_2, param2);
	///////// Start param3 - NIBBLE /////////
	param3 = superval[currentPos++] & 0x0f;
	putValue(M_FSG_40_0_0_63_Start_3, param3);
	///////// Start param4 - NIBBLE /////////
	param4 = (superval[currentPos] & 0xf0)>>4;
	putValue(M_FSG_40_0_0_63_Start_4, param4);
	///////// Start param5 - NIBBLE /////////
	param5 = superval[currentPos++] & 0x0f;
	putValue(M_FSG_40_0_0_63_Start_5, param5);
	///////// Start param6 - UINT8 /////////
	param6 = superval[currentPos++];
	putValue(M_FSG_40_0_0_63_Start_6, param6);
	///////// Start param7 - STRING /////////
	getValue(M_FSG_40_0_0_63_Start_7, param7);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(40>127) /* Max Fct-Katalog Laenge: 40*/
		{
			len7 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt7 = 1;
		}
		else
		{
			len7 = 40;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_40_0_0_63_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len7 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt7 = 0;
	}
	
	if(len7 > 40)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len7, currentPos);
		len7 = 40;
	
		if(len7 < 128) cnt7 = 0;
		else cnt7 = 1;
	}
	
	for(i = 0; i < len7; i++)
	{
		param7[i] = superval[currentPos++];
	}
	
	putValue(M_FSG_40_0_0_63_Start_7_len, len7);
	putValue(M_FSG_40_0_0_63_Start_7_cnt, cnt7);
	
	if(len7 > getValueSize(M_FSG_40_0_0_63_Start_7))
		putValue(M_FSG_40_0_0_63_Start_7, param7, len7);
	else
		putValue(M_FSG_40_0_0_63_Start_7, param7, getValueSize(M_FSG_40_0_0_63_Start_7));

	///////// Start param8 - STRING /////////
	//getValue(M_FSG_40_0_0_63_Start_8, param8);
  getValue(M_FSG_40_0_0_63_Start_8_Hex, param8);
	if((superval[currentPos] & 0x80) > 0)
	{
		if(148>127) /* Max Fct-Katalog Laenge: 148*/
		{
			len8 = ( (superval[currentPos]&0x7F) <<8) + superval[currentPos+1];
			currentPos = currentPos + 2;
			cnt8 = 1;
		}
		else
		{
			len8 = 148;
			writelineEx(gBAP_Trace, 0, "Anzahl der Laengeninformation-Bytes in M_FSG_40_0_0_63_Start ueberschreitet die erlaubte 1 Byte vom Fct-Kalatog.");
		}
	}
	else
	{
		len8 = superval[currentPos]&0x7F;
		currentPos = currentPos + 1;
		cnt8 = 0;
	}
	
	if(len8 > 148)
	{
		writelineEx(gBAP_Trace, 0, "Laenge:%d bei der Byte Position:%d ueberschreitet die Maximale erlaubte Laenge von Fct-Kalatog", len8, currentPos);
		len8 = 148;
	
		if(len8 < 128) cnt8 = 0;
		else cnt8 = 1;
	}
	
	for(i = 0; i < len8; i++)
	{
		param8[i] = superval[currentPos++];
	}
	
	putValue(M_FSG_40_0_0_63_Start_8_len, len8);
	putValue(M_FSG_40_0_0_63_Start_8_cnt, cnt8);
	
  if(len8 > getValueSize(M_FSG_40_0_0_63_Start_8_Hex))
		putValue(M_FSG_40_0_0_63_Start_8_Hex, param8, len8);
	else
		putValue(M_FSG_40_0_0_63_Start_8_Hex, param8, getValueSize(M_FSG_40_0_0_63_Start_8_Hex));
  
	/*if(len8 > getValueSize(M_FSG_40_0_0_63_Start_8))
		putValue(M_FSG_40_0_0_63_Start_8, param8, len8);
	else
		putValue(M_FSG_40_0_0_63_Start_8, param8, getValueSize(M_FSG_40_0_0_63_Start_8));*/

}

// Updates the bus value field and other dependencies.
M_FSG_40_0_0_63_Start_BuildFct()
{
	byte param1; // CallFunction
	byte param2; // CallID
	byte param3; // MessageID
	byte param4; // ServiceType
	byte param5; // Control
	byte param6; // SelectedAudioSink
	byte param7[41]; // TelNumber
	word len7;
	byte cnt7;
	byte param8[150]; // Name
	word len8;
	byte cnt8;

	int i;
	byte superval[195];
	int currentPos;
	currentPos = 0;
// gen_BuildFunc_SetSuperVals 
	param1 = getValue(M_FSG_40_0_0_63_Start_1);
	superval[currentPos++]=param1;
// gen_BuildFunc_SetSuperVals 
	param2 = getValue(M_FSG_40_0_0_63_Start_2);
	param2 = param2 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param2<<4);
// gen_BuildFunc_SetSuperVals 
	param3 = getValue(M_FSG_40_0_0_63_Start_3);
	param3 = param3 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param3;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param4 = getValue(M_FSG_40_0_0_63_Start_4);
	param4 = param4 & 0x0f;
	superval[currentPos]= superval[currentPos]&0x0f;
	superval[currentPos]= superval[currentPos]|(param4<<4);
// gen_BuildFunc_SetSuperVals 
	param5 = getValue(M_FSG_40_0_0_63_Start_5);
	param5 = param5 & 0x0f;
	superval[currentPos]= superval[currentPos]&0xf0;
	superval[currentPos]= superval[currentPos]|param5;
	currentPos++;
// gen_BuildFunc_SetSuperVals 
	param6 = getValue(M_FSG_40_0_0_63_Start_6);
	superval[currentPos++]=param6;
// gen_BuildFunc_SetSuperVals 
	getValue(M_FSG_40_0_0_63_Start_7, param7);
	len7 = getValue(M_FSG_40_0_0_63_Start_7_len);
	cnt7= getValue(M_FSG_40_0_0_63_Start_7_cnt);
	
	/* check box aktiviert*/
	if (cnt7 == 1)
	{
		/* 0 bis 40 (MaxString - 1B oder 2B) */
		if(len7 >= 0 && len7 <= 40)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
			superval[currentPos] = (len7&0x7f00) | 0x80;
			superval[currentPos+1] = len7 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_63_Start_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 40);
			return;
		}
	}
	else if(cnt7 == 0) /*check box deaktiviert*/
	{
		if(len7 >= 0 && len7 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len7: %d", len7);
			superval[currentPos]= len7 & 0x00ff;
			putValue(M_FSG_40_0_0_63_Start_7_len, len7);
		}
		else if(len7 > 127 && len7 <= 40)
		{
			superval[currentPos] = (len7&0x7f00) | 0x80;
			superval[currentPos+1] = len7 & 0x00ff;
			putValue(M_FSG_40_0_0_63_Start_7_len, len7);
			putValue(M_FSG_40_0_0_63_Start_7_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_63_Start_7 ist ungueltig. Die max. erlaubte Laenge ist %d.", len7, 40);
			return;
		}
	}
	currentPos += cnt7+1;
	for(i = 0; i < len7; i++)
	{
		superval[currentPos++]= param7[i];
	}

// gen_BuildFunc_SetSuperVals 
	//getValue(M_FSG_40_0_0_63_Start_8, param8);
  getValue(M_FSG_40_0_0_63_Start_8_Hex, param8);
	len8 = getValue(M_FSG_40_0_0_63_Start_8_len);
	cnt8= getValue(M_FSG_40_0_0_63_Start_8_cnt);
	
	/* check box aktiviert*/
	if (cnt8 == 1)
	{
		/* 0 bis 148 (MaxString - 1B oder 2B) */
		if(len8 >= 0 && len8 <= 148)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
			superval[currentPos] = (len8&0x7f00) | 0x80;
			superval[currentPos+1] = len8 & 0x00ff;
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_63_Start_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 148);
			return;
		}
	}
	else if(cnt8 == 0) /*check box deaktiviert*/
	{
		if(len8 >= 0 && len8 <= 127)
		{
			//writelineEx(gBAP_Trace, 0, "[Debug-1] Len8: %d", len8);
			superval[currentPos]= len8 & 0x00ff;
			putValue(M_FSG_40_0_0_63_Start_8_len, len8);
		}
		else if(len8 > 127 && len8 <= 148)
		{
			superval[currentPos] = (len8&0x7f00) | 0x80;
			superval[currentPos+1] = len8 & 0x00ff;
			putValue(M_FSG_40_0_0_63_Start_8_len, len8);
			putValue(M_FSG_40_0_0_63_Start_8_cnt, 1);
		}
		else
		{
			writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_63_Start_8 ist ungueltig. Die max. erlaubte Laenge ist %d.", len8, 148);
			return;
		}
	}
	currentPos += cnt8+1;
	for(i = 0; i < len8; i++)
	{
		superval[currentPos++]= param8[i];
	}

	putValue(M_FSG_40_0_0_63_Start, superval, currentPos);
}


on envVar M_FSG_40_0_0_63_Start_1 // CallFunctions.CallFunction
{
	M_FSG_40_0_0_63_Start_BuildFct();
}

on envVar M_FSG_40_0_0_63_Start_2 // CallFunctions.CallID
{
	M_FSG_40_0_0_63_Start_BuildFct();
}

on envVar M_FSG_40_0_0_63_Start_3 // CallFunctions.MessageID
{
	M_FSG_40_0_0_63_Start_BuildFct();
}

on envVar M_FSG_40_0_0_63_Start_4 // CallFunctions.ServiceType
{
	M_FSG_40_0_0_63_Start_BuildFct();
}

on envVar M_FSG_40_0_0_63_Start_5 // CallFunctions.Control
{
	M_FSG_40_0_0_63_Start_BuildFct();
}

on envVar M_FSG_40_0_0_63_Start_6 // CallFunctions.SelectedAudioSink
{
	M_FSG_40_0_0_63_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_40_0_0_63_Start_7_cnt
{
	word len;
	byte cnt;
	len = getValue(M_FSG_40_0_0_63_Start_7_len);
	cnt = getValue(M_FSG_40_0_0_63_Start_7_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_FSG_40_0_0_63_Start_7_len, 127);
		}
	}

	M_FSG_40_0_0_63_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_40_0_0_63_Start_7_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 40)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_63_Start_7 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 40);
		putValue(this, 40);
	}
	M_FSG_40_0_0_63_Start_BuildFct();
}


on envVar M_FSG_40_0_0_63_Start_7 // CallFunctions.TelNumber
{
	putValue(M_FSG_40_0_0_63_Start_7_len, getValueSize(this));
	M_FSG_40_0_0_63_Start_BuildFct();
}


// Ueberwachung der CheckBox fuer String
on envVar  M_FSG_40_0_0_63_Start_8_cnt
{
	word len;
	byte cnt;
	len = getValue(M_FSG_40_0_0_63_Start_8_len);
	cnt = getValue(M_FSG_40_0_0_63_Start_8_cnt);

	/* wird nur gerufen, wenn check box deaktiviert mit Length>127*/ 
	if( cnt == 0) 
	{
		if(len > 127 )
		{
			putValue(M_FSG_40_0_0_63_Start_8_len, 127);
		}
	}

	M_FSG_40_0_0_63_Start_BuildFct();
}



// Ueberwachung der Eingabefeld fuer String Data
on envVar M_FSG_40_0_0_63_Start_8_len
{
	word len;
	len = getValue(this);
	/* Validierung der Eingabe*/
	if(len > 148)
	{
		writelineEx(gBAP_Trace, 0, "Eingegebene Laenge: %d von M_FSG_40_0_0_63_Start_8 ist ungueltig. Die max. erlaubte Laenge ist %d. ", len, 148);
		putValue(this, 148);
	}
	M_FSG_40_0_0_63_Start_BuildFct();
}


on envVar M_FSG_40_0_0_63_Start_8 // CallFunctions.Name
{
  int j, offset;
  int temp;
  int string_length_org;
  int string_length_mod;
  byte string_buffer_org[255];
  byte string_buffer_mod[255];
  
  //Start-Länge
  string_length_org = getValueSize(this);
  string_length_mod = string_length_org;
  
  //Start-String in Buffer
  getvalue(this,string_buffer_org);
  
  //Buffer auf Sonderzeichen checken und ersetzen
  offset = 0;
  for (j=0;j<string_length_org;j++)
  {
    if ( string_buffer_org[j] >= 0x80 && string_buffer_org[j] <= 0xBF ) 
    {
      temp = string_buffer_org[j] + 0xC200;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else if ( string_buffer_org[j] >= 0xC0 && string_buffer_org[j] <= 0xFF ) 
    {
      temp = string_buffer_org[j] + 0xC2C0;
      
      string_buffer_mod[j+offset] = temp>>8;
      string_buffer_mod[j+offset+1] = temp;
      offset++;
      string_length_mod++;
    }
    else
      string_buffer_mod[j+offset] = string_buffer_org[j];
  }
    
  //neuen String schreiben
  putvalue(M_FSG_40_0_0_63_Start_8_Hex,string_buffer_mod,string_length_mod);
  putValue(M_FSG_40_0_0_63_Start_8_len, string_length_mod);
  
  /*putValue(M_FSG_40_0_0_63_Start_8_len, getValueSize(this));
	M_FSG_40_0_0_63_Start_BuildFct();*/
}



/**
*
* Template-Funktion zum automatischen befuellen der Array-Daten, die in einer Arrayfunktion genutzt werden.
* Die Funktion wird durch den von BAPSimGen generierten Code aufgerufen.
*
* Parameter:
* - structArray: Muss mindestens nMax * Arraygroesse Bytes Platz haben, wird vom BAPSimGen automatisch generiert
* - structElementsSizeArray: Enthaelt die Groesseangabe jedes Array-Elements. Die Arraygroesse entspricht der Elementanzahl im Array.
*       Byte & Nibble = 1; Word = 2; usw. Bei Strings wird die maximale Stringlaenge angegeben.
* - structElementsTypeArray: Gibt den Datentyp eines Array-Elements zurueck. Die Arraygroesse entspricht der Elmentanzahl im Array.
*                               0x0 = Zahlenwert, also ein Slider, Enum, Bitfield,...
*                               0xE = String (darauf folgt immer eine 2, mit der Angabe der benutzen Bytes im String)
*                               0xF = Laenge der Nutzdaten des Strings, nur return Wert
* - fctID: Kann zur Fallunterscheidung der Funktions-IDs verwendet werden.
* - nMax: Array-Index
*
* Die Funktion kann im Switch-Case beliebig erweitert werden. Der Switch-Case wertet den Parameter fctID aus.
*           
*                    
**/
initStruct(byte structArray[], dword structElementsSizeArray[], byte structElementsTypeArray[], dword structElementsMaxSizeArray[], word fctID, word nMax )
{
    byte rand8;
    word rand16;
    word randSize;
    word index;           //indexNr die an die String Parameter angehaengt wird.
    dword destArraySize;   //groesse von structArray
    dword destStructSize;  //groesse eines "Structs" also destArraySize / Anzahl Elemente (nMax))
    dword rand32;    
    dword i;
    dword pos;    //aktuelle Position im structArray
    dword elpos;  //aktuelle Position in den structElementsXXXArray's
    
    destArraySize = elCount(structArray);
    destStructSize = destArraySize / nMax;    

    Switch(fctID){

        //Idee ist, die Arrays je nach Funcion-ID speziell initalisieren zu koennen.
        //hierbei koennten die Daten z.B. aus einer Datei eingelesen werden,
        //oder auch ueber spezielle init Funktionen mit festen Werten initialisiert werden.
        //Der Default-Fall befuellt das Array mit Random-Werten und Strings mit einem vordefinierten Wort (hier test,)

        default :
        {
            pos = 0; 
            for(i = 1; i <= nMax; i++)
            {
                //walk through the array
                
                elpos = 0;
                while(pos < (destStructSize * i) )
                {   
                    //check Element type
                    if( structElementsTypeArray[elpos] == 0x0)          
                    { //Params like int, word, etc.
                        //check element length
                        Switch(structElementsSizeArray[elpos])
                        {
                            case(1) : //byte / nibble
                                rand8 = random(structElementsMaxSizeArray[elpos]);
                                structArray[pos] = rand8;
                                pos++;
                                break;

                            case(2) : //word / int
                                rand16 = random(structElementsMaxSizeArray[elpos]);
                                int2byte(structArray, pos, rand16);
                                pos += 2;
                                break;

                            case (4) : //dword / long
                                rand32 = random(structElementsMaxSizeArray[elpos]);
                                long2byte(structArray, pos, rand32);
                                pos += 4;
                                break;                        
                         }
                    }
                    else if(structElementsTypeArray[elpos] == 0xE)          
                    { //String Params like byte[]
                        randSize = random(structElementsSizeArray[elpos]);
                        if(randSize < 2) randSize = 2; 
                        index = i-1;
                        setRandomString(structArray ,pos ,structElementsSizeArray[elpos], randSize, index);
                        pos += structElementsSizeArray[elpos];
                    }
                    else if(structElementsTypeArray[elpos] == 0xF)          
                    {
                        int2byte(structArray, pos, randSize);
                        pos += 2;
                        //write("Pos: %d Strlth: %d Type: %d ",pos-1,randSize,structElementsTypeArray[elpos]);
                    
                    }
                    elpos++;
                }
            }   
        break;
        }            
    }
}

long2Byte(byte in[], dword pos, dword value)
{
    if( (elCount(in)-pos) < 4)
        write("Array out ouf bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);
    in[++pos] = (value >> 16);
    in[++pos] = (value >> 24);
}

int2byte (byte in[],dword pos,word value)
{
    if( (elCount(in)-pos) < 2 )
        write("Array out of bounds - too small!");
    in[pos] = value;
    in[++pos] = (value >> 8);        
}

setRandomString (byte in[], dword pos, word strSize, word randSize, word count)
{
    word endPos, endString, j;
    byte testString[4]={'t','e','s','t'};
    
    endPos = pos + strSize;
    endString = pos + randSize;
    j=0;
    
    int2ascii(in, pos, count);
    pos += 2;
    
    for(pos; pos < endPos ;pos ++)
    {
        if(j > 3 )
            j = 0;
        if(pos < endString)
            in[pos] = testString[j++];
        else
            in[pos] = 0x0;
    }
}

int2ascii (byte in[], dword pos, word value)
{
    //Konvertiert nur die erste und zweite Dezimalstelle, also Zahlen zw. 0 und 99.
    
    //auf 2 Stellen kuerzen
    value = value%100;
    //10er schreiben
    in[pos] = (value/10) + 48;    //  0x30 hex = 48 dez = ascii null
    //1er schreiben
    in[pos+1] = (value%10) + 48;  //  0x30 hex = 48 dez = ascii null
}

//MR61529 
on envVar P_FSG_40_0_0_0_2_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_BAP_Config;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//MR61529 
on envVar C_FSG_40_0_0_0_1_SegmEn
{
       if(getValue(this)) 
       {
           putValue(C_FSG_40_0_0_0_1_IntTlgEn,0);
           sequence_err(FctID_GetAll,154);
       }
       else
       {
              sequence_err_off(FctID_GetAll);
       }
}

//MR61529 
on envVar C_FSG_40_0_0_0_1_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(C_FSG_40_0_0_0_1_SegmEn,0);
           intertelegram_err(FctID_GetAll);
       }
       else
       {
           intertelegram_err_off(FctID_GetAll);
       }
}

//MR61529 
on envVar C_FSG_40_0_0_0_1_ErrEn
{
if (getValue(this))
putValue(C_FSG_40_0_0_0_1_FctEn,0);
}

//MR61529 
on envVar C_FSG_40_0_0_0_1_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_GetAll;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//MR61529 
on envVar P_FSG_40_0_0_0_3_SegmEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_0_3_IntTlgEn,0);
           sequence_err(FctID_FunctionList,8);
       }
       else
       {
              sequence_err_off(FctID_FunctionList);
       }
}

//MR61529 
on envVar P_FSG_40_0_0_0_3_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(P_FSG_40_0_0_0_3_SegmEn,0);
           intertelegram_err(FctID_FunctionList);
       }
       else
       {
           intertelegram_err_off(FctID_FunctionList);
       }
}

//MR61529 
on envVar P_FSG_40_0_0_0_3_ErrEn
{
if (getValue(this))
putValue(P_FSG_40_0_0_0_3_FctEn,0);
}

//MR61529 
on envVar P_FSG_40_0_0_0_3_FctEn
{
    long data[3];
    data[0]=LSGID;
    data[1]=FctID_FunctionList;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//MR61529 	
//resending BAPconfig when this button is pressed
on envVar P_FSG_40_0_0_0_2Reset_BTN
{
   message 0x100 _mBAPconfig;

    if (getValue(this))
    {
        //for BAPconfig Set/Reset button
         _mBAPconfig.CAN=1; 
		 _mBAPconfig.ID=0x97332810; 
		 _mBAPconfig.DLC=8; 
                	
         _mBAPconfig.byte(0) = 0x0A;
         _mBAPconfig.byte(1) = 0x2;
         _mBAPconfig.byte(2) = getValue(BAPCFG_FSG_40_0_0_ProtocolMajor);
         _mBAPconfig.byte(3) = getValue(BAPCFG_FSG_40_0_0_ProtocolMinor);
         _mBAPconfig.byte(4) = getValue(BAPCFG_FSG_40_0_0_LsgClassMajor);
         _mBAPconfig.byte(5) = getValue(BAPCFG_FSG_40_0_0_LsgClassMinor);
         _mBAPconfig.byte(6) = getValue(BAPCFG_FSG_40_0_0_DFMajor);
         _mBAPconfig.byte(7) = getValue(BAPCFG_FSG_40_0_0_DFMinor);
      
        output(_mBAPconfig);	
   }
}

// Telefon - 0x31 CombinedNumbers

on envVar Env_Telefon_CombinedNumbers_LoadBTN
{
  if (@this == 1)
  {
    getValue(Env_Telefon_CombinedNumbers_Path, gTelefon_CombinedNumbers_Path);
    Telefon_CombinedNumbers_LoadArray();
  } 
}

on envVar Env_Telefon_CombinedNumbers_LoadBTN_Full
{
  if (@this == 1)
  {
    getValue(Env_Telefon_CombinedNumbers_Path, gTelefon_CombinedNumbers_Path);
    Telefon_CombinedNumbers_LoadArray();
    Telefon_CombinedNumbers_Changed(0x8,0x0, 0x0000, 0xFFFF);
  }
}

Telefon_CombinedNumbers_LoadArray()
{ 
 /********* Statische Deklarationen ***********/
	dword CSVfileHandle;
	dword filePos;
	dword paramPos;
	dword Num_of_csv_byte;
	dword element;
	dword current_CSV_line;
	byte buffer_byte[0xFFFF];
	dword i;
	dword j;
	char CSV_filename[255];
  char CSV_filepath[255];
  byte pos;
  byte empty=0;

	/********* Param Puffer Deklarationen ***********/
	char temp1[25];
  //char temp2[25];
	char temp3[25];
  char temp4[25];
	//char temp5[25];
	char temp6[25];
	char temp7[25];
	char temp8[25];
	char temp9[25];
	char temp10[25];
  char temp11[25];
  
	/********* Initialisierungen ***********/
	CSVfileHandle = 0;
	filePos = 0;
	paramPos = 0;
	Num_of_csv_byte = 0;
	element = 1;
	current_CSV_line = 0;
    //putValue(A_FSG_40_0_0_49_fileSelector,gTelefon_CombinedNumbers_Path);
    //putValue(A_FSG_40_0_0_49_loadArray_Btn, TRUE);
	for (i = 0; i < Max_Array_Size; i++)
	{ /* Initialisierung von den Ziel-Strukturen */
		Telefon_CombinedNumbers[i].Param1 = 0;
    
		for (j=0; j<100; j++) 
	  Telefon_CombinedNumbers[i].Param2[j] = 0;
		Telefon_CombinedNumbers[i].Param2_Length = 0;
		Telefon_CombinedNumbers[i].Param3 = 0;
    Telefon_CombinedNumbers[i].Param4 = 0;
		for (j=0; j<41; j++)
		Telefon_CombinedNumbers[i].Param5[j] = 0;
		Telefon_CombinedNumbers[i].Param5_Length = 0;
		Telefon_CombinedNumbers[i].Param6 = 0;
		Telefon_CombinedNumbers[i].Param7 = 0;
		Telefon_CombinedNumbers[i].Param8 = 0;
		Telefon_CombinedNumbers[i].Param9 = 0;
		Telefon_CombinedNumbers[i].Param10 = 0;
    Telefon_CombinedNumbers[i].Param11 = 0;
	}

	/********* Laden der CSV-Datei ***********/
	for (i = 0; i < strlen(gTelefon_CombinedNumbers_Path); i++)
  {
    if (gTelefon_CombinedNumbers_Path[i] == '\\' )
      pos = i;
  }
  
  // Strings löschen
  str_replace(CSV_filepath, CSV_filepath, "");
  str_replace(CSV_filename, CSV_filename, "");
 
  // Strings aufteilen
  substr_cpy(CSV_filepath, gTelefon_CombinedNumbers_Path, 0, pos, elcount(CSV_filepath)); 
  substr_cpy(CSV_filename, gTelefon_CombinedNumbers_Path, (pos+1), -1, elcount(CSV_filename)); 
 
  setFilePath(CSV_filepath,0);
  CSVfileHandle = openFileRead(CSV_filename, 1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)
  

	if (CSVfileHandle!=0) //*.csv file access successful
	{
		writelineEx(gBAP_Trace, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);    //output result
		//get data from *.csv and store the total number of byte in *.csv-file
		Num_of_csv_byte = fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);

    //writelineEx(4, 0,"Dateizugriff auf '%s' erfolgreich", CSV_filename);
   // writelineEx(4, 0,"Num_of_csv_byte '%d'", Num_of_csv_byte);
    
		for (filePos = 0; filePos < Num_of_csv_byte; filePos++) //copy data into "CombinedNumbers"
		{
      if ((buffer_byte[filePos+1] == 0xA) && (buffer_byte[filePos+2] == 0xD)) // leere Zeilen in csv ignorieren
        empty++;
      
			if (buffer_byte[filePos] != 0x3B) //read data if no ";" is detected
			{
				//nextline in *.csv (next "record element" in CombinedNumbers) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
				if (buffer_byte[filePos] == 0x0D && buffer_byte[filePos+1] == 0x0A)
				{     //writelineex(4,0,"LF / CR detected");
					if (current_CSV_line > 0 && current_CSV_line < 65535) //ignore first line in *.csv file
					{
						Telefon_CombinedNumbers[current_CSV_line-1].Param1 = atol(temp1); //Pos
            //Telefon_CombinedNumbers[current_CSV_line-1].Param2 = atol(temp2); //PbName
						Telefon_CombinedNumbers[current_CSV_line-1].Param3 = atol(temp3); //NumberType
            Telefon_CombinedNumbers[current_CSV_line-1].Param4= atol(temp4); //CallMode
						//Telefon_CombinedNumbers[current_CSV_line-1].Param5 = atol(temp5); //TelNumber
						Telefon_CombinedNumbers[current_CSV_line-1].Param6 = atol(temp6); //Day
						Telefon_CombinedNumbers[current_CSV_line-1].Param7 = atol(temp7); //Month
						Telefon_CombinedNumbers[current_CSV_line-1].Param8 = atol(temp8); //Year
						Telefon_CombinedNumbers[current_CSV_line-1].Param9 = atol(temp9); //Hour
						Telefon_CombinedNumbers[current_CSV_line-1].Param10 = atol(temp10); //Minute
            Telefon_CombinedNumbers[current_CSV_line-1].Param11 = atol(temp11); //Second
            
						for (i = 0; i < 25; i++)
						{ /* Temp-Puffer Initialisierung zur Vermeidung von Nebeneffekte */
							temp1[i]=0;
              //temp2[i]=0;
							temp3[i]=0;
							temp4[i]=0;
              //temp5[i]=0;
							temp6[i]=0;
							temp7[i]=0;
							temp8[i]=0;
							temp9[i]=0;
							temp10[i]=0;
              temp11[i]=0;
						}
					}
					current_CSV_line++; //next line in *.csv file
          i=0;
          //writelineEx(4, 0, "current_CSV_line %d", current_CSV_line);
          
          element = 1; //start at 'POS' (first record element of "array data")
					paramPos = 0; //reset value
				}
 				//copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
				else if (current_CSV_line > 0 && current_CSV_line < 65535)
				{
					//writelineEx(gBAP_Trace, 0, "Element %x  Index %x", element, j);
					switch (element)
					{
						case 1: //Pos
								if ( paramPos >= elCount(temp1) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
                  temp1[paramPos] = buffer_byte[filePos];
									paramPos++;
								}          
							break;
						case 2: //PbName
								if (paramPos < 99)
								{
                  // Sonderzeichen im UTF-8 Format (2 Byte)
                  if ( (buffer_byte[filePos] == 0xC2 || buffer_byte[filePos] == 0xC3) && (@Env_Telefon_CombinedNumbers_ListFormat == 1) )
                  {
                   A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param2[i++] = buffer_byte[filePos]; //save name as data type
								  
                    
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos++] = buffer_byte[filePos++];
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos]; //save name as char
                    
                   A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param2[i] = buffer_byte[filePos];
                    
                  }
                  // Sonderzeichen im ASCII-Format (1 Byte)
                  else if ( (buffer_byte[filePos] >= 0x80) && (buffer_byte[filePos] <= 0xBF) && (@Env_Telefon_CombinedNumbers_ListFormat == 0) )
                  {
                 
								    A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param2[i] = buffer_byte[filePos]; //save name as data type
                    
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos++] = 0xC2;
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos];  //save name as char
                   
                   
                    
                  }
                  else if ( (buffer_byte[filePos] >= 0xC0) && (buffer_byte[filePos] <= 0xFF) && (@Env_Telefon_CombinedNumbers_ListFormat == 0) )
                  {
                  
									   A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param2[i] = buffer_byte[filePos]; //save name as data type
                    
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos++] = 0xC3;
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos] - 0x40;  //save name as char
                     
             
                  }
                  // keine Sonderzeichen
                  else
                  {
                     A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param2[i] = buffer_byte[filePos]; //save name as bytes
                    Telefon_CombinedNumbers[current_CSV_line-1].Param2[paramPos] = buffer_byte[filePos]; //save name as char
                  }
									Telefon_CombinedNumbers[current_CSV_line-1].Param2_Length = paramPos +1;
                  A_FSG_40_0_0_49_ArrayDataList[current_CSV_line-1].Param2_Length = i+1;
								}
								paramPos++;
                i++;
						break;
						case 3: //NumberType
								if ( paramPos >= elCount(temp3) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp3[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
            case 4: //CallMode
								if ( paramPos >= elCount(temp4) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp4[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 5: //TelNumber
								if (paramPos < 40)
								{
									Telefon_CombinedNumbers[current_CSV_line-1].Param5[paramPos] = buffer_byte[filePos];
									Telefon_CombinedNumbers[current_CSV_line-1].Param5_Length = paramPos +1;
								}
								paramPos++;
						  break;
						case 6: //Day
								if ( paramPos >= elCount(temp6) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp6[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 7: //Month
								if ( paramPos >= elCount(temp7) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp7[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 8: //Year
								if ( paramPos >= elCount(temp8) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp8[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 9: //Hour
								if ( paramPos >= elCount(temp9) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp9[paramPos] = buffer_byte[filePos];
									paramPos++;
								}
							break;
						case 10: //Minute
								if ( paramPos >= elCount(temp10) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp10[paramPos] = buffer_byte[filePos];
									paramPos++;
                }
					 	case 11: //Second
						 		if ( paramPos >= elCount(temp11) ){
									writelineEx(gBAP_Trace, 0, "Param%x in Zeile %d in der Input CSV Datei, enthaelt mehr Zeichen als erlaubt. Bearbeitung abgebrochen!", element, current_CSV_line);
									return; //False
								}else{
									temp11[paramPos] = buffer_byte[filePos];
									paramPos++;                  
								}
							break;
                
						default:
						break;
					}
				}
			}
			else  // ";" is detected ->next record element of "array data"
			{
				//writelineEx(gBAP_Trace, 0, "naechstes Element %d Bytes",element);
				element++;
        //writelineEx(4, 0,"element: %d", element);
				paramPos=0; //reset value
			}
		}

		if (fileClose (CSVfileHandle) !=0) //close *.csv file
      writelineEx(gBAP_Trace, 0,"Datei '%s' geschlossen", CSV_filename); //output result
		else
			writelineEx(gBAP_Trace, 0,"Fehler beim Schliessen der Datei '%s'", CSV_filename);//output result
	}
	else //*.csv file access not successful
	{
		writelineEx(gBAP_Trace, 0,"Fehler beim Dateizugriff auf '%s'",CSV_filename); //output result
	}
  
  Telefon_CombinedNumbers_TotalListNum = current_CSV_line- 1 - empty;
  empty=0;
}

Telefon_CombinedNumbers (byte opcode, byte data[])
{
  byte ASG_ID, TAID, mode, recordaddress;
  byte IndexSize, Shift, Direction, TransPos;
  dword list_start, elements;
  
  if ((opcode == 1) && (Telefon_Source == 1)) // ASG GetArray
  {
    ASG_ID = data[0] >> 4 & 0xF;
    TAID = data[0] & 0xF;
    mode = data[1] >> 4 & 0xF;
    recordaddress = data[1] & 0xF;
    IndexSize = mode >> 3 & 0x1;
    Direction = (mode>>1) & 0x1;
    TransPos = (mode>>2) & 0x1;
    Shift = (mode>>0) & 0x1;

    if (IndexSize == 1)
    {
      list_start = data[2] +data[3]*256;
      elements = data[4] + data[5]*256;
    }
    else
    {
      list_start = data[2];
      elements = data[3];
    }
    
    ///////// "BAP-Array-Lists - FSG-Response Status-Array" - Control for automatic adaption from "Get Array" header values /////////
  
    if (@env_AutoGetArray_ASG_ID == 0)  // ASG_ID  from GetArray
      @A_FSG_40_0_0_49_1 = ASG_ID;  // Set to panel value
    else
      ASG_ID = @A_FSG_40_0_0_49_1; // Set from panel value
      
    if (@env_AutoGetArray_TAID == 0)  // TAID
      @A_FSG_40_0_0_49_2 = TAID;
    else
      TAID = @A_FSG_40_0_0_49_2;
    
    if (@env_AutoGetArray_RecAdr == 0)  // RecordAddress
      @A_FSG_40_0_0_49_RecAdr = recordaddress;
    else
      recordaddress = @A_FSG_40_0_0_49_RecAdr;
    
    if (@env_AutoGetArray_Shift == 0)  // Mode.Shift
      @A_FSG_40_0_0_49_Shift = (mode>>0);
    else
      mode = ((@A_FSG_40_0_0_49_Shift*1)+(Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Dir == 0)  // Mode.Direction
      @A_FSG_40_0_0_49_Direction = (mode>>1);
    else
      mode = ((Shift*1)+(@A_FSG_40_0_0_49_Direction*2)+(TransPos*4)+(IndexSize*8));
    
    if (@env_AutoGetArray_Start == 0)  // Start
      @A_FSG_40_0_0_49_Start = list_start;
    else
      list_start = @A_FSG_40_0_0_49_Start;
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
    if (@env_AutoGetArray_AutoStatus == 0)  // switch auto/manual Status-Array
    {
      Telefon_CombinedNumbers_Status (ASG_ID, TAID, mode, recordaddress,list_start, elements);
    }
  }
}

Telefon_CombinedNumbers_Status (byte ASG_ID, byte TAID, byte mode, byte recordaddress, dword list_start, dword received_elements)
{   
  byte string[60];
  byte IndexSize, shift, direction;
  int startposition, endposition, elements;
  byte sequenceNumber = 0;
  int i, k , strctr;
  int stringsize;
  
  elements = received_elements;
  
  Data_Telefon_CombinedNumbers[0] = ASG_ID*16 + (TAID & 0xF);
  Data_Telefon_CombinedNumbers[1] = (Telefon_CombinedNumbers_TotalListNum & 0xFF);
  Data_Telefon_CombinedNumbers[2] = (mode|0x4)*16 + (recordaddress & 0xF);
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1;
  
  switch(direction)
  {
    case 0: // Anfrage in pos. Richtung

      // Start bei Listenbeginn
      if (list_start == 0)
      {
        startposition = shift;
        endposition = startposition + elements - 1;
      }
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (list_start < Telefon_CombinedNumbers_TotalListNum)
        {
          startposition = list_start + shift;
          endposition = startposition + elements - 1;
        }
        else
        {
          startposition = list_start + shift;
          elements = 0;
        }
      }
        
      // wenn Endposition außerhalb der max. Listenelemente liegt, die zu übertragenden Elemente kürzen
      if (endposition >= Telefon_CombinedNumbers_TotalListNum)
      {
        endposition = Telefon_CombinedNumbers_TotalListNum -1;
        elements = Telefon_CombinedNumbers_TotalListNum - startposition;
      }
      
    break;
  
    case 1: // Anfrage in neg. Richtung
      
      // Start in Liste
      if (list_start > 0)
      {
        // prüfen, ob Startelement innerhalb der Liste vorhanden ist
        if (list_start <= Telefon_CombinedNumbers_TotalListNum)
        {
          startposition = list_start - shift;
          endposition = startposition - elements + 1;
        }
        else
        {
          startposition = list_start - shift;
          elements = 0;
        }
        // wenn Endposition im negativen Bereich , die zu übertragenden Elemente kürzen
        if ((float) endposition < 0)
        {
          endposition = 0;
          elements = list_start - shift + 1;
        }
      }
      
      // Start bei Listenbeginn
      if ((list_start == 0))
      {
        // Abfrage letzte Listenelemente
        if (shift == 1)
        {
          startposition = Telefon_CombinedNumbers_TotalListNum - 1;
          endposition = startposition - elements + 1;
        }
        else
          elements = 0;
      }
      
    break;
  }
    
  if (IndexSize == 0)
  {
    Data_Telefon_CombinedNumbers[3] = list_start & 0xFF;
    Data_Telefon_CombinedNumbers[4] = elements & 0xFF;

    j_Telefon_CombinedNumbers = 5;
  }
  else
  {
    Data_Telefon_CombinedNumbers[4] = (list_start >> 8) & 0xFF;
    Data_Telefon_CombinedNumbers[3] = list_start & 0xFF;
    Data_Telefon_CombinedNumbers[6] = (elements >> 8) & 0xFF;
    Data_Telefon_CombinedNumbers[5] = elements & 0xFF;

    j_Telefon_CombinedNumbers = 7;
  }
  
  if (elements > 0)
  {
    switch(direction)
    {
      case 0:        

        for (i = startposition ; i <= endposition && i >= 0; i++)
        {              
          switch(IndexSize)
          {
            case 0: Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param1;
                    break;
            case 1: Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param1 &0xFF;
                    Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = (Telefon_CombinedNumbers[i].param1 >> 8)&0xFF;
                    break;
          }

          if (recordaddress == 0x0 || recordaddress == 0x1)
          {
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param2_Length; 
            stringsize = Telefon_CombinedNumbers[i].param2_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param2[strctr];            
            }
          }

          if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x2)
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = (Telefon_CombinedNumbers[i].param3 & 0xF) *16 + (Telefon_CombinedNumbers[i].param4 & 0xF);

          if (recordaddress == 0x0 ||  recordaddress == 0x2)
          {
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param5_Length; 
            stringsize = Telefon_CombinedNumbers[i].param5_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param5[strctr];            
            }
          }

          if (recordaddress == 0x0 || recordaddress == 0x2)
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param6;
          
          if (recordaddress == 0x0 || recordaddress == 0x2)
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param7;
          
          if (recordaddress == 0x0 || recordaddress == 0x2)
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param8;
          
          if (recordaddress == 0x0 || recordaddress == 0x2)
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param9;
          
          if (recordaddress == 0x0 || recordaddress == 0x2)
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param10;
          
          if (recordaddress == 0x0 || recordaddress == 0x2)
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param11;
                
        }
            
      break;
        
      case 1:
              
        for (i = startposition ; i >= endposition && i >= 0; i--)
        {
          switch(IndexSize)
          {
            case 0: Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param1;
                    break;
            case 1: Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param1 &0xFF;
                    Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = (Telefon_CombinedNumbers[i].param1 >> 8)&0xFF;
                    break;
          }

          if (recordaddress == 0x0 || recordaddress == 0x1)
          {
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param2_Length; 
            stringsize = Telefon_CombinedNumbers[i].param2_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param2[strctr];
            }
          }

          if (recordaddress == 0x0 || recordaddress == 0x1 ||  recordaddress == 0x2)
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = (Telefon_CombinedNumbers[i].param3 & 0xF) *16 + (Telefon_CombinedNumbers[i].param4 & 0xF);

          if (recordaddress == 0x0 ||  recordaddress == 0x2)
          {
            Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param5_Length; 
            stringsize = Telefon_CombinedNumbers[i].param5_Length;
          
            for (strctr = 0; strctr < stringsize; strctr++)
            {
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param5[strctr];            
            }
          }

          if (recordaddress == 0x0 || recordaddress == 0x2)
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param6;
          
          if (recordaddress == 0x0 || recordaddress == 0x2)
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param7;
          
          if (recordaddress == 0x0 || recordaddress == 0x2)
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param8;
          
          if (recordaddress == 0x0 || recordaddress == 0x2)
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param9;
          
          if (recordaddress == 0x0 || recordaddress == 0x2)
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param10;
          
          if (recordaddress == 0x0 || recordaddress == 0x2)
              Data_Telefon_CombinedNumbers[j_Telefon_CombinedNumbers++] = Telefon_CombinedNumbers[i].param11;
        }
        
      break;
    }
  }
  settimer (Delay_Telefon_CombinedNumbers, @Env_Telefon_CombinedNumbers_ListDelay);
}

Telefon_CombinedNumbers_Changed(byte mode, byte recordaddress, dword list_start, dword elements)
{
  byte data[BAP_BUFFERSIZE];
  byte IndexSize, direction, shift, length;
  
  IndexSize = (mode>>3) & 0x1;
  direction = (mode>>1) & 0x1;
  shift     = mode & 0x1; 
       
  data[0] = (mode & 0xF) *16 + (recordaddress & 0xF);

  if (IndexSize == 0)
  {
    data[1] = list_start;
    data[2] = elements;
    length = 3;
  }
  else if (IndexSize == 1)
  {
    data[1] = list_start & 0xFF;
    data[2] = (list_start >> 8) & 0xFF;
    data[3] = elements & 0xFF;
    data[4] = (elements >> 8) & 0xFF;
    
    length = 5;
  }
  SendRequestByteSequence(NODE_INDEX, 0x31, Changed_REQ, length, data);
}

on timer Delay_Telefon_CombinedNumbers
{
  sendRequestByteSequence(NODE_INDEX, 0x31, Data_REQ, j_Telefon_CombinedNumbers, Data_Telefon_CombinedNumbers);
}

sendRequestByteSequence(dword NodeIndex, byte fctID, byte req, dword length,byte data[])
{
  int i;
  byte temp = 0;
  //dword NodeIndex;
  dword header[6];
  byte request_data[BAP_BUFFERSIZE];
 
  for (i = 0; i <BAP_BUFFERSIZE; i++)
      request_data[i] = 0;
  for (i = 0; i < length; i++)
      request_data[i] = data[i];

  /*switch(LSGID)
  {
    case 13: NodeIndex = Node_Index_DoorLocking; break;
    case 35: NodeIndex = Node_Index_BCmE; break;
    case 37: NodeIndex = Node_Index_BatteryControl; break;
    case 40: NodeIndex = Node_Index_Telefon; break;
    case 41: NodeIndex = Node_Index_Telefon2; break;
    case 49: NodeIndex = Node_Index_Audio; break;
    case 50: NodeIndex = Node_Index_Navigation; break;
    case 70: NodeIndex = Node_Index_SDS; break;
    case 80: NodeIndex = Node_Index_InfoSettings; break;
    default: writelineex(gBAP_Trace, 3, "ungültige LSGID");
      
    return;
  }*/

  header[0] = LSGID;
  header[1] = fctID;
  header[2] = req;
  header[3] = Bap_byteSequence;
  header[4] = length;
  header[5] = 0;
  
  ///Debug Ausgaben///
  /*writelineex(4,0,"------------------");
  writelineex(4,0,"NodeIndex: %d", NodeIndex);
  writelineex(4,0,"LSGID: %d", LSGID);
  writelineex(4,0,"fctID: 0x%x", fctID);
  writelineex(4,0,"req: 0x%x", req);
  writelineex(4,0,"BAP: 0x%x", Bap_byteSequence);
  writelineex(4,0,"length: %d", length);*/
  
  /*for (i=0; i<length; i++)
    writelineex(4,0,"data[%d]: %x", i,data[i]);*/

  temp = BAP180_Request(NodeIndex, header, request_data);
  
  if (temp != 0)
    writelineex(gBAP_Trace, 3, "ERROR: 0x%X LSGID: 0x%X fctID: 0x%X REQ: 0x%X NodeIndex: %d", temp , LSGID, fctID, req, NodeIndex);
  else
    writelineex(gBAP_Trace, 1, "Request successful LSGID: 0x%X fctID: 0x%X REQ: 0x%X NodeIndex: %d",LSGID, fctID, req, NodeIndex);
}

void updateCallOptions(int callID, int callState)
{ int i, activeCallFlag=0, onholdFlag=0; 
  	switch (callState)
					{
						case active:
            onholdFlag=0;
            for(i=0;i<7;i++)
                {	if(gCallState[i]==onhold) onholdFlag = 1; }
                
				          if(callID == 0)
                  {
                    if( onholdFlag == 1 && gCallType[callID] != 0x05) // not conference call
                    @P_FSG_40_0_0_22_3 = 96; //end call & microfon on/off options - by default -> call option MP Swap and CC join set by value 96 : bit 5 = 1 and bit 6 = 1
                    else if( onholdFlag == 1 && gCallType[callID] == 0x05 && !areAllOnHold) // conference call
                    @P_FSG_40_0_0_22_3 = 32; //end call & microfon on/off options - by default -> call option MP Swap set by value 32 : bit 5 = 1
                    else
                    @P_FSG_40_0_0_22_3 = 8; //end call & microfon on/off options - by default -> call option on hold set by value 8 : bit 3 = 1                
                  }
                  if(callID == 1)
                  {
                   if( onholdFlag == 1 && gCallType[callID] != 0x05) // not conference call
                    @P_FSG_40_0_0_22_6 = 96; //end call & microfon on/off options - by default -> call option MP Swap and CC join set by value 96 : bit 5 = 1 and bit 6 = 1
                    else if( onholdFlag == 1 && gCallType[callID] == 0x05 && !areAllOnHold) // conference call
                    @P_FSG_40_0_0_22_6 = 32; //end call & microfon on/off options - by default -> call option MP Swap set by value 32 : bit 5 = 1
                    else
                    @P_FSG_40_0_0_22_6 = 8; //end call & microfon on/off options - by default -> call option on hold set by value 8 : bit 3 = 1                
                  }
                  if(callID == 2)
                  {
                    if( onholdFlag == 1 && gCallType[callID] != 0x05) // not conference call
                    @P_FSG_40_0_0_22_9 = 96; //end call & microfon on/off options - by default -> call option MP Swap and CC join set by value 96 : bit 5 = 1 and bit 6 = 1
                    else if( onholdFlag == 1 && gCallType[callID] == 0x05 && !areAllOnHold) // conference call
                    @P_FSG_40_0_0_22_9 = 32; //end call & microfon on/off options - by default -> call option MP Swap set by value 32 : bit 5 = 1
                    else
                    @P_FSG_40_0_0_22_9 = 8; //end call & microfon on/off options - by default -> call option on hold set by value 8 : bit 3 = 1                
                  }
                  if(callID == 3)
                  {
                  if( onholdFlag == 1 && gCallType[callID] != 0x05) // not conference call
                    @P_FSG_40_0_0_22_12 = 96; //end call & microfon on/off options - by default -> call option MP Swap and CC join set by value 96 : bit 5 = 1 and bit 6 = 1
                    else if( onholdFlag == 1 && gCallType[callID] == 0x05 && !areAllOnHold) // conference call
                    @P_FSG_40_0_0_22_12 = 32; //end call & microfon on/off options - by default -> call option MP Swap set by value 32 : bit 5 = 1
                    else
                    @P_FSG_40_0_0_22_12 = 8; //end call & microfon on/off options - by default -> call option on hold set by value 8 : bit 3 = 1
                  }
                  if(callID == 4)
                  {
                    if( onholdFlag == 1 && gCallType[callID] != 0x05) // not conference call
                    @P_FSG_40_0_0_22_15 = 96; //end call & microfon on/off options - by default -> call option MP Swap and CC join set by value 96 : bit 5 = 1 and bit 6 = 1
                    else if( onholdFlag == 1 && gCallType[callID] == 0x05 && !areAllOnHold) // conference call
                    @P_FSG_40_0_0_22_15 = 32; //end call & microfon on/off options - by default -> call option MP Swap set by value 32 : bit 5 = 1
                    else
                    @P_FSG_40_0_0_22_15 = 8; //end call & microfon on/off options - by default -> call option on hold set by value 8 : bit 3 = 1                
                  }
                  if(callID == 5)
                  {
                    if( onholdFlag == 1 && gCallType[callID] != 0x05) // not conference call
                    @P_FSG_40_0_0_22_18 = 96; //end call & microfon on/off options - by default -> call option MP Swap and CC join set by value 96 : bit 5 = 1 and bit 6 = 1
                    else if( onholdFlag == 1 && gCallType[callID] == 0x05 && !areAllOnHold) // conference call
                    @P_FSG_40_0_0_22_18 = 32; //end call & microfon on/off options - by default -> call option MP Swap set by value 32 : bit 5 = 1
                    else
                    @P_FSG_40_0_0_22_18 = 8; //end call & microfon on/off options - by default -> call option on hold set by value 8 : bit 3 = 1                
                  }
                  if(callID == 6)
                  {
                    if( onholdFlag == 1 && gCallType[callID] != 0x05) // not conference call
                    @P_FSG_40_0_0_22_21 = 96; //end call & microfon on/off options - by default -> call option MP Swap and CC join set by value 96 : bit 5 = 1 and bit 6 = 1
                    else if( onholdFlag == 1 && gCallType[callID] == 0x05 && !areAllOnHold) // conference call
                    @P_FSG_40_0_0_22_21 = 32; //end call & microfon on/off options - by default -> call option MP Swap set by value 32 : bit 5 = 1
                    else
                    @P_FSG_40_0_0_22_21 = 8; //end call & microfon on/off options - by default -> call option on hold set by value 8 : bit 3 = 1                
                  }
                   
							break;
                  
						case ringing_waiting:
                   activeCallFlag=0;
                   for(i=0;i<7;i++)
                        {	if(gCallState[i]==active) activeCallFlag = 1; }
                        
                  if(callID == 0)
                  {
                    if( activeCallFlag == 1 )
                    @P_FSG_40_0_0_22_3 = 6; //end call & mute options - by default -> call option MPCallHoldAcceptWAitinCall & MP Release Active Call Accept Waiting call set by value 5 : bit 0 = 1 & bit 2 = 1
                    else     
                    @P_FSG_40_0_0_22_3 = 1; //end call & mute options - by default -> call option accept Call set by value 1 : bit 0 = 1               
                  }
                  if(callID == 1)
                  {
                    if( activeCallFlag == 1 )
                    @P_FSG_40_0_0_22_6 = 6; //end call & mute options - by default -> call option MPCallHoldAcceptWAitinCall & MP Release Active Call Accept Waiting call set by value 5 : bit 0 = 1 & bit 2 = 1
                    else
                    @P_FSG_40_0_0_22_6 = 1; //end call & mute options - by default -> call option accept Call set by value 1 : bit 0 = 1
                  }
                  if(callID == 2)
                  {
                    if( activeCallFlag == 1 )
                    @P_FSG_40_0_0_22_9 = 6; //end call & mute options - by default -> call option MPCallHoldAcceptWAitinCall & MP Release Active Call Accept Waiting call set by value 5 : bit 0 = 1 & bit 2 = 1
                    else
                    @P_FSG_40_0_0_22_9 = 1; //end call & mute options - by default -> call option accept Call set by value 1 : bit 0 = 1
                  }
                  if(callID == 3)
                  {
                     if( activeCallFlag == 1 )
                    @P_FSG_40_0_0_22_12 = 6; //end call & mute options - by default -> call option MPCallHoldAcceptWAitinCall & MP Release Active Call Accept Waiting call set by value 5 : bit 1 = 1 & bit 2 = 1
                    else
                    @P_FSG_40_0_0_22_12 = 1; //end call & mute options - by default -> call option accept Call set by value 1 : bit 0 = 1
                  }
                  if(callID == 4)
                  {
                    if( activeCallFlag == 1 )
                    @P_FSG_40_0_0_22_15 = 6; //end call & mute options - by default -> call option MPCallHoldAcceptWAitinCall & MP Release Active Call Accept Waiting call set by value 5 : bit 1 = 1 & bit 2 = 1
                    else
                    @P_FSG_40_0_0_22_15 = 1; //end call & mute options - by default -> call option accept Call set by value 1 : bit 0 = 1
                  }
                  if(callID == 5)
                  {
                     if( activeCallFlag == 1 )
                    @P_FSG_40_0_0_22_18 = 6; //end call & mute options - by default -> call option MPCallHoldAcceptWAitinCall & MP Release Active Call Accept Waiting call set by value 5 : bit 1 = 1 & bit 2 = 1
                    else
                    @P_FSG_40_0_0_22_18 = 1; //end call & mute options - by default -> call option accept Call set by value 1 : bit 0 = 1
                  }
                    if(callID == 6)
                  {
                     if( activeCallFlag == 1 )
                    @P_FSG_40_0_0_22_21 = 6; //end call & mute options - by default -> call option MPCallHoldAcceptWAitinCall & MP Release Active Call Accept Waiting call set by value 5 : bit 1 = 1 & bit 2 = 1
                    else
                    @P_FSG_40_0_0_22_21 = 1; //end call & mute options - by default -> call option accept Call set by value 1 : bit 0 = 1
                  }
        
							break;
        
						case onhold: 
                  if(callID == 0)
                  {
                     @P_FSG_40_0_0_22_3 = 16; //end call - by default -> call option Resume Call set by value 16 : bit 4 = 1               
                  }
                  if(callID == 1)
                  {
                     @P_FSG_40_0_0_22_6 = 16; //end call - by default -> call option Resume Call set by value 16 : bit 4 = 1 
                  }
                  if(callID == 2)
                  {
                     @P_FSG_40_0_0_22_9 = 16; //end call - by default -> call option Resume Call set by value 16 : bit 4 = 1 
                  }
                  if(callID == 3)
                  {
                    @P_FSG_40_0_0_22_12 = 16; //end call - by default -> call option Resume Call set by value 16 : bit 4 = 1 
                  }
                  if(callID == 4)
                  {
                    @P_FSG_40_0_0_22_15 = 16; //end call - by default -> call option Resume Call set by value 16 : bit 4 = 1 
                  }
                  if(callID == 5)
                  {
                    @P_FSG_40_0_0_22_18 = 16; //end call - by default -> call option Resume Call set by value 16 : bit 4 = 1 
                  }
                    if(callID == 6)
                  {
                    @P_FSG_40_0_0_22_21 = 16; //end call- by default -> call option Resume Call set by value 16 : bit 4 = 1 
                  }
        
							break;
        	
          }
          
              
}

//extra function 

long lStringToByteArray(byte BArray[], char InpStr[], long InpOffset, long InpMaxChar, byte TreatAsHEX)
{
  /**************************************************************************************************
   lStringToByteArray: 
        Converts the InpStr[] string containing byte values (decimal or hexadecimal if starting
        with 0x or $ or TreatAsHEX is set) separated by non hex-number character into an array
        of byte values.

 

        The content of InpStr[] is converted starting with index InpOffset for InpMaxChar characters.

 

        In case TreatAsHEX is set (!=0) all data in InpStr[] are automatically interpreted as hexadecimal
        and InpStr[] must not contain any base indicators as '$' or '0x'.
        
        
        Returns the number of converted values (as long).
        
        Example:
        lNum = lStringToByteArray(BArray, "123, 0x10 47    $64", 0, 100, 0);
        will result in:
        lNum == 4
        BArray[0] == 123
        BArray[1] == 16
        BArray[2] == 47
        BArray[3] == 100

 

        lNum = lStringToByteArray(BArray, "123, 0x10 47    $64", 5, 8, 0);
        will result in:
        lNum == 2
        BArray[0] == 16
        BArray[1] == 47

 

        lNum = lStringToByteArray(BArray, "12, 10 47        64", 0, 100, 1);
        will result in:
        lNum == 4
        BArray[0] == 18
        BArray[1] == 16
        BArray[2] == 71
        BArray[3] == 100

 

        Autor: Frank Dressler
  **************************************************************************************************/

 

  char bstr[5]; /* actual substring to convert: 0xnn\0 */
 
  long bstrIdx;
  long InpStrIdx; /* processing index for InpStr[] */
  long ValIdx; /* processing index for BArray[] */
  long lval;   /* temporary conversion result */
  long strLength; /* length of input string */
  byte bConvertFlag; /* flag to start convertion */

 


  bstrIdx = 0;
  strLength = strlen(InpStr);
  if (InpOffset + InpMaxChar < strLength) {
     strLength = InpOffset + InpMaxChar;
  }

 

  ValIdx = 0;
  bstr[0] = '\0';
  for(InpStrIdx = InpOffset; InpStrIdx < strLength; InpStrIdx++) {
//  write ("%d/%d: %c", InpStrIdx, strLength, InpStr[InpStrIdx]);
    bConvertFlag = 0;
      if (   (TreatAsHEX == 0 && (InpStr[InpStrIdx] == 'x' || InpStr[InpStrIdx] == 'X' || InpStr[InpStrIdx] == '$'))
        || (InpStr[InpStrIdx] >= 'A' && InpStr[InpStrIdx] <= 'F')
        || (InpStr[InpStrIdx] >= 'a' && InpStr[InpStrIdx] <= 'f')
        || (InpStr[InpStrIdx] >= '0' && InpStr[InpStrIdx] <= '9')) {
        /* valid number character: */
      if (TreatAsHEX && (bstrIdx == 0)) {
            bstr[0] = '0';
            bstr[1] = 'X';
            bstrIdx = 2;
        }

 

      if (bstrIdx < 4) { /* not more than 4 characters allowed  */
        if ((InpStr[InpStrIdx] == '$') && (bstrIdx == 0)) {
            /* treat '$' special at the beginning of a value -> replace it by 0X: */
            bstr[0] = '0';
            bstr[1] = 'X';
            bstrIdx = 2;
        }
          else {
             /* copy it to convertion string */
          bstr[bstrIdx] = InpStr[InpStrIdx];
            bstrIdx++;
        }
      }
      else {
        write("lStringToByteArray: strange value (No. %d)in InpStr limited to 4 char", ValIdx+1);
      }
    if (TreatAsHEX && bstrIdx == 4) {
      /* in case all values are hex we don' t need delimiter */  
       bConvertFlag = 1;
    }
      if (InpStrIdx == strLength-1) {
        /* last char in string, start conversion */
        bConvertFlag = 1;
      }
    }
    else {
      /* all other characters treated as delimiter */
        bConvertFlag = 1;
    }

 

    if (bConvertFlag) {
      /* first check if there is something to convert */
      if (bstrIdx > 0) {
        bstr[bstrIdx] = '\0'; /* add terminating \0 */
        /* convert number in bstr[] */
        lval = atol(bstr);
        /* limitation to max. allowed byte value */
        if (lval > 255) {
            write("lStringToByteArray: %d. value in InpStr > 255! (limited to 255)", ValIdx+1);
            lval = 255;
        }
        /* copy result to byte array: */
        if (ValIdx < elcount(BArray)) {
          BArray[ValIdx] = lval;
          ValIdx++;
        }
        else {
          write ("lStringToByteArray: Not enough elements in BArray[] to store all converted values!");
        }
      }
      bstrIdx = 0; /* ready to convert next number */ 
    }
  }

 

  return ValIdx; /* return number of converted values */
}

//////////Remote Side Panel


on envVar env_FSG_IncomingCall
{
int i, length, valid, strlength;
byte possible;

//init lokal variables
	length=0;
	valid=0;
	possible=1;
//********************	

	for(i = 0; i < 7; i++){
		if(gCallState[i] == dialing || gCallState[i] == ringing_waiting || gCallState[i] ==  disconnecting)
			possible = 0;
	}



	if(@ON_OFF_FSG40_0 == 1 && getvalue(this) && possible == 1) //incoming call is possible
	{
//		for (i=0;i<CALL_INFO_NUMBER_LENGTH;i++)													//initialize array for incoming call number
//			gincomingcall_number[i] = 0;
		for (i=0;i<CALL_INFO_NAME_LENGTH;i++)													//initialize array for incoming call name
		{	gDialName_data[i] = 0;
		  gDialName_string[i] = 0;
    }
    
		getvalue(env_FSG_incomingcallstring, gDialTelNumber_string);		//read incoming call number fromm panel
    length=strlen(gDialTelNumber_string);
   
    
    for(i=0;i<length;i++) 
       gDialTelNumber_data[i] = gDialTelNumber_string[i]; // copy TelNumber to data type variable for CALL INFO
		// write("telnum=%x",gDialTelNumber_data[i]);
    
		valid=tel_number_valid (gDialTelNumber_string, length);			//check each part of the new number of correctness
				
			if (valid)														//when new number only includes valid characters
			{
		//		write("Incoming Call: valid number");
		//		gincomingcall=1;
				gcallID= searchFREEcallID(ringing_waiting);					//check for free call-ID
				write("FSG-Telephone-Call incomingcall CallID: %d", gcallID);
        
    //search number in phonebook
      searchandSetNameNr(gcallID);
      setcallState(gcallID,ringing_waiting); 
      sendCallStateStatus();
      
      }       
    
  }  
        
      
}

void updateCallType()
{
     gCallType[0] = @P_FSG_40_0_0_22_2; //  call type - ID 0
     gCallType[1] = @P_FSG_40_0_0_22_5; //  call type - ID 1
     gCallType[2] = @P_FSG_40_0_0_22_8; //  call type - ID 2
     gCallType[3] = @P_FSG_40_0_0_22_11; // call type - ID 3
     gCallType[4] = @P_FSG_40_0_0_22_14; // call type - ID 4
     gCallType[5] = @P_FSG_40_0_0_22_17; // call type - ID 5  
     gCallType[6] = @P_FSG_40_0_0_22_20; // call type - ID 6
}

void updateCallState()
{
     gCallState[0] = @P_FSG_40_0_0_22_1; //  call state - ID 0
     gCallState[1] = @P_FSG_40_0_0_22_4; //  call state - ID 1
     gCallState[2] = @P_FSG_40_0_0_22_7; //  call state - ID 2
     gCallState[3] = @P_FSG_40_0_0_22_10; // call state - ID 3
     gCallState[4] = @P_FSG_40_0_0_22_13; // call state - ID 4
     gCallState[5] = @P_FSG_40_0_0_22_16; // call state - ID 5  
     gCallState[6] = @P_FSG_40_0_0_22_19; // call state - ID 6
}

int tel_number_valid (char tel_number [], byte length)
{

  int valid, i;

  //init lokal variables
	i=0;
	valid=1;
  //********************

	for (i=0; i<length; ++i)
  {
		switch(tel_number [i])
    {
			case '0': break;
			case '1': break;
			case '2':	break;
			case '3': break;
			case '4': break;
			case '5':	break;
			case '6':	break;
			case '7':	break;
			case '8':	break;
			case '9':	break;
			case '+':
				if(i!=0)
					valid = 0;	
			  break;
			case '*':	break;
			case '#': break;
      case 'p': break;
      case 'w': break;
			default:
				valid = 0;
			  break;
		}
	}

	return valid;

}


int searchFREEcallID (byte event)
{
  int i, finish, freecallstate;

  //init lokal variables
	finish=0;
	freecallstate=0xff;
//********************

 if (event == ringing_waiting)
{	  for(i=0;finish!=1;i++)
      {								//check status of each callID
					switch(gCallState [i])
          {
						case idle:
							if(freecallstate==0xff)
								freecallstate=i;
						break;
              
//            case active: // active allowed for short time  /// -update in ticket GVBA-11140
//              setcallState(i,onhold);
//              break;
              
            case ringing_waiting:
							freecallstate=0xff;						//no incoming call possible
							finish=1;								//loop finished
						break;
              
						case dialing:
							freecallstate=0xff;						//no incoming call possible
							finish=1;								//loop finished
						break;
              
						case disconnecting:
							freecallstate=0xff;						//no incoming call  possible
							finish=1;								//loop finished
						break;
              
						default:
						break;
					}
					if (i==6 && finish==0)							//last element is reached and loop in't finished yet
						finish=1;									//loop finished
				}
}


if(event == dialing)
{   for(i=0;finish!=1;i++)
      {								//check status of each callID
					switch(gCallState [i])
          {
						case idle:
							if(freecallstate==0xff)
								freecallstate=i;
						break;
              
						case onhold:
						break;
              
            case INCOMING_ON_HOLD:
            break;
              
            case active: // active allowed for short time
              setcallState(i,onhold);
              sendCallStateStatus();
              break;
              
              default:									//one callID status is "dialing/disconnecting" // active allowed for short time
							freecallstate=0xff;						//no dialing possible
							finish=1;								//loop finished
						break;
					}
					if (i==6 && finish==0)							//last element is reached and loop in't finished yet
						finish=1;									//loop finished
				}
}
 		
return(freecallstate);
		
}





on envVar env_FSG_RemoteSide_HangUpWait
{
int i;

	if(@ON_OFF_FSG40_0 == 1 && getvalue(this) )//&& getvalue(env_FSG_dialednumber_free_busy)==free)??????
	{
		//search for ringing_waiting corresponding call ID 
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==ringing_waiting)						//found corresponding call
			{
				
				setcallState(gcallID, disconnecting);				//disconnect call
        sendCallStateStatus();
				settimer(disconnectingTimer, 1500);
				
				i=7;												//loop finished
			}
		}
	}
}

on envVar env_FSG_dialednumber_accepted
{
int i;

	if(@ON_OFF_FSG40_0 == 1)
	{
		if(getvalue(this) )  //&& getvalue(env_FSG_dialednumber_free_busy)==free) ????  
		{
			//search for dialing calls 
			for(i=0;i<7;i++)
			{
				if(gCallState[i]==dialing)
				{
          gcallID = i ; 
					setcallState(gcallID, active);
          sendCallStateStatus();
				//	EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);
					i=7;
				}
			}
	
		}
	}
}

on envVar env_FSG_RemoteSide_HangUp
{
int i;

	if(@ON_OFF_FSG40_0 == 1 && getvalue(this) ) //  && getvalue(env_FSG_dialednumber_free_busy)==free) ???
	{
		//search for dialing calls 
		for(i=0;i<7;i++)
		{
			if(gCallState[i]==dialing)								//found corresponding dialing call 
			{
//				EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);	
				
//				gDisconnectReason=linebusy;								//set Disconnect Reason
//				putvalue(env_FSG_DisconnectReason, gDisconnectReason);	//update panel
//				DisconnectReason_Request(Data_REQ, 0);						//send Disconnect Reason
        gcallID = i ;
				setcallState(gcallID, disconnecting);				//disconnect call
        sendCallStateStatus();
				settimer(disconnectingTimer, 1500);
				
				i=7;												//loop finished
			}
			else if(gCallState[i]==active)							//found corresponding active call
			{
		//		EnableControl("FSG-Telephone_Remote_Side", "free_busy", 1);	
				gcallID = i ;
				setcallState(gcallID, disconnecting);				//disconnect call
        sendCallStateStatus();
				settimer(disconnectingTimer, 1500);
				
				i=7;												//loop finished
			}
		}
	}
}

/////////Methods 

on envVar env_FSG_DialNumber
{
int nulength, nalength, hexnalength, is_emergency_call;
byte valid=0;
char empty_string [3];
int i,isEmergency;
//byte useHexString;
//byte hexName[DIAL_NUMBER_NAME_LENGTH];

//init lokal variables
	nulength=0;     //stringlength of number 
    nalength=0;     //stringlenght of name
    i = 0;
	for(i=0;i<3;i++)
		empty_string[i]=0;
//********************

	if(@ON_OFF_FSG40_0 == 1 && getvalue(this))
    {
        // check if any call is still dialing
        for(i = 0; i < 7; i++)
        {            
            if(gCallState[i] == dialing)
            {
                //write("call %d is still dialing", i);
                return;
            }
//            if(gCallState[i] == active)
//            {
//                //write("call %d is still active", i);
//                return;
//            }
        }

    getvalue(env_FSG_DialNumber_TelNumber, gDialTelNumber_string);		//read incoming call number fromm panel
    nulength=strlen(gDialTelNumber_string);
    
    getvalue(env_FSG_DialNumber_Name, gDialName_string);		//read incoming call number fromm panel
    nalength=strlen(gDialName_string);
   
    
    for(i=0;i<nulength;i++) 
       gDialTelNumber_data[i] = gDialTelNumber_string[i]; // copy TelNumber to data type variable for CALL INFO
    
    for(i=0;i<nalength;i++) 
    { gDialName_data[i] = gDialName_string[i];           // copy Name to data type variable for CALL INFO
      write("name=%x",gDialName_data[i]);
      }
    
		valid = tel_number_valid (gDialTelNumber_string, nulength);			//check each part of the new number of correctness
		isEmergency = tel_number_emergency (gDialTelNumber_string, nulength);	// check if number is 112 or 911 
    
			if (valid)														//when new number only includes valid characters
			{        
				
          
        if(isEmergency )
        {
           setcallState(gcallID,ecallconfirmationpending); 
           sendCallStateStatus();
           settimer (EmergencyCallTimer,10); // 10 seconds waiting for confirmation or cancel 
        }
        
        else
        {
          gcallID= searchFREEcallID(dialing);					//check for free call-ID
				  write("FSG-Telephone-Call Dial CallID: %d", gcallID);
          
            //search number in phonebook
        searchandSetNameNr(gcallID);
        setcallState(gcallID,dialing); 
        sendCallStateStatus();
        }
      }       
    
  }  

}

on envVar env_FSG_HangupCall
{
byte i;
byte HangupPossible;

//init lokal variables
    i=0;
    HangupPossible=0;
//********************

	if(@ON_OFF_FSG40_0 == 1 && getvalue(this)) 
    {
		 gHangupCall_CallID = getvalue(env_FSG_HangupCall_CallID);
        
        if(gHangupCall_CallID<7)        //Single call hangup
        {
            HangupPossible = check_hangup(gHangupCall_CallID);
            if(HangupPossible==1)          //only when call or emergency call is ring_waiting/dialing/active/hold
			{    
                gcallID = gHangupCall_CallID;
                setcallState(gHangupCall_CallID, disconnecting);
                sendCallStateStatus();
                settimer(disconnectingTimer, 1500);
            }
		    else
                writelineEx(gError_Trace, 0, "FSG-Telephone HangupCall-Error: 0x%x", HangupPossible);
        
		}
        else
        {
            switch(gHangupCall_CallID)
            { 
                case ALL_ACTIVE_CALLS:
                    for(i=0;i<7;i++)
                    {
					    if(gCallState[i]==active)
                        {    gcallID = i ; 
                             setcallState(i,disconnecting);
                             sendCallStateStatus();
                        }     
                    }
                break;
                case ALL_HELD_CALLS:
                    for(i=0;i<7;i++)
                    {
					    if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
                          {    gcallID = i ; 
                               setcallState(i,disconnecting);
                               sendCallStateStatus();
                          }
                    }
                break;
                case ALL_ACTIVE_AND_HELD_CALLS:
                    for(i=0;i<7;i++)
                    {
					    if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD || gCallState[i]==active)
                          {    gcallID = i ; 
                               setcallState(i,disconnecting);
                               sendCallStateStatus();
                          }
                    }
                break;
                case ALL_CALLS:
                    for(i=0;i<7;i++)
                    {
					    if(gCallState[i]!=idle)
                        {    gcallID = i ; 
                             setcallState(i,disconnecting);
                             sendCallStateStatus();
                        }
                    }
                break;
            }
            settimer(disconnectingTimer_Methods, 1500);
        }
	}
}

byte check_hangup (byte call_id)	//check, if in this call state hang up is possible (0=impossible, 1=possible)
{
byte hangup;

//init lokal variables
	hangup=0;
//********************


	switch(gCallState[call_id])
	{
				case ringing_waiting:
					hangup=TRUE;
				break;
				case active:
					hangup=TRUE;
				break;
				case dialing:
					hangup=TRUE;
				break;
				case onhold:
					hangup=TRUE;
				break;
        case INCOMING_ON_HOLD:
					hangup=TRUE;
				break;
				default:	//hangup is impossible in this state 
					hangup=0;
				break;
	}
			
	return(hangup);

}

on timer disconnectingTimer_Methods
{
  byte BAPTemp[994];
  byte emptyString[1];
  int i;
  
  for(i=0; i<7 ; i++)
  {
    if(gCallState[i]==disconnecting)
    {   gcallID = i;
        setcallState(gcallID,0); // set "idle " call state after "disconnecting" state -- Hang up Method
        call_options_disable (); // disable all call options
        sendCallStateStatus();
        
        cleancallINFO(gcallID);
        cleancallType(gcallID); 
    }
  }
}

on envVar env_FSG_AcceptCall
{
byte i, incomingcallID, acceptpossible;

//init lokal variables
	incomingcallID=0xff;
	acceptpossible=1;
//********************

	for(i=0;i<7;i++){
		if(gCallState[i]==active || gCallState[i]==disconnecting)
			acceptpossible=0;
	}

	if(@ON_OFF_FSG40_0 == 1 && acceptpossible==1)
  {
		for(i=0;i<7;i++)
    {															//check call-states for incoming call
			if(gCallState[i]==ringing_waiting)
				incomingcallID=i;
		}
	
		if(getvalue(this) && incomingcallID!=0xff)		//only when button ist pressed and one callID-callstate is "ringing/waiting"
		{
			setcallState(incomingcallID, active); 
      sendCallStateStatus();
		}
	}
}

on envVar env_FSG_CallHold
{
byte i, callID, callholdpossible;


//init lokal variables
	callID=0xff;
	callholdpossible=1;
//********************

	for(i=0;i<7;i++)
  {
		if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
			callholdpossible=0;
	}

	if(@ON_OFF_FSG40_0 == 1 && getvalue(this) && callholdpossible==1){
		for(i=0;i<7;i++)
    {																//searching for active calls
			if(gCallState[i]==active)
      {
				gcallID=i;
				setcallState(gcallID,onhold);											//set call state
			  sendCallStateStatus();
			}
		}
	}
}

on envVar env_FSG_CallResume
{
byte i, callID, callresumepossible;


//init lokal variables
	callID=0xff;
	callresumepossible=1;
//********************

	for(i=0;i<7;i++)
  {
		if(gCallState[i]==active || gCallState[i]==disconnecting || gCallState[i]==dialing || gCallState[i]==ringing_waiting)
			callresumepossible=0;
	}

	if(@ON_OFF_FSG40_0 == 1 && getvalue(this) && callresumepossible==1)
  {
		for(i=0;i<7;i++)
    {																//searching for active calls
  			if(gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD)
        {
  				callID=i;
  				setcallState(callID,active);												//set call state	
          sendCallStateStatus();
  	  	}
	  }
  }
}

// multiple call states handling

on timer MPswapTimer
 {
   byte i;
   int elementsJustSetToOnHold[7];
   byte j;
   
   for(j=0;j<7;j++)
   {
   elementsJustSetToOnHold[j] = 0;
   }

//init lokal variables
	gcallID=0xff;
//********************

	for(i=0;i<7;i++)
  {																//searching for active calls
      		if(gCallState[i]==active)
        {
      			gcallID=i;
      			setcallState(gcallID,onhold);											//set active call -> on hold
                elementsJustSetToOnHold[i] = onhold;
            sendCallStateStatus();
        }
      		
  }
  
  for(i=0;i<7;i++)
  {																//searching for active calls
      		if((gCallState[i]==onhold || gCallState[i]==INCOMING_ON_HOLD) && (elementsJustSetToOnHold[i] != onhold))
        {
      			gcallID=i;
      			setcallState(gcallID,active);											//set on Hold call -> Active
            sendCallStateStatus();
         }
  }
}


sendCallStateStatus()
{ byte BAPTemp[994];
  
        P_FSG_40_0_0_22_BuildFct();
        getValue(P_FSG_40_0_0_22, BAPTemp);
        Request_ByteSequence(LSGID, P_FSG_40_0_0_22_ID, Data_REQ, BAPTemp, getValueSize(P_FSG_40_0_0_22));
}

//emergency call handling

int tel_number_emergency (char tel_number [], byte length)
{

  int valid, i;

  //init lokal variables
	valid=0;
  //********************

	if ( strncmp(tel_number,"112",strlen(tel_number)) == 0 )
      valid = 1 ;
  
	if ( strncmp(tel_number,"911",strlen(tel_number)) == 0 )
      valid = 1 ;
 
  
  return valid;
}

on timer EmergencyCallTimer   // after 10 seconds of "do nothing" set eCallConfirmationPending = False 
{
      putvalue(P_FSG_40_0_0_22_23,0); // bit 7 = 0  -> eCallConfirmationPending = False 
      sendCallStateStatus();
}

void SetNameandNumber(int callID, char name[], char number[])
{
  int i,j,t,length_name=0,length_number=0;
  byte BAPTemp[994];
  char tempTelNR[40]; 
  char tempName[6];
 
  for(i=0;i<strlen(name);i++)
    gDialName_data[i] = name[i]; 
   
  
  for(i=0;i<strlen(number);i++)
  {  gDialTelNumber_data[i] = number[i]; 
    write("gDialTelNumber_data=%x",gDialTelNumber_data[i]);}
 
   if(callID == 0)
  {
  putvalue(P_FSG_40_0_0_23_2, gDialTelNumber_data,strlen(number)); //TelNumber0
  putvalue(P_FSG_40_0_0_23_1, gDialName_data,strlen(name)); //PbName0 
  }
    if(callID == 1)
  {
  putvalue(P_FSG_40_0_0_23_5, gDialTelNumber_data,strlen(number)); //TelNumber1
  putvalue(P_FSG_40_0_0_23_4, gDialName_data,strlen(name)); //PbName1 
  }
    if(callID == 2)
  {
  putvalue(P_FSG_40_0_0_23_8, gDialTelNumber_data,strlen(number)); //TelNumber2
  putvalue(P_FSG_40_0_0_23_7, gDialName_data,strlen(name)); //PbName2
  }
    if(callID == 3)
  {
  putvalue(P_FSG_40_0_0_23_11, gDialTelNumber_data,strlen(number)); //TelNumber3
  putvalue(P_FSG_40_0_0_23_10, gDialName_data,strlen(name)); //PbName3
  }
    if(callID == 4)
  {
  putvalue(P_FSG_40_0_0_23_14, gDialTelNumber_data,strlen(number)); //TelNumber4 
  putvalue(P_FSG_40_0_0_23_13, gDialName_data,strlen(name)); //PbName4
  }
    if(callID == 5)
  {
  putvalue(P_FSG_40_0_0_23_17, gDialTelNumber_data,strlen(number)); //TelNumber5
  putvalue(P_FSG_40_0_0_23_16, gDialName_data,strlen(name)); //PbName5
  }
    if(callID == 6)
  {
  putvalue(P_FSG_40_0_0_23_20, gDialTelNumber_data,strlen(number)); //TelNumber6
  putvalue(P_FSG_40_0_0_23_19, gDialName_data,strlen(name)); //PbName6
  }
  
   P_FSG_40_0_0_23_BuildFct();
   settimer(setcallInfo,1);
  
  
}

byte areAllActiveInConference()
{
    byte u8Index, u8Result = 1;
    
    for(u8Index=0;u8Index<7;u8Index++)
    {			
        if((gCallState[u8Index] != active 
            && gCallState[u8Index] != idle)
            || (gCallType[u8Index] != conferenceVoiceCall
            && gCallType[u8Index] != unknownCall))
        {
            u8Result = 0;
            break;
        }
    }
    
    return u8Result;
}

void setAllActiveInConferenceBits()
{
    byte u8Index;
    
    for(u8Index=0;u8Index<7;u8Index++)
    {			
        //check call-states for incoming call
            if(gCallState[u8Index] == active && gCallType[u8Index] == conferenceVoiceCall)
            {
                  switch (u8Index)
                  {
                    case 0: // Call 0
                            putValue(P_FSG_40_0_0_22_3,8);
                            break;
                    case 1: // Call 1
                            putValue(P_FSG_40_0_0_22_6,8);
                            break;
                    case 2: // Call 2
                            putValue(P_FSG_40_0_0_22_9,8);
                            break;
                    case 3: // Call 3
                            putValue(P_FSG_40_0_0_22_12,8);
                            break;
                    case 4: // Call 4
                            putValue(P_FSG_40_0_0_22_15,8);
                            break;
                    case 5: // Call 5
                            putValue(P_FSG_40_0_0_22_18,8);
                            break;
                    case 6: // Call 6
                            putValue(P_FSG_40_0_0_22_21,8);
                            break;
                  }
            }
    }
}

void call_options_disable ()
{
  switch (gcallID)
  {
    case 0: // Call 0
            putValue(P_FSG_40_0_0_22_3,0);
            break;
    case 1: // Call 1
            putValue(P_FSG_40_0_0_22_6,0);
            break;
    case 2: // Call 2
            putValue(P_FSG_40_0_0_22_9,0);
            break;
    case 3: // Call 3
            putValue(P_FSG_40_0_0_22_12,0);
            break;
    case 4: // Call 4
            putValue(P_FSG_40_0_0_22_15,0);
            break;
    case 5: // Call 5
            putValue(P_FSG_40_0_0_22_18,0);
            break;
    case 6: // Call 6
            putValue(P_FSG_40_0_0_22_21,0);
            break;
  }
}
